<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_capi.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="number_asformat.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_compact.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_capi.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 10,79 ***</span>
  #define UNISTR_FROM_STRING_EXPLICIT
  
  #include &quot;fphdlimp.h&quot;
  #include &quot;number_utypes.h&quot;
  #include &quot;numparse_types.h&quot;
  #include &quot;unicode/numberformatter.h&quot;
  #include &quot;unicode/unumberformatter.h&quot;
  
  using namespace icu;
  using namespace icu::number;
  using namespace icu::number::impl;
  
  
<span class="line-modified">! //////////////////////////////////</span>
<span class="line-modified">! /// C API CONVERSION FUNCTIONS ///</span>
<span class="line-modified">! //////////////////////////////////</span>
  
<span class="line-modified">! UNumberFormatterData* UNumberFormatterData::validate(UNumberFormatter* input, UErrorCode&amp; status) {</span>
<span class="line-modified">!     auto* constInput = static_cast&lt;const UNumberFormatter*&gt;(input);</span>
<span class="line-modified">!     auto* validated = validate(constInput, status);</span>
<span class="line-modified">!     return const_cast&lt;UNumberFormatterData*&gt;(validated);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! const UNumberFormatterData*</span>
<span class="line-modified">! UNumberFormatterData::validate(const UNumberFormatter* input, UErrorCode&amp; status) {</span>
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
<span class="line-modified">!         return nullptr;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (input == nullptr) {</span>
<span class="line-modified">!         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-modified">!         return nullptr;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     auto* impl = reinterpret_cast&lt;const UNumberFormatterData*&gt;(input);</span>
<span class="line-modified">!     if (impl-&gt;fMagic != UNumberFormatterData::kMagic) {</span>
<span class="line-modified">!         status = U_INVALID_FORMAT_ERROR;</span>
<span class="line-modified">!         return nullptr;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     return impl;</span>
  }
  
<span class="line-modified">! UNumberFormatter* UNumberFormatterData::exportForC() {</span>
<span class="line-modified">!     return reinterpret_cast&lt;UNumberFormatter*&gt;(this);</span>
  }
  
<span class="line-removed">- UFormattedNumberData* UFormattedNumberData::validate(UFormattedNumber* input, UErrorCode&amp; status) {</span>
<span class="line-removed">-     auto* constInput = static_cast&lt;const UFormattedNumber*&gt;(input);</span>
<span class="line-removed">-     auto* validated = validate(constInput, status);</span>
<span class="line-removed">-     return const_cast&lt;UFormattedNumberData*&gt;(validated);</span>
  }
  
<span class="line-modified">! const UFormattedNumberData*</span>
<span class="line-modified">! UFormattedNumberData::validate(const UFormattedNumber* input, UErrorCode&amp; status) {</span>
      if (U_FAILURE(status)) {
          return nullptr;
      }
<span class="line-modified">!     if (input == nullptr) {</span>
<span class="line-removed">-         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-removed">-         return nullptr;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     auto* impl = reinterpret_cast&lt;const UFormattedNumberData*&gt;(input);</span>
<span class="line-removed">-     if (impl-&gt;fMagic != UFormattedNumberData::kMagic) {</span>
<span class="line-removed">-         status = U_INVALID_FORMAT_ERROR;</span>
<span class="line-removed">-         return nullptr;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return impl;</span>
  }
  
<span class="line-removed">- UFormattedNumber* UFormattedNumberData::exportForC() {</span>
<span class="line-removed">-     return reinterpret_cast&lt;UFormattedNumber*&gt;(this);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- /////////////////////////////////////</span>
<span class="line-removed">- /// END CAPI CONVERSION FUNCTIONS ///</span>
<span class="line-removed">- /////////////////////////////////////</span>
  
  
  U_CAPI UNumberFormatter* U_EXPORT2
  unumf_openForSkeletonAndLocale(const UChar* skeleton, int32_t skeletonLen, const char* locale,
                                 UErrorCode* ec) {
<span class="line-new-header">--- 10,76 ---</span>
  #define UNISTR_FROM_STRING_EXPLICIT
  
  #include &quot;fphdlimp.h&quot;
  #include &quot;number_utypes.h&quot;
  #include &quot;numparse_types.h&quot;
<span class="line-added">+ #include &quot;formattedval_impl.h&quot;</span>
  #include &quot;unicode/numberformatter.h&quot;
  #include &quot;unicode/unumberformatter.h&quot;
  
  using namespace icu;
  using namespace icu::number;
  using namespace icu::number::impl;
  
  
<span class="line-modified">! U_NAMESPACE_BEGIN</span>
<span class="line-modified">! namespace number {</span>
<span class="line-modified">! namespace impl {</span>
  
<span class="line-modified">! /**</span>
<span class="line-modified">!  * Implementation class for UNumberFormatter. Wraps a LocalizedNumberFormatter.</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! struct UNumberFormatterData : public UMemory,</span>
<span class="line-modified">!         // Magic number as ASCII == &quot;NFR&quot; (NumberFormatteR)</span>
<span class="line-added">+         public IcuCApiHelper&lt;UNumberFormatter, UNumberFormatterData, 0x4E465200&gt; {</span>
<span class="line-added">+     LocalizedNumberFormatter fFormatter;</span>
<span class="line-added">+ };</span>
  
<span class="line-modified">! struct UFormattedNumberImpl;</span>
<span class="line-modified">! </span>
<span class="line-modified">! // Magic number as ASCII == &quot;FDN&quot; (FormatteDNumber)</span>
<span class="line-modified">! typedef IcuCApiHelper&lt;UFormattedNumber, UFormattedNumberImpl, 0x46444E00&gt; UFormattedNumberApiHelper;</span>
<span class="line-modified">! </span>
<span class="line-modified">! struct UFormattedNumberImpl : public UFormattedValueImpl, public UFormattedNumberApiHelper {</span>
<span class="line-modified">!     UFormattedNumberImpl();</span>
<span class="line-modified">!     ~UFormattedNumberImpl();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     FormattedNumber fImpl;</span>
<span class="line-modified">!     UFormattedNumberData fData;</span>
<span class="line-modified">! };</span>
<span class="line-modified">! </span>
<span class="line-modified">! UFormattedNumberImpl::UFormattedNumberImpl()</span>
<span class="line-modified">!         : fImpl(&amp;fData) {</span>
<span class="line-added">+     fFormattedValue = &amp;fImpl;</span>
  }
  
<span class="line-modified">! UFormattedNumberImpl::~UFormattedNumberImpl() {</span>
<span class="line-modified">!     // Disown the data from fImpl so it doesn&#39;t get deleted twice</span>
<span class="line-added">+     fImpl.fData = nullptr;</span>
  }
  
  }
<span class="line-added">+ }</span>
<span class="line-added">+ U_NAMESPACE_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ UPRV_FORMATTED_VALUE_CAPI_NO_IMPLTYPE_AUTO_IMPL(</span>
<span class="line-added">+     UFormattedNumber,</span>
<span class="line-added">+     UFormattedNumberImpl,</span>
<span class="line-added">+     UFormattedNumberApiHelper,</span>
<span class="line-added">+     unumf)</span>
<span class="line-added">+ </span>
  
<span class="line-modified">! const DecimalQuantity* icu::number::impl::validateUFormattedNumberToDecimalQuantity(</span>
<span class="line-modified">!         const UFormattedNumber* uresult, UErrorCode&amp; status) {</span>
<span class="line-added">+     auto* result = UFormattedNumberApiHelper::validate(uresult, status);</span>
      if (U_FAILURE(status)) {
          return nullptr;
      }
<span class="line-modified">!     return &amp;result-&gt;fData.quantity;</span>
  }
  
  
  
  U_CAPI UNumberFormatter* U_EXPORT2
  unumf_openForSkeletonAndLocale(const UChar* skeleton, int32_t skeletonLen, const char* locale,
                                 UErrorCode* ec) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,74 ***</span>
      UnicodeString skeletonString(skeletonLen == -1, skeleton, skeletonLen);
      impl-&gt;fFormatter = NumberFormatter::forSkeleton(skeletonString, *ec).locale(locale);
      return impl-&gt;exportForC();
  }
  
<span class="line-modified">! U_CAPI UFormattedNumber* U_EXPORT2</span>
<span class="line-modified">! unumf_openResult(UErrorCode* ec) {</span>
<span class="line-modified">!     auto* impl = new UFormattedNumberData();</span>
      if (impl == nullptr) {
          *ec = U_MEMORY_ALLOCATION_ERROR;
          return nullptr;
      }
      return impl-&gt;exportForC();
  }
  
  U_CAPI void U_EXPORT2
  unumf_formatInt(const UNumberFormatter* uformatter, int64_t value, UFormattedNumber* uresult,
                  UErrorCode* ec) {
      const UNumberFormatterData* formatter = UNumberFormatterData::validate(uformatter, *ec);
<span class="line-modified">!     UFormattedNumberData* result = UFormattedNumberData::validate(uresult, *ec);</span>
      if (U_FAILURE(*ec)) { return; }
  
<span class="line-modified">!     result-&gt;string.clear();</span>
<span class="line-modified">!     result-&gt;quantity.setToLong(value);</span>
<span class="line-modified">!     formatter-&gt;fFormatter.formatImpl(result, *ec);</span>
  }
  
  U_CAPI void U_EXPORT2
  unumf_formatDouble(const UNumberFormatter* uformatter, double value, UFormattedNumber* uresult,
                     UErrorCode* ec) {
      const UNumberFormatterData* formatter = UNumberFormatterData::validate(uformatter, *ec);
<span class="line-modified">!     UFormattedNumberData* result = UFormattedNumberData::validate(uresult, *ec);</span>
      if (U_FAILURE(*ec)) { return; }
  
<span class="line-modified">!     result-&gt;string.clear();</span>
<span class="line-modified">!     result-&gt;quantity.setToDouble(value);</span>
<span class="line-modified">!     formatter-&gt;fFormatter.formatImpl(result, *ec);</span>
  }
  
  U_CAPI void U_EXPORT2
  unumf_formatDecimal(const UNumberFormatter* uformatter, const char* value, int32_t valueLen,
                      UFormattedNumber* uresult, UErrorCode* ec) {
      const UNumberFormatterData* formatter = UNumberFormatterData::validate(uformatter, *ec);
<span class="line-modified">!     UFormattedNumberData* result = UFormattedNumberData::validate(uresult, *ec);</span>
      if (U_FAILURE(*ec)) { return; }
  
<span class="line-modified">!     result-&gt;string.clear();</span>
<span class="line-modified">!     result-&gt;quantity.setToDecNumber({value, valueLen}, *ec);</span>
      if (U_FAILURE(*ec)) { return; }
<span class="line-modified">!     formatter-&gt;fFormatter.formatImpl(result, *ec);</span>
  }
  
  U_CAPI int32_t U_EXPORT2
  unumf_resultToString(const UFormattedNumber* uresult, UChar* buffer, int32_t bufferCapacity,
                       UErrorCode* ec) {
<span class="line-modified">!     const UFormattedNumberData* result = UFormattedNumberData::validate(uresult, *ec);</span>
      if (U_FAILURE(*ec)) { return 0; }
  
      if (buffer == nullptr ? bufferCapacity != 0 : bufferCapacity &lt; 0) {
          *ec = U_ILLEGAL_ARGUMENT_ERROR;
          return 0;
      }
  
<span class="line-modified">!     return result-&gt;string.toTempUnicodeString().extract(buffer, bufferCapacity, *ec);</span>
  }
  
  U_CAPI UBool U_EXPORT2
  unumf_resultNextFieldPosition(const UFormattedNumber* uresult, UFieldPosition* ufpos, UErrorCode* ec) {
<span class="line-modified">!     const UFormattedNumberData* result = UFormattedNumberData::validate(uresult, *ec);</span>
      if (U_FAILURE(*ec)) { return FALSE; }
  
      if (ufpos == nullptr) {
          *ec = U_ILLEGAL_ARGUMENT_ERROR;
          return FALSE;
<span class="line-new-header">--- 92,78 ---</span>
      UnicodeString skeletonString(skeletonLen == -1, skeleton, skeletonLen);
      impl-&gt;fFormatter = NumberFormatter::forSkeleton(skeletonString, *ec).locale(locale);
      return impl-&gt;exportForC();
  }
  
<span class="line-modified">! U_CAPI UNumberFormatter* U_EXPORT2</span>
<span class="line-modified">! unumf_openForSkeletonAndLocaleWithError(const UChar* skeleton, int32_t skeletonLen, const char* locale,</span>
<span class="line-modified">!                                          UParseError* perror, UErrorCode* ec) {</span>
<span class="line-added">+     auto* impl = new UNumberFormatterData();</span>
      if (impl == nullptr) {
          *ec = U_MEMORY_ALLOCATION_ERROR;
          return nullptr;
      }
<span class="line-added">+     // Readonly-alias constructor (first argument is whether we are NUL-terminated)</span>
<span class="line-added">+     UnicodeString skeletonString(skeletonLen == -1, skeleton, skeletonLen);</span>
<span class="line-added">+     impl-&gt;fFormatter = NumberFormatter::forSkeleton(skeletonString, *perror, *ec).locale(locale);</span>
      return impl-&gt;exportForC();
  }
  
  U_CAPI void U_EXPORT2
  unumf_formatInt(const UNumberFormatter* uformatter, int64_t value, UFormattedNumber* uresult,
                  UErrorCode* ec) {
      const UNumberFormatterData* formatter = UNumberFormatterData::validate(uformatter, *ec);
<span class="line-modified">!     auto* result = UFormattedNumberApiHelper::validate(uresult, *ec);</span>
      if (U_FAILURE(*ec)) { return; }
  
<span class="line-modified">!     result-&gt;fData.getStringRef().clear();</span>
<span class="line-modified">!     result-&gt;fData.quantity.setToLong(value);</span>
<span class="line-modified">!     formatter-&gt;fFormatter.formatImpl(&amp;result-&gt;fData, *ec);</span>
  }
  
  U_CAPI void U_EXPORT2
  unumf_formatDouble(const UNumberFormatter* uformatter, double value, UFormattedNumber* uresult,
                     UErrorCode* ec) {
      const UNumberFormatterData* formatter = UNumberFormatterData::validate(uformatter, *ec);
<span class="line-modified">!     auto* result = UFormattedNumberApiHelper::validate(uresult, *ec);</span>
      if (U_FAILURE(*ec)) { return; }
  
<span class="line-modified">!     result-&gt;fData.getStringRef().clear();</span>
<span class="line-modified">!     result-&gt;fData.quantity.setToDouble(value);</span>
<span class="line-modified">!     formatter-&gt;fFormatter.formatImpl(&amp;result-&gt;fData, *ec);</span>
  }
  
  U_CAPI void U_EXPORT2
  unumf_formatDecimal(const UNumberFormatter* uformatter, const char* value, int32_t valueLen,
                      UFormattedNumber* uresult, UErrorCode* ec) {
      const UNumberFormatterData* formatter = UNumberFormatterData::validate(uformatter, *ec);
<span class="line-modified">!     auto* result = UFormattedNumberApiHelper::validate(uresult, *ec);</span>
      if (U_FAILURE(*ec)) { return; }
  
<span class="line-modified">!     result-&gt;fData.getStringRef().clear();</span>
<span class="line-modified">!     result-&gt;fData.quantity.setToDecNumber({value, valueLen}, *ec);</span>
      if (U_FAILURE(*ec)) { return; }
<span class="line-modified">!     formatter-&gt;fFormatter.formatImpl(&amp;result-&gt;fData, *ec);</span>
  }
  
  U_CAPI int32_t U_EXPORT2
  unumf_resultToString(const UFormattedNumber* uresult, UChar* buffer, int32_t bufferCapacity,
                       UErrorCode* ec) {
<span class="line-modified">!     const auto* result = UFormattedNumberApiHelper::validate(uresult, *ec);</span>
      if (U_FAILURE(*ec)) { return 0; }
  
      if (buffer == nullptr ? bufferCapacity != 0 : bufferCapacity &lt; 0) {
          *ec = U_ILLEGAL_ARGUMENT_ERROR;
          return 0;
      }
  
<span class="line-modified">!     return result-&gt;fImpl.toTempString(*ec).extract(buffer, bufferCapacity, *ec);</span>
  }
  
  U_CAPI UBool U_EXPORT2
  unumf_resultNextFieldPosition(const UFormattedNumber* uresult, UFieldPosition* ufpos, UErrorCode* ec) {
<span class="line-modified">!     const auto* result = UFormattedNumberApiHelper::validate(uresult, *ec);</span>
      if (U_FAILURE(*ec)) { return FALSE; }
  
      if (ufpos == nullptr) {
          *ec = U_ILLEGAL_ARGUMENT_ERROR;
          return FALSE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 170,38 ***</span>
  
      FieldPosition fp;
      fp.setField(ufpos-&gt;field);
      fp.setBeginIndex(ufpos-&gt;beginIndex);
      fp.setEndIndex(ufpos-&gt;endIndex);
<span class="line-modified">!     bool retval = result-&gt;string.nextFieldPosition(fp, *ec);</span>
      ufpos-&gt;beginIndex = fp.getBeginIndex();
      ufpos-&gt;endIndex = fp.getEndIndex();
      // NOTE: MSVC sometimes complains when implicitly converting between bool and UBool
      return retval ? TRUE : FALSE;
  }
  
  U_CAPI void U_EXPORT2
  unumf_resultGetAllFieldPositions(const UFormattedNumber* uresult, UFieldPositionIterator* ufpositer,
                                   UErrorCode* ec) {
<span class="line-modified">!     const UFormattedNumberData* result = UFormattedNumberData::validate(uresult, *ec);</span>
      if (U_FAILURE(*ec)) { return; }
  
      if (ufpositer == nullptr) {
          *ec = U_ILLEGAL_ARGUMENT_ERROR;
          return;
      }
  
      auto* fpi = reinterpret_cast&lt;FieldPositionIterator*&gt;(ufpositer);
<span class="line-modified">!     FieldPositionIteratorHandler fpih(fpi, *ec);</span>
<span class="line-removed">-     result-&gt;string.getAllFieldPositions(fpih, *ec);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- U_CAPI void U_EXPORT2</span>
<span class="line-removed">- unumf_closeResult(UFormattedNumber* uresult) {</span>
<span class="line-removed">-     UErrorCode localStatus = U_ZERO_ERROR;</span>
<span class="line-removed">-     const UFormattedNumberData* impl = UFormattedNumberData::validate(uresult, localStatus);</span>
<span class="line-removed">-     delete impl;</span>
  }
  
  U_CAPI void U_EXPORT2
  unumf_close(UNumberFormatter* f) {
      UErrorCode localStatus = U_ZERO_ERROR;
<span class="line-new-header">--- 171,30 ---</span>
  
      FieldPosition fp;
      fp.setField(ufpos-&gt;field);
      fp.setBeginIndex(ufpos-&gt;beginIndex);
      fp.setEndIndex(ufpos-&gt;endIndex);
<span class="line-modified">!     bool retval = result-&gt;fImpl.nextFieldPosition(fp, *ec);</span>
      ufpos-&gt;beginIndex = fp.getBeginIndex();
      ufpos-&gt;endIndex = fp.getEndIndex();
      // NOTE: MSVC sometimes complains when implicitly converting between bool and UBool
      return retval ? TRUE : FALSE;
  }
  
  U_CAPI void U_EXPORT2
  unumf_resultGetAllFieldPositions(const UFormattedNumber* uresult, UFieldPositionIterator* ufpositer,
                                   UErrorCode* ec) {
<span class="line-modified">!     const auto* result = UFormattedNumberApiHelper::validate(uresult, *ec);</span>
      if (U_FAILURE(*ec)) { return; }
  
      if (ufpositer == nullptr) {
          *ec = U_ILLEGAL_ARGUMENT_ERROR;
          return;
      }
  
      auto* fpi = reinterpret_cast&lt;FieldPositionIterator*&gt;(ufpositer);
<span class="line-modified">!     result-&gt;fImpl.getAllFieldPositions(*fpi, *ec);</span>
  }
  
  U_CAPI void U_EXPORT2
  unumf_close(UNumberFormatter* f) {
      UErrorCode localStatus = U_ZERO_ERROR;
</pre>
<center><a href="number_asformat.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_compact.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>