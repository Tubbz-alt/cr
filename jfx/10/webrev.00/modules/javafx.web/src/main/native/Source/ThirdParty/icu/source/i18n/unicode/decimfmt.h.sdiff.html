<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/decimfmt.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="dcfmtsym.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="dtitvfmt.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/decimfmt.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  46 U_NAMESPACE_BEGIN
  47 
  48 class CurrencyPluralInfo;
  49 class CompactDecimalFormat;
  50 
  51 namespace number {
  52 class LocalizedNumberFormatter;
  53 class FormattedNumber;
  54 namespace impl {
  55 class DecimalQuantity;
  56 struct DecimalFormatFields;
  57 }
  58 }
  59 
  60 namespace numparse {
  61 namespace impl {
  62 class NumberParserImpl;
  63 }
  64 }
  65 
<span class="line-removed">  66 // explicit template instantiation. see digitlst.h</span>
<span class="line-removed">  67 // (When building DLLs for Windows this is required.)</span>
<span class="line-removed">  68 #if U_PF_WINDOWS &lt;= U_PLATFORM &amp;&amp; U_PLATFORM &lt;= U_PF_CYGWIN</span>
<span class="line-removed">  69 template class U_I18N_API    EnumSet&lt;UNumberFormatAttribute,</span>
<span class="line-removed">  70             UNUM_MAX_NONBOOLEAN_ATTRIBUTE+1,</span>
<span class="line-removed">  71             UNUM_LIMIT_BOOLEAN_ATTRIBUTE&gt;;</span>
<span class="line-removed">  72 #endif</span>
<span class="line-removed">  73 </span>
  74 /**
<span class="line-modified">  75  * &lt;p&gt;&lt;strong&gt;IMPORTANT:&lt;/strong&gt; New users are strongly encouraged to see if</span>
  76  * numberformatter.h fits their use case.  Although not deprecated, this header
  77  * is provided for backwards compatibility only.
<span class="line-removed">  78  * &lt;hr/&gt;</span>
  79  *
  80  * DecimalFormat is a concrete subclass of NumberFormat that formats decimal
  81  * numbers. It has a variety of features designed to make it possible to parse
  82  * and format numbers in any locale, including support for Western, Arabic, or
  83  * Indic digits.  It also supports different flavors of numbers, including
  84  * integers (&quot;123&quot;), fixed-point numbers (&quot;123.4&quot;), scientific notation
  85  * (&quot;1.23E4&quot;), percentages (&quot;12%&quot;), and currency amounts (&quot;$123&quot;, &quot;USD123&quot;,
  86  * &quot;123 US dollars&quot;).  All of these flavors can be easily localized.
  87  *
<span class="line-modified">  88  * &lt;p&gt;To obtain a NumberFormat for a specific locale (including the default</span>
  89  * locale) call one of NumberFormat&#39;s factory methods such as
  90  * createInstance(). Do not call the DecimalFormat constructors directly, unless
  91  * you know what you are doing, since the NumberFormat factory methods may
  92  * return subclasses other than DecimalFormat.
  93  *
<span class="line-modified">  94  * &lt;p&gt;&lt;strong&gt;Example Usage&lt;/strong&gt;</span>
  95  *
  96  * \code
  97  *     // Normally we would have a GUI with a menu for this
  98  *     int32_t locCount;
  99  *     const Locale* locales = NumberFormat::getAvailableLocales(locCount);
 100  *
 101  *     double myNumber = -1234.56;
 102  *     UErrorCode success = U_ZERO_ERROR;
 103  *     NumberFormat* form;
 104  *
 105  *     // Print out a number with the localized number, currency and percent
 106  *     // format for each locale.
 107  *     UnicodeString countryName;
 108  *     UnicodeString displayName;
 109  *     UnicodeString str;
 110  *     UnicodeString pattern;
 111  *     Formattable fmtable;
 112  *     for (int32_t j = 0; j &lt; 3; ++j) {
 113  *         cout &lt;&lt; endl &lt;&lt; &quot;FORMAT &quot; &lt;&lt; j &lt;&lt; endl;
 114  *         for (int32_t i = 0; i &lt; locCount; ++i) {
</pre>
<hr />
<pre>
 118  *             }
 119  *             switch (j) {
 120  *             case 0:
 121  *                 form = NumberFormat::createInstance(locales[i], success ); break;
 122  *             case 1:
 123  *                 form = NumberFormat::createCurrencyInstance(locales[i], success ); break;
 124  *             default:
 125  *                 form = NumberFormat::createPercentInstance(locales[i], success ); break;
 126  *             }
 127  *             if (form) {
 128  *                 str.remove();
 129  *                 pattern = ((DecimalFormat*)form)-&gt;toPattern(pattern);
 130  *                 cout &lt;&lt; locales[i].getDisplayName(displayName) &lt;&lt; &quot;: &quot; &lt;&lt; pattern;
 131  *                 cout &lt;&lt; &quot;  -&gt;  &quot; &lt;&lt; form-&gt;format(myNumber,str) &lt;&lt; endl;
 132  *                 form-&gt;parse(form-&gt;format(myNumber,str), fmtable, success);
 133  *                 delete form;
 134  *             }
 135  *         }
 136  *     }
 137  * \endcode
<span class="line-modified"> 138  * &lt;P&gt;</span>
<span class="line-modified"> 139  * Another example use createInstance(style)</span>
<span class="line-modified"> 140  * &lt;P&gt;</span>
<span class="line-modified"> 141  * &lt;pre&gt;</span>
<span class="line-modified"> 142  * &lt;strong&gt;// Print out a number using the localized number, currency,</span>
 143  * // percent, scientific, integer, iso currency, and plural currency
 144  * // format for each locale&lt;/strong&gt;
 145  * Locale* locale = new Locale(&quot;en&quot;, &quot;US&quot;);
 146  * double myNumber = 1234.56;
 147  * UErrorCode success = U_ZERO_ERROR;
 148  * UnicodeString str;
 149  * Formattable fmtable;
 150  * for (int j=NumberFormat::kNumberStyle;
 151  *      j&lt;=NumberFormat::kPluralCurrencyStyle;
 152  *      ++j) {
<span class="line-modified"> 153  *     NumberFormat* format = NumberFormat::createInstance(locale, j, success);</span>
 154  *     str.remove();
 155  *     cout &lt;&lt; &quot;format result &quot; &lt;&lt; form-&gt;format(myNumber, str) &lt;&lt; endl;
 156  *     format-&gt;parse(form-&gt;format(myNumber, str), fmtable, success);
<span class="line-modified"> 157  * }&lt;/pre&gt;</span>


 158  *
 159  *
 160  * &lt;p&gt;&lt;strong&gt;Patterns&lt;/strong&gt;
 161  *
 162  * &lt;p&gt;A DecimalFormat consists of a &lt;em&gt;pattern&lt;/em&gt; and a set of
 163  * &lt;em&gt;symbols&lt;/em&gt;.  The pattern may be set directly using
 164  * applyPattern(), or indirectly using other API methods which
 165  * manipulate aspects of the pattern, such as the minimum number of integer
 166  * digits.  The symbols are stored in a DecimalFormatSymbols
 167  * object.  When using the NumberFormat factory methods, the
 168  * pattern and symbols are read from ICU&#39;s locale data.
 169  *
 170  * &lt;p&gt;&lt;strong&gt;Special Pattern Characters&lt;/strong&gt;
 171  *
 172  * &lt;p&gt;Many characters in a pattern are taken literally; they are matched during
 173  * parsing and output unchanged during formatting.  Special characters, on the
 174  * other hand, stand for other characters, strings, or classes of characters.
 175  * For example, the &#39;#&#39; character is replaced by a localized digit.  Often the
 176  * replacement character is the same as the pattern character; in the U.S. locale,
 177  * the &#39;,&#39; grouping character is replaced by &#39;,&#39;.  However, the replacement is
</pre>
<hr />
<pre>
 266  *         doubled, replaced by international currency symbol.
 267  *         If tripled, replaced by currency plural names, for example,
 268  *         &quot;US dollar&quot; or &quot;US dollars&quot; for America.
 269  *         If present in a pattern, the monetary decimal separator
 270  *         is used instead of the decimal separator.
 271  *   &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
 272  *     &lt;td&gt;&lt;code&gt;&#39;&lt;/code&gt;
 273  *     &lt;td&gt;Prefix or suffix
 274  *     &lt;td&gt;No
 275  *     &lt;td&gt;Used to quote special characters in a prefix or suffix,
 276  *         for example, &lt;code&gt;&quot;&#39;#&#39;#&quot;&lt;/code&gt; formats 123 to
 277  *         &lt;code&gt;&quot;#123&quot;&lt;/code&gt;.  To create a single quote
 278  *         itself, use two in a row: &lt;code&gt;&quot;# o&#39;&#39;clock&quot;&lt;/code&gt;.
 279  *   &lt;tr valign=top&gt;
 280  *     &lt;td&gt;&lt;code&gt;*&lt;/code&gt;
 281  *     &lt;td&gt;Prefix or suffix boundary
 282  *     &lt;td&gt;Yes
 283  *     &lt;td&gt;Pad escape, precedes pad character
 284  * &lt;/table&gt;
 285  *
<span class="line-modified"> 286  * &lt;p&gt;A DecimalFormat pattern contains a postive and negative</span>
 287  * subpattern, for example, &quot;#,##0.00;(#,##0.00)&quot;.  Each subpattern has a
 288  * prefix, a numeric part, and a suffix.  If there is no explicit negative
 289  * subpattern, the negative subpattern is the localized minus sign prefixed to the
 290  * positive subpattern. That is, &quot;0.00&quot; alone is equivalent to &quot;0.00;-0.00&quot;.  If there
 291  * is an explicit negative subpattern, it serves only to specify the negative
 292  * prefix and suffix; the number of digits, minimal digits, and other
 293  * characteristics are ignored in the negative subpattern. That means that
 294  * &quot;#,##0.0#;(#)&quot; has precisely the same result as &quot;#,##0.0#;(#,##0.0#)&quot;.
 295  *
 296  * &lt;p&gt;The prefixes, suffixes, and various symbols used for infinity, digits,
 297  * thousands separators, decimal separators, etc. may be set to arbitrary
 298  * values, and they will appear properly during formatting.  However, care must
 299  * be taken that the symbols and strings do not conflict, or parsing will be
 300  * unreliable.  For example, either the positive and negative prefixes or the
 301  * suffixes must be distinct for parse() to be able
 302  * to distinguish positive from negative values.  Another example is that the
 303  * decimal separator and thousands separator should be distinct characters, or
 304  * parsing will be impossible.
 305  *
 306  * &lt;p&gt;The &lt;em&gt;grouping separator&lt;/em&gt; is a character that separates clusters of
</pre>
<hr />
<pre>
 401  * notation&lt;/a&gt; or &lt;a href=&quot;#sigdig&quot;&gt;significant digits&lt;/a&gt;.
 402  *
 403  * &lt;ul&gt;&lt;li&gt;If the number of actual integer digits exceeds the
 404  * &lt;em&gt;maximum integer digits&lt;/em&gt;, then only the least significant
 405  * digits are shown.  For example, 1997 is formatted as &quot;97&quot; if the
 406  * maximum integer digits is set to 2.
 407  *
 408  * &lt;li&gt;If the number of actual integer digits is less than the
 409  * &lt;em&gt;minimum integer digits&lt;/em&gt;, then leading zeros are added.  For
 410  * example, 1997 is formatted as &quot;01997&quot; if the minimum integer digits
 411  * is set to 5.
 412  *
 413  * &lt;li&gt;If the number of actual fraction digits exceeds the &lt;em&gt;maximum
 414  * fraction digits&lt;/em&gt;, then rounding is performed to the
 415  * maximum fraction digits.  For example, 0.125 is formatted as &quot;0.12&quot;
 416  * if the maximum fraction digits is 2.  This behavior can be changed
 417  * by specifying a rounding increment and/or a rounding mode.
 418  *
 419  * &lt;li&gt;If the number of actual fraction digits is less than the
 420  * &lt;em&gt;minimum fraction digits&lt;/em&gt;, then trailing zeros are added.
<span class="line-modified"> 421  * For example, 0.125 is formatted as &quot;0.1250&quot; if the mimimum fraction</span>
 422  * digits is set to 4.
 423  *
 424  * &lt;li&gt;Trailing fractional zeros are not displayed if they occur
 425  * &lt;em&gt;j&lt;/em&gt; positions after the decimal, where &lt;em&gt;j&lt;/em&gt; is less
 426  * than the maximum fraction digits. For example, 0.10004 is
 427  * formatted as &quot;0.1&quot; if the maximum fraction digits is four or less.
 428  * &lt;/ul&gt;
 429  *
 430  * &lt;p&gt;&lt;strong&gt;Special Values&lt;/strong&gt;
 431  *
 432  * &lt;p&gt;&lt;code&gt;NaN&lt;/code&gt; is represented as a single character, typically
 433  * &lt;code&gt;\\uFFFD&lt;/code&gt;.  This character is determined by the
 434  * DecimalFormatSymbols object.  This is the only value for which
 435  * the prefixes and suffixes are not used.
 436  *
 437  * &lt;p&gt;Infinity is represented as a single character, typically
 438  * &lt;code&gt;\\u221E&lt;/code&gt;, with the positive or negative prefixes and suffixes
 439  * applied.  The infinity character is determined by the
 440  * DecimalFormatSymbols object.
 441  *
</pre>
<hr />
<pre>
 566  * &lt;code&gt;&quot;#,#@#&quot;&lt;/code&gt; indicates a minimum of one significant digits,
 567  * a maximum of two significant digits, and a grouping size of three.
 568  *
 569  * &lt;li&gt;In order to enable significant digits formatting, use a pattern
 570  * containing the &lt;code&gt;&#39;@&#39;&lt;/code&gt; pattern character.  Alternatively,
 571  * call setSignificantDigitsUsed(TRUE).
 572  *
 573  * &lt;li&gt;In order to disable significant digits formatting, use a
 574  * pattern that does not contain the &lt;code&gt;&#39;@&#39;&lt;/code&gt; pattern
 575  * character. Alternatively, call setSignificantDigitsUsed(FALSE).
 576  *
 577  * &lt;li&gt;The number of significant digits has no effect on parsing.
 578  *
 579  * &lt;li&gt;Significant digits may be used together with exponential notation. Such
 580  * patterns are equivalent to a normal exponential pattern with a minimum and
 581  * maximum integer digit count of one, a minimum fraction digit count of
 582  * &lt;code&gt;getMinimumSignificantDigits() - 1&lt;/code&gt;, and a maximum fraction digit
 583  * count of &lt;code&gt;getMaximumSignificantDigits() - 1&lt;/code&gt;. For example, the
 584  * pattern &lt;code&gt;&quot;@@###E0&quot;&lt;/code&gt; is equivalent to &lt;code&gt;&quot;0.0###E0&quot;&lt;/code&gt;.
 585  *
<span class="line-modified"> 586  * &lt;li&gt;If signficant digits are in use, then the integer and fraction</span>
 587  * digit counts, as set via the API, are ignored.  If significant
<span class="line-modified"> 588  * digits are not in use, then the signficant digit counts, as set via</span>
 589  * the API, are ignored.
 590  *
 591  * &lt;/ul&gt;
 592  *
 593  * &lt;p&gt;&lt;strong&gt;Padding&lt;/strong&gt;
 594  *
 595  * &lt;p&gt;DecimalFormat supports padding the result of
 596  * format() to a specific width.  Padding may be specified either
 597  * through the API or through the pattern syntax.  In a pattern the pad escape
 598  * character, followed by a single pad character, causes padding to be parsed
 599  * and formatted.  The pad escape character is &#39;*&#39; in unlocalized patterns, and
 600  * can be localized using DecimalFormatSymbols::setSymbol() with a
 601  * DecimalFormatSymbols::kPadEscapeSymbol
 602  * selector.  For example, &lt;code&gt;&quot;$*x#,##0.00&quot;&lt;/code&gt; formats 123 to
 603  * &lt;code&gt;&quot;$xx123.00&quot;&lt;/code&gt;, and 1234 to &lt;code&gt;&quot;$1,234.00&quot;&lt;/code&gt;.
 604  *
 605  * &lt;ul&gt;
 606  * &lt;li&gt;When padding is in effect, the width of the positive subpattern,
 607  * including prefix and suffix, determines the format width.  For example, in
 608  * the pattern &lt;code&gt;&quot;* #0 o&#39;&#39;clock&quot;&lt;/code&gt;, the format width is 10.
</pre>
<hr />
<pre>
 622  * before the prefix and after the prefix are equivalent, likewise for the
 623  * suffix.
 624  *
 625  * &lt;li&gt;When specified in a pattern, the 32-bit code point immediately
 626  * following the pad escape is the pad character. This may be any character,
 627  * including a special pattern character. That is, the pad escape
 628  * &lt;em&gt;escapes&lt;/em&gt; the following character. If there is no character after
 629  * the pad escape, then the pattern is illegal.
 630  *
 631  * &lt;/ul&gt;
 632  *
 633  * &lt;p&gt;&lt;strong&gt;Rounding&lt;/strong&gt;
 634  *
 635  * &lt;p&gt;DecimalFormat supports rounding to a specific increment.  For
 636  * example, 1230 rounded to the nearest 50 is 1250.  1.234 rounded to the
 637  * nearest 0.65 is 1.3.  The rounding increment may be specified through the API
 638  * or in a pattern.  To specify a rounding increment in a pattern, include the
 639  * increment in the pattern itself.  &quot;#,#50&quot; specifies a rounding increment of
 640  * 50.  &quot;#,##0.05&quot; specifies a rounding increment of 0.05.
 641  *
<span class="line-modified"> 642  * &lt;p&gt;In the absense of an explicit rounding increment numbers are</span>
 643  * rounded to their formatted width.
 644  *
 645  * &lt;ul&gt;
 646  * &lt;li&gt;Rounding only affects the string produced by formatting.  It does
 647  * not affect parsing or change any numerical values.
 648  *
 649  * &lt;li&gt;A &lt;em&gt;rounding mode&lt;/em&gt; determines how values are rounded; see
 650  * DecimalFormat::ERoundingMode.  The default rounding mode is
 651  * DecimalFormat::kRoundHalfEven.  The rounding mode can only be set
 652  * through the API; it can not be set with a pattern.
 653  *
 654  * &lt;li&gt;Some locales use rounding in their currency formats to reflect the
 655  * smallest currency denomination.
 656  *
 657  * &lt;li&gt;In a pattern, digits &#39;1&#39; through &#39;9&#39; specify rounding, but otherwise
 658  * behave identically to digit &#39;0&#39;.
 659  * &lt;/ul&gt;
 660  *
 661  * &lt;p&gt;&lt;strong&gt;Synchronization&lt;/strong&gt;
 662  *
</pre>
<hr />
<pre>
 673   public:
 674     /**
 675      * Pad position.
 676      * @stable ICU 2.4
 677      */
 678     enum EPadPosition {
 679         kPadBeforePrefix, kPadAfterPrefix, kPadBeforeSuffix, kPadAfterSuffix
 680     };
 681 
 682     /**
 683      * Create a DecimalFormat using the default pattern and symbols
 684      * for the default locale. This is a convenient way to obtain a
 685      * DecimalFormat when internationalization is not the main concern.
 686      * &lt;P&gt;
 687      * To obtain standard formats for a given locale, use the factory methods
 688      * on NumberFormat such as createInstance. These factories will
 689      * return the most appropriate sub-class of NumberFormat for a given
 690      * locale.
 691      * &lt;p&gt;
 692      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified"> 693      * {@link NumberFormatter} instead of DecimalFormat.</span>
 694      * @param status    Output param set to success/failure code. If the
 695      *                  pattern is invalid this will be set to a failure code.
 696      * @stable ICU 2.0
 697      */
 698     DecimalFormat(UErrorCode&amp; status);
 699 
 700     /**
 701      * Create a DecimalFormat from the given pattern and the symbols
 702      * for the default locale. This is a convenient way to obtain a
 703      * DecimalFormat when internationalization is not the main concern.
 704      * &lt;P&gt;
 705      * To obtain standard formats for a given locale, use the factory methods
 706      * on NumberFormat such as createInstance. These factories will
 707      * return the most appropriate sub-class of NumberFormat for a given
 708      * locale.
 709      * &lt;p&gt;
 710      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified"> 711      * {@link NumberFormatter} instead of DecimalFormat.</span>
 712      * @param pattern   A non-localized pattern string.
 713      * @param status    Output param set to success/failure code. If the
 714      *                  pattern is invalid this will be set to a failure code.
 715      * @stable ICU 2.0
 716      */
 717     DecimalFormat(const UnicodeString&amp; pattern, UErrorCode&amp; status);
 718 
 719     /**
 720      * Create a DecimalFormat from the given pattern and symbols.
 721      * Use this constructor when you need to completely customize the
 722      * behavior of the format.
 723      * &lt;P&gt;
 724      * To obtain standard formats for a given
 725      * locale, use the factory methods on NumberFormat such as
 726      * createInstance or createCurrencyInstance. If you need only minor adjustments
 727      * to a standard format, you can modify the format returned by
 728      * a NumberFormat factory method.
 729      * &lt;p&gt;
 730      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified"> 731      * {@link NumberFormatter} instead of DecimalFormat.</span>
 732      *
 733      * @param pattern           a non-localized pattern string
 734      * @param symbolsToAdopt    the set of symbols to be used.  The caller should not
 735      *                          delete this object after making this call.
 736      * @param status            Output param set to success/failure code. If the
 737      *                          pattern is invalid this will be set to a failure code.
 738      * @stable ICU 2.0
 739      */
 740     DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt, UErrorCode&amp; status);
 741 
 742 #ifndef U_HIDE_INTERNAL_API
 743 
 744     /**
 745      * This API is for ICU use only.
 746      * Create a DecimalFormat from the given pattern, symbols, and style.
 747      *
 748      * @param pattern           a non-localized pattern string
 749      * @param symbolsToAdopt    the set of symbols to be used.  The caller should not
 750      *                          delete this object after making this call.
 751      * @param style             style of decimal format
</pre>
<hr />
<pre>
 765 
 766 #endif
 767 
 768 #endif  /* U_HIDE_INTERNAL_API */
 769 
 770   private:
 771 
 772     /**
 773      * Internal constructor for DecimalFormat; sets up internal fields. All public constructors should
 774      * call this constructor.
 775      */
 776     DecimalFormat(const DecimalFormatSymbols* symbolsToAdopt, UErrorCode&amp; status);
 777 
 778   public:
 779 
 780     /**
 781      * Set an integer attribute on this DecimalFormat.
 782      * May return U_UNSUPPORTED_ERROR if this instance does not support
 783      * the specified attribute.
 784      * @param attr the attribute to set
<span class="line-modified"> 785      * @param newvalue new value</span>
 786      * @param status the error type
 787      * @return *this - for chaining (example: format.setAttribute(...).setAttribute(...) )
 788      * @stable ICU 51
 789      */
 790     virtual DecimalFormat&amp; setAttribute(UNumberFormatAttribute attr, int32_t newValue, UErrorCode&amp; status);
 791 
 792     /**
 793      * Get an integer
 794      * May return U_UNSUPPORTED_ERROR if this instance does not support
 795      * the specified attribute.
 796      * @param attr the attribute to set
 797      * @param status the error type
 798      * @return the attribute value. Undefined if there is an error.
 799      * @stable ICU 51
 800      */
 801     virtual int32_t getAttribute(UNumberFormatAttribute attr, UErrorCode&amp; status) const;
 802 
 803 
 804     /**
 805      * Set whether or not grouping will be used in this format.
</pre>
<hr />
<pre>
 822      * Sets whether lenient parsing should be enabled (it is off by default).
 823      *
 824      * @param enable \c TRUE if lenient parsing should be used,
 825      *               \c FALSE otherwise.
 826      * @stable ICU 4.8
 827      */
 828     void setLenient(UBool enable) U_OVERRIDE;
 829 
 830     /**
 831      * Create a DecimalFormat from the given pattern and symbols.
 832      * Use this constructor when you need to completely customize the
 833      * behavior of the format.
 834      * &lt;P&gt;
 835      * To obtain standard formats for a given
 836      * locale, use the factory methods on NumberFormat such as
 837      * createInstance or createCurrencyInstance. If you need only minor adjustments
 838      * to a standard format, you can modify the format returned by
 839      * a NumberFormat factory method.
 840      * &lt;p&gt;
 841      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified"> 842      * {@link NumberFormatter} instead of DecimalFormat.</span>
 843      *
 844      * @param pattern           a non-localized pattern string
 845      * @param symbolsToAdopt    the set of symbols to be used.  The caller should not
 846      *                          delete this object after making this call.
<span class="line-modified"> 847      * @param parseError        Output param to receive errors occured during parsing</span>
 848      * @param status            Output param set to success/failure code. If the
 849      *                          pattern is invalid this will be set to a failure code.
 850      * @stable ICU 2.0
 851      */
 852     DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
 853                   UParseError&amp; parseError, UErrorCode&amp; status);
 854 
 855     /**
 856      * Create a DecimalFormat from the given pattern and symbols.
 857      * Use this constructor when you need to completely customize the
 858      * behavior of the format.
 859      * &lt;P&gt;
 860      * To obtain standard formats for a given
 861      * locale, use the factory methods on NumberFormat such as
 862      * createInstance or createCurrencyInstance. If you need only minor adjustments
 863      * to a standard format, you can modify the format returned by
 864      * a NumberFormat factory method.
 865      * &lt;p&gt;
 866      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified"> 867      * {@link NumberFormatter} instead of DecimalFormat.</span>
 868      *
 869      * @param pattern           a non-localized pattern string
 870      * @param symbols   the set of symbols to be used
 871      * @param status            Output param set to success/failure code. If the
 872      *                          pattern is invalid this will be set to a failure code.
 873      * @stable ICU 2.0
 874      */
 875     DecimalFormat(const UnicodeString&amp; pattern, const DecimalFormatSymbols&amp; symbols, UErrorCode&amp; status);
 876 
 877     /**
 878      * Copy constructor.
 879      *
 880      * @param source    the DecimalFormat object to be copied from.
 881      * @stable ICU 2.0
 882      */
 883     DecimalFormat(const DecimalFormat&amp; source);
 884 
 885     /**
 886      * Assignment operator.
 887      *
</pre>
<hr />
<pre>
 969      *
 970      * @param number    The value to be formatted.
 971      * @param appendTo  Output parameter to receive result.
 972      *                  Result is appended to existing contents.
 973      * @param pos       On input: an alignment field, if desired.
 974      *                  On output: the offsets of the alignment field.
 975      * @return          Reference to &#39;appendTo&#39; parameter.
 976      * @stable ICU 2.0
 977      */
 978     UnicodeString&amp; format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const U_OVERRIDE;
 979 
 980 #ifndef U_HIDE_INTERNAL_API
 981     /**
 982      * Format a long number using base-10 representation.
 983      *
 984      * @param number    The value to be formatted.
 985      * @param appendTo  Output parameter to receive result.
 986      *                  Result is appended to existing contents.
 987      * @param pos       On input: an alignment field, if desired.
 988      *                  On output: the offsets of the alignment field.

 989      * @return          Reference to &#39;appendTo&#39; parameter.
 990      * @internal
 991      */
 992     UnicodeString&amp; format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 993                           UErrorCode&amp; status) const U_OVERRIDE;
 994 #endif  /* U_HIDE_INTERNAL_API */
 995 
 996     /**
 997      * Format a long number using base-10 representation.
 998      *
 999      * @param number    The value to be formatted.
1000      * @param appendTo  Output parameter to receive result.
1001      *                  Result is appended to existing contents.
1002      * @param posIter   On return, can be used to iterate over positions
1003      *                  of fields generated by this format call.
1004      *                  Can be NULL.
1005      * @param status    Output param filled with success/failure status.
1006      * @return          Reference to &#39;appendTo&#39; parameter.
1007      * @stable ICU 4.4
1008      */
</pre>
<hr />
<pre>
1014      *
1015      * @param number    The value to be formatted.
1016      * @param appendTo  Output parameter to receive result.
1017      *                  Result is appended to existing contents.
1018      * @param pos       On input: an alignment field, if desired.
1019      *                  On output: the offsets of the alignment field.
1020      * @return          Reference to &#39;appendTo&#39; parameter.
1021      * @stable ICU 2.8
1022      */
1023     UnicodeString&amp; format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const U_OVERRIDE;
1024 
1025 #ifndef U_HIDE_INTERNAL_API
1026     /**
1027      * Format an int64 number using base-10 representation.
1028      *
1029      * @param number    The value to be formatted.
1030      * @param appendTo  Output parameter to receive result.
1031      *                  Result is appended to existing contents.
1032      * @param pos       On input: an alignment field, if desired.
1033      *                  On output: the offsets of the alignment field.

1034      * @return          Reference to &#39;appendTo&#39; parameter.
1035      * @internal
1036      */
1037     UnicodeString&amp; format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
1038                           UErrorCode&amp; status) const U_OVERRIDE;
1039 #endif  /* U_HIDE_INTERNAL_API */
1040 
1041     /**
1042      * Format an int64 number using base-10 representation.
1043      *
1044      * @param number    The value to be formatted.
1045      * @param appendTo  Output parameter to receive result.
1046      *                  Result is appended to existing contents.
1047      * @param posIter   On return, can be used to iterate over positions
1048      *                  of fields generated by this format call.
1049      *                  Can be NULL.
1050      * @param status    Output param filled with success/failure status.
1051      * @return          Reference to &#39;appendTo&#39; parameter.
1052      * @stable ICU 4.4
1053      */
</pre>
<hr />
<pre>
1103      * @param appendTo  Output parameter to receive result.
1104      *                  Result is appended to existing contents.
1105      * @param pos       On input: an alignment field, if desired.
1106      *                  On output: the offsets of the alignment field.
1107      * @param status    Output param filled with success/failure status.
1108      * @return          Reference to &#39;appendTo&#39; parameter.
1109      * @internal
1110      */
1111     UnicodeString&amp; format(const number::impl::DecimalQuantity&amp; number, UnicodeString&amp; appendTo,
1112                           FieldPosition&amp; pos, UErrorCode&amp; status) const U_OVERRIDE;
1113 
1114 #endif // U_HIDE_INTERNAL_API
1115 
1116     using NumberFormat::parse;
1117 
1118     /**
1119      * Parse the given string using this object&#39;s choices. The method
1120      * does string comparisons to try to find an optimal match.
1121      * If no object can be parsed, index is unchanged, and NULL is
1122      * returned.  The result is returned as the most parsimonious
<span class="line-modified">1123      * type of Formattable that will accomodate all of the</span>
1124      * necessary precision.  For example, if the result is exactly 12,
1125      * it will be returned as a long.  However, if it is 1.5, it will
1126      * be returned as a double.
1127      *
1128      * @param text           The text to be parsed.
1129      * @param result         Formattable to be set to the parse result.
1130      *                       If parse fails, return contents are undefined.
1131      * @param parsePosition  The position to start parsing at on input.
1132      *                       On output, moved to after the last successfully
1133      *                       parse character. On parse failure, does not change.
1134      * @see Formattable
1135      * @stable ICU 2.0
1136      */
1137     void parse(const UnicodeString&amp; text, Formattable&amp; result,
1138                ParsePosition&amp; parsePosition) const U_OVERRIDE;
1139 
1140     /**
1141      * Parses text from the given string as a currency amount.  Unlike
1142      * the parse() method, this method will attempt to parse a generic
1143      * currency name, searching for a match of this object&#39;s locale&#39;s
</pre>
<hr />
<pre>
1268 
1269     /**
1270      * Get the negative suffix.
1271      *
1272      * @param result    Output param which will receive the negative suffix.
1273      * @return          A reference to &#39;result&#39;.
1274      * Examples: -123%, ($123) (with positive suffixes)
1275      * @stable ICU 2.0
1276      */
1277     UnicodeString&amp; getNegativeSuffix(UnicodeString&amp; result) const;
1278 
1279     /**
1280      * Set the negative suffix.
1281      *
1282      * @param newValue    the new value of the negative suffix to be set.
1283      * Examples: 123%
1284      * @stable ICU 2.0
1285      */
1286     virtual void setNegativeSuffix(const UnicodeString&amp; newValue);
1287 
<span class="line-modified">1288 #ifndef U_HIDE_INTERNAL_API</span>
1289     /**
1290      * Whether to show the plus sign on positive (non-negative) numbers; for example, &quot;+12&quot;
<span class="line-modified">1291      * @internal Technical Preview</span>




1292      */
1293     UBool isSignAlwaysShown() const;
<span class="line-removed">1294 #endif  /* U_HIDE_INTERNAL_API */</span>
1295 
1296     /**
<span class="line-modified">1297      * Set whether to show the plus sign on positive (non-negative) numbers; for example, &quot;+12&quot;</span>
<span class="line-modified">1298      * @param value The new setting for whether to show plus sign on positive numbers</span>
<span class="line-modified">1299      * @internal Technical Preview</span>



1300      */
<span class="line-modified">1301     virtual void setSignAlwaysShown(UBool value);</span>

1302 
1303     /**
1304      * Get the multiplier for use in percent, permill, etc.
1305      * For a percentage, set the suffixes to have &quot;%&quot; and the multiplier to be 100.
1306      * (For Arabic, use arabic percent symbol).
1307      * For a permill, set the suffixes to have &quot;\\u2031&quot; and the multiplier to be 1000.
1308      *
1309      * The number may also be multiplied by a power of ten; see getMultiplierScale().
1310      *
1311      * @return    the multiplier for use in percent, permill, etc.
1312      * Examples: with 100, 1.23 -&gt; &quot;123&quot;, and &quot;123&quot; -&gt; 1.23
1313      * @stable ICU 2.0
1314      */
1315     int32_t getMultiplier(void) const;
1316 
1317     /**
1318      * Set the multiplier for use in percent, permill, etc.
1319      * For a percentage, set the suffixes to have &quot;%&quot; and the multiplier to be 100.
1320      * (For Arabic, use arabic percent symbol).
1321      * For a permill, set the suffixes to have &quot;\\u2031&quot; and the multiplier to be 1000.
</pre>
<hr />
<pre>
1326      * @param newValue    the new value of the multiplier for use in percent, permill, etc.
1327      * Examples: with 100, 1.23 -&gt; &quot;123&quot;, and &quot;123&quot; -&gt; 1.23
1328      * @stable ICU 2.0
1329      */
1330     virtual void setMultiplier(int32_t newValue);
1331 
1332 #ifndef U_HIDE_DRAFT_API
1333     /**
1334      * Gets the power of ten by which number should be multiplied before formatting, which
1335      * can be combined with setMultiplier() to multiply by any arbitrary decimal value.
1336      *
1337      * A multiplier scale of 2 corresponds to multiplication by 100, and a multiplier scale
1338      * of -2 corresponds to multiplication by 0.01.
1339      *
1340      * This method is analogous to UNUM_SCALE in getAttribute.
1341      *
1342      * @return    the current value of the power-of-ten multiplier.
1343      * @draft ICU 62
1344      */
1345     int32_t getMultiplierScale(void) const;
<span class="line-removed">1346 #endif  /* U_HIDE_DRAFT_API */</span>
1347 
1348     /**
1349      * Sets a power of ten by which number should be multiplied before formatting, which
1350      * can be combined with setMultiplier() to multiply by any arbitrary decimal value.
1351      *
1352      * A multiplier scale of 2 corresponds to multiplication by 100, and a multiplier scale
1353      * of -2 corresponds to multiplication by 0.01.
1354      *
1355      * For example, to multiply numbers by 0.5 before formatting, you can do:
1356      *
1357      * &lt;pre&gt;
1358      * df.setMultiplier(5);
1359      * df.setMultiplierScale(-1);
1360      * &lt;/pre&gt;
1361      *
1362      * This method is analogous to UNUM_SCALE in setAttribute.
1363      *
1364      * @param newValue    the new value of the power-of-ten multiplier.
1365      * @draft ICU 62
1366      */
<span class="line-modified">1367     virtual void setMultiplierScale(int32_t newValue);</span>

1368 
1369     /**
1370      * Get the rounding increment.
1371      * @return A positive rounding increment, or 0.0 if a custom rounding
1372      * increment is not in effect.
1373      * @see #setRoundingIncrement
1374      * @see #getRoundingMode
1375      * @see #setRoundingMode
1376      * @stable ICU 2.0
1377      */
1378     virtual double getRoundingIncrement(void) const;
1379 
1380     /**
1381      * Set the rounding increment.  In the absence of a rounding increment,
1382      *    numbers will be rounded to the number of digits displayed.
1383      * @param newValue A positive rounding increment, or 0.0 to
1384      * use the default rounding increment.
1385      * Negative increments are equivalent to 0.0.
1386      * @see #getRoundingIncrement
1387      * @see #getRoundingMode
</pre>
<hr />
<pre>
1440     virtual void setFormatWidth(int32_t width);
1441 
1442     /**
1443      * Get the pad character used to pad to the format width.  The
1444      * default is &#39; &#39;.
1445      * @return a string containing the pad character. This will always
1446      * have a length of one 32-bit code point.
1447      * @see #setFormatWidth
1448      * @see #getFormatWidth
1449      * @see #setPadCharacter
1450      * @see #getPadPosition
1451      * @see #setPadPosition
1452      * @stable ICU 2.0
1453      */
1454     virtual UnicodeString getPadCharacterString() const;
1455 
1456     /**
1457      * Set the character used to pad to the format width.  If padding
1458      * is not enabled, then this will take effect if padding is later
1459      * enabled.
<span class="line-modified">1460      * @param padChar a string containing the pad charcter. If the string</span>
<span class="line-modified">1461      * has length 0, then the pad characer is set to &#39; &#39;.  Otherwise</span>
1462      * padChar.char32At(0) will be used as the pad character.
1463      * @see #setFormatWidth
1464      * @see #getFormatWidth
1465      * @see #getPadCharacterString
1466      * @see #getPadPosition
1467      * @see #setPadPosition
1468      * @stable ICU 2.0
1469      */
1470     virtual void setPadCharacter(const UnicodeString&amp; padChar);
1471 
1472     /**
1473      * Get the position at which padding will take place.  This is the location
1474      * at which padding will be inserted if the result of format()
1475      * is shorter than the format width.
1476      * @return the pad position, one of kPadBeforePrefix,
1477      * kPadAfterPrefix, kPadBeforeSuffix, or
1478      * kPadAfterSuffix.
1479      * @see #setFormatWidth
1480      * @see #getFormatWidth
1481      * @see #setPadCharacter
</pre>
<hr />
<pre>
1630      * @see setSecondaryGroupingSize
1631      * @see NumberFormat::isGroupingUsed
1632      * @see DecimalFormatSymbols::getGroupingSeparator
1633      * @stable ICU 2.4
1634      */
1635     int32_t getSecondaryGroupingSize(void) const;
1636 
1637     /**
1638      * Set the secondary grouping size. If set to a value less than 1,
1639      * then secondary grouping is turned off, and the primary grouping
1640      * size is used for all intervals, not just the least significant.
1641      *
1642      * @param newValue    the new value of the secondary grouping size.
1643      * @see getSecondaryGroupingSize
1644      * @see NumberFormat#setGroupingUsed
1645      * @see DecimalFormatSymbols::setGroupingSeparator
1646      * @stable ICU 2.4
1647      */
1648     virtual void setSecondaryGroupingSize(int32_t newValue);
1649 
<span class="line-modified">1650 #ifndef U_HIDE_INTERNAL_API</span>
<span class="line-removed">1651 </span>
1652     /**
1653      * Returns the minimum number of grouping digits.
1654      * Grouping separators are output if there are at least this many
1655      * digits to the left of the first (rightmost) grouping separator,
1656      * that is, there are at least (minimum grouping + grouping size) integer digits.
1657      * (Subject to isGroupingUsed().)
1658      *
1659      * For example, if this value is 2, and the grouping size is 3, then
1660      * 9999 -&gt; &quot;9999&quot; and 10000 -&gt; &quot;10,000&quot;
1661      *
<span class="line-removed">1662      * This is a technology preview. This API may change behavior or may be removed.</span>
<span class="line-removed">1663      *</span>
1664      * The default value for this attribute is 0.
1665      * A value of 1, 0, or lower, means that the use of grouping separators
1666      * only depends on the grouping size (and on isGroupingUsed()).
<span class="line-modified">1667      * Currently, the corresponding CLDR data is not used; this is likely to change.</span>




1668      *
1669      * @see setMinimumGroupingDigits
1670      * @see getGroupingSize
<span class="line-modified">1671      * @internal technology preview</span>
1672      */
1673     int32_t getMinimumGroupingDigits() const;
1674 
<span class="line-removed">1675 #endif  /* U_HIDE_INTERNAL_API */</span>
<span class="line-removed">1676 </span>
<span class="line-removed">1677     /* Cannot use #ifndef U_HIDE_INTERNAL_API for the following draft method since it is virtual. */</span>
1678     /**
1679      * Sets the minimum grouping digits. Setting to a value less than or
1680      * equal to 1 turns off minimum grouping digits.
1681      *


1682      * @param newValue the new value of minimum grouping digits.
1683      * @see getMinimumGroupingDigits
<span class="line-modified">1684      * @internal technology preview</span>
1685      */
<span class="line-modified">1686     virtual void setMinimumGroupingDigits(int32_t newValue);</span>

1687 
1688 
1689     /**
1690      * Allows you to get the behavior of the decimal separator with integers.
1691      * (The decimal separator will always appear with decimals.)
1692      *
1693      * @return    TRUE if the decimal separator always appear with decimals.
1694      * Example: Decimal ON: 12345 -&gt; 12345.; OFF: 12345 -&gt; 12345
1695      * @stable ICU 2.0
1696      */
1697     UBool isDecimalSeparatorAlwaysShown(void) const;
1698 
1699     /**
1700      * Allows you to set the behavior of the decimal separator with integers.
1701      * (The decimal separator will always appear with decimals.)
1702      *
1703      * @param newValue    set TRUE if the decimal separator will always appear with decimals.
1704      * Example: Decimal ON: 12345 -&gt; 12345.; OFF: 12345 -&gt; 12345
1705      * @stable ICU 2.0
1706      */
</pre>
<hr />
<pre>
1708 
1709     /**
1710      * Allows you to get the parse behavior of the pattern decimal mark.
1711      *
1712      * @return    TRUE if input must contain a match to decimal mark in pattern
1713      * @stable ICU 54
1714      */
1715     UBool isDecimalPatternMatchRequired(void) const;
1716 
1717     /**
1718      * Allows you to set the parse behavior of the pattern decimal mark.
1719      *
1720      * if TRUE, the input must have a decimal mark if one was specified in the pattern. When
1721      * FALSE the decimal mark may be omitted from the input.
1722      *
1723      * @param newValue    set TRUE if input must contain a match to decimal mark in pattern
1724      * @stable ICU 54
1725      */
1726     virtual void setDecimalPatternMatchRequired(UBool newValue);
1727 

1728     /**
<span class="line-modified">1729      * {@icu} Returns whether to ignore exponents when parsing.</span>
1730      *

1731      * @see #setParseNoExponent
<span class="line-modified">1732      * @internal This API is a technical preview. It may change in an upcoming release.</span>
1733      */
<span class="line-modified">1734     virtual UBool isParseNoExponent() const;</span>
1735 
1736     /**
<span class="line-modified">1737      * {@icu} Specifies whether to stop parsing when an exponent separator is encountered. For</span>
1738      * example, parses &quot;123E4&quot; to 123 (with parse position 3) instead of 1230000 (with parse position
1739      * 5).
1740      *
1741      * @param value true to prevent exponents from being parsed; false to allow them to be parsed.
<span class="line-modified">1742      * @internal This API is a technical preview. It may change in an upcoming release.</span>
1743      */
<span class="line-modified">1744     virtual void setParseNoExponent(UBool value);</span>
1745 
1746     /**
<span class="line-modified">1747      * {@icu} Returns whether parsing is sensitive to case (lowercase/uppercase).</span>
1748      *

1749      * @see #setParseCaseSensitive
<span class="line-modified">1750      * @internal This API is a technical preview. It may change in an upcoming release.</span>
1751      */
<span class="line-modified">1752     virtual UBool isParseCaseSensitive() const;</span>
1753 
1754     /**
<span class="line-modified">1755      * {@icu} Whether to pay attention to case when parsing; default is to ignore case (perform</span>
1756      * case-folding). For example, &quot;A&quot; == &quot;a&quot; in case-insensitive but not case-sensitive mode.
1757      *
1758      * Currency symbols are never case-folded. For example, &quot;us$1.00&quot; will not parse in case-insensitive
1759      * mode, even though &quot;US$1.00&quot; parses.
1760      *
<span class="line-modified">1761      * @internal This API is a technical preview. It may change in an upcoming release.</span>


1762      */
<span class="line-modified">1763     virtual void setParseCaseSensitive(UBool value);</span>
1764 
1765     /**
<span class="line-modified">1766      * {@icu} Returns whether truncation of high-order integer digits should result in an error.</span>
1767      * By default, setMaximumIntegerDigits truncates high-order digits silently.
1768      *

1769      * @see setFormatFailIfMoreThanMaxDigits
<span class="line-modified">1770      * @internal This API is a technical preview. It may change in an upcoming release.</span>
1771      */
<span class="line-modified">1772     virtual UBool isFormatFailIfMoreThanMaxDigits() const;</span>
1773 
1774     /**
<span class="line-modified">1775      * {@icu} Sets whether truncation of high-order integer digits should result in an error.</span>
1776      * By default, setMaximumIntegerDigits truncates high-order digits silently.
1777      *
<span class="line-modified">1778      * @internal This API is a technical preview. It may change in an upcoming release.</span>

1779      */
<span class="line-modified">1780     virtual void setFormatFailIfMoreThanMaxDigits(UBool value);</span>

1781 
1782 
1783     /**
1784      * Synthesizes a pattern string that represents the current state
1785      * of this Format object.
1786      *
1787      * @param result    Output param which will receive the pattern.
1788      *                  Previous contents are deleted.
1789      * @return          A reference to &#39;result&#39;.
1790      * @see applyPattern
1791      * @stable ICU 2.0
1792      */
1793     virtual UnicodeString&amp; toPattern(UnicodeString&amp; result) const;
1794 
1795     /**
1796      * Synthesizes a localized pattern string that represents the current
1797      * state of this Format object.
1798      *
1799      * @param result    Output param which will receive the localized pattern.
1800      *                  Previous contents are deleted.
</pre>
<hr />
<pre>
2000      * amounts.  This takes effect immediately, if this format is a
2001      * currency format.  If this format is not a currency format, then
2002      * the currency is used if and when this object becomes a
2003      * currency format through the application of a new pattern.
2004      * @param theCurrency a 3-letter ISO code indicating new currency
2005      * to use.  It need not be null-terminated.  May be the empty
2006      * string or NULL to indicate no currency.
2007      * @param ec input-output error code
2008      * @stable ICU 3.0
2009      */
2010     void setCurrency(const char16_t* theCurrency, UErrorCode&amp; ec) U_OVERRIDE;
2011 
2012     /**
2013      * Sets the currency used to display currency amounts.  See
2014      * setCurrency(const char16_t*, UErrorCode&amp;).
2015      * @deprecated ICU 3.0. Use setCurrency(const char16_t*, UErrorCode&amp;).
2016      */
2017     virtual void setCurrency(const char16_t* theCurrency);
2018 
2019     /**
<span class="line-modified">2020      * Sets the &lt;tt&gt;Currency Context&lt;/tt&gt; object used to display currency.</span>
2021      * This takes effect immediately, if this format is a
2022      * currency format.
<span class="line-modified">2023      * @param currencyContext new currency context object to use.</span>

2024      * @stable ICU 54
2025      */
2026     void setCurrencyUsage(UCurrencyUsage newUsage, UErrorCode* ec);
2027 
2028     /**
<span class="line-modified">2029      * Returns the &lt;tt&gt;Currency Context&lt;/tt&gt; object used to display currency</span>
2030      * @stable ICU 54
2031      */
2032     UCurrencyUsage getCurrencyUsage() const;
2033 
2034 #ifndef U_HIDE_INTERNAL_API
2035 
2036     /**
2037      *  Format a number and save it into the given DecimalQuantity.
2038      *  Internal, not intended for public use.
2039      *  @internal
2040      */
2041     void formatToDecimalQuantity(double number, number::impl::DecimalQuantity&amp; output,
2042                                  UErrorCode&amp; status) const;
2043 
2044     /**
2045      *  Get a DecimalQuantity corresponding to a formattable as it would be
2046      *  formatted by this DecimalFormat.
2047      *  Internal, not intended for public use.
2048      *  @internal
2049      */
2050     void formatToDecimalQuantity(const Formattable&amp; number, number::impl::DecimalQuantity&amp; output,
2051                                  UErrorCode&amp; status) const;
2052 
<span class="line-modified">2053 #endif</span>
2054 
2055 #ifndef U_HIDE_DRAFT_API
2056     /**
<span class="line-modified">2057      * Converts this DecimalFormat to a NumberFormatter.  Starting in ICU 60,</span>
<span class="line-modified">2058      * NumberFormatter is the recommended way to format numbers.</span>
























2059      *
2060      * NOTE: The returned LocalizedNumberFormatter is owned by this DecimalFormat.
2061      * If a non-const method is called on the DecimalFormat, or if the DecimalFormat
2062      * is deleted, the object becomes invalid. If you plan to keep the return value
2063      * beyond the lifetime of the DecimalFormat, copy it to a local variable:
2064      *
2065      * &lt;pre&gt;
<span class="line-modified">2066      * LocalizedNumberFormatter f = df-&gt;toNumberFormatter();</span>



2067      * &lt;/pre&gt;
2068      *
<span class="line-modified">2069      * It is, however, safe to use the return value for chaining:</span>











2070      *
<span class="line-modified">2071      * &lt;pre&gt;</span>
<span class="line-modified">2072      * FormattedNumber result = df-&gt;toNumberFormatter().formatDouble(123, status);</span>
<span class="line-removed">2073      * &lt;/pre&gt;</span>
2074      *
<span class="line-modified">2075      * @param output The variable into which to store the LocalizedNumberFormatter.</span>
<span class="line-modified">2076      * @return The output variable, for chaining.</span>
<span class="line-modified">2077      * @draft ICU 62</span>

2078      */
2079     const number::LocalizedNumberFormatter&amp; toNumberFormatter() const;
<span class="line-modified">2080 #endif  /* U_HIDE_DRAFT_API */</span>
2081 
2082     /**
2083      * Return the class ID for this class.  This is useful only for
2084      * comparing to a return value from getDynamicClassID().  For example:
2085      * &lt;pre&gt;
2086      * .      Base* polymorphic_pointer = createPolymorphicObject();
2087      * .      if (polymorphic_pointer-&gt;getDynamicClassID() ==
2088      * .          Derived::getStaticClassID()) ...
2089      * &lt;/pre&gt;
2090      * @return          The class ID for all objects of this class.
2091      * @stable ICU 2.0
2092      */
2093     static UClassID U_EXPORT2 getStaticClassID(void);
2094 
2095     /**
2096      * Returns a unique class ID POLYMORPHICALLY.  Pure virtual override.
2097      * This method is to implement a simple version of RTTI, since not all
2098      * C++ compilers support genuine RTTI.  Polymorphic operator==() and
2099      * clone() methods call this method.
2100      *
2101      * @return          The class ID for this object. All objects of a
2102      *                  given class have the same class ID.  Objects of
2103      *                  other classes have different class IDs.
2104      * @stable ICU 2.0
2105      */
2106     UClassID getDynamicClassID(void) const U_OVERRIDE;
2107 
2108   private:
2109 
2110     /** Rebuilds the formatter object from the property bag. */
2111     void touch(UErrorCode&amp; status);
2112 
<span class="line-modified">2113     /** Rebuilds the formatter object, hiding the error code. */</span>
2114     void touchNoError();
2115 
2116     /**
2117      * Updates the property bag with settings from the given pattern.
2118      *
2119      * @param pattern The pattern string to parse.
2120      * @param ignoreRounding Whether to leave out rounding information (minFrac, maxFrac, and rounding
2121      *     increment) when parsing the pattern. This may be desirable if a custom rounding mode, such
2122      *     as CurrencyUsage, is to be used instead. One of {@link
2123      *     PatternStringParser#IGNORE_ROUNDING_ALWAYS}, {@link PatternStringParser#IGNORE_ROUNDING_IF_CURRENCY},
2124      *     or {@link PatternStringParser#IGNORE_ROUNDING_NEVER}.
2125      * @see PatternAndPropertyUtils#parseToExistingProperties
2126      */
2127     void setPropertiesFromPattern(const UnicodeString&amp; pattern, int32_t ignoreRounding,
2128                                   UErrorCode&amp; status);
2129 
2130     const numparse::impl::NumberParserImpl* getParser(UErrorCode&amp; status) const;
2131 
2132     const numparse::impl::NumberParserImpl* getCurrencyParser(UErrorCode&amp; status) const;
2133 
2134     static void fieldPositionHelper(const number::FormattedNumber&amp; formatted, FieldPosition&amp; fieldPosition,
2135                                     int32_t offset, UErrorCode&amp; status);
2136 
2137     static void fieldPositionIteratorHelper(const number::FormattedNumber&amp; formatted,
2138                                             FieldPositionIterator* fpi, int32_t offset, UErrorCode&amp; status);
2139 
2140     void setupFastFormat();
2141 
2142     bool fastFormatDouble(double input, UnicodeString&amp; output) const;
2143 
2144     bool fastFormatInt64(int64_t input, UnicodeString&amp; output) const;
2145 
2146     void doFastFormatInt32(int32_t input, bool isNegative, UnicodeString&amp; output) const;
2147 
2148     //=====================================================================================//
2149     //                                   INSTANCE FIELDS                                   //
2150     //=====================================================================================//
2151 
<span class="line-modified">2152     // Only one instance field: keep all fields inside of an implementation class defined in number_mapper.h</span>
<span class="line-modified">2153     number::impl::DecimalFormatFields* fields;</span>


2154 
2155     // Allow child class CompactDecimalFormat to access fProperties:
2156     friend class CompactDecimalFormat;
2157 



2158 };
2159 
2160 U_NAMESPACE_END
2161 
2162 #endif /* #if !UCONFIG_NO_FORMATTING */
2163 
2164 #endif // _DECIMFMT
2165 //eof
</pre>
</td>
<td>
<hr />
<pre>
  46 U_NAMESPACE_BEGIN
  47 
  48 class CurrencyPluralInfo;
  49 class CompactDecimalFormat;
  50 
  51 namespace number {
  52 class LocalizedNumberFormatter;
  53 class FormattedNumber;
  54 namespace impl {
  55 class DecimalQuantity;
  56 struct DecimalFormatFields;
  57 }
  58 }
  59 
  60 namespace numparse {
  61 namespace impl {
  62 class NumberParserImpl;
  63 }
  64 }
  65 








  66 /**
<span class="line-modified">  67  * **IMPORTANT:** New users are strongly encouraged to see if</span>
  68  * numberformatter.h fits their use case.  Although not deprecated, this header
  69  * is provided for backwards compatibility only.

  70  *
  71  * DecimalFormat is a concrete subclass of NumberFormat that formats decimal
  72  * numbers. It has a variety of features designed to make it possible to parse
  73  * and format numbers in any locale, including support for Western, Arabic, or
  74  * Indic digits.  It also supports different flavors of numbers, including
  75  * integers (&quot;123&quot;), fixed-point numbers (&quot;123.4&quot;), scientific notation
  76  * (&quot;1.23E4&quot;), percentages (&quot;12%&quot;), and currency amounts (&quot;$123&quot;, &quot;USD123&quot;,
  77  * &quot;123 US dollars&quot;).  All of these flavors can be easily localized.
  78  *
<span class="line-modified">  79  * To obtain a NumberFormat for a specific locale (including the default</span>
  80  * locale) call one of NumberFormat&#39;s factory methods such as
  81  * createInstance(). Do not call the DecimalFormat constructors directly, unless
  82  * you know what you are doing, since the NumberFormat factory methods may
  83  * return subclasses other than DecimalFormat.
  84  *
<span class="line-modified">  85  * **Example Usage**</span>
  86  *
  87  * \code
  88  *     // Normally we would have a GUI with a menu for this
  89  *     int32_t locCount;
  90  *     const Locale* locales = NumberFormat::getAvailableLocales(locCount);
  91  *
  92  *     double myNumber = -1234.56;
  93  *     UErrorCode success = U_ZERO_ERROR;
  94  *     NumberFormat* form;
  95  *
  96  *     // Print out a number with the localized number, currency and percent
  97  *     // format for each locale.
  98  *     UnicodeString countryName;
  99  *     UnicodeString displayName;
 100  *     UnicodeString str;
 101  *     UnicodeString pattern;
 102  *     Formattable fmtable;
 103  *     for (int32_t j = 0; j &lt; 3; ++j) {
 104  *         cout &lt;&lt; endl &lt;&lt; &quot;FORMAT &quot; &lt;&lt; j &lt;&lt; endl;
 105  *         for (int32_t i = 0; i &lt; locCount; ++i) {
</pre>
<hr />
<pre>
 109  *             }
 110  *             switch (j) {
 111  *             case 0:
 112  *                 form = NumberFormat::createInstance(locales[i], success ); break;
 113  *             case 1:
 114  *                 form = NumberFormat::createCurrencyInstance(locales[i], success ); break;
 115  *             default:
 116  *                 form = NumberFormat::createPercentInstance(locales[i], success ); break;
 117  *             }
 118  *             if (form) {
 119  *                 str.remove();
 120  *                 pattern = ((DecimalFormat*)form)-&gt;toPattern(pattern);
 121  *                 cout &lt;&lt; locales[i].getDisplayName(displayName) &lt;&lt; &quot;: &quot; &lt;&lt; pattern;
 122  *                 cout &lt;&lt; &quot;  -&gt;  &quot; &lt;&lt; form-&gt;format(myNumber,str) &lt;&lt; endl;
 123  *                 form-&gt;parse(form-&gt;format(myNumber,str), fmtable, success);
 124  *                 delete form;
 125  *             }
 126  *         }
 127  *     }
 128  * \endcode
<span class="line-modified"> 129  *</span>
<span class="line-modified"> 130  * **Another example use createInstance(style)**</span>
<span class="line-modified"> 131  *</span>
<span class="line-modified"> 132  * \code</span>
<span class="line-modified"> 133  * // Print out a number using the localized number, currency,</span>
 134  * // percent, scientific, integer, iso currency, and plural currency
 135  * // format for each locale&lt;/strong&gt;
 136  * Locale* locale = new Locale(&quot;en&quot;, &quot;US&quot;);
 137  * double myNumber = 1234.56;
 138  * UErrorCode success = U_ZERO_ERROR;
 139  * UnicodeString str;
 140  * Formattable fmtable;
 141  * for (int j=NumberFormat::kNumberStyle;
 142  *      j&lt;=NumberFormat::kPluralCurrencyStyle;
 143  *      ++j) {
<span class="line-modified"> 144  *     NumberFormat* form = NumberFormat::createInstance(locale, j, success);</span>
 145  *     str.remove();
 146  *     cout &lt;&lt; &quot;format result &quot; &lt;&lt; form-&gt;format(myNumber, str) &lt;&lt; endl;
 147  *     format-&gt;parse(form-&gt;format(myNumber, str), fmtable, success);
<span class="line-modified"> 148  *     delete form;</span>
<span class="line-added"> 149  * }</span>
<span class="line-added"> 150  * \endcode</span>
 151  *
 152  *
 153  * &lt;p&gt;&lt;strong&gt;Patterns&lt;/strong&gt;
 154  *
 155  * &lt;p&gt;A DecimalFormat consists of a &lt;em&gt;pattern&lt;/em&gt; and a set of
 156  * &lt;em&gt;symbols&lt;/em&gt;.  The pattern may be set directly using
 157  * applyPattern(), or indirectly using other API methods which
 158  * manipulate aspects of the pattern, such as the minimum number of integer
 159  * digits.  The symbols are stored in a DecimalFormatSymbols
 160  * object.  When using the NumberFormat factory methods, the
 161  * pattern and symbols are read from ICU&#39;s locale data.
 162  *
 163  * &lt;p&gt;&lt;strong&gt;Special Pattern Characters&lt;/strong&gt;
 164  *
 165  * &lt;p&gt;Many characters in a pattern are taken literally; they are matched during
 166  * parsing and output unchanged during formatting.  Special characters, on the
 167  * other hand, stand for other characters, strings, or classes of characters.
 168  * For example, the &#39;#&#39; character is replaced by a localized digit.  Often the
 169  * replacement character is the same as the pattern character; in the U.S. locale,
 170  * the &#39;,&#39; grouping character is replaced by &#39;,&#39;.  However, the replacement is
</pre>
<hr />
<pre>
 259  *         doubled, replaced by international currency symbol.
 260  *         If tripled, replaced by currency plural names, for example,
 261  *         &quot;US dollar&quot; or &quot;US dollars&quot; for America.
 262  *         If present in a pattern, the monetary decimal separator
 263  *         is used instead of the decimal separator.
 264  *   &lt;tr valign=top bgcolor=&quot;#eeeeff&quot;&gt;
 265  *     &lt;td&gt;&lt;code&gt;&#39;&lt;/code&gt;
 266  *     &lt;td&gt;Prefix or suffix
 267  *     &lt;td&gt;No
 268  *     &lt;td&gt;Used to quote special characters in a prefix or suffix,
 269  *         for example, &lt;code&gt;&quot;&#39;#&#39;#&quot;&lt;/code&gt; formats 123 to
 270  *         &lt;code&gt;&quot;#123&quot;&lt;/code&gt;.  To create a single quote
 271  *         itself, use two in a row: &lt;code&gt;&quot;# o&#39;&#39;clock&quot;&lt;/code&gt;.
 272  *   &lt;tr valign=top&gt;
 273  *     &lt;td&gt;&lt;code&gt;*&lt;/code&gt;
 274  *     &lt;td&gt;Prefix or suffix boundary
 275  *     &lt;td&gt;Yes
 276  *     &lt;td&gt;Pad escape, precedes pad character
 277  * &lt;/table&gt;
 278  *
<span class="line-modified"> 279  * &lt;p&gt;A DecimalFormat pattern contains a positive and negative</span>
 280  * subpattern, for example, &quot;#,##0.00;(#,##0.00)&quot;.  Each subpattern has a
 281  * prefix, a numeric part, and a suffix.  If there is no explicit negative
 282  * subpattern, the negative subpattern is the localized minus sign prefixed to the
 283  * positive subpattern. That is, &quot;0.00&quot; alone is equivalent to &quot;0.00;-0.00&quot;.  If there
 284  * is an explicit negative subpattern, it serves only to specify the negative
 285  * prefix and suffix; the number of digits, minimal digits, and other
 286  * characteristics are ignored in the negative subpattern. That means that
 287  * &quot;#,##0.0#;(#)&quot; has precisely the same result as &quot;#,##0.0#;(#,##0.0#)&quot;.
 288  *
 289  * &lt;p&gt;The prefixes, suffixes, and various symbols used for infinity, digits,
 290  * thousands separators, decimal separators, etc. may be set to arbitrary
 291  * values, and they will appear properly during formatting.  However, care must
 292  * be taken that the symbols and strings do not conflict, or parsing will be
 293  * unreliable.  For example, either the positive and negative prefixes or the
 294  * suffixes must be distinct for parse() to be able
 295  * to distinguish positive from negative values.  Another example is that the
 296  * decimal separator and thousands separator should be distinct characters, or
 297  * parsing will be impossible.
 298  *
 299  * &lt;p&gt;The &lt;em&gt;grouping separator&lt;/em&gt; is a character that separates clusters of
</pre>
<hr />
<pre>
 394  * notation&lt;/a&gt; or &lt;a href=&quot;#sigdig&quot;&gt;significant digits&lt;/a&gt;.
 395  *
 396  * &lt;ul&gt;&lt;li&gt;If the number of actual integer digits exceeds the
 397  * &lt;em&gt;maximum integer digits&lt;/em&gt;, then only the least significant
 398  * digits are shown.  For example, 1997 is formatted as &quot;97&quot; if the
 399  * maximum integer digits is set to 2.
 400  *
 401  * &lt;li&gt;If the number of actual integer digits is less than the
 402  * &lt;em&gt;minimum integer digits&lt;/em&gt;, then leading zeros are added.  For
 403  * example, 1997 is formatted as &quot;01997&quot; if the minimum integer digits
 404  * is set to 5.
 405  *
 406  * &lt;li&gt;If the number of actual fraction digits exceeds the &lt;em&gt;maximum
 407  * fraction digits&lt;/em&gt;, then rounding is performed to the
 408  * maximum fraction digits.  For example, 0.125 is formatted as &quot;0.12&quot;
 409  * if the maximum fraction digits is 2.  This behavior can be changed
 410  * by specifying a rounding increment and/or a rounding mode.
 411  *
 412  * &lt;li&gt;If the number of actual fraction digits is less than the
 413  * &lt;em&gt;minimum fraction digits&lt;/em&gt;, then trailing zeros are added.
<span class="line-modified"> 414  * For example, 0.125 is formatted as &quot;0.1250&quot; if the minimum fraction</span>
 415  * digits is set to 4.
 416  *
 417  * &lt;li&gt;Trailing fractional zeros are not displayed if they occur
 418  * &lt;em&gt;j&lt;/em&gt; positions after the decimal, where &lt;em&gt;j&lt;/em&gt; is less
 419  * than the maximum fraction digits. For example, 0.10004 is
 420  * formatted as &quot;0.1&quot; if the maximum fraction digits is four or less.
 421  * &lt;/ul&gt;
 422  *
 423  * &lt;p&gt;&lt;strong&gt;Special Values&lt;/strong&gt;
 424  *
 425  * &lt;p&gt;&lt;code&gt;NaN&lt;/code&gt; is represented as a single character, typically
 426  * &lt;code&gt;\\uFFFD&lt;/code&gt;.  This character is determined by the
 427  * DecimalFormatSymbols object.  This is the only value for which
 428  * the prefixes and suffixes are not used.
 429  *
 430  * &lt;p&gt;Infinity is represented as a single character, typically
 431  * &lt;code&gt;\\u221E&lt;/code&gt;, with the positive or negative prefixes and suffixes
 432  * applied.  The infinity character is determined by the
 433  * DecimalFormatSymbols object.
 434  *
</pre>
<hr />
<pre>
 559  * &lt;code&gt;&quot;#,#@#&quot;&lt;/code&gt; indicates a minimum of one significant digits,
 560  * a maximum of two significant digits, and a grouping size of three.
 561  *
 562  * &lt;li&gt;In order to enable significant digits formatting, use a pattern
 563  * containing the &lt;code&gt;&#39;@&#39;&lt;/code&gt; pattern character.  Alternatively,
 564  * call setSignificantDigitsUsed(TRUE).
 565  *
 566  * &lt;li&gt;In order to disable significant digits formatting, use a
 567  * pattern that does not contain the &lt;code&gt;&#39;@&#39;&lt;/code&gt; pattern
 568  * character. Alternatively, call setSignificantDigitsUsed(FALSE).
 569  *
 570  * &lt;li&gt;The number of significant digits has no effect on parsing.
 571  *
 572  * &lt;li&gt;Significant digits may be used together with exponential notation. Such
 573  * patterns are equivalent to a normal exponential pattern with a minimum and
 574  * maximum integer digit count of one, a minimum fraction digit count of
 575  * &lt;code&gt;getMinimumSignificantDigits() - 1&lt;/code&gt;, and a maximum fraction digit
 576  * count of &lt;code&gt;getMaximumSignificantDigits() - 1&lt;/code&gt;. For example, the
 577  * pattern &lt;code&gt;&quot;@@###E0&quot;&lt;/code&gt; is equivalent to &lt;code&gt;&quot;0.0###E0&quot;&lt;/code&gt;.
 578  *
<span class="line-modified"> 579  * &lt;li&gt;If significant digits are in use, then the integer and fraction</span>
 580  * digit counts, as set via the API, are ignored.  If significant
<span class="line-modified"> 581  * digits are not in use, then the significant digit counts, as set via</span>
 582  * the API, are ignored.
 583  *
 584  * &lt;/ul&gt;
 585  *
 586  * &lt;p&gt;&lt;strong&gt;Padding&lt;/strong&gt;
 587  *
 588  * &lt;p&gt;DecimalFormat supports padding the result of
 589  * format() to a specific width.  Padding may be specified either
 590  * through the API or through the pattern syntax.  In a pattern the pad escape
 591  * character, followed by a single pad character, causes padding to be parsed
 592  * and formatted.  The pad escape character is &#39;*&#39; in unlocalized patterns, and
 593  * can be localized using DecimalFormatSymbols::setSymbol() with a
 594  * DecimalFormatSymbols::kPadEscapeSymbol
 595  * selector.  For example, &lt;code&gt;&quot;$*x#,##0.00&quot;&lt;/code&gt; formats 123 to
 596  * &lt;code&gt;&quot;$xx123.00&quot;&lt;/code&gt;, and 1234 to &lt;code&gt;&quot;$1,234.00&quot;&lt;/code&gt;.
 597  *
 598  * &lt;ul&gt;
 599  * &lt;li&gt;When padding is in effect, the width of the positive subpattern,
 600  * including prefix and suffix, determines the format width.  For example, in
 601  * the pattern &lt;code&gt;&quot;* #0 o&#39;&#39;clock&quot;&lt;/code&gt;, the format width is 10.
</pre>
<hr />
<pre>
 615  * before the prefix and after the prefix are equivalent, likewise for the
 616  * suffix.
 617  *
 618  * &lt;li&gt;When specified in a pattern, the 32-bit code point immediately
 619  * following the pad escape is the pad character. This may be any character,
 620  * including a special pattern character. That is, the pad escape
 621  * &lt;em&gt;escapes&lt;/em&gt; the following character. If there is no character after
 622  * the pad escape, then the pattern is illegal.
 623  *
 624  * &lt;/ul&gt;
 625  *
 626  * &lt;p&gt;&lt;strong&gt;Rounding&lt;/strong&gt;
 627  *
 628  * &lt;p&gt;DecimalFormat supports rounding to a specific increment.  For
 629  * example, 1230 rounded to the nearest 50 is 1250.  1.234 rounded to the
 630  * nearest 0.65 is 1.3.  The rounding increment may be specified through the API
 631  * or in a pattern.  To specify a rounding increment in a pattern, include the
 632  * increment in the pattern itself.  &quot;#,#50&quot; specifies a rounding increment of
 633  * 50.  &quot;#,##0.05&quot; specifies a rounding increment of 0.05.
 634  *
<span class="line-modified"> 635  * &lt;p&gt;In the absence of an explicit rounding increment numbers are</span>
 636  * rounded to their formatted width.
 637  *
 638  * &lt;ul&gt;
 639  * &lt;li&gt;Rounding only affects the string produced by formatting.  It does
 640  * not affect parsing or change any numerical values.
 641  *
 642  * &lt;li&gt;A &lt;em&gt;rounding mode&lt;/em&gt; determines how values are rounded; see
 643  * DecimalFormat::ERoundingMode.  The default rounding mode is
 644  * DecimalFormat::kRoundHalfEven.  The rounding mode can only be set
 645  * through the API; it can not be set with a pattern.
 646  *
 647  * &lt;li&gt;Some locales use rounding in their currency formats to reflect the
 648  * smallest currency denomination.
 649  *
 650  * &lt;li&gt;In a pattern, digits &#39;1&#39; through &#39;9&#39; specify rounding, but otherwise
 651  * behave identically to digit &#39;0&#39;.
 652  * &lt;/ul&gt;
 653  *
 654  * &lt;p&gt;&lt;strong&gt;Synchronization&lt;/strong&gt;
 655  *
</pre>
<hr />
<pre>
 666   public:
 667     /**
 668      * Pad position.
 669      * @stable ICU 2.4
 670      */
 671     enum EPadPosition {
 672         kPadBeforePrefix, kPadAfterPrefix, kPadBeforeSuffix, kPadAfterSuffix
 673     };
 674 
 675     /**
 676      * Create a DecimalFormat using the default pattern and symbols
 677      * for the default locale. This is a convenient way to obtain a
 678      * DecimalFormat when internationalization is not the main concern.
 679      * &lt;P&gt;
 680      * To obtain standard formats for a given locale, use the factory methods
 681      * on NumberFormat such as createInstance. These factories will
 682      * return the most appropriate sub-class of NumberFormat for a given
 683      * locale.
 684      * &lt;p&gt;
 685      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified"> 686      * #icu::number::NumberFormatter instead of DecimalFormat.</span>
 687      * @param status    Output param set to success/failure code. If the
 688      *                  pattern is invalid this will be set to a failure code.
 689      * @stable ICU 2.0
 690      */
 691     DecimalFormat(UErrorCode&amp; status);
 692 
 693     /**
 694      * Create a DecimalFormat from the given pattern and the symbols
 695      * for the default locale. This is a convenient way to obtain a
 696      * DecimalFormat when internationalization is not the main concern.
 697      * &lt;P&gt;
 698      * To obtain standard formats for a given locale, use the factory methods
 699      * on NumberFormat such as createInstance. These factories will
 700      * return the most appropriate sub-class of NumberFormat for a given
 701      * locale.
 702      * &lt;p&gt;
 703      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified"> 704      * #icu::number::NumberFormatter instead of DecimalFormat.</span>
 705      * @param pattern   A non-localized pattern string.
 706      * @param status    Output param set to success/failure code. If the
 707      *                  pattern is invalid this will be set to a failure code.
 708      * @stable ICU 2.0
 709      */
 710     DecimalFormat(const UnicodeString&amp; pattern, UErrorCode&amp; status);
 711 
 712     /**
 713      * Create a DecimalFormat from the given pattern and symbols.
 714      * Use this constructor when you need to completely customize the
 715      * behavior of the format.
 716      * &lt;P&gt;
 717      * To obtain standard formats for a given
 718      * locale, use the factory methods on NumberFormat such as
 719      * createInstance or createCurrencyInstance. If you need only minor adjustments
 720      * to a standard format, you can modify the format returned by
 721      * a NumberFormat factory method.
 722      * &lt;p&gt;
 723      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified"> 724      * #icu::number::NumberFormatter instead of DecimalFormat.</span>
 725      *
 726      * @param pattern           a non-localized pattern string
 727      * @param symbolsToAdopt    the set of symbols to be used.  The caller should not
 728      *                          delete this object after making this call.
 729      * @param status            Output param set to success/failure code. If the
 730      *                          pattern is invalid this will be set to a failure code.
 731      * @stable ICU 2.0
 732      */
 733     DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt, UErrorCode&amp; status);
 734 
 735 #ifndef U_HIDE_INTERNAL_API
 736 
 737     /**
 738      * This API is for ICU use only.
 739      * Create a DecimalFormat from the given pattern, symbols, and style.
 740      *
 741      * @param pattern           a non-localized pattern string
 742      * @param symbolsToAdopt    the set of symbols to be used.  The caller should not
 743      *                          delete this object after making this call.
 744      * @param style             style of decimal format
</pre>
<hr />
<pre>
 758 
 759 #endif
 760 
 761 #endif  /* U_HIDE_INTERNAL_API */
 762 
 763   private:
 764 
 765     /**
 766      * Internal constructor for DecimalFormat; sets up internal fields. All public constructors should
 767      * call this constructor.
 768      */
 769     DecimalFormat(const DecimalFormatSymbols* symbolsToAdopt, UErrorCode&amp; status);
 770 
 771   public:
 772 
 773     /**
 774      * Set an integer attribute on this DecimalFormat.
 775      * May return U_UNSUPPORTED_ERROR if this instance does not support
 776      * the specified attribute.
 777      * @param attr the attribute to set
<span class="line-modified"> 778      * @param newValue new value</span>
 779      * @param status the error type
 780      * @return *this - for chaining (example: format.setAttribute(...).setAttribute(...) )
 781      * @stable ICU 51
 782      */
 783     virtual DecimalFormat&amp; setAttribute(UNumberFormatAttribute attr, int32_t newValue, UErrorCode&amp; status);
 784 
 785     /**
 786      * Get an integer
 787      * May return U_UNSUPPORTED_ERROR if this instance does not support
 788      * the specified attribute.
 789      * @param attr the attribute to set
 790      * @param status the error type
 791      * @return the attribute value. Undefined if there is an error.
 792      * @stable ICU 51
 793      */
 794     virtual int32_t getAttribute(UNumberFormatAttribute attr, UErrorCode&amp; status) const;
 795 
 796 
 797     /**
 798      * Set whether or not grouping will be used in this format.
</pre>
<hr />
<pre>
 815      * Sets whether lenient parsing should be enabled (it is off by default).
 816      *
 817      * @param enable \c TRUE if lenient parsing should be used,
 818      *               \c FALSE otherwise.
 819      * @stable ICU 4.8
 820      */
 821     void setLenient(UBool enable) U_OVERRIDE;
 822 
 823     /**
 824      * Create a DecimalFormat from the given pattern and symbols.
 825      * Use this constructor when you need to completely customize the
 826      * behavior of the format.
 827      * &lt;P&gt;
 828      * To obtain standard formats for a given
 829      * locale, use the factory methods on NumberFormat such as
 830      * createInstance or createCurrencyInstance. If you need only minor adjustments
 831      * to a standard format, you can modify the format returned by
 832      * a NumberFormat factory method.
 833      * &lt;p&gt;
 834      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified"> 835      * #icu::number::NumberFormatter instead of DecimalFormat.</span>
 836      *
 837      * @param pattern           a non-localized pattern string
 838      * @param symbolsToAdopt    the set of symbols to be used.  The caller should not
 839      *                          delete this object after making this call.
<span class="line-modified"> 840      * @param parseError        Output param to receive errors occurred during parsing</span>
 841      * @param status            Output param set to success/failure code. If the
 842      *                          pattern is invalid this will be set to a failure code.
 843      * @stable ICU 2.0
 844      */
 845     DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
 846                   UParseError&amp; parseError, UErrorCode&amp; status);
 847 
 848     /**
 849      * Create a DecimalFormat from the given pattern and symbols.
 850      * Use this constructor when you need to completely customize the
 851      * behavior of the format.
 852      * &lt;P&gt;
 853      * To obtain standard formats for a given
 854      * locale, use the factory methods on NumberFormat such as
 855      * createInstance or createCurrencyInstance. If you need only minor adjustments
 856      * to a standard format, you can modify the format returned by
 857      * a NumberFormat factory method.
 858      * &lt;p&gt;
 859      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<span class="line-modified"> 860      * #icu::number::NumberFormatter instead of DecimalFormat.</span>
 861      *
 862      * @param pattern           a non-localized pattern string
 863      * @param symbols   the set of symbols to be used
 864      * @param status            Output param set to success/failure code. If the
 865      *                          pattern is invalid this will be set to a failure code.
 866      * @stable ICU 2.0
 867      */
 868     DecimalFormat(const UnicodeString&amp; pattern, const DecimalFormatSymbols&amp; symbols, UErrorCode&amp; status);
 869 
 870     /**
 871      * Copy constructor.
 872      *
 873      * @param source    the DecimalFormat object to be copied from.
 874      * @stable ICU 2.0
 875      */
 876     DecimalFormat(const DecimalFormat&amp; source);
 877 
 878     /**
 879      * Assignment operator.
 880      *
</pre>
<hr />
<pre>
 962      *
 963      * @param number    The value to be formatted.
 964      * @param appendTo  Output parameter to receive result.
 965      *                  Result is appended to existing contents.
 966      * @param pos       On input: an alignment field, if desired.
 967      *                  On output: the offsets of the alignment field.
 968      * @return          Reference to &#39;appendTo&#39; parameter.
 969      * @stable ICU 2.0
 970      */
 971     UnicodeString&amp; format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const U_OVERRIDE;
 972 
 973 #ifndef U_HIDE_INTERNAL_API
 974     /**
 975      * Format a long number using base-10 representation.
 976      *
 977      * @param number    The value to be formatted.
 978      * @param appendTo  Output parameter to receive result.
 979      *                  Result is appended to existing contents.
 980      * @param pos       On input: an alignment field, if desired.
 981      *                  On output: the offsets of the alignment field.
<span class="line-added"> 982      * @param status    Output param filled with success/failure status.</span>
 983      * @return          Reference to &#39;appendTo&#39; parameter.
 984      * @internal
 985      */
 986     UnicodeString&amp; format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 987                           UErrorCode&amp; status) const U_OVERRIDE;
 988 #endif  /* U_HIDE_INTERNAL_API */
 989 
 990     /**
 991      * Format a long number using base-10 representation.
 992      *
 993      * @param number    The value to be formatted.
 994      * @param appendTo  Output parameter to receive result.
 995      *                  Result is appended to existing contents.
 996      * @param posIter   On return, can be used to iterate over positions
 997      *                  of fields generated by this format call.
 998      *                  Can be NULL.
 999      * @param status    Output param filled with success/failure status.
1000      * @return          Reference to &#39;appendTo&#39; parameter.
1001      * @stable ICU 4.4
1002      */
</pre>
<hr />
<pre>
1008      *
1009      * @param number    The value to be formatted.
1010      * @param appendTo  Output parameter to receive result.
1011      *                  Result is appended to existing contents.
1012      * @param pos       On input: an alignment field, if desired.
1013      *                  On output: the offsets of the alignment field.
1014      * @return          Reference to &#39;appendTo&#39; parameter.
1015      * @stable ICU 2.8
1016      */
1017     UnicodeString&amp; format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const U_OVERRIDE;
1018 
1019 #ifndef U_HIDE_INTERNAL_API
1020     /**
1021      * Format an int64 number using base-10 representation.
1022      *
1023      * @param number    The value to be formatted.
1024      * @param appendTo  Output parameter to receive result.
1025      *                  Result is appended to existing contents.
1026      * @param pos       On input: an alignment field, if desired.
1027      *                  On output: the offsets of the alignment field.
<span class="line-added">1028      * @param status    Output param filled with success/failure status.</span>
1029      * @return          Reference to &#39;appendTo&#39; parameter.
1030      * @internal
1031      */
1032     UnicodeString&amp; format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
1033                           UErrorCode&amp; status) const U_OVERRIDE;
1034 #endif  /* U_HIDE_INTERNAL_API */
1035 
1036     /**
1037      * Format an int64 number using base-10 representation.
1038      *
1039      * @param number    The value to be formatted.
1040      * @param appendTo  Output parameter to receive result.
1041      *                  Result is appended to existing contents.
1042      * @param posIter   On return, can be used to iterate over positions
1043      *                  of fields generated by this format call.
1044      *                  Can be NULL.
1045      * @param status    Output param filled with success/failure status.
1046      * @return          Reference to &#39;appendTo&#39; parameter.
1047      * @stable ICU 4.4
1048      */
</pre>
<hr />
<pre>
1098      * @param appendTo  Output parameter to receive result.
1099      *                  Result is appended to existing contents.
1100      * @param pos       On input: an alignment field, if desired.
1101      *                  On output: the offsets of the alignment field.
1102      * @param status    Output param filled with success/failure status.
1103      * @return          Reference to &#39;appendTo&#39; parameter.
1104      * @internal
1105      */
1106     UnicodeString&amp; format(const number::impl::DecimalQuantity&amp; number, UnicodeString&amp; appendTo,
1107                           FieldPosition&amp; pos, UErrorCode&amp; status) const U_OVERRIDE;
1108 
1109 #endif // U_HIDE_INTERNAL_API
1110 
1111     using NumberFormat::parse;
1112 
1113     /**
1114      * Parse the given string using this object&#39;s choices. The method
1115      * does string comparisons to try to find an optimal match.
1116      * If no object can be parsed, index is unchanged, and NULL is
1117      * returned.  The result is returned as the most parsimonious
<span class="line-modified">1118      * type of Formattable that will accommodate all of the</span>
1119      * necessary precision.  For example, if the result is exactly 12,
1120      * it will be returned as a long.  However, if it is 1.5, it will
1121      * be returned as a double.
1122      *
1123      * @param text           The text to be parsed.
1124      * @param result         Formattable to be set to the parse result.
1125      *                       If parse fails, return contents are undefined.
1126      * @param parsePosition  The position to start parsing at on input.
1127      *                       On output, moved to after the last successfully
1128      *                       parse character. On parse failure, does not change.
1129      * @see Formattable
1130      * @stable ICU 2.0
1131      */
1132     void parse(const UnicodeString&amp; text, Formattable&amp; result,
1133                ParsePosition&amp; parsePosition) const U_OVERRIDE;
1134 
1135     /**
1136      * Parses text from the given string as a currency amount.  Unlike
1137      * the parse() method, this method will attempt to parse a generic
1138      * currency name, searching for a match of this object&#39;s locale&#39;s
</pre>
<hr />
<pre>
1263 
1264     /**
1265      * Get the negative suffix.
1266      *
1267      * @param result    Output param which will receive the negative suffix.
1268      * @return          A reference to &#39;result&#39;.
1269      * Examples: -123%, ($123) (with positive suffixes)
1270      * @stable ICU 2.0
1271      */
1272     UnicodeString&amp; getNegativeSuffix(UnicodeString&amp; result) const;
1273 
1274     /**
1275      * Set the negative suffix.
1276      *
1277      * @param newValue    the new value of the negative suffix to be set.
1278      * Examples: 123%
1279      * @stable ICU 2.0
1280      */
1281     virtual void setNegativeSuffix(const UnicodeString&amp; newValue);
1282 
<span class="line-modified">1283 #ifndef U_HIDE_DRAFT_API</span>
1284     /**
1285      * Whether to show the plus sign on positive (non-negative) numbers; for example, &quot;+12&quot;
<span class="line-modified">1286      *</span>
<span class="line-added">1287      * For more control over sign display, use NumberFormatter.</span>
<span class="line-added">1288      *</span>
<span class="line-added">1289      * @return Whether the sign is shown on positive numbers and zero.</span>
<span class="line-added">1290      * @draft ICU 64</span>
1291      */
1292     UBool isSignAlwaysShown() const;

1293 
1294     /**
<span class="line-modified">1295      * Set whether to show the plus sign on positive (non-negative) numbers; for example, &quot;+12&quot;.</span>
<span class="line-modified">1296      *</span>
<span class="line-modified">1297      * For more control over sign display, use NumberFormatter.</span>
<span class="line-added">1298      *</span>
<span class="line-added">1299      * @param value true to always show a sign; false to hide the sign on positive numbers and zero.</span>
<span class="line-added">1300      * @draft ICU 64</span>
1301      */
<span class="line-modified">1302     void setSignAlwaysShown(UBool value);</span>
<span class="line-added">1303 #endif  /* U_HIDE_DRAFT_API */</span>
1304 
1305     /**
1306      * Get the multiplier for use in percent, permill, etc.
1307      * For a percentage, set the suffixes to have &quot;%&quot; and the multiplier to be 100.
1308      * (For Arabic, use arabic percent symbol).
1309      * For a permill, set the suffixes to have &quot;\\u2031&quot; and the multiplier to be 1000.
1310      *
1311      * The number may also be multiplied by a power of ten; see getMultiplierScale().
1312      *
1313      * @return    the multiplier for use in percent, permill, etc.
1314      * Examples: with 100, 1.23 -&gt; &quot;123&quot;, and &quot;123&quot; -&gt; 1.23
1315      * @stable ICU 2.0
1316      */
1317     int32_t getMultiplier(void) const;
1318 
1319     /**
1320      * Set the multiplier for use in percent, permill, etc.
1321      * For a percentage, set the suffixes to have &quot;%&quot; and the multiplier to be 100.
1322      * (For Arabic, use arabic percent symbol).
1323      * For a permill, set the suffixes to have &quot;\\u2031&quot; and the multiplier to be 1000.
</pre>
<hr />
<pre>
1328      * @param newValue    the new value of the multiplier for use in percent, permill, etc.
1329      * Examples: with 100, 1.23 -&gt; &quot;123&quot;, and &quot;123&quot; -&gt; 1.23
1330      * @stable ICU 2.0
1331      */
1332     virtual void setMultiplier(int32_t newValue);
1333 
1334 #ifndef U_HIDE_DRAFT_API
1335     /**
1336      * Gets the power of ten by which number should be multiplied before formatting, which
1337      * can be combined with setMultiplier() to multiply by any arbitrary decimal value.
1338      *
1339      * A multiplier scale of 2 corresponds to multiplication by 100, and a multiplier scale
1340      * of -2 corresponds to multiplication by 0.01.
1341      *
1342      * This method is analogous to UNUM_SCALE in getAttribute.
1343      *
1344      * @return    the current value of the power-of-ten multiplier.
1345      * @draft ICU 62
1346      */
1347     int32_t getMultiplierScale(void) const;

1348 
1349     /**
1350      * Sets a power of ten by which number should be multiplied before formatting, which
1351      * can be combined with setMultiplier() to multiply by any arbitrary decimal value.
1352      *
1353      * A multiplier scale of 2 corresponds to multiplication by 100, and a multiplier scale
1354      * of -2 corresponds to multiplication by 0.01.
1355      *
1356      * For example, to multiply numbers by 0.5 before formatting, you can do:
1357      *
1358      * &lt;pre&gt;
1359      * df.setMultiplier(5);
1360      * df.setMultiplierScale(-1);
1361      * &lt;/pre&gt;
1362      *
1363      * This method is analogous to UNUM_SCALE in setAttribute.
1364      *
1365      * @param newValue    the new value of the power-of-ten multiplier.
1366      * @draft ICU 62
1367      */
<span class="line-modified">1368     void setMultiplierScale(int32_t newValue);</span>
<span class="line-added">1369 #endif  /* U_HIDE_DRAFT_API */</span>
1370 
1371     /**
1372      * Get the rounding increment.
1373      * @return A positive rounding increment, or 0.0 if a custom rounding
1374      * increment is not in effect.
1375      * @see #setRoundingIncrement
1376      * @see #getRoundingMode
1377      * @see #setRoundingMode
1378      * @stable ICU 2.0
1379      */
1380     virtual double getRoundingIncrement(void) const;
1381 
1382     /**
1383      * Set the rounding increment.  In the absence of a rounding increment,
1384      *    numbers will be rounded to the number of digits displayed.
1385      * @param newValue A positive rounding increment, or 0.0 to
1386      * use the default rounding increment.
1387      * Negative increments are equivalent to 0.0.
1388      * @see #getRoundingIncrement
1389      * @see #getRoundingMode
</pre>
<hr />
<pre>
1442     virtual void setFormatWidth(int32_t width);
1443 
1444     /**
1445      * Get the pad character used to pad to the format width.  The
1446      * default is &#39; &#39;.
1447      * @return a string containing the pad character. This will always
1448      * have a length of one 32-bit code point.
1449      * @see #setFormatWidth
1450      * @see #getFormatWidth
1451      * @see #setPadCharacter
1452      * @see #getPadPosition
1453      * @see #setPadPosition
1454      * @stable ICU 2.0
1455      */
1456     virtual UnicodeString getPadCharacterString() const;
1457 
1458     /**
1459      * Set the character used to pad to the format width.  If padding
1460      * is not enabled, then this will take effect if padding is later
1461      * enabled.
<span class="line-modified">1462      * @param padChar a string containing the pad character. If the string</span>
<span class="line-modified">1463      * has length 0, then the pad character is set to &#39; &#39;.  Otherwise</span>
1464      * padChar.char32At(0) will be used as the pad character.
1465      * @see #setFormatWidth
1466      * @see #getFormatWidth
1467      * @see #getPadCharacterString
1468      * @see #getPadPosition
1469      * @see #setPadPosition
1470      * @stable ICU 2.0
1471      */
1472     virtual void setPadCharacter(const UnicodeString&amp; padChar);
1473 
1474     /**
1475      * Get the position at which padding will take place.  This is the location
1476      * at which padding will be inserted if the result of format()
1477      * is shorter than the format width.
1478      * @return the pad position, one of kPadBeforePrefix,
1479      * kPadAfterPrefix, kPadBeforeSuffix, or
1480      * kPadAfterSuffix.
1481      * @see #setFormatWidth
1482      * @see #getFormatWidth
1483      * @see #setPadCharacter
</pre>
<hr />
<pre>
1632      * @see setSecondaryGroupingSize
1633      * @see NumberFormat::isGroupingUsed
1634      * @see DecimalFormatSymbols::getGroupingSeparator
1635      * @stable ICU 2.4
1636      */
1637     int32_t getSecondaryGroupingSize(void) const;
1638 
1639     /**
1640      * Set the secondary grouping size. If set to a value less than 1,
1641      * then secondary grouping is turned off, and the primary grouping
1642      * size is used for all intervals, not just the least significant.
1643      *
1644      * @param newValue    the new value of the secondary grouping size.
1645      * @see getSecondaryGroupingSize
1646      * @see NumberFormat#setGroupingUsed
1647      * @see DecimalFormatSymbols::setGroupingSeparator
1648      * @stable ICU 2.4
1649      */
1650     virtual void setSecondaryGroupingSize(int32_t newValue);
1651 
<span class="line-modified">1652 #ifndef U_HIDE_DRAFT_API</span>

1653     /**
1654      * Returns the minimum number of grouping digits.
1655      * Grouping separators are output if there are at least this many
1656      * digits to the left of the first (rightmost) grouping separator,
1657      * that is, there are at least (minimum grouping + grouping size) integer digits.
1658      * (Subject to isGroupingUsed().)
1659      *
1660      * For example, if this value is 2, and the grouping size is 3, then
1661      * 9999 -&gt; &quot;9999&quot; and 10000 -&gt; &quot;10,000&quot;
1662      *


1663      * The default value for this attribute is 0.
1664      * A value of 1, 0, or lower, means that the use of grouping separators
1665      * only depends on the grouping size (and on isGroupingUsed()).
<span class="line-modified">1666      *</span>
<span class="line-added">1667      * NOTE: The CLDR data is used in NumberFormatter but not in DecimalFormat.</span>
<span class="line-added">1668      * This is for backwards compatibility reasons.</span>
<span class="line-added">1669      *</span>
<span class="line-added">1670      * For more control over grouping strategies, use NumberFormatter.</span>
1671      *
1672      * @see setMinimumGroupingDigits
1673      * @see getGroupingSize
<span class="line-modified">1674      * @draft ICU 64</span>
1675      */
1676     int32_t getMinimumGroupingDigits() const;
1677 



1678     /**
1679      * Sets the minimum grouping digits. Setting to a value less than or
1680      * equal to 1 turns off minimum grouping digits.
1681      *
<span class="line-added">1682      * For more control over grouping strategies, use NumberFormatter.</span>
<span class="line-added">1683      *</span>
1684      * @param newValue the new value of minimum grouping digits.
1685      * @see getMinimumGroupingDigits
<span class="line-modified">1686      * @draft ICU 64</span>
1687      */
<span class="line-modified">1688     void setMinimumGroupingDigits(int32_t newValue);</span>
<span class="line-added">1689 #endif  /* U_HIDE_DRAFT_API */</span>
1690 
1691 
1692     /**
1693      * Allows you to get the behavior of the decimal separator with integers.
1694      * (The decimal separator will always appear with decimals.)
1695      *
1696      * @return    TRUE if the decimal separator always appear with decimals.
1697      * Example: Decimal ON: 12345 -&gt; 12345.; OFF: 12345 -&gt; 12345
1698      * @stable ICU 2.0
1699      */
1700     UBool isDecimalSeparatorAlwaysShown(void) const;
1701 
1702     /**
1703      * Allows you to set the behavior of the decimal separator with integers.
1704      * (The decimal separator will always appear with decimals.)
1705      *
1706      * @param newValue    set TRUE if the decimal separator will always appear with decimals.
1707      * Example: Decimal ON: 12345 -&gt; 12345.; OFF: 12345 -&gt; 12345
1708      * @stable ICU 2.0
1709      */
</pre>
<hr />
<pre>
1711 
1712     /**
1713      * Allows you to get the parse behavior of the pattern decimal mark.
1714      *
1715      * @return    TRUE if input must contain a match to decimal mark in pattern
1716      * @stable ICU 54
1717      */
1718     UBool isDecimalPatternMatchRequired(void) const;
1719 
1720     /**
1721      * Allows you to set the parse behavior of the pattern decimal mark.
1722      *
1723      * if TRUE, the input must have a decimal mark if one was specified in the pattern. When
1724      * FALSE the decimal mark may be omitted from the input.
1725      *
1726      * @param newValue    set TRUE if input must contain a match to decimal mark in pattern
1727      * @stable ICU 54
1728      */
1729     virtual void setDecimalPatternMatchRequired(UBool newValue);
1730 
<span class="line-added">1731 #ifndef U_HIDE_DRAFT_API</span>
1732     /**
<span class="line-modified">1733      * Returns whether to ignore exponents when parsing.</span>
1734      *
<span class="line-added">1735      * @return Whether to ignore exponents when parsing.</span>
1736      * @see #setParseNoExponent
<span class="line-modified">1737      * @draft ICU 64</span>
1738      */
<span class="line-modified">1739     UBool isParseNoExponent() const;</span>
1740 
1741     /**
<span class="line-modified">1742      * Specifies whether to stop parsing when an exponent separator is encountered. For</span>
1743      * example, parses &quot;123E4&quot; to 123 (with parse position 3) instead of 1230000 (with parse position
1744      * 5).
1745      *
1746      * @param value true to prevent exponents from being parsed; false to allow them to be parsed.
<span class="line-modified">1747      * @draft ICU 64</span>
1748      */
<span class="line-modified">1749     void setParseNoExponent(UBool value);</span>
1750 
1751     /**
<span class="line-modified">1752      * Returns whether parsing is sensitive to case (lowercase/uppercase).</span>
1753      *
<span class="line-added">1754      * @return Whether parsing is case-sensitive.</span>
1755      * @see #setParseCaseSensitive
<span class="line-modified">1756      * @draft ICU 64</span>
1757      */
<span class="line-modified">1758     UBool isParseCaseSensitive() const;</span>
1759 
1760     /**
<span class="line-modified">1761      * Whether to pay attention to case when parsing; default is to ignore case (perform</span>
1762      * case-folding). For example, &quot;A&quot; == &quot;a&quot; in case-insensitive but not case-sensitive mode.
1763      *
1764      * Currency symbols are never case-folded. For example, &quot;us$1.00&quot; will not parse in case-insensitive
1765      * mode, even though &quot;US$1.00&quot; parses.
1766      *
<span class="line-modified">1767      * @param value true to enable case-sensitive parsing (the default); false to force</span>
<span class="line-added">1768      *              case-sensitive parsing behavior.</span>
<span class="line-added">1769      * @draft ICU 64</span>
1770      */
<span class="line-modified">1771     void setParseCaseSensitive(UBool value);</span>
1772 
1773     /**
<span class="line-modified">1774      * Returns whether truncation of high-order integer digits should result in an error.</span>
1775      * By default, setMaximumIntegerDigits truncates high-order digits silently.
1776      *
<span class="line-added">1777      * @return Whether an error code is set if high-order digits are truncated.</span>
1778      * @see setFormatFailIfMoreThanMaxDigits
<span class="line-modified">1779      * @draft ICU 64</span>
1780      */
<span class="line-modified">1781     UBool isFormatFailIfMoreThanMaxDigits() const;</span>
1782 
1783     /**
<span class="line-modified">1784      * Sets whether truncation of high-order integer digits should result in an error.</span>
1785      * By default, setMaximumIntegerDigits truncates high-order digits silently.
1786      *
<span class="line-modified">1787      * @param value Whether to set an error code if high-order digits are truncated.</span>
<span class="line-added">1788      * @draft ICU 64</span>
1789      */
<span class="line-modified">1790     void setFormatFailIfMoreThanMaxDigits(UBool value);</span>
<span class="line-added">1791 #endif  /* U_HIDE_DRAFT_API */</span>
1792 
1793 
1794     /**
1795      * Synthesizes a pattern string that represents the current state
1796      * of this Format object.
1797      *
1798      * @param result    Output param which will receive the pattern.
1799      *                  Previous contents are deleted.
1800      * @return          A reference to &#39;result&#39;.
1801      * @see applyPattern
1802      * @stable ICU 2.0
1803      */
1804     virtual UnicodeString&amp; toPattern(UnicodeString&amp; result) const;
1805 
1806     /**
1807      * Synthesizes a localized pattern string that represents the current
1808      * state of this Format object.
1809      *
1810      * @param result    Output param which will receive the localized pattern.
1811      *                  Previous contents are deleted.
</pre>
<hr />
<pre>
2011      * amounts.  This takes effect immediately, if this format is a
2012      * currency format.  If this format is not a currency format, then
2013      * the currency is used if and when this object becomes a
2014      * currency format through the application of a new pattern.
2015      * @param theCurrency a 3-letter ISO code indicating new currency
2016      * to use.  It need not be null-terminated.  May be the empty
2017      * string or NULL to indicate no currency.
2018      * @param ec input-output error code
2019      * @stable ICU 3.0
2020      */
2021     void setCurrency(const char16_t* theCurrency, UErrorCode&amp; ec) U_OVERRIDE;
2022 
2023     /**
2024      * Sets the currency used to display currency amounts.  See
2025      * setCurrency(const char16_t*, UErrorCode&amp;).
2026      * @deprecated ICU 3.0. Use setCurrency(const char16_t*, UErrorCode&amp;).
2027      */
2028     virtual void setCurrency(const char16_t* theCurrency);
2029 
2030     /**
<span class="line-modified">2031      * Sets the `Currency Usage` object used to display currency.</span>
2032      * This takes effect immediately, if this format is a
2033      * currency format.
<span class="line-modified">2034      * @param newUsage new currency usage object to use.</span>
<span class="line-added">2035      * @param ec input-output error code</span>
2036      * @stable ICU 54
2037      */
2038     void setCurrencyUsage(UCurrencyUsage newUsage, UErrorCode* ec);
2039 
2040     /**
<span class="line-modified">2041      * Returns the `Currency Usage` object used to display currency</span>
2042      * @stable ICU 54
2043      */
2044     UCurrencyUsage getCurrencyUsage() const;
2045 
2046 #ifndef U_HIDE_INTERNAL_API
2047 
2048     /**
2049      *  Format a number and save it into the given DecimalQuantity.
2050      *  Internal, not intended for public use.
2051      *  @internal
2052      */
2053     void formatToDecimalQuantity(double number, number::impl::DecimalQuantity&amp; output,
2054                                  UErrorCode&amp; status) const;
2055 
2056     /**
2057      *  Get a DecimalQuantity corresponding to a formattable as it would be
2058      *  formatted by this DecimalFormat.
2059      *  Internal, not intended for public use.
2060      *  @internal
2061      */
2062     void formatToDecimalQuantity(const Formattable&amp; number, number::impl::DecimalQuantity&amp; output,
2063                                  UErrorCode&amp; status) const;
2064 
<span class="line-modified">2065 #endif  /* U_HIDE_INTERNAL_API */</span>
2066 
2067 #ifndef U_HIDE_DRAFT_API
2068     /**
<span class="line-modified">2069      * Converts this DecimalFormat to a (Localized)NumberFormatter. Starting</span>
<span class="line-modified">2070      * in ICU 60, NumberFormatter is the recommended way to format numbers.</span>
<span class="line-added">2071      * You can use the returned LocalizedNumberFormatter to format numbers and</span>
<span class="line-added">2072      * get a FormattedNumber, which contains a string as well as additional</span>
<span class="line-added">2073      * annotations about the formatted value.</span>
<span class="line-added">2074      *</span>
<span class="line-added">2075      * If a memory allocation failure occurs, the return value of this method</span>
<span class="line-added">2076      * might be null. If you are concerned about correct recovery from</span>
<span class="line-added">2077      * out-of-memory situations, use this pattern:</span>
<span class="line-added">2078      *</span>
<span class="line-added">2079      * &lt;pre&gt;</span>
<span class="line-added">2080      * FormattedNumber result;</span>
<span class="line-added">2081      * if (auto* ptr = df-&gt;toNumberFormatter(status)) {</span>
<span class="line-added">2082      *     result = ptr-&gt;formatDouble(123, status);</span>
<span class="line-added">2083      * }</span>
<span class="line-added">2084      * &lt;/pre&gt;</span>
<span class="line-added">2085      *</span>
<span class="line-added">2086      * If you are not concerned about out-of-memory situations, or if your</span>
<span class="line-added">2087      * environment throws exceptions when memory allocation failure occurs,</span>
<span class="line-added">2088      * you can chain the methods, like this:</span>
<span class="line-added">2089      *</span>
<span class="line-added">2090      * &lt;pre&gt;</span>
<span class="line-added">2091      * FormattedNumber result = df</span>
<span class="line-added">2092      *     -&gt;toNumberFormatter(status)</span>
<span class="line-added">2093      *     -&gt;formatDouble(123, status);</span>
<span class="line-added">2094      * &lt;/pre&gt;</span>
2095      *
2096      * NOTE: The returned LocalizedNumberFormatter is owned by this DecimalFormat.
2097      * If a non-const method is called on the DecimalFormat, or if the DecimalFormat
2098      * is deleted, the object becomes invalid. If you plan to keep the return value
2099      * beyond the lifetime of the DecimalFormat, copy it to a local variable:
2100      *
2101      * &lt;pre&gt;
<span class="line-modified">2102      * LocalizedNumberFormatter lnf;</span>
<span class="line-added">2103      * if (auto* ptr = df-&gt;toNumberFormatter(status)) {</span>
<span class="line-added">2104      *     lnf = *ptr;</span>
<span class="line-added">2105      * }</span>
2106      * &lt;/pre&gt;
2107      *
<span class="line-modified">2108      * @param status Set on failure, like U_MEMORY_ALLOCATION_ERROR.</span>
<span class="line-added">2109      * @return A pointer to an internal object, or nullptr on failure.</span>
<span class="line-added">2110      *         Do not delete the return value!</span>
<span class="line-added">2111      * @draft ICU 64</span>
<span class="line-added">2112      */</span>
<span class="line-added">2113     const number::LocalizedNumberFormatter* toNumberFormatter(UErrorCode&amp; status) const;</span>
<span class="line-added">2114 #endif  /* U_HIDE_DRAFT_API */</span>
<span class="line-added">2115 </span>
<span class="line-added">2116 #ifndef U_HIDE_DEPRECATED_API</span>
<span class="line-added">2117     /**</span>
<span class="line-added">2118      * Deprecated: Like {@link #toNumberFormatter(UErrorCode&amp;) const},</span>
<span class="line-added">2119      * but does not take an error code.</span>
2120      *
<span class="line-modified">2121      * The new signature should be used in case an error occurs while returning the</span>
<span class="line-modified">2122      * LocalizedNumberFormatter.</span>

2123      *
<span class="line-modified">2124      * This old signature will be removed in ICU 65.</span>
<span class="line-modified">2125      *</span>
<span class="line-modified">2126      * @return A reference to an internal object.</span>
<span class="line-added">2127      * @deprecated ICU 64</span>
2128      */
2129     const number::LocalizedNumberFormatter&amp; toNumberFormatter() const;
<span class="line-modified">2130 #endif  /* U_HIDE_DEPRECATED_API */</span>
2131 
2132     /**
2133      * Return the class ID for this class.  This is useful only for
2134      * comparing to a return value from getDynamicClassID().  For example:
2135      * &lt;pre&gt;
2136      * .      Base* polymorphic_pointer = createPolymorphicObject();
2137      * .      if (polymorphic_pointer-&gt;getDynamicClassID() ==
2138      * .          Derived::getStaticClassID()) ...
2139      * &lt;/pre&gt;
2140      * @return          The class ID for all objects of this class.
2141      * @stable ICU 2.0
2142      */
2143     static UClassID U_EXPORT2 getStaticClassID(void);
2144 
2145     /**
2146      * Returns a unique class ID POLYMORPHICALLY.  Pure virtual override.
2147      * This method is to implement a simple version of RTTI, since not all
2148      * C++ compilers support genuine RTTI.  Polymorphic operator==() and
2149      * clone() methods call this method.
2150      *
2151      * @return          The class ID for this object. All objects of a
2152      *                  given class have the same class ID.  Objects of
2153      *                  other classes have different class IDs.
2154      * @stable ICU 2.0
2155      */
2156     UClassID getDynamicClassID(void) const U_OVERRIDE;
2157 
2158   private:
2159 
2160     /** Rebuilds the formatter object from the property bag. */
2161     void touch(UErrorCode&amp; status);
2162 
<span class="line-modified">2163     /** Rebuilds the formatter object, ignoring any error code. */</span>
2164     void touchNoError();
2165 
2166     /**
2167      * Updates the property bag with settings from the given pattern.
2168      *
2169      * @param pattern The pattern string to parse.
2170      * @param ignoreRounding Whether to leave out rounding information (minFrac, maxFrac, and rounding
2171      *     increment) when parsing the pattern. This may be desirable if a custom rounding mode, such
2172      *     as CurrencyUsage, is to be used instead. One of {@link
2173      *     PatternStringParser#IGNORE_ROUNDING_ALWAYS}, {@link PatternStringParser#IGNORE_ROUNDING_IF_CURRENCY},
2174      *     or {@link PatternStringParser#IGNORE_ROUNDING_NEVER}.
2175      * @see PatternAndPropertyUtils#parseToExistingProperties
2176      */
2177     void setPropertiesFromPattern(const UnicodeString&amp; pattern, int32_t ignoreRounding,
2178                                   UErrorCode&amp; status);
2179 
2180     const numparse::impl::NumberParserImpl* getParser(UErrorCode&amp; status) const;
2181 
2182     const numparse::impl::NumberParserImpl* getCurrencyParser(UErrorCode&amp; status) const;
2183 
2184     static void fieldPositionHelper(const number::FormattedNumber&amp; formatted, FieldPosition&amp; fieldPosition,
2185                                     int32_t offset, UErrorCode&amp; status);
2186 
2187     static void fieldPositionIteratorHelper(const number::FormattedNumber&amp; formatted,
2188                                             FieldPositionIterator* fpi, int32_t offset, UErrorCode&amp; status);
2189 
2190     void setupFastFormat();
2191 
2192     bool fastFormatDouble(double input, UnicodeString&amp; output) const;
2193 
2194     bool fastFormatInt64(int64_t input, UnicodeString&amp; output) const;
2195 
2196     void doFastFormatInt32(int32_t input, bool isNegative, UnicodeString&amp; output) const;
2197 
2198     //=====================================================================================//
2199     //                                   INSTANCE FIELDS                                   //
2200     //=====================================================================================//
2201 
<span class="line-modified">2202 </span>
<span class="line-modified">2203     // One instance field for the implementation, keep all fields inside of an implementation</span>
<span class="line-added">2204     // class defined in number_mapper.h</span>
<span class="line-added">2205     number::impl::DecimalFormatFields* fields = nullptr;</span>
2206 
2207     // Allow child class CompactDecimalFormat to access fProperties:
2208     friend class CompactDecimalFormat;
2209 
<span class="line-added">2210     // Allow MeasureFormat to use fieldPositionHelper:</span>
<span class="line-added">2211     friend class MeasureFormat;</span>
<span class="line-added">2212 </span>
2213 };
2214 
2215 U_NAMESPACE_END
2216 
2217 #endif /* #if !UCONFIG_NO_FORMATTING */
2218 
2219 #endif // _DECIMFMT
2220 //eof
</pre>
</td>
</tr>
</table>
<center><a href="dcfmtsym.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="dtitvfmt.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>