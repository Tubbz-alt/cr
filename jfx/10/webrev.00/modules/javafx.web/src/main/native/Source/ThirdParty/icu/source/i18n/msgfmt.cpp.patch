diff a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/msgfmt.cpp b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/msgfmt.cpp
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/msgfmt.cpp
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/msgfmt.cpp
@@ -808,30 +808,35 @@
     // This old API returns an array (which we hold) of Format*
     // pointers.  The array is valid up to the next call to any
     // method on this object.  We construct and resize an array
     // on demand that contains aliases to the subformats[i].format
     // pointers.
+
+    // Get total required capacity first (it's refreshed on each call).
+    int32_t totalCapacity = 0;
+    for (int32_t partIndex = 0; (partIndex = nextTopLevelArgStart(partIndex)) >= 0; ++totalCapacity) {};
+
     MessageFormat* t = const_cast<MessageFormat*> (this);
     cnt = 0;
-    if (formatAliases == NULL) {
-        t->formatAliasesCapacity = (argTypeCount<10) ? 10 : argTypeCount;
+    if (formatAliases == nullptr) {
+        t->formatAliasesCapacity = totalCapacity;
         Format** a = (Format**)
             uprv_malloc(sizeof(Format*) * formatAliasesCapacity);
-        if (a == NULL) {
+        if (a == nullptr) {
             t->formatAliasesCapacity = 0;
-            return NULL;
+            return nullptr;
         }
         t->formatAliases = a;
-    } else if (argTypeCount > formatAliasesCapacity) {
+    } else if (totalCapacity > formatAliasesCapacity) {
         Format** a = (Format**)
-            uprv_realloc(formatAliases, sizeof(Format*) * argTypeCount);
-        if (a == NULL) {
+            uprv_realloc(formatAliases, sizeof(Format*) * totalCapacity);
+        if (a == nullptr) {
             t->formatAliasesCapacity = 0;
-            return NULL;
+            return nullptr;
         }
         t->formatAliases = a;
-        t->formatAliasesCapacity = argTypeCount;
+        t->formatAliasesCapacity = totalCapacity;
     }
 
     for (int32_t partIndex = 0; (partIndex = nextTopLevelArgStart(partIndex)) >= 0;) {
         t->formatAliases[cnt++] = getCachedFormatter(partIndex);
     }
@@ -1076,11 +1081,11 @@
             } else {
                 // Do not use the formatted (number-offset) string for a named argument
                 // that formats the number without subtracting the offset.
                 appendTo.formatAndAppend(pluralNumber.formatter, *arg, success);
             }
-        } else if ((formatter = getCachedFormatter(i -2))) {
+        } else if ((formatter = getCachedFormatter(i -2)) != 0) {
             // Handles all ArgType.SIMPLE, and formatters from setFormat() and its siblings.
             if (dynamic_cast<const ChoiceFormat*>(formatter) ||
                 dynamic_cast<const PluralFormat*>(formatter) ||
                 dynamic_cast<const SelectFormat*>(formatter)) {
                 // We only handle nested formats here if they were provided via
@@ -1671,20 +1676,20 @@
             argTypes[argNumber] = formattableType;
         }
     }
 }
 
-
 Format* MessageFormat::createAppropriateFormat(UnicodeString& type, UnicodeString& style,
                                                Formattable::Type& formattableType, UParseError& parseError,
                                                UErrorCode& ec) {
     if (U_FAILURE(ec)) {
         return NULL;
+    int32_t firstNonSpace;
 
     switch (typeID = findKeyword(type, TYPE_IDS)) {
     case 0: // number
         formattableType = Formattable::kDouble;
         switch (findKeyword(style, NUMBER_STYLE_IDS)) {
@@ -1700,15 +1705,14 @@
         case 3: // integer
             formattableType = Formattable::kLong;
             fmt = createIntegerFormat(fLocale, ec);
             break;
         default: // pattern or skeleton
-            int32_t i = 0;
-            for (; PatternProps::isWhiteSpace(style.charAt(i)); i++);
-            if (style.compare(i, 2, u"::", 0, 2) == 0) {
+            firstNonSpace = PatternProps::skipWhiteSpace(style, 0);
+            if (style.compare(firstNonSpace, 2, u"::", 0, 2) == 0) {
                 // Skeleton
-                UnicodeString skeleton = style.tempSubString(i + 2);
+                UnicodeString skeleton = style.tempSubString(firstNonSpace + 2);
                 fmt = number::NumberFormatter::forSkeleton(skeleton, ec).locale(fLocale).toFormat(ec);
             } else {
                 // Pattern
                 fmt = NumberFormat::createInstance(fLocale, ec);
                 if (fmt) {
@@ -1723,23 +1727,31 @@
         break;
 
     case 1: // date
     case 2: // time
         formattableType = Formattable::kDate;
-        styleID = findKeyword(style, DATE_STYLE_IDS);
-        date_style = (styleID >= 0) ? DATE_STYLES[styleID] : DateFormat::kDefault;
-
-        if (typeID == 1) {
-            fmt = DateFormat::createDateInstance(date_style, fLocale);
+        firstNonSpace = PatternProps::skipWhiteSpace(style, 0);
+        if (style.compare(firstNonSpace, 2, u"::", 0, 2) == 0) {
+            // Skeleton
+            UnicodeString skeleton = style.tempSubString(firstNonSpace + 2);
+            fmt = DateFormat::createInstanceForSkeleton(skeleton, fLocale, ec);
         } else {
-            fmt = DateFormat::createTimeInstance(date_style, fLocale);
-        }
+            // Pattern
+            styleID = findKeyword(style, DATE_STYLE_IDS);
+            date_style = (styleID >= 0) ? DATE_STYLES[styleID] : DateFormat::kDefault;
 
-        if (styleID < 0 && fmt != NULL) {
-            SimpleDateFormat* sdtfmt = dynamic_cast<SimpleDateFormat*>(fmt);
-            if (sdtfmt != NULL) {
-                sdtfmt->applyPattern(style);
+            if (typeID == 1) {
+                fmt = DateFormat::createDateInstance(date_style, fLocale);
+            } else {
+                fmt = DateFormat::createTimeInstance(date_style, fLocale);
+            }
+
+            if (styleID < 0 && fmt != NULL) {
+                SimpleDateFormat* sdtfmt = dynamic_cast<SimpleDateFormat*>(fmt);
+                if (sdtfmt != NULL) {
+                    sdtfmt->applyPattern(style);
+                }
             }
         }
         break;
 
     case 3: // spellout
