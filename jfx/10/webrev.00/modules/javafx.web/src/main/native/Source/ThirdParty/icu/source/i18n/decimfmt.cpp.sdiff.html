<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/decimfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="decNumberLocal.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion-bignum-dtoa.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/decimfmt.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14 #include &lt;stdlib.h&gt;
  15 #include &quot;unicode/errorcode.h&quot;
  16 #include &quot;unicode/decimfmt.h&quot;
  17 #include &quot;number_decimalquantity.h&quot;
  18 #include &quot;number_types.h&quot;
  19 #include &quot;numparse_impl.h&quot;
  20 #include &quot;number_mapper.h&quot;
  21 #include &quot;number_patternstring.h&quot;
  22 #include &quot;putilimp.h&quot;
  23 #include &quot;number_utils.h&quot;
  24 #include &quot;number_utypes.h&quot;
  25 
  26 using namespace icu;
  27 using namespace icu::number;
  28 using namespace icu::number::impl;
  29 using namespace icu::numparse;
  30 using namespace icu::numparse::impl;
  31 using ERoundingMode = icu::DecimalFormat::ERoundingMode;
  32 using EPadPosition = icu::DecimalFormat::EPadPosition;
  33 
<span class="line-modified">  34 // MSVC warns C4805 when comparing bool with UBool</span>
  35 // TODO: Move this macro into a better place?
  36 #if U_PF_WINDOWS &lt;= U_PLATFORM &amp;&amp; U_PLATFORM &lt;= U_PF_CYGWIN
  37 #define UBOOL_TO_BOOL(b) static_cast&lt;bool&gt;(b)
  38 #else
  39 #define UBOOL_TO_BOOL(b) b
  40 #endif
  41 
  42 
  43 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DecimalFormat)
  44 
  45 
  46 DecimalFormat::DecimalFormat(UErrorCode&amp; status)
  47         : DecimalFormat(nullptr, status) {

  48     // Use the default locale and decimal pattern.
  49     const char* localeName = Locale::getDefault().getName();
  50     LocalPointer&lt;NumberingSystem&gt; ns(NumberingSystem::createInstance(status));
  51     UnicodeString patternString = utils::getPatternForStyle(
  52             localeName,
  53             ns-&gt;getName(),
  54             CLDR_PATTERN_STYLE_DECIMAL,
  55             status);
  56     setPropertiesFromPattern(patternString, IGNORE_ROUNDING_IF_CURRENCY, status);
  57     touch(status);
  58 }
  59 
  60 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, UErrorCode&amp; status)
  61         : DecimalFormat(nullptr, status) {

  62     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
  63     touch(status);
  64 }
  65 
  66 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
  67                              UErrorCode&amp; status)
  68         : DecimalFormat(symbolsToAdopt, status) {

  69     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
  70     touch(status);
  71 }
  72 
  73 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
  74                              UNumberFormatStyle style, UErrorCode&amp; status)
  75         : DecimalFormat(symbolsToAdopt, status) {

  76     // If choice is a currency type, ignore the rounding information.
<span class="line-modified">  77     if (style == UNumberFormatStyle::UNUM_CURRENCY || style == UNumberFormatStyle::UNUM_CURRENCY_ISO ||</span>

  78         style == UNumberFormatStyle::UNUM_CURRENCY_ACCOUNTING ||
  79         style == UNumberFormatStyle::UNUM_CASH_CURRENCY ||
  80         style == UNumberFormatStyle::UNUM_CURRENCY_STANDARD ||
  81         style == UNumberFormatStyle::UNUM_CURRENCY_PLURAL) {
  82         setPropertiesFromPattern(pattern, IGNORE_ROUNDING_ALWAYS, status);
  83     } else {
  84         setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
  85     }
  86     // Note: in Java, CurrencyPluralInfo is set in NumberFormat.java, but in C++, it is not set there,
  87     // so we have to set it here.
  88     if (style == UNumberFormatStyle::UNUM_CURRENCY_PLURAL) {
  89         LocalPointer&lt;CurrencyPluralInfo&gt; cpi(
  90                 new CurrencyPluralInfo(fields-&gt;symbols-&gt;getLocale(), status),
  91                 status);
  92         if (U_FAILURE(status)) { return; }
  93         fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(cpi.orphan());
  94     }
  95     touch(status);
  96 }
  97 
  98 DecimalFormat::DecimalFormat(const DecimalFormatSymbols* symbolsToAdopt, UErrorCode&amp; status) {

  99     LocalPointer&lt;const DecimalFormatSymbols&gt; adoptedSymbols(symbolsToAdopt);
<span class="line-removed"> 100     fields = new DecimalFormatFields();</span>
 101     if (U_FAILURE(status)) {
 102         return;
 103     }

 104     if (fields == nullptr) {
 105         status = U_MEMORY_ALLOCATION_ERROR;
 106         return;
 107     }

 108     fields-&gt;properties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);
 109     fields-&gt;exportedProperties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);
 110     if (adoptedSymbols.isNull()) {
 111         fields-&gt;symbols.adoptInsteadAndCheckErrorCode(new DecimalFormatSymbols(status), status);
 112     } else {
 113         fields-&gt;symbols.adoptInsteadAndCheckErrorCode(adoptedSymbols.orphan(), status);
 114     }








 115 }
 116 
 117 #if UCONFIG_HAVE_PARSEALLINPUT
 118 
 119 void DecimalFormat::setParseAllInput(UNumberFormatAttributeValue value) {

 120     if (value == fields-&gt;properties-&gt;parseAllInput) { return; }
 121     fields-&gt;properties-&gt;parseAllInput = value;
 122 }
 123 
 124 #endif
 125 
 126 DecimalFormat&amp;
 127 DecimalFormat::setAttribute(UNumberFormatAttribute attr, int32_t newValue, UErrorCode&amp; status) {
 128     if (U_FAILURE(status)) { return *this; }
 129 






 130     switch (attr) {
 131         case UNUM_LENIENT_PARSE:
 132             setLenient(newValue != 0);
 133             break;
 134 
 135         case UNUM_PARSE_INT_ONLY:
 136             setParseIntegerOnly(newValue != 0);
 137             break;
 138 
 139         case UNUM_GROUPING_USED:
 140             setGroupingUsed(newValue != 0);
 141             break;
 142 
 143         case UNUM_DECIMAL_ALWAYS_SHOWN:
 144             setDecimalSeparatorAlwaysShown(newValue != 0);
 145             break;
 146 
 147         case UNUM_MAX_INTEGER_DIGITS:
 148             setMaximumIntegerDigits(newValue);
 149             break;
</pre>
<hr />
<pre>
 237             setParseCaseSensitive(static_cast&lt;UBool&gt;(newValue));
 238             break;
 239 
 240         case UNUM_SIGN_ALWAYS_SHOWN:
 241             setSignAlwaysShown(static_cast&lt;UBool&gt;(newValue));
 242             break;
 243 
 244         case UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS:
 245             setFormatFailIfMoreThanMaxDigits(static_cast&lt;UBool&gt;(newValue));
 246             break;
 247 
 248         default:
 249             status = U_UNSUPPORTED_ERROR;
 250             break;
 251     }
 252     return *this;
 253 }
 254 
 255 int32_t DecimalFormat::getAttribute(UNumberFormatAttribute attr, UErrorCode&amp; status) const {
 256     if (U_FAILURE(status)) { return -1; }







 257     switch (attr) {
 258         case UNUM_LENIENT_PARSE:
 259             return isLenient();
 260 
 261         case UNUM_PARSE_INT_ONLY:
 262             return isParseIntegerOnly();
 263 
 264         case UNUM_GROUPING_USED:
 265             return isGroupingUsed();
 266 
 267         case UNUM_DECIMAL_ALWAYS_SHOWN:
 268             return isDecimalSeparatorAlwaysShown();
 269 
 270         case UNUM_MAX_INTEGER_DIGITS:
 271             return getMaximumIntegerDigits();
 272 
 273         case UNUM_MIN_INTEGER_DIGITS:
 274             return getMinimumIntegerDigits();
 275 
 276         case UNUM_INTEGER_DIGITS:
</pre>
<hr />
<pre>
 330             return getMinimumGroupingDigits();
 331 
 332         case UNUM_PARSE_CASE_SENSITIVE:
 333             return isParseCaseSensitive();
 334 
 335         case UNUM_SIGN_ALWAYS_SHOWN:
 336             return isSignAlwaysShown();
 337 
 338         case UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS:
 339             return isFormatFailIfMoreThanMaxDigits();
 340 
 341         default:
 342             status = U_UNSUPPORTED_ERROR;
 343             break;
 344     }
 345 
 346     return -1; /* undefined */
 347 }
 348 
 349 void DecimalFormat::setGroupingUsed(UBool enabled) {



 350     if (UBOOL_TO_BOOL(enabled) == fields-&gt;properties-&gt;groupingUsed) { return; }
 351     NumberFormat::setGroupingUsed(enabled); // to set field for compatibility
 352     fields-&gt;properties-&gt;groupingUsed = enabled;
 353     touchNoError();
 354 }
 355 
 356 void DecimalFormat::setParseIntegerOnly(UBool value) {



 357     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseIntegerOnly) { return; }
 358     NumberFormat::setParseIntegerOnly(value); // to set field for compatibility
 359     fields-&gt;properties-&gt;parseIntegerOnly = value;
 360     touchNoError();
 361 }
 362 
 363 void DecimalFormat::setLenient(UBool enable) {



 364     ParseMode mode = enable ? PARSE_MODE_LENIENT : PARSE_MODE_STRICT;
 365     if (!fields-&gt;properties-&gt;parseMode.isNull() &amp;&amp; mode == fields-&gt;properties-&gt;parseMode.getNoError()) { return; }
 366     NumberFormat::setLenient(enable); // to set field for compatibility
 367     fields-&gt;properties-&gt;parseMode = mode;
 368     touchNoError();
 369 }
 370 
 371 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
 372                              UParseError&amp;, UErrorCode&amp; status)
 373         : DecimalFormat(symbolsToAdopt, status) {

 374     // TODO: What is parseError for?
 375     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
 376     touch(status);
 377 }
 378 
 379 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, const DecimalFormatSymbols&amp; symbols,
 380                              UErrorCode&amp; status)
<span class="line-modified"> 381         : DecimalFormat(new DecimalFormatSymbols(symbols), status) {</span>











 382     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
 383     touch(status);
 384 }
 385 
 386 DecimalFormat::DecimalFormat(const DecimalFormat&amp; source) : NumberFormat(source) {




 387     // Note: it is not safe to copy fields-&gt;formatter or fWarehouse directly because fields-&gt;formatter might have
 388     // dangling pointers to fields inside fWarehouse. The safe thing is to re-construct fields-&gt;formatter from
 389     // the property bag, despite being somewhat slower.
 390     fields = new DecimalFormatFields();
 391     if (fields == nullptr) {
<span class="line-modified"> 392         return;</span>
 393     }
<span class="line-modified"> 394     fields-&gt;properties.adoptInstead(new DecimalFormatProperties(*source.fields-&gt;properties));</span>
<span class="line-modified"> 395     fields-&gt;symbols.adoptInstead(new DecimalFormatSymbols(*source.fields-&gt;symbols));</span>
<span class="line-modified"> 396     fields-&gt;exportedProperties.adoptInstead(new DecimalFormatProperties());</span>
<span class="line-modified"> 397     if (fields-&gt;properties == nullptr || fields-&gt;symbols == nullptr || fields-&gt;exportedProperties == nullptr) {</span>







 398         return;
 399     }
<span class="line-modified"> 400     touchNoError();</span>
 401 }
 402 
 403 DecimalFormat&amp; DecimalFormat::operator=(const DecimalFormat&amp; rhs) {








 404     *fields-&gt;properties = *rhs.fields-&gt;properties;
 405     fields-&gt;exportedProperties-&gt;clear();
<span class="line-modified"> 406     fields-&gt;symbols.adoptInstead(new DecimalFormatSymbols(*rhs.fields-&gt;symbols));</span>
<span class="line-modified"> 407     touchNoError();</span>










 408     return *this;
 409 }
 410 
 411 DecimalFormat::~DecimalFormat() {


 412     delete fields-&gt;atomicParser.exchange(nullptr);
 413     delete fields-&gt;atomicCurrencyParser.exchange(nullptr);
 414     delete fields;
 415 }
 416 
 417 Format* DecimalFormat::clone() const {
<span class="line-modified"> 418     return new DecimalFormat(*this);</span>








 419 }
 420 
 421 UBool DecimalFormat::operator==(const Format&amp; other) const {
 422     auto* otherDF = dynamic_cast&lt;const DecimalFormat*&gt;(&amp;other);
 423     if (otherDF == nullptr) {
 424         return false;
 425     }





 426     return *fields-&gt;properties == *otherDF-&gt;fields-&gt;properties &amp;&amp; *fields-&gt;symbols == *otherDF-&gt;fields-&gt;symbols;
 427 }
 428 
 429 UnicodeString&amp; DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {




 430     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatDouble(number, appendTo)) {
 431         return appendTo;
 432     }
 433     UErrorCode localStatus = U_ZERO_ERROR;
 434     FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, localStatus);
 435     fieldPositionHelper(output, pos, appendTo.length(), localStatus);
 436     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 437     output.appendTo(appendable);</span>
 438     return appendTo;
 439 }
 440 
 441 UnicodeString&amp; DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 442                                      UErrorCode&amp; status) const {









 443     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatDouble(number, appendTo)) {
 444         return appendTo;
 445     }
 446     FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, status);
 447     fieldPositionHelper(output, pos, appendTo.length(), status);
 448     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 449     output.appendTo(appendable);</span>
 450     return appendTo;
 451 }
 452 
 453 UnicodeString&amp;
 454 DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 455                       UErrorCode&amp; status) const {









 456     if (posIter == nullptr &amp;&amp; fastFormatDouble(number, appendTo)) {
 457         return appendTo;
 458     }
 459     FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, status);
 460     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 461     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 462     output.appendTo(appendable);</span>
 463     return appendTo;
 464 }
 465 
 466 UnicodeString&amp; DecimalFormat::format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
 467     return format(static_cast&lt;int64_t&gt; (number), appendTo, pos);
 468 }
 469 
 470 UnicodeString&amp; DecimalFormat::format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 471                                      UErrorCode&amp; status) const {
 472     return format(static_cast&lt;int64_t&gt; (number), appendTo, pos, status);
 473 }
 474 
 475 UnicodeString&amp;
 476 DecimalFormat::format(int32_t number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 477                       UErrorCode&amp; status) const {
 478     return format(static_cast&lt;int64_t&gt; (number), appendTo, posIter, status);
 479 }
 480 
 481 UnicodeString&amp; DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {




 482     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatInt64(number, appendTo)) {
 483         return appendTo;
 484     }
 485     UErrorCode localStatus = U_ZERO_ERROR;
 486     FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, localStatus);
 487     fieldPositionHelper(output, pos, appendTo.length(), localStatus);
 488     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 489     output.appendTo(appendable);</span>
 490     return appendTo;
 491 }
 492 
 493 UnicodeString&amp; DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 494                                      UErrorCode&amp; status) const {









 495     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatInt64(number, appendTo)) {
 496         return appendTo;
 497     }
 498     FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, status);
 499     fieldPositionHelper(output, pos, appendTo.length(), status);
 500     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 501     output.appendTo(appendable);</span>
 502     return appendTo;
 503 }
 504 
 505 UnicodeString&amp;
 506 DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 507                       UErrorCode&amp; status) const {









 508     if (posIter == nullptr &amp;&amp; fastFormatInt64(number, appendTo)) {
 509         return appendTo;
 510     }
 511     FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, status);
 512     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 513     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 514     output.appendTo(appendable);</span>
 515     return appendTo;
 516 }
 517 
 518 UnicodeString&amp;
 519 DecimalFormat::format(StringPiece number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 520                       UErrorCode&amp; status) const {









 521     FormattedNumber output = fields-&gt;formatter-&gt;formatDecimal(number, status);
 522     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 523     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 524     output.appendTo(appendable);</span>
 525     return appendTo;
 526 }
 527 
 528 UnicodeString&amp; DecimalFormat::format(const DecimalQuantity&amp; number, UnicodeString&amp; appendTo,
 529                                      FieldPositionIterator* posIter, UErrorCode&amp; status) const {









 530     FormattedNumber output = fields-&gt;formatter-&gt;formatDecimalQuantity(number, status);
 531     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 532     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 533     output.appendTo(appendable);</span>
 534     return appendTo;
 535 }
 536 
 537 UnicodeString&amp;
 538 DecimalFormat::format(const DecimalQuantity&amp; number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 539                       UErrorCode&amp; status) const {









 540     FormattedNumber output = fields-&gt;formatter-&gt;formatDecimalQuantity(number, status);
 541     fieldPositionHelper(output, pos, appendTo.length(), status);
 542     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 543     output.appendTo(appendable);</span>
 544     return appendTo;
 545 }
 546 
 547 void DecimalFormat::parse(const UnicodeString&amp; text, Formattable&amp; output,
 548                           ParsePosition&amp; parsePosition) const {



 549     if (parsePosition.getIndex() &lt; 0 || parsePosition.getIndex() &gt;= text.length()) {




 550         return;
 551     }
 552 
 553     ErrorCode status;
 554     ParsedNumber result;
 555     // Note: if this is a currency instance, currencies will be matched despite the fact that we are not in the
 556     // parseCurrency method (backwards compatibility)
 557     int32_t startIndex = parsePosition.getIndex();
 558     const NumberParserImpl* parser = getParser(status);
<span class="line-modified"> 559     if (U_FAILURE(status)) { return; }</span>


 560     parser-&gt;parse(text, startIndex, true, result, status);



 561     // TODO: Do we need to check for fImpl-&gt;properties-&gt;parseAllInput (UCONFIG_HAVE_PARSEALLINPUT) here?
 562     if (result.success()) {
 563         parsePosition.setIndex(result.charEnd);
 564         result.populateFormattable(output, parser-&gt;getParseFlags());
 565     } else {
 566         parsePosition.setErrorIndex(startIndex + result.charEnd);
 567     }
 568 }
 569 
 570 CurrencyAmount* DecimalFormat::parseCurrency(const UnicodeString&amp; text, ParsePosition&amp; parsePosition) const {



 571     if (parsePosition.getIndex() &lt; 0 || parsePosition.getIndex() &gt;= text.length()) {
 572         return nullptr;
 573     }
 574 
 575     ErrorCode status;
 576     ParsedNumber result;
 577     // Note: if this is a currency instance, currencies will be matched despite the fact that we are not in the
 578     // parseCurrency method (backwards compatibility)
 579     int32_t startIndex = parsePosition.getIndex();
 580     const NumberParserImpl* parser = getCurrencyParser(status);
<span class="line-modified"> 581     if (U_FAILURE(status)) { return nullptr; }</span>


 582     parser-&gt;parse(text, startIndex, true, result, status);



 583     // TODO: Do we need to check for fImpl-&gt;properties-&gt;parseAllInput (UCONFIG_HAVE_PARSEALLINPUT) here?
 584     if (result.success()) {
 585         parsePosition.setIndex(result.charEnd);
 586         Formattable formattable;
 587         result.populateFormattable(formattable, parser-&gt;getParseFlags());
<span class="line-modified"> 588         return new CurrencyAmount(formattable, result.currencyCode, status);</span>





 589     } else {
 590         parsePosition.setErrorIndex(startIndex + result.charEnd);
 591         return nullptr;
 592     }
 593 }
 594 
 595 const DecimalFormatSymbols* DecimalFormat::getDecimalFormatSymbols(void) const {



 596     return fields-&gt;symbols.getAlias();
 597 }
 598 
 599 void DecimalFormat::adoptDecimalFormatSymbols(DecimalFormatSymbols* symbolsToAdopt) {
 600     if (symbolsToAdopt == nullptr) {
 601         return; // do not allow caller to set fields-&gt;symbols to NULL
 602     }
<span class="line-modified"> 603     fields-&gt;symbols.adoptInstead(symbolsToAdopt);</span>





 604     touchNoError();
 605 }
 606 
 607 void DecimalFormat::setDecimalFormatSymbols(const DecimalFormatSymbols&amp; symbols) {
<span class="line-modified"> 608     fields-&gt;symbols.adoptInstead(new DecimalFormatSymbols(symbols));</span>












 609     touchNoError();
 610 }
 611 
 612 const CurrencyPluralInfo* DecimalFormat::getCurrencyPluralInfo(void) const {



 613     return fields-&gt;properties-&gt;currencyPluralInfo.fPtr.getAlias();
 614 }
 615 
 616 void DecimalFormat::adoptCurrencyPluralInfo(CurrencyPluralInfo* toAdopt) {
<span class="line-modified"> 617     fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(toAdopt);</span>






 618     touchNoError();
 619 }
 620 
 621 void DecimalFormat::setCurrencyPluralInfo(const CurrencyPluralInfo&amp; info) {



 622     if (fields-&gt;properties-&gt;currencyPluralInfo.fPtr.isNull()) {

 623         fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(info.clone());
 624     } else {
 625         *fields-&gt;properties-&gt;currencyPluralInfo.fPtr = info; // copy-assignment operator
 626     }
 627     touchNoError();
 628 }
 629 
 630 UnicodeString&amp; DecimalFormat::getPositivePrefix(UnicodeString&amp; result) const {
<span class="line-modified"> 631     ErrorCode localStatus;</span>
<span class="line-modified"> 632     fields-&gt;formatter-&gt;getAffixImpl(true, false, result, localStatus);</span>





 633     return result;
 634 }
 635 
 636 void DecimalFormat::setPositivePrefix(const UnicodeString&amp; newValue) {



 637     if (newValue == fields-&gt;properties-&gt;positivePrefix) { return; }
 638     fields-&gt;properties-&gt;positivePrefix = newValue;
 639     touchNoError();
 640 }
 641 
 642 UnicodeString&amp; DecimalFormat::getNegativePrefix(UnicodeString&amp; result) const {
<span class="line-modified"> 643     ErrorCode localStatus;</span>
<span class="line-modified"> 644     fields-&gt;formatter-&gt;getAffixImpl(true, true, result, localStatus);</span>





 645     return result;
 646 }
 647 
 648 void DecimalFormat::setNegativePrefix(const UnicodeString&amp; newValue) {



 649     if (newValue == fields-&gt;properties-&gt;negativePrefix) { return; }
 650     fields-&gt;properties-&gt;negativePrefix = newValue;
 651     touchNoError();
 652 }
 653 
 654 UnicodeString&amp; DecimalFormat::getPositiveSuffix(UnicodeString&amp; result) const {
<span class="line-modified"> 655     ErrorCode localStatus;</span>
<span class="line-modified"> 656     fields-&gt;formatter-&gt;getAffixImpl(false, false, result, localStatus);</span>





 657     return result;
 658 }
 659 
 660 void DecimalFormat::setPositiveSuffix(const UnicodeString&amp; newValue) {



 661     if (newValue == fields-&gt;properties-&gt;positiveSuffix) { return; }
 662     fields-&gt;properties-&gt;positiveSuffix = newValue;
 663     touchNoError();
 664 }
 665 
 666 UnicodeString&amp; DecimalFormat::getNegativeSuffix(UnicodeString&amp; result) const {
<span class="line-modified"> 667     ErrorCode localStatus;</span>
<span class="line-modified"> 668     fields-&gt;formatter-&gt;getAffixImpl(false, true, result, localStatus);</span>





 669     return result;
 670 }
 671 
 672 void DecimalFormat::setNegativeSuffix(const UnicodeString&amp; newValue) {



 673     if (newValue == fields-&gt;properties-&gt;negativeSuffix) { return; }
 674     fields-&gt;properties-&gt;negativeSuffix = newValue;
 675     touchNoError();
 676 }
 677 
 678 UBool DecimalFormat::isSignAlwaysShown() const {




 679     return fields-&gt;properties-&gt;signAlwaysShown;
 680 }
 681 
 682 void DecimalFormat::setSignAlwaysShown(UBool value) {

 683     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;signAlwaysShown) { return; }
 684     fields-&gt;properties-&gt;signAlwaysShown = value;
 685     touchNoError();
 686 }
 687 
 688 int32_t DecimalFormat::getMultiplier(void) const {
<span class="line-modified"> 689     if (fields-&gt;properties-&gt;multiplier != 1) {</span>
<span class="line-modified"> 690         return fields-&gt;properties-&gt;multiplier;</span>
<span class="line-modified"> 691     } else if (fields-&gt;properties-&gt;magnitudeMultiplier != 0) {</span>
<span class="line-modified"> 692         return static_cast&lt;int32_t&gt;(uprv_pow10(fields-&gt;properties-&gt;magnitudeMultiplier));</span>








 693     } else {
 694         return 1;
 695     }
 696 }
 697 
 698 void DecimalFormat::setMultiplier(int32_t multiplier) {



 699     if (multiplier == 0) {
 700         multiplier = 1;     // one being the benign default value for a multiplier.
 701     }
 702 
 703     // Try to convert to a magnitude multiplier first
 704     int delta = 0;
 705     int value = multiplier;
 706     while (value != 1) {
 707         delta++;
 708         int temp = value / 10;
 709         if (temp * 10 != value) {
 710             delta = -1;
 711             break;
 712         }
 713         value = temp;
 714     }
 715     if (delta != -1) {
 716         fields-&gt;properties-&gt;magnitudeMultiplier = delta;
 717         fields-&gt;properties-&gt;multiplier = 1;
 718     } else {
 719         fields-&gt;properties-&gt;magnitudeMultiplier = 0;
 720         fields-&gt;properties-&gt;multiplier = multiplier;
 721     }
 722     touchNoError();
 723 }
 724 
 725 int32_t DecimalFormat::getMultiplierScale() const {





 726     return fields-&gt;properties-&gt;multiplierScale;
 727 }
 728 
 729 void DecimalFormat::setMultiplierScale(int32_t newValue) {

 730     if (newValue == fields-&gt;properties-&gt;multiplierScale) { return; }
 731     fields-&gt;properties-&gt;multiplierScale = newValue;
 732     touchNoError();
 733 }
 734 
 735 double DecimalFormat::getRoundingIncrement(void) const {





 736     return fields-&gt;exportedProperties-&gt;roundingIncrement;
 737 }
 738 
 739 void DecimalFormat::setRoundingIncrement(double newValue) {

 740     if (newValue == fields-&gt;properties-&gt;roundingIncrement) { return; }
 741     fields-&gt;properties-&gt;roundingIncrement = newValue;
 742     touchNoError();
 743 }
 744 
 745 ERoundingMode DecimalFormat::getRoundingMode(void) const {





 746     // UNumberFormatRoundingMode and ERoundingMode have the same values.
 747     return static_cast&lt;ERoundingMode&gt;(fields-&gt;exportedProperties-&gt;roundingMode.getNoError());
 748 }
 749 
 750 void DecimalFormat::setRoundingMode(ERoundingMode roundingMode) {

 751     auto uRoundingMode = static_cast&lt;UNumberFormatRoundingMode&gt;(roundingMode);
 752     if (!fields-&gt;properties-&gt;roundingMode.isNull() &amp;&amp; uRoundingMode == fields-&gt;properties-&gt;roundingMode.getNoError()) {
 753         return;
 754     }
 755     NumberFormat::setMaximumIntegerDigits(roundingMode); // to set field for compatibility
 756     fields-&gt;properties-&gt;roundingMode = uRoundingMode;
 757     touchNoError();
 758 }
 759 
 760 int32_t DecimalFormat::getFormatWidth(void) const {





 761     return fields-&gt;properties-&gt;formatWidth;
 762 }
 763 
 764 void DecimalFormat::setFormatWidth(int32_t width) {

 765     if (width == fields-&gt;properties-&gt;formatWidth) { return; }
 766     fields-&gt;properties-&gt;formatWidth = width;
 767     touchNoError();
 768 }
 769 
 770 UnicodeString DecimalFormat::getPadCharacterString() const {
<span class="line-modified"> 771     if (fields-&gt;properties-&gt;padString.isBogus()) {</span>
 772         // Readonly-alias the static string kFallbackPaddingString
 773         return {TRUE, kFallbackPaddingString, -1};
 774     } else {
 775         return fields-&gt;properties-&gt;padString;
 776     }
 777 }
 778 
 779 void DecimalFormat::setPadCharacter(const UnicodeString&amp; padChar) {

 780     if (padChar == fields-&gt;properties-&gt;padString) { return; }
 781     if (padChar.length() &gt; 0) {
 782         fields-&gt;properties-&gt;padString = UnicodeString(padChar.char32At(0));
 783     } else {
 784         fields-&gt;properties-&gt;padString.setToBogus();
 785     }
 786     touchNoError();
 787 }
 788 
 789 EPadPosition DecimalFormat::getPadPosition(void) const {
<span class="line-modified"> 790     if (fields-&gt;properties-&gt;padPosition.isNull()) {</span>
 791         return EPadPosition::kPadBeforePrefix;
 792     } else {
 793         // UNumberFormatPadPosition and EPadPosition have the same values.
 794         return static_cast&lt;EPadPosition&gt;(fields-&gt;properties-&gt;padPosition.getNoError());
 795     }
 796 }
 797 
 798 void DecimalFormat::setPadPosition(EPadPosition padPos) {

 799     auto uPadPos = static_cast&lt;UNumberFormatPadPosition&gt;(padPos);
 800     if (!fields-&gt;properties-&gt;padPosition.isNull() &amp;&amp; uPadPos == fields-&gt;properties-&gt;padPosition.getNoError()) {
 801         return;
 802     }
 803     fields-&gt;properties-&gt;padPosition = uPadPos;
 804     touchNoError();
 805 }
 806 
 807 UBool DecimalFormat::isScientificNotation(void) const {
<span class="line-modified"> 808     return fields-&gt;properties-&gt;minimumExponentDigits != -1;</span>





 809 }
 810 
 811 void DecimalFormat::setScientificNotation(UBool useScientific) {

 812     int32_t minExp = useScientific ? 1 : -1;
 813     if (fields-&gt;properties-&gt;minimumExponentDigits == minExp) { return; }
 814     if (useScientific) {
 815         fields-&gt;properties-&gt;minimumExponentDigits = 1;
 816     } else {
 817         fields-&gt;properties-&gt;minimumExponentDigits = -1;
 818     }
 819     touchNoError();
 820 }
 821 
 822 int8_t DecimalFormat::getMinimumExponentDigits(void) const {





 823     return static_cast&lt;int8_t&gt;(fields-&gt;properties-&gt;minimumExponentDigits);
 824 }
 825 
 826 void DecimalFormat::setMinimumExponentDigits(int8_t minExpDig) {

 827     if (minExpDig == fields-&gt;properties-&gt;minimumExponentDigits) { return; }
 828     fields-&gt;properties-&gt;minimumExponentDigits = minExpDig;
 829     touchNoError();
 830 }
 831 
 832 UBool DecimalFormat::isExponentSignAlwaysShown(void) const {





 833     return fields-&gt;properties-&gt;exponentSignAlwaysShown;
 834 }
 835 
 836 void DecimalFormat::setExponentSignAlwaysShown(UBool expSignAlways) {

 837     if (UBOOL_TO_BOOL(expSignAlways) == fields-&gt;properties-&gt;exponentSignAlwaysShown) { return; }
 838     fields-&gt;properties-&gt;exponentSignAlwaysShown = expSignAlways;
 839     touchNoError();
 840 }
 841 
 842 int32_t DecimalFormat::getGroupingSize(void) const {
<span class="line-modified"> 843     if (fields-&gt;properties-&gt;groupingSize &lt; 0) {</span>








 844         return 0;
 845     }
<span class="line-modified"> 846     return fields-&gt;properties-&gt;groupingSize;</span>
 847 }
 848 
 849 void DecimalFormat::setGroupingSize(int32_t newValue) {

 850     if (newValue == fields-&gt;properties-&gt;groupingSize) { return; }
 851     fields-&gt;properties-&gt;groupingSize = newValue;
 852     touchNoError();
 853 }
 854 
 855 int32_t DecimalFormat::getSecondaryGroupingSize(void) const {
<span class="line-modified"> 856     int grouping2 = fields-&gt;properties-&gt;secondaryGroupingSize;</span>







 857     if (grouping2 &lt; 0) {
 858         return 0;
 859     }
 860     return grouping2;
 861 }
 862 
 863 void DecimalFormat::setSecondaryGroupingSize(int32_t newValue) {

 864     if (newValue == fields-&gt;properties-&gt;secondaryGroupingSize) { return; }
 865     fields-&gt;properties-&gt;secondaryGroupingSize = newValue;
 866     touchNoError();
 867 }
 868 
 869 int32_t DecimalFormat::getMinimumGroupingDigits() const {





 870     return fields-&gt;properties-&gt;minimumGroupingDigits;
 871 }
 872 
 873 void DecimalFormat::setMinimumGroupingDigits(int32_t newValue) {

 874     if (newValue == fields-&gt;properties-&gt;minimumGroupingDigits) { return; }
 875     fields-&gt;properties-&gt;minimumGroupingDigits = newValue;
 876     touchNoError();
 877 }
 878 
 879 UBool DecimalFormat::isDecimalSeparatorAlwaysShown(void) const {





 880     return fields-&gt;properties-&gt;decimalSeparatorAlwaysShown;
 881 }
 882 
 883 void DecimalFormat::setDecimalSeparatorAlwaysShown(UBool newValue) {

 884     if (UBOOL_TO_BOOL(newValue) == fields-&gt;properties-&gt;decimalSeparatorAlwaysShown) { return; }
 885     fields-&gt;properties-&gt;decimalSeparatorAlwaysShown = newValue;
 886     touchNoError();
 887 }
 888 
 889 UBool DecimalFormat::isDecimalPatternMatchRequired(void) const {





 890     return fields-&gt;properties-&gt;decimalPatternMatchRequired;
 891 }
 892 
 893 void DecimalFormat::setDecimalPatternMatchRequired(UBool newValue) {

 894     if (UBOOL_TO_BOOL(newValue) == fields-&gt;properties-&gt;decimalPatternMatchRequired) { return; }
 895     fields-&gt;properties-&gt;decimalPatternMatchRequired = newValue;
 896     touchNoError();
 897 }
 898 
 899 UBool DecimalFormat::isParseNoExponent() const {





 900     return fields-&gt;properties-&gt;parseNoExponent;
 901 }
 902 
 903 void DecimalFormat::setParseNoExponent(UBool value) {

 904     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseNoExponent) { return; }
 905     fields-&gt;properties-&gt;parseNoExponent = value;
 906     touchNoError();
 907 }
 908 
 909 UBool DecimalFormat::isParseCaseSensitive() const {





 910     return fields-&gt;properties-&gt;parseCaseSensitive;
 911 }
 912 
 913 void DecimalFormat::setParseCaseSensitive(UBool value) {

 914     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseCaseSensitive) { return; }
 915     fields-&gt;properties-&gt;parseCaseSensitive = value;
 916     touchNoError();
 917 }
 918 
 919 UBool DecimalFormat::isFormatFailIfMoreThanMaxDigits() const {





 920     return fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits;
 921 }
 922 
 923 void DecimalFormat::setFormatFailIfMoreThanMaxDigits(UBool value) {

 924     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits) { return; }
 925     fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits = value;
 926     touchNoError();
 927 }
 928 
 929 UnicodeString&amp; DecimalFormat::toPattern(UnicodeString&amp; result) const {





 930     // Pull some properties from exportedProperties and others from properties
 931     // to keep affix patterns intact.  In particular, pull rounding properties
 932     // so that CurrencyUsage is reflected properly.
 933     // TODO: Consider putting this logic in number_patternstring.cpp instead.
 934     ErrorCode localStatus;
 935     DecimalFormatProperties tprops(*fields-&gt;properties);
<span class="line-modified"> 936     bool useCurrency = ((!tprops.currency.isNull()) || !tprops.currencyPluralInfo.fPtr.isNull() ||</span>
<span class="line-modified"> 937                         !tprops.currencyUsage.isNull() || AffixUtils::hasCurrencySymbols(</span>
<span class="line-modified"> 938             tprops.positivePrefixPattern, localStatus) || AffixUtils::hasCurrencySymbols(</span>
<span class="line-modified"> 939             tprops.positiveSuffixPattern, localStatus) || AffixUtils::hasCurrencySymbols(</span>
<span class="line-modified"> 940             tprops.negativePrefixPattern, localStatus) || AffixUtils::hasCurrencySymbols(</span>
<span class="line-modified"> 941             tprops.negativeSuffixPattern, localStatus));</span>


 942     if (useCurrency) {
 943         tprops.minimumFractionDigits = fields-&gt;exportedProperties-&gt;minimumFractionDigits;
 944         tprops.maximumFractionDigits = fields-&gt;exportedProperties-&gt;maximumFractionDigits;
 945         tprops.roundingIncrement = fields-&gt;exportedProperties-&gt;roundingIncrement;
 946     }
 947     result = PatternStringUtils::propertiesToPatternString(tprops, localStatus);
 948     return result;
 949 }
 950 
 951 UnicodeString&amp; DecimalFormat::toLocalizedPattern(UnicodeString&amp; result) const {





 952     ErrorCode localStatus;
 953     result = toPattern(result);
 954     result = PatternStringUtils::convertLocalized(result, *fields-&gt;symbols, true, localStatus);
 955     return result;
 956 }
 957 
 958 void DecimalFormat::applyPattern(const UnicodeString&amp; pattern, UParseError&amp;, UErrorCode&amp; status) {
 959     // TODO: What is parseError for?
 960     applyPattern(pattern, status);
 961 }
 962 
 963 void DecimalFormat::applyPattern(const UnicodeString&amp; pattern, UErrorCode&amp; status) {







 964     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_NEVER, status);
 965     touch(status);
 966 }
 967 
 968 void DecimalFormat::applyLocalizedPattern(const UnicodeString&amp; localizedPattern, UParseError&amp;,
 969                                           UErrorCode&amp; status) {
 970     // TODO: What is parseError for?
 971     applyLocalizedPattern(localizedPattern, status);
 972 }
 973 
 974 void DecimalFormat::applyLocalizedPattern(const UnicodeString&amp; localizedPattern, UErrorCode&amp; status) {
<span class="line-modified"> 975     if (U_SUCCESS(status)) {</span>
<span class="line-modified"> 976         UnicodeString pattern = PatternStringUtils::convertLocalized(</span>
<span class="line-modified"> 977                 localizedPattern, *fields-&gt;symbols, false, status);</span>
<span class="line-modified"> 978         applyPattern(pattern, status);</span>


 979     }



 980 }
 981 
 982 void DecimalFormat::setMaximumIntegerDigits(int32_t newValue) {

 983     if (newValue == fields-&gt;properties-&gt;maximumIntegerDigits) { return; }
 984     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
 985     int32_t min = fields-&gt;properties-&gt;minimumIntegerDigits;
 986     if (min &gt;= 0 &amp;&amp; min &gt; newValue) {
 987         fields-&gt;properties-&gt;minimumIntegerDigits = newValue;
 988     }
 989     fields-&gt;properties-&gt;maximumIntegerDigits = newValue;
 990     touchNoError();
 991 }
 992 
 993 void DecimalFormat::setMinimumIntegerDigits(int32_t newValue) {

 994     if (newValue == fields-&gt;properties-&gt;minimumIntegerDigits) { return; }
 995     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
 996     int32_t max = fields-&gt;properties-&gt;maximumIntegerDigits;
 997     if (max &gt;= 0 &amp;&amp; max &lt; newValue) {
 998         fields-&gt;properties-&gt;maximumIntegerDigits = newValue;
 999     }
1000     fields-&gt;properties-&gt;minimumIntegerDigits = newValue;
1001     touchNoError();
1002 }
1003 
1004 void DecimalFormat::setMaximumFractionDigits(int32_t newValue) {

1005     if (newValue == fields-&gt;properties-&gt;maximumFractionDigits) { return; }
1006     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
1007     int32_t min = fields-&gt;properties-&gt;minimumFractionDigits;
1008     if (min &gt;= 0 &amp;&amp; min &gt; newValue) {
1009         fields-&gt;properties-&gt;minimumFractionDigits = newValue;
1010     }
1011     fields-&gt;properties-&gt;maximumFractionDigits = newValue;
1012     touchNoError();
1013 }
1014 
1015 void DecimalFormat::setMinimumFractionDigits(int32_t newValue) {

1016     if (newValue == fields-&gt;properties-&gt;minimumFractionDigits) { return; }
1017     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
1018     int32_t max = fields-&gt;properties-&gt;maximumFractionDigits;
1019     if (max &gt;= 0 &amp;&amp; max &lt; newValue) {
1020         fields-&gt;properties-&gt;maximumFractionDigits = newValue;
1021     }
1022     fields-&gt;properties-&gt;minimumFractionDigits = newValue;
1023     touchNoError();
1024 }
1025 
1026 int32_t DecimalFormat::getMinimumSignificantDigits() const {





1027     return fields-&gt;exportedProperties-&gt;minimumSignificantDigits;
1028 }
1029 
1030 int32_t DecimalFormat::getMaximumSignificantDigits() const {





1031     return fields-&gt;exportedProperties-&gt;maximumSignificantDigits;
1032 }
1033 
1034 void DecimalFormat::setMinimumSignificantDigits(int32_t value) {

1035     if (value == fields-&gt;properties-&gt;minimumSignificantDigits) { return; }
1036     int32_t max = fields-&gt;properties-&gt;maximumSignificantDigits;
1037     if (max &gt;= 0 &amp;&amp; max &lt; value) {
1038         fields-&gt;properties-&gt;maximumSignificantDigits = value;
1039     }
1040     fields-&gt;properties-&gt;minimumSignificantDigits = value;
1041     touchNoError();
1042 }
1043 
1044 void DecimalFormat::setMaximumSignificantDigits(int32_t value) {

1045     if (value == fields-&gt;properties-&gt;maximumSignificantDigits) { return; }
1046     int32_t min = fields-&gt;properties-&gt;minimumSignificantDigits;
1047     if (min &gt;= 0 &amp;&amp; min &gt; value) {
1048         fields-&gt;properties-&gt;minimumSignificantDigits = value;
1049     }
1050     fields-&gt;properties-&gt;maximumSignificantDigits = value;
1051     touchNoError();
1052 }
1053 
1054 UBool DecimalFormat::areSignificantDigitsUsed() const {
<span class="line-modified">1055     return fields-&gt;properties-&gt;minimumSignificantDigits != -1 || fields-&gt;properties-&gt;maximumSignificantDigits != -1;</span>








1056 }
1057 
1058 void DecimalFormat::setSignificantDigitsUsed(UBool useSignificantDigits) {


1059     // These are the default values from the old implementation.











1060     int32_t minSig = useSignificantDigits ? 1 : -1;
1061     int32_t maxSig = useSignificantDigits ? 6 : -1;
<span class="line-removed">1062     if (fields-&gt;properties-&gt;minimumSignificantDigits == minSig &amp;&amp;</span>
<span class="line-removed">1063         fields-&gt;properties-&gt;maximumSignificantDigits == maxSig) {</span>
<span class="line-removed">1064         return;</span>
<span class="line-removed">1065     }</span>
1066     fields-&gt;properties-&gt;minimumSignificantDigits = minSig;
1067     fields-&gt;properties-&gt;maximumSignificantDigits = maxSig;
1068     touchNoError();
1069 }
1070 
1071 void DecimalFormat::setCurrency(const char16_t* theCurrency, UErrorCode&amp; ec) {







1072     CurrencyUnit currencyUnit(theCurrency, ec);
1073     if (U_FAILURE(ec)) { return; }
1074     if (!fields-&gt;properties-&gt;currency.isNull() &amp;&amp; fields-&gt;properties-&gt;currency.getNoError() == currencyUnit) {
1075         return;
1076     }
1077     NumberFormat::setCurrency(theCurrency, ec); // to set field for compatibility
1078     fields-&gt;properties-&gt;currency = currencyUnit;
1079     // TODO: Set values in fields-&gt;symbols, too?
1080     touchNoError();
1081 }
1082 
1083 void DecimalFormat::setCurrency(const char16_t* theCurrency) {
1084     ErrorCode localStatus;
1085     setCurrency(theCurrency, localStatus);
1086 }
1087 
1088 void DecimalFormat::setCurrencyUsage(UCurrencyUsage newUsage, UErrorCode* ec) {
<span class="line-modified">1089     if (U_FAILURE(*ec)) {</span>




1090         return;
1091     }
1092     if (!fields-&gt;properties-&gt;currencyUsage.isNull() &amp;&amp; newUsage == fields-&gt;properties-&gt;currencyUsage.getNoError()) {
1093         return;
1094     }
1095     fields-&gt;properties-&gt;currencyUsage = newUsage;
1096     touch(*ec);
1097 }
1098 
1099 UCurrencyUsage DecimalFormat::getCurrencyUsage() const {
1100     // CurrencyUsage is not exported, so we have to get it from the input property bag.
1101     // TODO: Should we export CurrencyUsage instead?
<span class="line-modified">1102     if (fields-&gt;properties-&gt;currencyUsage.isNull()) {</span>
1103         return UCURR_USAGE_STANDARD;
1104     }
1105     return fields-&gt;properties-&gt;currencyUsage.getNoError();
1106 }
1107 
1108 void
1109 DecimalFormat::formatToDecimalQuantity(double number, DecimalQuantity&amp; output, UErrorCode&amp; status) const {







1110     fields-&gt;formatter-&gt;formatDouble(number, status).getDecimalQuantity(output, status);
1111 }
1112 
1113 void DecimalFormat::formatToDecimalQuantity(const Formattable&amp; number, DecimalQuantity&amp; output,
1114                                             UErrorCode&amp; status) const {







1115     UFormattedNumberData obj;
1116     number.populateDecimalQuantity(obj.quantity, status);
1117     fields-&gt;formatter-&gt;formatImpl(&amp;obj, status);
1118     output = std::move(obj.quantity);
1119 }
1120 











1121 const number::LocalizedNumberFormatter&amp; DecimalFormat::toNumberFormatter() const {
<span class="line-modified">1122     return *fields-&gt;formatter;</span>

1123 }
1124 
1125 /** Rebuilds the formatter object from the property bag. */
1126 void DecimalFormat::touch(UErrorCode&amp; status) {
<span class="line-modified">1127     if (fields-&gt;exportedProperties == nullptr) {</span>
<span class="line-modified">1128         // fields-&gt;exportedProperties is null only when the formatter is not ready yet.</span>
<span class="line-modified">1129         // The only time when this happens is during legacy deserialization.</span>






1130         return;
1131     }
1132 
1133     // In C++, fields-&gt;symbols is the source of truth for the locale.
1134     Locale locale = fields-&gt;symbols-&gt;getLocale();
1135 
1136     // Note: The formatter is relatively cheap to create, and we need it to populate fields-&gt;exportedProperties,
<span class="line-modified">1137     // so automatically compute it here. The parser is a bit more expensive and is not needed until the</span>
1138     // parse method is called, so defer that until needed.
1139     // TODO: Only update the pieces that changed instead of re-computing the whole formatter?
<span class="line-modified">1140     fields-&gt;formatter.adoptInstead(</span>
<span class="line-modified">1141             new LocalizedNumberFormatter(</span>
<span class="line-modified">1142                     NumberPropertyMapper::create(</span>
<span class="line-modified">1143                             *fields-&gt;properties, *fields-&gt;symbols, fields-&gt;warehouse, *fields-&gt;exportedProperties, status).locale(</span>
<span class="line-modified">1144                             locale)));</span>

1145 
1146     // Do this after fields-&gt;exportedProperties are set up
1147     setupFastFormat();
1148 
1149     // Delete the parsers if they were made previously
1150     delete fields-&gt;atomicParser.exchange(nullptr);
1151     delete fields-&gt;atomicCurrencyParser.exchange(nullptr);
1152 
1153     // In order for the getters to work, we need to populate some fields in NumberFormat.
1154     NumberFormat::setCurrency(fields-&gt;exportedProperties-&gt;currency.get(status).getISOCurrency(), status);
1155     NumberFormat::setMaximumIntegerDigits(fields-&gt;exportedProperties-&gt;maximumIntegerDigits);
1156     NumberFormat::setMinimumIntegerDigits(fields-&gt;exportedProperties-&gt;minimumIntegerDigits);
1157     NumberFormat::setMaximumFractionDigits(fields-&gt;exportedProperties-&gt;maximumFractionDigits);
1158     NumberFormat::setMinimumFractionDigits(fields-&gt;exportedProperties-&gt;minimumFractionDigits);
1159     // fImpl-&gt;properties, not fields-&gt;exportedProperties, since this information comes from the pattern:
1160     NumberFormat::setGroupingUsed(fields-&gt;properties-&gt;groupingUsed);
1161 }
1162 
1163 void DecimalFormat::touchNoError() {
1164     UErrorCode localStatus = U_ZERO_ERROR;
1165     touch(localStatus);
1166 }
1167 
1168 void DecimalFormat::setPropertiesFromPattern(const UnicodeString&amp; pattern, int32_t ignoreRounding,
1169                                              UErrorCode&amp; status) {
1170     if (U_SUCCESS(status)) {
1171         // Cast workaround to get around putting the enum in the public header file
1172         auto actualIgnoreRounding = static_cast&lt;IgnoreRounding&gt;(ignoreRounding);
1173         PatternParser::parseToExistingProperties(pattern, *fields-&gt;properties,  actualIgnoreRounding, status);
1174     }
1175 }
1176 
1177 const numparse::impl::NumberParserImpl* DecimalFormat::getParser(UErrorCode&amp; status) const {
<span class="line-modified">1178     if (U_FAILURE(status)) { return nullptr; }</span>





1179 
1180     // First try to get the pre-computed parser
1181     auto* ptr = fields-&gt;atomicParser.load();
1182     if (ptr != nullptr) {
1183         return ptr;
1184     }
1185 
1186     // Try computing the parser on our own
1187     auto* temp = NumberParserImpl::createParserFromProperties(*fields-&gt;properties, *fields-&gt;symbols, false, status);



1188     if (temp == nullptr) {
1189         status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified">1190         // although we may still dereference, call sites should be guarded</span>
1191     }
1192 
<span class="line-modified">1193     // Note: ptr starts as nullptr; during compare_exchange, it is set to what is actually stored in the</span>
<span class="line-modified">1194     // atomic if another thread beat us to computing the parser object.</span>

1195     auto* nonConstThis = const_cast&lt;DecimalFormat*&gt;(this);
1196     if (!nonConstThis-&gt;fields-&gt;atomicParser.compare_exchange_strong(ptr, temp)) {
1197         // Another thread beat us to computing the parser
1198         delete temp;
1199         return ptr;
1200     } else {
1201         // Our copy of the parser got stored in the atomic
1202         return temp;
1203     }
1204 }
1205 
1206 const numparse::impl::NumberParserImpl* DecimalFormat::getCurrencyParser(UErrorCode&amp; status) const {
1207     if (U_FAILURE(status)) { return nullptr; }
1208 
1209     // First try to get the pre-computed parser
1210     auto* ptr = fields-&gt;atomicCurrencyParser.load();
1211     if (ptr != nullptr) {
1212         return ptr;
1213     }
1214 
</pre>
<hr />
<pre>
1218         status = U_MEMORY_ALLOCATION_ERROR;
1219         // although we may still dereference, call sites should be guarded
1220     }
1221 
1222     // Note: ptr starts as nullptr; during compare_exchange, it is set to what is actually stored in the
1223     // atomic if another thread beat us to computing the parser object.
1224     auto* nonConstThis = const_cast&lt;DecimalFormat*&gt;(this);
1225     if (!nonConstThis-&gt;fields-&gt;atomicCurrencyParser.compare_exchange_strong(ptr, temp)) {
1226         // Another thread beat us to computing the parser
1227         delete temp;
1228         return ptr;
1229     } else {
1230         // Our copy of the parser got stored in the atomic
1231         return temp;
1232     }
1233 }
1234 
1235 void
1236 DecimalFormat::fieldPositionHelper(const number::FormattedNumber&amp; formatted, FieldPosition&amp; fieldPosition,
1237                                    int32_t offset, UErrorCode&amp; status) {

1238     // always return first occurrence:
1239     fieldPosition.setBeginIndex(0);
1240     fieldPosition.setEndIndex(0);
1241     bool found = formatted.nextFieldPosition(fieldPosition, status);
1242     if (found &amp;&amp; offset != 0) {
1243         FieldPositionOnlyHandler fpoh(fieldPosition);
1244         fpoh.shiftLast(offset);
1245     }
1246 }
1247 
1248 void
1249 DecimalFormat::fieldPositionIteratorHelper(const number::FormattedNumber&amp; formatted, FieldPositionIterator* fpi,
1250                                            int32_t offset, UErrorCode&amp; status) {
<span class="line-modified">1251     if (fpi != nullptr) {</span>
1252         FieldPositionIteratorHandler fpih(fpi, status);
1253         fpih.setShift(offset);
1254         formatted.getAllFieldPositionsImpl(fpih, status);
1255     }
1256 }
1257 
1258 // To debug fast-format, change void(x) to printf(x)
1259 #define trace(x) void(x)
1260 
1261 void DecimalFormat::setupFastFormat() {
1262     // Check the majority of properties:
1263     if (!fields-&gt;properties-&gt;equalsDefaultExceptFastFormat()) {
1264         trace(&quot;no fast format: equality\n&quot;);
1265         fields-&gt;canUseFastFormat = false;
1266         return;
1267     }
1268 
1269     // Now check the remaining properties.
1270     // Nontrivial affixes:
1271     UBool trivialPP = fields-&gt;properties-&gt;positivePrefixPattern.isEmpty();
</pre>
</td>
<td>
<hr />
<pre>
  14 #include &lt;stdlib.h&gt;
  15 #include &quot;unicode/errorcode.h&quot;
  16 #include &quot;unicode/decimfmt.h&quot;
  17 #include &quot;number_decimalquantity.h&quot;
  18 #include &quot;number_types.h&quot;
  19 #include &quot;numparse_impl.h&quot;
  20 #include &quot;number_mapper.h&quot;
  21 #include &quot;number_patternstring.h&quot;
  22 #include &quot;putilimp.h&quot;
  23 #include &quot;number_utils.h&quot;
  24 #include &quot;number_utypes.h&quot;
  25 
  26 using namespace icu;
  27 using namespace icu::number;
  28 using namespace icu::number::impl;
  29 using namespace icu::numparse;
  30 using namespace icu::numparse::impl;
  31 using ERoundingMode = icu::DecimalFormat::ERoundingMode;
  32 using EPadPosition = icu::DecimalFormat::EPadPosition;
  33 
<span class="line-modified">  34 // MSVC VS2015 warns C4805 when comparing bool with UBool, VS2017 no longer emits this warning.</span>
  35 // TODO: Move this macro into a better place?
  36 #if U_PF_WINDOWS &lt;= U_PLATFORM &amp;&amp; U_PLATFORM &lt;= U_PF_CYGWIN
  37 #define UBOOL_TO_BOOL(b) static_cast&lt;bool&gt;(b)
  38 #else
  39 #define UBOOL_TO_BOOL(b) b
  40 #endif
  41 
  42 
  43 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DecimalFormat)
  44 
  45 
  46 DecimalFormat::DecimalFormat(UErrorCode&amp; status)
  47         : DecimalFormat(nullptr, status) {
<span class="line-added">  48     if (U_FAILURE(status)) { return; }</span>
  49     // Use the default locale and decimal pattern.
  50     const char* localeName = Locale::getDefault().getName();
  51     LocalPointer&lt;NumberingSystem&gt; ns(NumberingSystem::createInstance(status));
  52     UnicodeString patternString = utils::getPatternForStyle(
  53             localeName,
  54             ns-&gt;getName(),
  55             CLDR_PATTERN_STYLE_DECIMAL,
  56             status);
  57     setPropertiesFromPattern(patternString, IGNORE_ROUNDING_IF_CURRENCY, status);
  58     touch(status);
  59 }
  60 
  61 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, UErrorCode&amp; status)
  62         : DecimalFormat(nullptr, status) {
<span class="line-added">  63     if (U_FAILURE(status)) { return; }</span>
  64     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
  65     touch(status);
  66 }
  67 
  68 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
  69                              UErrorCode&amp; status)
  70         : DecimalFormat(symbolsToAdopt, status) {
<span class="line-added">  71     if (U_FAILURE(status)) { return; }</span>
  72     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
  73     touch(status);
  74 }
  75 
  76 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
  77                              UNumberFormatStyle style, UErrorCode&amp; status)
  78         : DecimalFormat(symbolsToAdopt, status) {
<span class="line-added">  79     if (U_FAILURE(status)) { return; }</span>
  80     // If choice is a currency type, ignore the rounding information.
<span class="line-modified">  81     if (style == UNumberFormatStyle::UNUM_CURRENCY ||</span>
<span class="line-added">  82         style == UNumberFormatStyle::UNUM_CURRENCY_ISO ||</span>
  83         style == UNumberFormatStyle::UNUM_CURRENCY_ACCOUNTING ||
  84         style == UNumberFormatStyle::UNUM_CASH_CURRENCY ||
  85         style == UNumberFormatStyle::UNUM_CURRENCY_STANDARD ||
  86         style == UNumberFormatStyle::UNUM_CURRENCY_PLURAL) {
  87         setPropertiesFromPattern(pattern, IGNORE_ROUNDING_ALWAYS, status);
  88     } else {
  89         setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
  90     }
  91     // Note: in Java, CurrencyPluralInfo is set in NumberFormat.java, but in C++, it is not set there,
  92     // so we have to set it here.
  93     if (style == UNumberFormatStyle::UNUM_CURRENCY_PLURAL) {
  94         LocalPointer&lt;CurrencyPluralInfo&gt; cpi(
  95                 new CurrencyPluralInfo(fields-&gt;symbols-&gt;getLocale(), status),
  96                 status);
  97         if (U_FAILURE(status)) { return; }
  98         fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(cpi.orphan());
  99     }
 100     touch(status);
 101 }
 102 
 103 DecimalFormat::DecimalFormat(const DecimalFormatSymbols* symbolsToAdopt, UErrorCode&amp; status) {
<span class="line-added"> 104     // we must take ownership of symbolsToAdopt, even in a failure case.</span>
 105     LocalPointer&lt;const DecimalFormatSymbols&gt; adoptedSymbols(symbolsToAdopt);

 106     if (U_FAILURE(status)) {
 107         return;
 108     }
<span class="line-added"> 109     fields = new DecimalFormatFields();</span>
 110     if (fields == nullptr) {
 111         status = U_MEMORY_ALLOCATION_ERROR;
 112         return;
 113     }
<span class="line-added"> 114     fields-&gt;formatter.adoptInsteadAndCheckErrorCode(new LocalizedNumberFormatter(), status);</span>
 115     fields-&gt;properties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);
 116     fields-&gt;exportedProperties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);
 117     if (adoptedSymbols.isNull()) {
 118         fields-&gt;symbols.adoptInsteadAndCheckErrorCode(new DecimalFormatSymbols(status), status);
 119     } else {
 120         fields-&gt;symbols.adoptInsteadAndCheckErrorCode(adoptedSymbols.orphan(), status);
 121     }
<span class="line-added"> 122     // In order to simplify error handling logic in the various getters/setters/etc, we do not allow</span>
<span class="line-added"> 123     // any partially populated DecimalFormatFields object. We must have a fully complete fields object</span>
<span class="line-added"> 124     // or else we set it to nullptr.</span>
<span class="line-added"> 125     if (fields-&gt;formatter.isNull() || fields-&gt;properties.isNull() || fields-&gt;exportedProperties.isNull() || fields-&gt;symbols.isNull()) {</span>
<span class="line-added"> 126         delete fields;</span>
<span class="line-added"> 127         fields = nullptr;</span>
<span class="line-added"> 128         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 129     }</span>
 130 }
 131 
 132 #if UCONFIG_HAVE_PARSEALLINPUT
 133 
 134 void DecimalFormat::setParseAllInput(UNumberFormatAttributeValue value) {
<span class="line-added"> 135     if (fields == nullptr) { return; }</span>
 136     if (value == fields-&gt;properties-&gt;parseAllInput) { return; }
 137     fields-&gt;properties-&gt;parseAllInput = value;
 138 }
 139 
 140 #endif
 141 
 142 DecimalFormat&amp;
 143 DecimalFormat::setAttribute(UNumberFormatAttribute attr, int32_t newValue, UErrorCode&amp; status) {
 144     if (U_FAILURE(status)) { return *this; }
 145 
<span class="line-added"> 146     if (fields == nullptr) {</span>
<span class="line-added"> 147         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 148         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 149         return *this;</span>
<span class="line-added"> 150     }</span>
<span class="line-added"> 151 </span>
 152     switch (attr) {
 153         case UNUM_LENIENT_PARSE:
 154             setLenient(newValue != 0);
 155             break;
 156 
 157         case UNUM_PARSE_INT_ONLY:
 158             setParseIntegerOnly(newValue != 0);
 159             break;
 160 
 161         case UNUM_GROUPING_USED:
 162             setGroupingUsed(newValue != 0);
 163             break;
 164 
 165         case UNUM_DECIMAL_ALWAYS_SHOWN:
 166             setDecimalSeparatorAlwaysShown(newValue != 0);
 167             break;
 168 
 169         case UNUM_MAX_INTEGER_DIGITS:
 170             setMaximumIntegerDigits(newValue);
 171             break;
</pre>
<hr />
<pre>
 259             setParseCaseSensitive(static_cast&lt;UBool&gt;(newValue));
 260             break;
 261 
 262         case UNUM_SIGN_ALWAYS_SHOWN:
 263             setSignAlwaysShown(static_cast&lt;UBool&gt;(newValue));
 264             break;
 265 
 266         case UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS:
 267             setFormatFailIfMoreThanMaxDigits(static_cast&lt;UBool&gt;(newValue));
 268             break;
 269 
 270         default:
 271             status = U_UNSUPPORTED_ERROR;
 272             break;
 273     }
 274     return *this;
 275 }
 276 
 277 int32_t DecimalFormat::getAttribute(UNumberFormatAttribute attr, UErrorCode&amp; status) const {
 278     if (U_FAILURE(status)) { return -1; }
<span class="line-added"> 279 </span>
<span class="line-added"> 280     if (fields == nullptr) {</span>
<span class="line-added"> 281         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 282         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 283         return -1;</span>
<span class="line-added"> 284     }</span>
<span class="line-added"> 285 </span>
 286     switch (attr) {
 287         case UNUM_LENIENT_PARSE:
 288             return isLenient();
 289 
 290         case UNUM_PARSE_INT_ONLY:
 291             return isParseIntegerOnly();
 292 
 293         case UNUM_GROUPING_USED:
 294             return isGroupingUsed();
 295 
 296         case UNUM_DECIMAL_ALWAYS_SHOWN:
 297             return isDecimalSeparatorAlwaysShown();
 298 
 299         case UNUM_MAX_INTEGER_DIGITS:
 300             return getMaximumIntegerDigits();
 301 
 302         case UNUM_MIN_INTEGER_DIGITS:
 303             return getMinimumIntegerDigits();
 304 
 305         case UNUM_INTEGER_DIGITS:
</pre>
<hr />
<pre>
 359             return getMinimumGroupingDigits();
 360 
 361         case UNUM_PARSE_CASE_SENSITIVE:
 362             return isParseCaseSensitive();
 363 
 364         case UNUM_SIGN_ALWAYS_SHOWN:
 365             return isSignAlwaysShown();
 366 
 367         case UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS:
 368             return isFormatFailIfMoreThanMaxDigits();
 369 
 370         default:
 371             status = U_UNSUPPORTED_ERROR;
 372             break;
 373     }
 374 
 375     return -1; /* undefined */
 376 }
 377 
 378 void DecimalFormat::setGroupingUsed(UBool enabled) {
<span class="line-added"> 379     if (fields == nullptr) {</span>
<span class="line-added"> 380         return;</span>
<span class="line-added"> 381     }</span>
 382     if (UBOOL_TO_BOOL(enabled) == fields-&gt;properties-&gt;groupingUsed) { return; }
 383     NumberFormat::setGroupingUsed(enabled); // to set field for compatibility
 384     fields-&gt;properties-&gt;groupingUsed = enabled;
 385     touchNoError();
 386 }
 387 
 388 void DecimalFormat::setParseIntegerOnly(UBool value) {
<span class="line-added"> 389     if (fields == nullptr) {</span>
<span class="line-added"> 390         return;</span>
<span class="line-added"> 391     }</span>
 392     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseIntegerOnly) { return; }
 393     NumberFormat::setParseIntegerOnly(value); // to set field for compatibility
 394     fields-&gt;properties-&gt;parseIntegerOnly = value;
 395     touchNoError();
 396 }
 397 
 398 void DecimalFormat::setLenient(UBool enable) {
<span class="line-added"> 399     if (fields == nullptr) {</span>
<span class="line-added"> 400         return;</span>
<span class="line-added"> 401     }</span>
 402     ParseMode mode = enable ? PARSE_MODE_LENIENT : PARSE_MODE_STRICT;
 403     if (!fields-&gt;properties-&gt;parseMode.isNull() &amp;&amp; mode == fields-&gt;properties-&gt;parseMode.getNoError()) { return; }
 404     NumberFormat::setLenient(enable); // to set field for compatibility
 405     fields-&gt;properties-&gt;parseMode = mode;
 406     touchNoError();
 407 }
 408 
 409 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
 410                              UParseError&amp;, UErrorCode&amp; status)
 411         : DecimalFormat(symbolsToAdopt, status) {
<span class="line-added"> 412     if (U_FAILURE(status)) { return; }</span>
 413     // TODO: What is parseError for?
 414     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
 415     touch(status);
 416 }
 417 
 418 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, const DecimalFormatSymbols&amp; symbols,
 419                              UErrorCode&amp; status)
<span class="line-modified"> 420         : DecimalFormat(nullptr, status) {</span>
<span class="line-added"> 421     if (U_FAILURE(status)) { return; }</span>
<span class="line-added"> 422     LocalPointer&lt;DecimalFormatSymbols&gt; dfs(new DecimalFormatSymbols(symbols), status);</span>
<span class="line-added"> 423     if (U_FAILURE(status)) {</span>
<span class="line-added"> 424         // If we failed to allocate DecimalFormatSymbols, then release fields and its members.</span>
<span class="line-added"> 425         // We must have a fully complete fields object, we cannot have partially populated members.</span>
<span class="line-added"> 426         delete fields;</span>
<span class="line-added"> 427         fields = nullptr;</span>
<span class="line-added"> 428         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 429         return;</span>
<span class="line-added"> 430     }</span>
<span class="line-added"> 431     fields-&gt;symbols.adoptInstead(dfs.orphan());</span>
 432     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
 433     touch(status);
 434 }
 435 
 436 DecimalFormat::DecimalFormat(const DecimalFormat&amp; source) : NumberFormat(source) {
<span class="line-added"> 437     // If the object that we are copying from is invalid, no point in going further.</span>
<span class="line-added"> 438     if (source.fields == nullptr) {</span>
<span class="line-added"> 439         return;</span>
<span class="line-added"> 440     }</span>
 441     // Note: it is not safe to copy fields-&gt;formatter or fWarehouse directly because fields-&gt;formatter might have
 442     // dangling pointers to fields inside fWarehouse. The safe thing is to re-construct fields-&gt;formatter from
 443     // the property bag, despite being somewhat slower.
 444     fields = new DecimalFormatFields();
 445     if (fields == nullptr) {
<span class="line-modified"> 446         return; // no way to report an error.</span>
 447     }
<span class="line-modified"> 448     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified"> 449     fields-&gt;formatter.adoptInsteadAndCheckErrorCode(new LocalizedNumberFormatter(), status);</span>
<span class="line-modified"> 450     fields-&gt;properties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(*source.fields-&gt;properties), status);</span>
<span class="line-modified"> 451     fields-&gt;symbols.adoptInsteadAndCheckErrorCode(new DecimalFormatSymbols(*source.fields-&gt;symbols), status);</span>
<span class="line-added"> 452     fields-&gt;exportedProperties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);</span>
<span class="line-added"> 453     // In order to simplify error handling logic in the various getters/setters/etc, we do not allow</span>
<span class="line-added"> 454     // any partially populated DecimalFormatFields object. We must have a fully complete fields object</span>
<span class="line-added"> 455     // or else we set it to nullptr.</span>
<span class="line-added"> 456     if (fields-&gt;formatter.isNull() || fields-&gt;properties.isNull() || fields-&gt;exportedProperties.isNull() || fields-&gt;symbols.isNull()) {</span>
<span class="line-added"> 457         delete fields;</span>
<span class="line-added"> 458         fields = nullptr;</span>
 459         return;
 460     }
<span class="line-modified"> 461     touch(status);</span>
 462 }
 463 
 464 DecimalFormat&amp; DecimalFormat::operator=(const DecimalFormat&amp; rhs) {
<span class="line-added"> 465     // guard against self-assignment</span>
<span class="line-added"> 466     if (this == &amp;rhs) {</span>
<span class="line-added"> 467         return *this;</span>
<span class="line-added"> 468     }</span>
<span class="line-added"> 469     // Make sure both objects are valid.</span>
<span class="line-added"> 470     if (fields == nullptr || rhs.fields == nullptr) {</span>
<span class="line-added"> 471         return *this; // unfortunately, no way to report an error.</span>
<span class="line-added"> 472     }</span>
 473     *fields-&gt;properties = *rhs.fields-&gt;properties;
 474     fields-&gt;exportedProperties-&gt;clear();
<span class="line-modified"> 475     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified"> 476     LocalPointer&lt;DecimalFormatSymbols&gt; dfs(new DecimalFormatSymbols(*rhs.fields-&gt;symbols), status);</span>
<span class="line-added"> 477     if (U_FAILURE(status)) {</span>
<span class="line-added"> 478         // We failed to allocate DecimalFormatSymbols, release fields and its members.</span>
<span class="line-added"> 479         // We must have a fully complete fields object, we cannot have partially populated members.</span>
<span class="line-added"> 480         delete fields;</span>
<span class="line-added"> 481         fields = nullptr;</span>
<span class="line-added"> 482         return *this;</span>
<span class="line-added"> 483     }</span>
<span class="line-added"> 484     fields-&gt;symbols.adoptInstead(dfs.orphan());</span>
<span class="line-added"> 485     touch(status);</span>
<span class="line-added"> 486 </span>
 487     return *this;
 488 }
 489 
 490 DecimalFormat::~DecimalFormat() {
<span class="line-added"> 491     if (fields == nullptr) { return; }</span>
<span class="line-added"> 492 </span>
 493     delete fields-&gt;atomicParser.exchange(nullptr);
 494     delete fields-&gt;atomicCurrencyParser.exchange(nullptr);
 495     delete fields;
 496 }
 497 
 498 Format* DecimalFormat::clone() const {
<span class="line-modified"> 499     // can only clone valid objects.</span>
<span class="line-added"> 500     if (fields == nullptr) {</span>
<span class="line-added"> 501         return nullptr;</span>
<span class="line-added"> 502     }</span>
<span class="line-added"> 503     LocalPointer&lt;DecimalFormat&gt; df(new DecimalFormat(*this));</span>
<span class="line-added"> 504     if (df.isValid() &amp;&amp; df-&gt;fields != nullptr) {</span>
<span class="line-added"> 505         return df.orphan();</span>
<span class="line-added"> 506     }</span>
<span class="line-added"> 507     return nullptr;</span>
 508 }
 509 
 510 UBool DecimalFormat::operator==(const Format&amp; other) const {
 511     auto* otherDF = dynamic_cast&lt;const DecimalFormat*&gt;(&amp;other);
 512     if (otherDF == nullptr) {
 513         return false;
 514     }
<span class="line-added"> 515     // If either object is in an invalid state, prevent dereferencing nullptr below.</span>
<span class="line-added"> 516     // Additionally, invalid objects should not be considered equal to anything.</span>
<span class="line-added"> 517     if (fields == nullptr || otherDF-&gt;fields == nullptr) {</span>
<span class="line-added"> 518         return false;</span>
<span class="line-added"> 519     }</span>
 520     return *fields-&gt;properties == *otherDF-&gt;fields-&gt;properties &amp;&amp; *fields-&gt;symbols == *otherDF-&gt;fields-&gt;symbols;
 521 }
 522 
 523 UnicodeString&amp; DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
<span class="line-added"> 524     if (fields == nullptr) {</span>
<span class="line-added"> 525         appendTo.setToBogus();</span>
<span class="line-added"> 526         return appendTo;</span>
<span class="line-added"> 527     }</span>
 528     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatDouble(number, appendTo)) {
 529         return appendTo;
 530     }
 531     UErrorCode localStatus = U_ZERO_ERROR;
 532     FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, localStatus);
 533     fieldPositionHelper(output, pos, appendTo.length(), localStatus);
 534     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 535     output.appendTo(appendable, localStatus);</span>
 536     return appendTo;
 537 }
 538 
 539 UnicodeString&amp; DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 540                                      UErrorCode&amp; status) const {
<span class="line-added"> 541     if (U_FAILURE(status)) {</span>
<span class="line-added"> 542         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added"> 543     }</span>
<span class="line-added"> 544     if (fields == nullptr) {</span>
<span class="line-added"> 545         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 546         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 547         appendTo.setToBogus();</span>
<span class="line-added"> 548         return appendTo;</span>
<span class="line-added"> 549     }</span>
 550     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatDouble(number, appendTo)) {
 551         return appendTo;
 552     }
 553     FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, status);
 554     fieldPositionHelper(output, pos, appendTo.length(), status);
 555     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 556     output.appendTo(appendable, status);</span>
 557     return appendTo;
 558 }
 559 
 560 UnicodeString&amp;
 561 DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 562                       UErrorCode&amp; status) const {
<span class="line-added"> 563     if (U_FAILURE(status)) {</span>
<span class="line-added"> 564         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added"> 565     }</span>
<span class="line-added"> 566     if (fields == nullptr) {</span>
<span class="line-added"> 567         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 568         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 569         appendTo.setToBogus();</span>
<span class="line-added"> 570         return appendTo;</span>
<span class="line-added"> 571     }</span>
 572     if (posIter == nullptr &amp;&amp; fastFormatDouble(number, appendTo)) {
 573         return appendTo;
 574     }
 575     FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, status);
 576     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 577     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 578     output.appendTo(appendable, status);</span>
 579     return appendTo;
 580 }
 581 
 582 UnicodeString&amp; DecimalFormat::format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
 583     return format(static_cast&lt;int64_t&gt; (number), appendTo, pos);
 584 }
 585 
 586 UnicodeString&amp; DecimalFormat::format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 587                                      UErrorCode&amp; status) const {
 588     return format(static_cast&lt;int64_t&gt; (number), appendTo, pos, status);
 589 }
 590 
 591 UnicodeString&amp;
 592 DecimalFormat::format(int32_t number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 593                       UErrorCode&amp; status) const {
 594     return format(static_cast&lt;int64_t&gt; (number), appendTo, posIter, status);
 595 }
 596 
 597 UnicodeString&amp; DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
<span class="line-added"> 598     if (fields == nullptr) {</span>
<span class="line-added"> 599         appendTo.setToBogus();</span>
<span class="line-added"> 600         return appendTo;</span>
<span class="line-added"> 601     }</span>
 602     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatInt64(number, appendTo)) {
 603         return appendTo;
 604     }
 605     UErrorCode localStatus = U_ZERO_ERROR;
 606     FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, localStatus);
 607     fieldPositionHelper(output, pos, appendTo.length(), localStatus);
 608     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 609     output.appendTo(appendable, localStatus);</span>
 610     return appendTo;
 611 }
 612 
 613 UnicodeString&amp; DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 614                                      UErrorCode&amp; status) const {
<span class="line-added"> 615     if (U_FAILURE(status)) {</span>
<span class="line-added"> 616         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added"> 617     }</span>
<span class="line-added"> 618     if (fields == nullptr) {</span>
<span class="line-added"> 619         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 620         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 621         appendTo.setToBogus();</span>
<span class="line-added"> 622         return appendTo;</span>
<span class="line-added"> 623     }</span>
 624     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatInt64(number, appendTo)) {
 625         return appendTo;
 626     }
 627     FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, status);
 628     fieldPositionHelper(output, pos, appendTo.length(), status);
 629     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 630     output.appendTo(appendable, status);</span>
 631     return appendTo;
 632 }
 633 
 634 UnicodeString&amp;
 635 DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 636                       UErrorCode&amp; status) const {
<span class="line-added"> 637     if (U_FAILURE(status)) {</span>
<span class="line-added"> 638         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added"> 639     }</span>
<span class="line-added"> 640     if (fields == nullptr) {</span>
<span class="line-added"> 641         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 642         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 643         appendTo.setToBogus();</span>
<span class="line-added"> 644         return appendTo;</span>
<span class="line-added"> 645     }</span>
 646     if (posIter == nullptr &amp;&amp; fastFormatInt64(number, appendTo)) {
 647         return appendTo;
 648     }
 649     FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, status);
 650     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 651     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 652     output.appendTo(appendable, status);</span>
 653     return appendTo;
 654 }
 655 
 656 UnicodeString&amp;
 657 DecimalFormat::format(StringPiece number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 658                       UErrorCode&amp; status) const {
<span class="line-added"> 659     if (U_FAILURE(status)) {</span>
<span class="line-added"> 660         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added"> 661     }</span>
<span class="line-added"> 662     if (fields == nullptr) {</span>
<span class="line-added"> 663         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 664         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 665         appendTo.setToBogus();</span>
<span class="line-added"> 666         return appendTo;</span>
<span class="line-added"> 667     }</span>
 668     FormattedNumber output = fields-&gt;formatter-&gt;formatDecimal(number, status);
 669     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 670     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 671     output.appendTo(appendable, status);</span>
 672     return appendTo;
 673 }
 674 
 675 UnicodeString&amp; DecimalFormat::format(const DecimalQuantity&amp; number, UnicodeString&amp; appendTo,
 676                                      FieldPositionIterator* posIter, UErrorCode&amp; status) const {
<span class="line-added"> 677     if (U_FAILURE(status)) {</span>
<span class="line-added"> 678         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added"> 679     }</span>
<span class="line-added"> 680     if (fields == nullptr) {</span>
<span class="line-added"> 681         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 682         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 683         appendTo.setToBogus();</span>
<span class="line-added"> 684         return appendTo;</span>
<span class="line-added"> 685     }</span>
 686     FormattedNumber output = fields-&gt;formatter-&gt;formatDecimalQuantity(number, status);
 687     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 688     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 689     output.appendTo(appendable, status);</span>
 690     return appendTo;
 691 }
 692 
 693 UnicodeString&amp;
 694 DecimalFormat::format(const DecimalQuantity&amp; number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 695                       UErrorCode&amp; status) const {
<span class="line-added"> 696     if (U_FAILURE(status)) {</span>
<span class="line-added"> 697         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added"> 698     }</span>
<span class="line-added"> 699     if (fields == nullptr) {</span>
<span class="line-added"> 700         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 701         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 702         appendTo.setToBogus();</span>
<span class="line-added"> 703         return appendTo;</span>
<span class="line-added"> 704     }</span>
 705     FormattedNumber output = fields-&gt;formatter-&gt;formatDecimalQuantity(number, status);
 706     fieldPositionHelper(output, pos, appendTo.length(), status);
 707     auto appendable = UnicodeStringAppendable(appendTo);
<span class="line-modified"> 708     output.appendTo(appendable, status);</span>
 709     return appendTo;
 710 }
 711 
 712 void DecimalFormat::parse(const UnicodeString&amp; text, Formattable&amp; output,
 713                           ParsePosition&amp; parsePosition) const {
<span class="line-added"> 714     if (fields == nullptr) {</span>
<span class="line-added"> 715         return;</span>
<span class="line-added"> 716     }</span>
 717     if (parsePosition.getIndex() &lt; 0 || parsePosition.getIndex() &gt;= text.length()) {
<span class="line-added"> 718         if (parsePosition.getIndex() == text.length()) {</span>
<span class="line-added"> 719             // If there is nothing to parse, it is an error</span>
<span class="line-added"> 720             parsePosition.setErrorIndex(parsePosition.getIndex());</span>
<span class="line-added"> 721         }</span>
 722         return;
 723     }
 724 
 725     ErrorCode status;
 726     ParsedNumber result;
 727     // Note: if this is a currency instance, currencies will be matched despite the fact that we are not in the
 728     // parseCurrency method (backwards compatibility)
 729     int32_t startIndex = parsePosition.getIndex();
 730     const NumberParserImpl* parser = getParser(status);
<span class="line-modified"> 731     if (U_FAILURE(status)) {</span>
<span class="line-added"> 732         return; // unfortunately no way to report back the error.</span>
<span class="line-added"> 733     }</span>
 734     parser-&gt;parse(text, startIndex, true, result, status);
<span class="line-added"> 735     if (U_FAILURE(status)) {</span>
<span class="line-added"> 736         return; // unfortunately no way to report back the error.</span>
<span class="line-added"> 737     }</span>
 738     // TODO: Do we need to check for fImpl-&gt;properties-&gt;parseAllInput (UCONFIG_HAVE_PARSEALLINPUT) here?
 739     if (result.success()) {
 740         parsePosition.setIndex(result.charEnd);
 741         result.populateFormattable(output, parser-&gt;getParseFlags());
 742     } else {
 743         parsePosition.setErrorIndex(startIndex + result.charEnd);
 744     }
 745 }
 746 
 747 CurrencyAmount* DecimalFormat::parseCurrency(const UnicodeString&amp; text, ParsePosition&amp; parsePosition) const {
<span class="line-added"> 748     if (fields == nullptr) {</span>
<span class="line-added"> 749         return nullptr;</span>
<span class="line-added"> 750     }</span>
 751     if (parsePosition.getIndex() &lt; 0 || parsePosition.getIndex() &gt;= text.length()) {
 752         return nullptr;
 753     }
 754 
 755     ErrorCode status;
 756     ParsedNumber result;
 757     // Note: if this is a currency instance, currencies will be matched despite the fact that we are not in the
 758     // parseCurrency method (backwards compatibility)
 759     int32_t startIndex = parsePosition.getIndex();
 760     const NumberParserImpl* parser = getCurrencyParser(status);
<span class="line-modified"> 761     if (U_FAILURE(status)) {</span>
<span class="line-added"> 762         return nullptr;</span>
<span class="line-added"> 763     }</span>
 764     parser-&gt;parse(text, startIndex, true, result, status);
<span class="line-added"> 765     if (U_FAILURE(status)) {</span>
<span class="line-added"> 766         return nullptr;</span>
<span class="line-added"> 767     }</span>
 768     // TODO: Do we need to check for fImpl-&gt;properties-&gt;parseAllInput (UCONFIG_HAVE_PARSEALLINPUT) here?
 769     if (result.success()) {
 770         parsePosition.setIndex(result.charEnd);
 771         Formattable formattable;
 772         result.populateFormattable(formattable, parser-&gt;getParseFlags());
<span class="line-modified"> 773         LocalPointer&lt;CurrencyAmount&gt; currencyAmount(</span>
<span class="line-added"> 774             new CurrencyAmount(formattable, result.currencyCode, status), status);</span>
<span class="line-added"> 775         if (U_FAILURE(status)) {</span>
<span class="line-added"> 776             return nullptr;</span>
<span class="line-added"> 777         }</span>
<span class="line-added"> 778         return currencyAmount.orphan();</span>
 779     } else {
 780         parsePosition.setErrorIndex(startIndex + result.charEnd);
 781         return nullptr;
 782     }
 783 }
 784 
 785 const DecimalFormatSymbols* DecimalFormat::getDecimalFormatSymbols(void) const {
<span class="line-added"> 786     if (fields == nullptr) {</span>
<span class="line-added"> 787         return nullptr;</span>
<span class="line-added"> 788     }</span>
 789     return fields-&gt;symbols.getAlias();
 790 }
 791 
 792 void DecimalFormat::adoptDecimalFormatSymbols(DecimalFormatSymbols* symbolsToAdopt) {
 793     if (symbolsToAdopt == nullptr) {
 794         return; // do not allow caller to set fields-&gt;symbols to NULL
 795     }
<span class="line-modified"> 796     // we must take ownership of symbolsToAdopt, even in a failure case.</span>
<span class="line-added"> 797     LocalPointer&lt;DecimalFormatSymbols&gt; dfs(symbolsToAdopt);</span>
<span class="line-added"> 798     if (fields == nullptr) {</span>
<span class="line-added"> 799         return;</span>
<span class="line-added"> 800     }</span>
<span class="line-added"> 801     fields-&gt;symbols.adoptInstead(dfs.orphan());</span>
 802     touchNoError();
 803 }
 804 
 805 void DecimalFormat::setDecimalFormatSymbols(const DecimalFormatSymbols&amp; symbols) {
<span class="line-modified"> 806     if (fields == nullptr) {</span>
<span class="line-added"> 807         return;</span>
<span class="line-added"> 808     }</span>
<span class="line-added"> 809     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added"> 810     LocalPointer&lt;DecimalFormatSymbols&gt; dfs(new DecimalFormatSymbols(symbols), status);</span>
<span class="line-added"> 811     if (U_FAILURE(status)) {</span>
<span class="line-added"> 812         // We failed to allocate DecimalFormatSymbols, release fields and its members.</span>
<span class="line-added"> 813         // We must have a fully complete fields object, we cannot have partially populated members.</span>
<span class="line-added"> 814         delete fields;</span>
<span class="line-added"> 815         fields = nullptr;</span>
<span class="line-added"> 816         return;</span>
<span class="line-added"> 817     }</span>
<span class="line-added"> 818     fields-&gt;symbols.adoptInstead(dfs.orphan());</span>
 819     touchNoError();
 820 }
 821 
 822 const CurrencyPluralInfo* DecimalFormat::getCurrencyPluralInfo(void) const {
<span class="line-added"> 823     if (fields == nullptr) {</span>
<span class="line-added"> 824         return nullptr;</span>
<span class="line-added"> 825     }</span>
 826     return fields-&gt;properties-&gt;currencyPluralInfo.fPtr.getAlias();
 827 }
 828 
 829 void DecimalFormat::adoptCurrencyPluralInfo(CurrencyPluralInfo* toAdopt) {
<span class="line-modified"> 830     // TODO: should we guard against nullptr input, like in adoptDecimalFormatSymbols?</span>
<span class="line-added"> 831     // we must take ownership of toAdopt, even in a failure case.</span>
<span class="line-added"> 832     LocalPointer&lt;CurrencyPluralInfo&gt; cpi(toAdopt);</span>
<span class="line-added"> 833     if (fields == nullptr) {</span>
<span class="line-added"> 834         return;</span>
<span class="line-added"> 835     }</span>
<span class="line-added"> 836     fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(cpi.orphan());</span>
 837     touchNoError();
 838 }
 839 
 840 void DecimalFormat::setCurrencyPluralInfo(const CurrencyPluralInfo&amp; info) {
<span class="line-added"> 841     if (fields == nullptr) {</span>
<span class="line-added"> 842         return;</span>
<span class="line-added"> 843     }</span>
 844     if (fields-&gt;properties-&gt;currencyPluralInfo.fPtr.isNull()) {
<span class="line-added"> 845         // Note: clone() can fail with OOM error, but we have no way to report it. :(</span>
 846         fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(info.clone());
 847     } else {
 848         *fields-&gt;properties-&gt;currencyPluralInfo.fPtr = info; // copy-assignment operator
 849     }
 850     touchNoError();
 851 }
 852 
 853 UnicodeString&amp; DecimalFormat::getPositivePrefix(UnicodeString&amp; result) const {
<span class="line-modified"> 854     if (fields == nullptr) {</span>
<span class="line-modified"> 855         result.setToBogus();</span>
<span class="line-added"> 856         return result;</span>
<span class="line-added"> 857     }</span>
<span class="line-added"> 858     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added"> 859     fields-&gt;formatter-&gt;getAffixImpl(true, false, result, status);</span>
<span class="line-added"> 860     if (U_FAILURE(status)) { result.setToBogus(); }</span>
 861     return result;
 862 }
 863 
 864 void DecimalFormat::setPositivePrefix(const UnicodeString&amp; newValue) {
<span class="line-added"> 865     if (fields == nullptr) {</span>
<span class="line-added"> 866         return;</span>
<span class="line-added"> 867     }</span>
 868     if (newValue == fields-&gt;properties-&gt;positivePrefix) { return; }
 869     fields-&gt;properties-&gt;positivePrefix = newValue;
 870     touchNoError();
 871 }
 872 
 873 UnicodeString&amp; DecimalFormat::getNegativePrefix(UnicodeString&amp; result) const {
<span class="line-modified"> 874     if (fields == nullptr) {</span>
<span class="line-modified"> 875         result.setToBogus();</span>
<span class="line-added"> 876         return result;</span>
<span class="line-added"> 877     }</span>
<span class="line-added"> 878     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added"> 879     fields-&gt;formatter-&gt;getAffixImpl(true, true, result, status);</span>
<span class="line-added"> 880     if (U_FAILURE(status)) { result.setToBogus(); }</span>
 881     return result;
 882 }
 883 
 884 void DecimalFormat::setNegativePrefix(const UnicodeString&amp; newValue) {
<span class="line-added"> 885     if (fields == nullptr) {</span>
<span class="line-added"> 886         return;</span>
<span class="line-added"> 887     }</span>
 888     if (newValue == fields-&gt;properties-&gt;negativePrefix) { return; }
 889     fields-&gt;properties-&gt;negativePrefix = newValue;
 890     touchNoError();
 891 }
 892 
 893 UnicodeString&amp; DecimalFormat::getPositiveSuffix(UnicodeString&amp; result) const {
<span class="line-modified"> 894     if (fields == nullptr) {</span>
<span class="line-modified"> 895         result.setToBogus();</span>
<span class="line-added"> 896         return result;</span>
<span class="line-added"> 897     }</span>
<span class="line-added"> 898     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added"> 899     fields-&gt;formatter-&gt;getAffixImpl(false, false, result, status);</span>
<span class="line-added"> 900     if (U_FAILURE(status)) { result.setToBogus(); }</span>
 901     return result;
 902 }
 903 
 904 void DecimalFormat::setPositiveSuffix(const UnicodeString&amp; newValue) {
<span class="line-added"> 905     if (fields == nullptr) {</span>
<span class="line-added"> 906         return;</span>
<span class="line-added"> 907     }</span>
 908     if (newValue == fields-&gt;properties-&gt;positiveSuffix) { return; }
 909     fields-&gt;properties-&gt;positiveSuffix = newValue;
 910     touchNoError();
 911 }
 912 
 913 UnicodeString&amp; DecimalFormat::getNegativeSuffix(UnicodeString&amp; result) const {
<span class="line-modified"> 914     if (fields == nullptr) {</span>
<span class="line-modified"> 915         result.setToBogus();</span>
<span class="line-added"> 916         return result;</span>
<span class="line-added"> 917     }</span>
<span class="line-added"> 918     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added"> 919     fields-&gt;formatter-&gt;getAffixImpl(false, true, result, status);</span>
<span class="line-added"> 920     if (U_FAILURE(status)) { result.setToBogus(); }</span>
 921     return result;
 922 }
 923 
 924 void DecimalFormat::setNegativeSuffix(const UnicodeString&amp; newValue) {
<span class="line-added"> 925     if (fields == nullptr) {</span>
<span class="line-added"> 926         return;</span>
<span class="line-added"> 927     }</span>
 928     if (newValue == fields-&gt;properties-&gt;negativeSuffix) { return; }
 929     fields-&gt;properties-&gt;negativeSuffix = newValue;
 930     touchNoError();
 931 }
 932 
 933 UBool DecimalFormat::isSignAlwaysShown() const {
<span class="line-added"> 934     // Not much we can do to report an error.</span>
<span class="line-added"> 935     if (fields == nullptr) {</span>
<span class="line-added"> 936         return DecimalFormatProperties::getDefault().signAlwaysShown;</span>
<span class="line-added"> 937     }</span>
 938     return fields-&gt;properties-&gt;signAlwaysShown;
 939 }
 940 
 941 void DecimalFormat::setSignAlwaysShown(UBool value) {
<span class="line-added"> 942     if (fields == nullptr) { return; }</span>
 943     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;signAlwaysShown) { return; }
 944     fields-&gt;properties-&gt;signAlwaysShown = value;
 945     touchNoError();
 946 }
 947 
 948 int32_t DecimalFormat::getMultiplier(void) const {
<span class="line-modified"> 949     const DecimalFormatProperties *dfp;</span>
<span class="line-modified"> 950     // Not much we can do to report an error.</span>
<span class="line-modified"> 951     if (fields == nullptr) {</span>
<span class="line-modified"> 952         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added"> 953         dfp = &amp;(DecimalFormatProperties::getDefault());</span>
<span class="line-added"> 954     } else {</span>
<span class="line-added"> 955         dfp = fields-&gt;properties.getAlias();</span>
<span class="line-added"> 956     }</span>
<span class="line-added"> 957     if (dfp-&gt;multiplier != 1) {</span>
<span class="line-added"> 958         return dfp-&gt;multiplier;</span>
<span class="line-added"> 959     } else if (dfp-&gt;magnitudeMultiplier != 0) {</span>
<span class="line-added"> 960         return static_cast&lt;int32_t&gt;(uprv_pow10(dfp-&gt;magnitudeMultiplier));</span>
 961     } else {
 962         return 1;
 963     }
 964 }
 965 
 966 void DecimalFormat::setMultiplier(int32_t multiplier) {
<span class="line-added"> 967     if (fields == nullptr) {</span>
<span class="line-added"> 968          return;</span>
<span class="line-added"> 969     }</span>
 970     if (multiplier == 0) {
 971         multiplier = 1;     // one being the benign default value for a multiplier.
 972     }
 973 
 974     // Try to convert to a magnitude multiplier first
 975     int delta = 0;
 976     int value = multiplier;
 977     while (value != 1) {
 978         delta++;
 979         int temp = value / 10;
 980         if (temp * 10 != value) {
 981             delta = -1;
 982             break;
 983         }
 984         value = temp;
 985     }
 986     if (delta != -1) {
 987         fields-&gt;properties-&gt;magnitudeMultiplier = delta;
 988         fields-&gt;properties-&gt;multiplier = 1;
 989     } else {
 990         fields-&gt;properties-&gt;magnitudeMultiplier = 0;
 991         fields-&gt;properties-&gt;multiplier = multiplier;
 992     }
 993     touchNoError();
 994 }
 995 
 996 int32_t DecimalFormat::getMultiplierScale() const {
<span class="line-added"> 997     // Not much we can do to report an error.</span>
<span class="line-added"> 998     if (fields == nullptr) {</span>
<span class="line-added"> 999         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1000         return DecimalFormatProperties::getDefault().multiplierScale;</span>
<span class="line-added">1001     }</span>
1002     return fields-&gt;properties-&gt;multiplierScale;
1003 }
1004 
1005 void DecimalFormat::setMultiplierScale(int32_t newValue) {
<span class="line-added">1006     if (fields == nullptr) { return; }</span>
1007     if (newValue == fields-&gt;properties-&gt;multiplierScale) { return; }
1008     fields-&gt;properties-&gt;multiplierScale = newValue;
1009     touchNoError();
1010 }
1011 
1012 double DecimalFormat::getRoundingIncrement(void) const {
<span class="line-added">1013     // Not much we can do to report an error.</span>
<span class="line-added">1014     if (fields == nullptr) {</span>
<span class="line-added">1015         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1016         return DecimalFormatProperties::getDefault().roundingIncrement;</span>
<span class="line-added">1017     }</span>
1018     return fields-&gt;exportedProperties-&gt;roundingIncrement;
1019 }
1020 
1021 void DecimalFormat::setRoundingIncrement(double newValue) {
<span class="line-added">1022     if (fields == nullptr) { return; }</span>
1023     if (newValue == fields-&gt;properties-&gt;roundingIncrement) { return; }
1024     fields-&gt;properties-&gt;roundingIncrement = newValue;
1025     touchNoError();
1026 }
1027 
1028 ERoundingMode DecimalFormat::getRoundingMode(void) const {
<span class="line-added">1029     // Not much we can do to report an error.</span>
<span class="line-added">1030     if (fields == nullptr) {</span>
<span class="line-added">1031         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1032         return static_cast&lt;ERoundingMode&gt;(DecimalFormatProperties::getDefault().roundingMode.getNoError());</span>
<span class="line-added">1033     }</span>
1034     // UNumberFormatRoundingMode and ERoundingMode have the same values.
1035     return static_cast&lt;ERoundingMode&gt;(fields-&gt;exportedProperties-&gt;roundingMode.getNoError());
1036 }
1037 
1038 void DecimalFormat::setRoundingMode(ERoundingMode roundingMode) {
<span class="line-added">1039     if (fields == nullptr) { return; }</span>
1040     auto uRoundingMode = static_cast&lt;UNumberFormatRoundingMode&gt;(roundingMode);
1041     if (!fields-&gt;properties-&gt;roundingMode.isNull() &amp;&amp; uRoundingMode == fields-&gt;properties-&gt;roundingMode.getNoError()) {
1042         return;
1043     }
1044     NumberFormat::setMaximumIntegerDigits(roundingMode); // to set field for compatibility
1045     fields-&gt;properties-&gt;roundingMode = uRoundingMode;
1046     touchNoError();
1047 }
1048 
1049 int32_t DecimalFormat::getFormatWidth(void) const {
<span class="line-added">1050     // Not much we can do to report an error.</span>
<span class="line-added">1051     if (fields == nullptr) {</span>
<span class="line-added">1052         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1053         return DecimalFormatProperties::getDefault().formatWidth;</span>
<span class="line-added">1054     }</span>
1055     return fields-&gt;properties-&gt;formatWidth;
1056 }
1057 
1058 void DecimalFormat::setFormatWidth(int32_t width) {
<span class="line-added">1059     if (fields == nullptr) { return; }</span>
1060     if (width == fields-&gt;properties-&gt;formatWidth) { return; }
1061     fields-&gt;properties-&gt;formatWidth = width;
1062     touchNoError();
1063 }
1064 
1065 UnicodeString DecimalFormat::getPadCharacterString() const {
<span class="line-modified">1066     if (fields == nullptr || fields-&gt;properties-&gt;padString.isBogus()) {</span>
1067         // Readonly-alias the static string kFallbackPaddingString
1068         return {TRUE, kFallbackPaddingString, -1};
1069     } else {
1070         return fields-&gt;properties-&gt;padString;
1071     }
1072 }
1073 
1074 void DecimalFormat::setPadCharacter(const UnicodeString&amp; padChar) {
<span class="line-added">1075     if (fields == nullptr) { return; }</span>
1076     if (padChar == fields-&gt;properties-&gt;padString) { return; }
1077     if (padChar.length() &gt; 0) {
1078         fields-&gt;properties-&gt;padString = UnicodeString(padChar.char32At(0));
1079     } else {
1080         fields-&gt;properties-&gt;padString.setToBogus();
1081     }
1082     touchNoError();
1083 }
1084 
1085 EPadPosition DecimalFormat::getPadPosition(void) const {
<span class="line-modified">1086     if (fields == nullptr || fields-&gt;properties-&gt;padPosition.isNull()) {</span>
1087         return EPadPosition::kPadBeforePrefix;
1088     } else {
1089         // UNumberFormatPadPosition and EPadPosition have the same values.
1090         return static_cast&lt;EPadPosition&gt;(fields-&gt;properties-&gt;padPosition.getNoError());
1091     }
1092 }
1093 
1094 void DecimalFormat::setPadPosition(EPadPosition padPos) {
<span class="line-added">1095     if (fields == nullptr) { return; }</span>
1096     auto uPadPos = static_cast&lt;UNumberFormatPadPosition&gt;(padPos);
1097     if (!fields-&gt;properties-&gt;padPosition.isNull() &amp;&amp; uPadPos == fields-&gt;properties-&gt;padPosition.getNoError()) {
1098         return;
1099     }
1100     fields-&gt;properties-&gt;padPosition = uPadPos;
1101     touchNoError();
1102 }
1103 
1104 UBool DecimalFormat::isScientificNotation(void) const {
<span class="line-modified">1105     // Not much we can do to report an error.</span>
<span class="line-added">1106     if (fields == nullptr) {</span>
<span class="line-added">1107         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1108         return (DecimalFormatProperties::getDefault().minimumExponentDigits != -1);</span>
<span class="line-added">1109     }</span>
<span class="line-added">1110     return (fields-&gt;properties-&gt;minimumExponentDigits != -1);</span>
1111 }
1112 
1113 void DecimalFormat::setScientificNotation(UBool useScientific) {
<span class="line-added">1114     if (fields == nullptr) { return; }</span>
1115     int32_t minExp = useScientific ? 1 : -1;
1116     if (fields-&gt;properties-&gt;minimumExponentDigits == minExp) { return; }
1117     if (useScientific) {
1118         fields-&gt;properties-&gt;minimumExponentDigits = 1;
1119     } else {
1120         fields-&gt;properties-&gt;minimumExponentDigits = -1;
1121     }
1122     touchNoError();
1123 }
1124 
1125 int8_t DecimalFormat::getMinimumExponentDigits(void) const {
<span class="line-added">1126     // Not much we can do to report an error.</span>
<span class="line-added">1127     if (fields == nullptr) {</span>
<span class="line-added">1128         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1129         return static_cast&lt;int8_t&gt;(DecimalFormatProperties::getDefault().minimumExponentDigits);</span>
<span class="line-added">1130     }</span>
1131     return static_cast&lt;int8_t&gt;(fields-&gt;properties-&gt;minimumExponentDigits);
1132 }
1133 
1134 void DecimalFormat::setMinimumExponentDigits(int8_t minExpDig) {
<span class="line-added">1135     if (fields == nullptr) { return; }</span>
1136     if (minExpDig == fields-&gt;properties-&gt;minimumExponentDigits) { return; }
1137     fields-&gt;properties-&gt;minimumExponentDigits = minExpDig;
1138     touchNoError();
1139 }
1140 
1141 UBool DecimalFormat::isExponentSignAlwaysShown(void) const {
<span class="line-added">1142     // Not much we can do to report an error.</span>
<span class="line-added">1143     if (fields == nullptr) {</span>
<span class="line-added">1144         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1145         return DecimalFormatProperties::getDefault().exponentSignAlwaysShown;</span>
<span class="line-added">1146     }</span>
1147     return fields-&gt;properties-&gt;exponentSignAlwaysShown;
1148 }
1149 
1150 void DecimalFormat::setExponentSignAlwaysShown(UBool expSignAlways) {
<span class="line-added">1151     if (fields == nullptr) { return; }</span>
1152     if (UBOOL_TO_BOOL(expSignAlways) == fields-&gt;properties-&gt;exponentSignAlwaysShown) { return; }
1153     fields-&gt;properties-&gt;exponentSignAlwaysShown = expSignAlways;
1154     touchNoError();
1155 }
1156 
1157 int32_t DecimalFormat::getGroupingSize(void) const {
<span class="line-modified">1158     int32_t groupingSize;</span>
<span class="line-added">1159     // Not much we can do to report an error.</span>
<span class="line-added">1160     if (fields == nullptr) {</span>
<span class="line-added">1161         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1162         groupingSize = DecimalFormatProperties::getDefault().groupingSize;</span>
<span class="line-added">1163     } else {</span>
<span class="line-added">1164         groupingSize = fields-&gt;properties-&gt;groupingSize;</span>
<span class="line-added">1165     }</span>
<span class="line-added">1166     if (groupingSize &lt; 0) {</span>
1167         return 0;
1168     }
<span class="line-modified">1169     return groupingSize;</span>
1170 }
1171 
1172 void DecimalFormat::setGroupingSize(int32_t newValue) {
<span class="line-added">1173     if (fields == nullptr) { return; }</span>
1174     if (newValue == fields-&gt;properties-&gt;groupingSize) { return; }
1175     fields-&gt;properties-&gt;groupingSize = newValue;
1176     touchNoError();
1177 }
1178 
1179 int32_t DecimalFormat::getSecondaryGroupingSize(void) const {
<span class="line-modified">1180     int32_t grouping2;</span>
<span class="line-added">1181     // Not much we can do to report an error.</span>
<span class="line-added">1182     if (fields == nullptr) {</span>
<span class="line-added">1183         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1184         grouping2 = DecimalFormatProperties::getDefault().secondaryGroupingSize;</span>
<span class="line-added">1185     } else {</span>
<span class="line-added">1186         grouping2 = fields-&gt;properties-&gt;secondaryGroupingSize;</span>
<span class="line-added">1187     }</span>
1188     if (grouping2 &lt; 0) {
1189         return 0;
1190     }
1191     return grouping2;
1192 }
1193 
1194 void DecimalFormat::setSecondaryGroupingSize(int32_t newValue) {
<span class="line-added">1195     if (fields == nullptr) { return; }</span>
1196     if (newValue == fields-&gt;properties-&gt;secondaryGroupingSize) { return; }
1197     fields-&gt;properties-&gt;secondaryGroupingSize = newValue;
1198     touchNoError();
1199 }
1200 
1201 int32_t DecimalFormat::getMinimumGroupingDigits() const {
<span class="line-added">1202     // Not much we can do to report an error.</span>
<span class="line-added">1203     if (fields == nullptr) {</span>
<span class="line-added">1204         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1205         return DecimalFormatProperties::getDefault().minimumGroupingDigits;</span>
<span class="line-added">1206     }</span>
1207     return fields-&gt;properties-&gt;minimumGroupingDigits;
1208 }
1209 
1210 void DecimalFormat::setMinimumGroupingDigits(int32_t newValue) {
<span class="line-added">1211     if (fields == nullptr) { return; }</span>
1212     if (newValue == fields-&gt;properties-&gt;minimumGroupingDigits) { return; }
1213     fields-&gt;properties-&gt;minimumGroupingDigits = newValue;
1214     touchNoError();
1215 }
1216 
1217 UBool DecimalFormat::isDecimalSeparatorAlwaysShown(void) const {
<span class="line-added">1218     // Not much we can do to report an error.</span>
<span class="line-added">1219     if (fields == nullptr) {</span>
<span class="line-added">1220         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1221         return DecimalFormatProperties::getDefault().decimalSeparatorAlwaysShown;</span>
<span class="line-added">1222     }</span>
1223     return fields-&gt;properties-&gt;decimalSeparatorAlwaysShown;
1224 }
1225 
1226 void DecimalFormat::setDecimalSeparatorAlwaysShown(UBool newValue) {
<span class="line-added">1227     if (fields == nullptr) { return; }</span>
1228     if (UBOOL_TO_BOOL(newValue) == fields-&gt;properties-&gt;decimalSeparatorAlwaysShown) { return; }
1229     fields-&gt;properties-&gt;decimalSeparatorAlwaysShown = newValue;
1230     touchNoError();
1231 }
1232 
1233 UBool DecimalFormat::isDecimalPatternMatchRequired(void) const {
<span class="line-added">1234     // Not much we can do to report an error.</span>
<span class="line-added">1235     if (fields == nullptr) {</span>
<span class="line-added">1236         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1237         return DecimalFormatProperties::getDefault().decimalPatternMatchRequired;</span>
<span class="line-added">1238     }</span>
1239     return fields-&gt;properties-&gt;decimalPatternMatchRequired;
1240 }
1241 
1242 void DecimalFormat::setDecimalPatternMatchRequired(UBool newValue) {
<span class="line-added">1243     if (fields == nullptr) { return; }</span>
1244     if (UBOOL_TO_BOOL(newValue) == fields-&gt;properties-&gt;decimalPatternMatchRequired) { return; }
1245     fields-&gt;properties-&gt;decimalPatternMatchRequired = newValue;
1246     touchNoError();
1247 }
1248 
1249 UBool DecimalFormat::isParseNoExponent() const {
<span class="line-added">1250     // Not much we can do to report an error.</span>
<span class="line-added">1251     if (fields == nullptr) {</span>
<span class="line-added">1252         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1253         return DecimalFormatProperties::getDefault().parseNoExponent;</span>
<span class="line-added">1254     }</span>
1255     return fields-&gt;properties-&gt;parseNoExponent;
1256 }
1257 
1258 void DecimalFormat::setParseNoExponent(UBool value) {
<span class="line-added">1259     if (fields == nullptr) { return; }</span>
1260     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseNoExponent) { return; }
1261     fields-&gt;properties-&gt;parseNoExponent = value;
1262     touchNoError();
1263 }
1264 
1265 UBool DecimalFormat::isParseCaseSensitive() const {
<span class="line-added">1266     // Not much we can do to report an error.</span>
<span class="line-added">1267     if (fields == nullptr) {</span>
<span class="line-added">1268         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1269         return DecimalFormatProperties::getDefault().parseCaseSensitive;</span>
<span class="line-added">1270     }</span>
1271     return fields-&gt;properties-&gt;parseCaseSensitive;
1272 }
1273 
1274 void DecimalFormat::setParseCaseSensitive(UBool value) {
<span class="line-added">1275     if (fields == nullptr) { return; }</span>
1276     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseCaseSensitive) { return; }
1277     fields-&gt;properties-&gt;parseCaseSensitive = value;
1278     touchNoError();
1279 }
1280 
1281 UBool DecimalFormat::isFormatFailIfMoreThanMaxDigits() const {
<span class="line-added">1282     // Not much we can do to report an error.</span>
<span class="line-added">1283     if (fields == nullptr) {</span>
<span class="line-added">1284         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1285         return DecimalFormatProperties::getDefault().formatFailIfMoreThanMaxDigits;</span>
<span class="line-added">1286     }</span>
1287     return fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits;
1288 }
1289 
1290 void DecimalFormat::setFormatFailIfMoreThanMaxDigits(UBool value) {
<span class="line-added">1291     if (fields == nullptr) { return; }</span>
1292     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits) { return; }
1293     fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits = value;
1294     touchNoError();
1295 }
1296 
1297 UnicodeString&amp; DecimalFormat::toPattern(UnicodeString&amp; result) const {
<span class="line-added">1298     if (fields == nullptr) {</span>
<span class="line-added">1299         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1300         result.setToBogus();</span>
<span class="line-added">1301         return result;</span>
<span class="line-added">1302     }</span>
1303     // Pull some properties from exportedProperties and others from properties
1304     // to keep affix patterns intact.  In particular, pull rounding properties
1305     // so that CurrencyUsage is reflected properly.
1306     // TODO: Consider putting this logic in number_patternstring.cpp instead.
1307     ErrorCode localStatus;
1308     DecimalFormatProperties tprops(*fields-&gt;properties);
<span class="line-modified">1309     bool useCurrency = (</span>
<span class="line-modified">1310         !tprops.currency.isNull() ||</span>
<span class="line-modified">1311         !tprops.currencyPluralInfo.fPtr.isNull() ||</span>
<span class="line-modified">1312         !tprops.currencyUsage.isNull() ||</span>
<span class="line-modified">1313         AffixUtils::hasCurrencySymbols(tprops.positivePrefixPattern, localStatus) ||</span>
<span class="line-modified">1314         AffixUtils::hasCurrencySymbols(tprops.positiveSuffixPattern, localStatus) ||</span>
<span class="line-added">1315         AffixUtils::hasCurrencySymbols(tprops.negativePrefixPattern, localStatus) ||</span>
<span class="line-added">1316         AffixUtils::hasCurrencySymbols(tprops.negativeSuffixPattern, localStatus));</span>
1317     if (useCurrency) {
1318         tprops.minimumFractionDigits = fields-&gt;exportedProperties-&gt;minimumFractionDigits;
1319         tprops.maximumFractionDigits = fields-&gt;exportedProperties-&gt;maximumFractionDigits;
1320         tprops.roundingIncrement = fields-&gt;exportedProperties-&gt;roundingIncrement;
1321     }
1322     result = PatternStringUtils::propertiesToPatternString(tprops, localStatus);
1323     return result;
1324 }
1325 
1326 UnicodeString&amp; DecimalFormat::toLocalizedPattern(UnicodeString&amp; result) const {
<span class="line-added">1327     if (fields == nullptr) {</span>
<span class="line-added">1328         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1329         result.setToBogus();</span>
<span class="line-added">1330         return result;</span>
<span class="line-added">1331     }</span>
1332     ErrorCode localStatus;
1333     result = toPattern(result);
1334     result = PatternStringUtils::convertLocalized(result, *fields-&gt;symbols, true, localStatus);
1335     return result;
1336 }
1337 
1338 void DecimalFormat::applyPattern(const UnicodeString&amp; pattern, UParseError&amp;, UErrorCode&amp; status) {
1339     // TODO: What is parseError for?
1340     applyPattern(pattern, status);
1341 }
1342 
1343 void DecimalFormat::applyPattern(const UnicodeString&amp; pattern, UErrorCode&amp; status) {
<span class="line-added">1344     // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">1345     if (U_FAILURE(status)) { return; }</span>
<span class="line-added">1346     if (fields == nullptr) {</span>
<span class="line-added">1347         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1348         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1349         return;</span>
<span class="line-added">1350     }</span>
1351     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_NEVER, status);
1352     touch(status);
1353 }
1354 
1355 void DecimalFormat::applyLocalizedPattern(const UnicodeString&amp; localizedPattern, UParseError&amp;,
1356                                           UErrorCode&amp; status) {
1357     // TODO: What is parseError for?
1358     applyLocalizedPattern(localizedPattern, status);
1359 }
1360 
1361 void DecimalFormat::applyLocalizedPattern(const UnicodeString&amp; localizedPattern, UErrorCode&amp; status) {
<span class="line-modified">1362     // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-modified">1363     if (U_FAILURE(status)) { return; }</span>
<span class="line-modified">1364     if (fields == nullptr) {</span>
<span class="line-modified">1365         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1366         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1367         return;</span>
1368     }
<span class="line-added">1369     UnicodeString pattern = PatternStringUtils::convertLocalized(</span>
<span class="line-added">1370             localizedPattern, *fields-&gt;symbols, false, status);</span>
<span class="line-added">1371     applyPattern(pattern, status);</span>
1372 }
1373 
1374 void DecimalFormat::setMaximumIntegerDigits(int32_t newValue) {
<span class="line-added">1375     if (fields == nullptr) { return; }</span>
1376     if (newValue == fields-&gt;properties-&gt;maximumIntegerDigits) { return; }
1377     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
1378     int32_t min = fields-&gt;properties-&gt;minimumIntegerDigits;
1379     if (min &gt;= 0 &amp;&amp; min &gt; newValue) {
1380         fields-&gt;properties-&gt;minimumIntegerDigits = newValue;
1381     }
1382     fields-&gt;properties-&gt;maximumIntegerDigits = newValue;
1383     touchNoError();
1384 }
1385 
1386 void DecimalFormat::setMinimumIntegerDigits(int32_t newValue) {
<span class="line-added">1387     if (fields == nullptr) { return; }</span>
1388     if (newValue == fields-&gt;properties-&gt;minimumIntegerDigits) { return; }
1389     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
1390     int32_t max = fields-&gt;properties-&gt;maximumIntegerDigits;
1391     if (max &gt;= 0 &amp;&amp; max &lt; newValue) {
1392         fields-&gt;properties-&gt;maximumIntegerDigits = newValue;
1393     }
1394     fields-&gt;properties-&gt;minimumIntegerDigits = newValue;
1395     touchNoError();
1396 }
1397 
1398 void DecimalFormat::setMaximumFractionDigits(int32_t newValue) {
<span class="line-added">1399     if (fields == nullptr) { return; }</span>
1400     if (newValue == fields-&gt;properties-&gt;maximumFractionDigits) { return; }
1401     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
1402     int32_t min = fields-&gt;properties-&gt;minimumFractionDigits;
1403     if (min &gt;= 0 &amp;&amp; min &gt; newValue) {
1404         fields-&gt;properties-&gt;minimumFractionDigits = newValue;
1405     }
1406     fields-&gt;properties-&gt;maximumFractionDigits = newValue;
1407     touchNoError();
1408 }
1409 
1410 void DecimalFormat::setMinimumFractionDigits(int32_t newValue) {
<span class="line-added">1411     if (fields == nullptr) { return; }</span>
1412     if (newValue == fields-&gt;properties-&gt;minimumFractionDigits) { return; }
1413     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
1414     int32_t max = fields-&gt;properties-&gt;maximumFractionDigits;
1415     if (max &gt;= 0 &amp;&amp; max &lt; newValue) {
1416         fields-&gt;properties-&gt;maximumFractionDigits = newValue;
1417     }
1418     fields-&gt;properties-&gt;minimumFractionDigits = newValue;
1419     touchNoError();
1420 }
1421 
1422 int32_t DecimalFormat::getMinimumSignificantDigits() const {
<span class="line-added">1423     // Not much we can do to report an error.</span>
<span class="line-added">1424     if (fields == nullptr) {</span>
<span class="line-added">1425         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1426         return DecimalFormatProperties::getDefault().minimumSignificantDigits;</span>
<span class="line-added">1427     }</span>
1428     return fields-&gt;exportedProperties-&gt;minimumSignificantDigits;
1429 }
1430 
1431 int32_t DecimalFormat::getMaximumSignificantDigits() const {
<span class="line-added">1432     // Not much we can do to report an error.</span>
<span class="line-added">1433     if (fields == nullptr) {</span>
<span class="line-added">1434         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1435         return DecimalFormatProperties::getDefault().maximumSignificantDigits;</span>
<span class="line-added">1436     }</span>
1437     return fields-&gt;exportedProperties-&gt;maximumSignificantDigits;
1438 }
1439 
1440 void DecimalFormat::setMinimumSignificantDigits(int32_t value) {
<span class="line-added">1441     if (fields == nullptr) { return; }</span>
1442     if (value == fields-&gt;properties-&gt;minimumSignificantDigits) { return; }
1443     int32_t max = fields-&gt;properties-&gt;maximumSignificantDigits;
1444     if (max &gt;= 0 &amp;&amp; max &lt; value) {
1445         fields-&gt;properties-&gt;maximumSignificantDigits = value;
1446     }
1447     fields-&gt;properties-&gt;minimumSignificantDigits = value;
1448     touchNoError();
1449 }
1450 
1451 void DecimalFormat::setMaximumSignificantDigits(int32_t value) {
<span class="line-added">1452     if (fields == nullptr) { return; }</span>
1453     if (value == fields-&gt;properties-&gt;maximumSignificantDigits) { return; }
1454     int32_t min = fields-&gt;properties-&gt;minimumSignificantDigits;
1455     if (min &gt;= 0 &amp;&amp; min &gt; value) {
1456         fields-&gt;properties-&gt;minimumSignificantDigits = value;
1457     }
1458     fields-&gt;properties-&gt;maximumSignificantDigits = value;
1459     touchNoError();
1460 }
1461 
1462 UBool DecimalFormat::areSignificantDigitsUsed() const {
<span class="line-modified">1463     const DecimalFormatProperties* dfp;</span>
<span class="line-added">1464     // Not much we can do to report an error.</span>
<span class="line-added">1465     if (fields == nullptr) {</span>
<span class="line-added">1466         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1467         dfp = &amp;(DecimalFormatProperties::getDefault());</span>
<span class="line-added">1468     } else {</span>
<span class="line-added">1469         dfp = fields-&gt;properties.getAlias();</span>
<span class="line-added">1470     }</span>
<span class="line-added">1471     return dfp-&gt;minimumSignificantDigits != -1 || dfp-&gt;maximumSignificantDigits != -1;</span>
1472 }
1473 
1474 void DecimalFormat::setSignificantDigitsUsed(UBool useSignificantDigits) {
<span class="line-added">1475     if (fields == nullptr) { return; }</span>
<span class="line-added">1476 </span>
1477     // These are the default values from the old implementation.
<span class="line-added">1478     if (useSignificantDigits) {</span>
<span class="line-added">1479         if (fields-&gt;properties-&gt;minimumSignificantDigits != -1 ||</span>
<span class="line-added">1480             fields-&gt;properties-&gt;maximumSignificantDigits != -1) {</span>
<span class="line-added">1481             return;</span>
<span class="line-added">1482         }</span>
<span class="line-added">1483     } else {</span>
<span class="line-added">1484         if (fields-&gt;properties-&gt;minimumSignificantDigits == -1 &amp;&amp;</span>
<span class="line-added">1485             fields-&gt;properties-&gt;maximumSignificantDigits == -1) {</span>
<span class="line-added">1486             return;</span>
<span class="line-added">1487         }</span>
<span class="line-added">1488     }</span>
1489     int32_t minSig = useSignificantDigits ? 1 : -1;
1490     int32_t maxSig = useSignificantDigits ? 6 : -1;




1491     fields-&gt;properties-&gt;minimumSignificantDigits = minSig;
1492     fields-&gt;properties-&gt;maximumSignificantDigits = maxSig;
1493     touchNoError();
1494 }
1495 
1496 void DecimalFormat::setCurrency(const char16_t* theCurrency, UErrorCode&amp; ec) {
<span class="line-added">1497     // don&#39;t overwrite ec if it&#39;s already a failure.</span>
<span class="line-added">1498     if (U_FAILURE(ec)) { return; }</span>
<span class="line-added">1499     if (fields == nullptr) {</span>
<span class="line-added">1500         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1501         ec = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1502         return;</span>
<span class="line-added">1503     }</span>
1504     CurrencyUnit currencyUnit(theCurrency, ec);
1505     if (U_FAILURE(ec)) { return; }
1506     if (!fields-&gt;properties-&gt;currency.isNull() &amp;&amp; fields-&gt;properties-&gt;currency.getNoError() == currencyUnit) {
1507         return;
1508     }
1509     NumberFormat::setCurrency(theCurrency, ec); // to set field for compatibility
1510     fields-&gt;properties-&gt;currency = currencyUnit;
1511     // TODO: Set values in fields-&gt;symbols, too?
1512     touchNoError();
1513 }
1514 
1515 void DecimalFormat::setCurrency(const char16_t* theCurrency) {
1516     ErrorCode localStatus;
1517     setCurrency(theCurrency, localStatus);
1518 }
1519 
1520 void DecimalFormat::setCurrencyUsage(UCurrencyUsage newUsage, UErrorCode* ec) {
<span class="line-modified">1521     // don&#39;t overwrite ec if it&#39;s already a failure.</span>
<span class="line-added">1522     if (U_FAILURE(*ec)) { return; }</span>
<span class="line-added">1523     if (fields == nullptr) {</span>
<span class="line-added">1524         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1525         *ec = U_MEMORY_ALLOCATION_ERROR;</span>
1526         return;
1527     }
1528     if (!fields-&gt;properties-&gt;currencyUsage.isNull() &amp;&amp; newUsage == fields-&gt;properties-&gt;currencyUsage.getNoError()) {
1529         return;
1530     }
1531     fields-&gt;properties-&gt;currencyUsage = newUsage;
1532     touch(*ec);
1533 }
1534 
1535 UCurrencyUsage DecimalFormat::getCurrencyUsage() const {
1536     // CurrencyUsage is not exported, so we have to get it from the input property bag.
1537     // TODO: Should we export CurrencyUsage instead?
<span class="line-modified">1538     if (fields == nullptr || fields-&gt;properties-&gt;currencyUsage.isNull()) {</span>
1539         return UCURR_USAGE_STANDARD;
1540     }
1541     return fields-&gt;properties-&gt;currencyUsage.getNoError();
1542 }
1543 
1544 void
1545 DecimalFormat::formatToDecimalQuantity(double number, DecimalQuantity&amp; output, UErrorCode&amp; status) const {
<span class="line-added">1546     // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">1547     if (U_FAILURE(status)) { return; }</span>
<span class="line-added">1548     if (fields == nullptr) {</span>
<span class="line-added">1549         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1550         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1551         return;</span>
<span class="line-added">1552     }</span>
1553     fields-&gt;formatter-&gt;formatDouble(number, status).getDecimalQuantity(output, status);
1554 }
1555 
1556 void DecimalFormat::formatToDecimalQuantity(const Formattable&amp; number, DecimalQuantity&amp; output,
1557                                             UErrorCode&amp; status) const {
<span class="line-added">1558     // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">1559     if (U_FAILURE(status)) { return; }</span>
<span class="line-added">1560     if (fields == nullptr) {</span>
<span class="line-added">1561         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1562         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1563         return;</span>
<span class="line-added">1564     }</span>
1565     UFormattedNumberData obj;
1566     number.populateDecimalQuantity(obj.quantity, status);
1567     fields-&gt;formatter-&gt;formatImpl(&amp;obj, status);
1568     output = std::move(obj.quantity);
1569 }
1570 
<span class="line-added">1571 const number::LocalizedNumberFormatter* DecimalFormat::toNumberFormatter(UErrorCode&amp; status) const {</span>
<span class="line-added">1572     // We sometimes need to return nullptr here (see ICU-20380)</span>
<span class="line-added">1573     if (U_FAILURE(status)) { return nullptr; }</span>
<span class="line-added">1574     if (fields == nullptr) {</span>
<span class="line-added">1575         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1576         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1577         return nullptr;</span>
<span class="line-added">1578     }</span>
<span class="line-added">1579     return &amp;*fields-&gt;formatter;</span>
<span class="line-added">1580 }</span>
<span class="line-added">1581 </span>
1582 const number::LocalizedNumberFormatter&amp; DecimalFormat::toNumberFormatter() const {
<span class="line-modified">1583     UErrorCode localStatus = U_ZERO_ERROR;</span>
<span class="line-added">1584     return *toNumberFormatter(localStatus);</span>
1585 }
1586 
1587 /** Rebuilds the formatter object from the property bag. */
1588 void DecimalFormat::touch(UErrorCode&amp; status) {
<span class="line-modified">1589     if (U_FAILURE(status)) {</span>
<span class="line-modified">1590         return;</span>
<span class="line-modified">1591     }</span>
<span class="line-added">1592     if (fields == nullptr) {</span>
<span class="line-added">1593         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1594         // For regular construction, the caller should have checked the status variable for errors.</span>
<span class="line-added">1595         // For copy construction, there is unfortunately nothing to report the error, so we need to guard against</span>
<span class="line-added">1596         // this possible bad state here and set the status to an error.</span>
<span class="line-added">1597         status = U_MEMORY_ALLOCATION_ERROR;</span>
1598         return;
1599     }
1600 
1601     // In C++, fields-&gt;symbols is the source of truth for the locale.
1602     Locale locale = fields-&gt;symbols-&gt;getLocale();
1603 
1604     // Note: The formatter is relatively cheap to create, and we need it to populate fields-&gt;exportedProperties,
<span class="line-modified">1605     // so automatically recompute it here. The parser is a bit more expensive and is not needed until the</span>
1606     // parse method is called, so defer that until needed.
1607     // TODO: Only update the pieces that changed instead of re-computing the whole formatter?
<span class="line-modified">1608 </span>
<span class="line-modified">1609     // Since memory has already been allocated for the formatter, we can move assign a stack-allocated object</span>
<span class="line-modified">1610     // and don&#39;t need to call new. (Which is slower and could possibly fail).</span>
<span class="line-modified">1611     *fields-&gt;formatter = NumberPropertyMapper::create(</span>
<span class="line-modified">1612         *fields-&gt;properties, *fields-&gt;symbols, fields-&gt;warehouse, *fields-&gt;exportedProperties, status).locale(</span>
<span class="line-added">1613             locale);</span>
1614 
1615     // Do this after fields-&gt;exportedProperties are set up
1616     setupFastFormat();
1617 
1618     // Delete the parsers if they were made previously
1619     delete fields-&gt;atomicParser.exchange(nullptr);
1620     delete fields-&gt;atomicCurrencyParser.exchange(nullptr);
1621 
1622     // In order for the getters to work, we need to populate some fields in NumberFormat.
1623     NumberFormat::setCurrency(fields-&gt;exportedProperties-&gt;currency.get(status).getISOCurrency(), status);
1624     NumberFormat::setMaximumIntegerDigits(fields-&gt;exportedProperties-&gt;maximumIntegerDigits);
1625     NumberFormat::setMinimumIntegerDigits(fields-&gt;exportedProperties-&gt;minimumIntegerDigits);
1626     NumberFormat::setMaximumFractionDigits(fields-&gt;exportedProperties-&gt;maximumFractionDigits);
1627     NumberFormat::setMinimumFractionDigits(fields-&gt;exportedProperties-&gt;minimumFractionDigits);
1628     // fImpl-&gt;properties, not fields-&gt;exportedProperties, since this information comes from the pattern:
1629     NumberFormat::setGroupingUsed(fields-&gt;properties-&gt;groupingUsed);
1630 }
1631 
1632 void DecimalFormat::touchNoError() {
1633     UErrorCode localStatus = U_ZERO_ERROR;
1634     touch(localStatus);
1635 }
1636 
1637 void DecimalFormat::setPropertiesFromPattern(const UnicodeString&amp; pattern, int32_t ignoreRounding,
1638                                              UErrorCode&amp; status) {
1639     if (U_SUCCESS(status)) {
1640         // Cast workaround to get around putting the enum in the public header file
1641         auto actualIgnoreRounding = static_cast&lt;IgnoreRounding&gt;(ignoreRounding);
1642         PatternParser::parseToExistingProperties(pattern, *fields-&gt;properties,  actualIgnoreRounding, status);
1643     }
1644 }
1645 
1646 const numparse::impl::NumberParserImpl* DecimalFormat::getParser(UErrorCode&amp; status) const {
<span class="line-modified">1647     // TODO: Move this into umutex.h? (similar logic also in numrange_fluent.cpp)</span>
<span class="line-added">1648     // See ICU-20146</span>
<span class="line-added">1649 </span>
<span class="line-added">1650     if (U_FAILURE(status)) {</span>
<span class="line-added">1651         return nullptr;</span>
<span class="line-added">1652     }</span>
1653 
1654     // First try to get the pre-computed parser
1655     auto* ptr = fields-&gt;atomicParser.load();
1656     if (ptr != nullptr) {
1657         return ptr;
1658     }
1659 
1660     // Try computing the parser on our own
1661     auto* temp = NumberParserImpl::createParserFromProperties(*fields-&gt;properties, *fields-&gt;symbols, false, status);
<span class="line-added">1662     if (U_FAILURE(status)) {</span>
<span class="line-added">1663         return nullptr;</span>
<span class="line-added">1664     }</span>
1665     if (temp == nullptr) {
1666         status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified">1667         return nullptr;</span>
1668     }
1669 
<span class="line-modified">1670     // Note: ptr starts as nullptr; during compare_exchange,</span>
<span class="line-modified">1671     // it is set to what is actually stored in the atomic</span>
<span class="line-added">1672     // if another thread beat us to computing the parser object.</span>
1673     auto* nonConstThis = const_cast&lt;DecimalFormat*&gt;(this);
1674     if (!nonConstThis-&gt;fields-&gt;atomicParser.compare_exchange_strong(ptr, temp)) {
1675         // Another thread beat us to computing the parser
1676         delete temp;
1677         return ptr;
1678     } else {
1679         // Our copy of the parser got stored in the atomic
1680         return temp;
1681     }
1682 }
1683 
1684 const numparse::impl::NumberParserImpl* DecimalFormat::getCurrencyParser(UErrorCode&amp; status) const {
1685     if (U_FAILURE(status)) { return nullptr; }
1686 
1687     // First try to get the pre-computed parser
1688     auto* ptr = fields-&gt;atomicCurrencyParser.load();
1689     if (ptr != nullptr) {
1690         return ptr;
1691     }
1692 
</pre>
<hr />
<pre>
1696         status = U_MEMORY_ALLOCATION_ERROR;
1697         // although we may still dereference, call sites should be guarded
1698     }
1699 
1700     // Note: ptr starts as nullptr; during compare_exchange, it is set to what is actually stored in the
1701     // atomic if another thread beat us to computing the parser object.
1702     auto* nonConstThis = const_cast&lt;DecimalFormat*&gt;(this);
1703     if (!nonConstThis-&gt;fields-&gt;atomicCurrencyParser.compare_exchange_strong(ptr, temp)) {
1704         // Another thread beat us to computing the parser
1705         delete temp;
1706         return ptr;
1707     } else {
1708         // Our copy of the parser got stored in the atomic
1709         return temp;
1710     }
1711 }
1712 
1713 void
1714 DecimalFormat::fieldPositionHelper(const number::FormattedNumber&amp; formatted, FieldPosition&amp; fieldPosition,
1715                                    int32_t offset, UErrorCode&amp; status) {
<span class="line-added">1716     if (U_FAILURE(status)) { return; }</span>
1717     // always return first occurrence:
1718     fieldPosition.setBeginIndex(0);
1719     fieldPosition.setEndIndex(0);
1720     bool found = formatted.nextFieldPosition(fieldPosition, status);
1721     if (found &amp;&amp; offset != 0) {
1722         FieldPositionOnlyHandler fpoh(fieldPosition);
1723         fpoh.shiftLast(offset);
1724     }
1725 }
1726 
1727 void
1728 DecimalFormat::fieldPositionIteratorHelper(const number::FormattedNumber&amp; formatted, FieldPositionIterator* fpi,
1729                                            int32_t offset, UErrorCode&amp; status) {
<span class="line-modified">1730     if (U_SUCCESS(status) &amp;&amp; (fpi != nullptr)) {</span>
1731         FieldPositionIteratorHandler fpih(fpi, status);
1732         fpih.setShift(offset);
1733         formatted.getAllFieldPositionsImpl(fpih, status);
1734     }
1735 }
1736 
1737 // To debug fast-format, change void(x) to printf(x)
1738 #define trace(x) void(x)
1739 
1740 void DecimalFormat::setupFastFormat() {
1741     // Check the majority of properties:
1742     if (!fields-&gt;properties-&gt;equalsDefaultExceptFastFormat()) {
1743         trace(&quot;no fast format: equality\n&quot;);
1744         fields-&gt;canUseFastFormat = false;
1745         return;
1746     }
1747 
1748     // Now check the remaining properties.
1749     // Nontrivial affixes:
1750     UBool trivialPP = fields-&gt;properties-&gt;positivePrefixPattern.isEmpty();
</pre>
</td>
</tr>
</table>
<center><a href="decNumberLocal.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion-bignum-dtoa.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>