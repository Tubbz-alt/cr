<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtptngen_impl.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="dtptngen.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="fmtable.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtptngen_impl.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 99 #define DT_NUMERIC         0x100
100 #define DT_DELTA           0x10
101 
102 U_NAMESPACE_BEGIN
103 
104 const int32_t UDATPG_FRACTIONAL_MASK = 1&lt;&lt;UDATPG_FRACTIONAL_SECOND_FIELD;
105 const int32_t UDATPG_SECOND_AND_FRACTIONAL_MASK = (1&lt;&lt;UDATPG_SECOND_FIELD) | (1&lt;&lt;UDATPG_FRACTIONAL_SECOND_FIELD);
106 
107 typedef enum dtStrEnum {
108     DT_BASESKELETON,
109     DT_SKELETON,
110     DT_PATTERN
111 }dtStrEnum;
112 
113 typedef struct dtTypeElem {
114     UChar                  patternChar;
115     UDateTimePatternField  field;
116     int16_t                type;
117     int16_t                minLen;
118     int16_t                weight;
<span class="line-modified">119 }dtTypeElem;</span>
120 
121 // A compact storage mechanism for skeleton field strings.  Several dozen of these will be created
122 // for a typical DateTimePatternGenerator instance.
123 class SkeletonFields : public UMemory {
124 public:
125     SkeletonFields();
126     void clear();
127     void copyFrom(const SkeletonFields&amp; other);
128     void clearField(int32_t field);
129     UChar getFieldChar(int32_t field) const;
130     int32_t getFieldLength(int32_t field) const;
131     void populate(int32_t field, const UnicodeString&amp; value);
132     void populate(int32_t field, UChar repeatChar, int32_t repeatCount);
133     UBool isFieldEmpty(int32_t field) const;
134     UnicodeString&amp; appendTo(UnicodeString&amp; string) const;
135     UnicodeString&amp; appendFieldTo(int32_t field, UnicodeString&amp; string) const;
136     UChar getFirstChar() const;
137     inline UBool operator==(const SkeletonFields&amp; other) const;
138     inline UBool operator!=(const SkeletonFields&amp; other) const;
139 
</pre>
<hr />
<pre>
155 public:
156     int32_t type[UDATPG_FIELD_COUNT];
157     SkeletonFields original;
158     SkeletonFields baseOriginal;
159     UBool addedDefaultDayPeriod;
160 
161     PtnSkeleton();
162     PtnSkeleton(const PtnSkeleton&amp; other);
163     void copyFrom(const PtnSkeleton&amp; other);
164     void clear();
165     UBool equals(const PtnSkeleton&amp; other) const;
166     UnicodeString getSkeleton() const;
167     UnicodeString getBaseSkeleton() const;
168     UChar getFirstChar() const;
169 
170     // TODO: Why is this virtual, as well as the other destructors in this file? We don&#39;t want
171     // vtables when we don&#39;t use class objects polymorphically.
172     virtual ~PtnSkeleton();
173 };
174 
<span class="line-removed">175 </span>
176 class PtnElem : public UMemory {
177 public:
178     UnicodeString basePattern;
<span class="line-modified">179     PtnSkeleton   *skeleton;</span>
180     UnicodeString pattern;
181     UBool         skeletonWasSpecified; // if specified in availableFormats, not derived
<span class="line-modified">182     PtnElem       *next;</span>
183 
184     PtnElem(const UnicodeString &amp;basePattern, const UnicodeString &amp;pattern);
185     virtual ~PtnElem();
<span class="line-removed">186 </span>
187 };
188 
189 class FormatParser : public UMemory {
190 public:
191     UnicodeString items[MAX_DT_TOKEN];
<span class="line-modified">192     int32_t  itemNumber;</span>
193 
194     FormatParser();
195     virtual ~FormatParser();
196     void set(const UnicodeString&amp; patternString);
197     void getQuoteLiteral(UnicodeString&amp; quote, int32_t *itemIndex);
<span class="line-modified">198     UBool isPatternSeparator(UnicodeString&amp; field);</span>
199     static UBool isQuoteLiteral(const UnicodeString&amp; s);
200     static int32_t getCanonicalIndex(const UnicodeString&amp; s) { return getCanonicalIndex(s, TRUE); }
201     static int32_t getCanonicalIndex(const UnicodeString&amp; s, UBool strict);
202 
203 private:
204    typedef enum TokenStatus {
205        START,
206        ADD_TOKEN,
207        SYNTAX_ERROR,
208        DONE
<span class="line-modified">209    } ToeknStatus;</span>
210 
211    TokenStatus status;
212    virtual TokenStatus setTokens(const UnicodeString&amp; pattern, int32_t startPos, int32_t *len);
213 };
214 
215 class DistanceInfo : public UMemory {
216 public:
217     int32_t missingFieldMask;
218     int32_t extraFieldMask;
219 
220     DistanceInfo() {}
221     virtual ~DistanceInfo();
222     void clear() { missingFieldMask = extraFieldMask = 0; }
<span class="line-modified">223     void setTo(DistanceInfo&amp; other);</span>
224     void addMissing(int32_t field) { missingFieldMask |= (1&lt;&lt;field); }
225     void addExtra(int32_t field) { extraFieldMask |= (1&lt;&lt;field); }
226 };
227 
228 class DateTimeMatcher: public UMemory {
229 public:
230     PtnSkeleton skeleton;
231 
232     void getBasePattern(UnicodeString&amp; basePattern);
233     UnicodeString getPattern();
234     void set(const UnicodeString&amp; pattern, FormatParser* fp);
235     void set(const UnicodeString&amp; pattern, FormatParser* fp, PtnSkeleton&amp; skeleton);
236     void copyFrom(const PtnSkeleton&amp; skeleton);
237     void copyFrom();
238     PtnSkeleton* getSkeletonPtr();
239     UBool equals(const DateTimeMatcher* other) const;
<span class="line-modified">240     int32_t getDistance(const DateTimeMatcher&amp; other, int32_t includeMask, DistanceInfo&amp; distanceInfo);</span>
241     DateTimeMatcher();
242     DateTimeMatcher(const DateTimeMatcher&amp; other);
243     virtual ~DateTimeMatcher();
<span class="line-modified">244     int32_t getFieldMask();</span>
245 };
246 
247 class PatternMap : public UMemory {
248 public:
249     PtnElem *boot[MAX_PATTERN_ENTRIES];
250     PatternMap();
251     virtual  ~PatternMap();
252     void  add(const UnicodeString&amp; basePattern, const PtnSkeleton&amp; skeleton, const UnicodeString&amp; value, UBool skeletonWasSpecified, UErrorCode&amp; status);
<span class="line-modified">253     const UnicodeString* getPatternFromBasePattern(UnicodeString&amp; basePattern, UBool&amp; skeletonWasSpecified);</span>
<span class="line-modified">254     const UnicodeString* getPatternFromSkeleton(PtnSkeleton&amp; skeleton, const PtnSkeleton** specifiedSkeletonPtr = 0);</span>
255     void copyFrom(const PatternMap&amp; other, UErrorCode&amp; status);
<span class="line-modified">256     PtnElem* getHeader(UChar baseChar);</span>
<span class="line-modified">257     UBool equals(const PatternMap&amp; other);</span>
258 private:
259     UBool isDupAllowed;
<span class="line-modified">260     PtnElem*  getDuplicateElem(const UnicodeString &amp;basePattern, const PtnSkeleton&amp; skeleton, PtnElem *baseElem);</span>
261 }; // end  PatternMap
262 
263 class PatternMapIterator : public UMemory {
264 public:
<span class="line-modified">265     PatternMapIterator();</span>
266     virtual ~PatternMapIterator();
267     void set(PatternMap&amp; patternMap);
<span class="line-modified">268     PtnSkeleton* getSkeleton();</span>
<span class="line-modified">269     UBool hasNext();</span>
270     DateTimeMatcher&amp; next();
271 private:
272     int32_t bootIndex;
273     PtnElem *nodePtr;
<span class="line-modified">274     DateTimeMatcher *matcher;</span>
275     PatternMap *patternMap;
276 };
277 
278 class DTSkeletonEnumeration : public StringEnumeration {
279 public:
<span class="line-modified">280     DTSkeletonEnumeration(PatternMap &amp;patternMap, dtStrEnum type, UErrorCode&amp; status);</span>
281     virtual ~DTSkeletonEnumeration();
282     static UClassID U_EXPORT2 getStaticClassID(void);
283     virtual UClassID getDynamicClassID(void) const;
284     virtual const UnicodeString* snext(UErrorCode&amp; status);
285     virtual void reset(UErrorCode&amp; status);
286     virtual int32_t count(UErrorCode&amp; status) const;
287 private:
288     int32_t pos;
289     UBool isCanonicalItem(const UnicodeString&amp; item);
<span class="line-modified">290     UVector *fSkeletons;</span>
291 };
292 
293 class DTRedundantEnumeration : public StringEnumeration {
294 public:
295     DTRedundantEnumeration();
296     virtual ~DTRedundantEnumeration();
297     static UClassID U_EXPORT2 getStaticClassID(void);
298     virtual UClassID getDynamicClassID(void) const;
299     virtual const UnicodeString* snext(UErrorCode&amp; status);
300     virtual void reset(UErrorCode&amp; status);
301     virtual int32_t count(UErrorCode&amp; status) const;
302     void add(const UnicodeString &amp;pattern, UErrorCode&amp; status);
303 private:
304     int32_t pos;
<span class="line-modified">305     UBool isCanonicalItem(const UnicodeString&amp; item);</span>
<span class="line-modified">306     UVector *fPatterns;</span>
307 };
308 
309 U_NAMESPACE_END
310 
311 #endif
</pre>
</td>
<td>
<hr />
<pre>
 99 #define DT_NUMERIC         0x100
100 #define DT_DELTA           0x10
101 
102 U_NAMESPACE_BEGIN
103 
104 const int32_t UDATPG_FRACTIONAL_MASK = 1&lt;&lt;UDATPG_FRACTIONAL_SECOND_FIELD;
105 const int32_t UDATPG_SECOND_AND_FRACTIONAL_MASK = (1&lt;&lt;UDATPG_SECOND_FIELD) | (1&lt;&lt;UDATPG_FRACTIONAL_SECOND_FIELD);
106 
107 typedef enum dtStrEnum {
108     DT_BASESKELETON,
109     DT_SKELETON,
110     DT_PATTERN
111 }dtStrEnum;
112 
113 typedef struct dtTypeElem {
114     UChar                  patternChar;
115     UDateTimePatternField  field;
116     int16_t                type;
117     int16_t                minLen;
118     int16_t                weight;
<span class="line-modified">119 } dtTypeElem;</span>
120 
121 // A compact storage mechanism for skeleton field strings.  Several dozen of these will be created
122 // for a typical DateTimePatternGenerator instance.
123 class SkeletonFields : public UMemory {
124 public:
125     SkeletonFields();
126     void clear();
127     void copyFrom(const SkeletonFields&amp; other);
128     void clearField(int32_t field);
129     UChar getFieldChar(int32_t field) const;
130     int32_t getFieldLength(int32_t field) const;
131     void populate(int32_t field, const UnicodeString&amp; value);
132     void populate(int32_t field, UChar repeatChar, int32_t repeatCount);
133     UBool isFieldEmpty(int32_t field) const;
134     UnicodeString&amp; appendTo(UnicodeString&amp; string) const;
135     UnicodeString&amp; appendFieldTo(int32_t field, UnicodeString&amp; string) const;
136     UChar getFirstChar() const;
137     inline UBool operator==(const SkeletonFields&amp; other) const;
138     inline UBool operator!=(const SkeletonFields&amp; other) const;
139 
</pre>
<hr />
<pre>
155 public:
156     int32_t type[UDATPG_FIELD_COUNT];
157     SkeletonFields original;
158     SkeletonFields baseOriginal;
159     UBool addedDefaultDayPeriod;
160 
161     PtnSkeleton();
162     PtnSkeleton(const PtnSkeleton&amp; other);
163     void copyFrom(const PtnSkeleton&amp; other);
164     void clear();
165     UBool equals(const PtnSkeleton&amp; other) const;
166     UnicodeString getSkeleton() const;
167     UnicodeString getBaseSkeleton() const;
168     UChar getFirstChar() const;
169 
170     // TODO: Why is this virtual, as well as the other destructors in this file? We don&#39;t want
171     // vtables when we don&#39;t use class objects polymorphically.
172     virtual ~PtnSkeleton();
173 };
174 

175 class PtnElem : public UMemory {
176 public:
177     UnicodeString basePattern;
<span class="line-modified">178     LocalPointer&lt;PtnSkeleton&gt; skeleton;</span>
179     UnicodeString pattern;
180     UBool         skeletonWasSpecified; // if specified in availableFormats, not derived
<span class="line-modified">181     LocalPointer&lt;PtnElem&gt; next;</span>
182 
183     PtnElem(const UnicodeString &amp;basePattern, const UnicodeString &amp;pattern);
184     virtual ~PtnElem();

185 };
186 
187 class FormatParser : public UMemory {
188 public:
189     UnicodeString items[MAX_DT_TOKEN];
<span class="line-modified">190     int32_t itemNumber;</span>
191 
192     FormatParser();
193     virtual ~FormatParser();
194     void set(const UnicodeString&amp; patternString);
195     void getQuoteLiteral(UnicodeString&amp; quote, int32_t *itemIndex);
<span class="line-modified">196     UBool isPatternSeparator(const UnicodeString&amp; field) const;</span>
197     static UBool isQuoteLiteral(const UnicodeString&amp; s);
198     static int32_t getCanonicalIndex(const UnicodeString&amp; s) { return getCanonicalIndex(s, TRUE); }
199     static int32_t getCanonicalIndex(const UnicodeString&amp; s, UBool strict);
200 
201 private:
202    typedef enum TokenStatus {
203        START,
204        ADD_TOKEN,
205        SYNTAX_ERROR,
206        DONE
<span class="line-modified">207    } TokenStatus;</span>
208 
209    TokenStatus status;
210    virtual TokenStatus setTokens(const UnicodeString&amp; pattern, int32_t startPos, int32_t *len);
211 };
212 
213 class DistanceInfo : public UMemory {
214 public:
215     int32_t missingFieldMask;
216     int32_t extraFieldMask;
217 
218     DistanceInfo() {}
219     virtual ~DistanceInfo();
220     void clear() { missingFieldMask = extraFieldMask = 0; }
<span class="line-modified">221     void setTo(const DistanceInfo&amp; other);</span>
222     void addMissing(int32_t field) { missingFieldMask |= (1&lt;&lt;field); }
223     void addExtra(int32_t field) { extraFieldMask |= (1&lt;&lt;field); }
224 };
225 
226 class DateTimeMatcher: public UMemory {
227 public:
228     PtnSkeleton skeleton;
229 
230     void getBasePattern(UnicodeString&amp; basePattern);
231     UnicodeString getPattern();
232     void set(const UnicodeString&amp; pattern, FormatParser* fp);
233     void set(const UnicodeString&amp; pattern, FormatParser* fp, PtnSkeleton&amp; skeleton);
234     void copyFrom(const PtnSkeleton&amp; skeleton);
235     void copyFrom();
236     PtnSkeleton* getSkeletonPtr();
237     UBool equals(const DateTimeMatcher* other) const;
<span class="line-modified">238     int32_t getDistance(const DateTimeMatcher&amp; other, int32_t includeMask, DistanceInfo&amp; distanceInfo) const;</span>
239     DateTimeMatcher();
240     DateTimeMatcher(const DateTimeMatcher&amp; other);
241     virtual ~DateTimeMatcher();
<span class="line-modified">242     int32_t getFieldMask() const;</span>
243 };
244 
245 class PatternMap : public UMemory {
246 public:
247     PtnElem *boot[MAX_PATTERN_ENTRIES];
248     PatternMap();
249     virtual  ~PatternMap();
250     void  add(const UnicodeString&amp; basePattern, const PtnSkeleton&amp; skeleton, const UnicodeString&amp; value, UBool skeletonWasSpecified, UErrorCode&amp; status);
<span class="line-modified">251     const UnicodeString* getPatternFromBasePattern(const UnicodeString&amp; basePattern, UBool&amp; skeletonWasSpecified) const;</span>
<span class="line-modified">252     const UnicodeString* getPatternFromSkeleton(const PtnSkeleton&amp; skeleton, const PtnSkeleton** specifiedSkeletonPtr = 0) const;</span>
253     void copyFrom(const PatternMap&amp; other, UErrorCode&amp; status);
<span class="line-modified">254     PtnElem* getHeader(UChar baseChar) const;</span>
<span class="line-modified">255     UBool equals(const PatternMap&amp; other) const;</span>
256 private:
257     UBool isDupAllowed;
<span class="line-modified">258     PtnElem*  getDuplicateElem(const UnicodeString&amp; basePattern, const PtnSkeleton&amp; skeleton, PtnElem *baseElem);</span>
259 }; // end  PatternMap
260 
261 class PatternMapIterator : public UMemory {
262 public:
<span class="line-modified">263     PatternMapIterator(UErrorCode &amp;status);</span>
264     virtual ~PatternMapIterator();
265     void set(PatternMap&amp; patternMap);
<span class="line-modified">266     PtnSkeleton* getSkeleton() const;</span>
<span class="line-modified">267     UBool hasNext() const;</span>
268     DateTimeMatcher&amp; next();
269 private:
270     int32_t bootIndex;
271     PtnElem *nodePtr;
<span class="line-modified">272     LocalPointer&lt;DateTimeMatcher&gt; matcher;</span>
273     PatternMap *patternMap;
274 };
275 
276 class DTSkeletonEnumeration : public StringEnumeration {
277 public:
<span class="line-modified">278     DTSkeletonEnumeration(PatternMap&amp; patternMap, dtStrEnum type, UErrorCode&amp; status);</span>
279     virtual ~DTSkeletonEnumeration();
280     static UClassID U_EXPORT2 getStaticClassID(void);
281     virtual UClassID getDynamicClassID(void) const;
282     virtual const UnicodeString* snext(UErrorCode&amp; status);
283     virtual void reset(UErrorCode&amp; status);
284     virtual int32_t count(UErrorCode&amp; status) const;
285 private:
286     int32_t pos;
287     UBool isCanonicalItem(const UnicodeString&amp; item);
<span class="line-modified">288     LocalPointer&lt;UVector&gt; fSkeletons;</span>
289 };
290 
291 class DTRedundantEnumeration : public StringEnumeration {
292 public:
293     DTRedundantEnumeration();
294     virtual ~DTRedundantEnumeration();
295     static UClassID U_EXPORT2 getStaticClassID(void);
296     virtual UClassID getDynamicClassID(void) const;
297     virtual const UnicodeString* snext(UErrorCode&amp; status);
298     virtual void reset(UErrorCode&amp; status);
299     virtual int32_t count(UErrorCode&amp; status) const;
300     void add(const UnicodeString &amp;pattern, UErrorCode&amp; status);
301 private:
302     int32_t pos;
<span class="line-modified">303     UBool isCanonicalItem(const UnicodeString&amp; item) const;</span>
<span class="line-modified">304     LocalPointer&lt;UVector&gt; fPatterns;</span>
305 };
306 
307 U_NAMESPACE_END
308 
309 #endif
</pre>
</td>
</tr>
</table>
<center><a href="dtptngen.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="fmtable.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>