<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtitvfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="dtfmtsym.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="dtitvinf.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtitvfmt.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  #include &quot;cmemory.h&quot;
  #include &quot;cstring.h&quot;
  #include &quot;dtitv_impl.h&quot;
  #include &quot;mutex.h&quot;
  #include &quot;uresimp.h&quot;
<span class="line-added">+ #include &quot;formattedval_impl.h&quot;</span>
  
  #ifdef DTITVFMT_DEBUG
  #include &lt;iostream&gt;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,16 ***</span>
  
  // earliestFirst:
  static const UChar gEarlierFirstPrefix[] = {LOW_E, LOW_A, LOW_R, LOW_L, LOW_I, LOW_E, LOW_S, LOW_T, CAP_F, LOW_I, LOW_R, LOW_S, LOW_T, COLON};
  
  
  UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DateIntervalFormat)
  
  // Mutex, protects access to fDateFormat, fFromCalendar and fToCalendar.
  //        Needed because these data members are modified by const methods of DateIntervalFormat.
  
<span class="line-modified">! static UMutex gFormatterMutex = U_MUTEX_INITIALIZER;</span>
  
  DateIntervalFormat* U_EXPORT2
  DateIntervalFormat::createInstance(const UnicodeString&amp; skeleton,
                                     UErrorCode&amp; status) {
      return createInstance(skeleton, Locale::getDefault(), status);
<span class="line-new-header">--- 64,30 ---</span>
  
  // earliestFirst:
  static const UChar gEarlierFirstPrefix[] = {LOW_E, LOW_A, LOW_R, LOW_L, LOW_I, LOW_E, LOW_S, LOW_T, CAP_F, LOW_I, LOW_R, LOW_S, LOW_T, COLON};
  
  
<span class="line-added">+ class FormattedDateIntervalData : public FormattedValueFieldPositionIteratorImpl {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     FormattedDateIntervalData(UErrorCode&amp; status) : FormattedValueFieldPositionIteratorImpl(5, status) {}</span>
<span class="line-added">+     virtual ~FormattedDateIntervalData();</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ FormattedDateIntervalData::~FormattedDateIntervalData() = default;</span>
<span class="line-added">+ </span>
<span class="line-added">+ UPRV_FORMATTED_VALUE_SUBCLASS_AUTO_IMPL(FormattedDateInterval)</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DateIntervalFormat)
  
  // Mutex, protects access to fDateFormat, fFromCalendar and fToCalendar.
  //        Needed because these data members are modified by const methods of DateIntervalFormat.
  
<span class="line-modified">! static UMutex *gFormatterMutex() {</span>
<span class="line-added">+     static UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added">+     return &amp;m;</span>
<span class="line-added">+ }</span>
  
  DateIntervalFormat* U_EXPORT2
  DateIntervalFormat::createInstance(const UnicodeString&amp; skeleton,
                                     UErrorCode&amp; status) {
      return createInstance(skeleton, Locale::getDefault(), status);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 154,11 ***</span>
          delete fToCalendar;
          delete fDatePattern;
          delete fTimePattern;
          delete fDateTimeFormat;
          {
<span class="line-modified">!             Mutex lock(&amp;gFormatterMutex);</span>
              if ( itvfmt.fDateFormat ) {
                  fDateFormat = (SimpleDateFormat*)itvfmt.fDateFormat-&gt;clone();
              } else {
                  fDateFormat = NULL;
              }
<span class="line-new-header">--- 169,11 ---</span>
          delete fToCalendar;
          delete fDatePattern;
          delete fTimePattern;
          delete fDateTimeFormat;
          {
<span class="line-modified">!             Mutex lock(gFormatterMutex());</span>
              if ( itvfmt.fDateFormat ) {
                  fDateFormat = (SimpleDateFormat*)itvfmt.fDateFormat-&gt;clone();
              } else {
                  fDateFormat = NULL;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 216,11 ***</span>
      if (this == fmt) {return TRUE;}
      if (!Format::operator==(other)) {return FALSE;}
      if ((fInfo != fmt-&gt;fInfo) &amp;&amp; (fInfo == NULL || fmt-&gt;fInfo == NULL)) {return FALSE;}
      if (fInfo &amp;&amp; fmt-&gt;fInfo &amp;&amp; (*fInfo != *fmt-&gt;fInfo )) {return FALSE;}
      {
<span class="line-modified">!         Mutex lock(&amp;gFormatterMutex);</span>
          if (fDateFormat != fmt-&gt;fDateFormat &amp;&amp; (fDateFormat == NULL || fmt-&gt;fDateFormat == NULL)) {return FALSE;}
          if (fDateFormat &amp;&amp; fmt-&gt;fDateFormat &amp;&amp; (*fDateFormat != *fmt-&gt;fDateFormat)) {return FALSE;}
      }
      // note: fFromCalendar and fToCalendar hold no persistent state, and therefore do not participate in operator ==.
      //       fDateFormat has the master calendar for the DateIntervalFormat.
<span class="line-new-header">--- 231,11 ---</span>
      if (this == fmt) {return TRUE;}
      if (!Format::operator==(other)) {return FALSE;}
      if ((fInfo != fmt-&gt;fInfo) &amp;&amp; (fInfo == NULL || fmt-&gt;fInfo == NULL)) {return FALSE;}
      if (fInfo &amp;&amp; fmt-&gt;fInfo &amp;&amp; (*fInfo != *fmt-&gt;fInfo )) {return FALSE;}
      {
<span class="line-modified">!         Mutex lock(gFormatterMutex());</span>
          if (fDateFormat != fmt-&gt;fDateFormat &amp;&amp; (fDateFormat == NULL || fmt-&gt;fDateFormat == NULL)) {return FALSE;}
          if (fDateFormat &amp;&amp; fmt-&gt;fDateFormat &amp;&amp; (*fDateFormat != *fmt-&gt;fDateFormat)) {return FALSE;}
      }
      // note: fFromCalendar and fToCalendar hold no persistent state, and therefore do not participate in operator ==.
      //       fDateFormat has the master calendar for the DateIntervalFormat.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,43 ***</span>
                             FieldPosition&amp; fieldPosition,
                             UErrorCode&amp; status) const {
      if ( U_FAILURE(status) ) {
          return appendTo;
      }
<span class="line-modified">!     if (fFromCalendar == NULL || fToCalendar == NULL || fDateFormat == NULL || fInfo == NULL) {</span>
          status = U_INVALID_STATE_ERROR;
          return appendTo;
      }
  
<span class="line-modified">!     Mutex lock(&amp;gFormatterMutex);</span>
<span class="line-modified">!     fFromCalendar-&gt;setTime(dtInterval-&gt;getFromDate(), status);</span>
<span class="line-modified">!     fToCalendar-&gt;setTime(dtInterval-&gt;getToDate(), status);</span>
<span class="line-modified">!     return formatImpl(*fFromCalendar, *fToCalendar, appendTo,fieldPosition, status);</span>
  }
  
  
  UnicodeString&amp;
  DateIntervalFormat::format(Calendar&amp; fromCalendar,
                             Calendar&amp; toCalendar,
                             UnicodeString&amp; appendTo,
                             FieldPosition&amp; pos,
                             UErrorCode&amp; status) const {
<span class="line-modified">!     Mutex lock(&amp;gFormatterMutex);</span>
<span class="line-modified">!     return formatImpl(fromCalendar, toCalendar, appendTo, pos, status);</span>
  }
  
  
  UnicodeString&amp;
  DateIntervalFormat::formatImpl(Calendar&amp; fromCalendar,
                             Calendar&amp; toCalendar,
                             UnicodeString&amp; appendTo,
<span class="line-modified">!                            FieldPosition&amp; pos,</span>
                             UErrorCode&amp; status) const {
      if ( U_FAILURE(status) ) {
          return appendTo;
      }
  
      // not support different calendar types and time zones
      //if ( fromCalendar.getType() != toCalendar.getType() ) {
      if ( !fromCalendar.isEquivalentTo(toCalendar) ) {
          status = U_ILLEGAL_ARGUMENT_ERROR;
          return appendTo;
<span class="line-new-header">--- 284,138 ---</span>
                             FieldPosition&amp; fieldPosition,
                             UErrorCode&amp; status) const {
      if ( U_FAILURE(status) ) {
          return appendTo;
      }
<span class="line-modified">!     if (fDateFormat == NULL || fInfo == NULL) {</span>
          status = U_INVALID_STATE_ERROR;
          return appendTo;
      }
  
<span class="line-modified">!     FieldPositionOnlyHandler handler(fieldPosition);</span>
<span class="line-modified">!     handler.setAcceptFirstOnly(TRUE);</span>
<span class="line-modified">!     int8_t ignore;</span>
<span class="line-modified">! </span>
<span class="line-added">+     Mutex lock(gFormatterMutex());</span>
<span class="line-added">+     return formatIntervalImpl(*dtInterval, appendTo, ignore, handler, status);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ FormattedDateInterval DateIntervalFormat::formatToValue(</span>
<span class="line-added">+         const DateInterval&amp; dtInterval,</span>
<span class="line-added">+         UErrorCode&amp; status) const {</span>
<span class="line-added">+     LocalPointer&lt;FormattedDateIntervalData&gt; result(new FormattedDateIntervalData(status), status);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return FormattedDateInterval(status);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     UnicodeString string;</span>
<span class="line-added">+     int8_t firstIndex;</span>
<span class="line-added">+     auto handler = result-&gt;getHandler(status);</span>
<span class="line-added">+     handler.setCategory(UFIELD_CATEGORY_DATE);</span>
<span class="line-added">+     {</span>
<span class="line-added">+         Mutex lock(gFormatterMutex());</span>
<span class="line-added">+         formatIntervalImpl(dtInterval, string, firstIndex, handler, status);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     handler.getError(status);</span>
<span class="line-added">+     result-&gt;appendString(string, status);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return FormattedDateInterval(status);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Compute the span fields and sort them into place:</span>
<span class="line-added">+     if (firstIndex != -1) {</span>
<span class="line-added">+         result-&gt;addOverlapSpans(UFIELD_CATEGORY_DATE_INTERVAL_SPAN, firstIndex, status);</span>
<span class="line-added">+         if (U_FAILURE(status)) {</span>
<span class="line-added">+             return FormattedDateInterval(status);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         result-&gt;sort();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return FormattedDateInterval(result.orphan());</span>
  }
  
  
  UnicodeString&amp;
  DateIntervalFormat::format(Calendar&amp; fromCalendar,
                             Calendar&amp; toCalendar,
                             UnicodeString&amp; appendTo,
                             FieldPosition&amp; pos,
                             UErrorCode&amp; status) const {
<span class="line-modified">!     FieldPositionOnlyHandler handler(pos);</span>
<span class="line-modified">!     handler.setAcceptFirstOnly(TRUE);</span>
<span class="line-added">+     int8_t ignore;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Mutex lock(gFormatterMutex());</span>
<span class="line-added">+     return formatImpl(fromCalendar, toCalendar, appendTo, ignore, handler, status);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ FormattedDateInterval DateIntervalFormat::formatToValue(</span>
<span class="line-added">+         Calendar&amp; fromCalendar,</span>
<span class="line-added">+         Calendar&amp; toCalendar,</span>
<span class="line-added">+         UErrorCode&amp; status) const {</span>
<span class="line-added">+     LocalPointer&lt;FormattedDateIntervalData&gt; result(new FormattedDateIntervalData(status), status);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return FormattedDateInterval(status);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     UnicodeString string;</span>
<span class="line-added">+     int8_t firstIndex;</span>
<span class="line-added">+     auto handler = result-&gt;getHandler(status);</span>
<span class="line-added">+     handler.setCategory(UFIELD_CATEGORY_DATE);</span>
<span class="line-added">+     {</span>
<span class="line-added">+         Mutex lock(gFormatterMutex());</span>
<span class="line-added">+         formatImpl(fromCalendar, toCalendar, string, firstIndex, handler, status);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     handler.getError(status);</span>
<span class="line-added">+     result-&gt;appendString(string, status);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return FormattedDateInterval(status);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Compute the span fields and sort them into place:</span>
<span class="line-added">+     if (firstIndex != -1) {</span>
<span class="line-added">+         result-&gt;addOverlapSpans(UFIELD_CATEGORY_DATE_INTERVAL_SPAN, firstIndex, status);</span>
<span class="line-added">+         result-&gt;sort();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return FormattedDateInterval(result.orphan());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ UnicodeString&amp; DateIntervalFormat::formatIntervalImpl(</span>
<span class="line-added">+         const DateInterval&amp; dtInterval,</span>
<span class="line-added">+         UnicodeString&amp; appendTo,</span>
<span class="line-added">+         int8_t&amp; firstIndex,</span>
<span class="line-added">+         FieldPositionHandler&amp; fphandler,</span>
<span class="line-added">+         UErrorCode&amp; status) const {</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return appendTo;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (fFromCalendar == nullptr || fToCalendar == nullptr) {</span>
<span class="line-added">+         status = U_INVALID_STATE_ERROR;</span>
<span class="line-added">+         return appendTo;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     fFromCalendar-&gt;setTime(dtInterval.getFromDate(), status);</span>
<span class="line-added">+     fToCalendar-&gt;setTime(dtInterval.getToDate(), status);</span>
<span class="line-added">+     return formatImpl(*fFromCalendar, *fToCalendar, appendTo, firstIndex, fphandler, status);</span>
  }
  
  
  UnicodeString&amp;
  DateIntervalFormat::formatImpl(Calendar&amp; fromCalendar,
                             Calendar&amp; toCalendar,
                             UnicodeString&amp; appendTo,
<span class="line-modified">!                            int8_t&amp; firstIndex,</span>
<span class="line-added">+                            FieldPositionHandler&amp; fphandler,</span>
                             UErrorCode&amp; status) const {
      if ( U_FAILURE(status) ) {
          return appendTo;
      }
  
<span class="line-added">+     // Initialize firstIndex to -1 (single date, no range)</span>
<span class="line-added">+     firstIndex = -1;</span>
<span class="line-added">+ </span>
      // not support different calendar types and time zones
      //if ( fromCalendar.getType() != toCalendar.getType() ) {
      if ( !fromCalendar.isEquivalentTo(toCalendar) ) {
          status = U_ILLEGAL_ARGUMENT_ERROR;
          return appendTo;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 344,11 ***</span>
      }
      if ( field == UCAL_FIELD_COUNT ) {
          /* ignore the millisecond etc. small fields&#39; difference.
           * use single date when all the above are the same.
           */
<span class="line-modified">!         return fDateFormat-&gt;format(fromCalendar, appendTo, pos);</span>
      }
      UBool fromToOnSameDay = (field==UCAL_AM_PM || field==UCAL_HOUR || field==UCAL_MINUTE || field==UCAL_SECOND);
  
      // following call should not set wrong status,
      // all the pass-in fields are valid till here
<span class="line-new-header">--- 454,11 ---</span>
      }
      if ( field == UCAL_FIELD_COUNT ) {
          /* ignore the millisecond etc. small fields&#39; difference.
           * use single date when all the above are the same.
           */
<span class="line-modified">!         return fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
      }
      UBool fromToOnSameDay = (field==UCAL_AM_PM || field==UCAL_HOUR || field==UCAL_MINUTE || field==UCAL_SECOND);
  
      // following call should not set wrong status,
      // all the pass-in fields are valid till here
</pre>
<hr />
<pre>
<span class="line-old-header">*** 361,49 ***</span>
          if ( fDateFormat-&gt;isFieldUnitIgnored(field) ) {
              /* the largest different calendar field is small than
               * the smallest calendar field in pattern,
               * return single date format.
               */
<span class="line-modified">!             return fDateFormat-&gt;format(fromCalendar, appendTo, pos);</span>
          }
<span class="line-modified">!         return fallbackFormat(fromCalendar, toCalendar, fromToOnSameDay, appendTo, pos, status);</span>
      }
      // If the first part in interval pattern is empty,
      // the 2nd part of it saves the full-pattern used in fall-back.
      // For a &#39;real&#39; interval pattern, the first part will never be empty.
      if ( intervalPattern.firstPart.isEmpty() ) {
          // fall back
          UnicodeString originalPattern;
          fDateFormat-&gt;toPattern(originalPattern);
          fDateFormat-&gt;applyPattern(intervalPattern.secondPart);
<span class="line-modified">!         appendTo = fallbackFormat(fromCalendar, toCalendar, fromToOnSameDay, appendTo, pos, status);</span>
          fDateFormat-&gt;applyPattern(originalPattern);
          return appendTo;
      }
      Calendar* firstCal;
      Calendar* secondCal;
      if ( intervalPattern.laterDateFirst ) {
          firstCal = &amp;toCalendar;
          secondCal = &amp;fromCalendar;
      } else {
          firstCal = &amp;fromCalendar;
          secondCal = &amp;toCalendar;
      }
      // break the interval pattern into 2 parts,
      // first part should not be empty,
      UnicodeString originalPattern;
      fDateFormat-&gt;toPattern(originalPattern);
      fDateFormat-&gt;applyPattern(intervalPattern.firstPart);
<span class="line-modified">!     fDateFormat-&gt;format(*firstCal, appendTo, pos);</span>
      if ( !intervalPattern.secondPart.isEmpty() ) {
          fDateFormat-&gt;applyPattern(intervalPattern.secondPart);
<span class="line-modified">!         FieldPosition otherPos;</span>
<span class="line-removed">-         otherPos.setField(pos.getField());</span>
<span class="line-removed">-         fDateFormat-&gt;format(*secondCal, appendTo, otherPos);</span>
<span class="line-removed">-         if (pos.getEndIndex() == 0 &amp;&amp; otherPos.getEndIndex() &gt; 0) {</span>
<span class="line-removed">-             pos = otherPos;</span>
<span class="line-removed">-         }</span>
      }
      fDateFormat-&gt;applyPattern(originalPattern);
      return appendTo;
  }
  
<span class="line-new-header">--- 471,47 ---</span>
          if ( fDateFormat-&gt;isFieldUnitIgnored(field) ) {
              /* the largest different calendar field is small than
               * the smallest calendar field in pattern,
               * return single date format.
               */
<span class="line-modified">!             return fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
          }
<span class="line-modified">!         return fallbackFormat(fromCalendar, toCalendar, fromToOnSameDay, appendTo, firstIndex, fphandler, status);</span>
      }
      // If the first part in interval pattern is empty,
      // the 2nd part of it saves the full-pattern used in fall-back.
      // For a &#39;real&#39; interval pattern, the first part will never be empty.
      if ( intervalPattern.firstPart.isEmpty() ) {
          // fall back
          UnicodeString originalPattern;
          fDateFormat-&gt;toPattern(originalPattern);
          fDateFormat-&gt;applyPattern(intervalPattern.secondPart);
<span class="line-modified">!         appendTo = fallbackFormat(fromCalendar, toCalendar, fromToOnSameDay, appendTo, firstIndex, fphandler, status);</span>
          fDateFormat-&gt;applyPattern(originalPattern);
          return appendTo;
      }
      Calendar* firstCal;
      Calendar* secondCal;
      if ( intervalPattern.laterDateFirst ) {
          firstCal = &amp;toCalendar;
          secondCal = &amp;fromCalendar;
<span class="line-added">+         firstIndex = 1;</span>
      } else {
          firstCal = &amp;fromCalendar;
          secondCal = &amp;toCalendar;
<span class="line-added">+         firstIndex = 0;</span>
      }
      // break the interval pattern into 2 parts,
      // first part should not be empty,
      UnicodeString originalPattern;
      fDateFormat-&gt;toPattern(originalPattern);
      fDateFormat-&gt;applyPattern(intervalPattern.firstPart);
<span class="line-modified">!     fDateFormat-&gt;_format(*firstCal, appendTo, fphandler, status);</span>
<span class="line-added">+ </span>
      if ( !intervalPattern.secondPart.isEmpty() ) {
          fDateFormat-&gt;applyPattern(intervalPattern.secondPart);
<span class="line-modified">!         fDateFormat-&gt;_format(*secondCal, appendTo, fphandler, status);</span>
      }
      fDateFormat-&gt;applyPattern(originalPattern);
      return appendTo;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 490,11 ***</span>
  
  const TimeZone&amp;
  DateIntervalFormat::getTimeZone() const
  {
      if (fDateFormat != NULL) {
<span class="line-modified">!         Mutex lock(&amp;gFormatterMutex);</span>
          return fDateFormat-&gt;getTimeZone();
      }
      // If fDateFormat is NULL (unexpected), create default timezone.
      return *(TimeZone::createDefault());
  }
<span class="line-new-header">--- 598,11 ---</span>
  
  const TimeZone&amp;
  DateIntervalFormat::getTimeZone() const
  {
      if (fDateFormat != NULL) {
<span class="line-modified">!         Mutex lock(gFormatterMutex());</span>
          return fDateFormat-&gt;getTimeZone();
      }
      // If fDateFormat is NULL (unexpected), create default timezone.
      return *(TimeZone::createDefault());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 875,22 ***</span>
      }
      if ( MCount != 0 ) {
          if ( MCount &lt; 3 ) {
              normalizedDateSkeleton.append(CAP_M);
          } else {
<span class="line-modified">!             int32_t i;</span>
<span class="line-removed">-             for ( i = 0; i &lt; MCount &amp;&amp; i &lt; MAX_M_COUNT; ++i ) {</span>
                   normalizedDateSkeleton.append(CAP_M);
              }
          }
      }
      if ( ECount != 0 ) {
          if ( ECount &lt;= 3 ) {
              normalizedDateSkeleton.append(CAP_E);
          } else {
<span class="line-modified">!             int32_t i;</span>
<span class="line-removed">-             for ( i = 0; i &lt; ECount &amp;&amp; i &lt; MAX_E_COUNT; ++i ) {</span>
                   normalizedDateSkeleton.append(CAP_E);
              }
          }
      }
      if ( dCount != 0 ) {
<span class="line-new-header">--- 983,20 ---</span>
      }
      if ( MCount != 0 ) {
          if ( MCount &lt; 3 ) {
              normalizedDateSkeleton.append(CAP_M);
          } else {
<span class="line-modified">!             for ( int32_t j = 0; j &lt; MCount &amp;&amp; j &lt; MAX_M_COUNT; ++j) {</span>
                   normalizedDateSkeleton.append(CAP_M);
              }
          }
      }
      if ( ECount != 0 ) {
          if ( ECount &lt;= 3 ) {
              normalizedDateSkeleton.append(CAP_E);
          } else {
<span class="line-modified">!             for ( int32_t j = 0; j &lt; ECount &amp;&amp; j &lt; MAX_E_COUNT; ++j ) {</span>
                   normalizedDateSkeleton.append(CAP_E);
              }
          }
      }
      if ( dCount != 0 ) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1022,11 ***</span>
              bestSkeleton = &amp;extendedBestSkeleton;
              skeleton = &amp;extendedSkeleton;
          }
          setIntervalPattern(UCAL_YEAR, skeleton, bestSkeleton, differenceInfo,
                             &amp;extendedSkeleton, &amp;extendedBestSkeleton);
<span class="line-modified">!     } else {</span>
          setIntervalPattern(UCAL_MINUTE, skeleton, bestSkeleton, differenceInfo);
          setIntervalPattern(UCAL_HOUR, skeleton, bestSkeleton, differenceInfo);
          setIntervalPattern(UCAL_AM_PM, skeleton, bestSkeleton, differenceInfo);
      }
      return true;
<span class="line-new-header">--- 1128,13 ---</span>
              bestSkeleton = &amp;extendedBestSkeleton;
              skeleton = &amp;extendedSkeleton;
          }
          setIntervalPattern(UCAL_YEAR, skeleton, bestSkeleton, differenceInfo,
                             &amp;extendedSkeleton, &amp;extendedBestSkeleton);
<span class="line-modified">!         setIntervalPattern(UCAL_ERA, skeleton, bestSkeleton, differenceInfo,</span>
<span class="line-added">+                            &amp;extendedSkeleton, &amp;extendedBestSkeleton);</span>
<span class="line-added">+      } else {</span>
          setIntervalPattern(UCAL_MINUTE, skeleton, bestSkeleton, differenceInfo);
          setIntervalPattern(UCAL_HOUR, skeleton, bestSkeleton, differenceInfo);
          setIntervalPattern(UCAL_AM_PM, skeleton, bestSkeleton, differenceInfo);
      }
      return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1294,97 ***</span>
          }
      }
      return (i - count);
  }
  
<span class="line-modified">! static const UChar bracketedZero[] = {0x7B,0x30,0x7D};</span>
<span class="line-modified">! static const UChar bracketedOne[]  = {0x7B,0x31,0x7D};</span>
<span class="line-modified">! </span>
<span class="line-modified">! void</span>
<span class="line-modified">! DateIntervalFormat::adjustPosition(UnicodeString&amp; combiningPattern, // has {0} and {1} in it</span>
<span class="line-modified">!                                    UnicodeString&amp; pat0, FieldPosition&amp; pos0, // pattern and pos corresponding to {0}</span>
<span class="line-modified">!                                    UnicodeString&amp; pat1, FieldPosition&amp; pos1, // pattern and pos corresponding to {1}</span>
<span class="line-modified">!                                    FieldPosition&amp; posResult)  {</span>
<span class="line-modified">!     int32_t index0 = combiningPattern.indexOf(bracketedZero, 3, 0);</span>
<span class="line-modified">!     int32_t index1 = combiningPattern.indexOf(bracketedOne,  3, 0);</span>
<span class="line-modified">!     if (index0 &lt; 0 || index1 &lt; 0) {</span>
          return;
      }
<span class="line-modified">!     int32_t placeholderLen = 3; // length of &quot;{0}&quot; or &quot;{1}&quot;</span>
<span class="line-modified">!     if (index0 &lt; index1) {</span>
<span class="line-modified">!         if (pos0.getEndIndex() &gt; 0) {</span>
<span class="line-modified">!             posResult.setBeginIndex(pos0.getBeginIndex() + index0);</span>
<span class="line-modified">!             posResult.setEndIndex(pos0.getEndIndex() + index0);</span>
<span class="line-modified">!         } else if (pos1.getEndIndex() &gt; 0) {</span>
<span class="line-modified">!             // here index1 &gt;= 3</span>
<span class="line-modified">!             index1 += pat0.length() - placeholderLen; // adjust for pat0 replacing {0}</span>
<span class="line-modified">!             posResult.setBeginIndex(pos1.getBeginIndex() + index1);</span>
<span class="line-modified">!             posResult.setEndIndex(pos1.getEndIndex() + index1);</span>
<span class="line-modified">!         }</span>
      } else {
<span class="line-modified">!         if (pos1.getEndIndex() &gt; 0) {</span>
<span class="line-modified">!             posResult.setBeginIndex(pos1.getBeginIndex() + index1);</span>
<span class="line-modified">!             posResult.setEndIndex(pos1.getEndIndex() + index1);</span>
<span class="line-modified">!         } else if (pos0.getEndIndex() &gt; 0) {</span>
<span class="line-modified">!             // here index0 &gt;= 3</span>
<span class="line-modified">!             index0 += pat1.length() - placeholderLen; // adjust for pat1 replacing {1}</span>
<span class="line-removed">-             posResult.setBeginIndex(pos0.getBeginIndex() + index0);</span>
<span class="line-removed">-             posResult.setEndIndex(pos0.getEndIndex() + index0);</span>
<span class="line-removed">-         }</span>
      }
  }
  
  UnicodeString&amp;
  DateIntervalFormat::fallbackFormat(Calendar&amp; fromCalendar,
                                     Calendar&amp; toCalendar,
                                     UBool fromToOnSameDay, // new
                                     UnicodeString&amp; appendTo,
<span class="line-modified">!                                    FieldPosition&amp; pos,</span>
                                     UErrorCode&amp; status) const {
      if ( U_FAILURE(status) ) {
          return appendTo;
      }
<span class="line-modified">!     UnicodeString fullPattern; // for saving the pattern in fDateFormat</span>
      UBool formatDatePlusTimeRange = (fromToOnSameDay &amp;&amp; fDatePattern &amp;&amp; fTimePattern);
<span class="line-removed">-     // the fall back</span>
      if (formatDatePlusTimeRange) {
          fDateFormat-&gt;toPattern(fullPattern); // save current pattern, restore later
<span class="line-modified">!         fDateFormat-&gt;applyPattern(*fTimePattern);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     FieldPosition otherPos;</span>
<span class="line-modified">!     otherPos.setField(pos.getField());</span>
<span class="line-modified">!     UnicodeString earlierDate;</span>
<span class="line-modified">!     fDateFormat-&gt;format(fromCalendar, earlierDate, pos);</span>
<span class="line-modified">!     UnicodeString laterDate;</span>
<span class="line-modified">!     fDateFormat-&gt;format(toCalendar, laterDate, otherPos);</span>
<span class="line-modified">!     UnicodeString fallbackPattern;</span>
<span class="line-modified">!     fInfo-&gt;getFallbackIntervalPattern(fallbackPattern);</span>
<span class="line-modified">!     adjustPosition(fallbackPattern, earlierDate, pos, laterDate, otherPos, pos);</span>
<span class="line-modified">!     UnicodeString fallbackRange;</span>
<span class="line-modified">!     SimpleFormatter(fallbackPattern, 2, 2, status).</span>
<span class="line-modified">!             format(earlierDate, laterDate, fallbackRange, status);</span>
<span class="line-modified">!     if ( U_SUCCESS(status) &amp;&amp; formatDatePlusTimeRange ) {</span>
<span class="line-modified">!         // fallbackRange has just the time range, need to format the date part and combine that</span>
<span class="line-modified">!         fDateFormat-&gt;applyPattern(*fDatePattern);</span>
<span class="line-modified">!         UnicodeString datePortion;</span>
<span class="line-modified">!         otherPos.setBeginIndex(0);</span>
<span class="line-modified">!         otherPos.setEndIndex(0);</span>
<span class="line-modified">!         fDateFormat-&gt;format(fromCalendar, datePortion, otherPos);</span>
<span class="line-modified">!         adjustPosition(*fDateTimeFormat, fallbackRange, pos, datePortion, otherPos, pos);</span>
<span class="line-removed">-         const UnicodeString *values[2] = {</span>
<span class="line-removed">-             &amp;fallbackRange,  // {0} is time range</span>
<span class="line-removed">-             &amp;datePortion,  // {1} is single date portion</span>
<span class="line-removed">-         };</span>
<span class="line-removed">-         SimpleFormatter(*fDateTimeFormat, 2, 2, status).</span>
<span class="line-removed">-                 formatAndReplace(values, 2, fallbackRange, NULL, 0, status);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if ( U_SUCCESS(status) ) {</span>
<span class="line-removed">-         appendTo.append(fallbackRange);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (formatDatePlusTimeRange) {</span>
          // restore full pattern
          fDateFormat-&gt;applyPattern(fullPattern);
      }
      return appendTo;
  }
  
  
<span class="line-new-header">--- 1402,93 ---</span>
          }
      }
      return (i - count);
  }
  
<span class="line-modified">! void DateIntervalFormat::fallbackFormatRange(</span>
<span class="line-modified">!         Calendar&amp; fromCalendar,</span>
<span class="line-modified">!         Calendar&amp; toCalendar,</span>
<span class="line-modified">!         UnicodeString&amp; appendTo,</span>
<span class="line-modified">!         int8_t&amp; firstIndex,</span>
<span class="line-modified">!         FieldPositionHandler&amp; fphandler,</span>
<span class="line-modified">!         UErrorCode&amp; status) const {</span>
<span class="line-modified">!     UnicodeString fallbackPattern;</span>
<span class="line-modified">!     fInfo-&gt;getFallbackIntervalPattern(fallbackPattern);</span>
<span class="line-modified">!     SimpleFormatter sf(fallbackPattern, 2, 2, status);</span>
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
          return;
      }
<span class="line-modified">!     int32_t offsets[2];</span>
<span class="line-modified">!     UnicodeString patternBody = sf.getTextWithNoArguments(offsets, 2);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // TODO(ICU-20406): Use SimpleFormatter Iterator interface when available.</span>
<span class="line-modified">!     if (offsets[0] &lt; offsets[1]) {</span>
<span class="line-modified">!         firstIndex = 0;</span>
<span class="line-modified">!         appendTo.append(patternBody.tempSubStringBetween(0, offsets[0]));</span>
<span class="line-modified">!         fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">!         appendTo.append(patternBody.tempSubStringBetween(offsets[0], offsets[1]));</span>
<span class="line-modified">!         fDateFormat-&gt;_format(toCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">!         appendTo.append(patternBody.tempSubStringBetween(offsets[1]));</span>
      } else {
<span class="line-modified">!         firstIndex = 1;</span>
<span class="line-modified">!         appendTo.append(patternBody.tempSubStringBetween(0, offsets[1]));</span>
<span class="line-modified">!         fDateFormat-&gt;_format(toCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">!         appendTo.append(patternBody.tempSubStringBetween(offsets[1], offsets[0]));</span>
<span class="line-modified">!         fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">!         appendTo.append(patternBody.tempSubStringBetween(offsets[0]));</span>
      }
  }
  
  UnicodeString&amp;
  DateIntervalFormat::fallbackFormat(Calendar&amp; fromCalendar,
                                     Calendar&amp; toCalendar,
                                     UBool fromToOnSameDay, // new
                                     UnicodeString&amp; appendTo,
<span class="line-modified">!                                    int8_t&amp; firstIndex,</span>
<span class="line-added">+                                    FieldPositionHandler&amp; fphandler,</span>
                                     UErrorCode&amp; status) const {
      if ( U_FAILURE(status) ) {
          return appendTo;
      }
<span class="line-modified">! </span>
      UBool formatDatePlusTimeRange = (fromToOnSameDay &amp;&amp; fDatePattern &amp;&amp; fTimePattern);
      if (formatDatePlusTimeRange) {
<span class="line-added">+         SimpleFormatter sf(*fDateTimeFormat, 2, 2, status);</span>
<span class="line-added">+         if (U_FAILURE(status)) {</span>
<span class="line-added">+             return appendTo;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         int32_t offsets[2];</span>
<span class="line-added">+         UnicodeString patternBody = sf.getTextWithNoArguments(offsets, 2);</span>
<span class="line-added">+ </span>
<span class="line-added">+         UnicodeString fullPattern; // for saving the pattern in fDateFormat</span>
          fDateFormat-&gt;toPattern(fullPattern); // save current pattern, restore later
<span class="line-modified">! </span>
<span class="line-modified">!         // {0} is time range</span>
<span class="line-modified">!         // {1} is single date portion</span>
<span class="line-modified">!         // TODO(ICU-20406): Use SimpleFormatter Iterator interface when available.</span>
<span class="line-modified">!         if (offsets[0] &lt; offsets[1]) {</span>
<span class="line-modified">!             appendTo.append(patternBody.tempSubStringBetween(0, offsets[0]));</span>
<span class="line-modified">!             fDateFormat-&gt;applyPattern(*fTimePattern);</span>
<span class="line-modified">!             fallbackFormatRange(fromCalendar, toCalendar, appendTo, firstIndex, fphandler, status);</span>
<span class="line-modified">!             appendTo.append(patternBody.tempSubStringBetween(offsets[0], offsets[1]));</span>
<span class="line-modified">!             fDateFormat-&gt;applyPattern(*fDatePattern);</span>
<span class="line-modified">!             fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">!             appendTo.append(patternBody.tempSubStringBetween(offsets[1]));</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             appendTo.append(patternBody.tempSubStringBetween(0, offsets[1]));</span>
<span class="line-modified">!             fDateFormat-&gt;applyPattern(*fDatePattern);</span>
<span class="line-modified">!             fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">!             appendTo.append(patternBody.tempSubStringBetween(offsets[1], offsets[0]));</span>
<span class="line-modified">!             fDateFormat-&gt;applyPattern(*fTimePattern);</span>
<span class="line-modified">!             fallbackFormatRange(fromCalendar, toCalendar, appendTo, firstIndex, fphandler, status);</span>
<span class="line-modified">!             appendTo.append(patternBody.tempSubStringBetween(offsets[0]));</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
          // restore full pattern
          fDateFormat-&gt;applyPattern(fullPattern);
<span class="line-added">+     } else {</span>
<span class="line-added">+         fallbackFormatRange(fromCalendar, toCalendar, appendTo, firstIndex, fphandler, status);</span>
      }
      return appendTo;
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1552,8 ***</span>
<span class="line-new-header">--- 1656,9 ---</span>
      /*eug*/ LOW_E, LOW_U, LOW_G, // DOW_LOCAL, EXTENDED_YEAR, JULIAN_DAY,
      /*A..*/ CAP_A, SPACE, SPACE, // MILLISECONDS_IN_DAY, IS_LEAP_MONTH, FIELD_COUNT
  };
  
  
<span class="line-added">+ </span>
  U_NAMESPACE_END
  
  #endif
</pre>
<center><a href="dtfmtsym.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="dtitvinf.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>