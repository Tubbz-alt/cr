<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/unistr.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="uniset.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="uobject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/unistr.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  89  * (where the empty string &quot;&quot; indicates invariant-character conversion).
  90  *
  91  * @stable ICU 3.2
  92  */
  93 #define US_INV icu::UnicodeString::kInvariant
  94 
  95 /**
  96  * Unicode String literals in C++.
  97  *
  98  * Note: these macros are not recommended for new code.
  99  * Prior to the availability of C++11 and u&quot;unicode string literals&quot;,
 100  * these macros were provided for portability and efficiency when
 101  * initializing UnicodeStrings from literals.
 102  *
 103  * They work only for strings that contain &quot;invariant characters&quot;, i.e.,
 104  * only latin letters, digits, and some punctuation.
 105  * See utypes.h for details.
 106  *
 107  * The string parameter must be a C string literal.
 108  * The length of the string, not including the terminating
<span class="line-modified"> 109  * &lt;code&gt;NUL&lt;/code&gt;, must be specified as a constant.</span>
 110  * @stable ICU 2.0
 111  */
 112 #if !U_CHAR16_IS_TYPEDEF
 113 # define UNICODE_STRING(cs, _length) icu::UnicodeString(TRUE, u ## cs, _length)
 114 #else
 115 # define UNICODE_STRING(cs, _length) icu::UnicodeString(TRUE, (const char16_t*)u ## cs, _length)
 116 #endif
 117 
 118 /**
 119  * Unicode String literals in C++.
 120  * Dependent on the platform properties, different UnicodeString
 121  * constructors should be used to create a UnicodeString object from
 122  * a string literal.
 123  * The macros are defined for improved performance.
 124  * They work only for strings that contain &quot;invariant characters&quot;, i.e.,
 125  * only latin letters, digits, and some punctuation.
 126  * See utypes.h for details.
 127  *
 128  * The string parameter must be a C string literal.
 129  * @stable ICU 2.0
</pre>
<hr />
<pre>
 204 # define UNISTR_OBJECT_SIZE 64
 205 #endif
 206 
 207 /**
 208  * UnicodeString is a string class that stores Unicode characters directly and provides
 209  * similar functionality as the Java String and StringBuffer/StringBuilder classes.
 210  * It is a concrete implementation of the abstract class Replaceable (for transliteration).
 211  *
 212  * A UnicodeString may also &quot;alias&quot; an external array of characters
 213  * (that is, point to it, rather than own the array)
 214  * whose lifetime must then at least match the lifetime of the aliasing object.
 215  * This aliasing may be preserved when returning a UnicodeString by value,
 216  * depending on the compiler and the function implementation,
 217  * via Return Value Optimization (RVO) or the move assignment operator.
 218  * (However, the copy assignment operator does not preserve aliasing.)
 219  * For details see the description of storage models at the end of the class API docs
 220  * and in the User Guide chapter linked from there.
 221  *
 222  * The UnicodeString class is not suitable for subclassing.
 223  *
<span class="line-modified"> 224  * &lt;p&gt;For an overview of Unicode strings in C and C++ see the</span>
<span class="line-modified"> 225  * &lt;a href=&quot;http://userguide.icu-project.org/strings#TOC-Strings-in-C-C-&quot;&gt;User Guide Strings chapter&lt;/a&gt;.&lt;/p&gt;</span>
 226  *
<span class="line-modified"> 227  * &lt;p&gt;In ICU, a Unicode string consists of 16-bit Unicode &lt;em&gt;code units&lt;/em&gt;.</span>
 228  * A Unicode character may be stored with either one code unit
 229  * (the most common case) or with a matched pair of special code units
 230  * (&quot;surrogates&quot;). The data type for code units is char16_t.
<span class="line-modified"> 231  * For single-character handling, a Unicode character code &lt;em&gt;point&lt;/em&gt; is a value</span>
<span class="line-modified"> 232  * in the range 0..0x10ffff. ICU uses the UChar32 type for code points.&lt;/p&gt;</span>
 233  *
<span class="line-modified"> 234  * &lt;p&gt;Indexes and offsets into and lengths of strings always count code units, not code points.</span>
 235  * This is the same as with multi-byte char* strings in traditional string handling.
 236  * Operations on partial strings typically do not test for code point boundaries.
 237  * If necessary, the user needs to take care of such boundaries by testing for the code unit
 238  * values or by using functions like
 239  * UnicodeString::getChar32Start() and UnicodeString::getChar32Limit()
<span class="line-modified"> 240  * (or, in C, the equivalent macros U16_SET_CP_START() and U16_SET_CP_LIMIT(), see utf.h).&lt;/p&gt;</span>
 241  *
 242  * UnicodeString methods are more lenient with regard to input parameter values
 243  * than other ICU APIs. In particular:
 244  * - If indexes are out of bounds for a UnicodeString object
<span class="line-modified"> 245  *   (&lt;0 or &gt;length()) then they are &quot;pinned&quot; to the nearest boundary.</span>



 246  * - If primitive string pointer values (e.g., const char16_t * or char *)
 247  *   for input strings are NULL, then those input string parameters are treated
 248  *   as if they pointed to an empty string.
<span class="line-modified"> 249  *   However, this is &lt;em&gt;not&lt;/em&gt; the case for char * parameters for charset names</span>
 250  *   or other IDs.
 251  * - Most UnicodeString methods do not take a UErrorCode parameter because
 252  *   there are usually very few opportunities for failure other than a shortage
 253  *   of memory, error codes in low-level C++ string methods would be inconvenient,
 254  *   and the error code as the last parameter (ICU convention) would prevent
 255  *   the use of default parameter values.
 256  *   Instead, such methods set the UnicodeString into a &quot;bogus&quot; state
 257  *   (see isBogus()) if an error occurs.
 258  *
 259  * In string comparisons, two UnicodeString objects that are both &quot;bogus&quot;
 260  * compare equal (to be transitive and prevent endless loops in sorting),
 261  * and a &quot;bogus&quot; string compares less than any non-&quot;bogus&quot; one.
 262  *
 263  * Const UnicodeString methods are thread-safe. Multiple threads can use
 264  * const methods on the same UnicodeString object simultaneously,
 265  * but non-const methods must not be called concurrently (in multiple threads)
 266  * with any other (const or non-const) methods.
 267  *
 268  * Similarly, const UnicodeString &amp; parameters are thread-safe.
 269  * One object may be passed in as such a parameter concurrently in multiple threads.
 270  * This includes the const UnicodeString &amp; parameters for
 271  * copy construction, assignment, and cloning.
 272  *
<span class="line-modified"> 273  * &lt;p&gt;UnicodeString uses several storage methods.</span>
 274  * String contents can be stored inside the UnicodeString object itself,
 275  * in an allocated and shared buffer, or in an outside buffer that is &quot;aliased&quot;.
 276  * Most of this is done transparently, but careful aliasing in particular provides
 277  * significant performance improvements.
 278  * Also, the internal buffer is accessible via special functions.
 279  * For details see the
<span class="line-modified"> 280  * &lt;a href=&quot;http://userguide.icu-project.org/strings#TOC-Maximizing-Performance-with-the-UnicodeString-Storage-Model&quot;&gt;User Guide Strings chapter&lt;/a&gt;.&lt;/p&gt;</span>
 281  *
 282  * @see utf.h
 283  * @see CharacterIterator
 284  * @stable ICU 2.0
 285  */
 286 class U_COMMON_API UnicodeString : public Replaceable
 287 {
 288 public:
 289 
 290   /**
 291    * Constant to be used in the UnicodeString(char *, int32_t, EInvariant) constructor
 292    * which constructs a Unicode string from an invariant-character char * string.
 293    * Use the macro US_INV instead of the full qualification for this value.
 294    *
 295    * @see US_INV
 296    * @stable ICU 3.2
 297    */
 298   enum EInvariant {
 299     /**
 300      * @see EInvariant
 301      * @stable ICU 3.2
 302      */
 303     kInvariant
 304   };
 305 
 306   //========================================
 307   // Read-only operations
 308   //========================================
 309 
 310   /* Comparison - bitwise only - for international comparison use collation */
 311 
 312   /**
 313    * Equality operator. Performs only bitwise comparison.
 314    * @param text The UnicodeString to compare to this one.
<span class="line-modified"> 315    * @return TRUE if &lt;TT&gt;text&lt;/TT&gt; contains the same characters as this one,</span>
 316    * FALSE otherwise.
 317    * @stable ICU 2.0
 318    */
 319   inline UBool operator== (const UnicodeString&amp; text) const;
 320 
 321   /**
 322    * Inequality operator. Performs only bitwise comparison.
 323    * @param text The UnicodeString to compare to this one.
<span class="line-modified"> 324    * @return FALSE if &lt;TT&gt;text&lt;/TT&gt; contains the same characters as this one,</span>
 325    * TRUE otherwise.
 326    * @stable ICU 2.0
 327    */
 328   inline UBool operator!= (const UnicodeString&amp; text) const;
 329 
 330   /**
 331    * Greater than operator. Performs only bitwise comparison.
 332    * @param text The UnicodeString to compare to this one.
 333    * @return TRUE if the characters in this are bitwise
<span class="line-modified"> 334    * greater than the characters in &lt;code&gt;text&lt;/code&gt;, FALSE otherwise</span>
 335    * @stable ICU 2.0
 336    */
 337   inline UBool operator&gt; (const UnicodeString&amp; text) const;
 338 
 339   /**
 340    * Less than operator. Performs only bitwise comparison.
 341    * @param text The UnicodeString to compare to this one.
 342    * @return TRUE if the characters in this are bitwise
<span class="line-modified"> 343    * less than the characters in &lt;code&gt;text&lt;/code&gt;, FALSE otherwise</span>
 344    * @stable ICU 2.0
 345    */
 346   inline UBool operator&lt; (const UnicodeString&amp; text) const;
 347 
 348   /**
 349    * Greater than or equal operator. Performs only bitwise comparison.
 350    * @param text The UnicodeString to compare to this one.
 351    * @return TRUE if the characters in this are bitwise
<span class="line-modified"> 352    * greater than or equal to the characters in &lt;code&gt;text&lt;/code&gt;, FALSE otherwise</span>
 353    * @stable ICU 2.0
 354    */
 355   inline UBool operator&gt;= (const UnicodeString&amp; text) const;
 356 
 357   /**
 358    * Less than or equal operator. Performs only bitwise comparison.
 359    * @param text The UnicodeString to compare to this one.
 360    * @return TRUE if the characters in this are bitwise
<span class="line-modified"> 361    * less than or equal to the characters in &lt;code&gt;text&lt;/code&gt;, FALSE otherwise</span>
 362    * @stable ICU 2.0
 363    */
 364   inline UBool operator&lt;= (const UnicodeString&amp; text) const;
 365 
 366   /**
 367    * Compare the characters bitwise in this UnicodeString to
<span class="line-modified"> 368    * the characters in &lt;code&gt;text&lt;/code&gt;.</span>
 369    * @param text The UnicodeString to compare to this one.
 370    * @return The result of bitwise character comparison: 0 if this
<span class="line-modified"> 371    * contains the same characters as &lt;code&gt;text&lt;/code&gt;, -1 if the characters in</span>
<span class="line-modified"> 372    * this are bitwise less than the characters in &lt;code&gt;text&lt;/code&gt;, +1 if the</span>
 373    * characters in this are bitwise greater than the characters
<span class="line-modified"> 374    * in &lt;code&gt;text&lt;/code&gt;.</span>
 375    * @stable ICU 2.0
 376    */
 377   inline int8_t compare(const UnicodeString&amp; text) const;
 378 
 379   /**
 380    * Compare the characters bitwise in the range
<span class="line-modified"> 381    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the characters</span>
<span class="line-modified"> 382    * in the &lt;b&gt;entire string&lt;/b&gt; &lt;TT&gt;text&lt;/TT&gt;.</span>
 383    * (The parameters &quot;start&quot; and &quot;length&quot; are not applied to the other text &quot;text&quot;.)
 384    * @param start the offset at which the compare operation begins
 385    * @param length the number of characters of text to compare.
 386    * @param text the other text to be compared against this string.
 387    * @return The result of bitwise character comparison: 0 if this
<span class="line-modified"> 388    * contains the same characters as &lt;code&gt;text&lt;/code&gt;, -1 if the characters in</span>
<span class="line-modified"> 389    * this are bitwise less than the characters in &lt;code&gt;text&lt;/code&gt;, +1 if the</span>
 390    * characters in this are bitwise greater than the characters
<span class="line-modified"> 391    * in &lt;code&gt;text&lt;/code&gt;.</span>
 392    * @stable ICU 2.0
 393    */
 394   inline int8_t compare(int32_t start,
 395          int32_t length,
 396          const UnicodeString&amp; text) const;
 397 
 398   /**
 399    * Compare the characters bitwise in the range
<span class="line-modified"> 400    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the characters</span>
<span class="line-modified"> 401    * in &lt;TT&gt;srcText&lt;/TT&gt; in the range</span>
<span class="line-modified"> 402    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).</span>
 403    * @param start the offset at which the compare operation begins
 404    * @param length the number of characters in this to compare.
 405    * @param srcText the text to be compared
<span class="line-modified"> 406    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; to start comparison</span>
<span class="line-modified"> 407    * @param srcLength the number of characters in &lt;TT&gt;src&lt;/TT&gt; to compare</span>
 408    * @return The result of bitwise character comparison: 0 if this
<span class="line-modified"> 409    * contains the same characters as &lt;code&gt;srcText&lt;/code&gt;, -1 if the characters in</span>
<span class="line-modified"> 410    * this are bitwise less than the characters in &lt;code&gt;srcText&lt;/code&gt;, +1 if the</span>
 411    * characters in this are bitwise greater than the characters
<span class="line-modified"> 412    * in &lt;code&gt;srcText&lt;/code&gt;.</span>
 413    * @stable ICU 2.0
 414    */
 415    inline int8_t compare(int32_t start,
 416          int32_t length,
 417          const UnicodeString&amp; srcText,
 418          int32_t srcStart,
 419          int32_t srcLength) const;
 420 
 421   /**
 422    * Compare the characters bitwise in this UnicodeString with the first
<span class="line-modified"> 423    * &lt;TT&gt;srcLength&lt;/TT&gt; characters in &lt;TT&gt;srcChars&lt;/TT&gt;.</span>
 424    * @param srcChars The characters to compare to this UnicodeString.
<span class="line-modified"> 425    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to compare</span>
 426    * @return The result of bitwise character comparison: 0 if this
<span class="line-modified"> 427    * contains the same characters as &lt;code&gt;srcChars&lt;/code&gt;, -1 if the characters in</span>
<span class="line-modified"> 428    * this are bitwise less than the characters in &lt;code&gt;srcChars&lt;/code&gt;, +1 if the</span>
 429    * characters in this are bitwise greater than the characters
<span class="line-modified"> 430    * in &lt;code&gt;srcChars&lt;/code&gt;.</span>
 431    * @stable ICU 2.0
 432    */
 433   inline int8_t compare(ConstChar16Ptr srcChars,
 434          int32_t srcLength) const;
 435 
 436   /**
 437    * Compare the characters bitwise in the range
<span class="line-modified"> 438    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the first</span>
<span class="line-modified"> 439    * &lt;TT&gt;length&lt;/TT&gt; characters in &lt;TT&gt;srcChars&lt;/TT&gt;</span>
 440    * @param start the offset at which the compare operation begins
 441    * @param length the number of characters to compare.
 442    * @param srcChars the characters to be compared
 443    * @return The result of bitwise character comparison: 0 if this
<span class="line-modified"> 444    * contains the same characters as &lt;code&gt;srcChars&lt;/code&gt;, -1 if the characters in</span>
<span class="line-modified"> 445    * this are bitwise less than the characters in &lt;code&gt;srcChars&lt;/code&gt;, +1 if the</span>
 446    * characters in this are bitwise greater than the characters
<span class="line-modified"> 447    * in &lt;code&gt;srcChars&lt;/code&gt;.</span>
 448    * @stable ICU 2.0
 449    */
 450   inline int8_t compare(int32_t start,
 451          int32_t length,
 452          const char16_t *srcChars) const;
 453 
 454   /**
 455    * Compare the characters bitwise in the range
<span class="line-modified"> 456    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the characters</span>
<span class="line-modified"> 457    * in &lt;TT&gt;srcChars&lt;/TT&gt; in the range</span>
<span class="line-modified"> 458    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).</span>
 459    * @param start the offset at which the compare operation begins
 460    * @param length the number of characters in this to compare
 461    * @param srcChars the characters to be compared
<span class="line-modified"> 462    * @param srcStart the offset into &lt;TT&gt;srcChars&lt;/TT&gt; to start comparison</span>
<span class="line-modified"> 463    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to compare</span>
 464    * @return The result of bitwise character comparison: 0 if this
<span class="line-modified"> 465    * contains the same characters as &lt;code&gt;srcChars&lt;/code&gt;, -1 if the characters in</span>
<span class="line-modified"> 466    * this are bitwise less than the characters in &lt;code&gt;srcChars&lt;/code&gt;, +1 if the</span>
 467    * characters in this are bitwise greater than the characters
<span class="line-modified"> 468    * in &lt;code&gt;srcChars&lt;/code&gt;.</span>
 469    * @stable ICU 2.0
 470    */
 471   inline int8_t compare(int32_t start,
 472          int32_t length,
 473          const char16_t *srcChars,
 474          int32_t srcStart,
 475          int32_t srcLength) const;
 476 
 477   /**
 478    * Compare the characters bitwise in the range
<span class="line-modified"> 479    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;limit&lt;/TT&gt;) with the characters</span>
<span class="line-modified"> 480    * in &lt;TT&gt;srcText&lt;/TT&gt; in the range</span>
<span class="line-modified"> 481    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcLimit&lt;/TT&gt;).</span>
 482    * @param start the offset at which the compare operation begins
 483    * @param limit the offset immediately following the compare operation
 484    * @param srcText the text to be compared
<span class="line-modified"> 485    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; to start comparison</span>
<span class="line-modified"> 486    * @param srcLimit the offset into &lt;TT&gt;srcText&lt;/TT&gt; to limit comparison</span>
 487    * @return The result of bitwise character comparison: 0 if this
<span class="line-modified"> 488    * contains the same characters as &lt;code&gt;srcText&lt;/code&gt;, -1 if the characters in</span>
<span class="line-modified"> 489    * this are bitwise less than the characters in &lt;code&gt;srcText&lt;/code&gt;, +1 if the</span>
 490    * characters in this are bitwise greater than the characters
<span class="line-modified"> 491    * in &lt;code&gt;srcText&lt;/code&gt;.</span>
 492    * @stable ICU 2.0
 493    */
 494   inline int8_t compareBetween(int32_t start,
 495             int32_t limit,
 496             const UnicodeString&amp; srcText,
 497             int32_t srcStart,
 498             int32_t srcLimit) const;
 499 
 500   /**
 501    * Compare two Unicode strings in code point order.
 502    * The result may be different from the results of compare(), operator&lt;, etc.
 503    * if supplementary characters are present:
 504    *
 505    * In UTF-16, supplementary characters (with code points U+10000 and above) are
 506    * stored with pairs of surrogate code units. These have values from 0xd800 to 0xdfff,
 507    * which means that they compare as less than some other BMP characters like U+feff.
 508    * This function compares Unicode strings in code point order.
 509    * If either of the UTF-16 strings is malformed (i.e., it contains unpaired surrogates), then the result is not defined.
 510    *
 511    * @param text Another string to compare this one to.
</pre>
<hr />
<pre>
 828    *   - U_FOLD_CASE_DEFAULT or 0 is used for default options:
 829    *     Comparison in code unit order with default case folding.
 830    *
 831    *   - U_COMPARE_CODE_POINT_ORDER
 832    *     Set to choose code point order instead of code unit order
 833    *     (see u_strCompare for details).
 834    *
 835    *   - U_FOLD_CASE_EXCLUDE_SPECIAL_I
 836    *
 837    * @return A negative, zero, or positive integer indicating the comparison result.
 838    * @stable ICU 2.0
 839    */
 840   inline int8_t caseCompareBetween(int32_t start,
 841             int32_t limit,
 842             const UnicodeString&amp; srcText,
 843             int32_t srcStart,
 844             int32_t srcLimit,
 845             uint32_t options) const;
 846 
 847   /**
<span class="line-modified"> 848    * Determine if this starts with the characters in &lt;TT&gt;text&lt;/TT&gt;</span>
 849    * @param text The text to match.
<span class="line-modified"> 850    * @return TRUE if this starts with the characters in &lt;TT&gt;text&lt;/TT&gt;,</span>
 851    * FALSE otherwise
 852    * @stable ICU 2.0
 853    */
 854   inline UBool startsWith(const UnicodeString&amp; text) const;
 855 
 856   /**
<span class="line-modified"> 857    * Determine if this starts with the characters in &lt;TT&gt;srcText&lt;/TT&gt;</span>
<span class="line-modified"> 858    * in the range [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).</span>
 859    * @param srcText The text to match.
<span class="line-modified"> 860    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; to start matching</span>
<span class="line-modified"> 861    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; to match</span>
<span class="line-modified"> 862    * @return TRUE if this starts with the characters in &lt;TT&gt;text&lt;/TT&gt;,</span>
 863    * FALSE otherwise
 864    * @stable ICU 2.0
 865    */
 866   inline UBool startsWith(const UnicodeString&amp; srcText,
 867             int32_t srcStart,
 868             int32_t srcLength) const;
 869 
 870   /**
<span class="line-modified"> 871    * Determine if this starts with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;</span>
 872    * @param srcChars The characters to match.
<span class="line-modified"> 873    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt;</span>
<span class="line-modified"> 874    * @return TRUE if this starts with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;,</span>
 875    * FALSE otherwise
 876    * @stable ICU 2.0
 877    */
 878   inline UBool startsWith(ConstChar16Ptr srcChars,
 879             int32_t srcLength) const;
 880 
 881   /**
<span class="line-modified"> 882    * Determine if this ends with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;</span>
<span class="line-modified"> 883    * in the range  [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).</span>
 884    * @param srcChars The characters to match.
<span class="line-modified"> 885    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; to start matching</span>
<span class="line-modified"> 886    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to match</span>
<span class="line-modified"> 887    * @return TRUE if this ends with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;, FALSE otherwise</span>
 888    * @stable ICU 2.0
 889    */
 890   inline UBool startsWith(const char16_t *srcChars,
 891             int32_t srcStart,
 892             int32_t srcLength) const;
 893 
 894   /**
<span class="line-modified"> 895    * Determine if this ends with the characters in &lt;TT&gt;text&lt;/TT&gt;</span>
 896    * @param text The text to match.
<span class="line-modified"> 897    * @return TRUE if this ends with the characters in &lt;TT&gt;text&lt;/TT&gt;,</span>
 898    * FALSE otherwise
 899    * @stable ICU 2.0
 900    */
 901   inline UBool endsWith(const UnicodeString&amp; text) const;
 902 
 903   /**
<span class="line-modified"> 904    * Determine if this ends with the characters in &lt;TT&gt;srcText&lt;/TT&gt;</span>
<span class="line-modified"> 905    * in the range [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).</span>
 906    * @param srcText The text to match.
<span class="line-modified"> 907    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; to start matching</span>
<span class="line-modified"> 908    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; to match</span>
<span class="line-modified"> 909    * @return TRUE if this ends with the characters in &lt;TT&gt;text&lt;/TT&gt;,</span>
 910    * FALSE otherwise
 911    * @stable ICU 2.0
 912    */
 913   inline UBool endsWith(const UnicodeString&amp; srcText,
 914           int32_t srcStart,
 915           int32_t srcLength) const;
 916 
 917   /**
<span class="line-modified"> 918    * Determine if this ends with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;</span>
 919    * @param srcChars The characters to match.
<span class="line-modified"> 920    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt;</span>
<span class="line-modified"> 921    * @return TRUE if this ends with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;,</span>
 922    * FALSE otherwise
 923    * @stable ICU 2.0
 924    */
 925   inline UBool endsWith(ConstChar16Ptr srcChars,
 926           int32_t srcLength) const;
 927 
 928   /**
<span class="line-modified"> 929    * Determine if this ends with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;</span>
<span class="line-modified"> 930    * in the range  [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).</span>
 931    * @param srcChars The characters to match.
<span class="line-modified"> 932    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; to start matching</span>
<span class="line-modified"> 933    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to match</span>
<span class="line-modified"> 934    * @return TRUE if this ends with the characters in &lt;TT&gt;srcChars&lt;/TT&gt;,</span>
 935    * FALSE otherwise
 936    * @stable ICU 2.0
 937    */
 938   inline UBool endsWith(const char16_t *srcChars,
 939           int32_t srcStart,
 940           int32_t srcLength) const;
 941 
 942 
 943   /* Searching - bitwise only */
 944 
 945   /**
<span class="line-modified"> 946    * Locate in this the first occurrence of the characters in &lt;TT&gt;text&lt;/TT&gt;,</span>
 947    * using bitwise comparison.
 948    * @param text The text to search for.
<span class="line-modified"> 949    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,</span>
 950    * or -1 if not found.
 951    * @stable ICU 2.0
 952    */
 953   inline int32_t indexOf(const UnicodeString&amp; text) const;
 954 
 955   /**
<span class="line-modified"> 956    * Locate in this the first occurrence of the characters in &lt;TT&gt;text&lt;/TT&gt;</span>
<span class="line-modified"> 957    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.</span>
 958    * @param text The text to search for.
 959    * @param start The offset at which searching will start.
<span class="line-modified"> 960    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,</span>
 961    * or -1 if not found.
 962    * @stable ICU 2.0
 963    */
 964   inline int32_t indexOf(const UnicodeString&amp; text,
 965               int32_t start) const;
 966 
 967   /**
 968    * Locate in this the first occurrence in the range
<span class="line-modified"> 969    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters</span>
<span class="line-modified"> 970    * in &lt;TT&gt;text&lt;/TT&gt;, using bitwise comparison.</span>
 971    * @param text The text to search for.
 972    * @param start The offset at which searching will start.
 973    * @param length The number of characters to search
<span class="line-modified"> 974    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,</span>
 975    * or -1 if not found.
 976    * @stable ICU 2.0
 977    */
 978   inline int32_t indexOf(const UnicodeString&amp; text,
 979               int32_t start,
 980               int32_t length) const;
 981 
 982   /**
 983    * Locate in this the first occurrence in the range
<span class="line-modified"> 984    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters</span>
<span class="line-modified"> 985    *  in &lt;TT&gt;srcText&lt;/TT&gt; in the range</span>
<span class="line-modified"> 986    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;),</span>
 987    * using bitwise comparison.
 988    * @param srcText The text to search for.
<span class="line-modified"> 989    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; at which</span>
 990    * to start matching
<span class="line-modified"> 991    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; to match</span>
 992    * @param start the offset into this at which to start matching
 993    * @param length the number of characters in this to search
<span class="line-modified"> 994    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,</span>
 995    * or -1 if not found.
 996    * @stable ICU 2.0
 997    */
 998   inline int32_t indexOf(const UnicodeString&amp; srcText,
 999               int32_t srcStart,
1000               int32_t srcLength,
1001               int32_t start,
1002               int32_t length) const;
1003 
1004   /**
1005    * Locate in this the first occurrence of the characters in
<span class="line-modified">1006    * &lt;TT&gt;srcChars&lt;/TT&gt;</span>
<span class="line-modified">1007    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.</span>
1008    * @param srcChars The text to search for.
<span class="line-modified">1009    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to match</span>
1010    * @param start the offset into this at which to start matching
<span class="line-modified">1011    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,</span>
1012    * or -1 if not found.
1013    * @stable ICU 2.0
1014    */
1015   inline int32_t indexOf(const char16_t *srcChars,
1016               int32_t srcLength,
1017               int32_t start) const;
1018 
1019   /**
1020    * Locate in this the first occurrence in the range
<span class="line-modified">1021    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters</span>
<span class="line-modified">1022    * in &lt;TT&gt;srcChars&lt;/TT&gt;, using bitwise comparison.</span>
1023    * @param srcChars The text to search for.
<span class="line-modified">1024    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt;</span>
1025    * @param start The offset at which searching will start.
1026    * @param length The number of characters to search
<span class="line-modified">1027    * @return The offset into this of the start of &lt;TT&gt;srcChars&lt;/TT&gt;,</span>
1028    * or -1 if not found.
1029    * @stable ICU 2.0
1030    */
1031   inline int32_t indexOf(ConstChar16Ptr srcChars,
1032               int32_t srcLength,
1033               int32_t start,
1034               int32_t length) const;
1035 
1036   /**
1037    * Locate in this the first occurrence in the range
<span class="line-modified">1038    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters</span>
<span class="line-modified">1039    * in &lt;TT&gt;srcChars&lt;/TT&gt; in the range</span>
<span class="line-modified">1040    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;),</span>
1041    * using bitwise comparison.
1042    * @param srcChars The text to search for.
<span class="line-modified">1043    * @param srcStart the offset into &lt;TT&gt;srcChars&lt;/TT&gt; at which</span>
1044    * to start matching
<span class="line-modified">1045    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to match</span>
1046    * @param start the offset into this at which to start matching
1047    * @param length the number of characters in this to search
<span class="line-modified">1048    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,</span>
1049    * or -1 if not found.
1050    * @stable ICU 2.0
1051    */
1052   int32_t indexOf(const char16_t *srcChars,
1053               int32_t srcStart,
1054               int32_t srcLength,
1055               int32_t start,
1056               int32_t length) const;
1057 
1058   /**
<span class="line-modified">1059    * Locate in this the first occurrence of the BMP code point &lt;code&gt;c&lt;/code&gt;,</span>
1060    * using bitwise comparison.
1061    * @param c The code unit to search for.
<span class="line-modified">1062    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.</span>
1063    * @stable ICU 2.0
1064    */
1065   inline int32_t indexOf(char16_t c) const;
1066 
1067   /**
<span class="line-modified">1068    * Locate in this the first occurrence of the code point &lt;TT&gt;c&lt;/TT&gt;,</span>
1069    * using bitwise comparison.
1070    *
1071    * @param c The code point to search for.
<span class="line-modified">1072    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.</span>
1073    * @stable ICU 2.0
1074    */
1075   inline int32_t indexOf(UChar32 c) const;
1076 
1077   /**
<span class="line-modified">1078    * Locate in this the first occurrence of the BMP code point &lt;code&gt;c&lt;/code&gt;,</span>
<span class="line-modified">1079    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.</span>
1080    * @param c The code unit to search for.
1081    * @param start The offset at which searching will start.
<span class="line-modified">1082    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.</span>
1083    * @stable ICU 2.0
1084    */
1085   inline int32_t indexOf(char16_t c,
1086               int32_t start) const;
1087 
1088   /**
<span class="line-modified">1089    * Locate in this the first occurrence of the code point &lt;TT&gt;c&lt;/TT&gt;</span>
<span class="line-modified">1090    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.</span>
1091    *
1092    * @param c The code point to search for.
1093    * @param start The offset at which searching will start.
<span class="line-modified">1094    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.</span>
1095    * @stable ICU 2.0
1096    */
1097   inline int32_t indexOf(UChar32 c,
1098               int32_t start) const;
1099 
1100   /**
<span class="line-modified">1101    * Locate in this the first occurrence of the BMP code point &lt;code&gt;c&lt;/code&gt;</span>
<span class="line-modified">1102    * in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;),</span>
1103    * using bitwise comparison.
1104    * @param c The code unit to search for.
1105    * @param start the offset into this at which to start matching
1106    * @param length the number of characters in this to search
<span class="line-modified">1107    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.</span>
1108    * @stable ICU 2.0
1109    */
1110   inline int32_t indexOf(char16_t c,
1111               int32_t start,
1112               int32_t length) const;
1113 
1114   /**
<span class="line-modified">1115    * Locate in this the first occurrence of the code point &lt;TT&gt;c&lt;/TT&gt;</span>
<span class="line-modified">1116    * in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;),</span>
1117    * using bitwise comparison.
1118    *
1119    * @param c The code point to search for.
1120    * @param start the offset into this at which to start matching
1121    * @param length the number of characters in this to search
<span class="line-modified">1122    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.</span>
1123    * @stable ICU 2.0
1124    */
1125   inline int32_t indexOf(UChar32 c,
1126               int32_t start,
1127               int32_t length) const;
1128 
1129   /**
<span class="line-modified">1130    * Locate in this the last occurrence of the characters in &lt;TT&gt;text&lt;/TT&gt;,</span>
1131    * using bitwise comparison.
1132    * @param text The text to search for.
<span class="line-modified">1133    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,</span>
1134    * or -1 if not found.
1135    * @stable ICU 2.0
1136    */
1137   inline int32_t lastIndexOf(const UnicodeString&amp; text) const;
1138 
1139   /**
<span class="line-modified">1140    * Locate in this the last occurrence of the characters in &lt;TT&gt;text&lt;/TT&gt;</span>
<span class="line-modified">1141    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.</span>
1142    * @param text The text to search for.
1143    * @param start The offset at which searching will start.
<span class="line-modified">1144    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,</span>
1145    * or -1 if not found.
1146    * @stable ICU 2.0
1147    */
1148   inline int32_t lastIndexOf(const UnicodeString&amp; text,
1149               int32_t start) const;
1150 
1151   /**
1152    * Locate in this the last occurrence in the range
<span class="line-modified">1153    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters</span>
<span class="line-modified">1154    * in &lt;TT&gt;text&lt;/TT&gt;, using bitwise comparison.</span>
1155    * @param text The text to search for.
1156    * @param start The offset at which searching will start.
1157    * @param length The number of characters to search
<span class="line-modified">1158    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,</span>
1159    * or -1 if not found.
1160    * @stable ICU 2.0
1161    */
1162   inline int32_t lastIndexOf(const UnicodeString&amp; text,
1163               int32_t start,
1164               int32_t length) const;
1165 
1166   /**
1167    * Locate in this the last occurrence in the range
<span class="line-modified">1168    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters</span>
<span class="line-modified">1169    * in &lt;TT&gt;srcText&lt;/TT&gt; in the range</span>
<span class="line-modified">1170    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;),</span>
1171    * using bitwise comparison.
1172    * @param srcText The text to search for.
<span class="line-modified">1173    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; at which</span>
1174    * to start matching
<span class="line-modified">1175    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; to match</span>
1176    * @param start the offset into this at which to start matching
1177    * @param length the number of characters in this to search
<span class="line-modified">1178    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,</span>
1179    * or -1 if not found.
1180    * @stable ICU 2.0
1181    */
1182   inline int32_t lastIndexOf(const UnicodeString&amp; srcText,
1183               int32_t srcStart,
1184               int32_t srcLength,
1185               int32_t start,
1186               int32_t length) const;
1187 
1188   /**
<span class="line-modified">1189    * Locate in this the last occurrence of the characters in &lt;TT&gt;srcChars&lt;/TT&gt;</span>
<span class="line-modified">1190    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.</span>
1191    * @param srcChars The text to search for.
<span class="line-modified">1192    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to match</span>
1193    * @param start the offset into this at which to start matching
<span class="line-modified">1194    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,</span>
1195    * or -1 if not found.
1196    * @stable ICU 2.0
1197    */
1198   inline int32_t lastIndexOf(const char16_t *srcChars,
1199               int32_t srcLength,
1200               int32_t start) const;
1201 
1202   /**
1203    * Locate in this the last occurrence in the range
<span class="line-modified">1204    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters</span>
<span class="line-modified">1205    * in &lt;TT&gt;srcChars&lt;/TT&gt;, using bitwise comparison.</span>
1206    * @param srcChars The text to search for.
<span class="line-modified">1207    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt;</span>
1208    * @param start The offset at which searching will start.
1209    * @param length The number of characters to search
<span class="line-modified">1210    * @return The offset into this of the start of &lt;TT&gt;srcChars&lt;/TT&gt;,</span>
1211    * or -1 if not found.
1212    * @stable ICU 2.0
1213    */
1214   inline int32_t lastIndexOf(ConstChar16Ptr srcChars,
1215               int32_t srcLength,
1216               int32_t start,
1217               int32_t length) const;
1218 
1219   /**
1220    * Locate in this the last occurrence in the range
<span class="line-modified">1221    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) of the characters</span>
<span class="line-modified">1222    * in &lt;TT&gt;srcChars&lt;/TT&gt; in the range</span>
<span class="line-modified">1223    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;),</span>
1224    * using bitwise comparison.
1225    * @param srcChars The text to search for.
<span class="line-modified">1226    * @param srcStart the offset into &lt;TT&gt;srcChars&lt;/TT&gt; at which</span>
1227    * to start matching
<span class="line-modified">1228    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; to match</span>
1229    * @param start the offset into this at which to start matching
1230    * @param length the number of characters in this to search
<span class="line-modified">1231    * @return The offset into this of the start of &lt;TT&gt;text&lt;/TT&gt;,</span>
1232    * or -1 if not found.
1233    * @stable ICU 2.0
1234    */
1235   int32_t lastIndexOf(const char16_t *srcChars,
1236               int32_t srcStart,
1237               int32_t srcLength,
1238               int32_t start,
1239               int32_t length) const;
1240 
1241   /**
<span class="line-modified">1242    * Locate in this the last occurrence of the BMP code point &lt;code&gt;c&lt;/code&gt;,</span>
1243    * using bitwise comparison.
1244    * @param c The code unit to search for.
<span class="line-modified">1245    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.</span>
1246    * @stable ICU 2.0
1247    */
1248   inline int32_t lastIndexOf(char16_t c) const;
1249 
1250   /**
<span class="line-modified">1251    * Locate in this the last occurrence of the code point &lt;TT&gt;c&lt;/TT&gt;,</span>
1252    * using bitwise comparison.
1253    *
1254    * @param c The code point to search for.
<span class="line-modified">1255    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.</span>
1256    * @stable ICU 2.0
1257    */
1258   inline int32_t lastIndexOf(UChar32 c) const;
1259 
1260   /**
<span class="line-modified">1261    * Locate in this the last occurrence of the BMP code point &lt;code&gt;c&lt;/code&gt;</span>
<span class="line-modified">1262    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.</span>
1263    * @param c The code unit to search for.
1264    * @param start The offset at which searching will start.
<span class="line-modified">1265    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.</span>
1266    * @stable ICU 2.0
1267    */
1268   inline int32_t lastIndexOf(char16_t c,
1269               int32_t start) const;
1270 
1271   /**
<span class="line-modified">1272    * Locate in this the last occurrence of the code point &lt;TT&gt;c&lt;/TT&gt;</span>
<span class="line-modified">1273    * starting at offset &lt;TT&gt;start&lt;/TT&gt;, using bitwise comparison.</span>
1274    *
1275    * @param c The code point to search for.
1276    * @param start The offset at which searching will start.
<span class="line-modified">1277    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.</span>
1278    * @stable ICU 2.0
1279    */
1280   inline int32_t lastIndexOf(UChar32 c,
1281               int32_t start) const;
1282 
1283   /**
<span class="line-modified">1284    * Locate in this the last occurrence of the BMP code point &lt;code&gt;c&lt;/code&gt;</span>
<span class="line-modified">1285    * in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;),</span>
1286    * using bitwise comparison.
1287    * @param c The code unit to search for.
1288    * @param start the offset into this at which to start matching
1289    * @param length the number of characters in this to search
<span class="line-modified">1290    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.</span>
1291    * @stable ICU 2.0
1292    */
1293   inline int32_t lastIndexOf(char16_t c,
1294               int32_t start,
1295               int32_t length) const;
1296 
1297   /**
<span class="line-modified">1298    * Locate in this the last occurrence of the code point &lt;TT&gt;c&lt;/TT&gt;</span>
<span class="line-modified">1299    * in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;),</span>
1300    * using bitwise comparison.
1301    *
1302    * @param c The code point to search for.
1303    * @param start the offset into this at which to start matching
1304    * @param length the number of characters in this to search
<span class="line-modified">1305    * @return The offset into this of &lt;TT&gt;c&lt;/TT&gt;, or -1 if not found.</span>
1306    * @stable ICU 2.0
1307    */
1308   inline int32_t lastIndexOf(UChar32 c,
1309               int32_t start,
1310               int32_t length) const;
1311 
1312 
1313   /* Character access */
1314 
1315   /**
<span class="line-modified">1316    * Return the code unit at offset &lt;tt&gt;offset&lt;/tt&gt;.</span>
1317    * If the offset is not valid (0..length()-1) then U+ffff is returned.
1318    * @param offset a valid offset into the text
<span class="line-modified">1319    * @return the code unit at offset &lt;tt&gt;offset&lt;/tt&gt;</span>
1320    *         or 0xffff if the offset is not valid for this string
1321    * @stable ICU 2.0
1322    */
1323   inline char16_t charAt(int32_t offset) const;
1324 
1325   /**
<span class="line-modified">1326    * Return the code unit at offset &lt;tt&gt;offset&lt;/tt&gt;.</span>
1327    * If the offset is not valid (0..length()-1) then U+ffff is returned.
1328    * @param offset a valid offset into the text
<span class="line-modified">1329    * @return the code unit at offset &lt;tt&gt;offset&lt;/tt&gt;</span>
1330    * @stable ICU 2.0
1331    */
1332   inline char16_t operator[] (int32_t offset) const;
1333 
1334   /**
1335    * Return the code point that contains the code unit
<span class="line-modified">1336    * at offset &lt;tt&gt;offset&lt;/tt&gt;.</span>
1337    * If the offset is not valid (0..length()-1) then U+ffff is returned.
1338    * @param offset a valid offset into the text
1339    * that indicates the text offset of any of the code units
1340    * that will be assembled into a code point (21-bit value) and returned
<span class="line-modified">1341    * @return the code point of text at &lt;tt&gt;offset&lt;/tt&gt;</span>
1342    *         or 0xffff if the offset is not valid for this string
1343    * @stable ICU 2.0
1344    */
1345   UChar32 char32At(int32_t offset) const;
1346 
1347   /**
1348    * Adjust a random-access offset so that
1349    * it points to the beginning of a Unicode character.
1350    * The offset that is passed in points to
1351    * any code unit of a code point,
1352    * while the returned offset will point to the first code unit
1353    * of the same code point.
1354    * In UTF-16, if the input offset points to a second surrogate
1355    * of a surrogate pair, then the returned offset will point
1356    * to the first surrogate.
1357    * @param offset a valid offset into one code point of the text
1358    * @return offset of the first code unit of the same code point
1359    * @see U16_SET_CP_START
1360    * @stable ICU 2.0
1361    */
</pre>
<hr />
<pre>
1378    * @stable ICU 2.0
1379    */
1380   int32_t getChar32Limit(int32_t offset) const;
1381 
1382   /**
1383    * Move the code unit index along the string by delta code points.
1384    * Interpret the input index as a code unit-based offset into the string,
1385    * move the index forward or backward by delta code points, and
1386    * return the resulting index.
1387    * The input index should point to the first code unit of a code point,
1388    * if there is more than one.
1389    *
1390    * Both input and output indexes are code unit-based as for all
1391    * string indexes/offsets in ICU (and other libraries, like MBCS char*).
1392    * If delta&lt;0 then the index is moved backward (toward the start of the string).
1393    * If delta&gt;0 then the index is moved forward (toward the end of the string).
1394    *
1395    * This behaves like CharacterIterator::move32(delta, kCurrent).
1396    *
1397    * Behavior for out-of-bounds indexes:
<span class="line-modified">1398    * &lt;code&gt;moveIndex32&lt;/code&gt; pins the input index to 0..length(), i.e.,</span>
1399    * if the input index&lt;0 then it is pinned to 0;
1400    * if it is index&gt;length() then it is pinned to length().
<span class="line-modified">1401    * Afterwards, the index is moved by &lt;code&gt;delta&lt;/code&gt; code points</span>
1402    * forward or backward,
1403    * but no further backward than to 0 and no further forward than to length().
1404    * The resulting index return value will be in between 0 and length(), inclusively.
1405    *
1406    * Examples:
<span class="line-modified">1407    * &lt;pre&gt;</span>
<span class="line-modified">1408    * // s has code points &#39;a&#39; U+10000 &#39;b&#39; U+10ffff U+2029</span>
<span class="line-modified">1409    * UnicodeString s=UNICODE_STRING(&quot;a\\U00010000b\\U0010ffff\\u2029&quot;, 31).unescape();</span>
1410    *
<span class="line-modified">1411    * // initial index: position of U+10000</span>
<span class="line-modified">1412    * int32_t index=1;</span>
1413    *
<span class="line-modified">1414    * // the following examples will all result in index==4, position of U+10ffff</span>
1415    *
<span class="line-modified">1416    * // skip 2 code points from some position in the string</span>
<span class="line-modified">1417    * index=s.moveIndex32(index, 2); // skips U+10000 and &#39;b&#39;</span>
1418    *
<span class="line-modified">1419    * // go to the 3rd code point from the start of s (0-based)</span>
<span class="line-modified">1420    * index=s.moveIndex32(0, 3); // skips &#39;a&#39;, U+10000, and &#39;b&#39;</span>
1421    *
<span class="line-modified">1422    * // go to the next-to-last code point of s</span>
<span class="line-modified">1423    * index=s.moveIndex32(s.length(), -2); // backward-skips U+2029 and U+10ffff</span>
<span class="line-modified">1424    * &lt;/pre&gt;</span>
1425    *
1426    * @param index input code unit index
1427    * @param delta (signed) code point count to move the index forward or backward
1428    *        in the string
1429    * @return the resulting code unit index
1430    * @stable ICU 2.0
1431    */
1432   int32_t moveIndex32(int32_t index, int32_t delta) const;
1433 
1434   /* Substring extraction */
1435 
1436   /**
1437    * Copy the characters in the range
<span class="line-modified">1438    * [&lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;start + length&lt;/tt&gt;) into the array &lt;tt&gt;dst&lt;/tt&gt;,</span>
<span class="line-modified">1439    * beginning at &lt;tt&gt;dstStart&lt;/tt&gt;.</span>
<span class="line-modified">1440    * If the string aliases to &lt;code&gt;dst&lt;/code&gt; itself as an external buffer,</span>
1441    * then extract() will not copy the contents.
1442    *
1443    * @param start offset of first character which will be copied into the array
1444    * @param length the number of characters to extract
<span class="line-modified">1445    * @param dst array in which to copy characters.  The length of &lt;tt&gt;dst&lt;/tt&gt;</span>
<span class="line-modified">1446    * must be at least (&lt;tt&gt;dstStart + length&lt;/tt&gt;).</span>
<span class="line-modified">1447    * @param dstStart the offset in &lt;TT&gt;dst&lt;/TT&gt; where the first character</span>
1448    * will be extracted
1449    * @stable ICU 2.0
1450    */
1451   inline void extract(int32_t start,
1452            int32_t length,
1453            Char16Ptr dst,
1454            int32_t dstStart = 0) const;
1455 
1456   /**
1457    * Copy the contents of the string into dest.
1458    * This is a convenience function that
1459    * checks if there is enough space in dest,
1460    * extracts the entire string if possible,
1461    * and NUL-terminates dest if possible.
1462    *
1463    * If the string fits into dest but cannot be NUL-terminated
1464    * (length()==destCapacity) then the error code is set to U_STRING_NOT_TERMINATED_WARNING.
1465    * If the string itself does not fit into dest
1466    * (length()&gt;destCapacity) then the error code is set to U_BUFFER_OVERFLOW_ERROR.
1467    *
<span class="line-modified">1468    * If the string aliases to &lt;code&gt;dest&lt;/code&gt; itself as an external buffer,</span>
1469    * then extract() will not copy the contents.
1470    *
1471    * @param dest Destination string buffer.
1472    * @param destCapacity Number of char16_ts available at dest.
1473    * @param errorCode ICU error code.
1474    * @return length()
1475    * @stable ICU 2.0
1476    */
1477   int32_t
1478   extract(Char16Ptr dest, int32_t destCapacity,
1479           UErrorCode &amp;errorCode) const;
1480 
1481   /**
1482    * Copy the characters in the range
<span class="line-modified">1483    * [&lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;start + length&lt;/tt&gt;) into the  UnicodeString</span>
<span class="line-modified">1484    * &lt;tt&gt;target&lt;/tt&gt;.</span>
1485    * @param start offset of first character which will be copied
1486    * @param length the number of characters to extract
1487    * @param target UnicodeString into which to copy characters.
<span class="line-removed">1488    * @return A reference to &lt;TT&gt;target&lt;/TT&gt;</span>
1489    * @stable ICU 2.0
1490    */
1491   inline void extract(int32_t start,
1492            int32_t length,
1493            UnicodeString&amp; target) const;
1494 
1495   /**
<span class="line-modified">1496    * Copy the characters in the range [&lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;limit&lt;/tt&gt;)</span>
<span class="line-modified">1497    * into the array &lt;tt&gt;dst&lt;/tt&gt;, beginning at &lt;tt&gt;dstStart&lt;/tt&gt;.</span>
1498    * @param start offset of first character which will be copied into the array
1499    * @param limit offset immediately following the last character to be copied
<span class="line-modified">1500    * @param dst array in which to copy characters.  The length of &lt;tt&gt;dst&lt;/tt&gt;</span>
<span class="line-modified">1501    * must be at least (&lt;tt&gt;dstStart + (limit - start)&lt;/tt&gt;).</span>
<span class="line-modified">1502    * @param dstStart the offset in &lt;TT&gt;dst&lt;/TT&gt; where the first character</span>
1503    * will be extracted
1504    * @stable ICU 2.0
1505    */
1506   inline void extractBetween(int32_t start,
1507               int32_t limit,
1508               char16_t *dst,
1509               int32_t dstStart = 0) const;
1510 
1511   /**
<span class="line-modified">1512    * Copy the characters in the range [&lt;tt&gt;start&lt;/tt&gt;, &lt;tt&gt;limit&lt;/tt&gt;)</span>
<span class="line-modified">1513    * into the UnicodeString &lt;tt&gt;target&lt;/tt&gt;.  Replaceable API.</span>
1514    * @param start offset of first character which will be copied
1515    * @param limit offset immediately following the last character to be copied
1516    * @param target UnicodeString into which to copy characters.
<span class="line-removed">1517    * @return A reference to &lt;TT&gt;target&lt;/TT&gt;</span>
1518    * @stable ICU 2.0
1519    */
1520   virtual void extractBetween(int32_t start,
1521               int32_t limit,
1522               UnicodeString&amp; target) const;
1523 
1524   /**
1525    * Copy the characters in the range
<span class="line-modified">1526    * [&lt;tt&gt;start&lt;/TT&gt;, &lt;tt&gt;start + startLength&lt;/TT&gt;) into an array of characters.</span>
1527    * All characters must be invariant (see utypes.h).
1528    * Use US_INV as the last, signature-distinguishing parameter.
1529    *
<span class="line-modified">1530    * This function does not write any more than &lt;code&gt;targetCapacity&lt;/code&gt;</span>
1531    * characters but returns the length of the entire output string
1532    * so that one can allocate a larger buffer and call the function again
1533    * if necessary.
1534    * The output string is NUL-terminated if possible.
1535    *
1536    * @param start offset of first character which will be copied
1537    * @param startLength the number of characters to extract
1538    * @param target the target buffer for extraction, can be NULL
1539    *               if targetLength is 0
1540    * @param targetCapacity the length of the target buffer
1541    * @param inv Signature-distinguishing paramater, use US_INV.
1542    * @return the output string length, not including the terminating NUL
1543    * @stable ICU 3.2
1544    */
1545   int32_t extract(int32_t start,
1546            int32_t startLength,
1547            char *target,
1548            int32_t targetCapacity,
1549            enum EInvariant inv) const;
1550 
1551 #if U_CHARSET_IS_UTF8 || !UCONFIG_NO_CONVERSION
1552 
1553   /**
1554    * Copy the characters in the range
<span class="line-modified">1555    * [&lt;tt&gt;start&lt;/TT&gt;, &lt;tt&gt;start + length&lt;/TT&gt;) into an array of characters</span>
1556    * in the platform&#39;s default codepage.
<span class="line-modified">1557    * This function does not write any more than &lt;code&gt;targetLength&lt;/code&gt;</span>
1558    * characters but returns the length of the entire output string
1559    * so that one can allocate a larger buffer and call the function again
1560    * if necessary.
1561    * The output string is NUL-terminated if possible.
1562    *
1563    * @param start offset of first character which will be copied
1564    * @param startLength the number of characters to extract
1565    * @param target the target buffer for extraction
1566    * @param targetLength the length of the target buffer
<span class="line-modified">1567    * If &lt;TT&gt;target&lt;/TT&gt; is NULL, then the number of bytes required for</span>
<span class="line-modified">1568    * &lt;TT&gt;target&lt;/TT&gt; is returned.</span>
1569    * @return the output string length, not including the terminating NUL
1570    * @stable ICU 2.0
1571    */
1572   int32_t extract(int32_t start,
1573            int32_t startLength,
1574            char *target,
1575            uint32_t targetLength) const;
1576 
1577 #endif
1578 
1579 #if !UCONFIG_NO_CONVERSION
1580 
1581   /**
1582    * Copy the characters in the range
<span class="line-modified">1583    * [&lt;tt&gt;start&lt;/TT&gt;, &lt;tt&gt;start + length&lt;/TT&gt;) into an array of characters</span>
1584    * in a specified codepage.
1585    * The output string is NUL-terminated.
1586    *
1587    * Recommendation: For invariant-character strings use
1588    * extract(int32_t start, int32_t length, char *target, int32_t targetCapacity, enum EInvariant inv) const
1589    * because it avoids object code dependencies of UnicodeString on
1590    * the conversion code.
1591    *
1592    * @param start offset of first character which will be copied
1593    * @param startLength the number of characters to extract
1594    * @param target the target buffer for extraction
1595    * @param codepage the desired codepage for the characters.  0 has
1596    * the special meaning of the default codepage
<span class="line-modified">1597    * If &lt;code&gt;codepage&lt;/code&gt; is an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;),</span>
1598    * then a simple conversion is performed on the codepage-invariant
1599    * subset (&quot;invariant characters&quot;) of the platform encoding. See utypes.h.
<span class="line-modified">1600    * If &lt;TT&gt;target&lt;/TT&gt; is NULL, then the number of bytes required for</span>
<span class="line-modified">1601    * &lt;TT&gt;target&lt;/TT&gt; is returned. It is assumed that the target is big enough</span>
1602    * to fit all of the characters.
1603    * @return the output string length, not including the terminating NUL
1604    * @stable ICU 2.0
1605    */
1606   inline int32_t extract(int32_t start,
1607                  int32_t startLength,
1608                  char *target,
1609                  const char *codepage = 0) const;
1610 
1611   /**
1612    * Copy the characters in the range
<span class="line-modified">1613    * [&lt;tt&gt;start&lt;/TT&gt;, &lt;tt&gt;start + length&lt;/TT&gt;) into an array of characters</span>
1614    * in a specified codepage.
<span class="line-modified">1615    * This function does not write any more than &lt;code&gt;targetLength&lt;/code&gt;</span>
1616    * characters but returns the length of the entire output string
1617    * so that one can allocate a larger buffer and call the function again
1618    * if necessary.
1619    * The output string is NUL-terminated if possible.
1620    *
1621    * Recommendation: For invariant-character strings use
1622    * extract(int32_t start, int32_t length, char *target, int32_t targetCapacity, enum EInvariant inv) const
1623    * because it avoids object code dependencies of UnicodeString on
1624    * the conversion code.
1625    *
1626    * @param start offset of first character which will be copied
1627    * @param startLength the number of characters to extract
1628    * @param target the target buffer for extraction
1629    * @param targetLength the length of the target buffer
1630    * @param codepage the desired codepage for the characters.  0 has
1631    * the special meaning of the default codepage
<span class="line-modified">1632    * If &lt;code&gt;codepage&lt;/code&gt; is an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;),</span>
1633    * then a simple conversion is performed on the codepage-invariant
1634    * subset (&quot;invariant characters&quot;) of the platform encoding. See utypes.h.
<span class="line-modified">1635    * If &lt;TT&gt;target&lt;/TT&gt; is NULL, then the number of bytes required for</span>
<span class="line-modified">1636    * &lt;TT&gt;target&lt;/TT&gt; is returned.</span>
1637    * @return the output string length, not including the terminating NUL
1638    * @stable ICU 2.0
1639    */
1640   int32_t extract(int32_t start,
1641            int32_t startLength,
1642            char *target,
1643            uint32_t targetLength,
1644            const char *codepage) const;
1645 
1646   /**
1647    * Convert the UnicodeString into a codepage string using an existing UConverter.
1648    * The output string is NUL-terminated if possible.
1649    *
1650    * This function avoids the overhead of opening and closing a converter if
1651    * multiple strings are extracted.
1652    *
1653    * @param dest destination string buffer, can be NULL if destCapacity==0
1654    * @param destCapacity the number of chars available at dest
1655    * @param cnv the converter object to be used (ucnv_resetFromUnicode() will be called),
1656    *        or NULL for the default converter
</pre>
<hr />
<pre>
1829    * although in both cases isEmpty() returns TRUE and length() returns 0.
1830    * setToBogus() and isBogus() can be used to indicate that no string value is available.
1831    * For a bogus string, getBuffer() and getTerminatedBuffer() return NULL, and
1832    * length() returns 0.
1833    *
1834    * @return TRUE if the string is bogus/invalid, FALSE otherwise
1835    * @see setToBogus()
1836    * @stable ICU 2.0
1837    */
1838   inline UBool isBogus(void) const;
1839 
1840 
1841   //========================================
1842   // Write operations
1843   //========================================
1844 
1845   /* Assignment operations */
1846 
1847   /**
1848    * Assignment operator.  Replace the characters in this UnicodeString
<span class="line-modified">1849    * with the characters from &lt;TT&gt;srcText&lt;/TT&gt;.</span>
1850    *
1851    * Starting with ICU 2.4, the assignment operator and the copy constructor
1852    * allocate a new buffer and copy the buffer contents even for readonly aliases.
1853    * By contrast, the fastCopyFrom() function implements the old,
1854    * more efficient but less safe behavior
1855    * of making this string also a readonly alias to the same buffer.
1856    *
1857    * If the source object has an &quot;open&quot; buffer from getBuffer(minCapacity),
1858    * then the copy is an empty string.
1859    *
1860    * @param srcText The text containing the characters to replace
1861    * @return a reference to this
1862    * @stable ICU 2.0
1863    * @see fastCopyFrom
1864    */
1865   UnicodeString &amp;operator=(const UnicodeString &amp;srcText);
1866 
1867   /**
1868    * Almost the same as the assignment operator.
1869    * Replace the characters in this UnicodeString
<span class="line-modified">1870    * with the characters from &lt;code&gt;srcText&lt;/code&gt;.</span>
1871    *
1872    * This function works the same as the assignment operator
1873    * for all strings except for ones that are readonly aliases.
1874    *
1875    * Starting with ICU 2.4, the assignment operator and the copy constructor
1876    * allocate a new buffer and copy the buffer contents even for readonly aliases.
1877    * This function implements the old, more efficient but less safe behavior
1878    * of making this string also a readonly alias to the same buffer.
1879    *
1880    * The fastCopyFrom function must be used only if it is known that the lifetime of
1881    * this UnicodeString does not exceed the lifetime of the aliased buffer
1882    * including its contents, for example for strings from resource bundles
1883    * or aliases to string constants.
1884    *
1885    * If the source object has an &quot;open&quot; buffer from getBuffer(minCapacity),
1886    * then the copy is an empty string.
1887    *
1888    * @param src The text containing the characters to replace.
1889    * @return a reference to this
1890    * @stable ICU 2.4
1891    */
1892   UnicodeString &amp;fastCopyFrom(const UnicodeString &amp;src);
1893 
1894   /**
1895    * Move assignment operator; might leave src in bogus state.
1896    * This string will have the same contents and state that the source string had.
1897    * The behavior is undefined if *this and src are the same object.
1898    * @param src source string
1899    * @return *this
1900    * @stable ICU 56
1901    */
<span class="line-modified">1902   UnicodeString &amp;operator=(UnicodeString &amp;&amp;src) U_NOEXCEPT {</span>
<span class="line-removed">1903     return moveFrom(src);</span>
<span class="line-removed">1904   }</span>
<span class="line-removed">1905 </span>
<span class="line-removed">1906   // do not use #ifndef U_HIDE_DRAFT_API for moveFrom, needed by non-draft API</span>
<span class="line-removed">1907   /**</span>
<span class="line-removed">1908    * Move assignment; might leave src in bogus state.</span>
<span class="line-removed">1909    * This string will have the same contents and state that the source string had.</span>
<span class="line-removed">1910    * The behavior is undefined if *this and src are the same object.</span>
<span class="line-removed">1911    *</span>
<span class="line-removed">1912    * Can be called explicitly, does not need C++11 support.</span>
<span class="line-removed">1913    * @param src source string</span>
<span class="line-removed">1914    * @return *this</span>
<span class="line-removed">1915    * @draft ICU 56</span>
<span class="line-removed">1916    */</span>
<span class="line-removed">1917   UnicodeString &amp;moveFrom(UnicodeString &amp;src) U_NOEXCEPT;</span>
1918 
1919   /**
1920    * Swap strings.
1921    * @param other other string
1922    * @stable ICU 56
1923    */
1924   void swap(UnicodeString &amp;other) U_NOEXCEPT;
1925 
1926   /**
1927    * Non-member UnicodeString swap function.
1928    * @param s1 will get s2&#39;s contents and state
1929    * @param s2 will get s1&#39;s contents and state
1930    * @stable ICU 56
1931    */
<span class="line-modified">1932   friend U_COMMON_API inline void U_EXPORT2</span>
1933   swap(UnicodeString &amp;s1, UnicodeString &amp;s2) U_NOEXCEPT {
1934     s1.swap(s2);
1935   }
1936 
1937   /**
1938    * Assignment operator.  Replace the characters in this UnicodeString
<span class="line-modified">1939    * with the code unit &lt;TT&gt;ch&lt;/TT&gt;.</span>
1940    * @param ch the code unit to replace
1941    * @return a reference to this
1942    * @stable ICU 2.0
1943    */
1944   inline UnicodeString&amp; operator= (char16_t ch);
1945 
1946   /**
1947    * Assignment operator.  Replace the characters in this UnicodeString
<span class="line-modified">1948    * with the code point &lt;TT&gt;ch&lt;/TT&gt;.</span>
1949    * @param ch the code point to replace
1950    * @return a reference to this
1951    * @stable ICU 2.0
1952    */
1953   inline UnicodeString&amp; operator= (UChar32 ch);
1954 
1955   /**
1956    * Set the text in the UnicodeString object to the characters
<span class="line-modified">1957    * in &lt;TT&gt;srcText&lt;/TT&gt; in the range</span>
<span class="line-modified">1958    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcText.length()&lt;/TT&gt;).</span>
<span class="line-modified">1959    * &lt;TT&gt;srcText&lt;/TT&gt; is not modified.</span>
1960    * @param srcText the source for the new characters
<span class="line-modified">1961    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; where new characters</span>
1962    * will be obtained
1963    * @return a reference to this
1964    * @stable ICU 2.2
1965    */
1966   inline UnicodeString&amp; setTo(const UnicodeString&amp; srcText,
1967                int32_t srcStart);
1968 
1969   /**
1970    * Set the text in the UnicodeString object to the characters
<span class="line-modified">1971    * in &lt;TT&gt;srcText&lt;/TT&gt; in the range</span>
<span class="line-modified">1972    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).</span>
<span class="line-modified">1973    * &lt;TT&gt;srcText&lt;/TT&gt; is not modified.</span>
1974    * @param srcText the source for the new characters
<span class="line-modified">1975    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; where new characters</span>
1976    * will be obtained
<span class="line-modified">1977    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; in the</span>
1978    * replace string.
1979    * @return a reference to this
1980    * @stable ICU 2.0
1981    */
1982   inline UnicodeString&amp; setTo(const UnicodeString&amp; srcText,
1983                int32_t srcStart,
1984                int32_t srcLength);
1985 
1986   /**
1987    * Set the text in the UnicodeString object to the characters in
<span class="line-modified">1988    * &lt;TT&gt;srcText&lt;/TT&gt;.</span>
<span class="line-modified">1989    * &lt;TT&gt;srcText&lt;/TT&gt; is not modified.</span>
1990    * @param srcText the source for the new characters
1991    * @return a reference to this
1992    * @stable ICU 2.0
1993    */
1994   inline UnicodeString&amp; setTo(const UnicodeString&amp; srcText);
1995 
1996   /**
1997    * Set the characters in the UnicodeString object to the characters
<span class="line-modified">1998    * in &lt;TT&gt;srcChars&lt;/TT&gt;. &lt;TT&gt;srcChars&lt;/TT&gt; is not modified.</span>
1999    * @param srcChars the source for the new characters
2000    * @param srcLength the number of Unicode characters in srcChars.
2001    * @return a reference to this
2002    * @stable ICU 2.0
2003    */
2004   inline UnicodeString&amp; setTo(const char16_t *srcChars,
2005                int32_t srcLength);
2006 
2007   /**
2008    * Set the characters in the UnicodeString object to the code unit
<span class="line-modified">2009    * &lt;TT&gt;srcChar&lt;/TT&gt;.</span>
2010    * @param srcChar the code unit which becomes the UnicodeString&#39;s character
2011    * content
2012    * @return a reference to this
2013    * @stable ICU 2.0
2014    */
<span class="line-modified">2015   UnicodeString&amp; setTo(char16_t srcChar);</span>
2016 
2017   /**
2018    * Set the characters in the UnicodeString object to the code point
<span class="line-modified">2019    * &lt;TT&gt;srcChar&lt;/TT&gt;.</span>
2020    * @param srcChar the code point which becomes the UnicodeString&#39;s character
2021    * content
2022    * @return a reference to this
2023    * @stable ICU 2.0
2024    */
<span class="line-modified">2025   UnicodeString&amp; setTo(UChar32 srcChar);</span>
2026 
2027   /**
2028    * Aliasing setTo() function, analogous to the readonly-aliasing char16_t* constructor.
2029    * The text will be used for the UnicodeString object, but
2030    * it will not be released when the UnicodeString is destroyed.
2031    * This has copy-on-write semantics:
2032    * When the string is modified, then the buffer is first copied into
2033    * newly allocated memory.
2034    * The aliased buffer is never modified.
2035    *
2036    * In an assignment to another UnicodeString, when using the copy constructor
2037    * or the assignment operator, the text will be copied.
2038    * When using fastCopyFrom(), the text will be aliased again,
2039    * so that both strings then alias the same readonly-text.
2040    *
<span class="line-modified">2041    * @param isTerminated specifies if &lt;code&gt;text&lt;/code&gt; is &lt;code&gt;NUL&lt;/code&gt;-terminated.</span>
<span class="line-modified">2042    *                     This must be true if &lt;code&gt;textLength==-1&lt;/code&gt;.</span>
2043    * @param text The characters to alias for the UnicodeString.
<span class="line-modified">2044    * @param textLength The number of Unicode characters in &lt;code&gt;text&lt;/code&gt; to alias.</span>
2045    *                   If -1, then this constructor will determine the length
<span class="line-modified">2046    *                   by calling &lt;code&gt;u_strlen()&lt;/code&gt;.</span>
2047    * @return a reference to this
2048    * @stable ICU 2.0
2049    */
2050   UnicodeString &amp;setTo(UBool isTerminated,
2051                        ConstChar16Ptr text,
2052                        int32_t textLength);
2053 
2054   /**
2055    * Aliasing setTo() function, analogous to the writable-aliasing char16_t* constructor.
2056    * The text will be used for the UnicodeString object, but
2057    * it will not be released when the UnicodeString is destroyed.
2058    * This has write-through semantics:
2059    * For as long as the capacity of the buffer is sufficient, write operations
2060    * will directly affect the buffer. When more capacity is necessary, then
2061    * a new buffer will be allocated and the contents copied as with regularly
2062    * constructed strings.
2063    * In an assignment to another UnicodeString, the buffer will be copied.
2064    * The extract(Char16Ptr dst) function detects whether the dst pointer is the same
2065    * as the string buffer itself and will in this case not copy the contents.
2066    *
2067    * @param buffer The characters to alias for the UnicodeString.
<span class="line-modified">2068    * @param buffLength The number of Unicode characters in &lt;code&gt;buffer&lt;/code&gt; to alias.</span>
<span class="line-modified">2069    * @param buffCapacity The size of &lt;code&gt;buffer&lt;/code&gt; in char16_ts.</span>
2070    * @return a reference to this
2071    * @stable ICU 2.0
2072    */
2073   UnicodeString &amp;setTo(char16_t *buffer,
2074                        int32_t buffLength,
2075                        int32_t buffCapacity);
2076 
2077   /**
2078    * Make this UnicodeString object invalid.
2079    * The string will test TRUE with isBogus().
2080    *
2081    * A bogus string has no value. It is different from an empty string.
2082    * It can be used to indicate that no string value is available.
2083    * getBuffer() and getTerminatedBuffer() return NULL, and
2084    * length() returns 0.
2085    *
2086    * This utility function is used throughout the UnicodeString
2087    * implementation to indicate that a UnicodeString operation failed,
2088    * and may be used in other functions,
2089    * especially but not exclusively when such functions do not
</pre>
<hr />
<pre>
2113    *
2114    * @see isBogus()
2115    * @stable ICU 2.0
2116    */
2117   void setToBogus();
2118 
2119   /**
2120    * Set the character at the specified offset to the specified character.
2121    * @param offset A valid offset into the text of the character to set
2122    * @param ch The new character
2123    * @return A reference to this
2124    * @stable ICU 2.0
2125    */
2126   UnicodeString&amp; setCharAt(int32_t offset,
2127                char16_t ch);
2128 
2129 
2130   /* Append operations */
2131 
2132   /**
<span class="line-modified">2133    * Append operator. Append the code unit &lt;TT&gt;ch&lt;/TT&gt; to the UnicodeString</span>
2134    * object.
2135    * @param ch the code unit to be appended
2136    * @return a reference to this
2137    * @stable ICU 2.0
2138    */
2139  inline  UnicodeString&amp; operator+= (char16_t ch);
2140 
2141   /**
<span class="line-modified">2142    * Append operator. Append the code point &lt;TT&gt;ch&lt;/TT&gt; to the UnicodeString</span>
2143    * object.
2144    * @param ch the code point to be appended
2145    * @return a reference to this
2146    * @stable ICU 2.0
2147    */
2148  inline  UnicodeString&amp; operator+= (UChar32 ch);
2149 
2150   /**
<span class="line-modified">2151    * Append operator. Append the characters in &lt;TT&gt;srcText&lt;/TT&gt; to the</span>
<span class="line-modified">2152    * UnicodeString object. &lt;TT&gt;srcText&lt;/TT&gt; is not modified.</span>
2153    * @param srcText the source for the new characters
2154    * @return a reference to this
2155    * @stable ICU 2.0
2156    */
2157   inline UnicodeString&amp; operator+= (const UnicodeString&amp; srcText);
2158 
2159   /**
2160    * Append the characters
<span class="line-modified">2161    * in &lt;TT&gt;srcText&lt;/TT&gt; in the range</span>
<span class="line-modified">2162    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;) to the</span>
<span class="line-modified">2163    * UnicodeString object at offset &lt;TT&gt;start&lt;/TT&gt;. &lt;TT&gt;srcText&lt;/TT&gt;</span>
2164    * is not modified.
2165    * @param srcText the source for the new characters
<span class="line-modified">2166    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; where new characters</span>
2167    * will be obtained
<span class="line-modified">2168    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; in</span>
2169    * the append string
2170    * @return a reference to this
2171    * @stable ICU 2.0
2172    */
2173   inline UnicodeString&amp; append(const UnicodeString&amp; srcText,
2174             int32_t srcStart,
2175             int32_t srcLength);
2176 
2177   /**
<span class="line-modified">2178    * Append the characters in &lt;TT&gt;srcText&lt;/TT&gt; to the UnicodeString object.</span>
<span class="line-modified">2179    * &lt;TT&gt;srcText&lt;/TT&gt; is not modified.</span>
2180    * @param srcText the source for the new characters
2181    * @return a reference to this
2182    * @stable ICU 2.0
2183    */
2184   inline UnicodeString&amp; append(const UnicodeString&amp; srcText);
2185 
2186   /**
<span class="line-modified">2187    * Append the characters in &lt;TT&gt;srcChars&lt;/TT&gt; in the range</span>
<span class="line-modified">2188    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;) to the UnicodeString</span>
2189    * object at offset
<span class="line-modified">2190    * &lt;TT&gt;start&lt;/TT&gt;. &lt;TT&gt;srcChars&lt;/TT&gt; is not modified.</span>
2191    * @param srcChars the source for the new characters
<span class="line-modified">2192    * @param srcStart the offset into &lt;TT&gt;srcChars&lt;/TT&gt; where new characters</span>
2193    * will be obtained
<span class="line-modified">2194    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt; in</span>
<span class="line-modified">2195    *                  the append string; can be -1 if &lt;TT&gt;srcChars&lt;/TT&gt; is NUL-terminated</span>
2196    * @return a reference to this
2197    * @stable ICU 2.0
2198    */
2199   inline UnicodeString&amp; append(const char16_t *srcChars,
2200             int32_t srcStart,
2201             int32_t srcLength);
2202 
2203   /**
<span class="line-modified">2204    * Append the characters in &lt;TT&gt;srcChars&lt;/TT&gt; to the UnicodeString object</span>
<span class="line-modified">2205    * at offset &lt;TT&gt;start&lt;/TT&gt;. &lt;TT&gt;srcChars&lt;/TT&gt; is not modified.</span>
2206    * @param srcChars the source for the new characters
<span class="line-modified">2207    * @param srcLength the number of Unicode characters in &lt;TT&gt;srcChars&lt;/TT&gt;;</span>
<span class="line-modified">2208    *                  can be -1 if &lt;TT&gt;srcChars&lt;/TT&gt; is NUL-terminated</span>
2209    * @return a reference to this
2210    * @stable ICU 2.0
2211    */
2212   inline UnicodeString&amp; append(ConstChar16Ptr srcChars,
2213             int32_t srcLength);
2214 
2215   /**
<span class="line-modified">2216    * Append the code unit &lt;TT&gt;srcChar&lt;/TT&gt; to the UnicodeString object.</span>
2217    * @param srcChar the code unit to append
2218    * @return a reference to this
2219    * @stable ICU 2.0
2220    */
2221   inline UnicodeString&amp; append(char16_t srcChar);
2222 
2223   /**
<span class="line-modified">2224    * Append the code point &lt;TT&gt;srcChar&lt;/TT&gt; to the UnicodeString object.</span>
2225    * @param srcChar the code point to append
2226    * @return a reference to this
2227    * @stable ICU 2.0
2228    */
2229   UnicodeString&amp; append(UChar32 srcChar);
2230 
2231 
2232   /* Insert operations */
2233 
2234   /**
<span class="line-modified">2235    * Insert the characters in &lt;TT&gt;srcText&lt;/TT&gt; in the range</span>
<span class="line-modified">2236    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;) into the UnicodeString</span>
<span class="line-modified">2237    * object at offset &lt;TT&gt;start&lt;/TT&gt;. &lt;TT&gt;srcText&lt;/TT&gt; is not modified.</span>
2238    * @param start the offset where the insertion begins
2239    * @param srcText the source for the new characters
<span class="line-modified">2240    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; where new characters</span>
2241    * will be obtained
<span class="line-modified">2242    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; in</span>
2243    * the insert string
2244    * @return a reference to this
2245    * @stable ICU 2.0
2246    */
2247   inline UnicodeString&amp; insert(int32_t start,
2248             const UnicodeString&amp; srcText,
2249             int32_t srcStart,
2250             int32_t srcLength);
2251 
2252   /**
<span class="line-modified">2253    * Insert the characters in &lt;TT&gt;srcText&lt;/TT&gt; into the UnicodeString object</span>
<span class="line-modified">2254    * at offset &lt;TT&gt;start&lt;/TT&gt;. &lt;TT&gt;srcText&lt;/TT&gt; is not modified.</span>
2255    * @param start the offset where the insertion begins
2256    * @param srcText the source for the new characters
2257    * @return a reference to this
2258    * @stable ICU 2.0
2259    */
2260   inline UnicodeString&amp; insert(int32_t start,
2261             const UnicodeString&amp; srcText);
2262 
2263   /**
<span class="line-modified">2264    * Insert the characters in &lt;TT&gt;srcChars&lt;/TT&gt; in the range</span>
<span class="line-modified">2265    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;) into the UnicodeString</span>
<span class="line-modified">2266    *  object at offset &lt;TT&gt;start&lt;/TT&gt;. &lt;TT&gt;srcChars&lt;/TT&gt; is not modified.</span>
2267    * @param start the offset at which the insertion begins
2268    * @param srcChars the source for the new characters
<span class="line-modified">2269    * @param srcStart the offset into &lt;TT&gt;srcChars&lt;/TT&gt; where new characters</span>
2270    * will be obtained
<span class="line-modified">2271    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt;</span>
2272    * in the insert string
2273    * @return a reference to this
2274    * @stable ICU 2.0
2275    */
2276   inline UnicodeString&amp; insert(int32_t start,
2277             const char16_t *srcChars,
2278             int32_t srcStart,
2279             int32_t srcLength);
2280 
2281   /**
<span class="line-modified">2282    * Insert the characters in &lt;TT&gt;srcChars&lt;/TT&gt; into the UnicodeString object</span>
<span class="line-modified">2283    * at offset &lt;TT&gt;start&lt;/TT&gt;. &lt;TT&gt;srcChars&lt;/TT&gt; is not modified.</span>
2284    * @param start the offset where the insertion begins
2285    * @param srcChars the source for the new characters
2286    * @param srcLength the number of Unicode characters in srcChars.
2287    * @return a reference to this
2288    * @stable ICU 2.0
2289    */
2290   inline UnicodeString&amp; insert(int32_t start,
2291             ConstChar16Ptr srcChars,
2292             int32_t srcLength);
2293 
2294   /**
<span class="line-modified">2295    * Insert the code unit &lt;TT&gt;srcChar&lt;/TT&gt; into the UnicodeString object at</span>
<span class="line-modified">2296    * offset &lt;TT&gt;start&lt;/TT&gt;.</span>
2297    * @param start the offset at which the insertion occurs
2298    * @param srcChar the code unit to insert
2299    * @return a reference to this
2300    * @stable ICU 2.0
2301    */
2302   inline UnicodeString&amp; insert(int32_t start,
2303             char16_t srcChar);
2304 
2305   /**
<span class="line-modified">2306    * Insert the code point &lt;TT&gt;srcChar&lt;/TT&gt; into the UnicodeString object at</span>
<span class="line-modified">2307    * offset &lt;TT&gt;start&lt;/TT&gt;.</span>
2308    * @param start the offset at which the insertion occurs
2309    * @param srcChar the code point to insert
2310    * @return a reference to this
2311    * @stable ICU 2.0
2312    */
2313   inline UnicodeString&amp; insert(int32_t start,
2314             UChar32 srcChar);
2315 
2316 
2317   /* Replace operations */
2318 
2319   /**
2320    * Replace the characters in the range
<span class="line-modified">2321    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the characters in</span>
<span class="line-modified">2322    * &lt;TT&gt;srcText&lt;/TT&gt; in the range</span>
<span class="line-modified">2323    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;).</span>
<span class="line-modified">2324    * &lt;TT&gt;srcText&lt;/TT&gt; is not modified.</span>
2325    * @param start the offset at which the replace operation begins
2326    * @param length the number of characters to replace. The character at
<span class="line-modified">2327    * &lt;TT&gt;start + length&lt;/TT&gt; is not modified.</span>
2328    * @param srcText the source for the new characters
<span class="line-modified">2329    * @param srcStart the offset into &lt;TT&gt;srcText&lt;/TT&gt; where new characters</span>
2330    * will be obtained
<span class="line-modified">2331    * @param srcLength the number of characters in &lt;TT&gt;srcText&lt;/TT&gt; in</span>
2332    * the replace string
2333    * @return a reference to this
2334    * @stable ICU 2.0
2335    */
<span class="line-modified">2336   UnicodeString&amp; replace(int32_t start,</span>
2337              int32_t length,
2338              const UnicodeString&amp; srcText,
2339              int32_t srcStart,
2340              int32_t srcLength);
2341 
2342   /**
2343    * Replace the characters in the range
<span class="line-modified">2344    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;)</span>
<span class="line-modified">2345    * with the characters in &lt;TT&gt;srcText&lt;/TT&gt;.  &lt;TT&gt;srcText&lt;/TT&gt; is</span>
2346    *  not modified.
2347    * @param start the offset at which the replace operation begins
2348    * @param length the number of characters to replace. The character at
<span class="line-modified">2349    * &lt;TT&gt;start + length&lt;/TT&gt; is not modified.</span>
2350    * @param srcText the source for the new characters
2351    * @return a reference to this
2352    * @stable ICU 2.0
2353    */
<span class="line-modified">2354   UnicodeString&amp; replace(int32_t start,</span>
2355              int32_t length,
2356              const UnicodeString&amp; srcText);
2357 
2358   /**
2359    * Replace the characters in the range
<span class="line-modified">2360    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the characters in</span>
<span class="line-modified">2361    * &lt;TT&gt;srcChars&lt;/TT&gt; in the range</span>
<span class="line-modified">2362    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcStart + srcLength&lt;/TT&gt;). &lt;TT&gt;srcChars&lt;/TT&gt;</span>
2363    * is not modified.
2364    * @param start the offset at which the replace operation begins
2365    * @param length the number of characters to replace.  The character at
<span class="line-modified">2366    * &lt;TT&gt;start + length&lt;/TT&gt; is not modified.</span>
2367    * @param srcChars the source for the new characters
<span class="line-modified">2368    * @param srcStart the offset into &lt;TT&gt;srcChars&lt;/TT&gt; where new characters</span>
2369    * will be obtained
<span class="line-modified">2370    * @param srcLength the number of characters in &lt;TT&gt;srcChars&lt;/TT&gt;</span>
2371    * in the replace string
2372    * @return a reference to this
2373    * @stable ICU 2.0
2374    */
<span class="line-modified">2375   UnicodeString&amp; replace(int32_t start,</span>
2376              int32_t length,
2377              const char16_t *srcChars,
2378              int32_t srcStart,
2379              int32_t srcLength);
2380 
2381   /**
2382    * Replace the characters in the range
<span class="line-modified">2383    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the characters in</span>
<span class="line-modified">2384    * &lt;TT&gt;srcChars&lt;/TT&gt;.  &lt;TT&gt;srcChars&lt;/TT&gt; is not modified.</span>
2385    * @param start the offset at which the replace operation begins
2386    * @param length number of characters to replace.  The character at
<span class="line-modified">2387    * &lt;TT&gt;start + length&lt;/TT&gt; is not modified.</span>
2388    * @param srcChars the source for the new characters
2389    * @param srcLength the number of Unicode characters in srcChars
2390    * @return a reference to this
2391    * @stable ICU 2.0
2392    */
2393   inline UnicodeString&amp; replace(int32_t start,
2394              int32_t length,
2395              ConstChar16Ptr srcChars,
2396              int32_t srcLength);
2397 
2398   /**
2399    * Replace the characters in the range
<span class="line-modified">2400    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the code unit</span>
<span class="line-modified">2401    * &lt;TT&gt;srcChar&lt;/TT&gt;.</span>
2402    * @param start the offset at which the replace operation begins
2403    * @param length the number of characters to replace.  The character at
<span class="line-modified">2404    * &lt;TT&gt;start + length&lt;/TT&gt; is not modified.</span>
2405    * @param srcChar the new code unit
2406    * @return a reference to this
2407    * @stable ICU 2.0
2408    */
2409   inline UnicodeString&amp; replace(int32_t start,
2410              int32_t length,
2411              char16_t srcChar);
2412 
2413   /**
2414    * Replace the characters in the range
<span class="line-modified">2415    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) with the code point</span>
<span class="line-modified">2416    * &lt;TT&gt;srcChar&lt;/TT&gt;.</span>
2417    * @param start the offset at which the replace operation begins
2418    * @param length the number of characters to replace.  The character at
<span class="line-modified">2419    * &lt;TT&gt;start + length&lt;/TT&gt; is not modified.</span>
2420    * @param srcChar the new code point
2421    * @return a reference to this
2422    * @stable ICU 2.0
2423    */
2424   UnicodeString&amp; replace(int32_t start, int32_t length, UChar32 srcChar);
2425 
2426   /**
<span class="line-modified">2427    * Replace the characters in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;limit&lt;/TT&gt;)</span>
<span class="line-modified">2428    * with the characters in &lt;TT&gt;srcText&lt;/TT&gt;. &lt;TT&gt;srcText&lt;/TT&gt; is not modified.</span>
2429    * @param start the offset at which the replace operation begins
2430    * @param limit the offset immediately following the replace range
2431    * @param srcText the source for the new characters
2432    * @return a reference to this
2433    * @stable ICU 2.0
2434    */
2435   inline UnicodeString&amp; replaceBetween(int32_t start,
2436                 int32_t limit,
2437                 const UnicodeString&amp; srcText);
2438 
2439   /**
<span class="line-modified">2440    * Replace the characters in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;limit&lt;/TT&gt;)</span>
<span class="line-modified">2441    * with the characters in &lt;TT&gt;srcText&lt;/TT&gt; in the range</span>
<span class="line-modified">2442    * [&lt;TT&gt;srcStart&lt;/TT&gt;, &lt;TT&gt;srcLimit&lt;/TT&gt;). &lt;TT&gt;srcText&lt;/TT&gt; is not modified.</span>
2443    * @param start the offset at which the replace operation begins
2444    * @param limit the offset immediately following the replace range
2445    * @param srcText the source for the new characters
<span class="line-modified">2446    * @param srcStart the offset into &lt;TT&gt;srcChars&lt;/TT&gt; where new characters</span>
2447    * will be obtained
2448    * @param srcLimit the offset immediately following the range to copy
<span class="line-modified">2449    * in &lt;TT&gt;srcText&lt;/TT&gt;</span>
2450    * @return a reference to this
2451    * @stable ICU 2.0
2452    */
2453   inline UnicodeString&amp; replaceBetween(int32_t start,
2454                 int32_t limit,
2455                 const UnicodeString&amp; srcText,
2456                 int32_t srcStart,
2457                 int32_t srcLimit);
2458 
2459   /**
2460    * Replace a substring of this object with the given text.
<span class="line-modified">2461    * @param start the beginning index, inclusive; &lt;code&gt;0 &lt;= start</span>
<span class="line-modified">2462    * &lt;= limit&lt;/code&gt;.</span>
<span class="line-modified">2463    * @param limit the ending index, exclusive; &lt;code&gt;start &lt;= limit</span>
<span class="line-removed">2464    * &lt;= length()&lt;/code&gt;.</span>
<span class="line-removed">2465    * @param text the text to replace characters &lt;code&gt;start&lt;/code&gt;</span>
<span class="line-removed">2466    * to &lt;code&gt;limit - 1&lt;/code&gt;</span>
2467    * @stable ICU 2.0
2468    */
2469   virtual void handleReplaceBetween(int32_t start,
2470                                     int32_t limit,
2471                                     const UnicodeString&amp; text);
2472 
2473   /**
2474    * Replaceable API
2475    * @return TRUE if it has MetaData
2476    * @stable ICU 2.4
2477    */
2478   virtual UBool hasMetaData() const;
2479 
2480   /**
2481    * Copy a substring of this object, retaining attribute (out-of-band)
2482    * information.  This method is used to duplicate or reorder substrings.
2483    * The destination index must not overlap the source range.
2484    *
<span class="line-modified">2485    * @param start the beginning index, inclusive; &lt;code&gt;0 &lt;= start &lt;=</span>
<span class="line-modified">2486    * limit&lt;/code&gt;.</span>
<span class="line-removed">2487    * @param limit the ending index, exclusive; &lt;code&gt;start &lt;= limit &lt;=</span>
<span class="line-removed">2488    * length()&lt;/code&gt;.</span>
2489    * @param dest the destination index.  The characters from
<span class="line-modified">2490    * &lt;code&gt;start..limit-1&lt;/code&gt; will be copied to &lt;code&gt;dest&lt;/code&gt;.</span>
<span class="line-modified">2491    * Implementations of this method may assume that &lt;code&gt;dest &lt;= start ||</span>
<span class="line-modified">2492    * dest &gt;= limit&lt;/code&gt;.</span>
2493    * @stable ICU 2.0
2494    */
2495   virtual void copy(int32_t start, int32_t limit, int32_t dest);
2496 
2497   /* Search and replace operations */
2498 
2499   /**
2500    * Replace all occurrences of characters in oldText with the characters
2501    * in newText
2502    * @param oldText the text containing the search text
2503    * @param newText the text containing the replacement text
2504    * @return a reference to this
2505    * @stable ICU 2.0
2506    */
2507   inline UnicodeString&amp; findAndReplace(const UnicodeString&amp; oldText,
2508                 const UnicodeString&amp; newText);
2509 
2510   /**
2511    * Replace all occurrences of characters in oldText with characters
2512    * in newText
<span class="line-modified">2513    * in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;).</span>
2514    * @param start the start of the range in which replace will performed
2515    * @param length the length of the range in which replace will be performed
2516    * @param oldText the text containing the search text
2517    * @param newText the text containing the replacement text
2518    * @return a reference to this
2519    * @stable ICU 2.0
2520    */
2521   inline UnicodeString&amp; findAndReplace(int32_t start,
2522                 int32_t length,
2523                 const UnicodeString&amp; oldText,
2524                 const UnicodeString&amp; newText);
2525 
2526   /**
2527    * Replace all occurrences of characters in oldText in the range
<span class="line-modified">2528    * [&lt;TT&gt;oldStart&lt;/TT&gt;, &lt;TT&gt;oldStart + oldLength&lt;/TT&gt;) with the characters</span>
2529    * in newText in the range
<span class="line-modified">2530    * [&lt;TT&gt;newStart&lt;/TT&gt;, &lt;TT&gt;newStart + newLength&lt;/TT&gt;)</span>
<span class="line-modified">2531    * in the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;).</span>
2532    * @param start the start of the range in which replace will performed
2533    * @param length the length of the range in which replace will be performed
2534    * @param oldText the text containing the search text
<span class="line-modified">2535    * @param oldStart the start of the search range in &lt;TT&gt;oldText&lt;/TT&gt;</span>
<span class="line-modified">2536    * @param oldLength the length of the search range in &lt;TT&gt;oldText&lt;/TT&gt;</span>
2537    * @param newText the text containing the replacement text
<span class="line-modified">2538    * @param newStart the start of the replacement range in &lt;TT&gt;newText&lt;/TT&gt;</span>
<span class="line-modified">2539    * @param newLength the length of the replacement range in &lt;TT&gt;newText&lt;/TT&gt;</span>
2540    * @return a reference to this
2541    * @stable ICU 2.0
2542    */
2543   UnicodeString&amp; findAndReplace(int32_t start,
2544                 int32_t length,
2545                 const UnicodeString&amp; oldText,
2546                 int32_t oldStart,
2547                 int32_t oldLength,
2548                 const UnicodeString&amp; newText,
2549                 int32_t newStart,
2550                 int32_t newLength);
2551 
2552 
2553   /* Remove operations */
2554 
2555   /**
2556    * Remove all characters from the UnicodeString object.
2557    * @return a reference to this
2558    * @stable ICU 2.0
2559    */
2560   inline UnicodeString&amp; remove(void);
2561 
2562   /**
2563    * Remove the characters in the range
<span class="line-modified">2564    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) from the UnicodeString object.</span>
2565    * @param start the offset of the first character to remove
2566    * @param length the number of characters to remove
2567    * @return a reference to this
2568    * @stable ICU 2.0
2569    */
2570   inline UnicodeString&amp; remove(int32_t start,
2571                                int32_t length = (int32_t)INT32_MAX);
2572 
2573   /**
2574    * Remove the characters in the range
<span class="line-modified">2575    * [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;limit&lt;/TT&gt;) from the UnicodeString object.</span>
2576    * @param start the offset of the first character to remove
2577    * @param limit the offset immediately following the range to remove
2578    * @return a reference to this
2579    * @stable ICU 2.0
2580    */
2581   inline UnicodeString&amp; removeBetween(int32_t start,
2582                                       int32_t limit = (int32_t)INT32_MAX);
2583 
2584   /**
2585    * Retain only the characters in the range
<span class="line-modified">2586    * [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;limit&lt;/code&gt;) from the UnicodeString object.</span>
<span class="line-modified">2587    * Removes characters before &lt;code&gt;start&lt;/code&gt; and at and after &lt;code&gt;limit&lt;/code&gt;.</span>
2588    * @param start the offset of the first character to retain
2589    * @param limit the offset immediately following the range to retain
2590    * @return a reference to this
2591    * @stable ICU 4.4
2592    */
2593   inline UnicodeString &amp;retainBetween(int32_t start, int32_t limit = INT32_MAX);
2594 
2595   /* Length operations */
2596 
2597   /**
<span class="line-modified">2598    * Pad the start of this UnicodeString with the character &lt;TT&gt;padChar&lt;/TT&gt;.</span>
2599    * If the length of this UnicodeString is less than targetLength,
2600    * length() - targetLength copies of padChar will be added to the
2601    * beginning of this UnicodeString.
2602    * @param targetLength the desired length of the string
2603    * @param padChar the character to use for padding. Defaults to
2604    * space (U+0020)
2605    * @return TRUE if the text was padded, FALSE otherwise.
2606    * @stable ICU 2.0
2607    */
2608   UBool padLeading(int32_t targetLength,
2609                     char16_t padChar = 0x0020);
2610 
2611   /**
<span class="line-modified">2612    * Pad the end of this UnicodeString with the character &lt;TT&gt;padChar&lt;/TT&gt;.</span>
2613    * If the length of this UnicodeString is less than targetLength,
2614    * length() - targetLength copies of padChar will be added to the
2615    * end of this UnicodeString.
2616    * @param targetLength the desired length of the string
2617    * @param padChar the character to use for padding. Defaults to
2618    * space (U+0020)
2619    * @return TRUE if the text was padded, FALSE otherwise.
2620    * @stable ICU 2.0
2621    */
2622   UBool padTrailing(int32_t targetLength,
2623                      char16_t padChar = 0x0020);
2624 
2625   /**
<span class="line-modified">2626    * Truncate this UnicodeString to the &lt;TT&gt;targetLength&lt;/TT&gt;.</span>
2627    * @param targetLength the desired length of this UnicodeString.
2628    * @return TRUE if the text was truncated, FALSE otherwise
2629    * @stable ICU 2.0
2630    */
2631   inline UBool truncate(int32_t targetLength);
2632 
2633   /**
2634    * Trims leading and trailing whitespace from this UnicodeString.
2635    * @return a reference to this
2636    * @stable ICU 2.0
2637    */
2638   UnicodeString&amp; trim(void);
2639 
2640 
2641   /* Miscellaneous operations */
2642 
2643   /**
2644    * Reverse this UnicodeString in place.
2645    * @return a reference to this
2646    * @stable ICU 2.0
2647    */
2648   inline UnicodeString&amp; reverse(void);
2649 
2650   /**
<span class="line-modified">2651    * Reverse the range [&lt;TT&gt;start&lt;/TT&gt;, &lt;TT&gt;start + length&lt;/TT&gt;) in</span>
2652    * this UnicodeString.
2653    * @param start the start of the range to reverse
2654    * @param length the number of characters to to reverse
2655    * @return a reference to this
2656    * @stable ICU 2.0
2657    */
2658   inline UnicodeString&amp; reverse(int32_t start,
2659              int32_t length);
2660 
2661   /**
2662    * Convert the characters in this to UPPER CASE following the conventions of
2663    * the default locale.
2664    * @return A reference to this.
2665    * @stable ICU 2.0
2666    */
2667   UnicodeString&amp; toUpper(void);
2668 
2669   /**
2670    * Convert the characters in this to UPPER CASE following the conventions of
2671    * a specific locale.
</pre>
<hr />
<pre>
2816    *
2817    * An attempted nested call will return 0, and will not further modify the
2818    * state of the UnicodeString object.
2819    * It also returns 0 if the string is bogus.
2820    *
2821    * The actual capacity of the string buffer may be larger than minCapacity.
2822    * getCapacity() returns the actual capacity.
2823    * For many operations, the full capacity should be used to avoid reallocations.
2824    *
2825    * While the buffer is &quot;open&quot; between getBuffer(minCapacity)
2826    * and releaseBuffer(newLength), the following applies:
2827    * - The string length is set to 0.
2828    * - Any read API call on the UnicodeString object will behave like on a 0-length string.
2829    * - Any write API call on the UnicodeString object is disallowed and will have no effect.
2830    * - You can read from and write to the returned buffer.
2831    * - The previous string contents will still be in the buffer;
2832    *   if you want to use it, then you need to call length() before getBuffer(minCapacity).
2833    *   If the length() was greater than minCapacity, then any contents after minCapacity
2834    *   may be lost.
2835    *   The buffer contents is not NUL-terminated by getBuffer().
<span class="line-modified">2836    *   If length()&lt;getCapacity() then you can terminate it by writing a NUL</span>
2837    *   at index length().
2838    * - You must call releaseBuffer(newLength) before and in order to
2839    *   return to normal UnicodeString operation.
2840    *
2841    * @param minCapacity the minimum number of char16_ts that are to be available
2842    *        in the buffer, starting at the returned pointer;
2843    *        default to the current string capacity if minCapacity==-1
2844    * @return a writable pointer to the internal string buffer,
2845    *         or nullptr if an error occurs (nested calls, out of memory)
2846    *
2847    * @see releaseBuffer
2848    * @see getTerminatedBuffer()
2849    * @stable ICU 2.0
2850    */
2851   char16_t *getBuffer(int32_t minCapacity);
2852 
2853   /**
2854    * Release a read/write buffer on a UnicodeString object with an
2855    * &quot;open&quot; getBuffer(minCapacity).
2856    * This function must be called in a matched pair with getBuffer(minCapacity).
</pre>
<hr />
<pre>
2872    */
2873   void releaseBuffer(int32_t newLength=-1);
2874 
2875   /**
2876    * Get a read-only pointer to the internal buffer.
2877    * This can be called at any time on a valid UnicodeString.
2878    *
2879    * It returns 0 if the string is bogus, or
2880    * during an &quot;open&quot; getBuffer(minCapacity).
2881    *
2882    * It can be called as many times as desired.
2883    * The pointer that it returns will remain valid until the UnicodeString object is modified,
2884    * at which time the pointer is semantically invalidated and must not be used any more.
2885    *
2886    * The capacity of the buffer can be determined with getCapacity().
2887    * The part after length() may or may not be initialized and valid,
2888    * depending on the history of the UnicodeString object.
2889    *
2890    * The buffer contents is (probably) not NUL-terminated.
2891    * You can check if it is with
<span class="line-modified">2892    * &lt;code&gt;(s.length()&lt;s.getCapacity() &amp;&amp; buffer[s.length()]==0)&lt;/code&gt;.</span>
2893    * (See getTerminatedBuffer().)
2894    *
2895    * The buffer may reside in read-only memory. Its contents must not
2896    * be modified.
2897    *
2898    * @return a read-only pointer to the internal string buffer,
2899    *         or nullptr if the string is empty or bogus
2900    *
2901    * @see getBuffer(int32_t minCapacity)
2902    * @see getTerminatedBuffer()
2903    * @stable ICU 2.0
2904    */
2905   inline const char16_t *getBuffer() const;
2906 
2907   /**
2908    * Get a read-only pointer to the internal buffer,
2909    * making sure that it is NUL-terminated.
2910    * This can be called at any time on a valid UnicodeString.
2911    *
2912    * It returns 0 if the string is bogus, or
</pre>
<hr />
<pre>
2932    *
2933    * @return a read-only pointer to the internal string buffer,
2934    *         or 0 if the string is empty or bogus
2935    *
2936    * @see getBuffer(int32_t minCapacity)
2937    * @see getBuffer()
2938    * @stable ICU 2.2
2939    */
2940   const char16_t *getTerminatedBuffer();
2941 
2942   //========================================
2943   // Constructors
2944   //========================================
2945 
2946   /** Construct an empty UnicodeString.
2947    * @stable ICU 2.0
2948    */
2949   inline UnicodeString();
2950 
2951   /**
<span class="line-modified">2952    * Construct a UnicodeString with capacity to hold &lt;TT&gt;capacity&lt;/TT&gt; char16_ts</span>
2953    * @param capacity the number of char16_ts this UnicodeString should hold
2954    * before a resize is necessary; if count is greater than 0 and count
2955    * code points c take up more space than capacity, then capacity is adjusted
2956    * accordingly.
2957    * @param c is used to initially fill the string
2958    * @param count specifies how many code points c are to be written in the
2959    *              string
2960    * @stable ICU 2.0
2961    */
2962   UnicodeString(int32_t capacity, UChar32 c, int32_t count);
2963 
2964   /**
2965    * Single char16_t (code unit) constructor.
2966    *
2967    * It is recommended to mark this constructor &quot;explicit&quot; by
<span class="line-modified">2968    * &lt;code&gt;-DUNISTR_FROM_CHAR_EXPLICIT=explicit&lt;/code&gt;</span>
2969    * on the compiler command line or similar.
2970    * @param ch the character to place in the UnicodeString
2971    * @stable ICU 2.0
2972    */
2973   UNISTR_FROM_CHAR_EXPLICIT UnicodeString(char16_t ch);
2974 
2975   /**
2976    * Single UChar32 (code point) constructor.
2977    *
2978    * It is recommended to mark this constructor &quot;explicit&quot; by
<span class="line-modified">2979    * &lt;code&gt;-DUNISTR_FROM_CHAR_EXPLICIT=explicit&lt;/code&gt;</span>
2980    * on the compiler command line or similar.
2981    * @param ch the character to place in the UnicodeString
2982    * @stable ICU 2.0
2983    */
2984   UNISTR_FROM_CHAR_EXPLICIT UnicodeString(UChar32 ch);
2985 
2986   /**
2987    * char16_t* constructor.
2988    *
2989    * It is recommended to mark this constructor &quot;explicit&quot; by
<span class="line-modified">2990    * &lt;code&gt;-DUNISTR_FROM_STRING_EXPLICIT=explicit&lt;/code&gt;</span>
2991    * on the compiler command line or similar.
<span class="line-modified">2992    * @param text The characters to place in the UnicodeString.  &lt;TT&gt;text&lt;/TT&gt;</span>
2993    * must be NULL (U+0000) terminated.
2994    * @stable ICU 2.0
2995    */
2996   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const char16_t *text);
2997 
2998 #if !U_CHAR16_IS_TYPEDEF
2999   /**
3000    * uint16_t * constructor.
3001    * Delegates to UnicodeString(const char16_t *).
3002    *
3003    * It is recommended to mark this constructor &quot;explicit&quot; by
<span class="line-modified">3004    * &lt;code&gt;-DUNISTR_FROM_STRING_EXPLICIT=explicit&lt;/code&gt;</span>
3005    * on the compiler command line or similar.
3006    * @param text NUL-terminated UTF-16 string
3007    * @stable ICU 59
3008    */
3009   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const uint16_t *text) :
3010       UnicodeString(ConstChar16Ptr(text)) {}
3011 #endif
3012 
3013 #if U_SIZEOF_WCHAR_T==2 || defined(U_IN_DOXYGEN)
3014   /**
3015    * wchar_t * constructor.
3016    * (Only defined if U_SIZEOF_WCHAR_T==2.)
3017    * Delegates to UnicodeString(const char16_t *).
3018    *
3019    * It is recommended to mark this constructor &quot;explicit&quot; by
<span class="line-modified">3020    * &lt;code&gt;-DUNISTR_FROM_STRING_EXPLICIT=explicit&lt;/code&gt;</span>
3021    * on the compiler command line or similar.
3022    * @param text NUL-terminated UTF-16 string
3023    * @stable ICU 59
3024    */
3025   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const wchar_t *text) :
3026       UnicodeString(ConstChar16Ptr(text)) {}
3027 #endif
3028 
3029   /**
3030    * nullptr_t constructor.
3031    * Effectively the same as the default constructor, makes an empty string object.
3032    *
3033    * It is recommended to mark this constructor &quot;explicit&quot; by
<span class="line-modified">3034    * &lt;code&gt;-DUNISTR_FROM_STRING_EXPLICIT=explicit&lt;/code&gt;</span>
3035    * on the compiler command line or similar.
3036    * @param text nullptr
3037    * @stable ICU 59
3038    */
3039   UNISTR_FROM_STRING_EXPLICIT inline UnicodeString(const std::nullptr_t text);
3040 
3041   /**
3042    * char16_t* constructor.
3043    * @param text The characters to place in the UnicodeString.
<span class="line-modified">3044    * @param textLength The number of Unicode characters in &lt;TT&gt;text&lt;/TT&gt;</span>
3045    * to copy.
3046    * @stable ICU 2.0
3047    */
3048   UnicodeString(const char16_t *text,
3049         int32_t textLength);
3050 
3051 #if !U_CHAR16_IS_TYPEDEF
3052   /**
3053    * uint16_t * constructor.
3054    * Delegates to UnicodeString(const char16_t *, int32_t).
3055    * @param text UTF-16 string
3056    * @param length string length
3057    * @stable ICU 59
3058    */
3059   UnicodeString(const uint16_t *text, int32_t length) :
3060       UnicodeString(ConstChar16Ptr(text), length) {}
3061 #endif
3062 
3063 #if U_SIZEOF_WCHAR_T==2 || defined(U_IN_DOXYGEN)
3064   /**
</pre>
<hr />
<pre>
3079    * @param text nullptr
3080    * @param length ignored
3081    * @stable ICU 59
3082    */
3083   inline UnicodeString(const std::nullptr_t text, int32_t length);
3084 
3085   /**
3086    * Readonly-aliasing char16_t* constructor.
3087    * The text will be used for the UnicodeString object, but
3088    * it will not be released when the UnicodeString is destroyed.
3089    * This has copy-on-write semantics:
3090    * When the string is modified, then the buffer is first copied into
3091    * newly allocated memory.
3092    * The aliased buffer is never modified.
3093    *
3094    * In an assignment to another UnicodeString, when using the copy constructor
3095    * or the assignment operator, the text will be copied.
3096    * When using fastCopyFrom(), the text will be aliased again,
3097    * so that both strings then alias the same readonly-text.
3098    *
<span class="line-modified">3099    * @param isTerminated specifies if &lt;code&gt;text&lt;/code&gt; is &lt;code&gt;NUL&lt;/code&gt;-terminated.</span>
<span class="line-modified">3100    *                     This must be true if &lt;code&gt;textLength==-1&lt;/code&gt;.</span>
3101    * @param text The characters to alias for the UnicodeString.
<span class="line-modified">3102    * @param textLength The number of Unicode characters in &lt;code&gt;text&lt;/code&gt; to alias.</span>
3103    *                   If -1, then this constructor will determine the length
<span class="line-modified">3104    *                   by calling &lt;code&gt;u_strlen()&lt;/code&gt;.</span>
3105    * @stable ICU 2.0
3106    */
3107   UnicodeString(UBool isTerminated,
3108                 ConstChar16Ptr text,
3109                 int32_t textLength);
3110 
3111   /**
3112    * Writable-aliasing char16_t* constructor.
3113    * The text will be used for the UnicodeString object, but
3114    * it will not be released when the UnicodeString is destroyed.
3115    * This has write-through semantics:
3116    * For as long as the capacity of the buffer is sufficient, write operations
3117    * will directly affect the buffer. When more capacity is necessary, then
3118    * a new buffer will be allocated and the contents copied as with regularly
3119    * constructed strings.
3120    * In an assignment to another UnicodeString, the buffer will be copied.
3121    * The extract(Char16Ptr dst) function detects whether the dst pointer is the same
3122    * as the string buffer itself and will in this case not copy the contents.
3123    *
3124    * @param buffer The characters to alias for the UnicodeString.
<span class="line-modified">3125    * @param buffLength The number of Unicode characters in &lt;code&gt;buffer&lt;/code&gt; to alias.</span>
<span class="line-modified">3126    * @param buffCapacity The size of &lt;code&gt;buffer&lt;/code&gt; in char16_ts.</span>
3127    * @stable ICU 2.0
3128    */
3129   UnicodeString(char16_t *buffer, int32_t buffLength, int32_t buffCapacity);
3130 
3131 #if !U_CHAR16_IS_TYPEDEF
3132   /**
3133    * Writable-aliasing uint16_t * constructor.
3134    * Delegates to UnicodeString(const char16_t *, int32_t, int32_t).
3135    * @param buffer writable buffer of/for UTF-16 text
3136    * @param buffLength length of the current buffer contents
3137    * @param buffCapacity buffer capacity
3138    * @stable ICU 59
3139    */
3140   UnicodeString(uint16_t *buffer, int32_t buffLength, int32_t buffCapacity) :
3141       UnicodeString(Char16Ptr(buffer), buffLength, buffCapacity) {}
3142 #endif
3143 
3144 #if U_SIZEOF_WCHAR_T==2 || defined(U_IN_DOXYGEN)
3145   /**
3146    * Writable-aliasing wchar_t * constructor.
</pre>
<hr />
<pre>
3161    * @param buffer nullptr
3162    * @param buffLength ignored
3163    * @param buffCapacity ignored
3164    * @stable ICU 59
3165    */
3166   inline UnicodeString(std::nullptr_t buffer, int32_t buffLength, int32_t buffCapacity);
3167 
3168 #if U_CHARSET_IS_UTF8 || !UCONFIG_NO_CONVERSION
3169 
3170   /**
3171    * char* constructor.
3172    * Uses the default converter (and thus depends on the ICU conversion code)
3173    * unless U_CHARSET_IS_UTF8 is set to 1.
3174    *
3175    * For ASCII (really &quot;invariant character&quot;) strings it is more efficient to use
3176    * the constructor that takes a US_INV (for its enum EInvariant).
3177    * For ASCII (invariant-character) string literals, see UNICODE_STRING and
3178    * UNICODE_STRING_SIMPLE.
3179    *
3180    * It is recommended to mark this constructor &quot;explicit&quot; by
<span class="line-modified">3181    * &lt;code&gt;-DUNISTR_FROM_STRING_EXPLICIT=explicit&lt;/code&gt;</span>
3182    * on the compiler command line or similar.
3183    * @param codepageData an array of bytes, null-terminated,
3184    *                     in the platform&#39;s default codepage.
3185    * @stable ICU 2.0
3186    * @see UNICODE_STRING
3187    * @see UNICODE_STRING_SIMPLE
3188    */
3189   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const char *codepageData);
3190 
3191   /**
3192    * char* constructor.
3193    * Uses the default converter (and thus depends on the ICU conversion code)
3194    * unless U_CHARSET_IS_UTF8 is set to 1.
3195    * @param codepageData an array of bytes in the platform&#39;s default codepage.
<span class="line-modified">3196    * @param dataLength The number of bytes in &lt;TT&gt;codepageData&lt;/TT&gt;.</span>
3197    * @stable ICU 2.0
3198    */
3199   UnicodeString(const char *codepageData, int32_t dataLength);
3200 
3201 #endif
3202 
3203 #if !UCONFIG_NO_CONVERSION
3204 
3205   /**
3206    * char* constructor.
3207    * @param codepageData an array of bytes, null-terminated
<span class="line-modified">3208    * @param codepage the encoding of &lt;TT&gt;codepageData&lt;/TT&gt;.  The special</span>
<span class="line-modified">3209    * value 0 for &lt;TT&gt;codepage&lt;/TT&gt; indicates that the text is in the</span>
3210    * platform&#39;s default codepage.
3211    *
<span class="line-modified">3212    * If &lt;code&gt;codepage&lt;/code&gt; is an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;),</span>
3213    * then a simple conversion is performed on the codepage-invariant
3214    * subset (&quot;invariant characters&quot;) of the platform encoding. See utypes.h.
3215    * Recommendation: For invariant-character strings use the constructor
3216    * UnicodeString(const char *src, int32_t length, enum EInvariant inv)
3217    * because it avoids object code dependencies of UnicodeString on
3218    * the conversion code.
3219    *
3220    * @stable ICU 2.0
3221    */
3222   UnicodeString(const char *codepageData, const char *codepage);
3223 
3224   /**
3225    * char* constructor.
3226    * @param codepageData an array of bytes.
<span class="line-modified">3227    * @param dataLength The number of bytes in &lt;TT&gt;codepageData&lt;/TT&gt;.</span>
<span class="line-modified">3228    * @param codepage the encoding of &lt;TT&gt;codepageData&lt;/TT&gt;.  The special</span>
<span class="line-modified">3229    * value 0 for &lt;TT&gt;codepage&lt;/TT&gt; indicates that the text is in the</span>
3230    * platform&#39;s default codepage.
<span class="line-modified">3231    * If &lt;code&gt;codepage&lt;/code&gt; is an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;),</span>
3232    * then a simple conversion is performed on the codepage-invariant
3233    * subset (&quot;invariant characters&quot;) of the platform encoding. See utypes.h.
3234    * Recommendation: For invariant-character strings use the constructor
3235    * UnicodeString(const char *src, int32_t length, enum EInvariant inv)
3236    * because it avoids object code dependencies of UnicodeString on
3237    * the conversion code.
3238    *
3239    * @stable ICU 2.0
3240    */
3241   UnicodeString(const char *codepageData, int32_t dataLength, const char *codepage);
3242 
3243   /**
3244    * char * / UConverter constructor.
3245    * This constructor uses an existing UConverter object to
3246    * convert the codepage string to Unicode and construct a UnicodeString
3247    * from that.
3248    *
3249    * The converter is reset at first.
3250    * If the error code indicates a failure before this constructor is called,
3251    * or if an error occurs during conversion or construction,
</pre>
<hr />
<pre>
3262    * @stable ICU 2.0
3263    */
3264   UnicodeString(
3265         const char *src, int32_t srcLength,
3266         UConverter *cnv,
3267         UErrorCode &amp;errorCode);
3268 
3269 #endif
3270 
3271   /**
3272    * Constructs a Unicode string from an invariant-character char * string.
3273    * About invariant characters see utypes.h.
3274    * This constructor has no runtime dependency on conversion code and is
3275    * therefore recommended over ones taking a charset name string
3276    * (where the empty string &quot;&quot; indicates invariant-character conversion).
3277    *
3278    * Use the macro US_INV as the third, signature-distinguishing parameter.
3279    *
3280    * For example:
3281    * \code
<span class="line-modified">3282    * void fn(const char *s) {</span>
<span class="line-modified">3283    *   UnicodeString ustr(s, -1, US_INV);</span>
<span class="line-modified">3284    *   // use ustr ...</span>
<span class="line-modified">3285    * }</span>
3286    * \endcode
<span class="line-removed">3287    *</span>
3288    * @param src String using only invariant characters.
3289    * @param length Length of src, or -1 if NUL-terminated.
3290    * @param inv Signature-distinguishing paramater, use US_INV.
3291    *
3292    * @see US_INV
3293    * @stable ICU 3.2
3294    */
3295   UnicodeString(const char *src, int32_t length, enum EInvariant inv);
3296 
3297 
3298   /**
3299    * Copy constructor.
3300    *
3301    * Starting with ICU 2.4, the assignment operator and the copy constructor
3302    * allocate a new buffer and copy the buffer contents even for readonly aliases.
3303    * By contrast, the fastCopyFrom() function implements the old,
3304    * more efficient but less safe behavior
3305    * of making this string also a readonly alias to the same buffer.
3306    *
3307    * If the source object has an &quot;open&quot; buffer from getBuffer(minCapacity),
3308    * then the copy is an empty string.
3309    *
3310    * @param that The UnicodeString object to copy.
3311    * @stable ICU 2.0
3312    * @see fastCopyFrom
3313    */
3314   UnicodeString(const UnicodeString&amp; that);
3315 
3316   /**
3317    * Move constructor; might leave src in bogus state.
3318    * This string will have the same contents and state that the source string had.
3319    * @param src source string
3320    * @stable ICU 56
3321    */
3322   UnicodeString(UnicodeString &amp;&amp;src) U_NOEXCEPT;
3323 
3324   /**
3325    * &#39;Substring&#39; constructor from tail of source string.
3326    * @param src The UnicodeString object to copy.
<span class="line-modified">3327    * @param srcStart The offset into &lt;tt&gt;src&lt;/tt&gt; at which to start copying.</span>
3328    * @stable ICU 2.2
3329    */
3330   UnicodeString(const UnicodeString&amp; src, int32_t srcStart);
3331 
3332   /**
3333    * &#39;Substring&#39; constructor from subrange of source string.
3334    * @param src The UnicodeString object to copy.
<span class="line-modified">3335    * @param srcStart The offset into &lt;tt&gt;src&lt;/tt&gt; at which to start copying.</span>
<span class="line-modified">3336    * @param srcLength The number of characters from &lt;tt&gt;src&lt;/tt&gt; to copy.</span>
3337    * @stable ICU 2.2
3338    */
3339   UnicodeString(const UnicodeString&amp; src, int32_t srcStart, int32_t srcLength);
3340 
3341   /**
3342    * Clone this object, an instance of a subclass of Replaceable.
3343    * Clones can be used concurrently in multiple threads.
3344    * If a subclass does not implement clone(), or if an error occurs,
3345    * then NULL is returned.
3346    * The clone functions in all subclasses return a pointer to a Replaceable
3347    * because some compilers do not support covariant (same-as-this)
3348    * return types; cast to the appropriate subclass if necessary.
3349    * The caller must delete the clone.
3350    *
3351    * @return a clone of this object
3352    *
3353    * @see Replaceable::clone
3354    * @see getDynamicClassID
3355    * @stable ICU 2.6
3356    */
</pre>
<hr />
<pre>
3388    * @stable ICU 4.2
3389    */
3390   static UnicodeString fromUTF32(const UChar32 *utf32, int32_t length);
3391 
3392   /* Miscellaneous operations */
3393 
3394   /**
3395    * Unescape a string of characters and return a string containing
3396    * the result.  The following escape sequences are recognized:
3397    *
3398    * \\uhhhh       4 hex digits; h in [0-9A-Fa-f]
3399    * \\Uhhhhhhhh   8 hex digits
3400    * \\xhh         1-2 hex digits
3401    * \\ooo         1-3 octal digits; o in [0-7]
3402    * \\cX          control-X; X is masked with 0x1F
3403    *
3404    * as well as the standard ANSI C escapes:
3405    *
3406    * \\a =&gt; U+0007, \\b =&gt; U+0008, \\t =&gt; U+0009, \\n =&gt; U+000A,
3407    * \\v =&gt; U+000B, \\f =&gt; U+000C, \\r =&gt; U+000D, \\e =&gt; U+001B,
<span class="line-modified">3408    * \\&amp;quot; =&gt; U+0022, \\&#39; =&gt; U+0027, \\? =&gt; U+003F, \\\\ =&gt; U+005C</span>
3409    *
3410    * Anything else following a backslash is generically escaped.  For
3411    * example, &quot;[a\\-z]&quot; returns &quot;[a-z]&quot;.
3412    *
3413    * If an escape sequence is ill-formed, this method returns an empty
3414    * string.  An example of an ill-formed sequence is &quot;\\u&quot; followed by
3415    * fewer than 4 hex digits.
3416    *
3417    * This function is similar to u_unescape() but not identical to it.
3418    * The latter takes a source char*, so it does escape recognition
3419    * and also invariant conversion.
3420    *
3421    * @return a string with backslash escapes interpreted, or an
3422    * empty string on error.
3423    * @see UnicodeString#unescapeAt()
3424    * @see u_unescape()
3425    * @see u_unescapeAt()
3426    * @stable ICU 2.0
3427    */
3428   UnicodeString unescape() const;
</pre>
<hr />
<pre>
3636   // Copies just the fields without memory management.
3637   void copyFieldsFrom(UnicodeString &amp;src, UBool setSrcToBogus) U_NOEXCEPT;
3638 
3639   // Pin start and limit to acceptable values.
3640   inline void pinIndex(int32_t&amp; start) const;
3641   inline void pinIndices(int32_t&amp; start,
3642                          int32_t&amp; length) const;
3643 
3644 #if !UCONFIG_NO_CONVERSION
3645 
3646   /* Internal extract() using UConverter. */
3647   int32_t doExtract(int32_t start, int32_t length,
3648                     char *dest, int32_t destCapacity,
3649                     UConverter *cnv,
3650                     UErrorCode &amp;errorCode) const;
3651 
3652   /*
3653    * Real constructor for converting from codepage data.
3654    * It assumes that it is called with !fRefCounted.
3655    *
<span class="line-modified">3656    * If &lt;code&gt;codepage==0&lt;/code&gt;, then the default converter</span>
3657    * is used for the platform encoding.
<span class="line-modified">3658    * If &lt;code&gt;codepage&lt;/code&gt; is an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;),</span>
3659    * then a simple conversion is performed on the codepage-invariant
3660    * subset (&quot;invariant characters&quot;) of the platform encoding. See utypes.h.
3661    */
3662   void doCodepageCreate(const char *codepageData,
3663                         int32_t dataLength,
3664                         const char *codepage);
3665 
3666   /*
3667    * Worker function for creating a UnicodeString from
3668    * a codepage string using a UConverter.
3669    */
3670   void
3671   doCodepageCreate(const char *codepageData,
3672                    int32_t dataLength,
3673                    UConverter *converter,
3674                    UErrorCode &amp;status);
3675 
3676 #endif
3677 
3678   /*
</pre>
</td>
<td>
<hr />
<pre>
  89  * (where the empty string &quot;&quot; indicates invariant-character conversion).
  90  *
  91  * @stable ICU 3.2
  92  */
  93 #define US_INV icu::UnicodeString::kInvariant
  94 
  95 /**
  96  * Unicode String literals in C++.
  97  *
  98  * Note: these macros are not recommended for new code.
  99  * Prior to the availability of C++11 and u&quot;unicode string literals&quot;,
 100  * these macros were provided for portability and efficiency when
 101  * initializing UnicodeStrings from literals.
 102  *
 103  * They work only for strings that contain &quot;invariant characters&quot;, i.e.,
 104  * only latin letters, digits, and some punctuation.
 105  * See utypes.h for details.
 106  *
 107  * The string parameter must be a C string literal.
 108  * The length of the string, not including the terminating
<span class="line-modified"> 109  * `NUL`, must be specified as a constant.</span>
 110  * @stable ICU 2.0
 111  */
 112 #if !U_CHAR16_IS_TYPEDEF
 113 # define UNICODE_STRING(cs, _length) icu::UnicodeString(TRUE, u ## cs, _length)
 114 #else
 115 # define UNICODE_STRING(cs, _length) icu::UnicodeString(TRUE, (const char16_t*)u ## cs, _length)
 116 #endif
 117 
 118 /**
 119  * Unicode String literals in C++.
 120  * Dependent on the platform properties, different UnicodeString
 121  * constructors should be used to create a UnicodeString object from
 122  * a string literal.
 123  * The macros are defined for improved performance.
 124  * They work only for strings that contain &quot;invariant characters&quot;, i.e.,
 125  * only latin letters, digits, and some punctuation.
 126  * See utypes.h for details.
 127  *
 128  * The string parameter must be a C string literal.
 129  * @stable ICU 2.0
</pre>
<hr />
<pre>
 204 # define UNISTR_OBJECT_SIZE 64
 205 #endif
 206 
 207 /**
 208  * UnicodeString is a string class that stores Unicode characters directly and provides
 209  * similar functionality as the Java String and StringBuffer/StringBuilder classes.
 210  * It is a concrete implementation of the abstract class Replaceable (for transliteration).
 211  *
 212  * A UnicodeString may also &quot;alias&quot; an external array of characters
 213  * (that is, point to it, rather than own the array)
 214  * whose lifetime must then at least match the lifetime of the aliasing object.
 215  * This aliasing may be preserved when returning a UnicodeString by value,
 216  * depending on the compiler and the function implementation,
 217  * via Return Value Optimization (RVO) or the move assignment operator.
 218  * (However, the copy assignment operator does not preserve aliasing.)
 219  * For details see the description of storage models at the end of the class API docs
 220  * and in the User Guide chapter linked from there.
 221  *
 222  * The UnicodeString class is not suitable for subclassing.
 223  *
<span class="line-modified"> 224  * For an overview of Unicode strings in C and C++ see the</span>
<span class="line-modified"> 225  * [User Guide Strings chapter](http://userguide.icu-project.org/strings#TOC-Strings-in-C-C-).</span>
 226  *
<span class="line-modified"> 227  * In ICU, a Unicode string consists of 16-bit Unicode *code units*.</span>
 228  * A Unicode character may be stored with either one code unit
 229  * (the most common case) or with a matched pair of special code units
 230  * (&quot;surrogates&quot;). The data type for code units is char16_t.
<span class="line-modified"> 231  * For single-character handling, a Unicode character code *point* is a value</span>
<span class="line-modified"> 232  * in the range 0..0x10ffff. ICU uses the UChar32 type for code points.</span>
 233  *
<span class="line-modified"> 234  * Indexes and offsets into and lengths of strings always count code units, not code points.</span>
 235  * This is the same as with multi-byte char* strings in traditional string handling.
 236  * Operations on partial strings typically do not test for code point boundaries.
 237  * If necessary, the user needs to take care of such boundaries by testing for the code unit
 238  * values or by using functions like
 239  * UnicodeString::getChar32Start() and UnicodeString::getChar32Limit()
<span class="line-modified"> 240  * (or, in C, the equivalent macros U16_SET_CP_START() and U16_SET_CP_LIMIT(), see utf.h).</span>
 241  *
 242  * UnicodeString methods are more lenient with regard to input parameter values
 243  * than other ICU APIs. In particular:
 244  * - If indexes are out of bounds for a UnicodeString object
<span class="line-modified"> 245  *   (&lt; 0 or &gt; length()) then they are &quot;pinned&quot; to the nearest boundary.</span>
<span class="line-added"> 246  * - If the buffer passed to an insert/append/replace operation is owned by the</span>
<span class="line-added"> 247  *   target object, e.g., calling str.append(str), an extra copy may take place</span>
<span class="line-added"> 248  *   to ensure safety.</span>
 249  * - If primitive string pointer values (e.g., const char16_t * or char *)
 250  *   for input strings are NULL, then those input string parameters are treated
 251  *   as if they pointed to an empty string.
<span class="line-modified"> 252  *   However, this is *not* the case for char * parameters for charset names</span>
 253  *   or other IDs.
 254  * - Most UnicodeString methods do not take a UErrorCode parameter because
 255  *   there are usually very few opportunities for failure other than a shortage
 256  *   of memory, error codes in low-level C++ string methods would be inconvenient,
 257  *   and the error code as the last parameter (ICU convention) would prevent
 258  *   the use of default parameter values.
 259  *   Instead, such methods set the UnicodeString into a &quot;bogus&quot; state
 260  *   (see isBogus()) if an error occurs.
 261  *
 262  * In string comparisons, two UnicodeString objects that are both &quot;bogus&quot;
 263  * compare equal (to be transitive and prevent endless loops in sorting),
 264  * and a &quot;bogus&quot; string compares less than any non-&quot;bogus&quot; one.
 265  *
 266  * Const UnicodeString methods are thread-safe. Multiple threads can use
 267  * const methods on the same UnicodeString object simultaneously,
 268  * but non-const methods must not be called concurrently (in multiple threads)
 269  * with any other (const or non-const) methods.
 270  *
 271  * Similarly, const UnicodeString &amp; parameters are thread-safe.
 272  * One object may be passed in as such a parameter concurrently in multiple threads.
 273  * This includes the const UnicodeString &amp; parameters for
 274  * copy construction, assignment, and cloning.
 275  *
<span class="line-modified"> 276  * UnicodeString uses several storage methods.</span>
 277  * String contents can be stored inside the UnicodeString object itself,
 278  * in an allocated and shared buffer, or in an outside buffer that is &quot;aliased&quot;.
 279  * Most of this is done transparently, but careful aliasing in particular provides
 280  * significant performance improvements.
 281  * Also, the internal buffer is accessible via special functions.
 282  * For details see the
<span class="line-modified"> 283  * [User Guide Strings chapter](http://userguide.icu-project.org/strings#TOC-Maximizing-Performance-with-the-UnicodeString-Storage-Model).</span>
 284  *
 285  * @see utf.h
 286  * @see CharacterIterator
 287  * @stable ICU 2.0
 288  */
 289 class U_COMMON_API UnicodeString : public Replaceable
 290 {
 291 public:
 292 
 293   /**
 294    * Constant to be used in the UnicodeString(char *, int32_t, EInvariant) constructor
 295    * which constructs a Unicode string from an invariant-character char * string.
 296    * Use the macro US_INV instead of the full qualification for this value.
 297    *
 298    * @see US_INV
 299    * @stable ICU 3.2
 300    */
 301   enum EInvariant {
 302     /**
 303      * @see EInvariant
 304      * @stable ICU 3.2
 305      */
 306     kInvariant
 307   };
 308 
 309   //========================================
 310   // Read-only operations
 311   //========================================
 312 
 313   /* Comparison - bitwise only - for international comparison use collation */
 314 
 315   /**
 316    * Equality operator. Performs only bitwise comparison.
 317    * @param text The UnicodeString to compare to this one.
<span class="line-modified"> 318    * @return TRUE if `text` contains the same characters as this one,</span>
 319    * FALSE otherwise.
 320    * @stable ICU 2.0
 321    */
 322   inline UBool operator== (const UnicodeString&amp; text) const;
 323 
 324   /**
 325    * Inequality operator. Performs only bitwise comparison.
 326    * @param text The UnicodeString to compare to this one.
<span class="line-modified"> 327    * @return FALSE if `text` contains the same characters as this one,</span>
 328    * TRUE otherwise.
 329    * @stable ICU 2.0
 330    */
 331   inline UBool operator!= (const UnicodeString&amp; text) const;
 332 
 333   /**
 334    * Greater than operator. Performs only bitwise comparison.
 335    * @param text The UnicodeString to compare to this one.
 336    * @return TRUE if the characters in this are bitwise
<span class="line-modified"> 337    * greater than the characters in `text`, FALSE otherwise</span>
 338    * @stable ICU 2.0
 339    */
 340   inline UBool operator&gt; (const UnicodeString&amp; text) const;
 341 
 342   /**
 343    * Less than operator. Performs only bitwise comparison.
 344    * @param text The UnicodeString to compare to this one.
 345    * @return TRUE if the characters in this are bitwise
<span class="line-modified"> 346    * less than the characters in `text`, FALSE otherwise</span>
 347    * @stable ICU 2.0
 348    */
 349   inline UBool operator&lt; (const UnicodeString&amp; text) const;
 350 
 351   /**
 352    * Greater than or equal operator. Performs only bitwise comparison.
 353    * @param text The UnicodeString to compare to this one.
 354    * @return TRUE if the characters in this are bitwise
<span class="line-modified"> 355    * greater than or equal to the characters in `text`, FALSE otherwise</span>
 356    * @stable ICU 2.0
 357    */
 358   inline UBool operator&gt;= (const UnicodeString&amp; text) const;
 359 
 360   /**
 361    * Less than or equal operator. Performs only bitwise comparison.
 362    * @param text The UnicodeString to compare to this one.
 363    * @return TRUE if the characters in this are bitwise
<span class="line-modified"> 364    * less than or equal to the characters in `text`, FALSE otherwise</span>
 365    * @stable ICU 2.0
 366    */
 367   inline UBool operator&lt;= (const UnicodeString&amp; text) const;
 368 
 369   /**
 370    * Compare the characters bitwise in this UnicodeString to
<span class="line-modified"> 371    * the characters in `text`.</span>
 372    * @param text The UnicodeString to compare to this one.
 373    * @return The result of bitwise character comparison: 0 if this
<span class="line-modified"> 374    * contains the same characters as `text`, -1 if the characters in</span>
<span class="line-modified"> 375    * this are bitwise less than the characters in `text`, +1 if the</span>
 376    * characters in this are bitwise greater than the characters
<span class="line-modified"> 377    * in `text`.</span>
 378    * @stable ICU 2.0
 379    */
 380   inline int8_t compare(const UnicodeString&amp; text) const;
 381 
 382   /**
 383    * Compare the characters bitwise in the range
<span class="line-modified"> 384    * [`start`, `start + length`) with the characters</span>
<span class="line-modified"> 385    * in the **entire string** `text`.</span>
 386    * (The parameters &quot;start&quot; and &quot;length&quot; are not applied to the other text &quot;text&quot;.)
 387    * @param start the offset at which the compare operation begins
 388    * @param length the number of characters of text to compare.
 389    * @param text the other text to be compared against this string.
 390    * @return The result of bitwise character comparison: 0 if this
<span class="line-modified"> 391    * contains the same characters as `text`, -1 if the characters in</span>
<span class="line-modified"> 392    * this are bitwise less than the characters in `text`, +1 if the</span>
 393    * characters in this are bitwise greater than the characters
<span class="line-modified"> 394    * in `text`.</span>
 395    * @stable ICU 2.0
 396    */
 397   inline int8_t compare(int32_t start,
 398          int32_t length,
 399          const UnicodeString&amp; text) const;
 400 
 401   /**
 402    * Compare the characters bitwise in the range
<span class="line-modified"> 403    * [`start`, `start + length`) with the characters</span>
<span class="line-modified"> 404    * in `srcText` in the range</span>
<span class="line-modified"> 405    * [`srcStart`, `srcStart + srcLength`).</span>
 406    * @param start the offset at which the compare operation begins
 407    * @param length the number of characters in this to compare.
 408    * @param srcText the text to be compared
<span class="line-modified"> 409    * @param srcStart the offset into `srcText` to start comparison</span>
<span class="line-modified"> 410    * @param srcLength the number of characters in `src` to compare</span>
 411    * @return The result of bitwise character comparison: 0 if this
<span class="line-modified"> 412    * contains the same characters as `srcText`, -1 if the characters in</span>
<span class="line-modified"> 413    * this are bitwise less than the characters in `srcText`, +1 if the</span>
 414    * characters in this are bitwise greater than the characters
<span class="line-modified"> 415    * in `srcText`.</span>
 416    * @stable ICU 2.0
 417    */
 418    inline int8_t compare(int32_t start,
 419          int32_t length,
 420          const UnicodeString&amp; srcText,
 421          int32_t srcStart,
 422          int32_t srcLength) const;
 423 
 424   /**
 425    * Compare the characters bitwise in this UnicodeString with the first
<span class="line-modified"> 426    * `srcLength` characters in `srcChars`.</span>
 427    * @param srcChars The characters to compare to this UnicodeString.
<span class="line-modified"> 428    * @param srcLength the number of characters in `srcChars` to compare</span>
 429    * @return The result of bitwise character comparison: 0 if this
<span class="line-modified"> 430    * contains the same characters as `srcChars`, -1 if the characters in</span>
<span class="line-modified"> 431    * this are bitwise less than the characters in `srcChars`, +1 if the</span>
 432    * characters in this are bitwise greater than the characters
<span class="line-modified"> 433    * in `srcChars`.</span>
 434    * @stable ICU 2.0
 435    */
 436   inline int8_t compare(ConstChar16Ptr srcChars,
 437          int32_t srcLength) const;
 438 
 439   /**
 440    * Compare the characters bitwise in the range
<span class="line-modified"> 441    * [`start`, `start + length`) with the first</span>
<span class="line-modified"> 442    * `length` characters in `srcChars`</span>
 443    * @param start the offset at which the compare operation begins
 444    * @param length the number of characters to compare.
 445    * @param srcChars the characters to be compared
 446    * @return The result of bitwise character comparison: 0 if this
<span class="line-modified"> 447    * contains the same characters as `srcChars`, -1 if the characters in</span>
<span class="line-modified"> 448    * this are bitwise less than the characters in `srcChars`, +1 if the</span>
 449    * characters in this are bitwise greater than the characters
<span class="line-modified"> 450    * in `srcChars`.</span>
 451    * @stable ICU 2.0
 452    */
 453   inline int8_t compare(int32_t start,
 454          int32_t length,
 455          const char16_t *srcChars) const;
 456 
 457   /**
 458    * Compare the characters bitwise in the range
<span class="line-modified"> 459    * [`start`, `start + length`) with the characters</span>
<span class="line-modified"> 460    * in `srcChars` in the range</span>
<span class="line-modified"> 461    * [`srcStart`, `srcStart + srcLength`).</span>
 462    * @param start the offset at which the compare operation begins
 463    * @param length the number of characters in this to compare
 464    * @param srcChars the characters to be compared
<span class="line-modified"> 465    * @param srcStart the offset into `srcChars` to start comparison</span>
<span class="line-modified"> 466    * @param srcLength the number of characters in `srcChars` to compare</span>
 467    * @return The result of bitwise character comparison: 0 if this
<span class="line-modified"> 468    * contains the same characters as `srcChars`, -1 if the characters in</span>
<span class="line-modified"> 469    * this are bitwise less than the characters in `srcChars`, +1 if the</span>
 470    * characters in this are bitwise greater than the characters
<span class="line-modified"> 471    * in `srcChars`.</span>
 472    * @stable ICU 2.0
 473    */
 474   inline int8_t compare(int32_t start,
 475          int32_t length,
 476          const char16_t *srcChars,
 477          int32_t srcStart,
 478          int32_t srcLength) const;
 479 
 480   /**
 481    * Compare the characters bitwise in the range
<span class="line-modified"> 482    * [`start`, `limit`) with the characters</span>
<span class="line-modified"> 483    * in `srcText` in the range</span>
<span class="line-modified"> 484    * [`srcStart`, `srcLimit`).</span>
 485    * @param start the offset at which the compare operation begins
 486    * @param limit the offset immediately following the compare operation
 487    * @param srcText the text to be compared
<span class="line-modified"> 488    * @param srcStart the offset into `srcText` to start comparison</span>
<span class="line-modified"> 489    * @param srcLimit the offset into `srcText` to limit comparison</span>
 490    * @return The result of bitwise character comparison: 0 if this
<span class="line-modified"> 491    * contains the same characters as `srcText`, -1 if the characters in</span>
<span class="line-modified"> 492    * this are bitwise less than the characters in `srcText`, +1 if the</span>
 493    * characters in this are bitwise greater than the characters
<span class="line-modified"> 494    * in `srcText`.</span>
 495    * @stable ICU 2.0
 496    */
 497   inline int8_t compareBetween(int32_t start,
 498             int32_t limit,
 499             const UnicodeString&amp; srcText,
 500             int32_t srcStart,
 501             int32_t srcLimit) const;
 502 
 503   /**
 504    * Compare two Unicode strings in code point order.
 505    * The result may be different from the results of compare(), operator&lt;, etc.
 506    * if supplementary characters are present:
 507    *
 508    * In UTF-16, supplementary characters (with code points U+10000 and above) are
 509    * stored with pairs of surrogate code units. These have values from 0xd800 to 0xdfff,
 510    * which means that they compare as less than some other BMP characters like U+feff.
 511    * This function compares Unicode strings in code point order.
 512    * If either of the UTF-16 strings is malformed (i.e., it contains unpaired surrogates), then the result is not defined.
 513    *
 514    * @param text Another string to compare this one to.
</pre>
<hr />
<pre>
 831    *   - U_FOLD_CASE_DEFAULT or 0 is used for default options:
 832    *     Comparison in code unit order with default case folding.
 833    *
 834    *   - U_COMPARE_CODE_POINT_ORDER
 835    *     Set to choose code point order instead of code unit order
 836    *     (see u_strCompare for details).
 837    *
 838    *   - U_FOLD_CASE_EXCLUDE_SPECIAL_I
 839    *
 840    * @return A negative, zero, or positive integer indicating the comparison result.
 841    * @stable ICU 2.0
 842    */
 843   inline int8_t caseCompareBetween(int32_t start,
 844             int32_t limit,
 845             const UnicodeString&amp; srcText,
 846             int32_t srcStart,
 847             int32_t srcLimit,
 848             uint32_t options) const;
 849 
 850   /**
<span class="line-modified"> 851    * Determine if this starts with the characters in `text`</span>
 852    * @param text The text to match.
<span class="line-modified"> 853    * @return TRUE if this starts with the characters in `text`,</span>
 854    * FALSE otherwise
 855    * @stable ICU 2.0
 856    */
 857   inline UBool startsWith(const UnicodeString&amp; text) const;
 858 
 859   /**
<span class="line-modified"> 860    * Determine if this starts with the characters in `srcText`</span>
<span class="line-modified"> 861    * in the range [`srcStart`, `srcStart + srcLength`).</span>
 862    * @param srcText The text to match.
<span class="line-modified"> 863    * @param srcStart the offset into `srcText` to start matching</span>
<span class="line-modified"> 864    * @param srcLength the number of characters in `srcText` to match</span>
<span class="line-modified"> 865    * @return TRUE if this starts with the characters in `text`,</span>
 866    * FALSE otherwise
 867    * @stable ICU 2.0
 868    */
 869   inline UBool startsWith(const UnicodeString&amp; srcText,
 870             int32_t srcStart,
 871             int32_t srcLength) const;
 872 
 873   /**
<span class="line-modified"> 874    * Determine if this starts with the characters in `srcChars`</span>
 875    * @param srcChars The characters to match.
<span class="line-modified"> 876    * @param srcLength the number of characters in `srcChars`</span>
<span class="line-modified"> 877    * @return TRUE if this starts with the characters in `srcChars`,</span>
 878    * FALSE otherwise
 879    * @stable ICU 2.0
 880    */
 881   inline UBool startsWith(ConstChar16Ptr srcChars,
 882             int32_t srcLength) const;
 883 
 884   /**
<span class="line-modified"> 885    * Determine if this ends with the characters in `srcChars`</span>
<span class="line-modified"> 886    * in the range  [`srcStart`, `srcStart + srcLength`).</span>
 887    * @param srcChars The characters to match.
<span class="line-modified"> 888    * @param srcStart the offset into `srcText` to start matching</span>
<span class="line-modified"> 889    * @param srcLength the number of characters in `srcChars` to match</span>
<span class="line-modified"> 890    * @return TRUE if this ends with the characters in `srcChars`, FALSE otherwise</span>
 891    * @stable ICU 2.0
 892    */
 893   inline UBool startsWith(const char16_t *srcChars,
 894             int32_t srcStart,
 895             int32_t srcLength) const;
 896 
 897   /**
<span class="line-modified"> 898    * Determine if this ends with the characters in `text`</span>
 899    * @param text The text to match.
<span class="line-modified"> 900    * @return TRUE if this ends with the characters in `text`,</span>
 901    * FALSE otherwise
 902    * @stable ICU 2.0
 903    */
 904   inline UBool endsWith(const UnicodeString&amp; text) const;
 905 
 906   /**
<span class="line-modified"> 907    * Determine if this ends with the characters in `srcText`</span>
<span class="line-modified"> 908    * in the range [`srcStart`, `srcStart + srcLength`).</span>
 909    * @param srcText The text to match.
<span class="line-modified"> 910    * @param srcStart the offset into `srcText` to start matching</span>
<span class="line-modified"> 911    * @param srcLength the number of characters in `srcText` to match</span>
<span class="line-modified"> 912    * @return TRUE if this ends with the characters in `text`,</span>
 913    * FALSE otherwise
 914    * @stable ICU 2.0
 915    */
 916   inline UBool endsWith(const UnicodeString&amp; srcText,
 917           int32_t srcStart,
 918           int32_t srcLength) const;
 919 
 920   /**
<span class="line-modified"> 921    * Determine if this ends with the characters in `srcChars`</span>
 922    * @param srcChars The characters to match.
<span class="line-modified"> 923    * @param srcLength the number of characters in `srcChars`</span>
<span class="line-modified"> 924    * @return TRUE if this ends with the characters in `srcChars`,</span>
 925    * FALSE otherwise
 926    * @stable ICU 2.0
 927    */
 928   inline UBool endsWith(ConstChar16Ptr srcChars,
 929           int32_t srcLength) const;
 930 
 931   /**
<span class="line-modified"> 932    * Determine if this ends with the characters in `srcChars`</span>
<span class="line-modified"> 933    * in the range  [`srcStart`, `srcStart + srcLength`).</span>
 934    * @param srcChars The characters to match.
<span class="line-modified"> 935    * @param srcStart the offset into `srcText` to start matching</span>
<span class="line-modified"> 936    * @param srcLength the number of characters in `srcChars` to match</span>
<span class="line-modified"> 937    * @return TRUE if this ends with the characters in `srcChars`,</span>
 938    * FALSE otherwise
 939    * @stable ICU 2.0
 940    */
 941   inline UBool endsWith(const char16_t *srcChars,
 942           int32_t srcStart,
 943           int32_t srcLength) const;
 944 
 945 
 946   /* Searching - bitwise only */
 947 
 948   /**
<span class="line-modified"> 949    * Locate in this the first occurrence of the characters in `text`,</span>
 950    * using bitwise comparison.
 951    * @param text The text to search for.
<span class="line-modified"> 952    * @return The offset into this of the start of `text`,</span>
 953    * or -1 if not found.
 954    * @stable ICU 2.0
 955    */
 956   inline int32_t indexOf(const UnicodeString&amp; text) const;
 957 
 958   /**
<span class="line-modified"> 959    * Locate in this the first occurrence of the characters in `text`</span>
<span class="line-modified"> 960    * starting at offset `start`, using bitwise comparison.</span>
 961    * @param text The text to search for.
 962    * @param start The offset at which searching will start.
<span class="line-modified"> 963    * @return The offset into this of the start of `text`,</span>
 964    * or -1 if not found.
 965    * @stable ICU 2.0
 966    */
 967   inline int32_t indexOf(const UnicodeString&amp; text,
 968               int32_t start) const;
 969 
 970   /**
 971    * Locate in this the first occurrence in the range
<span class="line-modified"> 972    * [`start`, `start + length`) of the characters</span>
<span class="line-modified"> 973    * in `text`, using bitwise comparison.</span>
 974    * @param text The text to search for.
 975    * @param start The offset at which searching will start.
 976    * @param length The number of characters to search
<span class="line-modified"> 977    * @return The offset into this of the start of `text`,</span>
 978    * or -1 if not found.
 979    * @stable ICU 2.0
 980    */
 981   inline int32_t indexOf(const UnicodeString&amp; text,
 982               int32_t start,
 983               int32_t length) const;
 984 
 985   /**
 986    * Locate in this the first occurrence in the range
<span class="line-modified"> 987    * [`start`, `start + length`) of the characters</span>
<span class="line-modified"> 988    *  in `srcText` in the range</span>
<span class="line-modified"> 989    * [`srcStart`, `srcStart + srcLength`),</span>
 990    * using bitwise comparison.
 991    * @param srcText The text to search for.
<span class="line-modified"> 992    * @param srcStart the offset into `srcText` at which</span>
 993    * to start matching
<span class="line-modified"> 994    * @param srcLength the number of characters in `srcText` to match</span>
 995    * @param start the offset into this at which to start matching
 996    * @param length the number of characters in this to search
<span class="line-modified"> 997    * @return The offset into this of the start of `text`,</span>
 998    * or -1 if not found.
 999    * @stable ICU 2.0
1000    */
1001   inline int32_t indexOf(const UnicodeString&amp; srcText,
1002               int32_t srcStart,
1003               int32_t srcLength,
1004               int32_t start,
1005               int32_t length) const;
1006 
1007   /**
1008    * Locate in this the first occurrence of the characters in
<span class="line-modified">1009    * `srcChars`</span>
<span class="line-modified">1010    * starting at offset `start`, using bitwise comparison.</span>
1011    * @param srcChars The text to search for.
<span class="line-modified">1012    * @param srcLength the number of characters in `srcChars` to match</span>
1013    * @param start the offset into this at which to start matching
<span class="line-modified">1014    * @return The offset into this of the start of `text`,</span>
1015    * or -1 if not found.
1016    * @stable ICU 2.0
1017    */
1018   inline int32_t indexOf(const char16_t *srcChars,
1019               int32_t srcLength,
1020               int32_t start) const;
1021 
1022   /**
1023    * Locate in this the first occurrence in the range
<span class="line-modified">1024    * [`start`, `start + length`) of the characters</span>
<span class="line-modified">1025    * in `srcChars`, using bitwise comparison.</span>
1026    * @param srcChars The text to search for.
<span class="line-modified">1027    * @param srcLength the number of characters in `srcChars`</span>
1028    * @param start The offset at which searching will start.
1029    * @param length The number of characters to search
<span class="line-modified">1030    * @return The offset into this of the start of `srcChars`,</span>
1031    * or -1 if not found.
1032    * @stable ICU 2.0
1033    */
1034   inline int32_t indexOf(ConstChar16Ptr srcChars,
1035               int32_t srcLength,
1036               int32_t start,
1037               int32_t length) const;
1038 
1039   /**
1040    * Locate in this the first occurrence in the range
<span class="line-modified">1041    * [`start`, `start + length`) of the characters</span>
<span class="line-modified">1042    * in `srcChars` in the range</span>
<span class="line-modified">1043    * [`srcStart`, `srcStart + srcLength`),</span>
1044    * using bitwise comparison.
1045    * @param srcChars The text to search for.
<span class="line-modified">1046    * @param srcStart the offset into `srcChars` at which</span>
1047    * to start matching
<span class="line-modified">1048    * @param srcLength the number of characters in `srcChars` to match</span>
1049    * @param start the offset into this at which to start matching
1050    * @param length the number of characters in this to search
<span class="line-modified">1051    * @return The offset into this of the start of `text`,</span>
1052    * or -1 if not found.
1053    * @stable ICU 2.0
1054    */
1055   int32_t indexOf(const char16_t *srcChars,
1056               int32_t srcStart,
1057               int32_t srcLength,
1058               int32_t start,
1059               int32_t length) const;
1060 
1061   /**
<span class="line-modified">1062    * Locate in this the first occurrence of the BMP code point `c`,</span>
1063    * using bitwise comparison.
1064    * @param c The code unit to search for.
<span class="line-modified">1065    * @return The offset into this of `c`, or -1 if not found.</span>
1066    * @stable ICU 2.0
1067    */
1068   inline int32_t indexOf(char16_t c) const;
1069 
1070   /**
<span class="line-modified">1071    * Locate in this the first occurrence of the code point `c`,</span>
1072    * using bitwise comparison.
1073    *
1074    * @param c The code point to search for.
<span class="line-modified">1075    * @return The offset into this of `c`, or -1 if not found.</span>
1076    * @stable ICU 2.0
1077    */
1078   inline int32_t indexOf(UChar32 c) const;
1079 
1080   /**
<span class="line-modified">1081    * Locate in this the first occurrence of the BMP code point `c`,</span>
<span class="line-modified">1082    * starting at offset `start`, using bitwise comparison.</span>
1083    * @param c The code unit to search for.
1084    * @param start The offset at which searching will start.
<span class="line-modified">1085    * @return The offset into this of `c`, or -1 if not found.</span>
1086    * @stable ICU 2.0
1087    */
1088   inline int32_t indexOf(char16_t c,
1089               int32_t start) const;
1090 
1091   /**
<span class="line-modified">1092    * Locate in this the first occurrence of the code point `c`</span>
<span class="line-modified">1093    * starting at offset `start`, using bitwise comparison.</span>
1094    *
1095    * @param c The code point to search for.
1096    * @param start The offset at which searching will start.
<span class="line-modified">1097    * @return The offset into this of `c`, or -1 if not found.</span>
1098    * @stable ICU 2.0
1099    */
1100   inline int32_t indexOf(UChar32 c,
1101               int32_t start) const;
1102 
1103   /**
<span class="line-modified">1104    * Locate in this the first occurrence of the BMP code point `c`</span>
<span class="line-modified">1105    * in the range [`start`, `start + length`),</span>
1106    * using bitwise comparison.
1107    * @param c The code unit to search for.
1108    * @param start the offset into this at which to start matching
1109    * @param length the number of characters in this to search
<span class="line-modified">1110    * @return The offset into this of `c`, or -1 if not found.</span>
1111    * @stable ICU 2.0
1112    */
1113   inline int32_t indexOf(char16_t c,
1114               int32_t start,
1115               int32_t length) const;
1116 
1117   /**
<span class="line-modified">1118    * Locate in this the first occurrence of the code point `c`</span>
<span class="line-modified">1119    * in the range [`start`, `start + length`),</span>
1120    * using bitwise comparison.
1121    *
1122    * @param c The code point to search for.
1123    * @param start the offset into this at which to start matching
1124    * @param length the number of characters in this to search
<span class="line-modified">1125    * @return The offset into this of `c`, or -1 if not found.</span>
1126    * @stable ICU 2.0
1127    */
1128   inline int32_t indexOf(UChar32 c,
1129               int32_t start,
1130               int32_t length) const;
1131 
1132   /**
<span class="line-modified">1133    * Locate in this the last occurrence of the characters in `text`,</span>
1134    * using bitwise comparison.
1135    * @param text The text to search for.
<span class="line-modified">1136    * @return The offset into this of the start of `text`,</span>
1137    * or -1 if not found.
1138    * @stable ICU 2.0
1139    */
1140   inline int32_t lastIndexOf(const UnicodeString&amp; text) const;
1141 
1142   /**
<span class="line-modified">1143    * Locate in this the last occurrence of the characters in `text`</span>
<span class="line-modified">1144    * starting at offset `start`, using bitwise comparison.</span>
1145    * @param text The text to search for.
1146    * @param start The offset at which searching will start.
<span class="line-modified">1147    * @return The offset into this of the start of `text`,</span>
1148    * or -1 if not found.
1149    * @stable ICU 2.0
1150    */
1151   inline int32_t lastIndexOf(const UnicodeString&amp; text,
1152               int32_t start) const;
1153 
1154   /**
1155    * Locate in this the last occurrence in the range
<span class="line-modified">1156    * [`start`, `start + length`) of the characters</span>
<span class="line-modified">1157    * in `text`, using bitwise comparison.</span>
1158    * @param text The text to search for.
1159    * @param start The offset at which searching will start.
1160    * @param length The number of characters to search
<span class="line-modified">1161    * @return The offset into this of the start of `text`,</span>
1162    * or -1 if not found.
1163    * @stable ICU 2.0
1164    */
1165   inline int32_t lastIndexOf(const UnicodeString&amp; text,
1166               int32_t start,
1167               int32_t length) const;
1168 
1169   /**
1170    * Locate in this the last occurrence in the range
<span class="line-modified">1171    * [`start`, `start + length`) of the characters</span>
<span class="line-modified">1172    * in `srcText` in the range</span>
<span class="line-modified">1173    * [`srcStart`, `srcStart + srcLength`),</span>
1174    * using bitwise comparison.
1175    * @param srcText The text to search for.
<span class="line-modified">1176    * @param srcStart the offset into `srcText` at which</span>
1177    * to start matching
<span class="line-modified">1178    * @param srcLength the number of characters in `srcText` to match</span>
1179    * @param start the offset into this at which to start matching
1180    * @param length the number of characters in this to search
<span class="line-modified">1181    * @return The offset into this of the start of `text`,</span>
1182    * or -1 if not found.
1183    * @stable ICU 2.0
1184    */
1185   inline int32_t lastIndexOf(const UnicodeString&amp; srcText,
1186               int32_t srcStart,
1187               int32_t srcLength,
1188               int32_t start,
1189               int32_t length) const;
1190 
1191   /**
<span class="line-modified">1192    * Locate in this the last occurrence of the characters in `srcChars`</span>
<span class="line-modified">1193    * starting at offset `start`, using bitwise comparison.</span>
1194    * @param srcChars The text to search for.
<span class="line-modified">1195    * @param srcLength the number of characters in `srcChars` to match</span>
1196    * @param start the offset into this at which to start matching
<span class="line-modified">1197    * @return The offset into this of the start of `text`,</span>
1198    * or -1 if not found.
1199    * @stable ICU 2.0
1200    */
1201   inline int32_t lastIndexOf(const char16_t *srcChars,
1202               int32_t srcLength,
1203               int32_t start) const;
1204 
1205   /**
1206    * Locate in this the last occurrence in the range
<span class="line-modified">1207    * [`start`, `start + length`) of the characters</span>
<span class="line-modified">1208    * in `srcChars`, using bitwise comparison.</span>
1209    * @param srcChars The text to search for.
<span class="line-modified">1210    * @param srcLength the number of characters in `srcChars`</span>
1211    * @param start The offset at which searching will start.
1212    * @param length The number of characters to search
<span class="line-modified">1213    * @return The offset into this of the start of `srcChars`,</span>
1214    * or -1 if not found.
1215    * @stable ICU 2.0
1216    */
1217   inline int32_t lastIndexOf(ConstChar16Ptr srcChars,
1218               int32_t srcLength,
1219               int32_t start,
1220               int32_t length) const;
1221 
1222   /**
1223    * Locate in this the last occurrence in the range
<span class="line-modified">1224    * [`start`, `start + length`) of the characters</span>
<span class="line-modified">1225    * in `srcChars` in the range</span>
<span class="line-modified">1226    * [`srcStart`, `srcStart + srcLength`),</span>
1227    * using bitwise comparison.
1228    * @param srcChars The text to search for.
<span class="line-modified">1229    * @param srcStart the offset into `srcChars` at which</span>
1230    * to start matching
<span class="line-modified">1231    * @param srcLength the number of characters in `srcChars` to match</span>
1232    * @param start the offset into this at which to start matching
1233    * @param length the number of characters in this to search
<span class="line-modified">1234    * @return The offset into this of the start of `text`,</span>
1235    * or -1 if not found.
1236    * @stable ICU 2.0
1237    */
1238   int32_t lastIndexOf(const char16_t *srcChars,
1239               int32_t srcStart,
1240               int32_t srcLength,
1241               int32_t start,
1242               int32_t length) const;
1243 
1244   /**
<span class="line-modified">1245    * Locate in this the last occurrence of the BMP code point `c`,</span>
1246    * using bitwise comparison.
1247    * @param c The code unit to search for.
<span class="line-modified">1248    * @return The offset into this of `c`, or -1 if not found.</span>
1249    * @stable ICU 2.0
1250    */
1251   inline int32_t lastIndexOf(char16_t c) const;
1252 
1253   /**
<span class="line-modified">1254    * Locate in this the last occurrence of the code point `c`,</span>
1255    * using bitwise comparison.
1256    *
1257    * @param c The code point to search for.
<span class="line-modified">1258    * @return The offset into this of `c`, or -1 if not found.</span>
1259    * @stable ICU 2.0
1260    */
1261   inline int32_t lastIndexOf(UChar32 c) const;
1262 
1263   /**
<span class="line-modified">1264    * Locate in this the last occurrence of the BMP code point `c`</span>
<span class="line-modified">1265    * starting at offset `start`, using bitwise comparison.</span>
1266    * @param c The code unit to search for.
1267    * @param start The offset at which searching will start.
<span class="line-modified">1268    * @return The offset into this of `c`, or -1 if not found.</span>
1269    * @stable ICU 2.0
1270    */
1271   inline int32_t lastIndexOf(char16_t c,
1272               int32_t start) const;
1273 
1274   /**
<span class="line-modified">1275    * Locate in this the last occurrence of the code point `c`</span>
<span class="line-modified">1276    * starting at offset `start`, using bitwise comparison.</span>
1277    *
1278    * @param c The code point to search for.
1279    * @param start The offset at which searching will start.
<span class="line-modified">1280    * @return The offset into this of `c`, or -1 if not found.</span>
1281    * @stable ICU 2.0
1282    */
1283   inline int32_t lastIndexOf(UChar32 c,
1284               int32_t start) const;
1285 
1286   /**
<span class="line-modified">1287    * Locate in this the last occurrence of the BMP code point `c`</span>
<span class="line-modified">1288    * in the range [`start`, `start + length`),</span>
1289    * using bitwise comparison.
1290    * @param c The code unit to search for.
1291    * @param start the offset into this at which to start matching
1292    * @param length the number of characters in this to search
<span class="line-modified">1293    * @return The offset into this of `c`, or -1 if not found.</span>
1294    * @stable ICU 2.0
1295    */
1296   inline int32_t lastIndexOf(char16_t c,
1297               int32_t start,
1298               int32_t length) const;
1299 
1300   /**
<span class="line-modified">1301    * Locate in this the last occurrence of the code point `c`</span>
<span class="line-modified">1302    * in the range [`start`, `start + length`),</span>
1303    * using bitwise comparison.
1304    *
1305    * @param c The code point to search for.
1306    * @param start the offset into this at which to start matching
1307    * @param length the number of characters in this to search
<span class="line-modified">1308    * @return The offset into this of `c`, or -1 if not found.</span>
1309    * @stable ICU 2.0
1310    */
1311   inline int32_t lastIndexOf(UChar32 c,
1312               int32_t start,
1313               int32_t length) const;
1314 
1315 
1316   /* Character access */
1317 
1318   /**
<span class="line-modified">1319    * Return the code unit at offset `offset`.</span>
1320    * If the offset is not valid (0..length()-1) then U+ffff is returned.
1321    * @param offset a valid offset into the text
<span class="line-modified">1322    * @return the code unit at offset `offset`</span>
1323    *         or 0xffff if the offset is not valid for this string
1324    * @stable ICU 2.0
1325    */
1326   inline char16_t charAt(int32_t offset) const;
1327 
1328   /**
<span class="line-modified">1329    * Return the code unit at offset `offset`.</span>
1330    * If the offset is not valid (0..length()-1) then U+ffff is returned.
1331    * @param offset a valid offset into the text
<span class="line-modified">1332    * @return the code unit at offset `offset`</span>
1333    * @stable ICU 2.0
1334    */
1335   inline char16_t operator[] (int32_t offset) const;
1336 
1337   /**
1338    * Return the code point that contains the code unit
<span class="line-modified">1339    * at offset `offset`.</span>
1340    * If the offset is not valid (0..length()-1) then U+ffff is returned.
1341    * @param offset a valid offset into the text
1342    * that indicates the text offset of any of the code units
1343    * that will be assembled into a code point (21-bit value) and returned
<span class="line-modified">1344    * @return the code point of text at `offset`</span>
1345    *         or 0xffff if the offset is not valid for this string
1346    * @stable ICU 2.0
1347    */
1348   UChar32 char32At(int32_t offset) const;
1349 
1350   /**
1351    * Adjust a random-access offset so that
1352    * it points to the beginning of a Unicode character.
1353    * The offset that is passed in points to
1354    * any code unit of a code point,
1355    * while the returned offset will point to the first code unit
1356    * of the same code point.
1357    * In UTF-16, if the input offset points to a second surrogate
1358    * of a surrogate pair, then the returned offset will point
1359    * to the first surrogate.
1360    * @param offset a valid offset into one code point of the text
1361    * @return offset of the first code unit of the same code point
1362    * @see U16_SET_CP_START
1363    * @stable ICU 2.0
1364    */
</pre>
<hr />
<pre>
1381    * @stable ICU 2.0
1382    */
1383   int32_t getChar32Limit(int32_t offset) const;
1384 
1385   /**
1386    * Move the code unit index along the string by delta code points.
1387    * Interpret the input index as a code unit-based offset into the string,
1388    * move the index forward or backward by delta code points, and
1389    * return the resulting index.
1390    * The input index should point to the first code unit of a code point,
1391    * if there is more than one.
1392    *
1393    * Both input and output indexes are code unit-based as for all
1394    * string indexes/offsets in ICU (and other libraries, like MBCS char*).
1395    * If delta&lt;0 then the index is moved backward (toward the start of the string).
1396    * If delta&gt;0 then the index is moved forward (toward the end of the string).
1397    *
1398    * This behaves like CharacterIterator::move32(delta, kCurrent).
1399    *
1400    * Behavior for out-of-bounds indexes:
<span class="line-modified">1401    * `moveIndex32` pins the input index to 0..length(), i.e.,</span>
1402    * if the input index&lt;0 then it is pinned to 0;
1403    * if it is index&gt;length() then it is pinned to length().
<span class="line-modified">1404    * Afterwards, the index is moved by `delta` code points</span>
1405    * forward or backward,
1406    * but no further backward than to 0 and no further forward than to length().
1407    * The resulting index return value will be in between 0 and length(), inclusively.
1408    *
1409    * Examples:
<span class="line-modified">1410    * \code</span>
<span class="line-modified">1411    *     // s has code points &#39;a&#39; U+10000 &#39;b&#39; U+10ffff U+2029</span>
<span class="line-modified">1412    *     UnicodeString s(u&quot;a\U00010000b\U0010ffff\u2029&quot;);</span>
1413    *
<span class="line-modified">1414    *     // initial index: position of U+10000</span>
<span class="line-modified">1415    *     int32_t index=1;</span>
1416    *
<span class="line-modified">1417    *     // the following examples will all result in index==4, position of U+10ffff</span>
1418    *
<span class="line-modified">1419    *     // skip 2 code points from some position in the string</span>
<span class="line-modified">1420    *     index=s.moveIndex32(index, 2); // skips U+10000 and &#39;b&#39;</span>
1421    *
<span class="line-modified">1422    *     // go to the 3rd code point from the start of s (0-based)</span>
<span class="line-modified">1423    *     index=s.moveIndex32(0, 3); // skips &#39;a&#39;, U+10000, and &#39;b&#39;</span>
1424    *
<span class="line-modified">1425    *     // go to the next-to-last code point of s</span>
<span class="line-modified">1426    *     index=s.moveIndex32(s.length(), -2); // backward-skips U+2029 and U+10ffff</span>
<span class="line-modified">1427    * \endcode</span>
1428    *
1429    * @param index input code unit index
1430    * @param delta (signed) code point count to move the index forward or backward
1431    *        in the string
1432    * @return the resulting code unit index
1433    * @stable ICU 2.0
1434    */
1435   int32_t moveIndex32(int32_t index, int32_t delta) const;
1436 
1437   /* Substring extraction */
1438 
1439   /**
1440    * Copy the characters in the range
<span class="line-modified">1441    * [`start`, `start + length`) into the array `dst`,</span>
<span class="line-modified">1442    * beginning at `dstStart`.</span>
<span class="line-modified">1443    * If the string aliases to `dst` itself as an external buffer,</span>
1444    * then extract() will not copy the contents.
1445    *
1446    * @param start offset of first character which will be copied into the array
1447    * @param length the number of characters to extract
<span class="line-modified">1448    * @param dst array in which to copy characters.  The length of `dst`</span>
<span class="line-modified">1449    * must be at least (`dstStart + length`).</span>
<span class="line-modified">1450    * @param dstStart the offset in `dst` where the first character</span>
1451    * will be extracted
1452    * @stable ICU 2.0
1453    */
1454   inline void extract(int32_t start,
1455            int32_t length,
1456            Char16Ptr dst,
1457            int32_t dstStart = 0) const;
1458 
1459   /**
1460    * Copy the contents of the string into dest.
1461    * This is a convenience function that
1462    * checks if there is enough space in dest,
1463    * extracts the entire string if possible,
1464    * and NUL-terminates dest if possible.
1465    *
1466    * If the string fits into dest but cannot be NUL-terminated
1467    * (length()==destCapacity) then the error code is set to U_STRING_NOT_TERMINATED_WARNING.
1468    * If the string itself does not fit into dest
1469    * (length()&gt;destCapacity) then the error code is set to U_BUFFER_OVERFLOW_ERROR.
1470    *
<span class="line-modified">1471    * If the string aliases to `dest` itself as an external buffer,</span>
1472    * then extract() will not copy the contents.
1473    *
1474    * @param dest Destination string buffer.
1475    * @param destCapacity Number of char16_ts available at dest.
1476    * @param errorCode ICU error code.
1477    * @return length()
1478    * @stable ICU 2.0
1479    */
1480   int32_t
1481   extract(Char16Ptr dest, int32_t destCapacity,
1482           UErrorCode &amp;errorCode) const;
1483 
1484   /**
1485    * Copy the characters in the range
<span class="line-modified">1486    * [`start`, `start + length`) into the  UnicodeString</span>
<span class="line-modified">1487    * `target`.</span>
1488    * @param start offset of first character which will be copied
1489    * @param length the number of characters to extract
1490    * @param target UnicodeString into which to copy characters.

1491    * @stable ICU 2.0
1492    */
1493   inline void extract(int32_t start,
1494            int32_t length,
1495            UnicodeString&amp; target) const;
1496 
1497   /**
<span class="line-modified">1498    * Copy the characters in the range [`start`, `limit`)</span>
<span class="line-modified">1499    * into the array `dst`, beginning at `dstStart`.</span>
1500    * @param start offset of first character which will be copied into the array
1501    * @param limit offset immediately following the last character to be copied
<span class="line-modified">1502    * @param dst array in which to copy characters.  The length of `dst`</span>
<span class="line-modified">1503    * must be at least (`dstStart + (limit - start)`).</span>
<span class="line-modified">1504    * @param dstStart the offset in `dst` where the first character</span>
1505    * will be extracted
1506    * @stable ICU 2.0
1507    */
1508   inline void extractBetween(int32_t start,
1509               int32_t limit,
1510               char16_t *dst,
1511               int32_t dstStart = 0) const;
1512 
1513   /**
<span class="line-modified">1514    * Copy the characters in the range [`start`, `limit`)</span>
<span class="line-modified">1515    * into the UnicodeString `target`.  Replaceable API.</span>
1516    * @param start offset of first character which will be copied
1517    * @param limit offset immediately following the last character to be copied
1518    * @param target UnicodeString into which to copy characters.

1519    * @stable ICU 2.0
1520    */
1521   virtual void extractBetween(int32_t start,
1522               int32_t limit,
1523               UnicodeString&amp; target) const;
1524 
1525   /**
1526    * Copy the characters in the range
<span class="line-modified">1527    * [`start`, `start + startLength`) into an array of characters.</span>
1528    * All characters must be invariant (see utypes.h).
1529    * Use US_INV as the last, signature-distinguishing parameter.
1530    *
<span class="line-modified">1531    * This function does not write any more than `targetCapacity`</span>
1532    * characters but returns the length of the entire output string
1533    * so that one can allocate a larger buffer and call the function again
1534    * if necessary.
1535    * The output string is NUL-terminated if possible.
1536    *
1537    * @param start offset of first character which will be copied
1538    * @param startLength the number of characters to extract
1539    * @param target the target buffer for extraction, can be NULL
1540    *               if targetLength is 0
1541    * @param targetCapacity the length of the target buffer
1542    * @param inv Signature-distinguishing paramater, use US_INV.
1543    * @return the output string length, not including the terminating NUL
1544    * @stable ICU 3.2
1545    */
1546   int32_t extract(int32_t start,
1547            int32_t startLength,
1548            char *target,
1549            int32_t targetCapacity,
1550            enum EInvariant inv) const;
1551 
1552 #if U_CHARSET_IS_UTF8 || !UCONFIG_NO_CONVERSION
1553 
1554   /**
1555    * Copy the characters in the range
<span class="line-modified">1556    * [`start`, `start + length`) into an array of characters</span>
1557    * in the platform&#39;s default codepage.
<span class="line-modified">1558    * This function does not write any more than `targetLength`</span>
1559    * characters but returns the length of the entire output string
1560    * so that one can allocate a larger buffer and call the function again
1561    * if necessary.
1562    * The output string is NUL-terminated if possible.
1563    *
1564    * @param start offset of first character which will be copied
1565    * @param startLength the number of characters to extract
1566    * @param target the target buffer for extraction
1567    * @param targetLength the length of the target buffer
<span class="line-modified">1568    * If `target` is NULL, then the number of bytes required for</span>
<span class="line-modified">1569    * `target` is returned.</span>
1570    * @return the output string length, not including the terminating NUL
1571    * @stable ICU 2.0
1572    */
1573   int32_t extract(int32_t start,
1574            int32_t startLength,
1575            char *target,
1576            uint32_t targetLength) const;
1577 
1578 #endif
1579 
1580 #if !UCONFIG_NO_CONVERSION
1581 
1582   /**
1583    * Copy the characters in the range
<span class="line-modified">1584    * [`start`, `start + length`) into an array of characters</span>
1585    * in a specified codepage.
1586    * The output string is NUL-terminated.
1587    *
1588    * Recommendation: For invariant-character strings use
1589    * extract(int32_t start, int32_t length, char *target, int32_t targetCapacity, enum EInvariant inv) const
1590    * because it avoids object code dependencies of UnicodeString on
1591    * the conversion code.
1592    *
1593    * @param start offset of first character which will be copied
1594    * @param startLength the number of characters to extract
1595    * @param target the target buffer for extraction
1596    * @param codepage the desired codepage for the characters.  0 has
1597    * the special meaning of the default codepage
<span class="line-modified">1598    * If `codepage` is an empty string (`&quot;&quot;`),</span>
1599    * then a simple conversion is performed on the codepage-invariant
1600    * subset (&quot;invariant characters&quot;) of the platform encoding. See utypes.h.
<span class="line-modified">1601    * If `target` is NULL, then the number of bytes required for</span>
<span class="line-modified">1602    * `target` is returned. It is assumed that the target is big enough</span>
1603    * to fit all of the characters.
1604    * @return the output string length, not including the terminating NUL
1605    * @stable ICU 2.0
1606    */
1607   inline int32_t extract(int32_t start,
1608                  int32_t startLength,
1609                  char *target,
1610                  const char *codepage = 0) const;
1611 
1612   /**
1613    * Copy the characters in the range
<span class="line-modified">1614    * [`start`, `start + length`) into an array of characters</span>
1615    * in a specified codepage.
<span class="line-modified">1616    * This function does not write any more than `targetLength`</span>
1617    * characters but returns the length of the entire output string
1618    * so that one can allocate a larger buffer and call the function again
1619    * if necessary.
1620    * The output string is NUL-terminated if possible.
1621    *
1622    * Recommendation: For invariant-character strings use
1623    * extract(int32_t start, int32_t length, char *target, int32_t targetCapacity, enum EInvariant inv) const
1624    * because it avoids object code dependencies of UnicodeString on
1625    * the conversion code.
1626    *
1627    * @param start offset of first character which will be copied
1628    * @param startLength the number of characters to extract
1629    * @param target the target buffer for extraction
1630    * @param targetLength the length of the target buffer
1631    * @param codepage the desired codepage for the characters.  0 has
1632    * the special meaning of the default codepage
<span class="line-modified">1633    * If `codepage` is an empty string (`&quot;&quot;`),</span>
1634    * then a simple conversion is performed on the codepage-invariant
1635    * subset (&quot;invariant characters&quot;) of the platform encoding. See utypes.h.
<span class="line-modified">1636    * If `target` is NULL, then the number of bytes required for</span>
<span class="line-modified">1637    * `target` is returned.</span>
1638    * @return the output string length, not including the terminating NUL
1639    * @stable ICU 2.0
1640    */
1641   int32_t extract(int32_t start,
1642            int32_t startLength,
1643            char *target,
1644            uint32_t targetLength,
1645            const char *codepage) const;
1646 
1647   /**
1648    * Convert the UnicodeString into a codepage string using an existing UConverter.
1649    * The output string is NUL-terminated if possible.
1650    *
1651    * This function avoids the overhead of opening and closing a converter if
1652    * multiple strings are extracted.
1653    *
1654    * @param dest destination string buffer, can be NULL if destCapacity==0
1655    * @param destCapacity the number of chars available at dest
1656    * @param cnv the converter object to be used (ucnv_resetFromUnicode() will be called),
1657    *        or NULL for the default converter
</pre>
<hr />
<pre>
1830    * although in both cases isEmpty() returns TRUE and length() returns 0.
1831    * setToBogus() and isBogus() can be used to indicate that no string value is available.
1832    * For a bogus string, getBuffer() and getTerminatedBuffer() return NULL, and
1833    * length() returns 0.
1834    *
1835    * @return TRUE if the string is bogus/invalid, FALSE otherwise
1836    * @see setToBogus()
1837    * @stable ICU 2.0
1838    */
1839   inline UBool isBogus(void) const;
1840 
1841 
1842   //========================================
1843   // Write operations
1844   //========================================
1845 
1846   /* Assignment operations */
1847 
1848   /**
1849    * Assignment operator.  Replace the characters in this UnicodeString
<span class="line-modified">1850    * with the characters from `srcText`.</span>
1851    *
1852    * Starting with ICU 2.4, the assignment operator and the copy constructor
1853    * allocate a new buffer and copy the buffer contents even for readonly aliases.
1854    * By contrast, the fastCopyFrom() function implements the old,
1855    * more efficient but less safe behavior
1856    * of making this string also a readonly alias to the same buffer.
1857    *
1858    * If the source object has an &quot;open&quot; buffer from getBuffer(minCapacity),
1859    * then the copy is an empty string.
1860    *
1861    * @param srcText The text containing the characters to replace
1862    * @return a reference to this
1863    * @stable ICU 2.0
1864    * @see fastCopyFrom
1865    */
1866   UnicodeString &amp;operator=(const UnicodeString &amp;srcText);
1867 
1868   /**
1869    * Almost the same as the assignment operator.
1870    * Replace the characters in this UnicodeString
<span class="line-modified">1871    * with the characters from `srcText`.</span>
1872    *
1873    * This function works the same as the assignment operator
1874    * for all strings except for ones that are readonly aliases.
1875    *
1876    * Starting with ICU 2.4, the assignment operator and the copy constructor
1877    * allocate a new buffer and copy the buffer contents even for readonly aliases.
1878    * This function implements the old, more efficient but less safe behavior
1879    * of making this string also a readonly alias to the same buffer.
1880    *
1881    * The fastCopyFrom function must be used only if it is known that the lifetime of
1882    * this UnicodeString does not exceed the lifetime of the aliased buffer
1883    * including its contents, for example for strings from resource bundles
1884    * or aliases to string constants.
1885    *
1886    * If the source object has an &quot;open&quot; buffer from getBuffer(minCapacity),
1887    * then the copy is an empty string.
1888    *
1889    * @param src The text containing the characters to replace.
1890    * @return a reference to this
1891    * @stable ICU 2.4
1892    */
1893   UnicodeString &amp;fastCopyFrom(const UnicodeString &amp;src);
1894 
1895   /**
1896    * Move assignment operator; might leave src in bogus state.
1897    * This string will have the same contents and state that the source string had.
1898    * The behavior is undefined if *this and src are the same object.
1899    * @param src source string
1900    * @return *this
1901    * @stable ICU 56
1902    */
<span class="line-modified">1903   UnicodeString &amp;operator=(UnicodeString &amp;&amp;src) U_NOEXCEPT;</span>















1904 
1905   /**
1906    * Swap strings.
1907    * @param other other string
1908    * @stable ICU 56
1909    */
1910   void swap(UnicodeString &amp;other) U_NOEXCEPT;
1911 
1912   /**
1913    * Non-member UnicodeString swap function.
1914    * @param s1 will get s2&#39;s contents and state
1915    * @param s2 will get s1&#39;s contents and state
1916    * @stable ICU 56
1917    */
<span class="line-modified">1918   friend inline void U_EXPORT2</span>
1919   swap(UnicodeString &amp;s1, UnicodeString &amp;s2) U_NOEXCEPT {
1920     s1.swap(s2);
1921   }
1922 
1923   /**
1924    * Assignment operator.  Replace the characters in this UnicodeString
<span class="line-modified">1925    * with the code unit `ch`.</span>
1926    * @param ch the code unit to replace
1927    * @return a reference to this
1928    * @stable ICU 2.0
1929    */
1930   inline UnicodeString&amp; operator= (char16_t ch);
1931 
1932   /**
1933    * Assignment operator.  Replace the characters in this UnicodeString
<span class="line-modified">1934    * with the code point `ch`.</span>
1935    * @param ch the code point to replace
1936    * @return a reference to this
1937    * @stable ICU 2.0
1938    */
1939   inline UnicodeString&amp; operator= (UChar32 ch);
1940 
1941   /**
1942    * Set the text in the UnicodeString object to the characters
<span class="line-modified">1943    * in `srcText` in the range</span>
<span class="line-modified">1944    * [`srcStart`, `srcText.length()`).</span>
<span class="line-modified">1945    * `srcText` is not modified.</span>
1946    * @param srcText the source for the new characters
<span class="line-modified">1947    * @param srcStart the offset into `srcText` where new characters</span>
1948    * will be obtained
1949    * @return a reference to this
1950    * @stable ICU 2.2
1951    */
1952   inline UnicodeString&amp; setTo(const UnicodeString&amp; srcText,
1953                int32_t srcStart);
1954 
1955   /**
1956    * Set the text in the UnicodeString object to the characters
<span class="line-modified">1957    * in `srcText` in the range</span>
<span class="line-modified">1958    * [`srcStart`, `srcStart + srcLength`).</span>
<span class="line-modified">1959    * `srcText` is not modified.</span>
1960    * @param srcText the source for the new characters
<span class="line-modified">1961    * @param srcStart the offset into `srcText` where new characters</span>
1962    * will be obtained
<span class="line-modified">1963    * @param srcLength the number of characters in `srcText` in the</span>
1964    * replace string.
1965    * @return a reference to this
1966    * @stable ICU 2.0
1967    */
1968   inline UnicodeString&amp; setTo(const UnicodeString&amp; srcText,
1969                int32_t srcStart,
1970                int32_t srcLength);
1971 
1972   /**
1973    * Set the text in the UnicodeString object to the characters in
<span class="line-modified">1974    * `srcText`.</span>
<span class="line-modified">1975    * `srcText` is not modified.</span>
1976    * @param srcText the source for the new characters
1977    * @return a reference to this
1978    * @stable ICU 2.0
1979    */
1980   inline UnicodeString&amp; setTo(const UnicodeString&amp; srcText);
1981 
1982   /**
1983    * Set the characters in the UnicodeString object to the characters
<span class="line-modified">1984    * in `srcChars`. `srcChars` is not modified.</span>
1985    * @param srcChars the source for the new characters
1986    * @param srcLength the number of Unicode characters in srcChars.
1987    * @return a reference to this
1988    * @stable ICU 2.0
1989    */
1990   inline UnicodeString&amp; setTo(const char16_t *srcChars,
1991                int32_t srcLength);
1992 
1993   /**
1994    * Set the characters in the UnicodeString object to the code unit
<span class="line-modified">1995    * `srcChar`.</span>
1996    * @param srcChar the code unit which becomes the UnicodeString&#39;s character
1997    * content
1998    * @return a reference to this
1999    * @stable ICU 2.0
2000    */
<span class="line-modified">2001   inline UnicodeString&amp; setTo(char16_t srcChar);</span>
2002 
2003   /**
2004    * Set the characters in the UnicodeString object to the code point
<span class="line-modified">2005    * `srcChar`.</span>
2006    * @param srcChar the code point which becomes the UnicodeString&#39;s character
2007    * content
2008    * @return a reference to this
2009    * @stable ICU 2.0
2010    */
<span class="line-modified">2011   inline UnicodeString&amp; setTo(UChar32 srcChar);</span>
2012 
2013   /**
2014    * Aliasing setTo() function, analogous to the readonly-aliasing char16_t* constructor.
2015    * The text will be used for the UnicodeString object, but
2016    * it will not be released when the UnicodeString is destroyed.
2017    * This has copy-on-write semantics:
2018    * When the string is modified, then the buffer is first copied into
2019    * newly allocated memory.
2020    * The aliased buffer is never modified.
2021    *
2022    * In an assignment to another UnicodeString, when using the copy constructor
2023    * or the assignment operator, the text will be copied.
2024    * When using fastCopyFrom(), the text will be aliased again,
2025    * so that both strings then alias the same readonly-text.
2026    *
<span class="line-modified">2027    * @param isTerminated specifies if `text` is `NUL`-terminated.</span>
<span class="line-modified">2028    *                     This must be true if `textLength==-1`.</span>
2029    * @param text The characters to alias for the UnicodeString.
<span class="line-modified">2030    * @param textLength The number of Unicode characters in `text` to alias.</span>
2031    *                   If -1, then this constructor will determine the length
<span class="line-modified">2032    *                   by calling `u_strlen()`.</span>
2033    * @return a reference to this
2034    * @stable ICU 2.0
2035    */
2036   UnicodeString &amp;setTo(UBool isTerminated,
2037                        ConstChar16Ptr text,
2038                        int32_t textLength);
2039 
2040   /**
2041    * Aliasing setTo() function, analogous to the writable-aliasing char16_t* constructor.
2042    * The text will be used for the UnicodeString object, but
2043    * it will not be released when the UnicodeString is destroyed.
2044    * This has write-through semantics:
2045    * For as long as the capacity of the buffer is sufficient, write operations
2046    * will directly affect the buffer. When more capacity is necessary, then
2047    * a new buffer will be allocated and the contents copied as with regularly
2048    * constructed strings.
2049    * In an assignment to another UnicodeString, the buffer will be copied.
2050    * The extract(Char16Ptr dst) function detects whether the dst pointer is the same
2051    * as the string buffer itself and will in this case not copy the contents.
2052    *
2053    * @param buffer The characters to alias for the UnicodeString.
<span class="line-modified">2054    * @param buffLength The number of Unicode characters in `buffer` to alias.</span>
<span class="line-modified">2055    * @param buffCapacity The size of `buffer` in char16_ts.</span>
2056    * @return a reference to this
2057    * @stable ICU 2.0
2058    */
2059   UnicodeString &amp;setTo(char16_t *buffer,
2060                        int32_t buffLength,
2061                        int32_t buffCapacity);
2062 
2063   /**
2064    * Make this UnicodeString object invalid.
2065    * The string will test TRUE with isBogus().
2066    *
2067    * A bogus string has no value. It is different from an empty string.
2068    * It can be used to indicate that no string value is available.
2069    * getBuffer() and getTerminatedBuffer() return NULL, and
2070    * length() returns 0.
2071    *
2072    * This utility function is used throughout the UnicodeString
2073    * implementation to indicate that a UnicodeString operation failed,
2074    * and may be used in other functions,
2075    * especially but not exclusively when such functions do not
</pre>
<hr />
<pre>
2099    *
2100    * @see isBogus()
2101    * @stable ICU 2.0
2102    */
2103   void setToBogus();
2104 
2105   /**
2106    * Set the character at the specified offset to the specified character.
2107    * @param offset A valid offset into the text of the character to set
2108    * @param ch The new character
2109    * @return A reference to this
2110    * @stable ICU 2.0
2111    */
2112   UnicodeString&amp; setCharAt(int32_t offset,
2113                char16_t ch);
2114 
2115 
2116   /* Append operations */
2117 
2118   /**
<span class="line-modified">2119    * Append operator. Append the code unit `ch` to the UnicodeString</span>
2120    * object.
2121    * @param ch the code unit to be appended
2122    * @return a reference to this
2123    * @stable ICU 2.0
2124    */
2125  inline  UnicodeString&amp; operator+= (char16_t ch);
2126 
2127   /**
<span class="line-modified">2128    * Append operator. Append the code point `ch` to the UnicodeString</span>
2129    * object.
2130    * @param ch the code point to be appended
2131    * @return a reference to this
2132    * @stable ICU 2.0
2133    */
2134  inline  UnicodeString&amp; operator+= (UChar32 ch);
2135 
2136   /**
<span class="line-modified">2137    * Append operator. Append the characters in `srcText` to the</span>
<span class="line-modified">2138    * UnicodeString object. `srcText` is not modified.</span>
2139    * @param srcText the source for the new characters
2140    * @return a reference to this
2141    * @stable ICU 2.0
2142    */
2143   inline UnicodeString&amp; operator+= (const UnicodeString&amp; srcText);
2144 
2145   /**
2146    * Append the characters
<span class="line-modified">2147    * in `srcText` in the range</span>
<span class="line-modified">2148    * [`srcStart`, `srcStart + srcLength`) to the</span>
<span class="line-modified">2149    * UnicodeString object at offset `start`. `srcText`</span>
2150    * is not modified.
2151    * @param srcText the source for the new characters
<span class="line-modified">2152    * @param srcStart the offset into `srcText` where new characters</span>
2153    * will be obtained
<span class="line-modified">2154    * @param srcLength the number of characters in `srcText` in</span>
2155    * the append string
2156    * @return a reference to this
2157    * @stable ICU 2.0
2158    */
2159   inline UnicodeString&amp; append(const UnicodeString&amp; srcText,
2160             int32_t srcStart,
2161             int32_t srcLength);
2162 
2163   /**
<span class="line-modified">2164    * Append the characters in `srcText` to the UnicodeString object.</span>
<span class="line-modified">2165    * `srcText` is not modified.</span>
2166    * @param srcText the source for the new characters
2167    * @return a reference to this
2168    * @stable ICU 2.0
2169    */
2170   inline UnicodeString&amp; append(const UnicodeString&amp; srcText);
2171 
2172   /**
<span class="line-modified">2173    * Append the characters in `srcChars` in the range</span>
<span class="line-modified">2174    * [`srcStart`, `srcStart + srcLength`) to the UnicodeString</span>
2175    * object at offset
<span class="line-modified">2176    * `start`. `srcChars` is not modified.</span>
2177    * @param srcChars the source for the new characters
<span class="line-modified">2178    * @param srcStart the offset into `srcChars` where new characters</span>
2179    * will be obtained
<span class="line-modified">2180    * @param srcLength the number of characters in `srcChars` in</span>
<span class="line-modified">2181    *                  the append string; can be -1 if `srcChars` is NUL-terminated</span>
2182    * @return a reference to this
2183    * @stable ICU 2.0
2184    */
2185   inline UnicodeString&amp; append(const char16_t *srcChars,
2186             int32_t srcStart,
2187             int32_t srcLength);
2188 
2189   /**
<span class="line-modified">2190    * Append the characters in `srcChars` to the UnicodeString object</span>
<span class="line-modified">2191    * at offset `start`. `srcChars` is not modified.</span>
2192    * @param srcChars the source for the new characters
<span class="line-modified">2193    * @param srcLength the number of Unicode characters in `srcChars`;</span>
<span class="line-modified">2194    *                  can be -1 if `srcChars` is NUL-terminated</span>
2195    * @return a reference to this
2196    * @stable ICU 2.0
2197    */
2198   inline UnicodeString&amp; append(ConstChar16Ptr srcChars,
2199             int32_t srcLength);
2200 
2201   /**
<span class="line-modified">2202    * Append the code unit `srcChar` to the UnicodeString object.</span>
2203    * @param srcChar the code unit to append
2204    * @return a reference to this
2205    * @stable ICU 2.0
2206    */
2207   inline UnicodeString&amp; append(char16_t srcChar);
2208 
2209   /**
<span class="line-modified">2210    * Append the code point `srcChar` to the UnicodeString object.</span>
2211    * @param srcChar the code point to append
2212    * @return a reference to this
2213    * @stable ICU 2.0
2214    */
2215   UnicodeString&amp; append(UChar32 srcChar);
2216 
2217 
2218   /* Insert operations */
2219 
2220   /**
<span class="line-modified">2221    * Insert the characters in `srcText` in the range</span>
<span class="line-modified">2222    * [`srcStart`, `srcStart + srcLength`) into the UnicodeString</span>
<span class="line-modified">2223    * object at offset `start`. `srcText` is not modified.</span>
2224    * @param start the offset where the insertion begins
2225    * @param srcText the source for the new characters
<span class="line-modified">2226    * @param srcStart the offset into `srcText` where new characters</span>
2227    * will be obtained
<span class="line-modified">2228    * @param srcLength the number of characters in `srcText` in</span>
2229    * the insert string
2230    * @return a reference to this
2231    * @stable ICU 2.0
2232    */
2233   inline UnicodeString&amp; insert(int32_t start,
2234             const UnicodeString&amp; srcText,
2235             int32_t srcStart,
2236             int32_t srcLength);
2237 
2238   /**
<span class="line-modified">2239    * Insert the characters in `srcText` into the UnicodeString object</span>
<span class="line-modified">2240    * at offset `start`. `srcText` is not modified.</span>
2241    * @param start the offset where the insertion begins
2242    * @param srcText the source for the new characters
2243    * @return a reference to this
2244    * @stable ICU 2.0
2245    */
2246   inline UnicodeString&amp; insert(int32_t start,
2247             const UnicodeString&amp; srcText);
2248 
2249   /**
<span class="line-modified">2250    * Insert the characters in `srcChars` in the range</span>
<span class="line-modified">2251    * [`srcStart`, `srcStart + srcLength`) into the UnicodeString</span>
<span class="line-modified">2252    *  object at offset `start`. `srcChars` is not modified.</span>
2253    * @param start the offset at which the insertion begins
2254    * @param srcChars the source for the new characters
<span class="line-modified">2255    * @param srcStart the offset into `srcChars` where new characters</span>
2256    * will be obtained
<span class="line-modified">2257    * @param srcLength the number of characters in `srcChars`</span>
2258    * in the insert string
2259    * @return a reference to this
2260    * @stable ICU 2.0
2261    */
2262   inline UnicodeString&amp; insert(int32_t start,
2263             const char16_t *srcChars,
2264             int32_t srcStart,
2265             int32_t srcLength);
2266 
2267   /**
<span class="line-modified">2268    * Insert the characters in `srcChars` into the UnicodeString object</span>
<span class="line-modified">2269    * at offset `start`. `srcChars` is not modified.</span>
2270    * @param start the offset where the insertion begins
2271    * @param srcChars the source for the new characters
2272    * @param srcLength the number of Unicode characters in srcChars.
2273    * @return a reference to this
2274    * @stable ICU 2.0
2275    */
2276   inline UnicodeString&amp; insert(int32_t start,
2277             ConstChar16Ptr srcChars,
2278             int32_t srcLength);
2279 
2280   /**
<span class="line-modified">2281    * Insert the code unit `srcChar` into the UnicodeString object at</span>
<span class="line-modified">2282    * offset `start`.</span>
2283    * @param start the offset at which the insertion occurs
2284    * @param srcChar the code unit to insert
2285    * @return a reference to this
2286    * @stable ICU 2.0
2287    */
2288   inline UnicodeString&amp; insert(int32_t start,
2289             char16_t srcChar);
2290 
2291   /**
<span class="line-modified">2292    * Insert the code point `srcChar` into the UnicodeString object at</span>
<span class="line-modified">2293    * offset `start`.</span>
2294    * @param start the offset at which the insertion occurs
2295    * @param srcChar the code point to insert
2296    * @return a reference to this
2297    * @stable ICU 2.0
2298    */
2299   inline UnicodeString&amp; insert(int32_t start,
2300             UChar32 srcChar);
2301 
2302 
2303   /* Replace operations */
2304 
2305   /**
2306    * Replace the characters in the range
<span class="line-modified">2307    * [`start`, `start + length`) with the characters in</span>
<span class="line-modified">2308    * `srcText` in the range</span>
<span class="line-modified">2309    * [`srcStart`, `srcStart + srcLength`).</span>
<span class="line-modified">2310    * `srcText` is not modified.</span>
2311    * @param start the offset at which the replace operation begins
2312    * @param length the number of characters to replace. The character at
<span class="line-modified">2313    * `start + length` is not modified.</span>
2314    * @param srcText the source for the new characters
<span class="line-modified">2315    * @param srcStart the offset into `srcText` where new characters</span>
2316    * will be obtained
<span class="line-modified">2317    * @param srcLength the number of characters in `srcText` in</span>
2318    * the replace string
2319    * @return a reference to this
2320    * @stable ICU 2.0
2321    */
<span class="line-modified">2322   inline UnicodeString&amp; replace(int32_t start,</span>
2323              int32_t length,
2324              const UnicodeString&amp; srcText,
2325              int32_t srcStart,
2326              int32_t srcLength);
2327 
2328   /**
2329    * Replace the characters in the range
<span class="line-modified">2330    * [`start`, `start + length`)</span>
<span class="line-modified">2331    * with the characters in `srcText`.  `srcText` is</span>
2332    *  not modified.
2333    * @param start the offset at which the replace operation begins
2334    * @param length the number of characters to replace. The character at
<span class="line-modified">2335    * `start + length` is not modified.</span>
2336    * @param srcText the source for the new characters
2337    * @return a reference to this
2338    * @stable ICU 2.0
2339    */
<span class="line-modified">2340   inline UnicodeString&amp; replace(int32_t start,</span>
2341              int32_t length,
2342              const UnicodeString&amp; srcText);
2343 
2344   /**
2345    * Replace the characters in the range
<span class="line-modified">2346    * [`start`, `start + length`) with the characters in</span>
<span class="line-modified">2347    * `srcChars` in the range</span>
<span class="line-modified">2348    * [`srcStart`, `srcStart + srcLength`). `srcChars`</span>
2349    * is not modified.
2350    * @param start the offset at which the replace operation begins
2351    * @param length the number of characters to replace.  The character at
<span class="line-modified">2352    * `start + length` is not modified.</span>
2353    * @param srcChars the source for the new characters
<span class="line-modified">2354    * @param srcStart the offset into `srcChars` where new characters</span>
2355    * will be obtained
<span class="line-modified">2356    * @param srcLength the number of characters in `srcChars`</span>
2357    * in the replace string
2358    * @return a reference to this
2359    * @stable ICU 2.0
2360    */
<span class="line-modified">2361   inline UnicodeString&amp; replace(int32_t start,</span>
2362              int32_t length,
2363              const char16_t *srcChars,
2364              int32_t srcStart,
2365              int32_t srcLength);
2366 
2367   /**
2368    * Replace the characters in the range
<span class="line-modified">2369    * [`start`, `start + length`) with the characters in</span>
<span class="line-modified">2370    * `srcChars`.  `srcChars` is not modified.</span>
2371    * @param start the offset at which the replace operation begins
2372    * @param length number of characters to replace.  The character at
<span class="line-modified">2373    * `start + length` is not modified.</span>
2374    * @param srcChars the source for the new characters
2375    * @param srcLength the number of Unicode characters in srcChars
2376    * @return a reference to this
2377    * @stable ICU 2.0
2378    */
2379   inline UnicodeString&amp; replace(int32_t start,
2380              int32_t length,
2381              ConstChar16Ptr srcChars,
2382              int32_t srcLength);
2383 
2384   /**
2385    * Replace the characters in the range
<span class="line-modified">2386    * [`start`, `start + length`) with the code unit</span>
<span class="line-modified">2387    * `srcChar`.</span>
2388    * @param start the offset at which the replace operation begins
2389    * @param length the number of characters to replace.  The character at
<span class="line-modified">2390    * `start + length` is not modified.</span>
2391    * @param srcChar the new code unit
2392    * @return a reference to this
2393    * @stable ICU 2.0
2394    */
2395   inline UnicodeString&amp; replace(int32_t start,
2396              int32_t length,
2397              char16_t srcChar);
2398 
2399   /**
2400    * Replace the characters in the range
<span class="line-modified">2401    * [`start`, `start + length`) with the code point</span>
<span class="line-modified">2402    * `srcChar`.</span>
2403    * @param start the offset at which the replace operation begins
2404    * @param length the number of characters to replace.  The character at
<span class="line-modified">2405    * `start + length` is not modified.</span>
2406    * @param srcChar the new code point
2407    * @return a reference to this
2408    * @stable ICU 2.0
2409    */
2410   UnicodeString&amp; replace(int32_t start, int32_t length, UChar32 srcChar);
2411 
2412   /**
<span class="line-modified">2413    * Replace the characters in the range [`start`, `limit`)</span>
<span class="line-modified">2414    * with the characters in `srcText`. `srcText` is not modified.</span>
2415    * @param start the offset at which the replace operation begins
2416    * @param limit the offset immediately following the replace range
2417    * @param srcText the source for the new characters
2418    * @return a reference to this
2419    * @stable ICU 2.0
2420    */
2421   inline UnicodeString&amp; replaceBetween(int32_t start,
2422                 int32_t limit,
2423                 const UnicodeString&amp; srcText);
2424 
2425   /**
<span class="line-modified">2426    * Replace the characters in the range [`start`, `limit`)</span>
<span class="line-modified">2427    * with the characters in `srcText` in the range</span>
<span class="line-modified">2428    * [`srcStart`, `srcLimit`). `srcText` is not modified.</span>
2429    * @param start the offset at which the replace operation begins
2430    * @param limit the offset immediately following the replace range
2431    * @param srcText the source for the new characters
<span class="line-modified">2432    * @param srcStart the offset into `srcChars` where new characters</span>
2433    * will be obtained
2434    * @param srcLimit the offset immediately following the range to copy
<span class="line-modified">2435    * in `srcText`</span>
2436    * @return a reference to this
2437    * @stable ICU 2.0
2438    */
2439   inline UnicodeString&amp; replaceBetween(int32_t start,
2440                 int32_t limit,
2441                 const UnicodeString&amp; srcText,
2442                 int32_t srcStart,
2443                 int32_t srcLimit);
2444 
2445   /**
2446    * Replace a substring of this object with the given text.
<span class="line-modified">2447    * @param start the beginning index, inclusive; `0 &lt;= start &lt;= limit`.</span>
<span class="line-modified">2448    * @param limit the ending index, exclusive; `start &lt;= limit &lt;= length()`.</span>
<span class="line-modified">2449    * @param text the text to replace characters `start` to `limit - 1`</span>



2450    * @stable ICU 2.0
2451    */
2452   virtual void handleReplaceBetween(int32_t start,
2453                                     int32_t limit,
2454                                     const UnicodeString&amp; text);
2455 
2456   /**
2457    * Replaceable API
2458    * @return TRUE if it has MetaData
2459    * @stable ICU 2.4
2460    */
2461   virtual UBool hasMetaData() const;
2462 
2463   /**
2464    * Copy a substring of this object, retaining attribute (out-of-band)
2465    * information.  This method is used to duplicate or reorder substrings.
2466    * The destination index must not overlap the source range.
2467    *
<span class="line-modified">2468    * @param start the beginning index, inclusive; `0 &lt;= start &lt;= limit`.</span>
<span class="line-modified">2469    * @param limit the ending index, exclusive; `start &lt;= limit &lt;= length()`.</span>


2470    * @param dest the destination index.  The characters from
<span class="line-modified">2471    *             `start..limit-1` will be copied to `dest`.</span>
<span class="line-modified">2472    * Implementations of this method may assume that `dest &lt;= start ||</span>
<span class="line-modified">2473    * dest &gt;= limit`.</span>
2474    * @stable ICU 2.0
2475    */
2476   virtual void copy(int32_t start, int32_t limit, int32_t dest);
2477 
2478   /* Search and replace operations */
2479 
2480   /**
2481    * Replace all occurrences of characters in oldText with the characters
2482    * in newText
2483    * @param oldText the text containing the search text
2484    * @param newText the text containing the replacement text
2485    * @return a reference to this
2486    * @stable ICU 2.0
2487    */
2488   inline UnicodeString&amp; findAndReplace(const UnicodeString&amp; oldText,
2489                 const UnicodeString&amp; newText);
2490 
2491   /**
2492    * Replace all occurrences of characters in oldText with characters
2493    * in newText
<span class="line-modified">2494    * in the range [`start`, `start + length`).</span>
2495    * @param start the start of the range in which replace will performed
2496    * @param length the length of the range in which replace will be performed
2497    * @param oldText the text containing the search text
2498    * @param newText the text containing the replacement text
2499    * @return a reference to this
2500    * @stable ICU 2.0
2501    */
2502   inline UnicodeString&amp; findAndReplace(int32_t start,
2503                 int32_t length,
2504                 const UnicodeString&amp; oldText,
2505                 const UnicodeString&amp; newText);
2506 
2507   /**
2508    * Replace all occurrences of characters in oldText in the range
<span class="line-modified">2509    * [`oldStart`, `oldStart + oldLength`) with the characters</span>
2510    * in newText in the range
<span class="line-modified">2511    * [`newStart`, `newStart + newLength`)</span>
<span class="line-modified">2512    * in the range [`start`, `start + length`).</span>
2513    * @param start the start of the range in which replace will performed
2514    * @param length the length of the range in which replace will be performed
2515    * @param oldText the text containing the search text
<span class="line-modified">2516    * @param oldStart the start of the search range in `oldText`</span>
<span class="line-modified">2517    * @param oldLength the length of the search range in `oldText`</span>
2518    * @param newText the text containing the replacement text
<span class="line-modified">2519    * @param newStart the start of the replacement range in `newText`</span>
<span class="line-modified">2520    * @param newLength the length of the replacement range in `newText`</span>
2521    * @return a reference to this
2522    * @stable ICU 2.0
2523    */
2524   UnicodeString&amp; findAndReplace(int32_t start,
2525                 int32_t length,
2526                 const UnicodeString&amp; oldText,
2527                 int32_t oldStart,
2528                 int32_t oldLength,
2529                 const UnicodeString&amp; newText,
2530                 int32_t newStart,
2531                 int32_t newLength);
2532 
2533 
2534   /* Remove operations */
2535 
2536   /**
2537    * Remove all characters from the UnicodeString object.
2538    * @return a reference to this
2539    * @stable ICU 2.0
2540    */
2541   inline UnicodeString&amp; remove(void);
2542 
2543   /**
2544    * Remove the characters in the range
<span class="line-modified">2545    * [`start`, `start + length`) from the UnicodeString object.</span>
2546    * @param start the offset of the first character to remove
2547    * @param length the number of characters to remove
2548    * @return a reference to this
2549    * @stable ICU 2.0
2550    */
2551   inline UnicodeString&amp; remove(int32_t start,
2552                                int32_t length = (int32_t)INT32_MAX);
2553 
2554   /**
2555    * Remove the characters in the range
<span class="line-modified">2556    * [`start`, `limit`) from the UnicodeString object.</span>
2557    * @param start the offset of the first character to remove
2558    * @param limit the offset immediately following the range to remove
2559    * @return a reference to this
2560    * @stable ICU 2.0
2561    */
2562   inline UnicodeString&amp; removeBetween(int32_t start,
2563                                       int32_t limit = (int32_t)INT32_MAX);
2564 
2565   /**
2566    * Retain only the characters in the range
<span class="line-modified">2567    * [`start`, `limit`) from the UnicodeString object.</span>
<span class="line-modified">2568    * Removes characters before `start` and at and after `limit`.</span>
2569    * @param start the offset of the first character to retain
2570    * @param limit the offset immediately following the range to retain
2571    * @return a reference to this
2572    * @stable ICU 4.4
2573    */
2574   inline UnicodeString &amp;retainBetween(int32_t start, int32_t limit = INT32_MAX);
2575 
2576   /* Length operations */
2577 
2578   /**
<span class="line-modified">2579    * Pad the start of this UnicodeString with the character `padChar`.</span>
2580    * If the length of this UnicodeString is less than targetLength,
2581    * length() - targetLength copies of padChar will be added to the
2582    * beginning of this UnicodeString.
2583    * @param targetLength the desired length of the string
2584    * @param padChar the character to use for padding. Defaults to
2585    * space (U+0020)
2586    * @return TRUE if the text was padded, FALSE otherwise.
2587    * @stable ICU 2.0
2588    */
2589   UBool padLeading(int32_t targetLength,
2590                     char16_t padChar = 0x0020);
2591 
2592   /**
<span class="line-modified">2593    * Pad the end of this UnicodeString with the character `padChar`.</span>
2594    * If the length of this UnicodeString is less than targetLength,
2595    * length() - targetLength copies of padChar will be added to the
2596    * end of this UnicodeString.
2597    * @param targetLength the desired length of the string
2598    * @param padChar the character to use for padding. Defaults to
2599    * space (U+0020)
2600    * @return TRUE if the text was padded, FALSE otherwise.
2601    * @stable ICU 2.0
2602    */
2603   UBool padTrailing(int32_t targetLength,
2604                      char16_t padChar = 0x0020);
2605 
2606   /**
<span class="line-modified">2607    * Truncate this UnicodeString to the `targetLength`.</span>
2608    * @param targetLength the desired length of this UnicodeString.
2609    * @return TRUE if the text was truncated, FALSE otherwise
2610    * @stable ICU 2.0
2611    */
2612   inline UBool truncate(int32_t targetLength);
2613 
2614   /**
2615    * Trims leading and trailing whitespace from this UnicodeString.
2616    * @return a reference to this
2617    * @stable ICU 2.0
2618    */
2619   UnicodeString&amp; trim(void);
2620 
2621 
2622   /* Miscellaneous operations */
2623 
2624   /**
2625    * Reverse this UnicodeString in place.
2626    * @return a reference to this
2627    * @stable ICU 2.0
2628    */
2629   inline UnicodeString&amp; reverse(void);
2630 
2631   /**
<span class="line-modified">2632    * Reverse the range [`start`, `start + length`) in</span>
2633    * this UnicodeString.
2634    * @param start the start of the range to reverse
2635    * @param length the number of characters to to reverse
2636    * @return a reference to this
2637    * @stable ICU 2.0
2638    */
2639   inline UnicodeString&amp; reverse(int32_t start,
2640              int32_t length);
2641 
2642   /**
2643    * Convert the characters in this to UPPER CASE following the conventions of
2644    * the default locale.
2645    * @return A reference to this.
2646    * @stable ICU 2.0
2647    */
2648   UnicodeString&amp; toUpper(void);
2649 
2650   /**
2651    * Convert the characters in this to UPPER CASE following the conventions of
2652    * a specific locale.
</pre>
<hr />
<pre>
2797    *
2798    * An attempted nested call will return 0, and will not further modify the
2799    * state of the UnicodeString object.
2800    * It also returns 0 if the string is bogus.
2801    *
2802    * The actual capacity of the string buffer may be larger than minCapacity.
2803    * getCapacity() returns the actual capacity.
2804    * For many operations, the full capacity should be used to avoid reallocations.
2805    *
2806    * While the buffer is &quot;open&quot; between getBuffer(minCapacity)
2807    * and releaseBuffer(newLength), the following applies:
2808    * - The string length is set to 0.
2809    * - Any read API call on the UnicodeString object will behave like on a 0-length string.
2810    * - Any write API call on the UnicodeString object is disallowed and will have no effect.
2811    * - You can read from and write to the returned buffer.
2812    * - The previous string contents will still be in the buffer;
2813    *   if you want to use it, then you need to call length() before getBuffer(minCapacity).
2814    *   If the length() was greater than minCapacity, then any contents after minCapacity
2815    *   may be lost.
2816    *   The buffer contents is not NUL-terminated by getBuffer().
<span class="line-modified">2817    *   If length() &lt; getCapacity() then you can terminate it by writing a NUL</span>
2818    *   at index length().
2819    * - You must call releaseBuffer(newLength) before and in order to
2820    *   return to normal UnicodeString operation.
2821    *
2822    * @param minCapacity the minimum number of char16_ts that are to be available
2823    *        in the buffer, starting at the returned pointer;
2824    *        default to the current string capacity if minCapacity==-1
2825    * @return a writable pointer to the internal string buffer,
2826    *         or nullptr if an error occurs (nested calls, out of memory)
2827    *
2828    * @see releaseBuffer
2829    * @see getTerminatedBuffer()
2830    * @stable ICU 2.0
2831    */
2832   char16_t *getBuffer(int32_t minCapacity);
2833 
2834   /**
2835    * Release a read/write buffer on a UnicodeString object with an
2836    * &quot;open&quot; getBuffer(minCapacity).
2837    * This function must be called in a matched pair with getBuffer(minCapacity).
</pre>
<hr />
<pre>
2853    */
2854   void releaseBuffer(int32_t newLength=-1);
2855 
2856   /**
2857    * Get a read-only pointer to the internal buffer.
2858    * This can be called at any time on a valid UnicodeString.
2859    *
2860    * It returns 0 if the string is bogus, or
2861    * during an &quot;open&quot; getBuffer(minCapacity).
2862    *
2863    * It can be called as many times as desired.
2864    * The pointer that it returns will remain valid until the UnicodeString object is modified,
2865    * at which time the pointer is semantically invalidated and must not be used any more.
2866    *
2867    * The capacity of the buffer can be determined with getCapacity().
2868    * The part after length() may or may not be initialized and valid,
2869    * depending on the history of the UnicodeString object.
2870    *
2871    * The buffer contents is (probably) not NUL-terminated.
2872    * You can check if it is with
<span class="line-modified">2873    * `(s.length() &lt; s.getCapacity() &amp;&amp; buffer[s.length()]==0)`.</span>
2874    * (See getTerminatedBuffer().)
2875    *
2876    * The buffer may reside in read-only memory. Its contents must not
2877    * be modified.
2878    *
2879    * @return a read-only pointer to the internal string buffer,
2880    *         or nullptr if the string is empty or bogus
2881    *
2882    * @see getBuffer(int32_t minCapacity)
2883    * @see getTerminatedBuffer()
2884    * @stable ICU 2.0
2885    */
2886   inline const char16_t *getBuffer() const;
2887 
2888   /**
2889    * Get a read-only pointer to the internal buffer,
2890    * making sure that it is NUL-terminated.
2891    * This can be called at any time on a valid UnicodeString.
2892    *
2893    * It returns 0 if the string is bogus, or
</pre>
<hr />
<pre>
2913    *
2914    * @return a read-only pointer to the internal string buffer,
2915    *         or 0 if the string is empty or bogus
2916    *
2917    * @see getBuffer(int32_t minCapacity)
2918    * @see getBuffer()
2919    * @stable ICU 2.2
2920    */
2921   const char16_t *getTerminatedBuffer();
2922 
2923   //========================================
2924   // Constructors
2925   //========================================
2926 
2927   /** Construct an empty UnicodeString.
2928    * @stable ICU 2.0
2929    */
2930   inline UnicodeString();
2931 
2932   /**
<span class="line-modified">2933    * Construct a UnicodeString with capacity to hold `capacity` char16_ts</span>
2934    * @param capacity the number of char16_ts this UnicodeString should hold
2935    * before a resize is necessary; if count is greater than 0 and count
2936    * code points c take up more space than capacity, then capacity is adjusted
2937    * accordingly.
2938    * @param c is used to initially fill the string
2939    * @param count specifies how many code points c are to be written in the
2940    *              string
2941    * @stable ICU 2.0
2942    */
2943   UnicodeString(int32_t capacity, UChar32 c, int32_t count);
2944 
2945   /**
2946    * Single char16_t (code unit) constructor.
2947    *
2948    * It is recommended to mark this constructor &quot;explicit&quot; by
<span class="line-modified">2949    * `-DUNISTR_FROM_CHAR_EXPLICIT=explicit`</span>
2950    * on the compiler command line or similar.
2951    * @param ch the character to place in the UnicodeString
2952    * @stable ICU 2.0
2953    */
2954   UNISTR_FROM_CHAR_EXPLICIT UnicodeString(char16_t ch);
2955 
2956   /**
2957    * Single UChar32 (code point) constructor.
2958    *
2959    * It is recommended to mark this constructor &quot;explicit&quot; by
<span class="line-modified">2960    * `-DUNISTR_FROM_CHAR_EXPLICIT=explicit`</span>
2961    * on the compiler command line or similar.
2962    * @param ch the character to place in the UnicodeString
2963    * @stable ICU 2.0
2964    */
2965   UNISTR_FROM_CHAR_EXPLICIT UnicodeString(UChar32 ch);
2966 
2967   /**
2968    * char16_t* constructor.
2969    *
2970    * It is recommended to mark this constructor &quot;explicit&quot; by
<span class="line-modified">2971    * `-DUNISTR_FROM_STRING_EXPLICIT=explicit`</span>
2972    * on the compiler command line or similar.
<span class="line-modified">2973    * @param text The characters to place in the UnicodeString.  `text`</span>
2974    * must be NULL (U+0000) terminated.
2975    * @stable ICU 2.0
2976    */
2977   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const char16_t *text);
2978 
2979 #if !U_CHAR16_IS_TYPEDEF
2980   /**
2981    * uint16_t * constructor.
2982    * Delegates to UnicodeString(const char16_t *).
2983    *
2984    * It is recommended to mark this constructor &quot;explicit&quot; by
<span class="line-modified">2985    * `-DUNISTR_FROM_STRING_EXPLICIT=explicit`</span>
2986    * on the compiler command line or similar.
2987    * @param text NUL-terminated UTF-16 string
2988    * @stable ICU 59
2989    */
2990   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const uint16_t *text) :
2991       UnicodeString(ConstChar16Ptr(text)) {}
2992 #endif
2993 
2994 #if U_SIZEOF_WCHAR_T==2 || defined(U_IN_DOXYGEN)
2995   /**
2996    * wchar_t * constructor.
2997    * (Only defined if U_SIZEOF_WCHAR_T==2.)
2998    * Delegates to UnicodeString(const char16_t *).
2999    *
3000    * It is recommended to mark this constructor &quot;explicit&quot; by
<span class="line-modified">3001    * `-DUNISTR_FROM_STRING_EXPLICIT=explicit`</span>
3002    * on the compiler command line or similar.
3003    * @param text NUL-terminated UTF-16 string
3004    * @stable ICU 59
3005    */
3006   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const wchar_t *text) :
3007       UnicodeString(ConstChar16Ptr(text)) {}
3008 #endif
3009 
3010   /**
3011    * nullptr_t constructor.
3012    * Effectively the same as the default constructor, makes an empty string object.
3013    *
3014    * It is recommended to mark this constructor &quot;explicit&quot; by
<span class="line-modified">3015    * `-DUNISTR_FROM_STRING_EXPLICIT=explicit`</span>
3016    * on the compiler command line or similar.
3017    * @param text nullptr
3018    * @stable ICU 59
3019    */
3020   UNISTR_FROM_STRING_EXPLICIT inline UnicodeString(const std::nullptr_t text);
3021 
3022   /**
3023    * char16_t* constructor.
3024    * @param text The characters to place in the UnicodeString.
<span class="line-modified">3025    * @param textLength The number of Unicode characters in `text`</span>
3026    * to copy.
3027    * @stable ICU 2.0
3028    */
3029   UnicodeString(const char16_t *text,
3030         int32_t textLength);
3031 
3032 #if !U_CHAR16_IS_TYPEDEF
3033   /**
3034    * uint16_t * constructor.
3035    * Delegates to UnicodeString(const char16_t *, int32_t).
3036    * @param text UTF-16 string
3037    * @param length string length
3038    * @stable ICU 59
3039    */
3040   UnicodeString(const uint16_t *text, int32_t length) :
3041       UnicodeString(ConstChar16Ptr(text), length) {}
3042 #endif
3043 
3044 #if U_SIZEOF_WCHAR_T==2 || defined(U_IN_DOXYGEN)
3045   /**
</pre>
<hr />
<pre>
3060    * @param text nullptr
3061    * @param length ignored
3062    * @stable ICU 59
3063    */
3064   inline UnicodeString(const std::nullptr_t text, int32_t length);
3065 
3066   /**
3067    * Readonly-aliasing char16_t* constructor.
3068    * The text will be used for the UnicodeString object, but
3069    * it will not be released when the UnicodeString is destroyed.
3070    * This has copy-on-write semantics:
3071    * When the string is modified, then the buffer is first copied into
3072    * newly allocated memory.
3073    * The aliased buffer is never modified.
3074    *
3075    * In an assignment to another UnicodeString, when using the copy constructor
3076    * or the assignment operator, the text will be copied.
3077    * When using fastCopyFrom(), the text will be aliased again,
3078    * so that both strings then alias the same readonly-text.
3079    *
<span class="line-modified">3080    * @param isTerminated specifies if `text` is `NUL`-terminated.</span>
<span class="line-modified">3081    *                     This must be true if `textLength==-1`.</span>
3082    * @param text The characters to alias for the UnicodeString.
<span class="line-modified">3083    * @param textLength The number of Unicode characters in `text` to alias.</span>
3084    *                   If -1, then this constructor will determine the length
<span class="line-modified">3085    *                   by calling `u_strlen()`.</span>
3086    * @stable ICU 2.0
3087    */
3088   UnicodeString(UBool isTerminated,
3089                 ConstChar16Ptr text,
3090                 int32_t textLength);
3091 
3092   /**
3093    * Writable-aliasing char16_t* constructor.
3094    * The text will be used for the UnicodeString object, but
3095    * it will not be released when the UnicodeString is destroyed.
3096    * This has write-through semantics:
3097    * For as long as the capacity of the buffer is sufficient, write operations
3098    * will directly affect the buffer. When more capacity is necessary, then
3099    * a new buffer will be allocated and the contents copied as with regularly
3100    * constructed strings.
3101    * In an assignment to another UnicodeString, the buffer will be copied.
3102    * The extract(Char16Ptr dst) function detects whether the dst pointer is the same
3103    * as the string buffer itself and will in this case not copy the contents.
3104    *
3105    * @param buffer The characters to alias for the UnicodeString.
<span class="line-modified">3106    * @param buffLength The number of Unicode characters in `buffer` to alias.</span>
<span class="line-modified">3107    * @param buffCapacity The size of `buffer` in char16_ts.</span>
3108    * @stable ICU 2.0
3109    */
3110   UnicodeString(char16_t *buffer, int32_t buffLength, int32_t buffCapacity);
3111 
3112 #if !U_CHAR16_IS_TYPEDEF
3113   /**
3114    * Writable-aliasing uint16_t * constructor.
3115    * Delegates to UnicodeString(const char16_t *, int32_t, int32_t).
3116    * @param buffer writable buffer of/for UTF-16 text
3117    * @param buffLength length of the current buffer contents
3118    * @param buffCapacity buffer capacity
3119    * @stable ICU 59
3120    */
3121   UnicodeString(uint16_t *buffer, int32_t buffLength, int32_t buffCapacity) :
3122       UnicodeString(Char16Ptr(buffer), buffLength, buffCapacity) {}
3123 #endif
3124 
3125 #if U_SIZEOF_WCHAR_T==2 || defined(U_IN_DOXYGEN)
3126   /**
3127    * Writable-aliasing wchar_t * constructor.
</pre>
<hr />
<pre>
3142    * @param buffer nullptr
3143    * @param buffLength ignored
3144    * @param buffCapacity ignored
3145    * @stable ICU 59
3146    */
3147   inline UnicodeString(std::nullptr_t buffer, int32_t buffLength, int32_t buffCapacity);
3148 
3149 #if U_CHARSET_IS_UTF8 || !UCONFIG_NO_CONVERSION
3150 
3151   /**
3152    * char* constructor.
3153    * Uses the default converter (and thus depends on the ICU conversion code)
3154    * unless U_CHARSET_IS_UTF8 is set to 1.
3155    *
3156    * For ASCII (really &quot;invariant character&quot;) strings it is more efficient to use
3157    * the constructor that takes a US_INV (for its enum EInvariant).
3158    * For ASCII (invariant-character) string literals, see UNICODE_STRING and
3159    * UNICODE_STRING_SIMPLE.
3160    *
3161    * It is recommended to mark this constructor &quot;explicit&quot; by
<span class="line-modified">3162    * `-DUNISTR_FROM_STRING_EXPLICIT=explicit`</span>
3163    * on the compiler command line or similar.
3164    * @param codepageData an array of bytes, null-terminated,
3165    *                     in the platform&#39;s default codepage.
3166    * @stable ICU 2.0
3167    * @see UNICODE_STRING
3168    * @see UNICODE_STRING_SIMPLE
3169    */
3170   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const char *codepageData);
3171 
3172   /**
3173    * char* constructor.
3174    * Uses the default converter (and thus depends on the ICU conversion code)
3175    * unless U_CHARSET_IS_UTF8 is set to 1.
3176    * @param codepageData an array of bytes in the platform&#39;s default codepage.
<span class="line-modified">3177    * @param dataLength The number of bytes in `codepageData`.</span>
3178    * @stable ICU 2.0
3179    */
3180   UnicodeString(const char *codepageData, int32_t dataLength);
3181 
3182 #endif
3183 
3184 #if !UCONFIG_NO_CONVERSION
3185 
3186   /**
3187    * char* constructor.
3188    * @param codepageData an array of bytes, null-terminated
<span class="line-modified">3189    * @param codepage the encoding of `codepageData`.  The special</span>
<span class="line-modified">3190    * value 0 for `codepage` indicates that the text is in the</span>
3191    * platform&#39;s default codepage.
3192    *
<span class="line-modified">3193    * If `codepage` is an empty string (`&quot;&quot;`),</span>
3194    * then a simple conversion is performed on the codepage-invariant
3195    * subset (&quot;invariant characters&quot;) of the platform encoding. See utypes.h.
3196    * Recommendation: For invariant-character strings use the constructor
3197    * UnicodeString(const char *src, int32_t length, enum EInvariant inv)
3198    * because it avoids object code dependencies of UnicodeString on
3199    * the conversion code.
3200    *
3201    * @stable ICU 2.0
3202    */
3203   UnicodeString(const char *codepageData, const char *codepage);
3204 
3205   /**
3206    * char* constructor.
3207    * @param codepageData an array of bytes.
<span class="line-modified">3208    * @param dataLength The number of bytes in `codepageData`.</span>
<span class="line-modified">3209    * @param codepage the encoding of `codepageData`.  The special</span>
<span class="line-modified">3210    * value 0 for `codepage` indicates that the text is in the</span>
3211    * platform&#39;s default codepage.
<span class="line-modified">3212    * If `codepage` is an empty string (`&quot;&quot;`),</span>
3213    * then a simple conversion is performed on the codepage-invariant
3214    * subset (&quot;invariant characters&quot;) of the platform encoding. See utypes.h.
3215    * Recommendation: For invariant-character strings use the constructor
3216    * UnicodeString(const char *src, int32_t length, enum EInvariant inv)
3217    * because it avoids object code dependencies of UnicodeString on
3218    * the conversion code.
3219    *
3220    * @stable ICU 2.0
3221    */
3222   UnicodeString(const char *codepageData, int32_t dataLength, const char *codepage);
3223 
3224   /**
3225    * char * / UConverter constructor.
3226    * This constructor uses an existing UConverter object to
3227    * convert the codepage string to Unicode and construct a UnicodeString
3228    * from that.
3229    *
3230    * The converter is reset at first.
3231    * If the error code indicates a failure before this constructor is called,
3232    * or if an error occurs during conversion or construction,
</pre>
<hr />
<pre>
3243    * @stable ICU 2.0
3244    */
3245   UnicodeString(
3246         const char *src, int32_t srcLength,
3247         UConverter *cnv,
3248         UErrorCode &amp;errorCode);
3249 
3250 #endif
3251 
3252   /**
3253    * Constructs a Unicode string from an invariant-character char * string.
3254    * About invariant characters see utypes.h.
3255    * This constructor has no runtime dependency on conversion code and is
3256    * therefore recommended over ones taking a charset name string
3257    * (where the empty string &quot;&quot; indicates invariant-character conversion).
3258    *
3259    * Use the macro US_INV as the third, signature-distinguishing parameter.
3260    *
3261    * For example:
3262    * \code
<span class="line-modified">3263    *     void fn(const char *s) {</span>
<span class="line-modified">3264    *       UnicodeString ustr(s, -1, US_INV);</span>
<span class="line-modified">3265    *       // use ustr ...</span>
<span class="line-modified">3266    *     }</span>
3267    * \endcode

3268    * @param src String using only invariant characters.
3269    * @param length Length of src, or -1 if NUL-terminated.
3270    * @param inv Signature-distinguishing paramater, use US_INV.
3271    *
3272    * @see US_INV
3273    * @stable ICU 3.2
3274    */
3275   UnicodeString(const char *src, int32_t length, enum EInvariant inv);
3276 
3277 
3278   /**
3279    * Copy constructor.
3280    *
3281    * Starting with ICU 2.4, the assignment operator and the copy constructor
3282    * allocate a new buffer and copy the buffer contents even for readonly aliases.
3283    * By contrast, the fastCopyFrom() function implements the old,
3284    * more efficient but less safe behavior
3285    * of making this string also a readonly alias to the same buffer.
3286    *
3287    * If the source object has an &quot;open&quot; buffer from getBuffer(minCapacity),
3288    * then the copy is an empty string.
3289    *
3290    * @param that The UnicodeString object to copy.
3291    * @stable ICU 2.0
3292    * @see fastCopyFrom
3293    */
3294   UnicodeString(const UnicodeString&amp; that);
3295 
3296   /**
3297    * Move constructor; might leave src in bogus state.
3298    * This string will have the same contents and state that the source string had.
3299    * @param src source string
3300    * @stable ICU 56
3301    */
3302   UnicodeString(UnicodeString &amp;&amp;src) U_NOEXCEPT;
3303 
3304   /**
3305    * &#39;Substring&#39; constructor from tail of source string.
3306    * @param src The UnicodeString object to copy.
<span class="line-modified">3307    * @param srcStart The offset into `src` at which to start copying.</span>
3308    * @stable ICU 2.2
3309    */
3310   UnicodeString(const UnicodeString&amp; src, int32_t srcStart);
3311 
3312   /**
3313    * &#39;Substring&#39; constructor from subrange of source string.
3314    * @param src The UnicodeString object to copy.
<span class="line-modified">3315    * @param srcStart The offset into `src` at which to start copying.</span>
<span class="line-modified">3316    * @param srcLength The number of characters from `src` to copy.</span>
3317    * @stable ICU 2.2
3318    */
3319   UnicodeString(const UnicodeString&amp; src, int32_t srcStart, int32_t srcLength);
3320 
3321   /**
3322    * Clone this object, an instance of a subclass of Replaceable.
3323    * Clones can be used concurrently in multiple threads.
3324    * If a subclass does not implement clone(), or if an error occurs,
3325    * then NULL is returned.
3326    * The clone functions in all subclasses return a pointer to a Replaceable
3327    * because some compilers do not support covariant (same-as-this)
3328    * return types; cast to the appropriate subclass if necessary.
3329    * The caller must delete the clone.
3330    *
3331    * @return a clone of this object
3332    *
3333    * @see Replaceable::clone
3334    * @see getDynamicClassID
3335    * @stable ICU 2.6
3336    */
</pre>
<hr />
<pre>
3368    * @stable ICU 4.2
3369    */
3370   static UnicodeString fromUTF32(const UChar32 *utf32, int32_t length);
3371 
3372   /* Miscellaneous operations */
3373 
3374   /**
3375    * Unescape a string of characters and return a string containing
3376    * the result.  The following escape sequences are recognized:
3377    *
3378    * \\uhhhh       4 hex digits; h in [0-9A-Fa-f]
3379    * \\Uhhhhhhhh   8 hex digits
3380    * \\xhh         1-2 hex digits
3381    * \\ooo         1-3 octal digits; o in [0-7]
3382    * \\cX          control-X; X is masked with 0x1F
3383    *
3384    * as well as the standard ANSI C escapes:
3385    *
3386    * \\a =&gt; U+0007, \\b =&gt; U+0008, \\t =&gt; U+0009, \\n =&gt; U+000A,
3387    * \\v =&gt; U+000B, \\f =&gt; U+000C, \\r =&gt; U+000D, \\e =&gt; U+001B,
<span class="line-modified">3388    * \\&quot; =&gt; U+0022, \\&#39; =&gt; U+0027, \\? =&gt; U+003F, \\\\ =&gt; U+005C</span>
3389    *
3390    * Anything else following a backslash is generically escaped.  For
3391    * example, &quot;[a\\-z]&quot; returns &quot;[a-z]&quot;.
3392    *
3393    * If an escape sequence is ill-formed, this method returns an empty
3394    * string.  An example of an ill-formed sequence is &quot;\\u&quot; followed by
3395    * fewer than 4 hex digits.
3396    *
3397    * This function is similar to u_unescape() but not identical to it.
3398    * The latter takes a source char*, so it does escape recognition
3399    * and also invariant conversion.
3400    *
3401    * @return a string with backslash escapes interpreted, or an
3402    * empty string on error.
3403    * @see UnicodeString#unescapeAt()
3404    * @see u_unescape()
3405    * @see u_unescapeAt()
3406    * @stable ICU 2.0
3407    */
3408   UnicodeString unescape() const;
</pre>
<hr />
<pre>
3616   // Copies just the fields without memory management.
3617   void copyFieldsFrom(UnicodeString &amp;src, UBool setSrcToBogus) U_NOEXCEPT;
3618 
3619   // Pin start and limit to acceptable values.
3620   inline void pinIndex(int32_t&amp; start) const;
3621   inline void pinIndices(int32_t&amp; start,
3622                          int32_t&amp; length) const;
3623 
3624 #if !UCONFIG_NO_CONVERSION
3625 
3626   /* Internal extract() using UConverter. */
3627   int32_t doExtract(int32_t start, int32_t length,
3628                     char *dest, int32_t destCapacity,
3629                     UConverter *cnv,
3630                     UErrorCode &amp;errorCode) const;
3631 
3632   /*
3633    * Real constructor for converting from codepage data.
3634    * It assumes that it is called with !fRefCounted.
3635    *
<span class="line-modified">3636    * If `codepage==0`, then the default converter</span>
3637    * is used for the platform encoding.
<span class="line-modified">3638    * If `codepage` is an empty string (`&quot;&quot;`),</span>
3639    * then a simple conversion is performed on the codepage-invariant
3640    * subset (&quot;invariant characters&quot;) of the platform encoding. See utypes.h.
3641    */
3642   void doCodepageCreate(const char *codepageData,
3643                         int32_t dataLength,
3644                         const char *codepage);
3645 
3646   /*
3647    * Worker function for creating a UnicodeString from
3648    * a codepage string using a UConverter.
3649    */
3650   void
3651   doCodepageCreate(const char *codepageData,
3652                    int32_t dataLength,
3653                    UConverter *converter,
3654                    UErrorCode &amp;status);
3655 
3656 #endif
3657 
3658   /*
</pre>
</td>
</tr>
</table>
<center><a href="uniset.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="uobject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>