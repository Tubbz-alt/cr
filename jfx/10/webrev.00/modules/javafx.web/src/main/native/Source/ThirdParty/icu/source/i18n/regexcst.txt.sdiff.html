<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/regexcst.txt</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="regexcmp.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="region.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/regexcst.txt</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 58 start:
 59    default                 term                                     doPatStart
 60 
 61 
 62 
 63 
 64 #
 65 #  term.  At a position where we can accept the start most items in a pattern.
 66 #
 67 term:
 68     quoted               n expr-quant                               doLiteralChar
 69     rule_char            n expr-quant                               doLiteralChar
 70     &#39;[&#39;                  n set-open       ^set-finish               doSetBegin
 71     &#39;(&#39;                  n open-paren
 72     &#39;.&#39;                  n expr-quant                               doDotAny
 73     &#39;^&#39;                  n expr-quant                               doCaret
 74     &#39;$&#39;                  n expr-quant                               doDollar
 75     &#39;\&#39;                  n backslash
 76     &#39;|&#39;                  n  term                                    doOrOperator
 77     &#39;)&#39;                  n  pop                                     doCloseParen
<span class="line-modified"> 78     eof	                   term                                     doPatFinish</span>
 79     default                errorDeath                               doRuleError
 80 
 81 
 82 
 83 #
 84 #   expr-quant    We&#39;ve just finished scanning a term, now look for the optional
 85 #                 trailing quantifier - *, +, ?, *?,  etc.
 86 #
 87 expr-quant:
 88     &#39;*&#39;                  n  quant-star
 89     &#39;+&#39;                  n  quant-plus
 90     &#39;?&#39;                  n  quant-opt
 91     &#39;{&#39;                  n  interval-open                          doIntervalInit
 92     &#39;(&#39;                  n  open-paren-quant
 93     default                 expr-cont
 94 
 95 
 96 #
 97 #  expr-cont      Expression, continuation.  At a point where additional terms are
 98 #                                            allowed, but not required.  No Quantifiers
</pre>
<hr />
<pre>
140     &#39;u&#39;                     paren-flag                              doBeginMatchMode
141     &#39;w&#39;                     paren-flag                              doBeginMatchMode
142     &#39;x&#39;                     paren-flag                              doBeginMatchMode
143     &#39;-&#39;                     paren-flag                              doBeginMatchMode
144     &#39;(&#39;                  n  errorDeath                              doConditionalExpr
145     &#39;{&#39;                  n  errorDeath                              doPerlInline
146     default                 errorDeath                              doBadOpenParenType
147 
148 open-paren-lookbehind:
149     &#39;=&#39;                  n  term            ^expr-cont              doOpenLookBehind       #  (?&lt;=
150     &#39;!&#39;                  n  term            ^expr-cont              doOpenLookBehindNeg    #  (?&lt;!
151     ascii_letter            named-capture                           doBeginNamedCapture    #  (?&lt;name
152     default                 errorDeath                              doBadOpenParenType
153 
154 
155 #
156 #   paren-comment    We&#39;ve got a (?# ... )  style comment.  Eat pattern text till we get to the &#39;)&#39;
157 #
158 paren-comment:
159     &#39;)&#39;                  n  pop
<span class="line-modified">160     eof		                errorDeath                              doMismatchedParenErr</span>
161     default              n  paren-comment
162 
163 #
164 #  paren-flag    Scanned a (?ismx-ismx  flag setting
165 #
166 paren-flag:
167     &#39;i&#39;                  n  paren-flag                              doMatchMode
168     &#39;d&#39;                  n  paren-flag                              doMatchMode
169     &#39;m&#39;                  n  paren-flag                              doMatchMode
170     &#39;s&#39;                  n  paren-flag                              doMatchMode
171     &#39;u&#39;                  n  paren-flag                              doMatchMode
172     &#39;w&#39;                  n  paren-flag                              doMatchMode
173     &#39;x&#39;                  n  paren-flag                              doMatchMode
174     &#39;-&#39;                  n  paren-flag                              doMatchMode
175     &#39;)&#39;                  n  term                                    doSetMatchMode
176     &#39;:&#39;                  n  term              ^expr-quant           doMatchModeParen
177     default                 errorDeath                              doBadModeFlag
178 
179 #
180 #  named-capture    (?&lt;name&gt; ... ), position currently on the name.
</pre>
<hr />
<pre>
208 #
209 #  quant-opt  Scanning a &#39;?&#39; quantifier.  Need to look ahead to decide
210 #                  between plain &#39;?&#39;, &#39;??&#39;, &#39;?+&#39;
211 #
212 quant-opt:
213      &#39;?&#39;                 n  expr-cont                               doNGOpt                 #  ??
214      &#39;+&#39;                 n  expr-cont                               doPossessiveOpt         #  ?+
215      default                expr-cont                               doOpt                   #  ?
216 
217 
218 #
219 #   Interval         scanning a &#39;{&#39;, the opening delimiter for an interval specification
220 #                                   {number} or {min, max} or {min,}
221 #
222 interval-open:
223     digit_char              interval-lower
224     default                 errorDeath                              doIntervalError
225 
226 interval-lower:
227     digit_char           n  interval-lower                          doIntevalLowerDigit
<span class="line-modified">228     &#39;,&#39;			         n  interval-upper</span>
229     &#39;}&#39;                  n  interval-type                           doIntervalSame             # {n}
230     default                 errorDeath                              doIntervalError
231 
232 interval-upper:
233     digit_char           n  interval-upper                          doIntervalUpperDigit
234     &#39;}&#39;                  n  interval-type
235     default                 errorDeath                              doIntervalError
236 
237 interval-type:
238     &#39;?&#39;                  n  expr-cont                               doNGInterval                # {n,m}?
239     &#39;+&#39;                  n  expr-cont                               doPossessiveInterval        # {n,m}+
240     default                 expr-cont                               doInterval                  # {m,n}
241 
242 
243 #
244 #  backslash        #  Backslash.  Figure out which of the \thingies we have encountered.
245 #                                  The low level next-char function will have preprocessed
246 #                                  some of them already; those won&#39;t come here.
247 backslash:
248    &#39;A&#39;                   n  term                                    doBackslashA
</pre>
<hr />
<pre>
355     eof                     errorDeath                              doSetNoCloseError
356     default              n  set-after-lit                           doSetLiteral
357 
358 set-after-set:
359     &#39;]&#39;                  n  pop                                     doSetEnd
360     &#39;[&#39;                  n  set-open      ^set-after-set            doSetBeginUnion
361     &#39;-&#39;                  n  set-set-dash
362     &#39;&amp;&#39;                  n  set-set-amp
363     &#39;\&#39;                  n  set-escape
364     eof                     errorDeath                              doSetNoCloseError
365     default              n  set-after-lit                           doSetLiteral
366 
367 set-after-range:
368     &#39;]&#39;                  n  pop                                     doSetEnd
369     &#39;[&#39;                  n  set-open      ^set-after-set            doSetBeginUnion
370     &#39;-&#39;                  n  set-range-dash
371     &#39;&amp;&#39;                  n  set-range-amp
372     &#39;\&#39;                  n  set-escape
373     eof                     errorDeath                              doSetNoCloseError
374     default              n  set-after-lit                           doSetLiteral
<span class="line-modified">375     </span>
376 
377 # set-after-op
378 #     After a --  or &amp;&amp;
379 #     It is an error to close a set at this point.
380 #
381 set-after-op:
382     &#39;[&#39;                  n  set-open         ^set-after-set         doSetBeginUnion
383     &#39;]&#39;                     errorDeath                              doSetOpError
384     &#39;\&#39;                  n  set-escape
385     default              n  set-after-lit                           doSetLiteral
386 
387 #
388 #   set-set-amp
389 #      Have scanned [[set]&amp;
390 #      Could be a &#39;&amp;&#39; intersection operator, if a set follows.
391 #      Could be the start of a &#39;&amp;&amp;&#39; operator.
392 #      Otherewise is a literal.
393 set-set-amp:
394     &#39;[&#39;                  n  set-open      ^set-after-set           doSetBeginIntersection1
395     &#39;&amp;&#39;                  n  set-after-op                           doSetIntersection2
</pre>
<hr />
<pre>
446     &#39;]&#39;                     set-after-lit                           doSetAddDash
447     &#39;\&#39;                  n  set-lit-dash-escape
448     default              n  set-after-range                         doSetRange
449 
450 # set-lit-dash-escape
451 #
452 #    scanned &quot;[literal-\&quot;
453 #    Could be a range, if the \ introduces an escaped literal char or a named char.
454 #    Otherwise it is an error.
455 #
456 set-lit-dash-escape:
457    &#39;s&#39;                      errorDeath                             doSetOpError
458    &#39;S&#39;                      errorDeath                             doSetOpError
459    &#39;w&#39;                      errorDeath                             doSetOpError
460    &#39;W&#39;                      errorDeath                             doSetOpError
461    &#39;d&#39;                      errorDeath                             doSetOpError
462    &#39;D&#39;                      errorDeath                             doSetOpError
463    &#39;N&#39;                      set-after-range                        doSetNamedRange
464    default               n  set-after-range                        doSetRange
465 
<span class="line-modified">466    </span>
467 #
468 #  set-escape
469 #       Common back-slash escape processing within set expressions
470 #
471 set-escape:
472    &#39;p&#39;                      set-after-set                           doSetProp
473    &#39;P&#39;                      set-after-set                           doSetProp
474    &#39;N&#39;                      set-after-lit                           doSetNamedChar
475    &#39;s&#39;                   n  set-after-range                         doSetBackslash_s
476    &#39;S&#39;                   n  set-after-range                         doSetBackslash_S
477    &#39;w&#39;                   n  set-after-range                         doSetBackslash_w
478    &#39;W&#39;                   n  set-after-range                         doSetBackslash_W
479    &#39;d&#39;                   n  set-after-range                         doSetBackslash_d
480    &#39;D&#39;                   n  set-after-range                         doSetBackslash_D
481    &#39;h&#39;                   n  set-after-range                         doSetBackslash_h
482    &#39;H&#39;                   n  set-after-range                         doSetBackslash_H
483    &#39;v&#39;                   n  set-after-range                         doSetBackslash_v
484    &#39;V&#39;                   n  set-after-range                         doSetBackslash_V
<span class="line-modified">485    default               n  set-after-lit                           doSetLiteralEscaped </span>
486 
487 #
488 # set-finish
489 #     Have just encountered the final &#39;]&#39; that completes a [set], and
490 #     arrived here via a pop.  From here, we exit the set parsing world, and go
491 #     back to generic regular expression parsing.
492 #
493 set-finish:
494     default                 expr-quant                              doSetFinish
495 
496 
497 #
498 # errorDeath.   This state is specified as the next state whenever a syntax error
499 #               in the source rules is detected.  Barring bugs, the state machine will never
500 #               actually get here, but will stop because of the action associated with the error.
501 #               But, just in case, this state asks the state machine to exit.
502 errorDeath:
503     default              n errorDeath                               doExit
504 
505 
</pre>
</td>
<td>
<hr />
<pre>
 58 start:
 59    default                 term                                     doPatStart
 60 
 61 
 62 
 63 
 64 #
 65 #  term.  At a position where we can accept the start most items in a pattern.
 66 #
 67 term:
 68     quoted               n expr-quant                               doLiteralChar
 69     rule_char            n expr-quant                               doLiteralChar
 70     &#39;[&#39;                  n set-open       ^set-finish               doSetBegin
 71     &#39;(&#39;                  n open-paren
 72     &#39;.&#39;                  n expr-quant                               doDotAny
 73     &#39;^&#39;                  n expr-quant                               doCaret
 74     &#39;$&#39;                  n expr-quant                               doDollar
 75     &#39;\&#39;                  n backslash
 76     &#39;|&#39;                  n  term                                    doOrOperator
 77     &#39;)&#39;                  n  pop                                     doCloseParen
<span class="line-modified"> 78     eof                       term                                     doPatFinish</span>
 79     default                errorDeath                               doRuleError
 80 
 81 
 82 
 83 #
 84 #   expr-quant    We&#39;ve just finished scanning a term, now look for the optional
 85 #                 trailing quantifier - *, +, ?, *?,  etc.
 86 #
 87 expr-quant:
 88     &#39;*&#39;                  n  quant-star
 89     &#39;+&#39;                  n  quant-plus
 90     &#39;?&#39;                  n  quant-opt
 91     &#39;{&#39;                  n  interval-open                          doIntervalInit
 92     &#39;(&#39;                  n  open-paren-quant
 93     default                 expr-cont
 94 
 95 
 96 #
 97 #  expr-cont      Expression, continuation.  At a point where additional terms are
 98 #                                            allowed, but not required.  No Quantifiers
</pre>
<hr />
<pre>
140     &#39;u&#39;                     paren-flag                              doBeginMatchMode
141     &#39;w&#39;                     paren-flag                              doBeginMatchMode
142     &#39;x&#39;                     paren-flag                              doBeginMatchMode
143     &#39;-&#39;                     paren-flag                              doBeginMatchMode
144     &#39;(&#39;                  n  errorDeath                              doConditionalExpr
145     &#39;{&#39;                  n  errorDeath                              doPerlInline
146     default                 errorDeath                              doBadOpenParenType
147 
148 open-paren-lookbehind:
149     &#39;=&#39;                  n  term            ^expr-cont              doOpenLookBehind       #  (?&lt;=
150     &#39;!&#39;                  n  term            ^expr-cont              doOpenLookBehindNeg    #  (?&lt;!
151     ascii_letter            named-capture                           doBeginNamedCapture    #  (?&lt;name
152     default                 errorDeath                              doBadOpenParenType
153 
154 
155 #
156 #   paren-comment    We&#39;ve got a (?# ... )  style comment.  Eat pattern text till we get to the &#39;)&#39;
157 #
158 paren-comment:
159     &#39;)&#39;                  n  pop
<span class="line-modified">160     eof                        errorDeath                              doMismatchedParenErr</span>
161     default              n  paren-comment
162 
163 #
164 #  paren-flag    Scanned a (?ismx-ismx  flag setting
165 #
166 paren-flag:
167     &#39;i&#39;                  n  paren-flag                              doMatchMode
168     &#39;d&#39;                  n  paren-flag                              doMatchMode
169     &#39;m&#39;                  n  paren-flag                              doMatchMode
170     &#39;s&#39;                  n  paren-flag                              doMatchMode
171     &#39;u&#39;                  n  paren-flag                              doMatchMode
172     &#39;w&#39;                  n  paren-flag                              doMatchMode
173     &#39;x&#39;                  n  paren-flag                              doMatchMode
174     &#39;-&#39;                  n  paren-flag                              doMatchMode
175     &#39;)&#39;                  n  term                                    doSetMatchMode
176     &#39;:&#39;                  n  term              ^expr-quant           doMatchModeParen
177     default                 errorDeath                              doBadModeFlag
178 
179 #
180 #  named-capture    (?&lt;name&gt; ... ), position currently on the name.
</pre>
<hr />
<pre>
208 #
209 #  quant-opt  Scanning a &#39;?&#39; quantifier.  Need to look ahead to decide
210 #                  between plain &#39;?&#39;, &#39;??&#39;, &#39;?+&#39;
211 #
212 quant-opt:
213      &#39;?&#39;                 n  expr-cont                               doNGOpt                 #  ??
214      &#39;+&#39;                 n  expr-cont                               doPossessiveOpt         #  ?+
215      default                expr-cont                               doOpt                   #  ?
216 
217 
218 #
219 #   Interval         scanning a &#39;{&#39;, the opening delimiter for an interval specification
220 #                                   {number} or {min, max} or {min,}
221 #
222 interval-open:
223     digit_char              interval-lower
224     default                 errorDeath                              doIntervalError
225 
226 interval-lower:
227     digit_char           n  interval-lower                          doIntevalLowerDigit
<span class="line-modified">228     &#39;,&#39;                     n  interval-upper</span>
229     &#39;}&#39;                  n  interval-type                           doIntervalSame             # {n}
230     default                 errorDeath                              doIntervalError
231 
232 interval-upper:
233     digit_char           n  interval-upper                          doIntervalUpperDigit
234     &#39;}&#39;                  n  interval-type
235     default                 errorDeath                              doIntervalError
236 
237 interval-type:
238     &#39;?&#39;                  n  expr-cont                               doNGInterval                # {n,m}?
239     &#39;+&#39;                  n  expr-cont                               doPossessiveInterval        # {n,m}+
240     default                 expr-cont                               doInterval                  # {m,n}
241 
242 
243 #
244 #  backslash        #  Backslash.  Figure out which of the \thingies we have encountered.
245 #                                  The low level next-char function will have preprocessed
246 #                                  some of them already; those won&#39;t come here.
247 backslash:
248    &#39;A&#39;                   n  term                                    doBackslashA
</pre>
<hr />
<pre>
355     eof                     errorDeath                              doSetNoCloseError
356     default              n  set-after-lit                           doSetLiteral
357 
358 set-after-set:
359     &#39;]&#39;                  n  pop                                     doSetEnd
360     &#39;[&#39;                  n  set-open      ^set-after-set            doSetBeginUnion
361     &#39;-&#39;                  n  set-set-dash
362     &#39;&amp;&#39;                  n  set-set-amp
363     &#39;\&#39;                  n  set-escape
364     eof                     errorDeath                              doSetNoCloseError
365     default              n  set-after-lit                           doSetLiteral
366 
367 set-after-range:
368     &#39;]&#39;                  n  pop                                     doSetEnd
369     &#39;[&#39;                  n  set-open      ^set-after-set            doSetBeginUnion
370     &#39;-&#39;                  n  set-range-dash
371     &#39;&amp;&#39;                  n  set-range-amp
372     &#39;\&#39;                  n  set-escape
373     eof                     errorDeath                              doSetNoCloseError
374     default              n  set-after-lit                           doSetLiteral
<span class="line-modified">375 </span>
376 
377 # set-after-op
378 #     After a --  or &amp;&amp;
379 #     It is an error to close a set at this point.
380 #
381 set-after-op:
382     &#39;[&#39;                  n  set-open         ^set-after-set         doSetBeginUnion
383     &#39;]&#39;                     errorDeath                              doSetOpError
384     &#39;\&#39;                  n  set-escape
385     default              n  set-after-lit                           doSetLiteral
386 
387 #
388 #   set-set-amp
389 #      Have scanned [[set]&amp;
390 #      Could be a &#39;&amp;&#39; intersection operator, if a set follows.
391 #      Could be the start of a &#39;&amp;&amp;&#39; operator.
392 #      Otherewise is a literal.
393 set-set-amp:
394     &#39;[&#39;                  n  set-open      ^set-after-set           doSetBeginIntersection1
395     &#39;&amp;&#39;                  n  set-after-op                           doSetIntersection2
</pre>
<hr />
<pre>
446     &#39;]&#39;                     set-after-lit                           doSetAddDash
447     &#39;\&#39;                  n  set-lit-dash-escape
448     default              n  set-after-range                         doSetRange
449 
450 # set-lit-dash-escape
451 #
452 #    scanned &quot;[literal-\&quot;
453 #    Could be a range, if the \ introduces an escaped literal char or a named char.
454 #    Otherwise it is an error.
455 #
456 set-lit-dash-escape:
457    &#39;s&#39;                      errorDeath                             doSetOpError
458    &#39;S&#39;                      errorDeath                             doSetOpError
459    &#39;w&#39;                      errorDeath                             doSetOpError
460    &#39;W&#39;                      errorDeath                             doSetOpError
461    &#39;d&#39;                      errorDeath                             doSetOpError
462    &#39;D&#39;                      errorDeath                             doSetOpError
463    &#39;N&#39;                      set-after-range                        doSetNamedRange
464    default               n  set-after-range                        doSetRange
465 
<span class="line-modified">466 </span>
467 #
468 #  set-escape
469 #       Common back-slash escape processing within set expressions
470 #
471 set-escape:
472    &#39;p&#39;                      set-after-set                           doSetProp
473    &#39;P&#39;                      set-after-set                           doSetProp
474    &#39;N&#39;                      set-after-lit                           doSetNamedChar
475    &#39;s&#39;                   n  set-after-range                         doSetBackslash_s
476    &#39;S&#39;                   n  set-after-range                         doSetBackslash_S
477    &#39;w&#39;                   n  set-after-range                         doSetBackslash_w
478    &#39;W&#39;                   n  set-after-range                         doSetBackslash_W
479    &#39;d&#39;                   n  set-after-range                         doSetBackslash_d
480    &#39;D&#39;                   n  set-after-range                         doSetBackslash_D
481    &#39;h&#39;                   n  set-after-range                         doSetBackslash_h
482    &#39;H&#39;                   n  set-after-range                         doSetBackslash_H
483    &#39;v&#39;                   n  set-after-range                         doSetBackslash_v
484    &#39;V&#39;                   n  set-after-range                         doSetBackslash_V
<span class="line-modified">485    default               n  set-after-lit                           doSetLiteralEscaped</span>
486 
487 #
488 # set-finish
489 #     Have just encountered the final &#39;]&#39; that completes a [set], and
490 #     arrived here via a pop.  From here, we exit the set parsing world, and go
491 #     back to generic regular expression parsing.
492 #
493 set-finish:
494     default                 expr-quant                              doSetFinish
495 
496 
497 #
498 # errorDeath.   This state is specified as the next state whenever a syntax error
499 #               in the source rules is detected.  Barring bugs, the state machine will never
500 #               actually get here, but will stop because of the action associated with the error.
501 #               But, just in case, this state asks the state machine to exit.
502 errorDeath:
503     default              n errorDeath                               doExit
504 
505 
</pre>
</td>
</tr>
</table>
<center><a href="regexcmp.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="region.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>