<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/rematch.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **************************************************************************
   5 *   Copyright (C) 2002-2016 International Business Machines Corporation
   6 *   and others. All rights reserved.
   7 **************************************************************************
   8 */
   9 //
  10 //  file:  rematch.cpp
  11 //
  12 //         Contains the implementation of class RegexMatcher,
  13 //         which is one of the main API classes for the ICU regular expression package.
  14 //
  15 
  16 #include &quot;unicode/utypes.h&quot;
  17 #if !UCONFIG_NO_REGULAR_EXPRESSIONS
  18 
  19 #include &quot;unicode/regex.h&quot;
  20 #include &quot;unicode/uniset.h&quot;
  21 #include &quot;unicode/uchar.h&quot;
  22 #include &quot;unicode/ustring.h&quot;
  23 #include &quot;unicode/rbbi.h&quot;
  24 #include &quot;unicode/utf.h&quot;
  25 #include &quot;unicode/utf16.h&quot;
  26 #include &quot;uassert.h&quot;
  27 #include &quot;cmemory.h&quot;
  28 #include &quot;cstr.h&quot;
  29 #include &quot;uvector.h&quot;
  30 #include &quot;uvectr32.h&quot;
  31 #include &quot;uvectr64.h&quot;
  32 #include &quot;regeximp.h&quot;
  33 #include &quot;regexst.h&quot;
  34 #include &quot;regextxt.h&quot;
  35 #include &quot;ucase.h&quot;
  36 
  37 // #include &lt;malloc.h&gt;        // Needed for heapcheck testing
  38 
  39 
  40 U_NAMESPACE_BEGIN
  41 
  42 // Default limit for the size of the back track stack, to avoid system
  43 //    failures causedby heap exhaustion.  Units are in 32 bit words, not bytes.
  44 // This value puts ICU&#39;s limits higher than most other regexp implementations,
  45 //    which use recursion rather than the heap, and take more storage per
  46 //    backtrack point.
  47 //
  48 static const int32_t DEFAULT_BACKTRACK_STACK_CAPACITY = 8000000;
  49 
  50 // Time limit counter constant.
  51 //   Time limits for expression evaluation are in terms of quanta of work by
  52 //   the engine, each of which is 10,000 state saves.
  53 //   This constant determines that state saves per tick number.
  54 static const int32_t TIMER_INITIAL_VALUE = 10000;
  55 
  56 
  57 // Test for any of the Unicode line terminating characters.
  58 static inline UBool isLineTerminator(UChar32 c) {
  59     if (c &amp; ~(0x0a | 0x0b | 0x0c | 0x0d | 0x85 | 0x2028 | 0x2029)) {
  60         return false;
  61     }
  62     return (c&lt;=0x0d &amp;&amp; c&gt;=0x0a) || c==0x85 || c==0x2028 || c==0x2029;
  63 }
  64 
  65 //-----------------------------------------------------------------------------
  66 //
  67 //   Constructor and Destructor
  68 //
  69 //-----------------------------------------------------------------------------
  70 RegexMatcher::RegexMatcher(const RegexPattern *pat)  {
  71     fDeferredStatus = U_ZERO_ERROR;
  72     init(fDeferredStatus);
  73     if (U_FAILURE(fDeferredStatus)) {
  74         return;
  75     }
  76     if (pat==NULL) {
  77         fDeferredStatus = U_ILLEGAL_ARGUMENT_ERROR;
  78         return;
  79     }
  80     fPattern = pat;
  81     init2(RegexStaticSets::gStaticSets-&gt;fEmptyText, fDeferredStatus);
  82 }
  83 
  84 
  85 
  86 RegexMatcher::RegexMatcher(const UnicodeString &amp;regexp, const UnicodeString &amp;input,
  87                            uint32_t flags, UErrorCode &amp;status) {
  88     init(status);
  89     if (U_FAILURE(status)) {
  90         return;
  91     }
  92     UParseError    pe;
  93     fPatternOwned      = RegexPattern::compile(regexp, flags, pe, status);
  94     fPattern           = fPatternOwned;
  95 
  96     UText inputText = UTEXT_INITIALIZER;
  97     utext_openConstUnicodeString(&amp;inputText, &amp;input, &amp;status);
  98     init2(&amp;inputText, status);
  99     utext_close(&amp;inputText);
 100 
 101     fInputUniStrMaybeMutable = TRUE;
 102 }
 103 
 104 
 105 RegexMatcher::RegexMatcher(UText *regexp, UText *input,
 106                            uint32_t flags, UErrorCode &amp;status) {
 107     init(status);
 108     if (U_FAILURE(status)) {
 109         return;
 110     }
 111     UParseError    pe;
 112     fPatternOwned      = RegexPattern::compile(regexp, flags, pe, status);
 113     if (U_FAILURE(status)) {
 114         return;
 115     }
 116 
 117     fPattern           = fPatternOwned;
 118     init2(input, status);
 119 }
 120 
 121 
 122 RegexMatcher::RegexMatcher(const UnicodeString &amp;regexp,
 123                            uint32_t flags, UErrorCode &amp;status) {
 124     init(status);
 125     if (U_FAILURE(status)) {
 126         return;
 127     }
 128     UParseError    pe;
 129     fPatternOwned      = RegexPattern::compile(regexp, flags, pe, status);
 130     if (U_FAILURE(status)) {
 131         return;
 132     }
 133     fPattern           = fPatternOwned;
 134     init2(RegexStaticSets::gStaticSets-&gt;fEmptyText, status);
 135 }
 136 
 137 RegexMatcher::RegexMatcher(UText *regexp,
 138                            uint32_t flags, UErrorCode &amp;status) {
 139     init(status);
 140     if (U_FAILURE(status)) {
 141         return;
 142     }
 143     UParseError    pe;
 144     fPatternOwned      = RegexPattern::compile(regexp, flags, pe, status);
 145         if (U_FAILURE(status)) {
 146         return;
 147     }
 148 
 149     fPattern           = fPatternOwned;
 150     init2(RegexStaticSets::gStaticSets-&gt;fEmptyText, status);
 151 }
 152 
 153 
 154 
 155 
 156 RegexMatcher::~RegexMatcher() {
 157     delete fStack;
 158     if (fData != fSmallData) {
 159         uprv_free(fData);
 160         fData = NULL;
 161     }
 162     if (fPatternOwned) {
 163         delete fPatternOwned;
 164         fPatternOwned = NULL;
 165         fPattern = NULL;
 166     }
 167 
 168     if (fInput) {
 169         delete fInput;
 170     }
 171     if (fInputText) {
 172         utext_close(fInputText);
 173     }
 174     if (fAltInputText) {
 175         utext_close(fAltInputText);
 176     }
 177 
 178     #if UCONFIG_NO_BREAK_ITERATION==0
 179     delete fWordBreakItr;
 180     #endif
 181 }
 182 
 183 //
 184 //   init()   common initialization for use by all constructors.
 185 //            Initialize all fields, get the object into a consistent state.
 186 //            This must be done even when the initial status shows an error,
 187 //            so that the object is initialized sufficiently well for the destructor
 188 //            to run safely.
 189 //
 190 void RegexMatcher::init(UErrorCode &amp;status) {
 191     fPattern           = NULL;
 192     fPatternOwned      = NULL;
 193     fFrameSize         = 0;
 194     fRegionStart       = 0;
 195     fRegionLimit       = 0;
 196     fAnchorStart       = 0;
 197     fAnchorLimit       = 0;
 198     fLookStart         = 0;
 199     fLookLimit         = 0;
 200     fActiveStart       = 0;
 201     fActiveLimit       = 0;
 202     fTransparentBounds = FALSE;
 203     fAnchoringBounds   = TRUE;
 204     fMatch             = FALSE;
 205     fMatchStart        = 0;
 206     fMatchEnd          = 0;
 207     fLastMatchEnd      = -1;
 208     fAppendPosition    = 0;
 209     fHitEnd            = FALSE;
 210     fRequireEnd        = FALSE;
 211     fStack             = NULL;
 212     fFrame             = NULL;
 213     fTimeLimit         = 0;
 214     fTime              = 0;
 215     fTickCounter       = 0;
 216     fStackLimit        = DEFAULT_BACKTRACK_STACK_CAPACITY;
 217     fCallbackFn        = NULL;
 218     fCallbackContext   = NULL;
 219     fFindProgressCallbackFn      = NULL;
 220     fFindProgressCallbackContext = NULL;
 221     fTraceDebug        = FALSE;
 222     fDeferredStatus    = status;
 223     fData              = fSmallData;
 224     fWordBreakItr      = NULL;
 225 
 226     fStack             = NULL;
 227     fInputText         = NULL;
 228     fAltInputText      = NULL;
 229     fInput             = NULL;
 230     fInputLength       = 0;
 231     fInputUniStrMaybeMutable = FALSE;
 232 }
 233 
 234 //
 235 //  init2()   Common initialization for use by RegexMatcher constructors, part 2.
 236 //            This handles the common setup to be done after the Pattern is available.
 237 //
 238 void RegexMatcher::init2(UText *input, UErrorCode &amp;status) {
 239     if (U_FAILURE(status)) {
 240         fDeferredStatus = status;
 241         return;
 242     }
 243 
 244     if (fPattern-&gt;fDataSize &gt; UPRV_LENGTHOF(fSmallData)) {
 245         fData = (int64_t *)uprv_malloc(fPattern-&gt;fDataSize * sizeof(int64_t));
 246         if (fData == NULL) {
 247             status = fDeferredStatus = U_MEMORY_ALLOCATION_ERROR;
 248             return;
 249         }
 250     }
 251 
 252     fStack = new UVector64(status);
 253     if (fStack == NULL) {
 254         status = fDeferredStatus = U_MEMORY_ALLOCATION_ERROR;
 255         return;
 256     }
 257 
 258     reset(input);
 259     setStackLimit(DEFAULT_BACKTRACK_STACK_CAPACITY, status);
 260     if (U_FAILURE(status)) {
 261         fDeferredStatus = status;
 262         return;
 263     }
 264 }
 265 
 266 
 267 static const UChar BACKSLASH  = 0x5c;
 268 static const UChar DOLLARSIGN = 0x24;
 269 static const UChar LEFTBRACKET = 0x7b;
 270 static const UChar RIGHTBRACKET = 0x7d;
 271 
 272 //--------------------------------------------------------------------------------
 273 //
 274 //    appendReplacement
 275 //
 276 //--------------------------------------------------------------------------------
 277 RegexMatcher &amp;RegexMatcher::appendReplacement(UnicodeString &amp;dest,
 278                                               const UnicodeString &amp;replacement,
 279                                               UErrorCode &amp;status) {
 280     UText replacementText = UTEXT_INITIALIZER;
 281 
 282     utext_openConstUnicodeString(&amp;replacementText, &amp;replacement, &amp;status);
 283     if (U_SUCCESS(status)) {
 284         UText resultText = UTEXT_INITIALIZER;
 285         utext_openUnicodeString(&amp;resultText, &amp;dest, &amp;status);
 286 
 287         if (U_SUCCESS(status)) {
 288             appendReplacement(&amp;resultText, &amp;replacementText, status);
 289             utext_close(&amp;resultText);
 290         }
 291         utext_close(&amp;replacementText);
 292     }
 293 
 294     return *this;
 295 }
 296 
 297 //
 298 //    appendReplacement, UText mode
 299 //
 300 RegexMatcher &amp;RegexMatcher::appendReplacement(UText *dest,
 301                                               UText *replacement,
 302                                               UErrorCode &amp;status) {
 303     if (U_FAILURE(status)) {
 304         return *this;
 305     }
 306     if (U_FAILURE(fDeferredStatus)) {
 307         status = fDeferredStatus;
 308         return *this;
 309     }
 310     if (fMatch == FALSE) {
 311         status = U_REGEX_INVALID_STATE;
 312         return *this;
 313     }
 314 
 315     // Copy input string from the end of previous match to start of current match
 316     int64_t  destLen = utext_nativeLength(dest);
 317     if (fMatchStart &gt; fAppendPosition) {
 318         if (UTEXT_FULL_TEXT_IN_CHUNK(fInputText, fInputLength)) {
 319             destLen += utext_replace(dest, destLen, destLen, fInputText-&gt;chunkContents+fAppendPosition,
 320                                      (int32_t)(fMatchStart-fAppendPosition), &amp;status);
 321         } else {
 322             int32_t len16;
 323             if (UTEXT_USES_U16(fInputText)) {
 324                 len16 = (int32_t)(fMatchStart-fAppendPosition);
 325             } else {
 326                 UErrorCode lengthStatus = U_ZERO_ERROR;
 327                 len16 = utext_extract(fInputText, fAppendPosition, fMatchStart, NULL, 0, &amp;lengthStatus);
 328             }
 329             UChar *inputChars = (UChar *)uprv_malloc(sizeof(UChar)*(len16+1));
 330             if (inputChars == NULL) {
 331                 status = U_MEMORY_ALLOCATION_ERROR;
 332                 return *this;
 333             }
 334             utext_extract(fInputText, fAppendPosition, fMatchStart, inputChars, len16+1, &amp;status);
 335             destLen += utext_replace(dest, destLen, destLen, inputChars, len16, &amp;status);
 336             uprv_free(inputChars);
 337         }
 338     }
 339     fAppendPosition = fMatchEnd;
 340 
 341 
 342     // scan the replacement text, looking for substitutions ($n) and \escapes.
 343     //  TODO:  optimize this loop by efficiently scanning for &#39;$&#39; or &#39;\&#39;,
 344     //         move entire ranges not containing substitutions.
 345     UTEXT_SETNATIVEINDEX(replacement, 0);
 346     for (UChar32 c = UTEXT_NEXT32(replacement); U_SUCCESS(status) &amp;&amp; c != U_SENTINEL;  c = UTEXT_NEXT32(replacement)) {
 347         if (c == BACKSLASH) {
 348             // Backslash Escape.  Copy the following char out without further checks.
 349             //                    Note:  Surrogate pairs don&#39;t need any special handling
 350             //                           The second half wont be a &#39;$&#39; or a &#39;\&#39;, and
 351             //                           will move to the dest normally on the next
 352             //                           loop iteration.
 353             c = UTEXT_CURRENT32(replacement);
 354             if (c == U_SENTINEL) {
 355                 break;
 356             }
 357 
 358             if (c==0x55/*U*/ || c==0x75/*u*/) {
 359                 // We have a \udddd or \Udddddddd escape sequence.
 360                 int32_t offset = 0;
 361                 struct URegexUTextUnescapeCharContext context = U_REGEX_UTEXT_UNESCAPE_CONTEXT(replacement);
 362                 UChar32 escapedChar = u_unescapeAt(uregex_utext_unescape_charAt, &amp;offset, INT32_MAX, &amp;context);
 363                 if (escapedChar != (UChar32)0xFFFFFFFF) {
 364                     if (U_IS_BMP(escapedChar)) {
 365                         UChar c16 = (UChar)escapedChar;
 366                         destLen += utext_replace(dest, destLen, destLen, &amp;c16, 1, &amp;status);
 367                     } else {
 368                         UChar surrogate[2];
 369                         surrogate[0] = U16_LEAD(escapedChar);
 370                         surrogate[1] = U16_TRAIL(escapedChar);
 371                         if (U_SUCCESS(status)) {
 372                             destLen += utext_replace(dest, destLen, destLen, surrogate, 2, &amp;status);
 373                         }
 374                     }
 375                     // TODO:  Report errors for mal-formed \u escapes?
 376                     //        As this is, the original sequence is output, which may be OK.
 377                     if (context.lastOffset == offset) {
 378                         (void)UTEXT_PREVIOUS32(replacement);
 379                     } else if (context.lastOffset != offset-1) {
 380                         utext_moveIndex32(replacement, offset - context.lastOffset - 1);
 381                     }
 382                 }
 383             } else {
 384                 (void)UTEXT_NEXT32(replacement);
 385                 // Plain backslash escape.  Just put out the escaped character.
 386                 if (U_IS_BMP(c)) {
 387                     UChar c16 = (UChar)c;
 388                     destLen += utext_replace(dest, destLen, destLen, &amp;c16, 1, &amp;status);
 389                 } else {
 390                     UChar surrogate[2];
 391                     surrogate[0] = U16_LEAD(c);
 392                     surrogate[1] = U16_TRAIL(c);
 393                     if (U_SUCCESS(status)) {
 394                         destLen += utext_replace(dest, destLen, destLen, surrogate, 2, &amp;status);
 395                     }
 396                 }
 397             }
 398         } else if (c != DOLLARSIGN) {
 399             // Normal char, not a $.  Copy it out without further checks.
 400             if (U_IS_BMP(c)) {
 401                 UChar c16 = (UChar)c;
 402                 destLen += utext_replace(dest, destLen, destLen, &amp;c16, 1, &amp;status);
 403             } else {
 404                 UChar surrogate[2];
 405                 surrogate[0] = U16_LEAD(c);
 406                 surrogate[1] = U16_TRAIL(c);
 407                 if (U_SUCCESS(status)) {
 408                     destLen += utext_replace(dest, destLen, destLen, surrogate, 2, &amp;status);
 409                 }
 410             }
 411         } else {
 412             // We&#39;ve got a $.  Pick up a capture group name or number if one follows.
 413             // Consume digits so long as the resulting group number &lt;= the number of
 414             // number of capture groups in the pattern.
 415 
 416             int32_t groupNum  = 0;
 417             int32_t numDigits = 0;
 418             UChar32 nextChar = utext_current32(replacement);
 419             if (nextChar == LEFTBRACKET) {
 420                 // Scan for a Named Capture Group, ${name}.
 421                 UnicodeString groupName;
 422                 utext_next32(replacement);
 423                 while(U_SUCCESS(status) &amp;&amp; nextChar != RIGHTBRACKET) {
 424                     nextChar = utext_next32(replacement);
 425                     if (nextChar == U_SENTINEL) {
 426                         status = U_REGEX_INVALID_CAPTURE_GROUP_NAME;
 427                     } else if ((nextChar &gt;= 0x41 &amp;&amp; nextChar &lt;= 0x5a) ||       // A..Z
 428                                (nextChar &gt;= 0x61 &amp;&amp; nextChar &lt;= 0x7a) ||       // a..z
 429                                (nextChar &gt;= 0x31 &amp;&amp; nextChar &lt;= 0x39)) {       // 0..9
 430                         groupName.append(nextChar);
 431                     } else if (nextChar == RIGHTBRACKET) {
 432                         groupNum = uhash_geti(fPattern-&gt;fNamedCaptureMap, &amp;groupName);
 433                         if (groupNum == 0) {
 434                             status = U_REGEX_INVALID_CAPTURE_GROUP_NAME;
 435                         }
 436                     } else {
 437                         // Character was something other than a name char or a closing &#39;}&#39;
 438                         status = U_REGEX_INVALID_CAPTURE_GROUP_NAME;
 439                     }
 440                 }
 441 
 442             } else if (u_isdigit(nextChar)) {
 443                 // $n    Scan for a capture group number
 444                 int32_t numCaptureGroups = fPattern-&gt;fGroupMap-&gt;size();
 445                 for (;;) {
 446                     nextChar = UTEXT_CURRENT32(replacement);
 447                     if (nextChar == U_SENTINEL) {
 448                         break;
 449                     }
 450                     if (u_isdigit(nextChar) == FALSE) {
 451                         break;
 452                     }
 453                     int32_t nextDigitVal = u_charDigitValue(nextChar);
 454                     if (groupNum*10 + nextDigitVal &gt; numCaptureGroups) {
 455                         // Don&#39;t consume the next digit if it makes the capture group number too big.
 456                         if (numDigits == 0) {
 457                             status = U_INDEX_OUTOFBOUNDS_ERROR;
 458                         }
 459                         break;
 460                     }
 461                     (void)UTEXT_NEXT32(replacement);
 462                     groupNum=groupNum*10 + nextDigitVal;
 463                     ++numDigits;
 464                 }
 465             } else {
 466                 // $ not followed by capture group name or number.
 467                 status = U_REGEX_INVALID_CAPTURE_GROUP_NAME;
 468             }
 469 
 470             if (U_SUCCESS(status)) {
 471                 destLen += appendGroup(groupNum, dest, status);
 472             }
 473         }  // End of $ capture group handling
 474     }  // End of per-character loop through the replacement string.
 475 
 476     return *this;
 477 }
 478 
 479 
 480 
 481 //--------------------------------------------------------------------------------
 482 //
 483 //    appendTail     Intended to be used in conjunction with appendReplacement()
 484 //                   To the destination string, append everything following
 485 //                   the last match position from the input string.
 486 //
 487 //                   Note:  Match ranges do not affect appendTail or appendReplacement
 488 //
 489 //--------------------------------------------------------------------------------
 490 UnicodeString &amp;RegexMatcher::appendTail(UnicodeString &amp;dest) {
 491     UErrorCode status = U_ZERO_ERROR;
 492     UText resultText = UTEXT_INITIALIZER;
 493     utext_openUnicodeString(&amp;resultText, &amp;dest, &amp;status);
 494 
 495     if (U_SUCCESS(status)) {
 496         appendTail(&amp;resultText, status);
 497         utext_close(&amp;resultText);
 498     }
 499 
 500     return dest;
 501 }
 502 
 503 //
 504 //   appendTail, UText mode
 505 //
 506 UText *RegexMatcher::appendTail(UText *dest, UErrorCode &amp;status) {
 507     if (U_FAILURE(status)) {
 508         return dest;
 509     }
 510     if (U_FAILURE(fDeferredStatus)) {
 511         status = fDeferredStatus;
 512         return dest;
 513     }
 514 
 515     if (fInputLength &gt; fAppendPosition) {
 516         if (UTEXT_FULL_TEXT_IN_CHUNK(fInputText, fInputLength)) {
 517             int64_t destLen = utext_nativeLength(dest);
 518             utext_replace(dest, destLen, destLen, fInputText-&gt;chunkContents+fAppendPosition,
 519                           (int32_t)(fInputLength-fAppendPosition), &amp;status);
 520         } else {
 521             int32_t len16;
 522             if (UTEXT_USES_U16(fInputText)) {
 523                 len16 = (int32_t)(fInputLength-fAppendPosition);
 524             } else {
 525                 len16 = utext_extract(fInputText, fAppendPosition, fInputLength, NULL, 0, &amp;status);
 526                 status = U_ZERO_ERROR; // buffer overflow
 527             }
 528 
 529             UChar *inputChars = (UChar *)uprv_malloc(sizeof(UChar)*(len16));
 530             if (inputChars == NULL) {
 531                 fDeferredStatus = U_MEMORY_ALLOCATION_ERROR;
 532             } else {
 533                 utext_extract(fInputText, fAppendPosition, fInputLength, inputChars, len16, &amp;status); // unterminated
 534                 int64_t destLen = utext_nativeLength(dest);
 535                 utext_replace(dest, destLen, destLen, inputChars, len16, &amp;status);
 536                 uprv_free(inputChars);
 537             }
 538         }
 539     }
 540     return dest;
 541 }
 542 
 543 
 544 
 545 //--------------------------------------------------------------------------------
 546 //
 547 //   end
 548 //
 549 //--------------------------------------------------------------------------------
 550 int32_t RegexMatcher::end(UErrorCode &amp;err) const {
 551     return end(0, err);
 552 }
 553 
 554 int64_t RegexMatcher::end64(UErrorCode &amp;err) const {
 555     return end64(0, err);
 556 }
 557 
 558 int64_t RegexMatcher::end64(int32_t group, UErrorCode &amp;err) const {
 559     if (U_FAILURE(err)) {
 560         return -1;
 561     }
 562     if (fMatch == FALSE) {
 563         err = U_REGEX_INVALID_STATE;
 564         return -1;
 565     }
 566     if (group &lt; 0 || group &gt; fPattern-&gt;fGroupMap-&gt;size()) {
 567         err = U_INDEX_OUTOFBOUNDS_ERROR;
 568         return -1;
 569     }
 570     int64_t e = -1;
 571     if (group == 0) {
 572         e = fMatchEnd;
 573     } else {
 574         // Get the position within the stack frame of the variables for
 575         //    this capture group.
 576         int32_t groupOffset = fPattern-&gt;fGroupMap-&gt;elementAti(group-1);
 577         U_ASSERT(groupOffset &lt; fPattern-&gt;fFrameSize);
 578         U_ASSERT(groupOffset &gt;= 0);
 579         e = fFrame-&gt;fExtra[groupOffset + 1];
 580     }
 581 
 582         return e;
 583 }
 584 
 585 int32_t RegexMatcher::end(int32_t group, UErrorCode &amp;err) const {
 586     return (int32_t)end64(group, err);
 587 }
 588 
 589 //--------------------------------------------------------------------------------
 590 //
 591 //   findProgressInterrupt  This function is called once for each advance in the target
 592 //                          string from the find() function, and calls the user progress callback
 593 //                          function if there is one installed.
 594 //
 595 //         Return:  TRUE if the find operation is to be terminated.
 596 //                  FALSE if the find operation is to continue running.
 597 //
 598 //--------------------------------------------------------------------------------
 599 UBool RegexMatcher::findProgressInterrupt(int64_t pos, UErrorCode &amp;status) {
 600     if (fFindProgressCallbackFn &amp;&amp; !(*fFindProgressCallbackFn)(fFindProgressCallbackContext, pos)) {
 601         status = U_REGEX_STOPPED_BY_CALLER;
 602         return TRUE;
 603     }
 604     return FALSE;
 605 }
 606 
 607 //--------------------------------------------------------------------------------
 608 //
 609 //   find()
 610 //
 611 //--------------------------------------------------------------------------------
 612 UBool RegexMatcher::find() {
 613     if (U_FAILURE(fDeferredStatus)) {
 614         return FALSE;
 615     }
 616     UErrorCode status = U_ZERO_ERROR;
 617     UBool result = find(status);
 618     return result;
 619 }
 620 
 621 //--------------------------------------------------------------------------------
 622 //
 623 //   find()
 624 //
 625 //--------------------------------------------------------------------------------
 626 UBool RegexMatcher::find(UErrorCode &amp;status) {
 627     // Start at the position of the last match end.  (Will be zero if the
 628     //   matcher has been reset.)
 629     //
 630     if (U_FAILURE(status)) {
 631         return FALSE;
 632     }
 633     if (U_FAILURE(fDeferredStatus)) {
 634         status = fDeferredStatus;
 635         return FALSE;
 636     }
 637 
 638     if (UTEXT_FULL_TEXT_IN_CHUNK(fInputText, fInputLength)) {
 639         return findUsingChunk(status);
 640     }
 641 
 642     int64_t startPos = fMatchEnd;
 643     if (startPos==0) {
 644         startPos = fActiveStart;
 645     }
 646 
 647     if (fMatch) {
 648         // Save the position of any previous successful match.
 649         fLastMatchEnd = fMatchEnd;
 650 
 651         if (fMatchStart == fMatchEnd) {
 652             // Previous match had zero length.  Move start position up one position
 653             //  to avoid sending find() into a loop on zero-length matches.
 654             if (startPos &gt;= fActiveLimit) {
 655                 fMatch = FALSE;
 656                 fHitEnd = TRUE;
 657                 return FALSE;
 658             }
 659             UTEXT_SETNATIVEINDEX(fInputText, startPos);
 660             (void)UTEXT_NEXT32(fInputText);
 661             startPos = UTEXT_GETNATIVEINDEX(fInputText);
 662         }
 663     } else {
 664         if (fLastMatchEnd &gt;= 0) {
 665             // A previous find() failed to match.  Don&#39;t try again.
 666             //   (without this test, a pattern with a zero-length match
 667             //    could match again at the end of an input string.)
 668             fHitEnd = TRUE;
 669             return FALSE;
 670         }
 671     }
 672 
 673 
 674     // Compute the position in the input string beyond which a match can not begin, because
 675     //   the minimum length match would extend past the end of the input.
 676     //   Note:  some patterns that cannot match anything will have fMinMatchLength==Max Int.
 677     //          Be aware of possible overflows if making changes here.
 678     int64_t testStartLimit;
 679     if (UTEXT_USES_U16(fInputText)) {
 680         testStartLimit = fActiveLimit - fPattern-&gt;fMinMatchLen;
 681         if (startPos &gt; testStartLimit) {
 682             fMatch = FALSE;
 683             fHitEnd = TRUE;
 684             return FALSE;
 685         }
 686     } else {
 687         // We don&#39;t know exactly how long the minimum match length is in native characters.
 688         // Treat anything &gt; 0 as 1.
 689         testStartLimit = fActiveLimit - (fPattern-&gt;fMinMatchLen &gt; 0 ? 1 : 0);
 690     }
 691 
 692     UChar32  c;
 693     U_ASSERT(startPos &gt;= 0);
 694 
 695     switch (fPattern-&gt;fStartType) {
 696     case START_NO_INFO:
 697         // No optimization was found.
 698         //  Try a match at each input position.
 699         for (;;) {
 700             MatchAt(startPos, FALSE, status);
 701             if (U_FAILURE(status)) {
 702                 return FALSE;
 703             }
 704             if (fMatch) {
 705                 return TRUE;
 706             }
 707             if (startPos &gt;= testStartLimit) {
 708                 fHitEnd = TRUE;
 709                 return FALSE;
 710             }
 711             UTEXT_SETNATIVEINDEX(fInputText, startPos);
 712             (void)UTEXT_NEXT32(fInputText);
 713             startPos = UTEXT_GETNATIVEINDEX(fInputText);
 714             // Note that it&#39;s perfectly OK for a pattern to have a zero-length
 715             //   match at the end of a string, so we must make sure that the loop
 716             //   runs with startPos == testStartLimit the last time through.
 717             if  (findProgressInterrupt(startPos, status))
 718                 return FALSE;
 719         }
<a name="1" id="anc1"></a><span class="line-modified"> 720         UPRV_UNREACHABLE;</span>
 721 
 722     case START_START:
 723         // Matches are only possible at the start of the input string
 724         //   (pattern begins with ^ or \A)
 725         if (startPos &gt; fActiveStart) {
 726             fMatch = FALSE;
 727             return FALSE;
 728         }
 729         MatchAt(startPos, FALSE, status);
 730         if (U_FAILURE(status)) {
 731             return FALSE;
 732         }
 733         return fMatch;
 734 
 735 
 736     case START_SET:
 737         {
 738             // Match may start on any char from a pre-computed set.
 739             U_ASSERT(fPattern-&gt;fMinMatchLen &gt; 0);
 740             UTEXT_SETNATIVEINDEX(fInputText, startPos);
 741             for (;;) {
 742                 int64_t pos = startPos;
 743                 c = UTEXT_NEXT32(fInputText);
 744                 startPos = UTEXT_GETNATIVEINDEX(fInputText);
 745                 // c will be -1 (U_SENTINEL) at end of text, in which case we
 746                 // skip this next block (so we don&#39;t have a negative array index)
 747                 // and handle end of text in the following block.
 748                 if (c &gt;= 0 &amp;&amp; ((c&lt;256 &amp;&amp; fPattern-&gt;fInitialChars8-&gt;contains(c)) ||
 749                               (c&gt;=256 &amp;&amp; fPattern-&gt;fInitialChars-&gt;contains(c)))) {
 750                     MatchAt(pos, FALSE, status);
 751                     if (U_FAILURE(status)) {
 752                         return FALSE;
 753                     }
 754                     if (fMatch) {
 755                         return TRUE;
 756                     }
 757                     UTEXT_SETNATIVEINDEX(fInputText, pos);
 758                 }
 759                 if (startPos &gt; testStartLimit) {
 760                     fMatch = FALSE;
 761                     fHitEnd = TRUE;
 762                     return FALSE;
 763                 }
 764                 if  (findProgressInterrupt(startPos, status))
 765                     return FALSE;
 766             }
 767         }
<a name="2" id="anc2"></a><span class="line-modified"> 768         UPRV_UNREACHABLE;</span>
 769 
 770     case START_STRING:
 771     case START_CHAR:
 772         {
 773             // Match starts on exactly one char.
 774             U_ASSERT(fPattern-&gt;fMinMatchLen &gt; 0);
 775             UChar32 theChar = fPattern-&gt;fInitialChar;
 776             UTEXT_SETNATIVEINDEX(fInputText, startPos);
 777             for (;;) {
 778                 int64_t pos = startPos;
 779                 c = UTEXT_NEXT32(fInputText);
 780                 startPos = UTEXT_GETNATIVEINDEX(fInputText);
 781                 if (c == theChar) {
 782                     MatchAt(pos, FALSE, status);
 783                     if (U_FAILURE(status)) {
 784                         return FALSE;
 785                     }
 786                     if (fMatch) {
 787                         return TRUE;
 788                     }
 789                     UTEXT_SETNATIVEINDEX(fInputText, startPos);
 790                 }
 791                 if (startPos &gt; testStartLimit) {
 792                     fMatch = FALSE;
 793                     fHitEnd = TRUE;
 794                     return FALSE;
 795                 }
 796                 if  (findProgressInterrupt(startPos, status))
 797                     return FALSE;
 798            }
 799         }
<a name="3" id="anc3"></a><span class="line-modified"> 800         UPRV_UNREACHABLE;</span>
 801 
 802     case START_LINE:
 803         {
<a name="4" id="anc4"></a><span class="line-modified"> 804             UChar32 ch;</span>
 805             if (startPos == fAnchorStart) {
 806                 MatchAt(startPos, FALSE, status);
 807                 if (U_FAILURE(status)) {
 808                     return FALSE;
 809                 }
 810                 if (fMatch) {
 811                     return TRUE;
 812                 }
 813                 UTEXT_SETNATIVEINDEX(fInputText, startPos);
<a name="5" id="anc5"></a><span class="line-modified"> 814                 ch = UTEXT_NEXT32(fInputText);</span>
 815                 startPos = UTEXT_GETNATIVEINDEX(fInputText);
 816             } else {
 817                 UTEXT_SETNATIVEINDEX(fInputText, startPos);
<a name="6" id="anc6"></a><span class="line-modified"> 818                 ch = UTEXT_PREVIOUS32(fInputText);</span>
 819                 UTEXT_SETNATIVEINDEX(fInputText, startPos);
 820             }
 821 
 822             if (fPattern-&gt;fFlags &amp; UREGEX_UNIX_LINES) {
 823                 for (;;) {
<a name="7" id="anc7"></a><span class="line-modified"> 824                     if (ch == 0x0a) {</span>
 825                             MatchAt(startPos, FALSE, status);
 826                             if (U_FAILURE(status)) {
 827                                 return FALSE;
 828                             }
 829                             if (fMatch) {
 830                                 return TRUE;
 831                             }
 832                             UTEXT_SETNATIVEINDEX(fInputText, startPos);
 833                     }
 834                     if (startPos &gt;= testStartLimit) {
 835                         fMatch = FALSE;
 836                         fHitEnd = TRUE;
 837                         return FALSE;
 838                     }
<a name="8" id="anc8"></a><span class="line-modified"> 839                     ch = UTEXT_NEXT32(fInputText);</span>
 840                     startPos = UTEXT_GETNATIVEINDEX(fInputText);
 841                     // Note that it&#39;s perfectly OK for a pattern to have a zero-length
 842                     //   match at the end of a string, so we must make sure that the loop
 843                     //   runs with startPos == testStartLimit the last time through.
 844                     if  (findProgressInterrupt(startPos, status))
 845                         return FALSE;
 846                 }
 847             } else {
 848                 for (;;) {
<a name="9" id="anc9"></a><span class="line-modified"> 849                     if (isLineTerminator(ch)) {</span>
<span class="line-modified"> 850                         if (ch == 0x0d &amp;&amp; startPos &lt; fActiveLimit &amp;&amp; UTEXT_CURRENT32(fInputText) == 0x0a) {</span>
 851                             (void)UTEXT_NEXT32(fInputText);
 852                             startPos = UTEXT_GETNATIVEINDEX(fInputText);
 853                         }
 854                         MatchAt(startPos, FALSE, status);
 855                         if (U_FAILURE(status)) {
 856                             return FALSE;
 857                         }
 858                         if (fMatch) {
 859                             return TRUE;
 860                         }
 861                         UTEXT_SETNATIVEINDEX(fInputText, startPos);
 862                     }
 863                     if (startPos &gt;= testStartLimit) {
 864                         fMatch = FALSE;
 865                         fHitEnd = TRUE;
 866                         return FALSE;
 867                     }
<a name="10" id="anc10"></a><span class="line-modified"> 868                     ch = UTEXT_NEXT32(fInputText);</span>
 869                     startPos = UTEXT_GETNATIVEINDEX(fInputText);
 870                     // Note that it&#39;s perfectly OK for a pattern to have a zero-length
 871                     //   match at the end of a string, so we must make sure that the loop
 872                     //   runs with startPos == testStartLimit the last time through.
 873                     if  (findProgressInterrupt(startPos, status))
 874                         return FALSE;
 875                 }
 876             }
 877         }
 878 
 879     default:
<a name="11" id="anc11"></a><span class="line-modified"> 880         UPRV_UNREACHABLE;</span>
 881     }
 882 
<a name="12" id="anc12"></a><span class="line-modified"> 883     UPRV_UNREACHABLE;</span>

 884 }
 885 
 886 
 887 
 888 UBool RegexMatcher::find(int64_t start, UErrorCode &amp;status) {
 889     if (U_FAILURE(status)) {
 890         return FALSE;
 891     }
 892     if (U_FAILURE(fDeferredStatus)) {
 893         status = fDeferredStatus;
 894         return FALSE;
 895     }
 896     this-&gt;reset();                        // Note:  Reset() is specified by Java Matcher documentation.
 897                                           //        This will reset the region to be the full input length.
 898     if (start &lt; 0) {
 899         status = U_INDEX_OUTOFBOUNDS_ERROR;
 900         return FALSE;
 901     }
 902 
 903     int64_t nativeStart = start;
 904     if (nativeStart &lt; fActiveStart || nativeStart &gt; fActiveLimit) {
 905         status = U_INDEX_OUTOFBOUNDS_ERROR;
 906         return FALSE;
 907     }
 908     fMatchEnd = nativeStart;
 909     return find(status);
 910 }
 911 
 912 
 913 //--------------------------------------------------------------------------------
 914 //
 915 //   findUsingChunk() -- like find(), but with the advance knowledge that the
 916 //                       entire string is available in the UText&#39;s chunk buffer.
 917 //
 918 //--------------------------------------------------------------------------------
 919 UBool RegexMatcher::findUsingChunk(UErrorCode &amp;status) {
 920     // Start at the position of the last match end.  (Will be zero if the
 921     //   matcher has been reset.
 922     //
 923 
 924     int32_t startPos = (int32_t)fMatchEnd;
 925     if (startPos==0) {
 926         startPos = (int32_t)fActiveStart;
 927     }
 928 
 929     const UChar *inputBuf = fInputText-&gt;chunkContents;
 930 
 931     if (fMatch) {
 932         // Save the position of any previous successful match.
 933         fLastMatchEnd = fMatchEnd;
 934 
 935         if (fMatchStart == fMatchEnd) {
 936             // Previous match had zero length.  Move start position up one position
 937             //  to avoid sending find() into a loop on zero-length matches.
 938             if (startPos &gt;= fActiveLimit) {
 939                 fMatch = FALSE;
 940                 fHitEnd = TRUE;
 941                 return FALSE;
 942             }
 943             U16_FWD_1(inputBuf, startPos, fInputLength);
 944         }
 945     } else {
 946         if (fLastMatchEnd &gt;= 0) {
 947             // A previous find() failed to match.  Don&#39;t try again.
 948             //   (without this test, a pattern with a zero-length match
 949             //    could match again at the end of an input string.)
 950             fHitEnd = TRUE;
 951             return FALSE;
 952         }
 953     }
 954 
 955 
 956     // Compute the position in the input string beyond which a match can not begin, because
 957     //   the minimum length match would extend past the end of the input.
 958     //   Note:  some patterns that cannot match anything will have fMinMatchLength==Max Int.
 959     //          Be aware of possible overflows if making changes here.
 960     //   Note:  a match can begin at inputBuf + testLen; it is an inclusive limit.
 961     int32_t testLen  = (int32_t)(fActiveLimit - fPattern-&gt;fMinMatchLen);
 962     if (startPos &gt; testLen) {
 963         fMatch = FALSE;
 964         fHitEnd = TRUE;
 965         return FALSE;
 966     }
 967 
 968     UChar32  c;
 969     U_ASSERT(startPos &gt;= 0);
 970 
 971     switch (fPattern-&gt;fStartType) {
 972     case START_NO_INFO:
 973         // No optimization was found.
 974         //  Try a match at each input position.
 975         for (;;) {
 976             MatchChunkAt(startPos, FALSE, status);
 977             if (U_FAILURE(status)) {
 978                 return FALSE;
 979             }
 980             if (fMatch) {
 981                 return TRUE;
 982             }
 983             if (startPos &gt;= testLen) {
 984                 fHitEnd = TRUE;
 985                 return FALSE;
 986             }
 987             U16_FWD_1(inputBuf, startPos, fActiveLimit);
 988             // Note that it&#39;s perfectly OK for a pattern to have a zero-length
 989             //   match at the end of a string, so we must make sure that the loop
 990             //   runs with startPos == testLen the last time through.
 991             if  (findProgressInterrupt(startPos, status))
 992                 return FALSE;
 993         }
<a name="13" id="anc13"></a><span class="line-modified"> 994         UPRV_UNREACHABLE;</span>
 995 
 996     case START_START:
 997         // Matches are only possible at the start of the input string
 998         //   (pattern begins with ^ or \A)
 999         if (startPos &gt; fActiveStart) {
1000             fMatch = FALSE;
1001             return FALSE;
1002         }
1003         MatchChunkAt(startPos, FALSE, status);
1004         if (U_FAILURE(status)) {
1005             return FALSE;
1006         }
1007         return fMatch;
1008 
1009 
1010     case START_SET:
1011     {
1012         // Match may start on any char from a pre-computed set.
1013         U_ASSERT(fPattern-&gt;fMinMatchLen &gt; 0);
1014         for (;;) {
1015             int32_t pos = startPos;
1016             U16_NEXT(inputBuf, startPos, fActiveLimit, c);  // like c = inputBuf[startPos++];
1017             if ((c&lt;256 &amp;&amp; fPattern-&gt;fInitialChars8-&gt;contains(c)) ||
1018                 (c&gt;=256 &amp;&amp; fPattern-&gt;fInitialChars-&gt;contains(c))) {
1019                 MatchChunkAt(pos, FALSE, status);
1020                 if (U_FAILURE(status)) {
1021                     return FALSE;
1022                 }
1023                 if (fMatch) {
1024                     return TRUE;
1025                 }
1026             }
1027             if (startPos &gt; testLen) {
1028                 fMatch = FALSE;
1029                 fHitEnd = TRUE;
1030                 return FALSE;
1031             }
1032             if  (findProgressInterrupt(startPos, status))
1033                 return FALSE;
1034         }
1035     }
<a name="14" id="anc14"></a><span class="line-modified">1036     UPRV_UNREACHABLE;</span>
1037 
1038     case START_STRING:
1039     case START_CHAR:
1040     {
1041         // Match starts on exactly one char.
1042         U_ASSERT(fPattern-&gt;fMinMatchLen &gt; 0);
1043         UChar32 theChar = fPattern-&gt;fInitialChar;
1044         for (;;) {
1045             int32_t pos = startPos;
1046             U16_NEXT(inputBuf, startPos, fActiveLimit, c);  // like c = inputBuf[startPos++];
1047             if (c == theChar) {
1048                 MatchChunkAt(pos, FALSE, status);
1049                 if (U_FAILURE(status)) {
1050                     return FALSE;
1051                 }
1052                 if (fMatch) {
1053                     return TRUE;
1054                 }
1055             }
1056             if (startPos &gt; testLen) {
1057                 fMatch = FALSE;
1058                 fHitEnd = TRUE;
1059                 return FALSE;
1060             }
1061             if  (findProgressInterrupt(startPos, status))
1062                 return FALSE;
1063         }
1064     }
<a name="15" id="anc15"></a><span class="line-modified">1065     UPRV_UNREACHABLE;</span>
1066 
1067     case START_LINE:
1068     {
<a name="16" id="anc16"></a><span class="line-modified">1069         UChar32 ch;</span>
1070         if (startPos == fAnchorStart) {
1071             MatchChunkAt(startPos, FALSE, status);
1072             if (U_FAILURE(status)) {
1073                 return FALSE;
1074             }
1075             if (fMatch) {
1076                 return TRUE;
1077             }
1078             U16_FWD_1(inputBuf, startPos, fActiveLimit);
1079         }
1080 
1081         if (fPattern-&gt;fFlags &amp; UREGEX_UNIX_LINES) {
1082             for (;;) {
<a name="17" id="anc17"></a><span class="line-modified">1083                 ch = inputBuf[startPos-1];</span>
<span class="line-modified">1084                 if (ch == 0x0a) {</span>
1085                     MatchChunkAt(startPos, FALSE, status);
1086                     if (U_FAILURE(status)) {
1087                         return FALSE;
1088                     }
1089                     if (fMatch) {
1090                         return TRUE;
1091                     }
1092                 }
1093                 if (startPos &gt;= testLen) {
1094                     fMatch = FALSE;
1095                     fHitEnd = TRUE;
1096                     return FALSE;
1097                 }
1098                 U16_FWD_1(inputBuf, startPos, fActiveLimit);
1099                 // Note that it&#39;s perfectly OK for a pattern to have a zero-length
1100                 //   match at the end of a string, so we must make sure that the loop
1101                 //   runs with startPos == testLen the last time through.
1102                 if  (findProgressInterrupt(startPos, status))
1103                     return FALSE;
1104             }
1105         } else {
1106             for (;;) {
<a name="18" id="anc18"></a><span class="line-modified">1107                 ch = inputBuf[startPos-1];</span>
<span class="line-modified">1108                 if (isLineTerminator(ch)) {</span>
<span class="line-modified">1109                     if (ch == 0x0d &amp;&amp; startPos &lt; fActiveLimit &amp;&amp; inputBuf[startPos] == 0x0a) {</span>
1110                         startPos++;
1111                     }
1112                     MatchChunkAt(startPos, FALSE, status);
1113                     if (U_FAILURE(status)) {
1114                         return FALSE;
1115                     }
1116                     if (fMatch) {
1117                         return TRUE;
1118                     }
1119                 }
1120                 if (startPos &gt;= testLen) {
1121                     fMatch = FALSE;
1122                     fHitEnd = TRUE;
1123                     return FALSE;
1124                 }
1125                 U16_FWD_1(inputBuf, startPos, fActiveLimit);
1126                 // Note that it&#39;s perfectly OK for a pattern to have a zero-length
1127                 //   match at the end of a string, so we must make sure that the loop
1128                 //   runs with startPos == testLen the last time through.
1129                 if  (findProgressInterrupt(startPos, status))
1130                     return FALSE;
1131             }
1132         }
1133     }
1134 
1135     default:
<a name="19" id="anc19"></a><span class="line-modified">1136         UPRV_UNREACHABLE;</span>
1137     }
1138 
<a name="20" id="anc20"></a><span class="line-modified">1139     UPRV_UNREACHABLE;</span>

1140 }
1141 
1142 
1143 
1144 //--------------------------------------------------------------------------------
1145 //
1146 //  group()
1147 //
1148 //--------------------------------------------------------------------------------
1149 UnicodeString RegexMatcher::group(UErrorCode &amp;status) const {
1150     return group(0, status);
1151 }
1152 
1153 //  Return immutable shallow clone
1154 UText *RegexMatcher::group(UText *dest, int64_t &amp;group_len, UErrorCode &amp;status) const {
1155     return group(0, dest, group_len, status);
1156 }
1157 
1158 //  Return immutable shallow clone
1159 UText *RegexMatcher::group(int32_t groupNum, UText *dest, int64_t &amp;group_len, UErrorCode &amp;status) const {
1160     group_len = 0;
1161     if (U_FAILURE(status)) {
1162         return dest;
1163     }
1164     if (U_FAILURE(fDeferredStatus)) {
1165         status = fDeferredStatus;
1166     } else if (fMatch == FALSE) {
1167         status = U_REGEX_INVALID_STATE;
1168     } else if (groupNum &lt; 0 || groupNum &gt; fPattern-&gt;fGroupMap-&gt;size()) {
1169         status = U_INDEX_OUTOFBOUNDS_ERROR;
1170     }
1171 
1172     if (U_FAILURE(status)) {
1173         return dest;
1174     }
1175 
1176     int64_t s, e;
1177     if (groupNum == 0) {
1178         s = fMatchStart;
1179         e = fMatchEnd;
1180     } else {
1181         int32_t groupOffset = fPattern-&gt;fGroupMap-&gt;elementAti(groupNum-1);
1182         U_ASSERT(groupOffset &lt; fPattern-&gt;fFrameSize);
1183         U_ASSERT(groupOffset &gt;= 0);
1184         s = fFrame-&gt;fExtra[groupOffset];
1185         e = fFrame-&gt;fExtra[groupOffset+1];
1186     }
1187 
1188     if (s &lt; 0) {
1189         // A capture group wasn&#39;t part of the match
1190         return utext_clone(dest, fInputText, FALSE, TRUE, &amp;status);
1191     }
1192     U_ASSERT(s &lt;= e);
1193     group_len = e - s;
1194 
1195     dest = utext_clone(dest, fInputText, FALSE, TRUE, &amp;status);
1196     if (dest)
1197         UTEXT_SETNATIVEINDEX(dest, s);
1198     return dest;
1199 }
1200 
1201 UnicodeString RegexMatcher::group(int32_t groupNum, UErrorCode &amp;status) const {
1202     UnicodeString result;
1203     int64_t groupStart = start64(groupNum, status);
1204     int64_t groupEnd = end64(groupNum, status);
1205     if (U_FAILURE(status) || groupStart == -1 || groupStart == groupEnd) {
1206         return result;
1207     }
1208 
1209     // Get the group length using a utext_extract preflight.
1210     //    UText is actually pretty efficient at this when underlying encoding is UTF-16.
1211     int32_t length = utext_extract(fInputText, groupStart, groupEnd, NULL, 0, &amp;status);
1212     if (status != U_BUFFER_OVERFLOW_ERROR) {
1213         return result;
1214     }
1215 
1216     status = U_ZERO_ERROR;
1217     UChar *buf = result.getBuffer(length);
1218     if (buf == NULL) {
1219         status = U_MEMORY_ALLOCATION_ERROR;
1220     } else {
1221         int32_t extractLength = utext_extract(fInputText, groupStart, groupEnd, buf, length, &amp;status);
1222         result.releaseBuffer(extractLength);
1223         U_ASSERT(length == extractLength);
1224     }
1225     return result;
1226 }
1227 
1228 
1229 //--------------------------------------------------------------------------------
1230 //
1231 //  appendGroup() -- currently internal only, appends a group to a UText rather
1232 //                   than replacing its contents
1233 //
1234 //--------------------------------------------------------------------------------
1235 
1236 int64_t RegexMatcher::appendGroup(int32_t groupNum, UText *dest, UErrorCode &amp;status) const {
1237     if (U_FAILURE(status)) {
1238         return 0;
1239     }
1240     if (U_FAILURE(fDeferredStatus)) {
1241         status = fDeferredStatus;
1242         return 0;
1243     }
1244     int64_t destLen = utext_nativeLength(dest);
1245 
1246     if (fMatch == FALSE) {
1247         status = U_REGEX_INVALID_STATE;
1248         return utext_replace(dest, destLen, destLen, NULL, 0, &amp;status);
1249     }
1250     if (groupNum &lt; 0 || groupNum &gt; fPattern-&gt;fGroupMap-&gt;size()) {
1251         status = U_INDEX_OUTOFBOUNDS_ERROR;
1252         return utext_replace(dest, destLen, destLen, NULL, 0, &amp;status);
1253     }
1254 
1255     int64_t s, e;
1256     if (groupNum == 0) {
1257         s = fMatchStart;
1258         e = fMatchEnd;
1259     } else {
1260         int32_t groupOffset = fPattern-&gt;fGroupMap-&gt;elementAti(groupNum-1);
1261         U_ASSERT(groupOffset &lt; fPattern-&gt;fFrameSize);
1262         U_ASSERT(groupOffset &gt;= 0);
1263         s = fFrame-&gt;fExtra[groupOffset];
1264         e = fFrame-&gt;fExtra[groupOffset+1];
1265     }
1266 
1267     if (s &lt; 0) {
1268         // A capture group wasn&#39;t part of the match
1269         return utext_replace(dest, destLen, destLen, NULL, 0, &amp;status);
1270     }
1271     U_ASSERT(s &lt;= e);
1272 
1273     int64_t deltaLen;
1274     if (UTEXT_FULL_TEXT_IN_CHUNK(fInputText, fInputLength)) {
1275         U_ASSERT(e &lt;= fInputLength);
1276         deltaLen = utext_replace(dest, destLen, destLen, fInputText-&gt;chunkContents+s, (int32_t)(e-s), &amp;status);
1277     } else {
1278         int32_t len16;
1279         if (UTEXT_USES_U16(fInputText)) {
1280             len16 = (int32_t)(e-s);
1281         } else {
1282             UErrorCode lengthStatus = U_ZERO_ERROR;
1283             len16 = utext_extract(fInputText, s, e, NULL, 0, &amp;lengthStatus);
1284         }
1285         UChar *groupChars = (UChar *)uprv_malloc(sizeof(UChar)*(len16+1));
1286         if (groupChars == NULL) {
1287             status = U_MEMORY_ALLOCATION_ERROR;
1288             return 0;
1289         }
1290         utext_extract(fInputText, s, e, groupChars, len16+1, &amp;status);
1291 
1292         deltaLen = utext_replace(dest, destLen, destLen, groupChars, len16, &amp;status);
1293         uprv_free(groupChars);
1294     }
1295     return deltaLen;
1296 }
1297 
1298 
1299 
1300 //--------------------------------------------------------------------------------
1301 //
1302 //  groupCount()
1303 //
1304 //--------------------------------------------------------------------------------
1305 int32_t RegexMatcher::groupCount() const {
1306     return fPattern-&gt;fGroupMap-&gt;size();
1307 }
1308 
1309 //--------------------------------------------------------------------------------
1310 //
1311 //  hasAnchoringBounds()
1312 //
1313 //--------------------------------------------------------------------------------
1314 UBool RegexMatcher::hasAnchoringBounds() const {
1315     return fAnchoringBounds;
1316 }
1317 
1318 
1319 //--------------------------------------------------------------------------------
1320 //
1321 //  hasTransparentBounds()
1322 //
1323 //--------------------------------------------------------------------------------
1324 UBool RegexMatcher::hasTransparentBounds() const {
1325     return fTransparentBounds;
1326 }
1327 
1328 
1329 
1330 //--------------------------------------------------------------------------------
1331 //
1332 //  hitEnd()
1333 //
1334 //--------------------------------------------------------------------------------
1335 UBool RegexMatcher::hitEnd() const {
1336     return fHitEnd;
1337 }
1338 
1339 
1340 //--------------------------------------------------------------------------------
1341 //
1342 //  input()
1343 //
1344 //--------------------------------------------------------------------------------
1345 const UnicodeString &amp;RegexMatcher::input() const {
1346     if (!fInput) {
1347         UErrorCode status = U_ZERO_ERROR;
1348         int32_t len16;
1349         if (UTEXT_USES_U16(fInputText)) {
1350             len16 = (int32_t)fInputLength;
1351         } else {
1352             len16 = utext_extract(fInputText, 0, fInputLength, NULL, 0, &amp;status);
1353             status = U_ZERO_ERROR; // overflow, length status
1354         }
1355         UnicodeString *result = new UnicodeString(len16, 0, 0);
1356 
1357         UChar *inputChars = result-&gt;getBuffer(len16);
1358         utext_extract(fInputText, 0, fInputLength, inputChars, len16, &amp;status); // unterminated warning
1359         result-&gt;releaseBuffer(len16);
1360 
1361         (*(const UnicodeString **)&amp;fInput) = result; // pointer assignment, rather than operator=
1362     }
1363 
1364     return *fInput;
1365 }
1366 
1367 //--------------------------------------------------------------------------------
1368 //
1369 //  inputText()
1370 //
1371 //--------------------------------------------------------------------------------
1372 UText *RegexMatcher::inputText() const {
1373     return fInputText;
1374 }
1375 
1376 
1377 //--------------------------------------------------------------------------------
1378 //
1379 //  getInput() -- like inputText(), but makes a clone or copies into another UText
1380 //
1381 //--------------------------------------------------------------------------------
1382 UText *RegexMatcher::getInput (UText *dest, UErrorCode &amp;status) const {
1383     if (U_FAILURE(status)) {
1384         return dest;
1385     }
1386     if (U_FAILURE(fDeferredStatus)) {
1387         status = fDeferredStatus;
1388         return dest;
1389     }
1390 
1391     if (dest) {
1392         if (UTEXT_FULL_TEXT_IN_CHUNK(fInputText, fInputLength)) {
1393             utext_replace(dest, 0, utext_nativeLength(dest), fInputText-&gt;chunkContents, (int32_t)fInputLength, &amp;status);
1394         } else {
1395             int32_t input16Len;
1396             if (UTEXT_USES_U16(fInputText)) {
1397                 input16Len = (int32_t)fInputLength;
1398             } else {
1399                 UErrorCode lengthStatus = U_ZERO_ERROR;
1400                 input16Len = utext_extract(fInputText, 0, fInputLength, NULL, 0, &amp;lengthStatus); // buffer overflow error
1401             }
1402             UChar *inputChars = (UChar *)uprv_malloc(sizeof(UChar)*(input16Len));
1403             if (inputChars == NULL) {
1404                 return dest;
1405             }
1406 
1407             status = U_ZERO_ERROR;
1408             utext_extract(fInputText, 0, fInputLength, inputChars, input16Len, &amp;status); // not terminated warning
1409             status = U_ZERO_ERROR;
1410             utext_replace(dest, 0, utext_nativeLength(dest), inputChars, input16Len, &amp;status);
1411 
1412             uprv_free(inputChars);
1413         }
1414         return dest;
1415     } else {
1416         return utext_clone(NULL, fInputText, FALSE, TRUE, &amp;status);
1417     }
1418 }
1419 
1420 
1421 static UBool compat_SyncMutableUTextContents(UText *ut);
1422 static UBool compat_SyncMutableUTextContents(UText *ut) {
1423     UBool retVal = FALSE;
1424 
1425     //  In the following test, we&#39;re really only interested in whether the UText should switch
1426     //  between heap and stack allocation.  If length hasn&#39;t changed, we won&#39;t, so the chunkContents
1427     //  will still point to the correct data.
1428     if (utext_nativeLength(ut) != ut-&gt;nativeIndexingLimit) {
1429         UnicodeString *us=(UnicodeString *)ut-&gt;context;
1430 
1431         // Update to the latest length.
1432         // For example, (utext_nativeLength(ut) != ut-&gt;nativeIndexingLimit).
1433         int32_t newLength = us-&gt;length();
1434 
1435         // Update the chunk description.
1436         // The buffer may have switched between stack- and heap-based.
1437         ut-&gt;chunkContents    = us-&gt;getBuffer();
1438         ut-&gt;chunkLength      = newLength;
1439         ut-&gt;chunkNativeLimit = newLength;
1440         ut-&gt;nativeIndexingLimit = newLength;
1441         retVal = TRUE;
1442     }
1443 
1444     return retVal;
1445 }
1446 
1447 //--------------------------------------------------------------------------------
1448 //
1449 //  lookingAt()
1450 //
1451 //--------------------------------------------------------------------------------
1452 UBool RegexMatcher::lookingAt(UErrorCode &amp;status) {
1453     if (U_FAILURE(status)) {
1454         return FALSE;
1455     }
1456     if (U_FAILURE(fDeferredStatus)) {
1457         status = fDeferredStatus;
1458         return FALSE;
1459     }
1460 
1461     if (fInputUniStrMaybeMutable) {
1462         if (compat_SyncMutableUTextContents(fInputText)) {
1463         fInputLength = utext_nativeLength(fInputText);
1464         reset();
1465         }
1466     }
1467     else {
1468         resetPreserveRegion();
1469     }
1470     if (UTEXT_FULL_TEXT_IN_CHUNK(fInputText, fInputLength)) {
1471         MatchChunkAt((int32_t)fActiveStart, FALSE, status);
1472     } else {
1473         MatchAt(fActiveStart, FALSE, status);
1474     }
1475     return fMatch;
1476 }
1477 
1478 
1479 UBool RegexMatcher::lookingAt(int64_t start, UErrorCode &amp;status) {
1480     if (U_FAILURE(status)) {
1481         return FALSE;
1482     }
1483     if (U_FAILURE(fDeferredStatus)) {
1484         status = fDeferredStatus;
1485         return FALSE;
1486     }
1487     reset();
1488 
1489     if (start &lt; 0) {
1490         status = U_INDEX_OUTOFBOUNDS_ERROR;
1491         return FALSE;
1492     }
1493 
1494     if (fInputUniStrMaybeMutable) {
1495         if (compat_SyncMutableUTextContents(fInputText)) {
1496         fInputLength = utext_nativeLength(fInputText);
1497         reset();
1498         }
1499     }
1500 
1501     int64_t nativeStart;
1502     nativeStart = start;
1503     if (nativeStart &lt; fActiveStart || nativeStart &gt; fActiveLimit) {
1504         status = U_INDEX_OUTOFBOUNDS_ERROR;
1505         return FALSE;
1506     }
1507 
1508     if (UTEXT_FULL_TEXT_IN_CHUNK(fInputText, fInputLength)) {
1509         MatchChunkAt((int32_t)nativeStart, FALSE, status);
1510     } else {
1511         MatchAt(nativeStart, FALSE, status);
1512     }
1513     return fMatch;
1514 }
1515 
1516 
1517 
1518 //--------------------------------------------------------------------------------
1519 //
1520 //  matches()
1521 //
1522 //--------------------------------------------------------------------------------
1523 UBool RegexMatcher::matches(UErrorCode &amp;status) {
1524     if (U_FAILURE(status)) {
1525         return FALSE;
1526     }
1527     if (U_FAILURE(fDeferredStatus)) {
1528         status = fDeferredStatus;
1529         return FALSE;
1530     }
1531 
1532     if (fInputUniStrMaybeMutable) {
1533         if (compat_SyncMutableUTextContents(fInputText)) {
1534         fInputLength = utext_nativeLength(fInputText);
1535         reset();
1536         }
1537     }
1538     else {
1539         resetPreserveRegion();
1540     }
1541 
1542     if (UTEXT_FULL_TEXT_IN_CHUNK(fInputText, fInputLength)) {
1543         MatchChunkAt((int32_t)fActiveStart, TRUE, status);
1544     } else {
1545         MatchAt(fActiveStart, TRUE, status);
1546     }
1547     return fMatch;
1548 }
1549 
1550 
1551 UBool RegexMatcher::matches(int64_t start, UErrorCode &amp;status) {
1552     if (U_FAILURE(status)) {
1553         return FALSE;
1554     }
1555     if (U_FAILURE(fDeferredStatus)) {
1556         status = fDeferredStatus;
1557         return FALSE;
1558     }
1559     reset();
1560 
1561     if (start &lt; 0) {
1562         status = U_INDEX_OUTOFBOUNDS_ERROR;
1563         return FALSE;
1564     }
1565 
1566     if (fInputUniStrMaybeMutable) {
1567         if (compat_SyncMutableUTextContents(fInputText)) {
1568         fInputLength = utext_nativeLength(fInputText);
1569         reset();
1570         }
1571     }
1572 
1573     int64_t nativeStart;
1574     nativeStart = start;
1575     if (nativeStart &lt; fActiveStart || nativeStart &gt; fActiveLimit) {
1576         status = U_INDEX_OUTOFBOUNDS_ERROR;
1577         return FALSE;
1578     }
1579 
1580     if (UTEXT_FULL_TEXT_IN_CHUNK(fInputText, fInputLength)) {
1581         MatchChunkAt((int32_t)nativeStart, TRUE, status);
1582     } else {
1583         MatchAt(nativeStart, TRUE, status);
1584     }
1585     return fMatch;
1586 }
1587 
1588 
1589 
1590 //--------------------------------------------------------------------------------
1591 //
1592 //    pattern
1593 //
1594 //--------------------------------------------------------------------------------
1595 const RegexPattern &amp;RegexMatcher::pattern() const {
1596     return *fPattern;
1597 }
1598 
1599 
1600 
1601 //--------------------------------------------------------------------------------
1602 //
1603 //    region
1604 //
1605 //--------------------------------------------------------------------------------
1606 RegexMatcher &amp;RegexMatcher::region(int64_t regionStart, int64_t regionLimit, int64_t startIndex, UErrorCode &amp;status) {
1607     if (U_FAILURE(status)) {
1608         return *this;
1609     }
1610 
1611     if (regionStart&gt;regionLimit || regionStart&lt;0 || regionLimit&lt;0) {
1612         status = U_ILLEGAL_ARGUMENT_ERROR;
1613     }
1614 
1615     int64_t nativeStart = regionStart;
1616     int64_t nativeLimit = regionLimit;
1617     if (nativeStart &gt; fInputLength || nativeLimit &gt; fInputLength) {
1618       status = U_ILLEGAL_ARGUMENT_ERROR;
1619     }
1620 
1621     if (startIndex == -1)
1622       this-&gt;reset();
1623     else
1624       resetPreserveRegion();
1625 
1626     fRegionStart = nativeStart;
1627     fRegionLimit = nativeLimit;
1628     fActiveStart = nativeStart;
1629     fActiveLimit = nativeLimit;
1630 
1631     if (startIndex != -1) {
1632       if (startIndex &lt; fActiveStart || startIndex &gt; fActiveLimit) {
1633           status = U_INDEX_OUTOFBOUNDS_ERROR;
1634       }
1635       fMatchEnd = startIndex;
1636     }
1637 
1638     if (!fTransparentBounds) {
1639         fLookStart = nativeStart;
1640         fLookLimit = nativeLimit;
1641     }
1642     if (fAnchoringBounds) {
1643         fAnchorStart = nativeStart;
1644         fAnchorLimit = nativeLimit;
1645     }
1646     return *this;
1647 }
1648 
1649 RegexMatcher &amp;RegexMatcher::region(int64_t start, int64_t limit, UErrorCode &amp;status) {
1650   return region(start, limit, -1, status);
1651 }
1652 
1653 //--------------------------------------------------------------------------------
1654 //
1655 //    regionEnd
1656 //
1657 //--------------------------------------------------------------------------------
1658 int32_t RegexMatcher::regionEnd() const {
1659     return (int32_t)fRegionLimit;
1660 }
1661 
1662 int64_t RegexMatcher::regionEnd64() const {
1663     return fRegionLimit;
1664 }
1665 
1666 //--------------------------------------------------------------------------------
1667 //
1668 //    regionStart
1669 //
1670 //--------------------------------------------------------------------------------
1671 int32_t RegexMatcher::regionStart() const {
1672     return (int32_t)fRegionStart;
1673 }
1674 
1675 int64_t RegexMatcher::regionStart64() const {
1676     return fRegionStart;
1677 }
1678 
1679 
1680 //--------------------------------------------------------------------------------
1681 //
1682 //    replaceAll
1683 //
1684 //--------------------------------------------------------------------------------
1685 UnicodeString RegexMatcher::replaceAll(const UnicodeString &amp;replacement, UErrorCode &amp;status) {
1686     UText replacementText = UTEXT_INITIALIZER;
1687     UText resultText = UTEXT_INITIALIZER;
1688     UnicodeString resultString;
1689     if (U_FAILURE(status)) {
1690         return resultString;
1691     }
1692 
1693     utext_openConstUnicodeString(&amp;replacementText, &amp;replacement, &amp;status);
1694     utext_openUnicodeString(&amp;resultText, &amp;resultString, &amp;status);
1695 
1696     replaceAll(&amp;replacementText, &amp;resultText, status);
1697 
1698     utext_close(&amp;resultText);
1699     utext_close(&amp;replacementText);
1700 
1701     return resultString;
1702 }
1703 
1704 
1705 //
1706 //    replaceAll, UText mode
1707 //
1708 UText *RegexMatcher::replaceAll(UText *replacement, UText *dest, UErrorCode &amp;status) {
1709     if (U_FAILURE(status)) {
1710         return dest;
1711     }
1712     if (U_FAILURE(fDeferredStatus)) {
1713         status = fDeferredStatus;
1714         return dest;
1715     }
1716 
1717     if (dest == NULL) {
1718         UnicodeString emptyString;
1719         UText empty = UTEXT_INITIALIZER;
1720 
1721         utext_openUnicodeString(&amp;empty, &amp;emptyString, &amp;status);
1722         dest = utext_clone(NULL, &amp;empty, TRUE, FALSE, &amp;status);
1723         utext_close(&amp;empty);
1724     }
1725 
1726     if (U_SUCCESS(status)) {
1727         reset();
1728         while (find()) {
1729             appendReplacement(dest, replacement, status);
1730             if (U_FAILURE(status)) {
1731                 break;
1732             }
1733         }
1734         appendTail(dest, status);
1735     }
1736 
1737     return dest;
1738 }
1739 
1740 
1741 //--------------------------------------------------------------------------------
1742 //
1743 //    replaceFirst
1744 //
1745 //--------------------------------------------------------------------------------
1746 UnicodeString RegexMatcher::replaceFirst(const UnicodeString &amp;replacement, UErrorCode &amp;status) {
1747     UText replacementText = UTEXT_INITIALIZER;
1748     UText resultText = UTEXT_INITIALIZER;
1749     UnicodeString resultString;
1750 
1751     utext_openConstUnicodeString(&amp;replacementText, &amp;replacement, &amp;status);
1752     utext_openUnicodeString(&amp;resultText, &amp;resultString, &amp;status);
1753 
1754     replaceFirst(&amp;replacementText, &amp;resultText, status);
1755 
1756     utext_close(&amp;resultText);
1757     utext_close(&amp;replacementText);
1758 
1759     return resultString;
1760 }
1761 
1762 //
1763 //    replaceFirst, UText mode
1764 //
1765 UText *RegexMatcher::replaceFirst(UText *replacement, UText *dest, UErrorCode &amp;status) {
1766     if (U_FAILURE(status)) {
1767         return dest;
1768     }
1769     if (U_FAILURE(fDeferredStatus)) {
1770         status = fDeferredStatus;
1771         return dest;
1772     }
1773 
1774     reset();
1775     if (!find()) {
1776         return getInput(dest, status);
1777     }
1778 
1779     if (dest == NULL) {
1780         UnicodeString emptyString;
1781         UText empty = UTEXT_INITIALIZER;
1782 
1783         utext_openUnicodeString(&amp;empty, &amp;emptyString, &amp;status);
1784         dest = utext_clone(NULL, &amp;empty, TRUE, FALSE, &amp;status);
1785         utext_close(&amp;empty);
1786     }
1787 
1788     appendReplacement(dest, replacement, status);
1789     appendTail(dest, status);
1790 
1791     return dest;
1792 }
1793 
1794 
1795 //--------------------------------------------------------------------------------
1796 //
1797 //     requireEnd
1798 //
1799 //--------------------------------------------------------------------------------
1800 UBool RegexMatcher::requireEnd() const {
1801     return fRequireEnd;
1802 }
1803 
1804 
1805 //--------------------------------------------------------------------------------
1806 //
1807 //     reset
1808 //
1809 //--------------------------------------------------------------------------------
1810 RegexMatcher &amp;RegexMatcher::reset() {
1811     fRegionStart    = 0;
1812     fRegionLimit    = fInputLength;
1813     fActiveStart    = 0;
1814     fActiveLimit    = fInputLength;
1815     fAnchorStart    = 0;
1816     fAnchorLimit    = fInputLength;
1817     fLookStart      = 0;
1818     fLookLimit      = fInputLength;
1819     resetPreserveRegion();
1820     return *this;
1821 }
1822 
1823 
1824 
1825 void RegexMatcher::resetPreserveRegion() {
1826     fMatchStart     = 0;
1827     fMatchEnd       = 0;
1828     fLastMatchEnd   = -1;
1829     fAppendPosition = 0;
1830     fMatch          = FALSE;
1831     fHitEnd         = FALSE;
1832     fRequireEnd     = FALSE;
1833     fTime           = 0;
1834     fTickCounter    = TIMER_INITIAL_VALUE;
1835     //resetStack(); // more expensive than it looks...
1836 }
1837 
1838 
1839 RegexMatcher &amp;RegexMatcher::reset(const UnicodeString &amp;input) {
1840     fInputText = utext_openConstUnicodeString(fInputText, &amp;input, &amp;fDeferredStatus);
1841     if (fPattern-&gt;fNeedsAltInput) {
1842         fAltInputText = utext_clone(fAltInputText, fInputText, FALSE, TRUE, &amp;fDeferredStatus);
1843     }
1844     if (U_FAILURE(fDeferredStatus)) {
1845         return *this;
1846     }
1847     fInputLength = utext_nativeLength(fInputText);
1848 
1849     reset();
1850     delete fInput;
1851     fInput = NULL;
1852 
1853     //  Do the following for any UnicodeString.
1854     //  This is for compatibility for those clients who modify the input string &quot;live&quot; during regex operations.
1855     fInputUniStrMaybeMutable = TRUE;
1856 
1857     if (fWordBreakItr != NULL) {
1858 #if UCONFIG_NO_BREAK_ITERATION==0
1859         UErrorCode status = U_ZERO_ERROR;
1860         fWordBreakItr-&gt;setText(fInputText, status);
1861 #endif
1862     }
1863     return *this;
1864 }
1865 
1866 
1867 RegexMatcher &amp;RegexMatcher::reset(UText *input) {
1868     if (fInputText != input) {
1869         fInputText = utext_clone(fInputText, input, FALSE, TRUE, &amp;fDeferredStatus);
1870         if (fPattern-&gt;fNeedsAltInput) fAltInputText = utext_clone(fAltInputText, fInputText, FALSE, TRUE, &amp;fDeferredStatus);
1871         if (U_FAILURE(fDeferredStatus)) {
1872             return *this;
1873         }
1874         fInputLength = utext_nativeLength(fInputText);
1875 
1876         delete fInput;
1877         fInput = NULL;
1878 
1879         if (fWordBreakItr != NULL) {
1880 #if UCONFIG_NO_BREAK_ITERATION==0
1881             UErrorCode status = U_ZERO_ERROR;
1882             fWordBreakItr-&gt;setText(input, status);
1883 #endif
1884         }
1885     }
1886     reset();
1887     fInputUniStrMaybeMutable = FALSE;
1888 
1889     return *this;
1890 }
1891 
1892 /*RegexMatcher &amp;RegexMatcher::reset(const UChar *) {
1893     fDeferredStatus = U_INTERNAL_PROGRAM_ERROR;
1894     return *this;
1895 }*/
1896 
1897 RegexMatcher &amp;RegexMatcher::reset(int64_t position, UErrorCode &amp;status) {
1898     if (U_FAILURE(status)) {
1899         return *this;
1900     }
1901     reset();       // Reset also resets the region to be the entire string.
1902 
1903     if (position &lt; 0 || position &gt; fActiveLimit) {
1904         status = U_INDEX_OUTOFBOUNDS_ERROR;
1905         return *this;
1906     }
1907     fMatchEnd = position;
1908     return *this;
1909 }
1910 
1911 
1912 //--------------------------------------------------------------------------------
1913 //
1914 //    refresh
1915 //
1916 //--------------------------------------------------------------------------------
1917 RegexMatcher &amp;RegexMatcher::refreshInputText(UText *input, UErrorCode &amp;status) {
1918     if (U_FAILURE(status)) {
1919         return *this;
1920     }
1921     if (input == NULL) {
1922         status = U_ILLEGAL_ARGUMENT_ERROR;
1923         return *this;
1924     }
1925     if (utext_nativeLength(fInputText) != utext_nativeLength(input)) {
1926         status = U_ILLEGAL_ARGUMENT_ERROR;
1927         return *this;
1928     }
1929     int64_t  pos = utext_getNativeIndex(fInputText);
1930     //  Shallow read-only clone of the new UText into the existing input UText
1931     fInputText = utext_clone(fInputText, input, FALSE, TRUE, &amp;status);
1932     if (U_FAILURE(status)) {
1933         return *this;
1934     }
1935     utext_setNativeIndex(fInputText, pos);
1936 
1937     if (fAltInputText != NULL) {
1938         pos = utext_getNativeIndex(fAltInputText);
1939         fAltInputText = utext_clone(fAltInputText, input, FALSE, TRUE, &amp;status);
1940         if (U_FAILURE(status)) {
1941             return *this;
1942         }
1943         utext_setNativeIndex(fAltInputText, pos);
1944     }
1945     return *this;
1946 }
1947 
1948 
1949 
1950 //--------------------------------------------------------------------------------
1951 //
1952 //    setTrace
1953 //
1954 //--------------------------------------------------------------------------------
1955 void RegexMatcher::setTrace(UBool state) {
1956     fTraceDebug = state;
1957 }
1958 
1959 
1960 
1961 /**
1962   *  UText, replace entire contents of the destination UText with a substring of the source UText.
1963   *
1964   *     @param src    The source UText
1965   *     @param dest   The destination UText. Must be writable.
1966   *                   May be NULL, in which case a new UText will be allocated.
1967   *     @param start  Start index of source substring.
1968   *     @param limit  Limit index of source substring.
1969   *     @param status An error code.
1970   */
1971 static UText *utext_extract_replace(UText *src, UText *dest, int64_t start, int64_t limit, UErrorCode *status) {
1972     if (U_FAILURE(*status)) {
1973         return dest;
1974     }
1975     if (start == limit) {
1976         if (dest) {
1977             utext_replace(dest, 0, utext_nativeLength(dest), NULL, 0, status);
1978             return dest;
1979         } else {
1980             return utext_openUChars(NULL, NULL, 0, status);
1981         }
1982     }
1983     int32_t length = utext_extract(src, start, limit, NULL, 0, status);
1984     if (*status != U_BUFFER_OVERFLOW_ERROR &amp;&amp; U_FAILURE(*status)) {
1985         return dest;
1986     }
1987     *status = U_ZERO_ERROR;
1988     MaybeStackArray&lt;UChar, 40&gt; buffer;
1989     if (length &gt;= buffer.getCapacity()) {
1990         UChar *newBuf = buffer.resize(length+1);   // Leave space for terminating Nul.
1991         if (newBuf == NULL) {
1992             *status = U_MEMORY_ALLOCATION_ERROR;
1993         }
1994     }
1995     utext_extract(src, start, limit, buffer.getAlias(), length+1, status);
1996     if (dest) {
1997         utext_replace(dest, 0, utext_nativeLength(dest), buffer.getAlias(), length, status);
1998         return dest;
1999     }
2000 
2001     // Caller did not provide a prexisting UText.
2002     // Open a new one, and have it adopt the text buffer storage.
2003     if (U_FAILURE(*status)) {
2004         return NULL;
2005     }
2006     int32_t ownedLength = 0;
2007     UChar *ownedBuf = buffer.orphanOrClone(length+1, ownedLength);
2008     if (ownedBuf == NULL) {
2009         *status = U_MEMORY_ALLOCATION_ERROR;
2010         return NULL;
2011     }
2012     UText *result = utext_openUChars(NULL, ownedBuf, length, status);
2013     if (U_FAILURE(*status)) {
2014         uprv_free(ownedBuf);
2015         return NULL;
2016     }
2017     result-&gt;providerProperties |= (1 &lt;&lt; UTEXT_PROVIDER_OWNS_TEXT);
2018     return result;
2019 }
2020 
2021 
2022 //---------------------------------------------------------------------
2023 //
2024 //   split
2025 //
2026 //---------------------------------------------------------------------
2027 int32_t  RegexMatcher::split(const UnicodeString &amp;input,
2028         UnicodeString    dest[],
2029         int32_t          destCapacity,
2030         UErrorCode      &amp;status)
2031 {
2032     UText inputText = UTEXT_INITIALIZER;
2033     utext_openConstUnicodeString(&amp;inputText, &amp;input, &amp;status);
2034     if (U_FAILURE(status)) {
2035         return 0;
2036     }
2037 
2038     UText **destText = (UText **)uprv_malloc(sizeof(UText*)*destCapacity);
2039     if (destText == NULL) {
2040         status = U_MEMORY_ALLOCATION_ERROR;
2041         return 0;
2042     }
2043     int32_t i;
2044     for (i = 0; i &lt; destCapacity; i++) {
2045         destText[i] = utext_openUnicodeString(NULL, &amp;dest[i], &amp;status);
2046     }
2047 
2048     int32_t fieldCount = split(&amp;inputText, destText, destCapacity, status);
2049 
2050     for (i = 0; i &lt; destCapacity; i++) {
2051         utext_close(destText[i]);
2052     }
2053 
2054     uprv_free(destText);
2055     utext_close(&amp;inputText);
2056     return fieldCount;
2057 }
2058 
2059 //
2060 //   split, UText mode
2061 //
2062 int32_t  RegexMatcher::split(UText *input,
2063         UText           *dest[],
2064         int32_t          destCapacity,
2065         UErrorCode      &amp;status)
2066 {
2067     //
2068     // Check arguements for validity
2069     //
2070     if (U_FAILURE(status)) {
2071         return 0;
2072     };
2073 
2074     if (destCapacity &lt; 1) {
2075         status = U_ILLEGAL_ARGUMENT_ERROR;
2076         return 0;
2077     }
2078 
2079     //
2080     // Reset for the input text
2081     //
2082     reset(input);
2083     int64_t   nextOutputStringStart = 0;
2084     if (fActiveLimit == 0) {
2085         return 0;
2086     }
2087 
2088     //
2089     // Loop through the input text, searching for the delimiter pattern
2090     //
2091     int32_t i;
2092     int32_t numCaptureGroups = fPattern-&gt;fGroupMap-&gt;size();
2093     for (i=0; ; i++) {
2094         if (i&gt;=destCapacity-1) {
2095             // There is one or zero output string left.
2096             // Fill the last output string with whatever is left from the input, then exit the loop.
2097             //  ( i will be == destCapacity if we filled the output array while processing
2098             //    capture groups of the delimiter expression, in which case we will discard the
2099             //    last capture group saved in favor of the unprocessed remainder of the
2100             //    input string.)
2101             i = destCapacity-1;
2102             if (fActiveLimit &gt; nextOutputStringStart) {
2103                 if (UTEXT_FULL_TEXT_IN_CHUNK(input, fInputLength)) {
2104                     if (dest[i]) {
2105                         utext_replace(dest[i], 0, utext_nativeLength(dest[i]),
2106                                       input-&gt;chunkContents+nextOutputStringStart,
2107                                       (int32_t)(fActiveLimit-nextOutputStringStart), &amp;status);
2108                     } else {
2109                         UText remainingText = UTEXT_INITIALIZER;
2110                         utext_openUChars(&amp;remainingText, input-&gt;chunkContents+nextOutputStringStart,
2111                                          fActiveLimit-nextOutputStringStart, &amp;status);
2112                         dest[i] = utext_clone(NULL, &amp;remainingText, TRUE, FALSE, &amp;status);
2113                         utext_close(&amp;remainingText);
2114                     }
2115                 } else {
2116                     UErrorCode lengthStatus = U_ZERO_ERROR;
2117                     int32_t remaining16Length =
2118                         utext_extract(input, nextOutputStringStart, fActiveLimit, NULL, 0, &amp;lengthStatus);
2119                     UChar *remainingChars = (UChar *)uprv_malloc(sizeof(UChar)*(remaining16Length+1));
2120                     if (remainingChars == NULL) {
2121                         status = U_MEMORY_ALLOCATION_ERROR;
2122                         break;
2123                     }
2124 
2125                     utext_extract(input, nextOutputStringStart, fActiveLimit, remainingChars, remaining16Length+1, &amp;status);
2126                     if (dest[i]) {
2127                         utext_replace(dest[i], 0, utext_nativeLength(dest[i]), remainingChars, remaining16Length, &amp;status);
2128                     } else {
2129                         UText remainingText = UTEXT_INITIALIZER;
2130                         utext_openUChars(&amp;remainingText, remainingChars, remaining16Length, &amp;status);
2131                         dest[i] = utext_clone(NULL, &amp;remainingText, TRUE, FALSE, &amp;status);
2132                         utext_close(&amp;remainingText);
2133                     }
2134 
2135                     uprv_free(remainingChars);
2136                 }
2137             }
2138             break;
2139         }
2140         if (find()) {
2141             // We found another delimiter.  Move everything from where we started looking
2142             //  up until the start of the delimiter into the next output string.
2143             if (UTEXT_FULL_TEXT_IN_CHUNK(input, fInputLength)) {
2144                 if (dest[i]) {
2145                     utext_replace(dest[i], 0, utext_nativeLength(dest[i]),
2146                                   input-&gt;chunkContents+nextOutputStringStart,
2147                                   (int32_t)(fMatchStart-nextOutputStringStart), &amp;status);
2148                 } else {
2149                     UText remainingText = UTEXT_INITIALIZER;
2150                     utext_openUChars(&amp;remainingText, input-&gt;chunkContents+nextOutputStringStart,
2151                                       fMatchStart-nextOutputStringStart, &amp;status);
2152                     dest[i] = utext_clone(NULL, &amp;remainingText, TRUE, FALSE, &amp;status);
2153                     utext_close(&amp;remainingText);
2154                 }
2155             } else {
2156                 UErrorCode lengthStatus = U_ZERO_ERROR;
2157                 int32_t remaining16Length = utext_extract(input, nextOutputStringStart, fMatchStart, NULL, 0, &amp;lengthStatus);
2158                 UChar *remainingChars = (UChar *)uprv_malloc(sizeof(UChar)*(remaining16Length+1));
2159                 if (remainingChars == NULL) {
2160                     status = U_MEMORY_ALLOCATION_ERROR;
2161                     break;
2162                 }
2163                 utext_extract(input, nextOutputStringStart, fMatchStart, remainingChars, remaining16Length+1, &amp;status);
2164                 if (dest[i]) {
2165                     utext_replace(dest[i], 0, utext_nativeLength(dest[i]), remainingChars, remaining16Length, &amp;status);
2166                 } else {
2167                     UText remainingText = UTEXT_INITIALIZER;
2168                     utext_openUChars(&amp;remainingText, remainingChars, remaining16Length, &amp;status);
2169                     dest[i] = utext_clone(NULL, &amp;remainingText, TRUE, FALSE, &amp;status);
2170                     utext_close(&amp;remainingText);
2171                 }
2172 
2173                 uprv_free(remainingChars);
2174             }
2175             nextOutputStringStart = fMatchEnd;
2176 
2177             // If the delimiter pattern has capturing parentheses, the captured
2178             //  text goes out into the next n destination strings.
2179             int32_t groupNum;
2180             for (groupNum=1; groupNum&lt;=numCaptureGroups; groupNum++) {
2181                 if (i &gt;= destCapacity-2) {
2182                     // Never fill the last available output string with capture group text.
2183                     // It will filled with the last field, the remainder of the
2184                     //  unsplit input text.
2185                     break;
2186                 }
2187                 i++;
2188                 dest[i] = utext_extract_replace(fInputText, dest[i],
2189                                                start64(groupNum, status), end64(groupNum, status), &amp;status);
2190             }
2191 
2192             if (nextOutputStringStart == fActiveLimit) {
2193                 // The delimiter was at the end of the string.  We&#39;re done, but first
2194                 // we output one last empty string, for the empty field following
2195                 //   the delimiter at the end of input.
2196                 if (i+1 &lt; destCapacity) {
2197                     ++i;
2198                     if (dest[i] == NULL) {
2199                         dest[i] = utext_openUChars(NULL, NULL, 0, &amp;status);
2200                     } else {
2201                         static const UChar emptyString[] = {(UChar)0};
2202                         utext_replace(dest[i], 0, utext_nativeLength(dest[i]), emptyString, 0, &amp;status);
2203                     }
2204                 }
2205                 break;
2206 
2207             }
2208         }
2209         else
2210         {
2211             // We ran off the end of the input while looking for the next delimiter.
2212             // All the remaining text goes into the current output string.
2213             if (UTEXT_FULL_TEXT_IN_CHUNK(input, fInputLength)) {
2214                 if (dest[i]) {
2215                     utext_replace(dest[i], 0, utext_nativeLength(dest[i]),
2216                                   input-&gt;chunkContents+nextOutputStringStart,
2217                                   (int32_t)(fActiveLimit-nextOutputStringStart), &amp;status);
2218                 } else {
2219                     UText remainingText = UTEXT_INITIALIZER;
2220                     utext_openUChars(&amp;remainingText, input-&gt;chunkContents+nextOutputStringStart,
2221                                      fActiveLimit-nextOutputStringStart, &amp;status);
2222                     dest[i] = utext_clone(NULL, &amp;remainingText, TRUE, FALSE, &amp;status);
2223                     utext_close(&amp;remainingText);
2224                 }
2225             } else {
2226                 UErrorCode lengthStatus = U_ZERO_ERROR;
2227                 int32_t remaining16Length = utext_extract(input, nextOutputStringStart, fActiveLimit, NULL, 0, &amp;lengthStatus);
2228                 UChar *remainingChars = (UChar *)uprv_malloc(sizeof(UChar)*(remaining16Length+1));
2229                 if (remainingChars == NULL) {
2230                     status = U_MEMORY_ALLOCATION_ERROR;
2231                     break;
2232                 }
2233 
2234                 utext_extract(input, nextOutputStringStart, fActiveLimit, remainingChars, remaining16Length+1, &amp;status);
2235                 if (dest[i]) {
2236                     utext_replace(dest[i], 0, utext_nativeLength(dest[i]), remainingChars, remaining16Length, &amp;status);
2237                 } else {
2238                     UText remainingText = UTEXT_INITIALIZER;
2239                     utext_openUChars(&amp;remainingText, remainingChars, remaining16Length, &amp;status);
2240                     dest[i] = utext_clone(NULL, &amp;remainingText, TRUE, FALSE, &amp;status);
2241                     utext_close(&amp;remainingText);
2242                 }
2243 
2244                 uprv_free(remainingChars);
2245             }
2246             break;
2247         }
2248         if (U_FAILURE(status)) {
2249             break;
2250         }
2251     }   // end of for loop
2252     return i+1;
2253 }
2254 
2255 
2256 //--------------------------------------------------------------------------------
2257 //
2258 //     start
2259 //
2260 //--------------------------------------------------------------------------------
2261 int32_t RegexMatcher::start(UErrorCode &amp;status) const {
2262     return start(0, status);
2263 }
2264 
2265 int64_t RegexMatcher::start64(UErrorCode &amp;status) const {
2266     return start64(0, status);
2267 }
2268 
2269 //--------------------------------------------------------------------------------
2270 //
2271 //     start(int32_t group, UErrorCode &amp;status)
2272 //
2273 //--------------------------------------------------------------------------------
2274 
2275 int64_t RegexMatcher::start64(int32_t group, UErrorCode &amp;status) const {
2276     if (U_FAILURE(status)) {
2277         return -1;
2278     }
2279     if (U_FAILURE(fDeferredStatus)) {
2280         status = fDeferredStatus;
2281         return -1;
2282     }
2283     if (fMatch == FALSE) {
2284         status = U_REGEX_INVALID_STATE;
2285         return -1;
2286     }
2287     if (group &lt; 0 || group &gt; fPattern-&gt;fGroupMap-&gt;size()) {
2288         status = U_INDEX_OUTOFBOUNDS_ERROR;
2289         return -1;
2290     }
2291     int64_t s;
2292     if (group == 0) {
2293         s = fMatchStart;
2294     } else {
2295         int32_t groupOffset = fPattern-&gt;fGroupMap-&gt;elementAti(group-1);
2296         U_ASSERT(groupOffset &lt; fPattern-&gt;fFrameSize);
2297         U_ASSERT(groupOffset &gt;= 0);
2298         s = fFrame-&gt;fExtra[groupOffset];
2299     }
2300 
2301     return s;
2302 }
2303 
2304 
2305 int32_t RegexMatcher::start(int32_t group, UErrorCode &amp;status) const {
2306     return (int32_t)start64(group, status);
2307 }
2308 
2309 //--------------------------------------------------------------------------------
2310 //
2311 //     useAnchoringBounds
2312 //
2313 //--------------------------------------------------------------------------------
2314 RegexMatcher &amp;RegexMatcher::useAnchoringBounds(UBool b) {
2315     fAnchoringBounds = b;
2316     fAnchorStart = (fAnchoringBounds ? fRegionStart : 0);
2317     fAnchorLimit = (fAnchoringBounds ? fRegionLimit : fInputLength);
2318     return *this;
2319 }
2320 
2321 
2322 //--------------------------------------------------------------------------------
2323 //
2324 //     useTransparentBounds
2325 //
2326 //--------------------------------------------------------------------------------
2327 RegexMatcher &amp;RegexMatcher::useTransparentBounds(UBool b) {
2328     fTransparentBounds = b;
2329     fLookStart = (fTransparentBounds ? 0 : fRegionStart);
2330     fLookLimit = (fTransparentBounds ? fInputLength : fRegionLimit);
2331     return *this;
2332 }
2333 
2334 //--------------------------------------------------------------------------------
2335 //
2336 //     setTimeLimit
2337 //
2338 //--------------------------------------------------------------------------------
2339 void RegexMatcher::setTimeLimit(int32_t limit, UErrorCode &amp;status) {
2340     if (U_FAILURE(status)) {
2341         return;
2342     }
2343     if (U_FAILURE(fDeferredStatus)) {
2344         status = fDeferredStatus;
2345         return;
2346     }
2347     if (limit &lt; 0) {
2348         status = U_ILLEGAL_ARGUMENT_ERROR;
2349         return;
2350     }
2351     fTimeLimit = limit;
2352 }
2353 
2354 
2355 //--------------------------------------------------------------------------------
2356 //
2357 //     getTimeLimit
2358 //
2359 //--------------------------------------------------------------------------------
2360 int32_t RegexMatcher::getTimeLimit() const {
2361     return fTimeLimit;
2362 }
2363 
2364 
2365 //--------------------------------------------------------------------------------
2366 //
2367 //     setStackLimit
2368 //
2369 //--------------------------------------------------------------------------------
2370 void RegexMatcher::setStackLimit(int32_t limit, UErrorCode &amp;status) {
2371     if (U_FAILURE(status)) {
2372         return;
2373     }
2374     if (U_FAILURE(fDeferredStatus)) {
2375         status = fDeferredStatus;
2376         return;
2377     }
2378     if (limit &lt; 0) {
2379         status = U_ILLEGAL_ARGUMENT_ERROR;
2380         return;
2381     }
2382 
2383     // Reset the matcher.  This is needed here in case there is a current match
2384     //    whose final stack frame (containing the match results, pointed to by fFrame)
2385     //    would be lost by resizing to a smaller stack size.
2386     reset();
2387 
2388     if (limit == 0) {
2389         // Unlimited stack expansion
2390         fStack-&gt;setMaxCapacity(0);
2391     } else {
2392         // Change the units of the limit  from bytes to ints, and bump the size up
2393         //   to be big enough to hold at least one stack frame for the pattern,
2394         //   if it isn&#39;t there already.
2395         int32_t adjustedLimit = limit / sizeof(int32_t);
2396         if (adjustedLimit &lt; fPattern-&gt;fFrameSize) {
2397             adjustedLimit = fPattern-&gt;fFrameSize;
2398         }
2399         fStack-&gt;setMaxCapacity(adjustedLimit);
2400     }
2401     fStackLimit = limit;
2402 }
2403 
2404 
2405 //--------------------------------------------------------------------------------
2406 //
2407 //     getStackLimit
2408 //
2409 //--------------------------------------------------------------------------------
2410 int32_t RegexMatcher::getStackLimit() const {
2411     return fStackLimit;
2412 }
2413 
2414 
2415 //--------------------------------------------------------------------------------
2416 //
2417 //     setMatchCallback
2418 //
2419 //--------------------------------------------------------------------------------
2420 void RegexMatcher::setMatchCallback(URegexMatchCallback     *callback,
2421                                     const void              *context,
2422                                     UErrorCode              &amp;status) {
2423     if (U_FAILURE(status)) {
2424         return;
2425     }
2426     fCallbackFn = callback;
2427     fCallbackContext = context;
2428 }
2429 
2430 
2431 //--------------------------------------------------------------------------------
2432 //
2433 //     getMatchCallback
2434 //
2435 //--------------------------------------------------------------------------------
2436 void RegexMatcher::getMatchCallback(URegexMatchCallback   *&amp;callback,
2437                                   const void              *&amp;context,
2438                                   UErrorCode              &amp;status) {
2439     if (U_FAILURE(status)) {
2440        return;
2441     }
2442     callback = fCallbackFn;
2443     context  = fCallbackContext;
2444 }
2445 
2446 
2447 //--------------------------------------------------------------------------------
2448 //
2449 //     setMatchCallback
2450 //
2451 //--------------------------------------------------------------------------------
2452 void RegexMatcher::setFindProgressCallback(URegexFindProgressCallback      *callback,
2453                                                 const void                      *context,
2454                                                 UErrorCode                      &amp;status) {
2455     if (U_FAILURE(status)) {
2456         return;
2457     }
2458     fFindProgressCallbackFn = callback;
2459     fFindProgressCallbackContext = context;
2460 }
2461 
2462 
2463 //--------------------------------------------------------------------------------
2464 //
2465 //     getMatchCallback
2466 //
2467 //--------------------------------------------------------------------------------
2468 void RegexMatcher::getFindProgressCallback(URegexFindProgressCallback    *&amp;callback,
2469                                                 const void                    *&amp;context,
2470                                                 UErrorCode                    &amp;status) {
2471     if (U_FAILURE(status)) {
2472        return;
2473     }
2474     callback = fFindProgressCallbackFn;
2475     context  = fFindProgressCallbackContext;
2476 }
2477 
2478 
2479 //================================================================================
2480 //
2481 //    Code following this point in this file is the internal
2482 //    Match Engine Implementation.
2483 //
2484 //================================================================================
2485 
2486 
2487 //--------------------------------------------------------------------------------
2488 //
2489 //   resetStack
2490 //           Discard any previous contents of the state save stack, and initialize a
2491 //           new stack frame to all -1.  The -1s are needed for capture group limits,
2492 //           where they indicate that a group has not yet matched anything.
2493 //--------------------------------------------------------------------------------
2494 REStackFrame *RegexMatcher::resetStack() {
2495     // Discard any previous contents of the state save stack, and initialize a
2496     //  new stack frame with all -1 data.  The -1s are needed for capture group limits,
2497     //  where they indicate that a group has not yet matched anything.
2498     fStack-&gt;removeAllElements();
2499 
2500     REStackFrame *iFrame = (REStackFrame *)fStack-&gt;reserveBlock(fPattern-&gt;fFrameSize, fDeferredStatus);
2501     if(U_FAILURE(fDeferredStatus)) {
2502         return NULL;
2503     }
2504 
2505     int32_t i;
2506     for (i=0; i&lt;fPattern-&gt;fFrameSize-RESTACKFRAME_HDRCOUNT; i++) {
2507         iFrame-&gt;fExtra[i] = -1;
2508     }
2509     return iFrame;
2510 }
2511 
2512 
2513 
2514 //--------------------------------------------------------------------------------
2515 //
2516 //   isWordBoundary
2517 //                     in perl, &quot;xab..cd..&quot;, \b is true at positions 0,3,5,7
2518 //                     For us,
2519 //                       If the current char is a combining mark,
2520 //                          \b is FALSE.
2521 //                       Else Scan backwards to the first non-combining char.
2522 //                            We are at a boundary if the this char and the original chars are
2523 //                               opposite in membership in \w set
2524 //
2525 //          parameters:   pos   - the current position in the input buffer
2526 //
2527 //              TODO:  double-check edge cases at region boundaries.
2528 //
2529 //--------------------------------------------------------------------------------
2530 UBool RegexMatcher::isWordBoundary(int64_t pos) {
2531     UBool isBoundary = FALSE;
2532     UBool cIsWord    = FALSE;
2533 
2534     if (pos &gt;= fLookLimit) {
2535         fHitEnd = TRUE;
2536     } else {
2537         // Determine whether char c at current position is a member of the word set of chars.
2538         // If we&#39;re off the end of the string, behave as though we&#39;re not at a word char.
2539         UTEXT_SETNATIVEINDEX(fInputText, pos);
2540         UChar32  c = UTEXT_CURRENT32(fInputText);
2541         if (u_hasBinaryProperty(c, UCHAR_GRAPHEME_EXTEND) || u_charType(c) == U_FORMAT_CHAR) {
2542             // Current char is a combining one.  Not a boundary.
2543             return FALSE;
2544         }
2545         cIsWord = fPattern-&gt;fStaticSets[URX_ISWORD_SET]-&gt;contains(c);
2546     }
2547 
2548     // Back up until we come to a non-combining char, determine whether
2549     //  that char is a word char.
2550     UBool prevCIsWord = FALSE;
2551     for (;;) {
2552         if (UTEXT_GETNATIVEINDEX(fInputText) &lt;= fLookStart) {
2553             break;
2554         }
2555         UChar32 prevChar = UTEXT_PREVIOUS32(fInputText);
2556         if (!(u_hasBinaryProperty(prevChar, UCHAR_GRAPHEME_EXTEND)
2557               || u_charType(prevChar) == U_FORMAT_CHAR)) {
2558             prevCIsWord = fPattern-&gt;fStaticSets[URX_ISWORD_SET]-&gt;contains(prevChar);
2559             break;
2560         }
2561     }
2562     isBoundary = cIsWord ^ prevCIsWord;
2563     return isBoundary;
2564 }
2565 
2566 UBool RegexMatcher::isChunkWordBoundary(int32_t pos) {
2567     UBool isBoundary = FALSE;
2568     UBool cIsWord    = FALSE;
2569 
2570     const UChar *inputBuf = fInputText-&gt;chunkContents;
2571 
2572     if (pos &gt;= fLookLimit) {
2573         fHitEnd = TRUE;
2574     } else {
2575         // Determine whether char c at current position is a member of the word set of chars.
2576         // If we&#39;re off the end of the string, behave as though we&#39;re not at a word char.
2577         UChar32 c;
2578         U16_GET(inputBuf, fLookStart, pos, fLookLimit, c);
2579         if (u_hasBinaryProperty(c, UCHAR_GRAPHEME_EXTEND) || u_charType(c) == U_FORMAT_CHAR) {
2580             // Current char is a combining one.  Not a boundary.
2581             return FALSE;
2582         }
2583         cIsWord = fPattern-&gt;fStaticSets[URX_ISWORD_SET]-&gt;contains(c);
2584     }
2585 
2586     // Back up until we come to a non-combining char, determine whether
2587     //  that char is a word char.
2588     UBool prevCIsWord = FALSE;
2589     for (;;) {
2590         if (pos &lt;= fLookStart) {
2591             break;
2592         }
2593         UChar32 prevChar;
2594         U16_PREV(inputBuf, fLookStart, pos, prevChar);
2595         if (!(u_hasBinaryProperty(prevChar, UCHAR_GRAPHEME_EXTEND)
2596               || u_charType(prevChar) == U_FORMAT_CHAR)) {
2597             prevCIsWord = fPattern-&gt;fStaticSets[URX_ISWORD_SET]-&gt;contains(prevChar);
2598             break;
2599         }
2600     }
2601     isBoundary = cIsWord ^ prevCIsWord;
2602     return isBoundary;
2603 }
2604 
2605 //--------------------------------------------------------------------------------
2606 //
2607 //   isUWordBoundary
2608 //
2609 //         Test for a word boundary using RBBI word break.
2610 //
2611 //          parameters:   pos   - the current position in the input buffer
2612 //
2613 //--------------------------------------------------------------------------------
2614 UBool RegexMatcher::isUWordBoundary(int64_t pos) {
2615     UBool       returnVal = FALSE;
2616 #if UCONFIG_NO_BREAK_ITERATION==0
2617 
2618     // If we haven&#39;t yet created a break iterator for this matcher, do it now.
2619     if (fWordBreakItr == NULL) {
2620         fWordBreakItr =
2621             (RuleBasedBreakIterator *)BreakIterator::createWordInstance(Locale::getEnglish(), fDeferredStatus);
2622         if (U_FAILURE(fDeferredStatus)) {
2623             return FALSE;
2624         }
2625         fWordBreakItr-&gt;setText(fInputText, fDeferredStatus);
2626     }
2627 
2628     if (pos &gt;= fLookLimit) {
2629         fHitEnd = TRUE;
2630         returnVal = TRUE;   // With Unicode word rules, only positions within the interior of &quot;real&quot;
2631                             //    words are not boundaries.  All non-word chars stand by themselves,
2632                             //    with word boundaries on both sides.
2633     } else {
2634         if (!UTEXT_USES_U16(fInputText)) {
2635             // !!!: Would like a better way to do this!
2636             UErrorCode status = U_ZERO_ERROR;
2637             pos = utext_extract(fInputText, 0, pos, NULL, 0, &amp;status);
2638         }
2639         returnVal = fWordBreakItr-&gt;isBoundary((int32_t)pos);
2640     }
2641 #endif
2642     return   returnVal;
2643 }
2644 
2645 //--------------------------------------------------------------------------------
2646 //
2647 //   IncrementTime     This function is called once each TIMER_INITIAL_VALUE state
2648 //                     saves. Increment the &quot;time&quot; counter, and call the
2649 //                     user callback function if there is one installed.
2650 //
2651 //                     If the match operation needs to be aborted, either for a time-out
2652 //                     or because the user callback asked for it, just set an error status.
2653 //                     The engine will pick that up and stop in its outer loop.
2654 //
2655 //--------------------------------------------------------------------------------
2656 void RegexMatcher::IncrementTime(UErrorCode &amp;status) {
2657     fTickCounter = TIMER_INITIAL_VALUE;
2658     fTime++;
2659     if (fCallbackFn != NULL) {
2660         if ((*fCallbackFn)(fCallbackContext, fTime) == FALSE) {
2661             status = U_REGEX_STOPPED_BY_CALLER;
2662             return;
2663         }
2664     }
2665     if (fTimeLimit &gt; 0 &amp;&amp; fTime &gt;= fTimeLimit) {
2666         status = U_REGEX_TIME_OUT;
2667     }
2668 }
2669 
2670 //--------------------------------------------------------------------------------
2671 //
2672 //   StateSave
2673 //       Make a new stack frame, initialized as a copy of the current stack frame.
2674 //       Set the pattern index in the original stack frame from the operand value
2675 //       in the opcode.  Execution of the engine continues with the state in
2676 //       the newly created stack frame
2677 //
2678 //       Note that reserveBlock() may grow the stack, resulting in the
2679 //       whole thing being relocated in memory.
2680 //
2681 //    Parameters:
2682 //       fp           The top frame pointer when called.  At return, a new
2683 //                    fame will be present
2684 //       savePatIdx   An index into the compiled pattern.  Goes into the original
2685 //                    (not new) frame.  If execution ever back-tracks out of the
2686 //                    new frame, this will be where we continue from in the pattern.
2687 //    Return
2688 //                    The new frame pointer.
2689 //
2690 //--------------------------------------------------------------------------------
2691 inline REStackFrame *RegexMatcher::StateSave(REStackFrame *fp, int64_t savePatIdx, UErrorCode &amp;status) {
2692     if (U_FAILURE(status)) {
2693         return fp;
2694     }
2695     // push storage for a new frame.
2696     int64_t *newFP = fStack-&gt;reserveBlock(fFrameSize, status);
2697     if (U_FAILURE(status)) {
2698         // Failure on attempted stack expansion.
2699         //   Stack function set some other error code, change it to a more
2700         //   specific one for regular expressions.
2701         status = U_REGEX_STACK_OVERFLOW;
2702         // We need to return a writable stack frame, so just return the
2703         //    previous frame.  The match operation will stop quickly
2704         //    because of the error status, after which the frame will never
2705         //    be looked at again.
2706         return fp;
2707     }
2708     fp = (REStackFrame *)(newFP - fFrameSize);  // in case of realloc of stack.
2709 
2710     // New stack frame = copy of old top frame.
2711     int64_t *source = (int64_t *)fp;
2712     int64_t *dest   = newFP;
2713     for (;;) {
2714         *dest++ = *source++;
2715         if (source == newFP) {
2716             break;
2717         }
2718     }
2719 
2720     fTickCounter--;
2721     if (fTickCounter &lt;= 0) {
2722        IncrementTime(status);    // Re-initializes fTickCounter
2723     }
2724     fp-&gt;fPatIdx = savePatIdx;
2725     return (REStackFrame *)newFP;
2726 }
2727 
2728 #if defined(REGEX_DEBUG)
2729 namespace {
2730 UnicodeString StringFromUText(UText *ut) {
2731     UnicodeString result;
2732     for (UChar32 c = utext_next32From(ut, 0); c != U_SENTINEL; c = UTEXT_NEXT32(ut)) {
2733         result.append(c);
2734     }
2735     return result;
2736 }
2737 }
2738 #endif // REGEX_DEBUG
2739 
2740 
2741 //--------------------------------------------------------------------------------
2742 //
2743 //   MatchAt      This is the actual matching engine.
2744 //
2745 //                  startIdx:    begin matching a this index.
2746 //                  toEnd:       if true, match must extend to end of the input region
2747 //
2748 //--------------------------------------------------------------------------------
2749 void RegexMatcher::MatchAt(int64_t startIdx, UBool toEnd, UErrorCode &amp;status) {
2750     UBool       isMatch  = FALSE;      // True if the we have a match.
2751 
2752     int64_t     backSearchIndex = U_INT64_MAX; // used after greedy single-character matches for searching backwards
2753 
2754     int32_t     op;                    // Operation from the compiled pattern, split into
2755     int32_t     opType;                //    the opcode
2756     int32_t     opValue;               //    and the operand value.
2757 
2758 #ifdef REGEX_RUN_DEBUG
2759     if (fTraceDebug) {
2760         printf(&quot;MatchAt(startIdx=%ld)\n&quot;, startIdx);
2761         printf(&quot;Original Pattern: \&quot;%s\&quot;\n&quot;, CStr(StringFromUText(fPattern-&gt;fPattern))());
2762         printf(&quot;Input String:     \&quot;%s\&quot;\n\n&quot;, CStr(StringFromUText(fInputText))());
2763     }
2764 #endif
2765 
2766     if (U_FAILURE(status)) {
2767         return;
2768     }
2769 
2770     //  Cache frequently referenced items from the compiled pattern
2771     //
2772     int64_t             *pat           = fPattern-&gt;fCompiledPat-&gt;getBuffer();
2773 
2774     const UChar         *litText       = fPattern-&gt;fLiteralText.getBuffer();
<a name="21" id="anc21"></a><span class="line-modified">2775     UVector             *fSets         = fPattern-&gt;fSets;</span>
2776 
2777     fFrameSize = fPattern-&gt;fFrameSize;
2778     REStackFrame        *fp            = resetStack();
2779     if (U_FAILURE(fDeferredStatus)) {
2780         status = fDeferredStatus;
2781         return;
2782     }
2783 
2784     fp-&gt;fPatIdx   = 0;
2785     fp-&gt;fInputIdx = startIdx;
2786 
2787     // Zero out the pattern&#39;s static data
2788     int32_t i;
2789     for (i = 0; i&lt;fPattern-&gt;fDataSize; i++) {
2790         fData[i] = 0;
2791     }
2792 
2793     //
2794     //  Main loop for interpreting the compiled pattern.
2795     //  One iteration of the loop per pattern operation performed.
2796     //
2797     for (;;) {
2798         op      = (int32_t)pat[fp-&gt;fPatIdx];
2799         opType  = URX_TYPE(op);
2800         opValue = URX_VAL(op);
2801 #ifdef REGEX_RUN_DEBUG
2802         if (fTraceDebug) {
2803             UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
2804             printf(&quot;inputIdx=%ld   inputChar=%x   sp=%3ld   activeLimit=%ld  &quot;, fp-&gt;fInputIdx,
2805                 UTEXT_CURRENT32(fInputText), (int64_t *)fp-fStack-&gt;getBuffer(), fActiveLimit);
2806             fPattern-&gt;dumpOp(fp-&gt;fPatIdx);
2807         }
2808 #endif
2809         fp-&gt;fPatIdx++;
2810 
2811         switch (opType) {
2812 
2813 
2814         case URX_NOP:
2815             break;
2816 
2817 
2818         case URX_BACKTRACK:
2819             // Force a backtrack.  In some circumstances, the pattern compiler
2820             //   will notice that the pattern can&#39;t possibly match anything, and will
2821             //   emit one of these at that point.
2822             fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
2823             break;
2824 
2825 
2826         case URX_ONECHAR:
2827             if (fp-&gt;fInputIdx &lt; fActiveLimit) {
2828                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
2829                 UChar32 c = UTEXT_NEXT32(fInputText);
2830                 if (c == opValue) {
2831                     fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
2832                     break;
2833                 }
2834             } else {
2835                 fHitEnd = TRUE;
2836             }
2837             fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
2838             break;
2839 
2840 
2841         case URX_STRING:
2842             {
2843                 // Test input against a literal string.
2844                 // Strings require two slots in the compiled pattern, one for the
2845                 //   offset to the string text, and one for the length.
2846 
2847                 int32_t   stringStartIdx = opValue;
2848                 op      = (int32_t)pat[fp-&gt;fPatIdx];     // Fetch the second operand
2849                 fp-&gt;fPatIdx++;
2850                 opType    = URX_TYPE(op);
2851                 int32_t stringLen = URX_VAL(op);
2852                 U_ASSERT(opType == URX_STRING_LEN);
2853                 U_ASSERT(stringLen &gt;= 2);
2854 
2855                 const UChar *patternString = litText+stringStartIdx;
2856                 int32_t patternStringIndex = 0;
2857                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
2858                 UChar32 inputChar;
2859                 UChar32 patternChar;
2860                 UBool success = TRUE;
2861                 while (patternStringIndex &lt; stringLen) {
2862                     if (UTEXT_GETNATIVEINDEX(fInputText) &gt;= fActiveLimit) {
2863                         success = FALSE;
2864                         fHitEnd = TRUE;
2865                         break;
2866                     }
2867                     inputChar = UTEXT_NEXT32(fInputText);
2868                     U16_NEXT(patternString, patternStringIndex, stringLen, patternChar);
2869                     if (patternChar != inputChar) {
2870                         success = FALSE;
2871                         break;
2872                     }
2873                 }
2874 
2875                 if (success) {
2876                     fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
2877                 } else {
2878                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
2879                 }
2880             }
2881             break;
2882 
2883 
2884         case URX_STATE_SAVE:
2885             fp = StateSave(fp, opValue, status);
2886             break;
2887 
2888 
2889         case URX_END:
2890             // The match loop will exit via this path on a successful match,
2891             //   when we reach the end of the pattern.
2892             if (toEnd &amp;&amp; fp-&gt;fInputIdx != fActiveLimit) {
2893                 // The pattern matched, but not to the end of input.  Try some more.
2894                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
2895                 break;
2896             }
2897             isMatch = TRUE;
2898             goto  breakFromLoop;
2899 
2900         // Start and End Capture stack frame variables are laid out out like this:
2901             //  fp-&gt;fExtra[opValue]  - The start of a completed capture group
2902             //             opValue+1 - The end   of a completed capture group
2903             //             opValue+2 - the start of a capture group whose end
2904             //                          has not yet been reached (and might not ever be).
2905         case URX_START_CAPTURE:
2906             U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fFrameSize-3);
2907             fp-&gt;fExtra[opValue+2] = fp-&gt;fInputIdx;
2908             break;
2909 
2910 
2911         case URX_END_CAPTURE:
2912             U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fFrameSize-3);
2913             U_ASSERT(fp-&gt;fExtra[opValue+2] &gt;= 0);            // Start pos for this group must be set.
2914             fp-&gt;fExtra[opValue]   = fp-&gt;fExtra[opValue+2];   // Tentative start becomes real.
2915             fp-&gt;fExtra[opValue+1] = fp-&gt;fInputIdx;           // End position
2916             U_ASSERT(fp-&gt;fExtra[opValue] &lt;= fp-&gt;fExtra[opValue+1]);
2917             break;
2918 
2919 
2920         case URX_DOLLAR:                   //  $, test for End of line
2921                                            //     or for position before new line at end of input
2922             {
2923                 if (fp-&gt;fInputIdx &gt;= fAnchorLimit) {
2924                     // We really are at the end of input.  Success.
2925                     fHitEnd = TRUE;
2926                     fRequireEnd = TRUE;
2927                     break;
2928                 }
2929 
2930                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
2931 
2932                 // If we are positioned just before a new-line that is located at the
2933                 //   end of input, succeed.
2934                 UChar32 c = UTEXT_NEXT32(fInputText);
2935                 if (UTEXT_GETNATIVEINDEX(fInputText) &gt;= fAnchorLimit) {
2936                     if (isLineTerminator(c)) {
2937                         // If not in the middle of a CR/LF sequence
2938                         if ( !(c==0x0a &amp;&amp; fp-&gt;fInputIdx&gt;fAnchorStart &amp;&amp; ((void)UTEXT_PREVIOUS32(fInputText), UTEXT_PREVIOUS32(fInputText))==0x0d)) {
2939                             // At new-line at end of input. Success
2940                             fHitEnd = TRUE;
2941                             fRequireEnd = TRUE;
2942 
2943                             break;
2944                         }
2945                     }
2946                 } else {
2947                     UChar32 nextC = UTEXT_NEXT32(fInputText);
2948                     if (c == 0x0d &amp;&amp; nextC == 0x0a &amp;&amp; UTEXT_GETNATIVEINDEX(fInputText) &gt;= fAnchorLimit) {
2949                         fHitEnd = TRUE;
2950                         fRequireEnd = TRUE;
2951                         break;                         // At CR/LF at end of input.  Success
2952                     }
2953                 }
2954 
2955                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
2956             }
2957             break;
2958 
2959 
2960          case URX_DOLLAR_D:                   //  $, test for End of Line, in UNIX_LINES mode.
2961             if (fp-&gt;fInputIdx &gt;= fAnchorLimit) {
2962                 // Off the end of input.  Success.
2963                 fHitEnd = TRUE;
2964                 fRequireEnd = TRUE;
2965                 break;
2966             } else {
2967                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
2968                 UChar32 c = UTEXT_NEXT32(fInputText);
2969                 // Either at the last character of input, or off the end.
2970                 if (c == 0x0a &amp;&amp; UTEXT_GETNATIVEINDEX(fInputText) == fAnchorLimit) {
2971                     fHitEnd = TRUE;
2972                     fRequireEnd = TRUE;
2973                     break;
2974                 }
2975             }
2976 
2977             // Not at end of input.  Back-track out.
2978             fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
2979             break;
2980 
2981 
2982          case URX_DOLLAR_M:                //  $, test for End of line in multi-line mode
2983              {
2984                  if (fp-&gt;fInputIdx &gt;= fAnchorLimit) {
2985                      // We really are at the end of input.  Success.
2986                      fHitEnd = TRUE;
2987                      fRequireEnd = TRUE;
2988                      break;
2989                  }
2990                  // If we are positioned just before a new-line, succeed.
2991                  // It makes no difference where the new-line is within the input.
2992                  UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
2993                  UChar32 c = UTEXT_CURRENT32(fInputText);
2994                  if (isLineTerminator(c)) {
2995                      // At a line end, except for the odd chance of  being in the middle of a CR/LF sequence
2996                      //  In multi-line mode, hitting a new-line just before the end of input does not
2997                      //   set the hitEnd or requireEnd flags
2998                      if ( !(c==0x0a &amp;&amp; fp-&gt;fInputIdx&gt;fAnchorStart &amp;&amp; UTEXT_PREVIOUS32(fInputText)==0x0d)) {
2999                         break;
3000                      }
3001                  }
3002                  // not at a new line.  Fail.
3003                  fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3004              }
3005              break;
3006 
3007 
3008          case URX_DOLLAR_MD:                //  $, test for End of line in multi-line and UNIX_LINES mode
3009              {
3010                  if (fp-&gt;fInputIdx &gt;= fAnchorLimit) {
3011                      // We really are at the end of input.  Success.
3012                      fHitEnd = TRUE;
3013                      fRequireEnd = TRUE;  // Java set requireEnd in this case, even though
3014                      break;               //   adding a new-line would not lose the match.
3015                  }
3016                  // If we are not positioned just before a new-line, the test fails; backtrack out.
3017                  // It makes no difference where the new-line is within the input.
3018                  UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3019                  if (UTEXT_CURRENT32(fInputText) != 0x0a) {
3020                      fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3021                  }
3022              }
3023              break;
3024 
3025 
3026        case URX_CARET:                    //  ^, test for start of line
3027             if (fp-&gt;fInputIdx != fAnchorStart) {
3028                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3029             }
3030             break;
3031 
3032 
3033        case URX_CARET_M:                   //  ^, test for start of line in mulit-line mode
3034            {
3035                if (fp-&gt;fInputIdx == fAnchorStart) {
3036                    // We are at the start input.  Success.
3037                    break;
3038                }
3039                // Check whether character just before the current pos is a new-line
3040                //   unless we are at the end of input
3041                UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3042                UChar32  c = UTEXT_PREVIOUS32(fInputText);
3043                if ((fp-&gt;fInputIdx &lt; fAnchorLimit) &amp;&amp; isLineTerminator(c)) {
3044                    //  It&#39;s a new-line.  ^ is true.  Success.
3045                    //  TODO:  what should be done with positions between a CR and LF?
3046                    break;
3047                }
3048                // Not at the start of a line.  Fail.
3049                fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3050            }
3051            break;
3052 
3053 
3054        case URX_CARET_M_UNIX:       //  ^, test for start of line in mulit-line + Unix-line mode
3055            {
3056                U_ASSERT(fp-&gt;fInputIdx &gt;= fAnchorStart);
3057                if (fp-&gt;fInputIdx &lt;= fAnchorStart) {
3058                    // We are at the start input.  Success.
3059                    break;
3060                }
3061                // Check whether character just before the current pos is a new-line
3062                U_ASSERT(fp-&gt;fInputIdx &lt;= fAnchorLimit);
3063                UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3064                UChar32  c = UTEXT_PREVIOUS32(fInputText);
3065                if (c != 0x0a) {
3066                    // Not at the start of a line.  Back-track out.
3067                    fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3068                }
3069            }
3070            break;
3071 
3072         case URX_BACKSLASH_B:          // Test for word boundaries
3073             {
3074                 UBool success = isWordBoundary(fp-&gt;fInputIdx);
3075                 success ^= (UBool)(opValue != 0);     // flip sense for \B
3076                 if (!success) {
3077                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3078                 }
3079             }
3080             break;
3081 
3082 
3083         case URX_BACKSLASH_BU:          // Test for word boundaries, Unicode-style
3084             {
3085                 UBool success = isUWordBoundary(fp-&gt;fInputIdx);
3086                 success ^= (UBool)(opValue != 0);     // flip sense for \B
3087                 if (!success) {
3088                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3089                 }
3090             }
3091             break;
3092 
3093 
3094         case URX_BACKSLASH_D:            // Test for decimal digit
3095             {
3096                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3097                     fHitEnd = TRUE;
3098                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3099                     break;
3100                 }
3101 
3102                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3103 
3104                 UChar32 c = UTEXT_NEXT32(fInputText);
3105                 int8_t ctype = u_charType(c);     // TODO:  make a unicode set for this.  Will be faster.
3106                 UBool success = (ctype == U_DECIMAL_DIGIT_NUMBER);
3107                 success ^= (UBool)(opValue != 0);        // flip sense for \D
3108                 if (success) {
3109                     fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3110                 } else {
3111                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3112                 }
3113             }
3114             break;
3115 
3116 
3117         case URX_BACKSLASH_G:          // Test for position at end of previous match
3118             if (!((fMatch &amp;&amp; fp-&gt;fInputIdx==fMatchEnd) || (fMatch==FALSE &amp;&amp; fp-&gt;fInputIdx==fActiveStart))) {
3119                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3120             }
3121             break;
3122 
3123 
3124         case URX_BACKSLASH_H:            // Test for \h, horizontal white space.
3125             {
3126                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3127                     fHitEnd = TRUE;
3128                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3129                     break;
3130                 }
3131                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3132                 UChar32 c = UTEXT_NEXT32(fInputText);
3133                 int8_t ctype = u_charType(c);
3134                 UBool success = (ctype == U_SPACE_SEPARATOR || c == 9);  // SPACE_SEPARATOR || TAB
3135                 success ^= (UBool)(opValue != 0);        // flip sense for \H
3136                 if (success) {
3137                     fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3138                 } else {
3139                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3140                 }
3141             }
3142             break;
3143 
3144 
3145         case URX_BACKSLASH_R:            // Test for \R, any line break sequence.
3146             {
3147                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3148                     fHitEnd = TRUE;
3149                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3150                     break;
3151                 }
3152                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3153                 UChar32 c = UTEXT_NEXT32(fInputText);
3154                 if (isLineTerminator(c)) {
3155                     if (c == 0x0d &amp;&amp; utext_current32(fInputText) == 0x0a) {
3156                         utext_next32(fInputText);
3157                     }
3158                     fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3159                 } else {
3160                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3161                 }
3162             }
3163             break;
3164 
3165 
3166         case URX_BACKSLASH_V:            // \v, any single line ending character.
3167             {
3168                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3169                     fHitEnd = TRUE;
3170                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3171                     break;
3172                 }
3173                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3174                 UChar32 c = UTEXT_NEXT32(fInputText);
3175                 UBool success = isLineTerminator(c);
3176                 success ^= (UBool)(opValue != 0);        // flip sense for \V
3177                 if (success) {
3178                     fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3179                 } else {
3180                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3181                 }
3182             }
3183             break;
3184 
3185 
3186         case URX_BACKSLASH_X:
3187             //  Match a Grapheme, as defined by Unicode TR 29.
3188             //  Differs slightly from Perl, which consumes combining marks independently
3189             //    of context.
3190             {
3191 
3192                 // Fail if at end of input
3193                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3194                     fHitEnd = TRUE;
3195                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3196                     break;
3197                 }
3198 
3199                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3200 
3201                 // Examine (and consume) the current char.
3202                 //   Dispatch into a little state machine, based on the char.
3203                 UChar32  c;
3204                 c = UTEXT_NEXT32(fInputText);
3205                 fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3206                 UnicodeSet **sets = fPattern-&gt;fStaticSets;
3207                 if (sets[URX_GC_NORMAL]-&gt;contains(c))  goto GC_Extend;
3208                 if (sets[URX_GC_CONTROL]-&gt;contains(c)) goto GC_Control;
3209                 if (sets[URX_GC_L]-&gt;contains(c))       goto GC_L;
3210                 if (sets[URX_GC_LV]-&gt;contains(c))      goto GC_V;
3211                 if (sets[URX_GC_LVT]-&gt;contains(c))     goto GC_T;
3212                 if (sets[URX_GC_V]-&gt;contains(c))       goto GC_V;
3213                 if (sets[URX_GC_T]-&gt;contains(c))       goto GC_T;
3214                 goto GC_Extend;
3215 
3216 
3217 
3218 GC_L:
3219                 if (fp-&gt;fInputIdx &gt;= fActiveLimit)         goto GC_Done;
3220                 c = UTEXT_NEXT32(fInputText);
3221                 fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3222                 if (sets[URX_GC_L]-&gt;contains(c))       goto GC_L;
3223                 if (sets[URX_GC_LV]-&gt;contains(c))      goto GC_V;
3224                 if (sets[URX_GC_LVT]-&gt;contains(c))     goto GC_T;
3225                 if (sets[URX_GC_V]-&gt;contains(c))       goto GC_V;
3226                 (void)UTEXT_PREVIOUS32(fInputText);
3227                 fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3228                 goto GC_Extend;
3229 
3230 GC_V:
3231                 if (fp-&gt;fInputIdx &gt;= fActiveLimit)         goto GC_Done;
3232                 c = UTEXT_NEXT32(fInputText);
3233                 fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3234                 if (sets[URX_GC_V]-&gt;contains(c))       goto GC_V;
3235                 if (sets[URX_GC_T]-&gt;contains(c))       goto GC_T;
3236                 (void)UTEXT_PREVIOUS32(fInputText);
3237                 fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3238                 goto GC_Extend;
3239 
3240 GC_T:
3241                 if (fp-&gt;fInputIdx &gt;= fActiveLimit)         goto GC_Done;
3242                 c = UTEXT_NEXT32(fInputText);
3243                 fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3244                 if (sets[URX_GC_T]-&gt;contains(c))       goto GC_T;
3245                 (void)UTEXT_PREVIOUS32(fInputText);
3246                 fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3247                 goto GC_Extend;
3248 
3249 GC_Extend:
3250                 // Combining characters are consumed here
3251                 for (;;) {
3252                     if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3253                         break;
3254                     }
3255                     c = UTEXT_CURRENT32(fInputText);
3256                     if (sets[URX_GC_EXTEND]-&gt;contains(c) == FALSE) {
3257                         break;
3258                     }
3259                     (void)UTEXT_NEXT32(fInputText);
3260                     fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3261                 }
3262                 goto GC_Done;
3263 
3264 GC_Control:
3265                 // Most control chars stand alone (don&#39;t combine with combining chars),
3266                 //   except for that CR/LF sequence is a single grapheme cluster.
3267                 if (c == 0x0d &amp;&amp; fp-&gt;fInputIdx &lt; fActiveLimit &amp;&amp; UTEXT_CURRENT32(fInputText) == 0x0a) {
3268                     c = UTEXT_NEXT32(fInputText);
3269                     fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3270                 }
3271 
3272 GC_Done:
3273                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3274                     fHitEnd = TRUE;
3275                 }
3276                 break;
3277             }
3278 
3279 
3280 
3281 
3282         case URX_BACKSLASH_Z:          // Test for end of Input
3283             if (fp-&gt;fInputIdx &lt; fAnchorLimit) {
3284                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3285             } else {
3286                 fHitEnd = TRUE;
3287                 fRequireEnd = TRUE;
3288             }
3289             break;
3290 
3291 
3292 
3293         case URX_STATIC_SETREF:
3294             {
3295                 // Test input character against one of the predefined sets
3296                 //    (Word Characters, for example)
3297                 // The high bit of the op value is a flag for the match polarity.
3298                 //    0:   success if input char is in set.
3299                 //    1:   success if input char is not in set.
3300                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3301                     fHitEnd = TRUE;
3302                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3303                     break;
3304                 }
3305 
3306                 UBool success = ((opValue &amp; URX_NEG_SET) == URX_NEG_SET);
3307                 opValue &amp;= ~URX_NEG_SET;
3308                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; URX_LAST_SET);
3309 
3310                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3311                 UChar32 c = UTEXT_NEXT32(fInputText);
3312                 if (c &lt; 256) {
3313                     Regex8BitSet *s8 = &amp;fPattern-&gt;fStaticSets8[opValue];
3314                     if (s8-&gt;contains(c)) {
3315                         success = !success;
3316                     }
3317                 } else {
3318                     const UnicodeSet *s = fPattern-&gt;fStaticSets[opValue];
3319                     if (s-&gt;contains(c)) {
3320                         success = !success;
3321                     }
3322                 }
3323                 if (success) {
3324                     fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3325                 } else {
3326                     // the character wasn&#39;t in the set.
3327                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3328                 }
3329             }
3330             break;
3331 
3332 
3333         case URX_STAT_SETREF_N:
3334             {
3335                 // Test input character for NOT being a member of  one of
3336                 //    the predefined sets (Word Characters, for example)
3337                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3338                     fHitEnd = TRUE;
3339                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3340                     break;
3341                 }
3342 
3343                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; URX_LAST_SET);
3344 
3345                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3346 
3347                 UChar32 c = UTEXT_NEXT32(fInputText);
3348                 if (c &lt; 256) {
3349                     Regex8BitSet *s8 = &amp;fPattern-&gt;fStaticSets8[opValue];
3350                     if (s8-&gt;contains(c) == FALSE) {
3351                         fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3352                         break;
3353                     }
3354                 } else {
3355                     const UnicodeSet *s = fPattern-&gt;fStaticSets[opValue];
3356                     if (s-&gt;contains(c) == FALSE) {
3357                         fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3358                         break;
3359                     }
3360                 }
3361                 // the character wasn&#39;t in the set.
3362                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3363             }
3364             break;
3365 
3366 
3367         case URX_SETREF:
3368             if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3369                 fHitEnd = TRUE;
3370                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3371                 break;
3372             } else {
3373                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3374 
3375                 // There is input left.  Pick up one char and test it for set membership.
3376                 UChar32 c = UTEXT_NEXT32(fInputText);
<a name="22" id="anc22"></a><span class="line-modified">3377                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; fSets-&gt;size());</span>
3378                 if (c&lt;256) {
3379                     Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
3380                     if (s8-&gt;contains(c)) {
3381                         fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3382                         break;
3383                     }
3384                 } else {
<a name="23" id="anc23"></a><span class="line-modified">3385                     UnicodeSet *s = (UnicodeSet *)fSets-&gt;elementAt(opValue);</span>
3386                     if (s-&gt;contains(c)) {
3387                         // The character is in the set.  A Match.
3388                         fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3389                         break;
3390                     }
3391                 }
3392 
3393                 // the character wasn&#39;t in the set.
3394                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3395             }
3396             break;
3397 
3398 
3399         case URX_DOTANY:
3400             {
3401                 // . matches anything, but stops at end-of-line.
3402                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3403                     // At end of input.  Match failed.  Backtrack out.
3404                     fHitEnd = TRUE;
3405                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3406                     break;
3407                 }
3408 
3409                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3410 
3411                 // There is input left.  Advance over one char, unless we&#39;ve hit end-of-line
3412                 UChar32 c = UTEXT_NEXT32(fInputText);
3413                 if (isLineTerminator(c)) {
3414                     // End of line in normal mode.   . does not match.
3415                         fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3416                     break;
3417                 }
3418                 fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3419             }
3420             break;
3421 
3422 
3423         case URX_DOTANY_ALL:
3424             {
3425                 // ., in dot-matches-all (including new lines) mode
3426                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3427                     // At end of input.  Match failed.  Backtrack out.
3428                     fHitEnd = TRUE;
3429                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3430                     break;
3431                 }
3432 
3433                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3434 
3435                 // There is input left.  Advance over one char, except if we are
3436                 //   at a cr/lf, advance over both of them.
3437                 UChar32 c;
3438                 c = UTEXT_NEXT32(fInputText);
3439                 fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3440                 if (c==0x0d &amp;&amp; fp-&gt;fInputIdx &lt; fActiveLimit) {
3441                     // In the case of a CR/LF, we need to advance over both.
3442                     UChar32 nextc = UTEXT_CURRENT32(fInputText);
3443                     if (nextc == 0x0a) {
3444                         (void)UTEXT_NEXT32(fInputText);
3445                         fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3446                     }
3447                 }
3448             }
3449             break;
3450 
3451 
3452         case URX_DOTANY_UNIX:
3453             {
3454                 // &#39;.&#39; operator, matches all, but stops at end-of-line.
3455                 //   UNIX_LINES mode, so 0x0a is the only recognized line ending.
3456                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
3457                     // At end of input.  Match failed.  Backtrack out.
3458                     fHitEnd = TRUE;
3459                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3460                     break;
3461                 }
3462 
3463                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3464 
3465                 // There is input left.  Advance over one char, unless we&#39;ve hit end-of-line
3466                 UChar32 c = UTEXT_NEXT32(fInputText);
3467                 if (c == 0x0a) {
3468                     // End of line in normal mode.   &#39;.&#39; does not match the \n
3469                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3470                 } else {
3471                     fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3472                 }
3473             }
3474             break;
3475 
3476 
3477         case URX_JMP:
3478             fp-&gt;fPatIdx = opValue;
3479             break;
3480 
3481         case URX_FAIL:
3482             isMatch = FALSE;
3483             goto breakFromLoop;
3484 
3485         case URX_JMP_SAV:
3486             U_ASSERT(opValue &lt; fPattern-&gt;fCompiledPat-&gt;size());
3487             fp = StateSave(fp, fp-&gt;fPatIdx, status);       // State save to loc following current
3488             fp-&gt;fPatIdx = opValue;                         // Then JMP.
3489             break;
3490 
3491         case URX_JMP_SAV_X:
3492             // This opcode is used with (x)+, when x can match a zero length string.
3493             // Same as JMP_SAV, except conditional on the match having made forward progress.
3494             // Destination of the JMP must be a URX_STO_INP_LOC, from which we get the
3495             //   data address of the input position at the start of the loop.
3496             {
3497                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; fPattern-&gt;fCompiledPat-&gt;size());
3498                 int32_t  stoOp = (int32_t)pat[opValue-1];
3499                 U_ASSERT(URX_TYPE(stoOp) == URX_STO_INP_LOC);
3500                 int32_t  frameLoc = URX_VAL(stoOp);
3501                 U_ASSERT(frameLoc &gt;= 0 &amp;&amp; frameLoc &lt; fFrameSize);
3502                 int64_t prevInputIdx = fp-&gt;fExtra[frameLoc];
3503                 U_ASSERT(prevInputIdx &lt;= fp-&gt;fInputIdx);
3504                 if (prevInputIdx &lt; fp-&gt;fInputIdx) {
3505                     // The match did make progress.  Repeat the loop.
3506                     fp = StateSave(fp, fp-&gt;fPatIdx, status);  // State save to loc following current
3507                     fp-&gt;fPatIdx = opValue;
3508                     fp-&gt;fExtra[frameLoc] = fp-&gt;fInputIdx;
3509                 }
3510                 // If the input position did not advance, we do nothing here,
3511                 //   execution will fall out of the loop.
3512             }
3513             break;
3514 
3515         case URX_CTR_INIT:
3516             {
3517                 U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fFrameSize-2);
3518                 fp-&gt;fExtra[opValue] = 0;                 //  Set the loop counter variable to zero
3519 
3520                 // Pick up the three extra operands that CTR_INIT has, and
3521                 //    skip the pattern location counter past
3522                 int32_t instrOperandLoc = (int32_t)fp-&gt;fPatIdx;
3523                 fp-&gt;fPatIdx += 3;
3524                 int32_t loopLoc  = URX_VAL(pat[instrOperandLoc]);
3525                 int32_t minCount = (int32_t)pat[instrOperandLoc+1];
3526                 int32_t maxCount = (int32_t)pat[instrOperandLoc+2];
3527                 U_ASSERT(minCount&gt;=0);
3528                 U_ASSERT(maxCount&gt;=minCount || maxCount==-1);
3529                 U_ASSERT(loopLoc&gt;=fp-&gt;fPatIdx);
3530 
3531                 if (minCount == 0) {
3532                     fp = StateSave(fp, loopLoc+1, status);
3533                 }
3534                 if (maxCount == -1) {
3535                     fp-&gt;fExtra[opValue+1] = fp-&gt;fInputIdx;   //  For loop breaking.
3536                 } else if (maxCount == 0) {
3537                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3538                 }
3539             }
3540             break;
3541 
3542         case URX_CTR_LOOP:
3543             {
3544                 U_ASSERT(opValue&gt;0 &amp;&amp; opValue &lt; fp-&gt;fPatIdx-2);
3545                 int32_t initOp = (int32_t)pat[opValue];
3546                 U_ASSERT(URX_TYPE(initOp) == URX_CTR_INIT);
3547                 int64_t *pCounter = &amp;fp-&gt;fExtra[URX_VAL(initOp)];
3548                 int32_t minCount  = (int32_t)pat[opValue+2];
3549                 int32_t maxCount  = (int32_t)pat[opValue+3];
3550                 (*pCounter)++;
3551                 if ((uint64_t)*pCounter &gt;= (uint32_t)maxCount &amp;&amp; maxCount != -1) {
3552                     U_ASSERT(*pCounter == maxCount);
3553                     break;
3554                 }
3555                 if (*pCounter &gt;= minCount) {
3556                     if (maxCount == -1) {
3557                         // Loop has no hard upper bound.
3558                         // Check that it is progressing through the input, break if it is not.
3559                         int64_t *pLastInputIdx =  &amp;fp-&gt;fExtra[URX_VAL(initOp) + 1];
3560                         if (fp-&gt;fInputIdx == *pLastInputIdx) {
3561                             break;
3562                         } else {
3563                             *pLastInputIdx = fp-&gt;fInputIdx;
3564                         }
3565                     }
3566                     fp = StateSave(fp, fp-&gt;fPatIdx, status);
3567                 } else {
3568                     // Increment time-out counter. (StateSave() does it if count &gt;= minCount)
3569                     fTickCounter--;
3570                     if (fTickCounter &lt;= 0) {
3571                         IncrementTime(status);    // Re-initializes fTickCounter
3572                     }
3573                 }
3574 
3575                 fp-&gt;fPatIdx = opValue + 4;    // Loop back.
3576             }
3577             break;
3578 
3579         case URX_CTR_INIT_NG:
3580             {
3581                 // Initialize a non-greedy loop
3582                 U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fFrameSize-2);
3583                 fp-&gt;fExtra[opValue] = 0;                 //  Set the loop counter variable to zero
3584 
3585                 // Pick up the three extra operands that CTR_INIT_NG has, and
3586                 //    skip the pattern location counter past
3587                 int32_t instrOperandLoc = (int32_t)fp-&gt;fPatIdx;
3588                 fp-&gt;fPatIdx += 3;
3589                 int32_t loopLoc  = URX_VAL(pat[instrOperandLoc]);
3590                 int32_t minCount = (int32_t)pat[instrOperandLoc+1];
3591                 int32_t maxCount = (int32_t)pat[instrOperandLoc+2];
3592                 U_ASSERT(minCount&gt;=0);
3593                 U_ASSERT(maxCount&gt;=minCount || maxCount==-1);
3594                 U_ASSERT(loopLoc&gt;fp-&gt;fPatIdx);
3595                 if (maxCount == -1) {
3596                     fp-&gt;fExtra[opValue+1] = fp-&gt;fInputIdx;   //  Save initial input index for loop breaking.
3597                 }
3598 
3599                 if (minCount == 0) {
3600                     if (maxCount != 0) {
3601                         fp = StateSave(fp, fp-&gt;fPatIdx, status);
3602                     }
3603                     fp-&gt;fPatIdx = loopLoc+1;   // Continue with stuff after repeated block
3604                 }
3605             }
3606             break;
3607 
3608         case URX_CTR_LOOP_NG:
3609             {
3610                 // Non-greedy {min, max} loops
3611                 U_ASSERT(opValue&gt;0 &amp;&amp; opValue &lt; fp-&gt;fPatIdx-2);
3612                 int32_t initOp = (int32_t)pat[opValue];
3613                 U_ASSERT(URX_TYPE(initOp) == URX_CTR_INIT_NG);
3614                 int64_t *pCounter = &amp;fp-&gt;fExtra[URX_VAL(initOp)];
3615                 int32_t minCount  = (int32_t)pat[opValue+2];
3616                 int32_t maxCount  = (int32_t)pat[opValue+3];
3617 
3618                 (*pCounter)++;
3619                 if ((uint64_t)*pCounter &gt;= (uint32_t)maxCount &amp;&amp; maxCount != -1) {
3620                     // The loop has matched the maximum permitted number of times.
3621                     //   Break out of here with no action.  Matching will
3622                     //   continue with the following pattern.
3623                     U_ASSERT(*pCounter == maxCount);
3624                     break;
3625                 }
3626 
3627                 if (*pCounter &lt; minCount) {
3628                     // We haven&#39;t met the minimum number of matches yet.
3629                     //   Loop back for another one.
3630                     fp-&gt;fPatIdx = opValue + 4;    // Loop back.
3631                     // Increment time-out counter. (StateSave() does it if count &gt;= minCount)
3632                     fTickCounter--;
3633                     if (fTickCounter &lt;= 0) {
3634                         IncrementTime(status);    // Re-initializes fTickCounter
3635                     }
3636                 } else {
3637                     // We do have the minimum number of matches.
3638 
3639                     // If there is no upper bound on the loop iterations, check that the input index
3640                     // is progressing, and stop the loop if it is not.
3641                     if (maxCount == -1) {
3642                         int64_t *pLastInputIdx =  &amp;fp-&gt;fExtra[URX_VAL(initOp) + 1];
3643                         if (fp-&gt;fInputIdx == *pLastInputIdx) {
3644                             break;
3645                         }
3646                         *pLastInputIdx = fp-&gt;fInputIdx;
3647                     }
3648 
3649                     // Loop Continuation: we will fall into the pattern following the loop
3650                     //   (non-greedy, don&#39;t execute loop body first), but first do
3651                     //   a state save to the top of the loop, so that a match failure
3652                     //   in the following pattern will try another iteration of the loop.
3653                     fp = StateSave(fp, opValue + 4, status);
3654                 }
3655             }
3656             break;
3657 
3658         case URX_STO_SP:
3659             U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fPattern-&gt;fDataSize);
3660             fData[opValue] = fStack-&gt;size();
3661             break;
3662 
3663         case URX_LD_SP:
3664             {
3665                 U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fPattern-&gt;fDataSize);
3666                 int32_t newStackSize = (int32_t)fData[opValue];
3667                 U_ASSERT(newStackSize &lt;= fStack-&gt;size());
3668                 int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
3669                 if (newFP == (int64_t *)fp) {
3670                     break;
3671                 }
<a name="24" id="anc24"></a><span class="line-modified">3672                 int32_t j;</span>
<span class="line-modified">3673                 for (j=0; j&lt;fFrameSize; j++) {</span>
<span class="line-modified">3674                     newFP[j] = ((int64_t *)fp)[j];</span>
3675                 }
3676                 fp = (REStackFrame *)newFP;
3677                 fStack-&gt;setSize(newStackSize);
3678             }
3679             break;
3680 
3681         case URX_BACKREF:
3682             {
3683                 U_ASSERT(opValue &lt; fFrameSize);
3684                 int64_t groupStartIdx = fp-&gt;fExtra[opValue];
3685                 int64_t groupEndIdx   = fp-&gt;fExtra[opValue+1];
3686                 U_ASSERT(groupStartIdx &lt;= groupEndIdx);
3687                 if (groupStartIdx &lt; 0) {
3688                     // This capture group has not participated in the match thus far,
3689                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);   // FAIL, no match.
3690                     break;
3691                 }
3692                 UTEXT_SETNATIVEINDEX(fAltInputText, groupStartIdx);
3693                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3694 
3695                 //   Note: if the capture group match was of an empty string the backref
3696                 //         match succeeds.  Verified by testing:  Perl matches succeed
3697                 //         in this case, so we do too.
3698 
3699                 UBool success = TRUE;
3700                 for (;;) {
3701                     if (utext_getNativeIndex(fAltInputText) &gt;= groupEndIdx) {
3702                         success = TRUE;
3703                         break;
3704                     }
3705                     if (utext_getNativeIndex(fInputText) &gt;= fActiveLimit) {
3706                         success = FALSE;
3707                         fHitEnd = TRUE;
3708                         break;
3709                     }
3710                     UChar32 captureGroupChar = utext_next32(fAltInputText);
3711                     UChar32 inputChar = utext_next32(fInputText);
3712                     if (inputChar != captureGroupChar) {
3713                         success = FALSE;
3714                         break;
3715                     }
3716                 }
3717 
3718                 if (success) {
3719                     fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3720                 } else {
3721                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3722                 }
3723             }
3724             break;
3725 
3726 
3727 
3728         case URX_BACKREF_I:
3729             {
3730                 U_ASSERT(opValue &lt; fFrameSize);
3731                 int64_t groupStartIdx = fp-&gt;fExtra[opValue];
3732                 int64_t groupEndIdx   = fp-&gt;fExtra[opValue+1];
3733                 U_ASSERT(groupStartIdx &lt;= groupEndIdx);
3734                 if (groupStartIdx &lt; 0) {
3735                     // This capture group has not participated in the match thus far,
3736                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);   // FAIL, no match.
3737                     break;
3738                 }
3739                 utext_setNativeIndex(fAltInputText, groupStartIdx);
3740                 utext_setNativeIndex(fInputText, fp-&gt;fInputIdx);
3741                 CaseFoldingUTextIterator captureGroupItr(*fAltInputText);
3742                 CaseFoldingUTextIterator inputItr(*fInputText);
3743 
3744                 //   Note: if the capture group match was of an empty string the backref
3745                 //         match succeeds.  Verified by testing:  Perl matches succeed
3746                 //         in this case, so we do too.
3747 
3748                 UBool success = TRUE;
3749                 for (;;) {
3750                     if (!captureGroupItr.inExpansion() &amp;&amp; utext_getNativeIndex(fAltInputText) &gt;= groupEndIdx) {
3751                         success = TRUE;
3752                         break;
3753                     }
3754                     if (!inputItr.inExpansion() &amp;&amp; utext_getNativeIndex(fInputText) &gt;= fActiveLimit) {
3755                         success = FALSE;
3756                         fHitEnd = TRUE;
3757                         break;
3758                     }
3759                     UChar32 captureGroupChar = captureGroupItr.next();
3760                     UChar32 inputChar = inputItr.next();
3761                     if (inputChar != captureGroupChar) {
3762                         success = FALSE;
3763                         break;
3764                     }
3765                 }
3766 
3767                 if (success &amp;&amp; inputItr.inExpansion()) {
3768                     // We otained a match by consuming part of a string obtained from
3769                     // case-folding a single code point of the input text.
3770                     // This does not count as an overall match.
3771                     success = FALSE;
3772                 }
3773 
3774                 if (success) {
3775                     fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3776                 } else {
3777                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3778                 }
3779 
3780             }
3781             break;
3782 
3783         case URX_STO_INP_LOC:
3784             {
3785                 U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fFrameSize);
3786                 fp-&gt;fExtra[opValue] = fp-&gt;fInputIdx;
3787             }
3788             break;
3789 
3790         case URX_JMPX:
3791             {
3792                 int32_t instrOperandLoc = (int32_t)fp-&gt;fPatIdx;
3793                 fp-&gt;fPatIdx += 1;
3794                 int32_t dataLoc  = URX_VAL(pat[instrOperandLoc]);
3795                 U_ASSERT(dataLoc &gt;= 0 &amp;&amp; dataLoc &lt; fFrameSize);
3796                 int64_t savedInputIdx = fp-&gt;fExtra[dataLoc];
3797                 U_ASSERT(savedInputIdx &lt;= fp-&gt;fInputIdx);
3798                 if (savedInputIdx &lt; fp-&gt;fInputIdx) {
3799                     fp-&gt;fPatIdx = opValue;                               // JMP
3800                 } else {
3801                      fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);   // FAIL, no progress in loop.
3802                 }
3803             }
3804             break;
3805 
3806         case URX_LA_START:
3807             {
3808                 // Entering a lookahead block.
3809                 // Save Stack Ptr, Input Pos.
3810                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
3811                 fData[opValue]   = fStack-&gt;size();
3812                 fData[opValue+1] = fp-&gt;fInputIdx;
3813                 fActiveStart     = fLookStart;          // Set the match region change for
3814                 fActiveLimit     = fLookLimit;          //   transparent bounds.
3815             }
3816             break;
3817 
3818         case URX_LA_END:
3819             {
3820                 // Leaving a look-ahead block.
3821                 //  restore Stack Ptr, Input Pos to positions they had on entry to block.
3822                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
3823                 int32_t stackSize = fStack-&gt;size();
3824                 int32_t newStackSize =(int32_t)fData[opValue];
3825                 U_ASSERT(stackSize &gt;= newStackSize);
3826                 if (stackSize &gt; newStackSize) {
3827                     // Copy the current top frame back to the new (cut back) top frame.
3828                     //   This makes the capture groups from within the look-ahead
3829                     //   expression available.
3830                     int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
<a name="25" id="anc25"></a><span class="line-modified">3831                     int32_t j;</span>
<span class="line-modified">3832                     for (j=0; j&lt;fFrameSize; j++) {</span>
<span class="line-modified">3833                         newFP[j] = ((int64_t *)fp)[j];</span>
3834                     }
3835                     fp = (REStackFrame *)newFP;
3836                     fStack-&gt;setSize(newStackSize);
3837                 }
3838                 fp-&gt;fInputIdx = fData[opValue+1];
3839 
3840                 // Restore the active region bounds in the input string; they may have
3841                 //    been changed because of transparent bounds on a Region.
3842                 fActiveStart = fRegionStart;
3843                 fActiveLimit = fRegionLimit;
3844             }
3845             break;
3846 
3847         case URX_ONECHAR_I:
3848             // Case insensitive one char.  The char from the pattern is already case folded.
3849             // Input text is not, but case folding the input can not reduce two or more code
3850             // points to one.
3851             if (fp-&gt;fInputIdx &lt; fActiveLimit) {
3852                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3853 
3854                 UChar32 c = UTEXT_NEXT32(fInputText);
3855                 if (u_foldCase(c, U_FOLD_CASE_DEFAULT) == opValue) {
3856                     fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3857                     break;
3858                 }
3859             } else {
3860                 fHitEnd = TRUE;
3861             }
3862 
3863             fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3864             break;
3865 
3866         case URX_STRING_I:
3867             {
3868                 // Case-insensitive test input against a literal string.
3869                 // Strings require two slots in the compiled pattern, one for the
3870                 //   offset to the string text, and one for the length.
3871                 //   The compiled string has already been case folded.
3872                 {
3873                     const UChar *patternString = litText + opValue;
3874                     int32_t      patternStringIdx  = 0;
3875 
3876                     op      = (int32_t)pat[fp-&gt;fPatIdx];
3877                     fp-&gt;fPatIdx++;
3878                     opType  = URX_TYPE(op);
3879                     opValue = URX_VAL(op);
3880                     U_ASSERT(opType == URX_STRING_LEN);
3881                     int32_t patternStringLen = opValue;  // Length of the string from the pattern.
3882 
3883 
3884                     UChar32   cPattern;
3885                     UChar32   cText;
3886                     UBool     success = TRUE;
3887 
3888                     UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
3889                     CaseFoldingUTextIterator inputIterator(*fInputText);
3890                     while (patternStringIdx &lt; patternStringLen) {
3891                         if (!inputIterator.inExpansion() &amp;&amp; UTEXT_GETNATIVEINDEX(fInputText) &gt;= fActiveLimit) {
3892                             success = FALSE;
3893                             fHitEnd = TRUE;
3894                             break;
3895                         }
3896                         U16_NEXT(patternString, patternStringIdx, patternStringLen, cPattern);
3897                         cText = inputIterator.next();
3898                         if (cText != cPattern) {
3899                             success = FALSE;
3900                             break;
3901                         }
3902                     }
3903                     if (inputIterator.inExpansion()) {
3904                         success = FALSE;
3905                     }
3906 
3907                     if (success) {
3908                         fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
3909                     } else {
3910                         fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3911                     }
3912                 }
3913             }
3914             break;
3915 
3916         case URX_LB_START:
3917             {
3918                 // Entering a look-behind block.
3919                 // Save Stack Ptr, Input Pos.
3920                 //   TODO:  implement transparent bounds.  Ticket #6067
3921                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
3922                 fData[opValue]   = fStack-&gt;size();
3923                 fData[opValue+1] = fp-&gt;fInputIdx;
3924                 // Init the variable containing the start index for attempted matches.
3925                 fData[opValue+2] = -1;
3926                 // Save input string length, then reset to pin any matches to end at
3927                 //   the current position.
3928                 fData[opValue+3] = fActiveLimit;
3929                 fActiveLimit     = fp-&gt;fInputIdx;
3930             }
3931             break;
3932 
3933 
3934         case URX_LB_CONT:
3935             {
3936                 // Positive Look-Behind, at top of loop checking for matches of LB expression
3937                 //    at all possible input starting positions.
3938 
3939                 // Fetch the min and max possible match lengths.  They are the operands
3940                 //   of this op in the pattern.
3941                 int32_t minML = (int32_t)pat[fp-&gt;fPatIdx++];
3942                 int32_t maxML = (int32_t)pat[fp-&gt;fPatIdx++];
3943                 if (!UTEXT_USES_U16(fInputText)) {
3944                     // utf-8 fix to maximum match length. The pattern compiler assumes utf-16.
3945                     // The max length need not be exact; it just needs to be &gt;= actual maximum.
3946                     maxML *= 3;
3947                 }
3948                 U_ASSERT(minML &lt;= maxML);
3949                 U_ASSERT(minML &gt;= 0);
3950 
3951                 // Fetch (from data) the last input index where a match was attempted.
3952                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
3953                 int64_t  &amp;lbStartIdx = fData[opValue+2];
3954                 if (lbStartIdx &lt; 0) {
3955                     // First time through loop.
3956                     lbStartIdx = fp-&gt;fInputIdx - minML;
3957                     if (lbStartIdx &gt; 0) {
3958                         // move index to a code point boudary, if it&#39;s not on one already.
3959                         UTEXT_SETNATIVEINDEX(fInputText, lbStartIdx);
3960                         lbStartIdx = UTEXT_GETNATIVEINDEX(fInputText);
3961                     }
3962                 } else {
3963                     // 2nd through nth time through the loop.
3964                     // Back up start position for match by one.
3965                     if (lbStartIdx == 0) {
3966                         (lbStartIdx)--;
3967                     } else {
3968                         UTEXT_SETNATIVEINDEX(fInputText, lbStartIdx);
3969                         (void)UTEXT_PREVIOUS32(fInputText);
3970                         lbStartIdx = UTEXT_GETNATIVEINDEX(fInputText);
3971                     }
3972                 }
3973 
3974                 if (lbStartIdx &lt; 0 || lbStartIdx &lt; fp-&gt;fInputIdx - maxML) {
3975                     // We have tried all potential match starting points without
3976                     //  getting a match.  Backtrack out, and out of the
3977                     //   Look Behind altogether.
3978                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
3979                     int64_t restoreInputLen = fData[opValue+3];
3980                     U_ASSERT(restoreInputLen &gt;= fActiveLimit);
3981                     U_ASSERT(restoreInputLen &lt;= fInputLength);
3982                     fActiveLimit = restoreInputLen;
3983                     break;
3984                 }
3985 
3986                 //    Save state to this URX_LB_CONT op, so failure to match will repeat the loop.
3987                 //      (successful match will fall off the end of the loop.)
3988                 fp = StateSave(fp, fp-&gt;fPatIdx-3, status);
3989                 fp-&gt;fInputIdx = lbStartIdx;
3990             }
3991             break;
3992 
3993         case URX_LB_END:
3994             // End of a look-behind block, after a successful match.
3995             {
3996                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
3997                 if (fp-&gt;fInputIdx != fActiveLimit) {
3998                     //  The look-behind expression matched, but the match did not
3999                     //    extend all the way to the point that we are looking behind from.
4000                     //  FAIL out of here, which will take us back to the LB_CONT, which
4001                     //     will retry the match starting at another position or fail
4002                     //     the look-behind altogether, whichever is appropriate.
4003                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4004                     break;
4005                 }
4006 
4007                 // Look-behind match is good.  Restore the orignal input string length,
4008                 //   which had been truncated to pin the end of the lookbehind match to the
4009                 //   position being looked-behind.
4010                 int64_t originalInputLen = fData[opValue+3];
4011                 U_ASSERT(originalInputLen &gt;= fActiveLimit);
4012                 U_ASSERT(originalInputLen &lt;= fInputLength);
4013                 fActiveLimit = originalInputLen;
4014             }
4015             break;
4016 
4017 
4018         case URX_LBN_CONT:
4019             {
4020                 // Negative Look-Behind, at top of loop checking for matches of LB expression
4021                 //    at all possible input starting positions.
4022 
4023                 // Fetch the extra parameters of this op.
4024                 int32_t minML       = (int32_t)pat[fp-&gt;fPatIdx++];
4025                 int32_t maxML       = (int32_t)pat[fp-&gt;fPatIdx++];
4026                 if (!UTEXT_USES_U16(fInputText)) {
4027                     // utf-8 fix to maximum match length. The pattern compiler assumes utf-16.
4028                     // The max length need not be exact; it just needs to be &gt;= actual maximum.
4029                     maxML *= 3;
4030                 }
4031                 int32_t continueLoc = (int32_t)pat[fp-&gt;fPatIdx++];
4032                         continueLoc = URX_VAL(continueLoc);
4033                 U_ASSERT(minML &lt;= maxML);
4034                 U_ASSERT(minML &gt;= 0);
4035                 U_ASSERT(continueLoc &gt; fp-&gt;fPatIdx);
4036 
4037                 // Fetch (from data) the last input index where a match was attempted.
4038                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
4039                 int64_t  &amp;lbStartIdx = fData[opValue+2];
4040                 if (lbStartIdx &lt; 0) {
4041                     // First time through loop.
4042                     lbStartIdx = fp-&gt;fInputIdx - minML;
4043                     if (lbStartIdx &gt; 0) {
4044                         // move index to a code point boudary, if it&#39;s not on one already.
4045                         UTEXT_SETNATIVEINDEX(fInputText, lbStartIdx);
4046                         lbStartIdx = UTEXT_GETNATIVEINDEX(fInputText);
4047                     }
4048                 } else {
4049                     // 2nd through nth time through the loop.
4050                     // Back up start position for match by one.
4051                     if (lbStartIdx == 0) {
4052                         (lbStartIdx)--;
4053                     } else {
4054                         UTEXT_SETNATIVEINDEX(fInputText, lbStartIdx);
4055                         (void)UTEXT_PREVIOUS32(fInputText);
4056                         lbStartIdx = UTEXT_GETNATIVEINDEX(fInputText);
4057                     }
4058                 }
4059 
4060                 if (lbStartIdx &lt; 0 || lbStartIdx &lt; fp-&gt;fInputIdx - maxML) {
4061                     // We have tried all potential match starting points without
4062                     //  getting a match, which means that the negative lookbehind as
4063                     //  a whole has succeeded.  Jump forward to the continue location
4064                     int64_t restoreInputLen = fData[opValue+3];
4065                     U_ASSERT(restoreInputLen &gt;= fActiveLimit);
4066                     U_ASSERT(restoreInputLen &lt;= fInputLength);
4067                     fActiveLimit = restoreInputLen;
4068                     fp-&gt;fPatIdx = continueLoc;
4069                     break;
4070                 }
4071 
4072                 //    Save state to this URX_LB_CONT op, so failure to match will repeat the loop.
4073                 //      (successful match will cause a FAIL out of the loop altogether.)
4074                 fp = StateSave(fp, fp-&gt;fPatIdx-4, status);
4075                 fp-&gt;fInputIdx = lbStartIdx;
4076             }
4077             break;
4078 
4079         case URX_LBN_END:
4080             // End of a negative look-behind block, after a successful match.
4081             {
4082                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
4083                 if (fp-&gt;fInputIdx != fActiveLimit) {
4084                     //  The look-behind expression matched, but the match did not
4085                     //    extend all the way to the point that we are looking behind from.
4086                     //  FAIL out of here, which will take us back to the LB_CONT, which
4087                     //     will retry the match starting at another position or succeed
4088                     //     the look-behind altogether, whichever is appropriate.
4089                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4090                     break;
4091                 }
4092 
4093                 // Look-behind expression matched, which means look-behind test as
4094                 //   a whole Fails
4095 
4096                 //   Restore the orignal input string length, which had been truncated
4097                 //   inorder to pin the end of the lookbehind match
4098                 //   to the position being looked-behind.
4099                 int64_t originalInputLen = fData[opValue+3];
4100                 U_ASSERT(originalInputLen &gt;= fActiveLimit);
4101                 U_ASSERT(originalInputLen &lt;= fInputLength);
4102                 fActiveLimit = originalInputLen;
4103 
4104                 // Restore original stack position, discarding any state saved
4105                 //   by the successful pattern match.
4106                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
4107                 int32_t newStackSize = (int32_t)fData[opValue];
4108                 U_ASSERT(fStack-&gt;size() &gt; newStackSize);
4109                 fStack-&gt;setSize(newStackSize);
4110 
4111                 //  FAIL, which will take control back to someplace
4112                 //  prior to entering the look-behind test.
4113                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4114             }
4115             break;
4116 
4117 
4118         case URX_LOOP_SR_I:
4119             // Loop Initialization for the optimized implementation of
4120             //     [some character set]*
4121             //   This op scans through all matching input.
4122             //   The following LOOP_C op emulates stack unwinding if the following pattern fails.
4123             {
<a name="26" id="anc26"></a><span class="line-modified">4124                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; fSets-&gt;size());</span>
4125                 Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
<a name="27" id="anc27"></a><span class="line-modified">4126                 UnicodeSet   *s  = (UnicodeSet *)fSets-&gt;elementAt(opValue);</span>
4127 
4128                 // Loop through input, until either the input is exhausted or
4129                 //   we reach a character that is not a member of the set.
4130                 int64_t ix = fp-&gt;fInputIdx;
4131                 UTEXT_SETNATIVEINDEX(fInputText, ix);
4132                 for (;;) {
4133                     if (ix &gt;= fActiveLimit) {
4134                         fHitEnd = TRUE;
4135                         break;
4136                     }
4137                     UChar32 c = UTEXT_NEXT32(fInputText);
4138                     if (c&lt;256) {
4139                         if (s8-&gt;contains(c) == FALSE) {
4140                             break;
4141                         }
4142                     } else {
4143                         if (s-&gt;contains(c) == FALSE) {
4144                             break;
4145                         }
4146                     }
4147                     ix = UTEXT_GETNATIVEINDEX(fInputText);
4148                 }
4149 
4150                 // If there were no matching characters, skip over the loop altogether.
4151                 //   The loop doesn&#39;t run at all, a * op always succeeds.
4152                 if (ix == fp-&gt;fInputIdx) {
4153                     fp-&gt;fPatIdx++;   // skip the URX_LOOP_C op.
4154                     break;
4155                 }
4156 
4157                 // Peek ahead in the compiled pattern, to the URX_LOOP_C that
4158                 //   must follow.  It&#39;s operand is the stack location
4159                 //   that holds the starting input index for the match of this [set]*
4160                 int32_t loopcOp = (int32_t)pat[fp-&gt;fPatIdx];
4161                 U_ASSERT(URX_TYPE(loopcOp) == URX_LOOP_C);
4162                 int32_t stackLoc = URX_VAL(loopcOp);
4163                 U_ASSERT(stackLoc &gt;= 0 &amp;&amp; stackLoc &lt; fFrameSize);
4164                 fp-&gt;fExtra[stackLoc] = fp-&gt;fInputIdx;
4165                 fp-&gt;fInputIdx = ix;
4166 
4167                 // Save State to the URX_LOOP_C op that follows this one,
4168                 //   so that match failures in the following code will return to there.
4169                 //   Then bump the pattern idx so the LOOP_C is skipped on the way out of here.
4170                 fp = StateSave(fp, fp-&gt;fPatIdx, status);
4171                 fp-&gt;fPatIdx++;
4172             }
4173             break;
4174 
4175 
4176         case URX_LOOP_DOT_I:
4177             // Loop Initialization for the optimized implementation of .*
4178             //   This op scans through all remaining input.
4179             //   The following LOOP_C op emulates stack unwinding if the following pattern fails.
4180             {
4181                 // Loop through input until the input is exhausted (we reach an end-of-line)
4182                 // In DOTALL mode, we can just go straight to the end of the input.
4183                 int64_t ix;
4184                 if ((opValue &amp; 1) == 1) {
4185                     // Dot-matches-All mode.  Jump straight to the end of the string.
4186                     ix = fActiveLimit;
4187                     fHitEnd = TRUE;
4188                 } else {
4189                     // NOT DOT ALL mode.  Line endings do not match &#39;.&#39;
4190                     // Scan forward until a line ending or end of input.
4191                     ix = fp-&gt;fInputIdx;
4192                     UTEXT_SETNATIVEINDEX(fInputText, ix);
4193                     for (;;) {
4194                         if (ix &gt;= fActiveLimit) {
4195                             fHitEnd = TRUE;
4196                             break;
4197                         }
4198                         UChar32 c = UTEXT_NEXT32(fInputText);
4199                         if ((c &amp; 0x7f) &lt;= 0x29) {          // Fast filter of non-new-line-s
4200                             if ((c == 0x0a) ||             //  0x0a is newline in both modes.
4201                                (((opValue &amp; 2) == 0) &amp;&amp;    // IF not UNIX_LINES mode
4202                                     isLineTerminator(c))) {
4203                                 //  char is a line ending.  Exit the scanning loop.
4204                                 break;
4205                             }
4206                         }
4207                         ix = UTEXT_GETNATIVEINDEX(fInputText);
4208                     }
4209                 }
4210 
4211                 // If there were no matching characters, skip over the loop altogether.
4212                 //   The loop doesn&#39;t run at all, a * op always succeeds.
4213                 if (ix == fp-&gt;fInputIdx) {
4214                     fp-&gt;fPatIdx++;   // skip the URX_LOOP_C op.
4215                     break;
4216                 }
4217 
4218                 // Peek ahead in the compiled pattern, to the URX_LOOP_C that
4219                 //   must follow.  It&#39;s operand is the stack location
4220                 //   that holds the starting input index for the match of this .*
4221                 int32_t loopcOp = (int32_t)pat[fp-&gt;fPatIdx];
4222                 U_ASSERT(URX_TYPE(loopcOp) == URX_LOOP_C);
4223                 int32_t stackLoc = URX_VAL(loopcOp);
4224                 U_ASSERT(stackLoc &gt;= 0 &amp;&amp; stackLoc &lt; fFrameSize);
4225                 fp-&gt;fExtra[stackLoc] = fp-&gt;fInputIdx;
4226                 fp-&gt;fInputIdx = ix;
4227 
4228                 // Save State to the URX_LOOP_C op that follows this one,
4229                 //   so that match failures in the following code will return to there.
4230                 //   Then bump the pattern idx so the LOOP_C is skipped on the way out of here.
4231                 fp = StateSave(fp, fp-&gt;fPatIdx, status);
4232                 fp-&gt;fPatIdx++;
4233             }
4234             break;
4235 
4236 
4237         case URX_LOOP_C:
4238             {
4239                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue&lt;fFrameSize);
4240                 backSearchIndex = fp-&gt;fExtra[opValue];
4241                 U_ASSERT(backSearchIndex &lt;= fp-&gt;fInputIdx);
4242                 if (backSearchIndex == fp-&gt;fInputIdx) {
4243                     // We&#39;ve backed up the input idx to the point that the loop started.
4244                     // The loop is done.  Leave here without saving state.
4245                     //  Subsequent failures won&#39;t come back here.
4246                     break;
4247                 }
4248                 // Set up for the next iteration of the loop, with input index
4249                 //   backed up by one from the last time through,
4250                 //   and a state save to this instruction in case the following code fails again.
4251                 //   (We&#39;re going backwards because this loop emulates stack unwinding, not
4252                 //    the initial scan forward.)
4253                 U_ASSERT(fp-&gt;fInputIdx &gt; 0);
4254                 UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
4255                 UChar32 prevC = UTEXT_PREVIOUS32(fInputText);
4256                 fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
4257 
4258                 UChar32 twoPrevC = UTEXT_PREVIOUS32(fInputText);
4259                 if (prevC == 0x0a &amp;&amp;
4260                     fp-&gt;fInputIdx &gt; backSearchIndex &amp;&amp;
4261                     twoPrevC == 0x0d) {
4262                     int32_t prevOp = (int32_t)pat[fp-&gt;fPatIdx-2];
4263                     if (URX_TYPE(prevOp) == URX_LOOP_DOT_I) {
4264                         // .*, stepping back over CRLF pair.
4265                         fp-&gt;fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
4266                     }
4267                 }
4268 
4269 
4270                 fp = StateSave(fp, fp-&gt;fPatIdx-1, status);
4271             }
4272             break;
4273 
4274 
4275 
4276         default:
4277             // Trouble.  The compiled pattern contains an entry with an
4278             //           unrecognized type tag.
<a name="28" id="anc28"></a><span class="line-modified">4279             UPRV_UNREACHABLE;</span>
4280         }
4281 
4282         if (U_FAILURE(status)) {
4283             isMatch = FALSE;
4284             break;
4285         }
4286     }
4287 
4288 breakFromLoop:
4289     fMatch = isMatch;
4290     if (isMatch) {
4291         fLastMatchEnd = fMatchEnd;
4292         fMatchStart   = startIdx;
4293         fMatchEnd     = fp-&gt;fInputIdx;
4294     }
4295 
4296 #ifdef REGEX_RUN_DEBUG
4297     if (fTraceDebug) {
4298         if (isMatch) {
4299             printf(&quot;Match.  start=%ld   end=%ld\n\n&quot;, fMatchStart, fMatchEnd);
4300         } else {
4301             printf(&quot;No match\n\n&quot;);
4302         }
4303     }
4304 #endif
4305 
4306     fFrame = fp;                // The active stack frame when the engine stopped.
4307                                 //   Contains the capture group results that we need to
4308                                 //    access later.
4309     return;
4310 }
4311 
4312 
4313 //--------------------------------------------------------------------------------
4314 //
4315 //   MatchChunkAt   This is the actual matching engine. Like MatchAt, but with the
4316 //                  assumption that the entire string is available in the UText&#39;s
4317 //                  chunk buffer. For now, that means we can use int32_t indexes,
4318 //                  except for anything that needs to be saved (like group starts
4319 //                  and ends).
4320 //
4321 //                  startIdx:    begin matching a this index.
4322 //                  toEnd:       if true, match must extend to end of the input region
4323 //
4324 //--------------------------------------------------------------------------------
4325 void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &amp;status) {
4326     UBool       isMatch  = FALSE;      // True if the we have a match.
4327 
4328     int32_t     backSearchIndex = INT32_MAX; // used after greedy single-character matches for searching backwards
4329 
4330     int32_t     op;                    // Operation from the compiled pattern, split into
4331     int32_t     opType;                //    the opcode
4332     int32_t     opValue;               //    and the operand value.
4333 
4334 #ifdef REGEX_RUN_DEBUG
4335     if (fTraceDebug) {
4336         printf(&quot;MatchAt(startIdx=%d)\n&quot;, startIdx);
4337         printf(&quot;Original Pattern: \&quot;%s\&quot;\n&quot;, CStr(StringFromUText(fPattern-&gt;fPattern))());
4338         printf(&quot;Input String:     \&quot;%s\&quot;\n\n&quot;, CStr(StringFromUText(fInputText))());
4339     }
4340 #endif
4341 
4342     if (U_FAILURE(status)) {
4343         return;
4344     }
4345 
4346     //  Cache frequently referenced items from the compiled pattern
4347     //
4348     int64_t             *pat           = fPattern-&gt;fCompiledPat-&gt;getBuffer();
4349 
4350     const UChar         *litText       = fPattern-&gt;fLiteralText.getBuffer();
<a name="29" id="anc29"></a><span class="line-modified">4351     UVector             *fSets         = fPattern-&gt;fSets;</span>
4352 
4353     const UChar         *inputBuf      = fInputText-&gt;chunkContents;
4354 
4355     fFrameSize = fPattern-&gt;fFrameSize;
4356     REStackFrame        *fp            = resetStack();
4357     if (U_FAILURE(fDeferredStatus)) {
4358         status = fDeferredStatus;
4359         return;
4360     }
4361 
4362     fp-&gt;fPatIdx   = 0;
4363     fp-&gt;fInputIdx = startIdx;
4364 
4365     // Zero out the pattern&#39;s static data
4366     int32_t i;
4367     for (i = 0; i&lt;fPattern-&gt;fDataSize; i++) {
4368         fData[i] = 0;
4369     }
4370 
4371     //
4372     //  Main loop for interpreting the compiled pattern.
4373     //  One iteration of the loop per pattern operation performed.
4374     //
4375     for (;;) {
4376         op      = (int32_t)pat[fp-&gt;fPatIdx];
4377         opType  = URX_TYPE(op);
4378         opValue = URX_VAL(op);
4379 #ifdef REGEX_RUN_DEBUG
4380         if (fTraceDebug) {
4381             UTEXT_SETNATIVEINDEX(fInputText, fp-&gt;fInputIdx);
4382             printf(&quot;inputIdx=%ld   inputChar=%x   sp=%3ld   activeLimit=%ld  &quot;, fp-&gt;fInputIdx,
4383                    UTEXT_CURRENT32(fInputText), (int64_t *)fp-fStack-&gt;getBuffer(), fActiveLimit);
4384             fPattern-&gt;dumpOp(fp-&gt;fPatIdx);
4385         }
4386 #endif
4387         fp-&gt;fPatIdx++;
4388 
4389         switch (opType) {
4390 
4391 
4392         case URX_NOP:
4393             break;
4394 
4395 
4396         case URX_BACKTRACK:
4397             // Force a backtrack.  In some circumstances, the pattern compiler
4398             //   will notice that the pattern can&#39;t possibly match anything, and will
4399             //   emit one of these at that point.
4400             fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4401             break;
4402 
4403 
4404         case URX_ONECHAR:
4405             if (fp-&gt;fInputIdx &lt; fActiveLimit) {
4406                 UChar32 c;
4407                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4408                 if (c == opValue) {
4409                     break;
4410                 }
4411             } else {
4412                 fHitEnd = TRUE;
4413             }
4414             fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4415             break;
4416 
4417 
4418         case URX_STRING:
4419             {
4420                 // Test input against a literal string.
4421                 // Strings require two slots in the compiled pattern, one for the
4422                 //   offset to the string text, and one for the length.
4423                 int32_t   stringStartIdx = opValue;
4424                 int32_t   stringLen;
4425 
4426                 op      = (int32_t)pat[fp-&gt;fPatIdx];     // Fetch the second operand
4427                 fp-&gt;fPatIdx++;
4428                 opType    = URX_TYPE(op);
4429                 stringLen = URX_VAL(op);
4430                 U_ASSERT(opType == URX_STRING_LEN);
4431                 U_ASSERT(stringLen &gt;= 2);
4432 
4433                 const UChar * pInp = inputBuf + fp-&gt;fInputIdx;
4434                 const UChar * pInpLimit = inputBuf + fActiveLimit;
4435                 const UChar * pPat = litText+stringStartIdx;
4436                 const UChar * pEnd = pInp + stringLen;
4437                 UBool success = TRUE;
4438                 while (pInp &lt; pEnd) {
4439                     if (pInp &gt;= pInpLimit) {
4440                         fHitEnd = TRUE;
4441                         success = FALSE;
4442                         break;
4443                     }
4444                     if (*pInp++ != *pPat++) {
4445                         success = FALSE;
4446                         break;
4447                     }
4448                 }
4449 
4450                 if (success) {
4451                     fp-&gt;fInputIdx += stringLen;
4452                 } else {
4453                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4454                 }
4455             }
4456             break;
4457 
4458 
4459         case URX_STATE_SAVE:
4460             fp = StateSave(fp, opValue, status);
4461             break;
4462 
4463 
4464         case URX_END:
4465             // The match loop will exit via this path on a successful match,
4466             //   when we reach the end of the pattern.
4467             if (toEnd &amp;&amp; fp-&gt;fInputIdx != fActiveLimit) {
4468                 // The pattern matched, but not to the end of input.  Try some more.
4469                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4470                 break;
4471             }
4472             isMatch = TRUE;
4473             goto  breakFromLoop;
4474 
4475             // Start and End Capture stack frame variables are laid out out like this:
4476             //  fp-&gt;fExtra[opValue]  - The start of a completed capture group
4477             //             opValue+1 - The end   of a completed capture group
4478             //             opValue+2 - the start of a capture group whose end
4479             //                          has not yet been reached (and might not ever be).
4480         case URX_START_CAPTURE:
4481             U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fFrameSize-3);
4482             fp-&gt;fExtra[opValue+2] = fp-&gt;fInputIdx;
4483             break;
4484 
4485 
4486         case URX_END_CAPTURE:
4487             U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fFrameSize-3);
4488             U_ASSERT(fp-&gt;fExtra[opValue+2] &gt;= 0);            // Start pos for this group must be set.
4489             fp-&gt;fExtra[opValue]   = fp-&gt;fExtra[opValue+2];   // Tentative start becomes real.
4490             fp-&gt;fExtra[opValue+1] = fp-&gt;fInputIdx;           // End position
4491             U_ASSERT(fp-&gt;fExtra[opValue] &lt;= fp-&gt;fExtra[opValue+1]);
4492             break;
4493 
4494 
4495         case URX_DOLLAR:                   //  $, test for End of line
4496             //     or for position before new line at end of input
4497             if (fp-&gt;fInputIdx &lt; fAnchorLimit-2) {
4498                 // We are no where near the end of input.  Fail.
4499                 //   This is the common case.  Keep it first.
4500                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4501                 break;
4502             }
4503             if (fp-&gt;fInputIdx &gt;= fAnchorLimit) {
4504                 // We really are at the end of input.  Success.
4505                 fHitEnd = TRUE;
4506                 fRequireEnd = TRUE;
4507                 break;
4508             }
4509 
4510             // If we are positioned just before a new-line that is located at the
4511             //   end of input, succeed.
4512             if (fp-&gt;fInputIdx == fAnchorLimit-1) {
4513                 UChar32 c;
4514                 U16_GET(inputBuf, fAnchorStart, fp-&gt;fInputIdx, fAnchorLimit, c);
4515 
4516                 if (isLineTerminator(c)) {
4517                     if ( !(c==0x0a &amp;&amp; fp-&gt;fInputIdx&gt;fAnchorStart &amp;&amp; inputBuf[fp-&gt;fInputIdx-1]==0x0d)) {
4518                         // At new-line at end of input. Success
4519                         fHitEnd = TRUE;
4520                         fRequireEnd = TRUE;
4521                         break;
4522                     }
4523                 }
4524             } else if (fp-&gt;fInputIdx == fAnchorLimit-2 &amp;&amp;
4525                 inputBuf[fp-&gt;fInputIdx]==0x0d &amp;&amp; inputBuf[fp-&gt;fInputIdx+1]==0x0a) {
4526                     fHitEnd = TRUE;
4527                     fRequireEnd = TRUE;
4528                     break;                         // At CR/LF at end of input.  Success
4529             }
4530 
4531             fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4532 
4533             break;
4534 
4535 
4536         case URX_DOLLAR_D:                   //  $, test for End of Line, in UNIX_LINES mode.
4537             if (fp-&gt;fInputIdx &gt;= fAnchorLimit-1) {
4538                 // Either at the last character of input, or off the end.
4539                 if (fp-&gt;fInputIdx == fAnchorLimit-1) {
4540                     // At last char of input.  Success if it&#39;s a new line.
4541                     if (inputBuf[fp-&gt;fInputIdx] == 0x0a) {
4542                         fHitEnd = TRUE;
4543                         fRequireEnd = TRUE;
4544                         break;
4545                     }
4546                 } else {
4547                     // Off the end of input.  Success.
4548                     fHitEnd = TRUE;
4549                     fRequireEnd = TRUE;
4550                     break;
4551                 }
4552             }
4553 
4554             // Not at end of input.  Back-track out.
4555             fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4556             break;
4557 
4558 
4559         case URX_DOLLAR_M:                //  $, test for End of line in multi-line mode
4560             {
4561                 if (fp-&gt;fInputIdx &gt;= fAnchorLimit) {
4562                     // We really are at the end of input.  Success.
4563                     fHitEnd = TRUE;
4564                     fRequireEnd = TRUE;
4565                     break;
4566                 }
4567                 // If we are positioned just before a new-line, succeed.
4568                 // It makes no difference where the new-line is within the input.
4569                 UChar32 c = inputBuf[fp-&gt;fInputIdx];
4570                 if (isLineTerminator(c)) {
4571                     // At a line end, except for the odd chance of  being in the middle of a CR/LF sequence
4572                     //  In multi-line mode, hitting a new-line just before the end of input does not
4573                     //   set the hitEnd or requireEnd flags
4574                     if ( !(c==0x0a &amp;&amp; fp-&gt;fInputIdx&gt;fAnchorStart &amp;&amp; inputBuf[fp-&gt;fInputIdx-1]==0x0d)) {
4575                         break;
4576                     }
4577                 }
4578                 // not at a new line.  Fail.
4579                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4580             }
4581             break;
4582 
4583 
4584         case URX_DOLLAR_MD:                //  $, test for End of line in multi-line and UNIX_LINES mode
4585             {
4586                 if (fp-&gt;fInputIdx &gt;= fAnchorLimit) {
4587                     // We really are at the end of input.  Success.
4588                     fHitEnd = TRUE;
4589                     fRequireEnd = TRUE;  // Java set requireEnd in this case, even though
4590                     break;               //   adding a new-line would not lose the match.
4591                 }
4592                 // If we are not positioned just before a new-line, the test fails; backtrack out.
4593                 // It makes no difference where the new-line is within the input.
4594                 if (inputBuf[fp-&gt;fInputIdx] != 0x0a) {
4595                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4596                 }
4597             }
4598             break;
4599 
4600 
4601         case URX_CARET:                    //  ^, test for start of line
4602             if (fp-&gt;fInputIdx != fAnchorStart) {
4603                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4604             }
4605             break;
4606 
4607 
4608         case URX_CARET_M:                   //  ^, test for start of line in mulit-line mode
4609             {
4610                 if (fp-&gt;fInputIdx == fAnchorStart) {
4611                     // We are at the start input.  Success.
4612                     break;
4613                 }
4614                 // Check whether character just before the current pos is a new-line
4615                 //   unless we are at the end of input
4616                 UChar  c = inputBuf[fp-&gt;fInputIdx - 1];
4617                 if ((fp-&gt;fInputIdx &lt; fAnchorLimit) &amp;&amp;
4618                     isLineTerminator(c)) {
4619                     //  It&#39;s a new-line.  ^ is true.  Success.
4620                     //  TODO:  what should be done with positions between a CR and LF?
4621                     break;
4622                 }
4623                 // Not at the start of a line.  Fail.
4624                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4625             }
4626             break;
4627 
4628 
4629         case URX_CARET_M_UNIX:       //  ^, test for start of line in mulit-line + Unix-line mode
4630             {
4631                 U_ASSERT(fp-&gt;fInputIdx &gt;= fAnchorStart);
4632                 if (fp-&gt;fInputIdx &lt;= fAnchorStart) {
4633                     // We are at the start input.  Success.
4634                     break;
4635                 }
4636                 // Check whether character just before the current pos is a new-line
4637                 U_ASSERT(fp-&gt;fInputIdx &lt;= fAnchorLimit);
4638                 UChar  c = inputBuf[fp-&gt;fInputIdx - 1];
4639                 if (c != 0x0a) {
4640                     // Not at the start of a line.  Back-track out.
4641                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4642                 }
4643             }
4644             break;
4645 
4646         case URX_BACKSLASH_B:          // Test for word boundaries
4647             {
4648                 UBool success = isChunkWordBoundary((int32_t)fp-&gt;fInputIdx);
4649                 success ^= (UBool)(opValue != 0);     // flip sense for \B
4650                 if (!success) {
4651                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4652                 }
4653             }
4654             break;
4655 
4656 
4657         case URX_BACKSLASH_BU:          // Test for word boundaries, Unicode-style
4658             {
4659                 UBool success = isUWordBoundary(fp-&gt;fInputIdx);
4660                 success ^= (UBool)(opValue != 0);     // flip sense for \B
4661                 if (!success) {
4662                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4663                 }
4664             }
4665             break;
4666 
4667 
4668         case URX_BACKSLASH_D:            // Test for decimal digit
4669             {
4670                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4671                     fHitEnd = TRUE;
4672                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4673                     break;
4674                 }
4675 
4676                 UChar32 c;
4677                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4678                 int8_t ctype = u_charType(c);     // TODO:  make a unicode set for this.  Will be faster.
4679                 UBool success = (ctype == U_DECIMAL_DIGIT_NUMBER);
4680                 success ^= (UBool)(opValue != 0);        // flip sense for \D
4681                 if (!success) {
4682                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4683                 }
4684             }
4685             break;
4686 
4687 
4688         case URX_BACKSLASH_G:          // Test for position at end of previous match
4689             if (!((fMatch &amp;&amp; fp-&gt;fInputIdx==fMatchEnd) || (fMatch==FALSE &amp;&amp; fp-&gt;fInputIdx==fActiveStart))) {
4690                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4691             }
4692             break;
4693 
4694 
4695         case URX_BACKSLASH_H:            // Test for \h, horizontal white space.
4696             {
4697                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4698                     fHitEnd = TRUE;
4699                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4700                     break;
4701                 }
4702                 UChar32 c;
4703                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4704                 int8_t ctype = u_charType(c);
4705                 UBool success = (ctype == U_SPACE_SEPARATOR || c == 9);  // SPACE_SEPARATOR || TAB
4706                 success ^= (UBool)(opValue != 0);        // flip sense for \H
4707                 if (!success) {
4708                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4709                 }
4710             }
4711             break;
4712 
4713 
4714         case URX_BACKSLASH_R:            // Test for \R, any line break sequence.
4715             {
4716                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4717                     fHitEnd = TRUE;
4718                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4719                     break;
4720                 }
4721                 UChar32 c;
4722                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4723                 if (isLineTerminator(c)) {
4724                     if (c == 0x0d &amp;&amp; fp-&gt;fInputIdx &lt; fActiveLimit) {
4725                         // Check for CR/LF sequence. Consume both together when found.
4726                         UChar c2;
4727                         U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c2);
4728                         if (c2 != 0x0a) {
4729                             U16_PREV(inputBuf, 0, fp-&gt;fInputIdx, c2);
4730                         }
4731                     }
4732                 } else {
4733                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4734                 }
4735             }
4736             break;
4737 
4738 
4739         case URX_BACKSLASH_V:         // Any single code point line ending.
4740             {
4741                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4742                     fHitEnd = TRUE;
4743                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4744                     break;
4745                 }
4746                 UChar32 c;
4747                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4748                 UBool success = isLineTerminator(c);
4749                 success ^= (UBool)(opValue != 0);        // flip sense for \V
4750                 if (!success) {
4751                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4752                 }
4753             }
4754             break;
4755 
4756 
4757 
4758         case URX_BACKSLASH_X:
4759         //  Match a Grapheme, as defined by Unicode TR 29.
4760         //  Differs slightly from Perl, which consumes combining marks independently
4761         //    of context.
4762         {
4763 
4764             // Fail if at end of input
4765             if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4766                 fHitEnd = TRUE;
4767                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4768                 break;
4769             }
4770 
4771             // Examine (and consume) the current char.
4772             //   Dispatch into a little state machine, based on the char.
4773             UChar32  c;
4774             U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4775             UnicodeSet **sets = fPattern-&gt;fStaticSets;
4776             if (sets[URX_GC_NORMAL]-&gt;contains(c))  goto GC_Extend;
4777             if (sets[URX_GC_CONTROL]-&gt;contains(c)) goto GC_Control;
4778             if (sets[URX_GC_L]-&gt;contains(c))       goto GC_L;
4779             if (sets[URX_GC_LV]-&gt;contains(c))      goto GC_V;
4780             if (sets[URX_GC_LVT]-&gt;contains(c))     goto GC_T;
4781             if (sets[URX_GC_V]-&gt;contains(c))       goto GC_V;
4782             if (sets[URX_GC_T]-&gt;contains(c))       goto GC_T;
4783             goto GC_Extend;
4784 
4785 
4786 
4787 GC_L:
4788             if (fp-&gt;fInputIdx &gt;= fActiveLimit)         goto GC_Done;
4789             U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4790             if (sets[URX_GC_L]-&gt;contains(c))       goto GC_L;
4791             if (sets[URX_GC_LV]-&gt;contains(c))      goto GC_V;
4792             if (sets[URX_GC_LVT]-&gt;contains(c))     goto GC_T;
4793             if (sets[URX_GC_V]-&gt;contains(c))       goto GC_V;
4794             U16_PREV(inputBuf, 0, fp-&gt;fInputIdx, c);
4795             goto GC_Extend;
4796 
4797 GC_V:
4798             if (fp-&gt;fInputIdx &gt;= fActiveLimit)         goto GC_Done;
4799             U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4800             if (sets[URX_GC_V]-&gt;contains(c))       goto GC_V;
4801             if (sets[URX_GC_T]-&gt;contains(c))       goto GC_T;
4802             U16_PREV(inputBuf, 0, fp-&gt;fInputIdx, c);
4803             goto GC_Extend;
4804 
4805 GC_T:
4806             if (fp-&gt;fInputIdx &gt;= fActiveLimit)         goto GC_Done;
4807             U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4808             if (sets[URX_GC_T]-&gt;contains(c))       goto GC_T;
4809             U16_PREV(inputBuf, 0, fp-&gt;fInputIdx, c);
4810             goto GC_Extend;
4811 
4812 GC_Extend:
4813             // Combining characters are consumed here
4814             for (;;) {
4815                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4816                     break;
4817                 }
4818                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4819                 if (sets[URX_GC_EXTEND]-&gt;contains(c) == FALSE) {
4820                     U16_BACK_1(inputBuf, 0, fp-&gt;fInputIdx);
4821                     break;
4822                 }
4823             }
4824             goto GC_Done;
4825 
4826 GC_Control:
4827             // Most control chars stand alone (don&#39;t combine with combining chars),
4828             //   except for that CR/LF sequence is a single grapheme cluster.
4829             if (c == 0x0d &amp;&amp; fp-&gt;fInputIdx &lt; fActiveLimit &amp;&amp; inputBuf[fp-&gt;fInputIdx] == 0x0a) {
4830                 fp-&gt;fInputIdx++;
4831             }
4832 
4833 GC_Done:
4834             if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4835                 fHitEnd = TRUE;
4836             }
4837             break;
4838         }
4839 
4840 
4841 
4842 
4843         case URX_BACKSLASH_Z:          // Test for end of Input
4844             if (fp-&gt;fInputIdx &lt; fAnchorLimit) {
4845                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4846             } else {
4847                 fHitEnd = TRUE;
4848                 fRequireEnd = TRUE;
4849             }
4850             break;
4851 
4852 
4853 
4854         case URX_STATIC_SETREF:
4855             {
4856                 // Test input character against one of the predefined sets
4857                 //    (Word Characters, for example)
4858                 // The high bit of the op value is a flag for the match polarity.
4859                 //    0:   success if input char is in set.
4860                 //    1:   success if input char is not in set.
4861                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4862                     fHitEnd = TRUE;
4863                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4864                     break;
4865                 }
4866 
4867                 UBool success = ((opValue &amp; URX_NEG_SET) == URX_NEG_SET);
4868                 opValue &amp;= ~URX_NEG_SET;
4869                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; URX_LAST_SET);
4870 
4871                 UChar32 c;
4872                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4873                 if (c &lt; 256) {
4874                     Regex8BitSet *s8 = &amp;fPattern-&gt;fStaticSets8[opValue];
4875                     if (s8-&gt;contains(c)) {
4876                         success = !success;
4877                     }
4878                 } else {
4879                     const UnicodeSet *s = fPattern-&gt;fStaticSets[opValue];
4880                     if (s-&gt;contains(c)) {
4881                         success = !success;
4882                     }
4883                 }
4884                 if (!success) {
4885                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4886                 }
4887             }
4888             break;
4889 
4890 
4891         case URX_STAT_SETREF_N:
4892             {
4893                 // Test input character for NOT being a member of  one of
4894                 //    the predefined sets (Word Characters, for example)
4895                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4896                     fHitEnd = TRUE;
4897                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4898                     break;
4899                 }
4900 
4901                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; URX_LAST_SET);
4902 
4903                 UChar32  c;
4904                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4905                 if (c &lt; 256) {
4906                     Regex8BitSet *s8 = &amp;fPattern-&gt;fStaticSets8[opValue];
4907                     if (s8-&gt;contains(c) == FALSE) {
4908                         break;
4909                     }
4910                 } else {
4911                     const UnicodeSet *s = fPattern-&gt;fStaticSets[opValue];
4912                     if (s-&gt;contains(c) == FALSE) {
4913                         break;
4914                     }
4915                 }
4916                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4917             }
4918             break;
4919 
4920 
4921         case URX_SETREF:
4922             {
4923                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4924                     fHitEnd = TRUE;
4925                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4926                     break;
4927                 }
4928 
<a name="30" id="anc30"></a><span class="line-modified">4929                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; fSets-&gt;size());</span>
4930 
4931                 // There is input left.  Pick up one char and test it for set membership.
4932                 UChar32  c;
4933                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4934                 if (c&lt;256) {
4935                     Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
4936                     if (s8-&gt;contains(c)) {
4937                         // The character is in the set.  A Match.
4938                         break;
4939                     }
4940                 } else {
<a name="31" id="anc31"></a><span class="line-modified">4941                     UnicodeSet *s = (UnicodeSet *)fSets-&gt;elementAt(opValue);</span>
4942                     if (s-&gt;contains(c)) {
4943                         // The character is in the set.  A Match.
4944                         break;
4945                     }
4946                 }
4947 
4948                 // the character wasn&#39;t in the set.
4949                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4950             }
4951             break;
4952 
4953 
4954         case URX_DOTANY:
4955             {
4956                 // . matches anything, but stops at end-of-line.
4957                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4958                     // At end of input.  Match failed.  Backtrack out.
4959                     fHitEnd = TRUE;
4960                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4961                     break;
4962                 }
4963 
4964                 // There is input left.  Advance over one char, unless we&#39;ve hit end-of-line
4965                 UChar32  c;
4966                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4967                 if (isLineTerminator(c)) {
4968                     // End of line in normal mode.   . does not match.
4969                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4970                     break;
4971                 }
4972             }
4973             break;
4974 
4975 
4976         case URX_DOTANY_ALL:
4977             {
4978                 // . in dot-matches-all (including new lines) mode
4979                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
4980                     // At end of input.  Match failed.  Backtrack out.
4981                     fHitEnd = TRUE;
4982                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
4983                     break;
4984                 }
4985 
4986                 // There is input left.  Advance over one char, except if we are
4987                 //   at a cr/lf, advance over both of them.
4988                 UChar32 c;
4989                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
4990                 if (c==0x0d &amp;&amp; fp-&gt;fInputIdx &lt; fActiveLimit) {
4991                     // In the case of a CR/LF, we need to advance over both.
4992                     if (inputBuf[fp-&gt;fInputIdx] == 0x0a) {
4993                         U16_FWD_1(inputBuf, fp-&gt;fInputIdx, fActiveLimit);
4994                     }
4995                 }
4996             }
4997             break;
4998 
4999 
5000         case URX_DOTANY_UNIX:
5001             {
5002                 // &#39;.&#39; operator, matches all, but stops at end-of-line.
5003                 //   UNIX_LINES mode, so 0x0a is the only recognized line ending.
5004                 if (fp-&gt;fInputIdx &gt;= fActiveLimit) {
5005                     // At end of input.  Match failed.  Backtrack out.
5006                     fHitEnd = TRUE;
5007                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
5008                     break;
5009                 }
5010 
5011                 // There is input left.  Advance over one char, unless we&#39;ve hit end-of-line
5012                 UChar32 c;
5013                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
5014                 if (c == 0x0a) {
5015                     // End of line in normal mode.   &#39;.&#39; does not match the \n
5016                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
5017                 }
5018             }
5019             break;
5020 
5021 
5022         case URX_JMP:
5023             fp-&gt;fPatIdx = opValue;
5024             break;
5025 
5026         case URX_FAIL:
5027             isMatch = FALSE;
5028             goto breakFromLoop;
5029 
5030         case URX_JMP_SAV:
5031             U_ASSERT(opValue &lt; fPattern-&gt;fCompiledPat-&gt;size());
5032             fp = StateSave(fp, fp-&gt;fPatIdx, status);       // State save to loc following current
5033             fp-&gt;fPatIdx = opValue;                         // Then JMP.
5034             break;
5035 
5036         case URX_JMP_SAV_X:
5037             // This opcode is used with (x)+, when x can match a zero length string.
5038             // Same as JMP_SAV, except conditional on the match having made forward progress.
5039             // Destination of the JMP must be a URX_STO_INP_LOC, from which we get the
5040             //   data address of the input position at the start of the loop.
5041             {
5042                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; fPattern-&gt;fCompiledPat-&gt;size());
5043                 int32_t  stoOp = (int32_t)pat[opValue-1];
5044                 U_ASSERT(URX_TYPE(stoOp) == URX_STO_INP_LOC);
5045                 int32_t  frameLoc = URX_VAL(stoOp);
5046                 U_ASSERT(frameLoc &gt;= 0 &amp;&amp; frameLoc &lt; fFrameSize);
5047                 int32_t prevInputIdx = (int32_t)fp-&gt;fExtra[frameLoc];
5048                 U_ASSERT(prevInputIdx &lt;= fp-&gt;fInputIdx);
5049                 if (prevInputIdx &lt; fp-&gt;fInputIdx) {
5050                     // The match did make progress.  Repeat the loop.
5051                     fp = StateSave(fp, fp-&gt;fPatIdx, status);  // State save to loc following current
5052                     fp-&gt;fPatIdx = opValue;
5053                     fp-&gt;fExtra[frameLoc] = fp-&gt;fInputIdx;
5054                 }
5055                 // If the input position did not advance, we do nothing here,
5056                 //   execution will fall out of the loop.
5057             }
5058             break;
5059 
5060         case URX_CTR_INIT:
5061             {
5062                 U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fFrameSize-2);
5063                 fp-&gt;fExtra[opValue] = 0;                 //  Set the loop counter variable to zero
5064 
5065                 // Pick up the three extra operands that CTR_INIT has, and
5066                 //    skip the pattern location counter past
5067                 int32_t instrOperandLoc = (int32_t)fp-&gt;fPatIdx;
5068                 fp-&gt;fPatIdx += 3;
5069                 int32_t loopLoc  = URX_VAL(pat[instrOperandLoc]);
5070                 int32_t minCount = (int32_t)pat[instrOperandLoc+1];
5071                 int32_t maxCount = (int32_t)pat[instrOperandLoc+2];
5072                 U_ASSERT(minCount&gt;=0);
5073                 U_ASSERT(maxCount&gt;=minCount || maxCount==-1);
5074                 U_ASSERT(loopLoc&gt;=fp-&gt;fPatIdx);
5075 
5076                 if (minCount == 0) {
5077                     fp = StateSave(fp, loopLoc+1, status);
5078                 }
5079                 if (maxCount == -1) {
5080                     fp-&gt;fExtra[opValue+1] = fp-&gt;fInputIdx;   //  For loop breaking.
5081                 } else if (maxCount == 0) {
5082                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
5083                 }
5084             }
5085             break;
5086 
5087         case URX_CTR_LOOP:
5088             {
5089                 U_ASSERT(opValue&gt;0 &amp;&amp; opValue &lt; fp-&gt;fPatIdx-2);
5090                 int32_t initOp = (int32_t)pat[opValue];
5091                 U_ASSERT(URX_TYPE(initOp) == URX_CTR_INIT);
5092                 int64_t *pCounter = &amp;fp-&gt;fExtra[URX_VAL(initOp)];
5093                 int32_t minCount  = (int32_t)pat[opValue+2];
5094                 int32_t maxCount  = (int32_t)pat[opValue+3];
5095                 (*pCounter)++;
5096                 if ((uint64_t)*pCounter &gt;= (uint32_t)maxCount &amp;&amp; maxCount != -1) {
5097                     U_ASSERT(*pCounter == maxCount);
5098                     break;
5099                 }
5100                 if (*pCounter &gt;= minCount) {
5101                     if (maxCount == -1) {
5102                         // Loop has no hard upper bound.
5103                         // Check that it is progressing through the input, break if it is not.
5104                         int64_t *pLastInputIdx =  &amp;fp-&gt;fExtra[URX_VAL(initOp) + 1];
5105                         if (fp-&gt;fInputIdx == *pLastInputIdx) {
5106                             break;
5107                         } else {
5108                             *pLastInputIdx = fp-&gt;fInputIdx;
5109                         }
5110                     }
5111                     fp = StateSave(fp, fp-&gt;fPatIdx, status);
5112                 } else {
5113                     // Increment time-out counter. (StateSave() does it if count &gt;= minCount)
5114                     fTickCounter--;
5115                     if (fTickCounter &lt;= 0) {
5116                         IncrementTime(status);    // Re-initializes fTickCounter
5117                     }
5118                 }
5119                 fp-&gt;fPatIdx = opValue + 4;    // Loop back.
5120             }
5121             break;
5122 
5123         case URX_CTR_INIT_NG:
5124             {
5125                 // Initialize a non-greedy loop
5126                 U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fFrameSize-2);
5127                 fp-&gt;fExtra[opValue] = 0;                 //  Set the loop counter variable to zero
5128 
5129                 // Pick up the three extra operands that CTR_INIT_NG has, and
5130                 //    skip the pattern location counter past
5131                 int32_t instrOperandLoc = (int32_t)fp-&gt;fPatIdx;
5132                 fp-&gt;fPatIdx += 3;
5133                 int32_t loopLoc  = URX_VAL(pat[instrOperandLoc]);
5134                 int32_t minCount = (int32_t)pat[instrOperandLoc+1];
5135                 int32_t maxCount = (int32_t)pat[instrOperandLoc+2];
5136                 U_ASSERT(minCount&gt;=0);
5137                 U_ASSERT(maxCount&gt;=minCount || maxCount==-1);
5138                 U_ASSERT(loopLoc&gt;fp-&gt;fPatIdx);
5139                 if (maxCount == -1) {
5140                     fp-&gt;fExtra[opValue+1] = fp-&gt;fInputIdx;   //  Save initial input index for loop breaking.
5141                 }
5142 
5143                 if (minCount == 0) {
5144                     if (maxCount != 0) {
5145                         fp = StateSave(fp, fp-&gt;fPatIdx, status);
5146                     }
5147                     fp-&gt;fPatIdx = loopLoc+1;   // Continue with stuff after repeated block
5148                 }
5149             }
5150             break;
5151 
5152         case URX_CTR_LOOP_NG:
5153             {
5154                 // Non-greedy {min, max} loops
5155                 U_ASSERT(opValue&gt;0 &amp;&amp; opValue &lt; fp-&gt;fPatIdx-2);
5156                 int32_t initOp = (int32_t)pat[opValue];
5157                 U_ASSERT(URX_TYPE(initOp) == URX_CTR_INIT_NG);
5158                 int64_t *pCounter = &amp;fp-&gt;fExtra[URX_VAL(initOp)];
5159                 int32_t minCount  = (int32_t)pat[opValue+2];
5160                 int32_t maxCount  = (int32_t)pat[opValue+3];
5161 
5162                 (*pCounter)++;
5163                 if ((uint64_t)*pCounter &gt;= (uint32_t)maxCount &amp;&amp; maxCount != -1) {
5164                     // The loop has matched the maximum permitted number of times.
5165                     //   Break out of here with no action.  Matching will
5166                     //   continue with the following pattern.
5167                     U_ASSERT(*pCounter == maxCount);
5168                     break;
5169                 }
5170 
5171                 if (*pCounter &lt; minCount) {
5172                     // We haven&#39;t met the minimum number of matches yet.
5173                     //   Loop back for another one.
5174                     fp-&gt;fPatIdx = opValue + 4;    // Loop back.
5175                     fTickCounter--;
5176                     if (fTickCounter &lt;= 0) {
5177                         IncrementTime(status);    // Re-initializes fTickCounter
5178                     }
5179                 } else {
5180                     // We do have the minimum number of matches.
5181 
5182                     // If there is no upper bound on the loop iterations, check that the input index
5183                     // is progressing, and stop the loop if it is not.
5184                     if (maxCount == -1) {
5185                         int64_t *pLastInputIdx =  &amp;fp-&gt;fExtra[URX_VAL(initOp) + 1];
5186                         if (fp-&gt;fInputIdx == *pLastInputIdx) {
5187                             break;
5188                         }
5189                         *pLastInputIdx = fp-&gt;fInputIdx;
5190                     }
5191 
5192                     // Loop Continuation: we will fall into the pattern following the loop
5193                     //   (non-greedy, don&#39;t execute loop body first), but first do
5194                     //   a state save to the top of the loop, so that a match failure
5195                     //   in the following pattern will try another iteration of the loop.
5196                     fp = StateSave(fp, opValue + 4, status);
5197                 }
5198             }
5199             break;
5200 
5201         case URX_STO_SP:
5202             U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fPattern-&gt;fDataSize);
5203             fData[opValue] = fStack-&gt;size();
5204             break;
5205 
5206         case URX_LD_SP:
5207             {
5208                 U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fPattern-&gt;fDataSize);
5209                 int32_t newStackSize = (int32_t)fData[opValue];
5210                 U_ASSERT(newStackSize &lt;= fStack-&gt;size());
5211                 int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
5212                 if (newFP == (int64_t *)fp) {
5213                     break;
5214                 }
<a name="32" id="anc32"></a><span class="line-modified">5215                 int32_t j;</span>
<span class="line-modified">5216                 for (j=0; j&lt;fFrameSize; j++) {</span>
<span class="line-modified">5217                     newFP[j] = ((int64_t *)fp)[j];</span>
5218                 }
5219                 fp = (REStackFrame *)newFP;
5220                 fStack-&gt;setSize(newStackSize);
5221             }
5222             break;
5223 
5224         case URX_BACKREF:
5225             {
5226                 U_ASSERT(opValue &lt; fFrameSize);
5227                 int64_t groupStartIdx = fp-&gt;fExtra[opValue];
5228                 int64_t groupEndIdx   = fp-&gt;fExtra[opValue+1];
5229                 U_ASSERT(groupStartIdx &lt;= groupEndIdx);
5230                 int64_t inputIndex = fp-&gt;fInputIdx;
5231                 if (groupStartIdx &lt; 0) {
5232                     // This capture group has not participated in the match thus far,
5233                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);   // FAIL, no match.
5234                     break;
5235                 }
5236                 UBool success = TRUE;
5237                 for (int64_t groupIndex = groupStartIdx; groupIndex &lt; groupEndIdx; ++groupIndex,++inputIndex) {
5238                     if (inputIndex &gt;= fActiveLimit) {
5239                         success = FALSE;
5240                         fHitEnd = TRUE;
5241                         break;
5242                     }
5243                     if (inputBuf[groupIndex] != inputBuf[inputIndex]) {
5244                         success = FALSE;
5245                         break;
5246                     }
5247                 }
5248                 if (success &amp;&amp; groupStartIdx &lt; groupEndIdx &amp;&amp; U16_IS_LEAD(inputBuf[groupEndIdx-1]) &amp;&amp;
5249                         inputIndex &lt; fActiveLimit &amp;&amp; U16_IS_TRAIL(inputBuf[inputIndex])) {
5250                     // Capture group ended with an unpaired lead surrogate.
5251                     // Back reference is not permitted to match lead only of a surrogatge pair.
5252                     success = FALSE;
5253                 }
5254                 if (success) {
5255                     fp-&gt;fInputIdx = inputIndex;
5256                 } else {
5257                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
5258                 }
5259             }
5260             break;
5261 
5262         case URX_BACKREF_I:
5263             {
5264                 U_ASSERT(opValue &lt; fFrameSize);
5265                 int64_t groupStartIdx = fp-&gt;fExtra[opValue];
5266                 int64_t groupEndIdx   = fp-&gt;fExtra[opValue+1];
5267                 U_ASSERT(groupStartIdx &lt;= groupEndIdx);
5268                 if (groupStartIdx &lt; 0) {
5269                     // This capture group has not participated in the match thus far,
5270                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);   // FAIL, no match.
5271                     break;
5272                 }
5273                 CaseFoldingUCharIterator captureGroupItr(inputBuf, groupStartIdx, groupEndIdx);
5274                 CaseFoldingUCharIterator inputItr(inputBuf, fp-&gt;fInputIdx, fActiveLimit);
5275 
5276                 //   Note: if the capture group match was of an empty string the backref
5277                 //         match succeeds.  Verified by testing:  Perl matches succeed
5278                 //         in this case, so we do too.
5279 
5280                 UBool success = TRUE;
5281                 for (;;) {
5282                     UChar32 captureGroupChar = captureGroupItr.next();
5283                     if (captureGroupChar == U_SENTINEL) {
5284                         success = TRUE;
5285                         break;
5286                     }
5287                     UChar32 inputChar = inputItr.next();
5288                     if (inputChar == U_SENTINEL) {
5289                         success = FALSE;
5290                         fHitEnd = TRUE;
5291                         break;
5292                     }
5293                     if (inputChar != captureGroupChar) {
5294                         success = FALSE;
5295                         break;
5296                     }
5297                 }
5298 
5299                 if (success &amp;&amp; inputItr.inExpansion()) {
5300                     // We otained a match by consuming part of a string obtained from
5301                     // case-folding a single code point of the input text.
5302                     // This does not count as an overall match.
5303                     success = FALSE;
5304                 }
5305 
5306                 if (success) {
5307                     fp-&gt;fInputIdx = inputItr.getIndex();
5308                 } else {
5309                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
5310                 }
5311             }
5312             break;
5313 
5314         case URX_STO_INP_LOC:
5315             {
5316                 U_ASSERT(opValue &gt;= 0 &amp;&amp; opValue &lt; fFrameSize);
5317                 fp-&gt;fExtra[opValue] = fp-&gt;fInputIdx;
5318             }
5319             break;
5320 
5321         case URX_JMPX:
5322             {
5323                 int32_t instrOperandLoc = (int32_t)fp-&gt;fPatIdx;
5324                 fp-&gt;fPatIdx += 1;
5325                 int32_t dataLoc  = URX_VAL(pat[instrOperandLoc]);
5326                 U_ASSERT(dataLoc &gt;= 0 &amp;&amp; dataLoc &lt; fFrameSize);
5327                 int32_t savedInputIdx = (int32_t)fp-&gt;fExtra[dataLoc];
5328                 U_ASSERT(savedInputIdx &lt;= fp-&gt;fInputIdx);
5329                 if (savedInputIdx &lt; fp-&gt;fInputIdx) {
5330                     fp-&gt;fPatIdx = opValue;                               // JMP
5331                 } else {
5332                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);   // FAIL, no progress in loop.
5333                 }
5334             }
5335             break;
5336 
5337         case URX_LA_START:
5338             {
5339                 // Entering a lookahead block.
5340                 // Save Stack Ptr, Input Pos.
5341                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
5342                 fData[opValue]   = fStack-&gt;size();
5343                 fData[opValue+1] = fp-&gt;fInputIdx;
5344                 fActiveStart     = fLookStart;          // Set the match region change for
5345                 fActiveLimit     = fLookLimit;          //   transparent bounds.
5346             }
5347             break;
5348 
5349         case URX_LA_END:
5350             {
5351                 // Leaving a look-ahead block.
5352                 //  restore Stack Ptr, Input Pos to positions they had on entry to block.
5353                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
5354                 int32_t stackSize = fStack-&gt;size();
5355                 int32_t newStackSize = (int32_t)fData[opValue];
5356                 U_ASSERT(stackSize &gt;= newStackSize);
5357                 if (stackSize &gt; newStackSize) {
5358                     // Copy the current top frame back to the new (cut back) top frame.
5359                     //   This makes the capture groups from within the look-ahead
5360                     //   expression available.
5361                     int64_t *newFP = fStack-&gt;getBuffer() + newStackSize - fFrameSize;
<a name="33" id="anc33"></a><span class="line-modified">5362                     int32_t j;</span>
<span class="line-modified">5363                     for (j=0; j&lt;fFrameSize; j++) {</span>
<span class="line-modified">5364                         newFP[j] = ((int64_t *)fp)[j];</span>
5365                     }
5366                     fp = (REStackFrame *)newFP;
5367                     fStack-&gt;setSize(newStackSize);
5368                 }
5369                 fp-&gt;fInputIdx = fData[opValue+1];
5370 
5371                 // Restore the active region bounds in the input string; they may have
5372                 //    been changed because of transparent bounds on a Region.
5373                 fActiveStart = fRegionStart;
5374                 fActiveLimit = fRegionLimit;
5375             }
5376             break;
5377 
5378         case URX_ONECHAR_I:
5379             if (fp-&gt;fInputIdx &lt; fActiveLimit) {
5380                 UChar32 c;
5381                 U16_NEXT(inputBuf, fp-&gt;fInputIdx, fActiveLimit, c);
5382                 if (u_foldCase(c, U_FOLD_CASE_DEFAULT) == opValue) {
5383                     break;
5384                 }
5385             } else {
5386                 fHitEnd = TRUE;
5387             }
5388             fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
5389             break;
5390 
5391         case URX_STRING_I:
5392             // Case-insensitive test input against a literal string.
5393             // Strings require two slots in the compiled pattern, one for the
5394             //   offset to the string text, and one for the length.
5395             //   The compiled string has already been case folded.
5396             {
5397                 const UChar *patternString = litText + opValue;
5398 
5399                 op      = (int32_t)pat[fp-&gt;fPatIdx];
5400                 fp-&gt;fPatIdx++;
5401                 opType  = URX_TYPE(op);
5402                 opValue = URX_VAL(op);
5403                 U_ASSERT(opType == URX_STRING_LEN);
5404                 int32_t patternStringLen = opValue;  // Length of the string from the pattern.
5405 
5406                 UChar32      cText;
5407                 UChar32      cPattern;
5408                 UBool        success = TRUE;
5409                 int32_t      patternStringIdx  = 0;
5410                 CaseFoldingUCharIterator inputIterator(inputBuf, fp-&gt;fInputIdx, fActiveLimit);
5411                 while (patternStringIdx &lt; patternStringLen) {
5412                     U16_NEXT(patternString, patternStringIdx, patternStringLen, cPattern);
5413                     cText = inputIterator.next();
5414                     if (cText != cPattern) {
5415                         success = FALSE;
5416                         if (cText == U_SENTINEL) {
5417                             fHitEnd = TRUE;
5418                         }
5419                         break;
5420                     }
5421                 }
5422                 if (inputIterator.inExpansion()) {
5423                     success = FALSE;
5424                 }
5425 
5426                 if (success) {
5427                     fp-&gt;fInputIdx = inputIterator.getIndex();
5428                 } else {
5429                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
5430                 }
5431             }
5432             break;
5433 
5434         case URX_LB_START:
5435             {
5436                 // Entering a look-behind block.
5437                 // Save Stack Ptr, Input Pos.
5438                 //   TODO:  implement transparent bounds.  Ticket #6067
5439                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
5440                 fData[opValue]   = fStack-&gt;size();
5441                 fData[opValue+1] = fp-&gt;fInputIdx;
5442                 // Init the variable containing the start index for attempted matches.
5443                 fData[opValue+2] = -1;
5444                 // Save input string length, then reset to pin any matches to end at
5445                 //   the current position.
5446                 fData[opValue+3] = fActiveLimit;
5447                 fActiveLimit     = fp-&gt;fInputIdx;
5448             }
5449             break;
5450 
5451 
5452         case URX_LB_CONT:
5453             {
5454                 // Positive Look-Behind, at top of loop checking for matches of LB expression
5455                 //    at all possible input starting positions.
5456 
5457                 // Fetch the min and max possible match lengths.  They are the operands
5458                 //   of this op in the pattern.
5459                 int32_t minML = (int32_t)pat[fp-&gt;fPatIdx++];
5460                 int32_t maxML = (int32_t)pat[fp-&gt;fPatIdx++];
5461                 U_ASSERT(minML &lt;= maxML);
5462                 U_ASSERT(minML &gt;= 0);
5463 
5464                 // Fetch (from data) the last input index where a match was attempted.
5465                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
5466                 int64_t  &amp;lbStartIdx = fData[opValue+2];
5467                 if (lbStartIdx &lt; 0) {
5468                     // First time through loop.
5469                     lbStartIdx = fp-&gt;fInputIdx - minML;
5470                     if (lbStartIdx &gt; 0 &amp;&amp; lbStartIdx &lt; fInputLength) {
5471                         U16_SET_CP_START(inputBuf, 0, lbStartIdx);
5472                     }
5473                 } else {
5474                     // 2nd through nth time through the loop.
5475                     // Back up start position for match by one.
5476                     if (lbStartIdx == 0) {
5477                         lbStartIdx--;
5478                     } else {
5479                         U16_BACK_1(inputBuf, 0, lbStartIdx);
5480                     }
5481                 }
5482 
5483                 if (lbStartIdx &lt; 0 || lbStartIdx &lt; fp-&gt;fInputIdx - maxML) {
5484                     // We have tried all potential match starting points without
5485                     //  getting a match.  Backtrack out, and out of the
5486                     //   Look Behind altogether.
5487                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
5488                     int64_t restoreInputLen = fData[opValue+3];
5489                     U_ASSERT(restoreInputLen &gt;= fActiveLimit);
5490                     U_ASSERT(restoreInputLen &lt;= fInputLength);
5491                     fActiveLimit = restoreInputLen;
5492                     break;
5493                 }
5494 
5495                 //    Save state to this URX_LB_CONT op, so failure to match will repeat the loop.
5496                 //      (successful match will fall off the end of the loop.)
5497                 fp = StateSave(fp, fp-&gt;fPatIdx-3, status);
5498                 fp-&gt;fInputIdx =  lbStartIdx;
5499             }
5500             break;
5501 
5502         case URX_LB_END:
5503             // End of a look-behind block, after a successful match.
5504             {
5505                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
5506                 if (fp-&gt;fInputIdx != fActiveLimit) {
5507                     //  The look-behind expression matched, but the match did not
5508                     //    extend all the way to the point that we are looking behind from.
5509                     //  FAIL out of here, which will take us back to the LB_CONT, which
5510                     //     will retry the match starting at another position or fail
5511                     //     the look-behind altogether, whichever is appropriate.
5512                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
5513                     break;
5514                 }
5515 
5516                 // Look-behind match is good.  Restore the orignal input string length,
5517                 //   which had been truncated to pin the end of the lookbehind match to the
5518                 //   position being looked-behind.
5519                 int64_t originalInputLen = fData[opValue+3];
5520                 U_ASSERT(originalInputLen &gt;= fActiveLimit);
5521                 U_ASSERT(originalInputLen &lt;= fInputLength);
5522                 fActiveLimit = originalInputLen;
5523             }
5524             break;
5525 
5526 
5527         case URX_LBN_CONT:
5528             {
5529                 // Negative Look-Behind, at top of loop checking for matches of LB expression
5530                 //    at all possible input starting positions.
5531 
5532                 // Fetch the extra parameters of this op.
5533                 int32_t minML       = (int32_t)pat[fp-&gt;fPatIdx++];
5534                 int32_t maxML       = (int32_t)pat[fp-&gt;fPatIdx++];
5535                 int32_t continueLoc = (int32_t)pat[fp-&gt;fPatIdx++];
5536                 continueLoc = URX_VAL(continueLoc);
5537                 U_ASSERT(minML &lt;= maxML);
5538                 U_ASSERT(minML &gt;= 0);
5539                 U_ASSERT(continueLoc &gt; fp-&gt;fPatIdx);
5540 
5541                 // Fetch (from data) the last input index where a match was attempted.
5542                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
5543                 int64_t  &amp;lbStartIdx = fData[opValue+2];
5544                 if (lbStartIdx &lt; 0) {
5545                     // First time through loop.
5546                     lbStartIdx = fp-&gt;fInputIdx - minML;
5547                     if (lbStartIdx &gt; 0 &amp;&amp; lbStartIdx &lt; fInputLength) {
5548                         U16_SET_CP_START(inputBuf, 0, lbStartIdx);
5549                     }
5550                 } else {
5551                     // 2nd through nth time through the loop.
5552                     // Back up start position for match by one.
5553                     if (lbStartIdx == 0) {
5554                         lbStartIdx--;   // Because U16_BACK is unsafe starting at 0.
5555                     } else {
5556                         U16_BACK_1(inputBuf, 0, lbStartIdx);
5557                     }
5558                 }
5559 
5560                 if (lbStartIdx &lt; 0 || lbStartIdx &lt; fp-&gt;fInputIdx - maxML) {
5561                     // We have tried all potential match starting points without
5562                     //  getting a match, which means that the negative lookbehind as
5563                     //  a whole has succeeded.  Jump forward to the continue location
5564                     int64_t restoreInputLen = fData[opValue+3];
5565                     U_ASSERT(restoreInputLen &gt;= fActiveLimit);
5566                     U_ASSERT(restoreInputLen &lt;= fInputLength);
5567                     fActiveLimit = restoreInputLen;
5568                     fp-&gt;fPatIdx = continueLoc;
5569                     break;
5570                 }
5571 
5572                 //    Save state to this URX_LB_CONT op, so failure to match will repeat the loop.
5573                 //      (successful match will cause a FAIL out of the loop altogether.)
5574                 fp = StateSave(fp, fp-&gt;fPatIdx-4, status);
5575                 fp-&gt;fInputIdx =  lbStartIdx;
5576             }
5577             break;
5578 
5579         case URX_LBN_END:
5580             // End of a negative look-behind block, after a successful match.
5581             {
5582                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
5583                 if (fp-&gt;fInputIdx != fActiveLimit) {
5584                     //  The look-behind expression matched, but the match did not
5585                     //    extend all the way to the point that we are looking behind from.
5586                     //  FAIL out of here, which will take us back to the LB_CONT, which
5587                     //     will retry the match starting at another position or succeed
5588                     //     the look-behind altogether, whichever is appropriate.
5589                     fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
5590                     break;
5591                 }
5592 
5593                 // Look-behind expression matched, which means look-behind test as
5594                 //   a whole Fails
5595 
5596                 //   Restore the orignal input string length, which had been truncated
5597                 //   inorder to pin the end of the lookbehind match
5598                 //   to the position being looked-behind.
5599                 int64_t originalInputLen = fData[opValue+3];
5600                 U_ASSERT(originalInputLen &gt;= fActiveLimit);
5601                 U_ASSERT(originalInputLen &lt;= fInputLength);
5602                 fActiveLimit = originalInputLen;
5603 
5604                 // Restore original stack position, discarding any state saved
5605                 //   by the successful pattern match.
5606                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue+1&lt;fPattern-&gt;fDataSize);
5607                 int32_t newStackSize = (int32_t)fData[opValue];
5608                 U_ASSERT(fStack-&gt;size() &gt; newStackSize);
5609                 fStack-&gt;setSize(newStackSize);
5610 
5611                 //  FAIL, which will take control back to someplace
5612                 //  prior to entering the look-behind test.
5613                 fp = (REStackFrame *)fStack-&gt;popFrame(fFrameSize);
5614             }
5615             break;
5616 
5617 
5618         case URX_LOOP_SR_I:
5619             // Loop Initialization for the optimized implementation of
5620             //     [some character set]*
5621             //   This op scans through all matching input.
5622             //   The following LOOP_C op emulates stack unwinding if the following pattern fails.
5623             {
<a name="34" id="anc34"></a><span class="line-modified">5624                 U_ASSERT(opValue &gt; 0 &amp;&amp; opValue &lt; fSets-&gt;size());</span>
5625                 Regex8BitSet *s8 = &amp;fPattern-&gt;fSets8[opValue];
<a name="35" id="anc35"></a><span class="line-modified">5626                 UnicodeSet   *s  = (UnicodeSet *)fSets-&gt;elementAt(opValue);</span>
5627 
5628                 // Loop through input, until either the input is exhausted or
5629                 //   we reach a character that is not a member of the set.
5630                 int32_t ix = (int32_t)fp-&gt;fInputIdx;
5631                 for (;;) {
5632                     if (ix &gt;= fActiveLimit) {
5633                         fHitEnd = TRUE;
5634                         break;
5635                     }
5636                     UChar32   c;
5637                     U16_NEXT(inputBuf, ix, fActiveLimit, c);
5638                     if (c&lt;256) {
5639                         if (s8-&gt;contains(c) == FALSE) {
5640                             U16_BACK_1(inputBuf, 0, ix);
5641                             break;
5642                         }
5643                     } else {
5644                         if (s-&gt;contains(c) == FALSE) {
5645                             U16_BACK_1(inputBuf, 0, ix);
5646                             break;
5647                         }
5648                     }
5649                 }
5650 
5651                 // If there were no matching characters, skip over the loop altogether.
5652                 //   The loop doesn&#39;t run at all, a * op always succeeds.
5653                 if (ix == fp-&gt;fInputIdx) {
5654                     fp-&gt;fPatIdx++;   // skip the URX_LOOP_C op.
5655                     break;
5656                 }
5657 
5658                 // Peek ahead in the compiled pattern, to the URX_LOOP_C that
5659                 //   must follow.  It&#39;s operand is the stack location
5660                 //   that holds the starting input index for the match of this [set]*
5661                 int32_t loopcOp = (int32_t)pat[fp-&gt;fPatIdx];
5662                 U_ASSERT(URX_TYPE(loopcOp) == URX_LOOP_C);
5663                 int32_t stackLoc = URX_VAL(loopcOp);
5664                 U_ASSERT(stackLoc &gt;= 0 &amp;&amp; stackLoc &lt; fFrameSize);
5665                 fp-&gt;fExtra[stackLoc] = fp-&gt;fInputIdx;
5666                 fp-&gt;fInputIdx = ix;
5667 
5668                 // Save State to the URX_LOOP_C op that follows this one,
5669                 //   so that match failures in the following code will return to there.
5670                 //   Then bump the pattern idx so the LOOP_C is skipped on the way out of here.
5671                 fp = StateSave(fp, fp-&gt;fPatIdx, status);
5672                 fp-&gt;fPatIdx++;
5673             }
5674             break;
5675 
5676 
5677         case URX_LOOP_DOT_I:
5678             // Loop Initialization for the optimized implementation of .*
5679             //   This op scans through all remaining input.
5680             //   The following LOOP_C op emulates stack unwinding if the following pattern fails.
5681             {
5682                 // Loop through input until the input is exhausted (we reach an end-of-line)
5683                 // In DOTALL mode, we can just go straight to the end of the input.
5684                 int32_t ix;
5685                 if ((opValue &amp; 1) == 1) {
5686                     // Dot-matches-All mode.  Jump straight to the end of the string.
5687                     ix = (int32_t)fActiveLimit;
5688                     fHitEnd = TRUE;
5689                 } else {
5690                     // NOT DOT ALL mode.  Line endings do not match &#39;.&#39;
5691                     // Scan forward until a line ending or end of input.
5692                     ix = (int32_t)fp-&gt;fInputIdx;
5693                     for (;;) {
5694                         if (ix &gt;= fActiveLimit) {
5695                             fHitEnd = TRUE;
5696                             break;
5697                         }
5698                         UChar32   c;
5699                         U16_NEXT(inputBuf, ix, fActiveLimit, c);   // c = inputBuf[ix++]
5700                         if ((c &amp; 0x7f) &lt;= 0x29) {          // Fast filter of non-new-line-s
5701                             if ((c == 0x0a) ||             //  0x0a is newline in both modes.
5702                                 (((opValue &amp; 2) == 0) &amp;&amp;    // IF not UNIX_LINES mode
5703                                    isLineTerminator(c))) {
5704                                 //  char is a line ending.  Put the input pos back to the
5705                                 //    line ending char, and exit the scanning loop.
5706                                 U16_BACK_1(inputBuf, 0, ix);
5707                                 break;
5708                             }
5709                         }
5710                     }
5711                 }
5712 
5713                 // If there were no matching characters, skip over the loop altogether.
5714                 //   The loop doesn&#39;t run at all, a * op always succeeds.
5715                 if (ix == fp-&gt;fInputIdx) {
5716                     fp-&gt;fPatIdx++;   // skip the URX_LOOP_C op.
5717                     break;
5718                 }
5719 
5720                 // Peek ahead in the compiled pattern, to the URX_LOOP_C that
5721                 //   must follow.  It&#39;s operand is the stack location
5722                 //   that holds the starting input index for the match of this .*
5723                 int32_t loopcOp = (int32_t)pat[fp-&gt;fPatIdx];
5724                 U_ASSERT(URX_TYPE(loopcOp) == URX_LOOP_C);
5725                 int32_t stackLoc = URX_VAL(loopcOp);
5726                 U_ASSERT(stackLoc &gt;= 0 &amp;&amp; stackLoc &lt; fFrameSize);
5727                 fp-&gt;fExtra[stackLoc] = fp-&gt;fInputIdx;
5728                 fp-&gt;fInputIdx = ix;
5729 
5730                 // Save State to the URX_LOOP_C op that follows this one,
5731                 //   so that match failures in the following code will return to there.
5732                 //   Then bump the pattern idx so the LOOP_C is skipped on the way out of here.
5733                 fp = StateSave(fp, fp-&gt;fPatIdx, status);
5734                 fp-&gt;fPatIdx++;
5735             }
5736             break;
5737 
5738 
5739         case URX_LOOP_C:
5740             {
5741                 U_ASSERT(opValue&gt;=0 &amp;&amp; opValue&lt;fFrameSize);
5742                 backSearchIndex = (int32_t)fp-&gt;fExtra[opValue];
5743                 U_ASSERT(backSearchIndex &lt;= fp-&gt;fInputIdx);
5744                 if (backSearchIndex == fp-&gt;fInputIdx) {
5745                     // We&#39;ve backed up the input idx to the point that the loop started.
5746                     // The loop is done.  Leave here without saving state.
5747                     //  Subsequent failures won&#39;t come back here.
5748                     break;
5749                 }
5750                 // Set up for the next iteration of the loop, with input index
5751                 //   backed up by one from the last time through,
5752                 //   and a state save to this instruction in case the following code fails again.
5753                 //   (We&#39;re going backwards because this loop emulates stack unwinding, not
5754                 //    the initial scan forward.)
5755                 U_ASSERT(fp-&gt;fInputIdx &gt; 0);
5756                 UChar32 prevC;
5757                 U16_PREV(inputBuf, 0, fp-&gt;fInputIdx, prevC); // !!!: should this 0 be one of f*Limit?
5758 
5759                 if (prevC == 0x0a &amp;&amp;
5760                     fp-&gt;fInputIdx &gt; backSearchIndex &amp;&amp;
5761                     inputBuf[fp-&gt;fInputIdx-1] == 0x0d) {
5762                     int32_t prevOp = (int32_t)pat[fp-&gt;fPatIdx-2];
5763                     if (URX_TYPE(prevOp) == URX_LOOP_DOT_I) {
5764                         // .*, stepping back over CRLF pair.
5765                         U16_BACK_1(inputBuf, 0, fp-&gt;fInputIdx);
5766                     }
5767                 }
5768 
5769 
5770                 fp = StateSave(fp, fp-&gt;fPatIdx-1, status);
5771             }
5772             break;
5773 
5774 
5775 
5776         default:
5777             // Trouble.  The compiled pattern contains an entry with an
5778             //           unrecognized type tag.
<a name="36" id="anc36"></a><span class="line-modified">5779             UPRV_UNREACHABLE;</span>
5780         }
5781 
5782         if (U_FAILURE(status)) {
5783             isMatch = FALSE;
5784             break;
5785         }
5786     }
5787 
5788 breakFromLoop:
5789     fMatch = isMatch;
5790     if (isMatch) {
5791         fLastMatchEnd = fMatchEnd;
5792         fMatchStart   = startIdx;
5793         fMatchEnd     = fp-&gt;fInputIdx;
5794     }
5795 
5796 #ifdef REGEX_RUN_DEBUG
5797     if (fTraceDebug) {
5798         if (isMatch) {
5799             printf(&quot;Match.  start=%ld   end=%ld\n\n&quot;, fMatchStart, fMatchEnd);
5800         } else {
5801             printf(&quot;No match\n\n&quot;);
5802         }
5803     }
5804 #endif
5805 
5806     fFrame = fp;                // The active stack frame when the engine stopped.
5807                                 //   Contains the capture group results that we need to
5808                                 //    access later.
5809 
5810     return;
5811 }
5812 
5813 
5814 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(RegexMatcher)
5815 
5816 U_NAMESPACE_END
5817 
5818 #endif  // !UCONFIG_NO_REGULAR_EXPRESSIONS
5819 
<a name="37" id="anc37"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="37" type="hidden" />
</body>
</html>