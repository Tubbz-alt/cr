<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/putil.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ******************************************************************************
   5 *
   6 *   Copyright (C) 1997-2016, International Business Machines
   7 *   Corporation and others.  All Rights Reserved.
   8 *
   9 ******************************************************************************
  10 *
  11 *  FILE NAME : putil.c (previously putil.cpp and ptypes.cpp)
  12 *
  13 *   Date        Name        Description
  14 *   04/14/97    aliu        Creation.
  15 *   04/24/97    aliu        Added getDefaultDataDirectory() and
  16 *                            getDefaultLocaleID().
  17 *   04/28/97    aliu        Rewritten to assume Unix and apply general methods
  18 *                            for assumed case.  Non-UNIX platforms must be
  19 *                            special-cased.  Rewrote numeric methods dealing
  20 *                            with NaN and Infinity to be platform independent
  21 *                             over all IEEE 754 platforms.
  22 *   05/13/97    aliu        Restored sign of timezone
  23 *                            (semantics are hours West of GMT)
  24 *   06/16/98    erm         Added IEEE_754 stuff, cleaned up isInfinite, isNan,
  25 *                             nextDouble..
  26 *   07/22/98    stephen     Added remainder, max, min, trunc
  27 *   08/13/98    stephen     Added isNegativeInfinity, isPositiveInfinity
  28 *   08/24/98    stephen     Added longBitsFromDouble
  29 *   09/08/98    stephen     Minor changes for Mac Port
  30 *   03/02/99    stephen     Removed openFile().  Added AS400 support.
  31 *                            Fixed EBCDIC tables
  32 *   04/15/99    stephen     Converted to C.
  33 *   06/28/99    stephen     Removed mutex locking in u_isBigEndian().
  34 *   08/04/99    jeffrey R.  Added OS/2 changes
  35 *   11/15/99    helena      Integrated S/390 IEEE support.
  36 *   04/26/01    Barry N.    OS/400 support for uprv_getDefaultLocaleID
  37 *   08/15/01    Steven H.   OS/400 support for uprv_getDefaultCodepage
  38 *   01/03/08    Steven L.   Fake Time Support
  39 ******************************************************************************
  40 */
  41 
  42 // Defines _XOPEN_SOURCE for access to POSIX functions.
  43 // Must be before any other #includes.
  44 #include &quot;uposixdefs.h&quot;
  45 
  46 // First, the platform type. Need this for U_PLATFORM.
  47 #include &quot;unicode/platform.h&quot;
  48 
  49 #if U_PLATFORM == U_PF_MINGW &amp;&amp; defined __STRICT_ANSI__
  50 /* tzset isn&#39;t defined in strict ANSI on MinGW. */
  51 #undef __STRICT_ANSI__
  52 #endif
  53 
  54 /*
  55  * Cygwin with GCC requires inclusion of time.h after the above disabling strict asci mode statement.
  56  */
  57 #include &lt;time.h&gt;
  58 
  59 #if !U_PLATFORM_USES_ONLY_WIN32_API
  60 #include &lt;sys/time.h&gt;
  61 #endif
  62 
  63 /* include the rest of the ICU headers */
  64 #include &quot;unicode/putil.h&quot;
  65 #include &quot;unicode/ustring.h&quot;
  66 #include &quot;putilimp.h&quot;
  67 #include &quot;uassert.h&quot;
  68 #include &quot;umutex.h&quot;
  69 #include &quot;cmemory.h&quot;
  70 #include &quot;cstring.h&quot;
  71 #include &quot;locmap.h&quot;
  72 #include &quot;ucln_cmn.h&quot;
  73 #include &quot;charstr.h&quot;
  74 
  75 /* Include standard headers. */
  76 #include &lt;stdio.h&gt;
  77 #include &lt;stdlib.h&gt;
  78 #include &lt;string.h&gt;
  79 #include &lt;math.h&gt;
  80 #include &lt;locale.h&gt;
  81 #include &lt;float.h&gt;
  82 
  83 #ifndef U_COMMON_IMPLEMENTATION
  84 #error U_COMMON_IMPLEMENTATION not set - must be set for all ICU source files in common/ - see http://userguide.icu-project.org/howtouseicu
  85 #endif
  86 
  87 
  88 /* include system headers */
  89 #if U_PLATFORM_USES_ONLY_WIN32_API
  90     /*
  91      * TODO: U_PLATFORM_USES_ONLY_WIN32_API includes MinGW.
  92      * Should Cygwin be included as well (U_PLATFORM_HAS_WIN32_API)
  93      * to use native APIs as much as possible?
  94      */
  95 #ifndef WIN32_LEAN_AND_MEAN
  96 #   define WIN32_LEAN_AND_MEAN
  97 #endif
  98 #   define VC_EXTRALEAN
  99 #   define NOUSER
 100 #   define NOSERVICE
 101 #   define NOIME
 102 #   define NOMCX
 103 #   include &lt;windows.h&gt;
 104 #   include &quot;unicode/uloc.h&quot;
 105 #   include &quot;wintz.h&quot;
 106 #elif U_PLATFORM == U_PF_OS400
 107 #   include &lt;float.h&gt;
 108 #   include &lt;qusec.h&gt;       /* error code structure */
 109 #   include &lt;qusrjobi.h&gt;
 110 #   include &lt;qliept.h&gt;      /* EPT_CALL macro  - this include must be after all other &quot;QSYSINCs&quot; */
 111 #   include &lt;mih/testptr.h&gt; /* For uprv_maximumPtr */
 112 #elif U_PLATFORM == U_PF_OS390
 113 #   include &quot;unicode/ucnv.h&quot;   /* Needed for UCNV_SWAP_LFNL_OPTION_STRING */
 114 #elif U_PLATFORM_IS_DARWIN_BASED || U_PLATFORM_IS_LINUX_BASED || U_PLATFORM == U_PF_BSD || U_PLATFORM == U_PF_SOLARIS
 115 #   include &lt;limits.h&gt;
 116 #   include &lt;unistd.h&gt;
 117 #   if U_PLATFORM == U_PF_SOLARIS
 118 #       ifndef _XPG4_2
 119 #           define _XPG4_2
 120 #       endif
 121 #   endif
 122 #elif U_PLATFORM == U_PF_QNX
 123 #   include &lt;sys/neutrino.h&gt;
 124 #endif
 125 
 126 /*
 127  * Only include langinfo.h if we have a way to get the codeset. If we later
 128  * depend on more feature, we can test on U_HAVE_NL_LANGINFO.
 129  *
 130  */
 131 
 132 #if U_HAVE_NL_LANGINFO_CODESET
 133 #include &lt;langinfo.h&gt;
 134 #endif
 135 
 136 /**
 137  * Simple things (presence of functions, etc) should just go in configure.in and be added to
 138  * icucfg.h via autoheader.
 139  */
 140 #if U_PLATFORM_IMPLEMENTS_POSIX
 141 #   if U_PLATFORM == U_PF_OS400
 142 #    define HAVE_DLFCN_H 0
 143 #    define HAVE_DLOPEN 0
 144 #   else
 145 #   ifndef HAVE_DLFCN_H
 146 #    define HAVE_DLFCN_H 1
 147 #   endif
 148 #   ifndef HAVE_DLOPEN
 149 #    define HAVE_DLOPEN 1
 150 #   endif
 151 #   endif
 152 #   ifndef HAVE_GETTIMEOFDAY
 153 #    define HAVE_GETTIMEOFDAY 1
 154 #   endif
 155 #else
 156 #   define HAVE_DLFCN_H 0
 157 #   define HAVE_DLOPEN 0
 158 #   define HAVE_GETTIMEOFDAY 0
 159 #endif
 160 
 161 U_NAMESPACE_USE
 162 
 163 /* Define the extension for data files, again... */
 164 #define DATA_TYPE &quot;dat&quot;
 165 
 166 /* Leave this copyright notice here! */
 167 static const char copyright[] = U_COPYRIGHT_STRING;
 168 
 169 /* floating point implementations ------------------------------------------- */
 170 
 171 /* We return QNAN rather than SNAN*/
 172 #define SIGN 0x80000000U
 173 
 174 /* Make it easy to define certain types of constants */
 175 typedef union {
 176     int64_t i64; /* This must be defined first in order to allow the initialization to work. This is a C89 feature. */
 177     double d64;
 178 } BitPatternConversion;
 179 static const BitPatternConversion gNan = { (int64_t) INT64_C(0x7FF8000000000000) };
 180 static const BitPatternConversion gInf = { (int64_t) INT64_C(0x7FF0000000000000) };
 181 
 182 /*---------------------------------------------------------------------------
 183   Platform utilities
 184   Our general strategy is to assume we&#39;re on a POSIX platform.  Platforms which
 185   are non-POSIX must declare themselves so.  The default POSIX implementation
 186   will sometimes work for non-POSIX platforms as well (e.g., the NaN-related
 187   functions).
 188   ---------------------------------------------------------------------------*/
 189 
 190 #if U_PLATFORM_USES_ONLY_WIN32_API || U_PLATFORM == U_PF_OS400
 191 #   undef U_POSIX_LOCALE
 192 #else
 193 #   define U_POSIX_LOCALE    1
 194 #endif
 195 
 196 /*
 197     WARNING! u_topNBytesOfDouble and u_bottomNBytesOfDouble
 198     can&#39;t be properly optimized by the gcc compiler sometimes (i.e. gcc 3.2).
 199 */
 200 #if !IEEE_754
 201 static char*
 202 u_topNBytesOfDouble(double* d, int n)
 203 {
 204 #if U_IS_BIG_ENDIAN
 205     return (char*)d;
 206 #else
 207     return (char*)(d + 1) - n;
 208 #endif
 209 }
 210 
 211 static char*
 212 u_bottomNBytesOfDouble(double* d, int n)
 213 {
 214 #if U_IS_BIG_ENDIAN
 215     return (char*)(d + 1) - n;
 216 #else
 217     return (char*)d;
 218 #endif
 219 }
 220 #endif   /* !IEEE_754 */
 221 
 222 #if IEEE_754
 223 static UBool
 224 u_signBit(double d) {
 225     uint8_t hiByte;
 226 #if U_IS_BIG_ENDIAN
 227     hiByte = *(uint8_t *)&amp;d;
 228 #else
 229     hiByte = *(((uint8_t *)&amp;d) + sizeof(double) - 1);
 230 #endif
 231     return (hiByte &amp; 0x80) != 0;
 232 }
 233 #endif
 234 
 235 
 236 
 237 #if defined (U_DEBUG_FAKETIME)
 238 /* Override the clock to test things without having to move the system clock.
 239  * Assumes POSIX gettimeofday() will function
 240  */
 241 UDate fakeClock_t0 = 0; /** Time to start the clock from **/
 242 UDate fakeClock_dt = 0; /** Offset (fake time - real time) **/
 243 UBool fakeClock_set = FALSE; /** True if fake clock has spun up **/
 244 
 245 static UDate getUTCtime_real() {
 246     struct timeval posixTime;
 247     gettimeofday(&amp;posixTime, NULL);
 248     return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));
 249 }
 250 
 251 static UDate getUTCtime_fake() {
 252     static UMutex fakeClockMutex = U_MUTEX_INTIALIZER;
 253     umtx_lock(&amp;fakeClockMutex);
 254     if(!fakeClock_set) {
 255         UDate real = getUTCtime_real();
 256         const char *fake_start = getenv(&quot;U_FAKETIME_START&quot;);
 257         if((fake_start!=NULL) &amp;&amp; (fake_start[0]!=0)) {
 258             sscanf(fake_start,&quot;%lf&quot;,&amp;fakeClock_t0);
 259             fakeClock_dt = fakeClock_t0 - real;
 260             fprintf(stderr,&quot;U_DEBUG_FAKETIME was set at compile time, so the ICU clock will start at a preset value\n&quot;
 261                     &quot;env variable U_FAKETIME_START=%.0f (%s) for an offset of %.0f ms from the current time %.0f\n&quot;,
 262                     fakeClock_t0, fake_start, fakeClock_dt, real);
 263         } else {
 264           fakeClock_dt = 0;
 265             fprintf(stderr,&quot;U_DEBUG_FAKETIME was set at compile time, but U_FAKETIME_START was not set.\n&quot;
 266                     &quot;Set U_FAKETIME_START to the number of milliseconds since 1/1/1970 to set the ICU clock.\n&quot;);
 267         }
 268         fakeClock_set = TRUE;
 269     }
 270     umtx_unlock(&amp;fakeClockMutex);
 271 
 272     return getUTCtime_real() + fakeClock_dt;
 273 }
 274 #endif
 275 
 276 #if U_PLATFORM_USES_ONLY_WIN32_API
 277 typedef union {
 278     int64_t int64;
 279     FILETIME fileTime;
 280 } FileTimeConversion;   /* This is like a ULARGE_INTEGER */
 281 
 282 /* Number of 100 nanoseconds from 1/1/1601 to 1/1/1970 */
 283 #define EPOCH_BIAS  INT64_C(116444736000000000)
 284 #define HECTONANOSECOND_PER_MILLISECOND   10000
 285 
 286 #endif
 287 
 288 /*---------------------------------------------------------------------------
 289   Universal Implementations
 290   These are designed to work on all platforms.  Try these, and if they
 291   don&#39;t work on your platform, then special case your platform with new
 292   implementations.
 293 ---------------------------------------------------------------------------*/
 294 
 295 U_CAPI UDate U_EXPORT2
 296 uprv_getUTCtime()
 297 {
 298 #if defined(U_DEBUG_FAKETIME)
 299     return getUTCtime_fake(); /* Hook for overriding the clock */
 300 #else
 301     return uprv_getRawUTCtime();
 302 #endif
 303 }
 304 
 305 /* Return UTC (GMT) time measured in milliseconds since 0:00 on 1/1/70.*/
 306 U_CAPI UDate U_EXPORT2
 307 uprv_getRawUTCtime()
 308 {
 309 #if U_PLATFORM_USES_ONLY_WIN32_API
 310 
 311     FileTimeConversion winTime;
 312     GetSystemTimeAsFileTime(&amp;winTime.fileTime);
 313     return (UDate)((winTime.int64 - EPOCH_BIAS) / HECTONANOSECOND_PER_MILLISECOND);
 314 #else
 315 
 316 #if HAVE_GETTIMEOFDAY
 317     struct timeval posixTime;
 318     gettimeofday(&amp;posixTime, NULL);
 319     return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));
 320 #else
 321     time_t epochtime;
 322     time(&amp;epochtime);
 323     return (UDate)epochtime * U_MILLIS_PER_SECOND;
 324 #endif
 325 
 326 #endif
 327 }
 328 
 329 /*-----------------------------------------------------------------------------
 330   IEEE 754
 331   These methods detect and return NaN and infinity values for doubles
 332   conforming to IEEE 754.  Platforms which support this standard include X86,
 333   Mac 680x0, Mac PowerPC, AIX RS/6000, and most others.
 334   If this doesn&#39;t work on your platform, you have non-IEEE floating-point, and
 335   will need to code your own versions.  A naive implementation is to return 0.0
 336   for getNaN and getInfinity, and false for isNaN and isInfinite.
 337   ---------------------------------------------------------------------------*/
 338 
 339 U_CAPI UBool U_EXPORT2
 340 uprv_isNaN(double number)
 341 {
 342 #if IEEE_754
 343     BitPatternConversion convertedNumber;
 344     convertedNumber.d64 = number;
 345     /* Infinity is 0x7FF0000000000000U. Anything greater than that is a NaN */
 346     return (UBool)((convertedNumber.i64 &amp; U_INT64_MAX) &gt; gInf.i64);
 347 
 348 #elif U_PLATFORM == U_PF_OS390
 349     uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&amp;number,
 350                         sizeof(uint32_t));
 351     uint32_t lowBits  = *(uint32_t*)u_bottomNBytesOfDouble(&amp;number,
 352                         sizeof(uint32_t));
 353 
 354     return ((highBits &amp; 0x7F080000L) == 0x7F080000L) &amp;&amp;
 355       (lowBits == 0x00000000L);
 356 
 357 #else
 358     /* If your platform doesn&#39;t support IEEE 754 but *does* have an NaN value,*/
 359     /* you&#39;ll need to replace this default implementation with what&#39;s correct*/
 360     /* for your platform.*/
 361     return number != number;
 362 #endif
 363 }
 364 
 365 U_CAPI UBool U_EXPORT2
 366 uprv_isInfinite(double number)
 367 {
 368 #if IEEE_754
 369     BitPatternConversion convertedNumber;
 370     convertedNumber.d64 = number;
 371     /* Infinity is exactly 0x7FF0000000000000U. */
 372     return (UBool)((convertedNumber.i64 &amp; U_INT64_MAX) == gInf.i64);
 373 #elif U_PLATFORM == U_PF_OS390
 374     uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&amp;number,
 375                         sizeof(uint32_t));
 376     uint32_t lowBits  = *(uint32_t*)u_bottomNBytesOfDouble(&amp;number,
 377                         sizeof(uint32_t));
 378 
 379     return ((highBits  &amp; ~SIGN) == 0x70FF0000L) &amp;&amp; (lowBits == 0x00000000L);
 380 
 381 #else
 382     /* If your platform doesn&#39;t support IEEE 754 but *does* have an infinity*/
 383     /* value, you&#39;ll need to replace this default implementation with what&#39;s*/
 384     /* correct for your platform.*/
 385     return number == (2.0 * number);
 386 #endif
 387 }
 388 
 389 U_CAPI UBool U_EXPORT2
 390 uprv_isPositiveInfinity(double number)
 391 {
 392 #if IEEE_754 || U_PLATFORM == U_PF_OS390
 393     return (UBool)(number &gt; 0 &amp;&amp; uprv_isInfinite(number));
 394 #else
 395     return uprv_isInfinite(number);
 396 #endif
 397 }
 398 
 399 U_CAPI UBool U_EXPORT2
 400 uprv_isNegativeInfinity(double number)
 401 {
 402 #if IEEE_754 || U_PLATFORM == U_PF_OS390
 403     return (UBool)(number &lt; 0 &amp;&amp; uprv_isInfinite(number));
 404 
 405 #else
 406     uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&amp;number,
 407                         sizeof(uint32_t));
 408     return((highBits &amp; SIGN) &amp;&amp; uprv_isInfinite(number));
 409 
 410 #endif
 411 }
 412 
 413 U_CAPI double U_EXPORT2
 414 uprv_getNaN()
 415 {
 416 #if IEEE_754 || U_PLATFORM == U_PF_OS390
 417     return gNan.d64;
 418 #else
 419     /* If your platform doesn&#39;t support IEEE 754 but *does* have an NaN value,*/
 420     /* you&#39;ll need to replace this default implementation with what&#39;s correct*/
 421     /* for your platform.*/
 422     return 0.0;
 423 #endif
 424 }
 425 
 426 U_CAPI double U_EXPORT2
 427 uprv_getInfinity()
 428 {
 429 #if IEEE_754 || U_PLATFORM == U_PF_OS390
 430     return gInf.d64;
 431 #else
 432     /* If your platform doesn&#39;t support IEEE 754 but *does* have an infinity*/
 433     /* value, you&#39;ll need to replace this default implementation with what&#39;s*/
 434     /* correct for your platform.*/
 435     return 0.0;
 436 #endif
 437 }
 438 
 439 U_CAPI double U_EXPORT2
 440 uprv_floor(double x)
 441 {
 442     return floor(x);
 443 }
 444 
 445 U_CAPI double U_EXPORT2
 446 uprv_ceil(double x)
 447 {
 448     return ceil(x);
 449 }
 450 
 451 U_CAPI double U_EXPORT2
 452 uprv_round(double x)
 453 {
 454     return uprv_floor(x + 0.5);
 455 }
 456 
 457 U_CAPI double U_EXPORT2
 458 uprv_fabs(double x)
 459 {
 460     return fabs(x);
 461 }
 462 
 463 U_CAPI double U_EXPORT2
 464 uprv_modf(double x, double* y)
 465 {
 466     return modf(x, y);
 467 }
 468 
 469 U_CAPI double U_EXPORT2
 470 uprv_fmod(double x, double y)
 471 {
 472     return fmod(x, y);
 473 }
 474 
 475 U_CAPI double U_EXPORT2
 476 uprv_pow(double x, double y)
 477 {
 478     /* This is declared as &quot;double pow(double x, double y)&quot; */
 479     return pow(x, y);
 480 }
 481 
 482 U_CAPI double U_EXPORT2
 483 uprv_pow10(int32_t x)
 484 {
 485     return pow(10.0, (double)x);
 486 }
 487 
 488 U_CAPI double U_EXPORT2
 489 uprv_fmax(double x, double y)
 490 {
 491 #if IEEE_754
 492     /* first handle NaN*/
 493     if(uprv_isNaN(x) || uprv_isNaN(y))
 494         return uprv_getNaN();
 495 
 496     /* check for -0 and 0*/
 497     if(x == 0.0 &amp;&amp; y == 0.0 &amp;&amp; u_signBit(x))
 498         return y;
 499 
 500 #endif
 501 
 502     /* this should work for all flt point w/o NaN and Inf special cases */
 503     return (x &gt; y ? x : y);
 504 }
 505 
 506 U_CAPI double U_EXPORT2
 507 uprv_fmin(double x, double y)
 508 {
 509 #if IEEE_754
 510     /* first handle NaN*/
 511     if(uprv_isNaN(x) || uprv_isNaN(y))
 512         return uprv_getNaN();
 513 
 514     /* check for -0 and 0*/
 515     if(x == 0.0 &amp;&amp; y == 0.0 &amp;&amp; u_signBit(y))
 516         return y;
 517 
 518 #endif
 519 
 520     /* this should work for all flt point w/o NaN and Inf special cases */
 521     return (x &gt; y ? y : x);
 522 }
 523 
 524 U_CAPI UBool U_EXPORT2
 525 uprv_add32_overflow(int32_t a, int32_t b, int32_t* res) {
 526     // NOTE: Some compilers (GCC, Clang) have primitives available, like __builtin_add_overflow.
 527     // This function could be optimized by calling one of those primitives.
 528     auto a64 = static_cast&lt;int64_t&gt;(a);
 529     auto b64 = static_cast&lt;int64_t&gt;(b);
 530     int64_t res64 = a64 + b64;
 531     *res = static_cast&lt;int32_t&gt;(res64);
 532     return res64 != *res;
 533 }
 534 
 535 U_CAPI UBool U_EXPORT2
 536 uprv_mul32_overflow(int32_t a, int32_t b, int32_t* res) {
 537     // NOTE: Some compilers (GCC, Clang) have primitives available, like __builtin_mul_overflow.
 538     // This function could be optimized by calling one of those primitives.
 539     auto a64 = static_cast&lt;int64_t&gt;(a);
 540     auto b64 = static_cast&lt;int64_t&gt;(b);
 541     int64_t res64 = a64 * b64;
 542     *res = static_cast&lt;int32_t&gt;(res64);
 543     return res64 != *res;
 544 }
 545 
 546 /**
 547  * Truncates the given double.
 548  * trunc(3.3) = 3.0, trunc (-3.3) = -3.0
 549  * This is different than calling floor() or ceil():
 550  * floor(3.3) = 3, floor(-3.3) = -4
 551  * ceil(3.3) = 4, ceil(-3.3) = -3
 552  */
 553 U_CAPI double U_EXPORT2
 554 uprv_trunc(double d)
 555 {
 556 #if IEEE_754
 557     /* handle error cases*/
 558     if(uprv_isNaN(d))
 559         return uprv_getNaN();
 560     if(uprv_isInfinite(d))
 561         return uprv_getInfinity();
 562 
 563     if(u_signBit(d))    /* Signbit() picks up -0.0;  d&lt;0 does not. */
 564         return ceil(d);
 565     else
 566         return floor(d);
 567 
 568 #else
 569     return d &gt;= 0 ? floor(d) : ceil(d);
 570 
 571 #endif
 572 }
 573 
 574 /**
 575  * Return the largest positive number that can be represented by an integer
 576  * type of arbitrary bit length.
 577  */
 578 U_CAPI double U_EXPORT2
 579 uprv_maxMantissa(void)
 580 {
 581     return pow(2.0, DBL_MANT_DIG + 1.0) - 1.0;
 582 }
 583 
 584 U_CAPI double U_EXPORT2
 585 uprv_log(double d)
 586 {
 587     return log(d);
 588 }
 589 
 590 U_CAPI void * U_EXPORT2
 591 uprv_maximumPtr(void * base)
 592 {
 593 #if U_PLATFORM == U_PF_OS400
 594     /*
 595      * With the provided function we should never be out of range of a given segment
 596      * (a traditional/typical segment that is).  Our segments have 5 bytes for the
 597      * id and 3 bytes for the offset.  The key is that the casting takes care of
 598      * only retrieving the offset portion minus x1000.  Hence, the smallest offset
 599      * seen in a program is x001000 and when casted to an int would be 0.
 600      * That&#39;s why we can only add 0xffefff.  Otherwise, we would exceed the segment.
 601      *
 602      * Currently, 16MB is the current addressing limitation on i5/OS if the activation is
 603      * non-TERASPACE.  If it is TERASPACE it is 2GB - 4k(header information).
 604      * This function determines the activation based on the pointer that is passed in and
 605      * calculates the appropriate maximum available size for
 606      * each pointer type (TERASPACE and non-TERASPACE)
 607      *
 608      * Unlike other operating systems, the pointer model isn&#39;t determined at
 609      * compile time on i5/OS.
 610      */
 611     if ((base != NULL) &amp;&amp; (_TESTPTR(base, _C_TERASPACE_CHECK))) {
 612         /* if it is a TERASPACE pointer the max is 2GB - 4k */
 613         return ((void *)(((char *)base)-((uint32_t)(base))+((uint32_t)0x7fffefff)));
 614     }
 615     /* otherwise 16MB since NULL ptr is not checkable or the ptr is not TERASPACE */
 616     return ((void *)(((char *)base)-((uint32_t)(base))+((uint32_t)0xffefff)));
 617 
 618 #else
 619     return U_MAX_PTR(base);
 620 #endif
 621 }
 622 
 623 /*---------------------------------------------------------------------------
 624   Platform-specific Implementations
 625   Try these, and if they don&#39;t work on your platform, then special case your
 626   platform with new implementations.
 627   ---------------------------------------------------------------------------*/
 628 
 629 /* Generic time zone layer -------------------------------------------------- */
 630 
 631 /* Time zone utilities */
 632 U_CAPI void U_EXPORT2
 633 uprv_tzset()
 634 {
 635 #if defined(U_TZSET)
 636     U_TZSET();
 637 #else
 638     /* no initialization*/
 639 #endif
 640 }
 641 
 642 U_CAPI int32_t U_EXPORT2
 643 uprv_timezone()
 644 {
 645 #ifdef U_TIMEZONE
 646     return U_TIMEZONE;
 647 #else
 648     time_t t, t1, t2;
 649     struct tm tmrec;
 650     int32_t tdiff = 0;
 651 
 652     time(&amp;t);
 653     uprv_memcpy( &amp;tmrec, localtime(&amp;t), sizeof(tmrec) );
 654 #if U_PLATFORM != U_PF_IPHONE
 655     UBool dst_checked = (tmrec.tm_isdst != 0); /* daylight savings time is checked*/
 656 #endif
 657     t1 = mktime(&amp;tmrec);                 /* local time in seconds*/
 658     uprv_memcpy( &amp;tmrec, gmtime(&amp;t), sizeof(tmrec) );
 659     t2 = mktime(&amp;tmrec);                 /* GMT (or UTC) in seconds*/
 660     tdiff = t2 - t1;
 661 
 662 #if U_PLATFORM != U_PF_IPHONE
 663     /* imitate NT behaviour, which returns same timezone offset to GMT for
 664        winter and summer.
 665        This does not work on all platforms. For instance, on glibc on Linux
 666        and on Mac OS 10.5, tdiff calculated above remains the same
 667        regardless of whether DST is in effect or not. iOS is another
 668        platform where this does not work. Linux + glibc and Mac OS 10.5
 669        have U_TIMEZONE defined so that this code is not reached.
 670     */
 671     if (dst_checked)
 672         tdiff += 3600;
 673 #endif
 674     return tdiff;
 675 #endif
 676 }
 677 
 678 /* Note that U_TZNAME does *not* have to be tzname, but if it is,
 679    some platforms need to have it declared here. */
 680 
 681 #if defined(U_TZNAME) &amp;&amp; (U_PLATFORM == U_PF_IRIX || U_PLATFORM_IS_DARWIN_BASED)
 682 /* RS6000 and others reject char **tzname.  */
 683 extern U_IMPORT char *U_TZNAME[];
 684 #endif
 685 
 686 #if !UCONFIG_NO_FILE_IO &amp;&amp; ((U_PLATFORM_IS_DARWIN_BASED &amp;&amp; (U_PLATFORM != U_PF_IPHONE || defined(U_TIMEZONE))) || U_PLATFORM_IS_LINUX_BASED || U_PLATFORM == U_PF_BSD || U_PLATFORM == U_PF_SOLARIS)
 687 /* These platforms are likely to use Olson timezone IDs. */
 688 /* common targets of the symbolic link at TZDEFAULT are:
 689  * &quot;/usr/share/zoneinfo/&lt;olsonID&gt;&quot; default, older Linux distros, macOS to 10.12
 690  * &quot;../usr/share/zoneinfo/&lt;olsonID&gt;&quot; newer Linux distros: Red Hat Enterprise Linux 7, Ubuntu 16, SuSe Linux 12
 691  * &quot;/usr/share/lib/zoneinfo/&lt;olsonID&gt;&quot; Solaris
 692  * &quot;../usr/share/lib/zoneinfo/&lt;olsonID&gt;&quot; Solaris
 693  * &quot;/var/db/timezone/zoneinfo/&lt;olsonID&gt;&quot; macOS 10.13
 694  * To avoid checking lots of paths, just check that the target path
 695  * before the &lt;olsonID&gt; ends with &quot;/zoneinfo/&quot;, and the &lt;olsonID&gt; is valid.
 696  */
 697 
 698 #define CHECK_LOCALTIME_LINK 1
 699 #if U_PLATFORM_IS_DARWIN_BASED
 700 #include &lt;tzfile.h&gt;
 701 #define TZZONEINFO      (TZDIR &quot;/&quot;)
 702 #elif U_PLATFORM == U_PF_SOLARIS
 703 #define TZDEFAULT       &quot;/etc/localtime&quot;
 704 #define TZZONEINFO      &quot;/usr/share/lib/zoneinfo/&quot;
 705 #define TZ_ENV_CHECK    &quot;localtime&quot;
 706 #else
 707 #define TZDEFAULT       &quot;/etc/localtime&quot;
 708 #define TZZONEINFO      &quot;/usr/share/zoneinfo/&quot;
 709 #endif
 710 #define TZZONEINFOTAIL  &quot;/zoneinfo/&quot;
 711 #if U_HAVE_DIRENT_H
 712 #define TZFILE_SKIP     &quot;posixrules&quot; /* tz file to skip when searching. */
 713 /* Some Linux distributions have &#39;localtime&#39; in /usr/share/zoneinfo
 714    symlinked to /etc/localtime, which makes searchForTZFile return
 715    &#39;localtime&#39; when it&#39;s the first match. */
 716 #define TZFILE_SKIP2    &quot;localtime&quot;
 717 #define SEARCH_TZFILE
 718 #include &lt;dirent.h&gt;  /* Needed to search through system timezone files */
 719 #endif
 720 static char gTimeZoneBuffer[PATH_MAX];
 721 static char *gTimeZoneBufferPtr = NULL;
 722 #endif
 723 
 724 #if !U_PLATFORM_USES_ONLY_WIN32_API
 725 #define isNonDigit(ch) (ch &lt; &#39;0&#39; || &#39;9&#39; &lt; ch)
 726 static UBool isValidOlsonID(const char *id) {
 727     int32_t idx = 0;
 728 
 729     /* Determine if this is something like Iceland (Olson ID)
 730     or AST4ADT (non-Olson ID) */
 731     while (id[idx] &amp;&amp; isNonDigit(id[idx]) &amp;&amp; id[idx] != &#39;,&#39;) {
 732         idx++;
 733     }
 734 
 735     /* If we went through the whole string, then it might be okay.
 736     The timezone is sometimes set to &quot;CST-7CDT&quot;, &quot;CST6CDT5,J129,J131/19:30&quot;,
 737     &quot;GRNLNDST3GRNLNDDT&quot; or similar, so we cannot use it.
 738     The rest of the time it could be an Olson ID. George */
 739     return (UBool)(id[idx] == 0
 740         || uprv_strcmp(id, &quot;PST8PDT&quot;) == 0
 741         || uprv_strcmp(id, &quot;MST7MDT&quot;) == 0
 742         || uprv_strcmp(id, &quot;CST6CDT&quot;) == 0
 743         || uprv_strcmp(id, &quot;EST5EDT&quot;) == 0);
 744 }
 745 
 746 /* On some Unix-like OS, &#39;posix&#39; subdirectory in
 747    /usr/share/zoneinfo replicates the top-level contents. &#39;right&#39;
 748    subdirectory has the same set of files, but individual files
 749    are different from those in the top-level directory or &#39;posix&#39;
 750    because &#39;right&#39; has files for TAI (Int&#39;l Atomic Time) while &#39;posix&#39;
 751    has files for UTC.
 752    When the first match for /etc/localtime is in either of them
 753    (usually in posix because &#39;right&#39; has different file contents),
 754    or TZ environment variable points to one of them, createTimeZone
 755    fails because, say, &#39;posix/America/New_York&#39; is not an Olson
 756    timezone id (&#39;America/New_York&#39; is). So, we have to skip
 757    &#39;posix/&#39; and &#39;right/&#39; at the beginning. */
 758 static void skipZoneIDPrefix(const char** id) {
 759     if (uprv_strncmp(*id, &quot;posix/&quot;, 6) == 0
 760         || uprv_strncmp(*id, &quot;right/&quot;, 6) == 0)
 761     {
 762         *id += 6;
 763     }
 764 }
 765 #endif
 766 
 767 #if defined(U_TZNAME) &amp;&amp; !U_PLATFORM_USES_ONLY_WIN32_API
 768 
 769 #define CONVERT_HOURS_TO_SECONDS(offset) (int32_t)(offset*3600)
 770 typedef struct OffsetZoneMapping {
 771     int32_t offsetSeconds;
 772     int32_t daylightType; /* 0=U_DAYLIGHT_NONE, 1=daylight in June-U_DAYLIGHT_JUNE, 2=daylight in December=U_DAYLIGHT_DECEMBER*/
 773     const char *stdID;
 774     const char *dstID;
 775     const char *olsonID;
 776 } OffsetZoneMapping;
 777 
 778 enum { U_DAYLIGHT_NONE=0,U_DAYLIGHT_JUNE=1,U_DAYLIGHT_DECEMBER=2 };
 779 
 780 /*
 781 This list tries to disambiguate a set of abbreviated timezone IDs and offsets
 782 and maps it to an Olson ID.
 783 Before adding anything to this list, take a look at
 784 icu/source/tools/tzcode/tz.alias
 785 Sometimes no daylight savings (0) is important to define due to aliases.
 786 This list can be tested with icu/source/test/compat/tzone.pl
 787 More values could be added to daylightType to increase precision.
 788 */
 789 static const struct OffsetZoneMapping OFFSET_ZONE_MAPPINGS[] = {
 790     {-45900, 2, &quot;CHAST&quot;, &quot;CHADT&quot;, &quot;Pacific/Chatham&quot;},
 791     {-43200, 1, &quot;PETT&quot;, &quot;PETST&quot;, &quot;Asia/Kamchatka&quot;},
 792     {-43200, 2, &quot;NZST&quot;, &quot;NZDT&quot;, &quot;Pacific/Auckland&quot;},
 793     {-43200, 1, &quot;ANAT&quot;, &quot;ANAST&quot;, &quot;Asia/Anadyr&quot;},
 794     {-39600, 1, &quot;MAGT&quot;, &quot;MAGST&quot;, &quot;Asia/Magadan&quot;},
 795     {-37800, 2, &quot;LHST&quot;, &quot;LHST&quot;, &quot;Australia/Lord_Howe&quot;},
 796     {-36000, 2, &quot;EST&quot;, &quot;EST&quot;, &quot;Australia/Sydney&quot;},
 797     {-36000, 1, &quot;SAKT&quot;, &quot;SAKST&quot;, &quot;Asia/Sakhalin&quot;},
 798     {-36000, 1, &quot;VLAT&quot;, &quot;VLAST&quot;, &quot;Asia/Vladivostok&quot;},
 799     {-34200, 2, &quot;CST&quot;, &quot;CST&quot;, &quot;Australia/South&quot;},
 800     {-32400, 1, &quot;YAKT&quot;, &quot;YAKST&quot;, &quot;Asia/Yakutsk&quot;},
 801     {-32400, 1, &quot;CHOT&quot;, &quot;CHOST&quot;, &quot;Asia/Choibalsan&quot;},
 802     {-31500, 2, &quot;CWST&quot;, &quot;CWST&quot;, &quot;Australia/Eucla&quot;},
 803     {-28800, 1, &quot;IRKT&quot;, &quot;IRKST&quot;, &quot;Asia/Irkutsk&quot;},
 804     {-28800, 1, &quot;ULAT&quot;, &quot;ULAST&quot;, &quot;Asia/Ulaanbaatar&quot;},
 805     {-28800, 2, &quot;WST&quot;, &quot;WST&quot;, &quot;Australia/West&quot;},
 806     {-25200, 1, &quot;HOVT&quot;, &quot;HOVST&quot;, &quot;Asia/Hovd&quot;},
 807     {-25200, 1, &quot;KRAT&quot;, &quot;KRAST&quot;, &quot;Asia/Krasnoyarsk&quot;},
 808     {-21600, 1, &quot;NOVT&quot;, &quot;NOVST&quot;, &quot;Asia/Novosibirsk&quot;},
 809     {-21600, 1, &quot;OMST&quot;, &quot;OMSST&quot;, &quot;Asia/Omsk&quot;},
 810     {-18000, 1, &quot;YEKT&quot;, &quot;YEKST&quot;, &quot;Asia/Yekaterinburg&quot;},
 811     {-14400, 1, &quot;SAMT&quot;, &quot;SAMST&quot;, &quot;Europe/Samara&quot;},
 812     {-14400, 1, &quot;AMT&quot;, &quot;AMST&quot;, &quot;Asia/Yerevan&quot;},
 813     {-14400, 1, &quot;AZT&quot;, &quot;AZST&quot;, &quot;Asia/Baku&quot;},
 814     {-10800, 1, &quot;AST&quot;, &quot;ADT&quot;, &quot;Asia/Baghdad&quot;},
 815     {-10800, 1, &quot;MSK&quot;, &quot;MSD&quot;, &quot;Europe/Moscow&quot;},
 816     {-10800, 1, &quot;VOLT&quot;, &quot;VOLST&quot;, &quot;Europe/Volgograd&quot;},
 817     {-7200, 0, &quot;EET&quot;, &quot;CEST&quot;, &quot;Africa/Tripoli&quot;},
 818     {-7200, 1, &quot;EET&quot;, &quot;EEST&quot;, &quot;Europe/Athens&quot;}, /* Conflicts with Africa/Cairo */
 819     {-7200, 1, &quot;IST&quot;, &quot;IDT&quot;, &quot;Asia/Jerusalem&quot;},
 820     {-3600, 0, &quot;CET&quot;, &quot;WEST&quot;, &quot;Africa/Algiers&quot;},
 821     {-3600, 2, &quot;WAT&quot;, &quot;WAST&quot;, &quot;Africa/Windhoek&quot;},
 822     {0, 1, &quot;GMT&quot;, &quot;IST&quot;, &quot;Europe/Dublin&quot;},
 823     {0, 1, &quot;GMT&quot;, &quot;BST&quot;, &quot;Europe/London&quot;},
 824     {0, 0, &quot;WET&quot;, &quot;WEST&quot;, &quot;Africa/Casablanca&quot;},
 825     {0, 0, &quot;WET&quot;, &quot;WET&quot;, &quot;Africa/El_Aaiun&quot;},
 826     {3600, 1, &quot;AZOT&quot;, &quot;AZOST&quot;, &quot;Atlantic/Azores&quot;},
 827     {3600, 1, &quot;EGT&quot;, &quot;EGST&quot;, &quot;America/Scoresbysund&quot;},
 828     {10800, 1, &quot;PMST&quot;, &quot;PMDT&quot;, &quot;America/Miquelon&quot;},
 829     {10800, 2, &quot;UYT&quot;, &quot;UYST&quot;, &quot;America/Montevideo&quot;},
 830     {10800, 1, &quot;WGT&quot;, &quot;WGST&quot;, &quot;America/Godthab&quot;},
 831     {10800, 2, &quot;BRT&quot;, &quot;BRST&quot;, &quot;Brazil/East&quot;},
 832     {12600, 1, &quot;NST&quot;, &quot;NDT&quot;, &quot;America/St_Johns&quot;},
 833     {14400, 1, &quot;AST&quot;, &quot;ADT&quot;, &quot;Canada/Atlantic&quot;},
 834     {14400, 2, &quot;AMT&quot;, &quot;AMST&quot;, &quot;America/Cuiaba&quot;},
 835     {14400, 2, &quot;CLT&quot;, &quot;CLST&quot;, &quot;Chile/Continental&quot;},
 836     {14400, 2, &quot;FKT&quot;, &quot;FKST&quot;, &quot;Atlantic/Stanley&quot;},
 837     {14400, 2, &quot;PYT&quot;, &quot;PYST&quot;, &quot;America/Asuncion&quot;},
 838     {18000, 1, &quot;CST&quot;, &quot;CDT&quot;, &quot;America/Havana&quot;},
 839     {18000, 1, &quot;EST&quot;, &quot;EDT&quot;, &quot;US/Eastern&quot;}, /* Conflicts with America/Grand_Turk */
 840     {21600, 2, &quot;EAST&quot;, &quot;EASST&quot;, &quot;Chile/EasterIsland&quot;},
 841     {21600, 0, &quot;CST&quot;, &quot;MDT&quot;, &quot;Canada/Saskatchewan&quot;},
 842     {21600, 0, &quot;CST&quot;, &quot;CDT&quot;, &quot;America/Guatemala&quot;},
 843     {21600, 1, &quot;CST&quot;, &quot;CDT&quot;, &quot;US/Central&quot;}, /* Conflicts with Mexico/General */
 844     {25200, 1, &quot;MST&quot;, &quot;MDT&quot;, &quot;US/Mountain&quot;}, /* Conflicts with Mexico/BajaSur */
 845     {28800, 0, &quot;PST&quot;, &quot;PST&quot;, &quot;Pacific/Pitcairn&quot;},
 846     {28800, 1, &quot;PST&quot;, &quot;PDT&quot;, &quot;US/Pacific&quot;}, /* Conflicts with Mexico/BajaNorte */
 847     {32400, 1, &quot;AKST&quot;, &quot;AKDT&quot;, &quot;US/Alaska&quot;},
 848     {36000, 1, &quot;HAST&quot;, &quot;HADT&quot;, &quot;US/Aleutian&quot;}
 849 };
 850 
 851 /*#define DEBUG_TZNAME*/
 852 
 853 static const char* remapShortTimeZone(const char *stdID, const char *dstID, int32_t daylightType, int32_t offset)
 854 {
 855     int32_t idx;
 856 #ifdef DEBUG_TZNAME
 857     fprintf(stderr, &quot;TZ=%s std=%s dst=%s daylight=%d offset=%d\n&quot;, getenv(&quot;TZ&quot;), stdID, dstID, daylightType, offset);
 858 #endif
 859     for (idx = 0; idx &lt; UPRV_LENGTHOF(OFFSET_ZONE_MAPPINGS); idx++)
 860     {
 861         if (offset == OFFSET_ZONE_MAPPINGS[idx].offsetSeconds
 862             &amp;&amp; daylightType == OFFSET_ZONE_MAPPINGS[idx].daylightType
 863             &amp;&amp; strcmp(OFFSET_ZONE_MAPPINGS[idx].stdID, stdID) == 0
 864             &amp;&amp; strcmp(OFFSET_ZONE_MAPPINGS[idx].dstID, dstID) == 0)
 865         {
 866             return OFFSET_ZONE_MAPPINGS[idx].olsonID;
 867         }
 868     }
 869     return NULL;
 870 }
 871 #endif
 872 
 873 #ifdef SEARCH_TZFILE
 874 #define MAX_READ_SIZE 512
 875 
 876 typedef struct DefaultTZInfo {
 877     char* defaultTZBuffer;
 878     int64_t defaultTZFileSize;
 879     FILE* defaultTZFilePtr;
 880     UBool defaultTZstatus;
 881     int32_t defaultTZPosition;
 882 } DefaultTZInfo;
 883 
 884 /*
 885  * This method compares the two files given to see if they are a match.
 886  * It is currently use to compare two TZ files.
 887  */
 888 static UBool compareBinaryFiles(const char* defaultTZFileName, const char* TZFileName, DefaultTZInfo* tzInfo) {
 889     FILE* file;
 890     int64_t sizeFile;
 891     int64_t sizeFileLeft;
 892     int32_t sizeFileRead;
 893     int32_t sizeFileToRead;
 894     char bufferFile[MAX_READ_SIZE];
 895     UBool result = TRUE;
 896 
 897     if (tzInfo-&gt;defaultTZFilePtr == NULL) {
 898         tzInfo-&gt;defaultTZFilePtr = fopen(defaultTZFileName, &quot;r&quot;);
 899     }
 900     file = fopen(TZFileName, &quot;r&quot;);
 901 
 902     tzInfo-&gt;defaultTZPosition = 0; /* reset position to begin search */
 903 
 904     if (file != NULL &amp;&amp; tzInfo-&gt;defaultTZFilePtr != NULL) {
 905         /* First check that the file size are equal. */
 906         if (tzInfo-&gt;defaultTZFileSize == 0) {
 907             fseek(tzInfo-&gt;defaultTZFilePtr, 0, SEEK_END);
 908             tzInfo-&gt;defaultTZFileSize = ftell(tzInfo-&gt;defaultTZFilePtr);
 909         }
 910         fseek(file, 0, SEEK_END);
 911         sizeFile = ftell(file);
 912         sizeFileLeft = sizeFile;
 913 
 914         if (sizeFile != tzInfo-&gt;defaultTZFileSize) {
 915             result = FALSE;
 916         } else {
 917             /* Store the data from the files in seperate buffers and
 918              * compare each byte to determine equality.
 919              */
 920             if (tzInfo-&gt;defaultTZBuffer == NULL) {
 921                 rewind(tzInfo-&gt;defaultTZFilePtr);
 922                 tzInfo-&gt;defaultTZBuffer = (char*)uprv_malloc(sizeof(char) * tzInfo-&gt;defaultTZFileSize);
 923                 sizeFileRead = fread(tzInfo-&gt;defaultTZBuffer, 1, tzInfo-&gt;defaultTZFileSize, tzInfo-&gt;defaultTZFilePtr);
 924             }
 925             rewind(file);
 926             while(sizeFileLeft &gt; 0) {
 927                 uprv_memset(bufferFile, 0, MAX_READ_SIZE);
 928                 sizeFileToRead = sizeFileLeft &lt; MAX_READ_SIZE ? sizeFileLeft : MAX_READ_SIZE;
 929 
 930                 sizeFileRead = fread(bufferFile, 1, sizeFileToRead, file);
 931                 if (memcmp(tzInfo-&gt;defaultTZBuffer + tzInfo-&gt;defaultTZPosition, bufferFile, sizeFileRead) != 0) {
 932                     result = FALSE;
 933                     break;
 934                 }
 935                 sizeFileLeft -= sizeFileRead;
 936                 tzInfo-&gt;defaultTZPosition += sizeFileRead;
 937             }
 938         }
 939     } else {
 940         result = FALSE;
 941     }
 942 
 943     if (file != NULL) {
 944         fclose(file);
 945     }
 946 
 947     return result;
 948 }
 949 
 950 
 951 /* dirent also lists two entries: &quot;.&quot; and &quot;..&quot; that we can safely ignore. */
 952 #define SKIP1 &quot;.&quot;
 953 #define SKIP2 &quot;..&quot;
 954 static UBool U_CALLCONV putil_cleanup(void);
 955 static CharString *gSearchTZFileResult = NULL;
 956 
 957 /*
 958  * This method recursively traverses the directory given for a matching TZ file and returns the first match.
 959  * This function is not thread safe - it uses a global, gSearchTZFileResult, to hold its results.
 960  */
 961 static char* searchForTZFile(const char* path, DefaultTZInfo* tzInfo) {
 962     DIR* dirp = NULL;
 963     struct dirent* dirEntry = NULL;
 964     char* result = NULL;
 965     UErrorCode status = U_ZERO_ERROR;
 966 
 967     /* Save the current path */
 968     CharString curpath(path, -1, status);
 969     if (U_FAILURE(status)) {
 970         goto cleanupAndReturn;
 971     }
 972 
 973     dirp = opendir(path);
 974     if (dirp == NULL) {
 975         goto cleanupAndReturn;
 976     }
 977 
 978     if (gSearchTZFileResult == NULL) {
 979         gSearchTZFileResult = new CharString;
 980         if (gSearchTZFileResult == NULL) {
 981             goto cleanupAndReturn;
 982         }
 983         ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
 984     }
 985 
 986     /* Check each entry in the directory. */
 987     while((dirEntry = readdir(dirp)) != NULL) {
 988         const char* dirName = dirEntry-&gt;d_name;
 989         if (uprv_strcmp(dirName, SKIP1) != 0 &amp;&amp; uprv_strcmp(dirName, SKIP2) != 0
 990             &amp;&amp; uprv_strcmp(TZFILE_SKIP, dirName) != 0 &amp;&amp; uprv_strcmp(TZFILE_SKIP2, dirName) != 0) {
 991             /* Create a newpath with the new entry to test each entry in the directory. */
 992             CharString newpath(curpath, status);
 993             newpath.append(dirName, -1, status);
 994             if (U_FAILURE(status)) {
 995                 break;
 996             }
 997 
 998             DIR* subDirp = NULL;
 999             if ((subDirp = opendir(newpath.data())) != NULL) {
1000                 /* If this new path is a directory, make a recursive call with the newpath. */
1001                 closedir(subDirp);
1002                 newpath.append(&#39;/&#39;, status);
1003                 if (U_FAILURE(status)) {
1004                     break;
1005                 }
1006                 result = searchForTZFile(newpath.data(), tzInfo);
1007                 /*
1008                  Have to get out here. Otherwise, we&#39;d keep looking
1009                  and return the first match in the top-level directory
1010                  if there&#39;s a match in the top-level. If not, this function
1011                  would return NULL and set gTimeZoneBufferPtr to NULL in initDefault().
1012                  It worked without this in most cases because we have a fallback of calling
1013                  localtime_r to figure out the default timezone.
1014                 */
1015                 if (result != NULL)
1016                     break;
1017             } else {
1018                 if(compareBinaryFiles(TZDEFAULT, newpath.data(), tzInfo)) {
1019                     int32_t amountToSkip = sizeof(TZZONEINFO) - 1;
1020                     if (amountToSkip &gt; newpath.length()) {
1021                         amountToSkip = newpath.length();
1022                     }
1023                     const char* zoneid = newpath.data() + amountToSkip;
1024                     skipZoneIDPrefix(&amp;zoneid);
1025                     gSearchTZFileResult-&gt;clear();
1026                     gSearchTZFileResult-&gt;append(zoneid, -1, status);
1027                     if (U_FAILURE(status)) {
1028                         break;
1029                     }
1030                     result = gSearchTZFileResult-&gt;data();
1031                     /* Get out after the first one found. */
1032                     break;
1033                 }
1034             }
1035         }
1036     }
1037 
1038   cleanupAndReturn:
1039     if (dirp) {
1040         closedir(dirp);
1041     }
1042     return result;
1043 }
1044 #endif
1045 
1046 U_CAPI void U_EXPORT2
1047 uprv_tzname_clear_cache()
1048 {
1049 #if defined(CHECK_LOCALTIME_LINK) &amp;&amp; !defined(DEBUG_SKIP_LOCALTIME_LINK)
1050     gTimeZoneBufferPtr = NULL;
1051 #endif
1052 }
1053 
1054 U_CAPI const char* U_EXPORT2
1055 uprv_tzname(int n)
1056 {
1057     (void)n; // Avoid unreferenced parameter warning.
1058     const char *tzid = NULL;
1059 #if U_PLATFORM_USES_ONLY_WIN32_API
1060     tzid = uprv_detectWindowsTimeZone();
1061 
1062     if (tzid != NULL) {
1063         return tzid;
1064     }
1065 
1066 #ifndef U_TZNAME
1067     // The return value is free&#39;d in timezone.cpp on Windows because
1068     // the other code path returns a pointer to a heap location.
1069     // If we don&#39;t have a name already, then tzname wouldn&#39;t be any
1070     // better, so just fall back.
1071     return uprv_strdup(&quot;&quot;);
1072 #endif // !U_TZNAME
1073 
1074 #else
1075 
1076 /*#if U_PLATFORM_IS_DARWIN_BASED
1077     int ret;
1078 
1079     tzid = getenv(&quot;TZFILE&quot;);
1080     if (tzid != NULL) {
1081         return tzid;
1082     }
1083 #endif*/
1084 
1085 /* This code can be temporarily disabled to test tzname resolution later on. */
1086 #ifndef DEBUG_TZNAME
1087     tzid = getenv(&quot;TZ&quot;);
1088     if (tzid != NULL &amp;&amp; isValidOlsonID(tzid)
1089 #if U_PLATFORM == U_PF_SOLARIS
1090     /* When TZ equals localtime on Solaris, check the /etc/localtime file. */
1091         &amp;&amp; uprv_strcmp(tzid, TZ_ENV_CHECK) != 0
1092 #endif
1093     ) {
1094         /* The colon forces tzset() to treat the remainder as zoneinfo path */
1095         if (tzid[0] == &#39;:&#39;) {
1096             tzid++;
1097         }
1098         /* This might be a good Olson ID. */
1099         skipZoneIDPrefix(&amp;tzid);
1100         return tzid;
1101     }
1102     /* else U_TZNAME will give a better result. */
1103 #endif
1104 
1105 #if defined(CHECK_LOCALTIME_LINK) &amp;&amp; !defined(DEBUG_SKIP_LOCALTIME_LINK)
1106     /* Caller must handle threading issues */
1107     if (gTimeZoneBufferPtr == NULL) {
1108         /*
1109         This is a trick to look at the name of the link to get the Olson ID
1110         because the tzfile contents is underspecified.
1111         This isn&#39;t guaranteed to work because it may not be a symlink.
1112         */
1113         int32_t ret = (int32_t)readlink(TZDEFAULT, gTimeZoneBuffer, sizeof(gTimeZoneBuffer)-1);
1114         if (0 &lt; ret) {
1115             int32_t tzZoneInfoTailLen = uprv_strlen(TZZONEINFOTAIL);
1116             gTimeZoneBuffer[ret] = 0;
1117             char *  tzZoneInfoTailPtr = uprv_strstr(gTimeZoneBuffer, TZZONEINFOTAIL);
1118 
1119             if (tzZoneInfoTailPtr != NULL
1120                 &amp;&amp; isValidOlsonID(tzZoneInfoTailPtr + tzZoneInfoTailLen))
1121             {
1122                 return (gTimeZoneBufferPtr = tzZoneInfoTailPtr + tzZoneInfoTailLen);
1123             }
1124         } else {
1125 #if defined(SEARCH_TZFILE)
1126             DefaultTZInfo* tzInfo = (DefaultTZInfo*)uprv_malloc(sizeof(DefaultTZInfo));
1127             if (tzInfo != NULL) {
1128                 tzInfo-&gt;defaultTZBuffer = NULL;
1129                 tzInfo-&gt;defaultTZFileSize = 0;
1130                 tzInfo-&gt;defaultTZFilePtr = NULL;
1131                 tzInfo-&gt;defaultTZstatus = FALSE;
1132                 tzInfo-&gt;defaultTZPosition = 0;
1133 
1134                 gTimeZoneBufferPtr = searchForTZFile(TZZONEINFO, tzInfo);
1135 
1136                 /* Free previously allocated memory */
1137                 if (tzInfo-&gt;defaultTZBuffer != NULL) {
1138                     uprv_free(tzInfo-&gt;defaultTZBuffer);
1139                 }
1140                 if (tzInfo-&gt;defaultTZFilePtr != NULL) {
1141                     fclose(tzInfo-&gt;defaultTZFilePtr);
1142                 }
1143                 uprv_free(tzInfo);
1144             }
1145 
1146             if (gTimeZoneBufferPtr != NULL &amp;&amp; isValidOlsonID(gTimeZoneBufferPtr)) {
1147                 return gTimeZoneBufferPtr;
1148             }
1149 #endif
1150         }
1151     }
1152     else {
1153         return gTimeZoneBufferPtr;
1154     }
1155 #endif
1156 #endif
1157 
1158 #ifdef U_TZNAME
1159 #if U_PLATFORM_USES_ONLY_WIN32_API
1160     /* The return value is free&#39;d in timezone.cpp on Windows because
1161      * the other code path returns a pointer to a heap location. */
1162     return uprv_strdup(U_TZNAME[n]);
1163 #else
1164     /*
1165     U_TZNAME is usually a non-unique abbreviation, which isn&#39;t normally usable.
1166     So we remap the abbreviation to an olson ID.
1167 
1168     Since Windows exposes a little more timezone information,
1169     we normally don&#39;t use this code on Windows because
1170     uprv_detectWindowsTimeZone should have already given the correct answer.
1171     */
1172     {
1173         struct tm juneSol, decemberSol;
1174         int daylightType;
1175         static const time_t juneSolstice=1182478260; /*2007-06-21 18:11 UT*/
1176         static const time_t decemberSolstice=1198332540; /*2007-12-22 06:09 UT*/
1177 
1178         /* This probing will tell us when daylight savings occurs.  */
1179         localtime_r(&amp;juneSolstice, &amp;juneSol);
1180         localtime_r(&amp;decemberSolstice, &amp;decemberSol);
1181         if(decemberSol.tm_isdst &gt; 0) {
1182           daylightType = U_DAYLIGHT_DECEMBER;
1183         } else if(juneSol.tm_isdst &gt; 0) {
1184           daylightType = U_DAYLIGHT_JUNE;
1185         } else {
1186           daylightType = U_DAYLIGHT_NONE;
1187         }
1188         tzid = remapShortTimeZone(U_TZNAME[0], U_TZNAME[1], daylightType, uprv_timezone());
1189         if (tzid != NULL) {
1190             return tzid;
1191         }
1192     }
1193     return U_TZNAME[n];
1194 #endif
1195 #else
1196     return &quot;&quot;;
1197 #endif
1198 }
1199 
1200 /* Get and set the ICU data directory --------------------------------------- */
1201 
1202 static icu::UInitOnce gDataDirInitOnce = U_INITONCE_INITIALIZER;
1203 static char *gDataDirectory = NULL;
1204 
1205 UInitOnce gTimeZoneFilesInitOnce = U_INITONCE_INITIALIZER;
1206 static CharString *gTimeZoneFilesDirectory = NULL;
1207 
1208 #if U_POSIX_LOCALE || U_PLATFORM_USES_ONLY_WIN32_API
1209  static const char *gCorrectedPOSIXLocale = NULL; /* Sometimes heap allocated */
1210  static bool gCorrectedPOSIXLocaleHeapAllocated = false;
1211 #endif
1212 
1213 static UBool U_CALLCONV putil_cleanup(void)
1214 {
1215     if (gDataDirectory &amp;&amp; *gDataDirectory) {
1216         uprv_free(gDataDirectory);
1217     }
1218     gDataDirectory = NULL;
1219     gDataDirInitOnce.reset();
1220 
1221     delete gTimeZoneFilesDirectory;
1222     gTimeZoneFilesDirectory = NULL;
1223     gTimeZoneFilesInitOnce.reset();
1224 
1225 #ifdef SEARCH_TZFILE
1226     delete gSearchTZFileResult;
1227     gSearchTZFileResult = NULL;
1228 #endif
1229 
1230 #if U_POSIX_LOCALE || U_PLATFORM_USES_ONLY_WIN32_API
1231     if (gCorrectedPOSIXLocale &amp;&amp; gCorrectedPOSIXLocaleHeapAllocated) {
1232         uprv_free(const_cast&lt;char *&gt;(gCorrectedPOSIXLocale));
1233         gCorrectedPOSIXLocale = NULL;
1234         gCorrectedPOSIXLocaleHeapAllocated = false;
1235     }
1236 #endif
1237     return TRUE;
1238 }
1239 
1240 /*
1241  * Set the data directory.
1242  *    Make a copy of the passed string, and set the global data dir to point to it.
1243  */
1244 U_CAPI void U_EXPORT2
1245 u_setDataDirectory(const char *directory) {
1246     char *newDataDir;
1247     int32_t length;
1248 
1249     if(directory==NULL || *directory==0) {
1250         /* A small optimization to prevent the malloc and copy when the
1251         shared library is used, and this is a way to make sure that NULL
1252         is never returned.
1253         */
1254         newDataDir = (char *)&quot;&quot;;
1255     }
1256     else {
1257         length=(int32_t)uprv_strlen(directory);
1258         newDataDir = (char *)uprv_malloc(length + 2);
1259         /* Exit out if newDataDir could not be created. */
1260         if (newDataDir == NULL) {
1261             return;
1262         }
1263         uprv_strcpy(newDataDir, directory);
1264 
1265 #if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)
1266         {
1267             char *p;
1268             while((p = uprv_strchr(newDataDir, U_FILE_ALT_SEP_CHAR)) != NULL) {
1269                 *p = U_FILE_SEP_CHAR;
1270             }
1271         }
1272 #endif
1273     }
1274 
1275     if (gDataDirectory &amp;&amp; *gDataDirectory) {
1276         uprv_free(gDataDirectory);
1277     }
1278     gDataDirectory = newDataDir;
1279     ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
1280 }
1281 
1282 U_CAPI UBool U_EXPORT2
1283 uprv_pathIsAbsolute(const char *path)
1284 {
1285   if(!path || !*path) {
1286     return FALSE;
1287   }
1288 
1289   if(*path == U_FILE_SEP_CHAR) {
1290     return TRUE;
1291   }
1292 
1293 #if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)
1294   if(*path == U_FILE_ALT_SEP_CHAR) {
1295     return TRUE;
1296   }
1297 #endif
1298 
1299 #if U_PLATFORM_USES_ONLY_WIN32_API
1300   if( (((path[0] &gt;= &#39;A&#39;) &amp;&amp; (path[0] &lt;= &#39;Z&#39;)) ||
1301        ((path[0] &gt;= &#39;a&#39;) &amp;&amp; (path[0] &lt;= &#39;z&#39;))) &amp;&amp;
1302       path[1] == &#39;:&#39; ) {
1303     return TRUE;
1304   }
1305 #endif
1306 
1307   return FALSE;
1308 }
1309 
1310 /* Backup setting of ICU_DATA_DIR_PREFIX_ENV_VAR
1311    (needed for some Darwin ICU build environments) */
1312 #if U_PLATFORM_IS_DARWIN_BASED &amp;&amp; TARGET_OS_SIMULATOR
1313 # if !defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
1314 #  define ICU_DATA_DIR_PREFIX_ENV_VAR &quot;IPHONE_SIMULATOR_ROOT&quot;
1315 # endif
1316 #endif
1317 
1318 #if U_PLATFORM_HAS_WINUWP_API != 0
1319 // Helper function to get the ICU Data Directory under the Windows directory location.
1320 static BOOL U_CALLCONV getIcuDataDirectoryUnderWindowsDirectory(char* directoryBuffer, UINT bufferLength)
1321 {
1322 #if defined(ICU_DATA_DIR_WINDOWS)
1323     wchar_t windowsPath[MAX_PATH];
1324     char windowsPathUtf8[MAX_PATH];
1325 
1326     UINT length = GetSystemWindowsDirectoryW(windowsPath, UPRV_LENGTHOF(windowsPath));
1327     if ((length &gt; 0) &amp;&amp; (length &lt; (UPRV_LENGTHOF(windowsPath) - 1))) {
1328         // Convert UTF-16 to a UTF-8 string.
1329         UErrorCode status = U_ZERO_ERROR;
1330         int32_t windowsPathUtf8Len = 0;
1331         u_strToUTF8(windowsPathUtf8, static_cast&lt;int32_t&gt;(UPRV_LENGTHOF(windowsPathUtf8)),
1332             &amp;windowsPathUtf8Len, reinterpret_cast&lt;const UChar*&gt;(windowsPath), -1, &amp;status);
1333 
1334         if (U_SUCCESS(status) &amp;&amp; (status != U_STRING_NOT_TERMINATED_WARNING) &amp;&amp;
1335             (windowsPathUtf8Len &lt; (UPRV_LENGTHOF(windowsPathUtf8) - 1))) {
1336             // Ensure it always has a separator, so we can append the ICU data path.
1337             if (windowsPathUtf8[windowsPathUtf8Len - 1] != U_FILE_SEP_CHAR) {
1338                 windowsPathUtf8[windowsPathUtf8Len++] = U_FILE_SEP_CHAR;
1339                 windowsPathUtf8[windowsPathUtf8Len] = &#39;\0&#39;;
1340             }
1341             // Check if the concatenated string will fit.
1342             if ((windowsPathUtf8Len + UPRV_LENGTHOF(ICU_DATA_DIR_WINDOWS)) &lt; bufferLength) {
1343                 uprv_strcpy(directoryBuffer, windowsPathUtf8);
1344                 uprv_strcat(directoryBuffer, ICU_DATA_DIR_WINDOWS);
1345                 return TRUE;
1346             }
1347         }
1348     }
1349 #endif
1350 
1351     return FALSE;
1352 }
1353 #endif
1354 
1355 static void U_CALLCONV dataDirectoryInitFn() {
1356     /* If we already have the directory, then return immediately. Will happen if user called
1357      * u_setDataDirectory().
1358      */
1359     if (gDataDirectory) {
1360         return;
1361     }
1362 
1363     const char *path = NULL;
1364 #if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
1365     char datadir_path_buffer[PATH_MAX];
1366 #endif
1367 
1368     /*
1369     When ICU_NO_USER_DATA_OVERRIDE is defined, users aren&#39;t allowed to
1370     override ICU&#39;s data with the ICU_DATA environment variable. This prevents
1371     problems where multiple custom copies of ICU&#39;s specific version of data
1372     are installed on a system. Either the application must define the data
1373     directory with u_setDataDirectory, define ICU_DATA_DIR when compiling
1374     ICU, set the data with udata_setCommonData or trust that all of the
1375     required data is contained in ICU&#39;s data library that contains
1376     the entry point defined by U_ICUDATA_ENTRY_POINT.
1377 
1378     There may also be some platforms where environment variables
1379     are not allowed.
1380     */
1381 #   if !defined(ICU_NO_USER_DATA_OVERRIDE) &amp;&amp; !UCONFIG_NO_FILE_IO
1382     /* First try to get the environment variable */
1383 #       if U_PLATFORM_HAS_WINUWP_API == 0  // Windows UWP does not support getenv
1384         path=getenv(&quot;ICU_DATA&quot;);
1385 #       endif
1386 #   endif
1387 
1388     /* ICU_DATA_DIR may be set as a compile option.
1389      * U_ICU_DATA_DEFAULT_DIR is provided and is set by ICU at compile time
1390      * and is used only when data is built in archive mode eliminating the need
1391      * for ICU_DATA_DIR to be set. U_ICU_DATA_DEFAULT_DIR is set to the installation
1392      * directory of the data dat file. Users should use ICU_DATA_DIR if they want to
1393      * set their own path.
1394      */
1395 #if defined(ICU_DATA_DIR) || defined(U_ICU_DATA_DEFAULT_DIR)
1396     if(path==NULL || *path==0) {
1397 # if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
1398         const char *prefix = getenv(ICU_DATA_DIR_PREFIX_ENV_VAR);
1399 # endif
1400 # ifdef ICU_DATA_DIR
1401         path=ICU_DATA_DIR;
1402 # else
1403         path=U_ICU_DATA_DEFAULT_DIR;
1404 # endif
1405 # if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
1406         if (prefix != NULL) {
1407             snprintf(datadir_path_buffer, PATH_MAX, &quot;%s%s&quot;, prefix, path);
1408             path=datadir_path_buffer;
1409         }
1410 # endif
1411     }
1412 #endif
1413 
1414 #if U_PLATFORM_HAS_WINUWP_API != 0  &amp;&amp; defined(ICU_DATA_DIR_WINDOWS)
1415     char datadir_path_buffer[MAX_PATH];
1416     if (getIcuDataDirectoryUnderWindowsDirectory(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer))) {
1417         path = datadir_path_buffer;
1418     }
1419 #endif
1420 
1421     if(path==NULL) {
1422         /* It looks really bad, set it to something. */
1423         path = &quot;&quot;;
1424     }
1425 
1426     u_setDataDirectory(path);
1427     return;
1428 }
1429 
1430 U_CAPI const char * U_EXPORT2
1431 u_getDataDirectory(void) {
1432     umtx_initOnce(gDataDirInitOnce, &amp;dataDirectoryInitFn);
1433     return gDataDirectory;
1434 }
1435 
1436 static void setTimeZoneFilesDir(const char *path, UErrorCode &amp;status) {
1437     if (U_FAILURE(status)) {
1438         return;
1439     }
1440     gTimeZoneFilesDirectory-&gt;clear();
1441     gTimeZoneFilesDirectory-&gt;append(path, status);
1442 #if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)
1443     char *p = gTimeZoneFilesDirectory-&gt;data();
1444     while ((p = uprv_strchr(p, U_FILE_ALT_SEP_CHAR)) != NULL) {
1445         *p = U_FILE_SEP_CHAR;
1446     }
1447 #endif
1448 }
1449 
1450 #define TO_STRING(x) TO_STRING_2(x)
1451 #define TO_STRING_2(x) #x
1452 
1453 static void U_CALLCONV TimeZoneDataDirInitFn(UErrorCode &amp;status) {
1454     U_ASSERT(gTimeZoneFilesDirectory == NULL);
1455     ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
1456     gTimeZoneFilesDirectory = new CharString();
1457     if (gTimeZoneFilesDirectory == NULL) {
1458         status = U_MEMORY_ALLOCATION_ERROR;
1459         return;
1460     }
1461 
1462     const char *dir = &quot;&quot;;
1463 
1464 #if U_PLATFORM_HAS_WINUWP_API != 0
1465     // The UWP version does not support the environment variable setting, but can possibly pick them up from the Windows directory.
1466     char datadir_path_buffer[MAX_PATH];
1467     if (getIcuDataDirectoryUnderWindowsDirectory(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer))) {
1468         dir = datadir_path_buffer;
1469     }
1470 #else
1471     dir = getenv(&quot;ICU_TIMEZONE_FILES_DIR&quot;);
1472 #endif // U_PLATFORM_HAS_WINUWP_API
1473 
1474 #if defined(U_TIMEZONE_FILES_DIR)
1475     if (dir == NULL) {
1476         // Build time configuration setting.
1477         dir = TO_STRING(U_TIMEZONE_FILES_DIR);
1478     }
1479 #endif
1480 
1481     if (dir == NULL) {
1482         dir = &quot;&quot;;
1483     }
1484 
1485     setTimeZoneFilesDir(dir, status);
1486 }
1487 
1488 
1489 U_CAPI const char * U_EXPORT2
1490 u_getTimeZoneFilesDirectory(UErrorCode *status) {
1491     umtx_initOnce(gTimeZoneFilesInitOnce, &amp;TimeZoneDataDirInitFn, *status);
1492     return U_SUCCESS(*status) ? gTimeZoneFilesDirectory-&gt;data() : &quot;&quot;;
1493 }
1494 
1495 U_CAPI void U_EXPORT2
1496 u_setTimeZoneFilesDirectory(const char *path, UErrorCode *status) {
1497     umtx_initOnce(gTimeZoneFilesInitOnce, &amp;TimeZoneDataDirInitFn, *status);
1498     setTimeZoneFilesDir(path, *status);
1499 
1500     // Note: this function does some extra churn, first setting based on the
1501     //       environment, then immediately replacing with the value passed in.
1502     //       The logic is simpler that way, and performance shouldn&#39;t be an issue.
1503 }
1504 
1505 
1506 #if U_POSIX_LOCALE
1507 /* A helper function used by uprv_getPOSIXIDForDefaultLocale and
1508  * uprv_getPOSIXIDForDefaultCodepage. Returns the posix locale id for
1509  * LC_CTYPE and LC_MESSAGES. It doesn&#39;t support other locale categories.
1510  */
1511 static const char *uprv_getPOSIXIDForCategory(int category)
1512 {
1513     const char* posixID = NULL;
1514     if (category == LC_MESSAGES || category == LC_CTYPE) {
1515         /*
1516         * On Solaris two different calls to setlocale can result in
1517         * different values. Only get this value once.
1518         *
1519         * We must check this first because an application can set this.
1520         *
1521         * LC_ALL can&#39;t be used because it&#39;s platform dependent. The LANG
1522         * environment variable seems to affect LC_CTYPE variable by default.
1523         * Here is what setlocale(LC_ALL, NULL) can return.
1524         * HPUX can return &#39;C C C C C C C&#39;
1525         * Solaris can return /en_US/C/C/C/C/C on the second try.
1526         * Linux can return LC_CTYPE=C;LC_NUMERIC=C;...
1527         *
1528         * The default codepage detection also needs to use LC_CTYPE.
1529         *
1530         * Do not call setlocale(LC_*, &quot;&quot;)! Using an empty string instead
1531         * of NULL, will modify the libc behavior.
1532         */
1533         posixID = setlocale(category, NULL);
1534         if ((posixID == 0)
1535             || (uprv_strcmp(&quot;C&quot;, posixID) == 0)
1536             || (uprv_strcmp(&quot;POSIX&quot;, posixID) == 0))
1537         {
1538             /* Maybe we got some garbage.  Try something more reasonable */
1539             posixID = getenv(&quot;LC_ALL&quot;);
1540             /* Solaris speaks POSIX -  See IEEE Std 1003.1-2008
1541              * This is needed to properly handle empty env. variables
1542              */
1543 #if U_PLATFORM == U_PF_SOLARIS
1544             if ((posixID == 0) || (posixID[0] == &#39;\0&#39;)) {
1545                 posixID = getenv(category == LC_MESSAGES ? &quot;LC_MESSAGES&quot; : &quot;LC_CTYPE&quot;);
1546                 if ((posixID == 0) || (posixID[0] == &#39;\0&#39;)) {
1547 #else
1548             if (posixID == 0) {
1549                 posixID = getenv(category == LC_MESSAGES ? &quot;LC_MESSAGES&quot; : &quot;LC_CTYPE&quot;);
1550                 if (posixID == 0) {
1551 #endif
1552                     posixID = getenv(&quot;LANG&quot;);
1553                 }
1554             }
1555         }
1556     }
1557     if ((posixID==0)
1558         || (uprv_strcmp(&quot;C&quot;, posixID) == 0)
1559         || (uprv_strcmp(&quot;POSIX&quot;, posixID) == 0))
1560     {
1561         /* Nothing worked.  Give it a nice POSIX default value. */
1562         posixID = &quot;en_US_POSIX&quot;;
1563     }
1564     return posixID;
1565 }
1566 
1567 /* Return just the POSIX id for the default locale, whatever happens to be in
1568  * it. It gets the value from LC_MESSAGES and indirectly from LC_ALL and LANG.
1569  */
1570 static const char *uprv_getPOSIXIDForDefaultLocale(void)
1571 {
1572     static const char* posixID = NULL;
1573     if (posixID == 0) {
1574         posixID = uprv_getPOSIXIDForCategory(LC_MESSAGES);
1575     }
1576     return posixID;
1577 }
1578 
1579 #if !U_CHARSET_IS_UTF8
1580 /* Return just the POSIX id for the default codepage, whatever happens to be in
1581  * it. It gets the value from LC_CTYPE and indirectly from LC_ALL and LANG.
1582  */
1583 static const char *uprv_getPOSIXIDForDefaultCodepage(void)
1584 {
1585     static const char* posixID = NULL;
1586     if (posixID == 0) {
1587         posixID = uprv_getPOSIXIDForCategory(LC_CTYPE);
1588     }
1589     return posixID;
1590 }
1591 #endif
1592 #endif
1593 
1594 /* NOTE: The caller should handle thread safety */
1595 U_CAPI const char* U_EXPORT2
1596 uprv_getDefaultLocaleID()
1597 {
1598 #if U_POSIX_LOCALE
1599 /*
1600   Note that:  (a &#39;!&#39; means the ID is improper somehow)
1601      LC_ALL  ----&gt;     default_loc          codepage
1602 --------------------------------------------------------
1603      ab.CD             ab                   CD
1604      ab@CD             ab__CD               -
1605      ab@CD.EF          ab__CD               EF
1606 
1607      ab_CD.EF@GH       ab_CD_GH             EF
1608 
1609 Some &#39;improper&#39; ways to do the same as above:
1610   !  ab_CD@GH.EF       ab_CD_GH             EF
1611   !  ab_CD.EF@GH.IJ    ab_CD_GH             EF
1612   !  ab_CD@ZZ.EF@GH.IJ ab_CD_GH             EF
1613 
1614      _CD@GH            _CD_GH               -
1615      _CD.EF@GH         _CD_GH               EF
1616 
1617 The variant cannot have dots in it.
1618 The &#39;rightmost&#39; variant (@xxx) wins.
1619 The leftmost codepage (.xxx) wins.
1620 */
1621     const char* posixID = uprv_getPOSIXIDForDefaultLocale();
1622 
1623     /* Format: (no spaces)
1624     ll [ _CC ] [ . MM ] [ @ VV]
1625 
1626       l = lang, C = ctry, M = charmap, V = variant
1627     */
1628 
1629     if (gCorrectedPOSIXLocale != nullptr) {
1630         return gCorrectedPOSIXLocale;
1631     }
1632 
1633     // Copy the ID into owned memory.
1634     // Over-allocate in case we replace &quot;@&quot; with &quot;__&quot;.
1635     char *correctedPOSIXLocale = static_cast&lt;char *&gt;(uprv_malloc(uprv_strlen(posixID) + 1 + 1));
1636     if (correctedPOSIXLocale == nullptr) {
1637         return nullptr;
1638     }
1639     uprv_strcpy(correctedPOSIXLocale, posixID);
1640 
1641     char *limit;
1642     if ((limit = uprv_strchr(correctedPOSIXLocale, &#39;.&#39;)) != nullptr) {
1643         *limit = 0;
1644         if ((limit = uprv_strchr(correctedPOSIXLocale, &#39;@&#39;)) != nullptr) {
1645             *limit = 0;
1646         }
1647     }
1648 
1649     /* Note that we scan the *uncorrected* ID. */
1650     const char *p;
1651     if ((p = uprv_strrchr(posixID, &#39;@&#39;)) != nullptr) {
1652         p++;
1653 
1654         /* Take care of any special cases here.. */
1655         if (!uprv_strcmp(p, &quot;nynorsk&quot;)) {
1656             p = &quot;NY&quot;;
1657             /* Don&#39;t worry about no__NY. In practice, it won&#39;t appear. */
1658         }
1659 
1660         if (uprv_strchr(correctedPOSIXLocale,&#39;_&#39;) == nullptr) {
1661             uprv_strcat(correctedPOSIXLocale, &quot;__&quot;); /* aa@b -&gt; aa__b (note this can make the new locale 1 char longer) */
1662         }
1663         else {
1664             uprv_strcat(correctedPOSIXLocale, &quot;_&quot;); /* aa_CC@b -&gt; aa_CC_b */
1665         }
1666 
1667         const char *q;
1668         if ((q = uprv_strchr(p, &#39;.&#39;)) != nullptr) {
1669             /* How big will the resulting string be? */
1670             int32_t len = (int32_t)(uprv_strlen(correctedPOSIXLocale) + (q-p));
1671             uprv_strncat(correctedPOSIXLocale, p, q-p);
1672             correctedPOSIXLocale[len] = 0;
1673         }
1674         else {
1675             /* Anything following the @ sign */
1676             uprv_strcat(correctedPOSIXLocale, p);
1677         }
1678 
1679         /* Should there be a map from &#39;no@nynorsk&#39; -&gt; no_NO_NY here?
1680          * How about &#39;russian&#39; -&gt; &#39;ru&#39;?
1681          * Many of the other locales using ISO codes will be handled by the
1682          * canonicalization functions in uloc_getDefault.
1683          */
1684     }
1685 
1686     if (gCorrectedPOSIXLocale == nullptr) {
1687         gCorrectedPOSIXLocale = correctedPOSIXLocale;
1688         gCorrectedPOSIXLocaleHeapAllocated = true;
1689         ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
1690         correctedPOSIXLocale = nullptr;
1691     }
1692     posixID = gCorrectedPOSIXLocale;
1693 
1694     if (correctedPOSIXLocale != nullptr) {  /* Was already set - clean up. */
1695         uprv_free(correctedPOSIXLocale);
1696     }
1697 
1698     return posixID;
1699 
1700 #elif U_PLATFORM_USES_ONLY_WIN32_API
1701 #define POSIX_LOCALE_CAPACITY 64
1702     UErrorCode status = U_ZERO_ERROR;
1703     char *correctedPOSIXLocale = nullptr;
1704 
1705     // If we have already figured this out just use the cached value
1706     if (gCorrectedPOSIXLocale != nullptr) {
1707         return gCorrectedPOSIXLocale;
1708     }
1709 
1710     // No cached value, need to determine the current value
1711     static WCHAR windowsLocale[LOCALE_NAME_MAX_LENGTH] = {};
1712     int length = GetLocaleInfoEx(LOCALE_NAME_USER_DEFAULT, LOCALE_SNAME, windowsLocale, LOCALE_NAME_MAX_LENGTH);
1713 
1714     // Now we should have a Windows locale name that needs converted to the POSIX style.
1715     if (length &gt; 0) // If length is 0, then the GetLocaleInfoEx failed.
1716     {
1717         // First we need to go from UTF-16 to char (and also convert from _ to - while we&#39;re at it.)
1718         char modifiedWindowsLocale[LOCALE_NAME_MAX_LENGTH] = {};
1719 
1720         int32_t i;
1721         for (i = 0; i &lt; UPRV_LENGTHOF(modifiedWindowsLocale); i++)
1722         {
1723             if (windowsLocale[i] == &#39;_&#39;)
1724             {
1725                 modifiedWindowsLocale[i] = &#39;-&#39;;
1726             }
1727             else
1728             {
1729                 modifiedWindowsLocale[i] = static_cast&lt;char&gt;(windowsLocale[i]);
1730             }
1731 
1732             if (modifiedWindowsLocale[i] == &#39;\0&#39;)
1733             {
1734                 break;
1735             }
1736         }
1737 
1738         if (i &gt;= UPRV_LENGTHOF(modifiedWindowsLocale))
1739         {
1740             // Ran out of room, can&#39;t really happen, maybe we&#39;ll be lucky about a matching
1741             // locale when tags are dropped
1742             modifiedWindowsLocale[UPRV_LENGTHOF(modifiedWindowsLocale) - 1] = &#39;\0&#39;;
1743         }
1744 
1745         // Now normalize the resulting name
1746         correctedPOSIXLocale = static_cast&lt;char *&gt;(uprv_malloc(POSIX_LOCALE_CAPACITY + 1));
1747         /* TODO: Should we just exit on memory allocation failure? */
1748         if (correctedPOSIXLocale)
1749         {
1750             int32_t posixLen = uloc_canonicalize(modifiedWindowsLocale, correctedPOSIXLocale, POSIX_LOCALE_CAPACITY, &amp;status);
1751             if (U_SUCCESS(status))
1752             {
1753                 *(correctedPOSIXLocale + posixLen) = 0;
1754                 gCorrectedPOSIXLocale = correctedPOSIXLocale;
1755                 gCorrectedPOSIXLocaleHeapAllocated = true;
1756                 ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
1757             }
1758             else
1759             {
1760                 uprv_free(correctedPOSIXLocale);
1761             }
1762         }
1763     }
1764 
1765     // If unable to find a locale we can agree upon, use en-US by default
1766     if (gCorrectedPOSIXLocale == nullptr) {
1767         gCorrectedPOSIXLocale = &quot;en_US&quot;;
1768     }
1769     return gCorrectedPOSIXLocale;
1770 
1771 #elif U_PLATFORM == U_PF_OS400
1772     /* locales are process scoped and are by definition thread safe */
1773     static char correctedLocale[64];
1774     const  char *localeID = getenv(&quot;LC_ALL&quot;);
1775            char *p;
1776 
1777     if (localeID == NULL)
1778         localeID = getenv(&quot;LANG&quot;);
1779     if (localeID == NULL)
1780         localeID = setlocale(LC_ALL, NULL);
1781     /* Make sure we have something... */
1782     if (localeID == NULL)
1783         return &quot;en_US_POSIX&quot;;
1784 
1785     /* Extract the locale name from the path. */
1786     if((p = uprv_strrchr(localeID, &#39;/&#39;)) != NULL)
1787     {
1788         /* Increment p to start of locale name. */
1789         p++;
1790         localeID = p;
1791     }
1792 
1793     /* Copy to work location. */
1794     uprv_strcpy(correctedLocale, localeID);
1795 
1796     /* Strip off the &#39;.locale&#39; extension. */
1797     if((p = uprv_strchr(correctedLocale, &#39;.&#39;)) != NULL) {
1798         *p = 0;
1799     }
1800 
1801     /* Upper case the locale name. */
1802     T_CString_toUpperCase(correctedLocale);
1803 
1804     /* See if we are using the POSIX locale.  Any of the
1805     * following are equivalent and use the same QLGPGCMA
1806     * (POSIX) locale.
1807     * QLGPGCMA2 means UCS2
1808     * QLGPGCMA_4 means UTF-32
1809     * QLGPGCMA_8 means UTF-8
1810     */
1811     if ((uprv_strcmp(&quot;C&quot;, correctedLocale) == 0) ||
1812         (uprv_strcmp(&quot;POSIX&quot;, correctedLocale) == 0) ||
1813         (uprv_strncmp(&quot;QLGPGCMA&quot;, correctedLocale, 8) == 0))
1814     {
1815         uprv_strcpy(correctedLocale, &quot;en_US_POSIX&quot;);
1816     }
1817     else
1818     {
1819         int16_t LocaleLen;
1820 
1821         /* Lower case the lang portion. */
1822         for(p = correctedLocale; *p != 0 &amp;&amp; *p != &#39;_&#39;; p++)
1823         {
1824             *p = uprv_tolower(*p);
1825         }
1826 
1827         /* Adjust for Euro.  After &#39;_E&#39; add &#39;URO&#39;. */
1828         LocaleLen = uprv_strlen(correctedLocale);
1829         if (correctedLocale[LocaleLen - 2] == &#39;_&#39; &amp;&amp;
1830             correctedLocale[LocaleLen - 1] == &#39;E&#39;)
1831         {
1832             uprv_strcat(correctedLocale, &quot;URO&quot;);
1833         }
1834 
1835         /* If using Lotus-based locale then convert to
1836          * equivalent non Lotus.
1837          */
1838         else if (correctedLocale[LocaleLen - 2] == &#39;_&#39; &amp;&amp;
1839             correctedLocale[LocaleLen - 1] == &#39;L&#39;)
1840         {
1841             correctedLocale[LocaleLen - 2] = 0;
1842         }
1843 
1844         /* There are separate simplified and traditional
1845          * locales called zh_HK_S and zh_HK_T.
1846          */
1847         else if (uprv_strncmp(correctedLocale, &quot;zh_HK&quot;, 5) == 0)
1848         {
1849             uprv_strcpy(correctedLocale, &quot;zh_HK&quot;);
1850         }
1851 
1852         /* A special zh_CN_GBK locale...
1853         */
1854         else if (uprv_strcmp(correctedLocale, &quot;zh_CN_GBK&quot;) == 0)
1855         {
1856             uprv_strcpy(correctedLocale, &quot;zh_CN&quot;);
1857         }
1858 
1859     }
1860 
1861     return correctedLocale;
1862 #endif
1863 
1864 }
1865 
1866 #if !U_CHARSET_IS_UTF8
1867 #if U_POSIX_LOCALE
1868 /*
1869 Due to various platform differences, one platform may specify a charset,
1870 when they really mean a different charset. Remap the names so that they are
1871 compatible with ICU. Only conflicting/ambiguous aliases should be resolved
1872 here. Before adding anything to this function, please consider adding unique
1873 names to the ICU alias table in the data directory.
1874 */
1875 static const char*
1876 remapPlatformDependentCodepage(const char *locale, const char *name) {
1877     if (locale != NULL &amp;&amp; *locale == 0) {
1878         /* Make sure that an empty locale is handled the same way. */
1879         locale = NULL;
1880     }
1881     if (name == NULL) {
1882         return NULL;
1883     }
1884 #if U_PLATFORM == U_PF_AIX
1885     if (uprv_strcmp(name, &quot;IBM-943&quot;) == 0) {
1886         /* Use the ASCII compatible ibm-943 */
1887         name = &quot;Shift-JIS&quot;;
1888     }
1889     else if (uprv_strcmp(name, &quot;IBM-1252&quot;) == 0) {
1890         /* Use the windows-1252 that contains the Euro */
1891         name = &quot;IBM-5348&quot;;
1892     }
1893 #elif U_PLATFORM == U_PF_SOLARIS
1894     if (locale != NULL &amp;&amp; uprv_strcmp(name, &quot;EUC&quot;) == 0) {
1895         /* Solaris underspecifies the &quot;EUC&quot; name. */
1896         if (uprv_strcmp(locale, &quot;zh_CN&quot;) == 0) {
1897             name = &quot;EUC-CN&quot;;
1898         }
1899         else if (uprv_strcmp(locale, &quot;zh_TW&quot;) == 0) {
1900             name = &quot;EUC-TW&quot;;
1901         }
1902         else if (uprv_strcmp(locale, &quot;ko_KR&quot;) == 0) {
1903             name = &quot;EUC-KR&quot;;
1904         }
1905     }
1906     else if (uprv_strcmp(name, &quot;eucJP&quot;) == 0) {
1907         /*
1908         ibm-954 is the best match.
1909         ibm-33722 is the default for eucJP (similar to Windows).
1910         */
1911         name = &quot;eucjis&quot;;
1912     }
1913     else if (uprv_strcmp(name, &quot;646&quot;) == 0) {
1914         /*
1915          * The default codepage given by Solaris is 646 but the C library routines treat it as if it was
1916          * ISO-8859-1 instead of US-ASCII(646).
1917          */
1918         name = &quot;ISO-8859-1&quot;;
1919     }
1920 #elif U_PLATFORM_IS_DARWIN_BASED
1921     if (locale == NULL &amp;&amp; *name == 0) {
1922         /*
1923         No locale was specified, and an empty name was passed in.
1924         This usually indicates that nl_langinfo didn&#39;t return valid information.
1925         Mac OS X uses UTF-8 by default (especially the locale data and console).
1926         */
1927         name = &quot;UTF-8&quot;;
1928     }
1929     else if (uprv_strcmp(name, &quot;CP949&quot;) == 0) {
1930         /* Remap CP949 to a similar codepage to avoid issues with backslash and won symbol. */
1931         name = &quot;EUC-KR&quot;;
1932     }
1933     else if (locale != NULL &amp;&amp; uprv_strcmp(locale, &quot;en_US_POSIX&quot;) != 0 &amp;&amp; uprv_strcmp(name, &quot;US-ASCII&quot;) == 0) {
1934         /*
1935          * For non C/POSIX locale, default the code page to UTF-8 instead of US-ASCII.
1936          */
1937         name = &quot;UTF-8&quot;;
1938     }
1939 #elif U_PLATFORM == U_PF_BSD
1940     if (uprv_strcmp(name, &quot;CP949&quot;) == 0) {
1941         /* Remap CP949 to a similar codepage to avoid issues with backslash and won symbol. */
1942         name = &quot;EUC-KR&quot;;
1943     }
1944 #elif U_PLATFORM == U_PF_HPUX
1945     if (locale != NULL &amp;&amp; uprv_strcmp(locale, &quot;zh_HK&quot;) == 0 &amp;&amp; uprv_strcmp(name, &quot;big5&quot;) == 0) {
1946         /* HP decided to extend big5 as hkbig5 even though it&#39;s not compatible :-( */
1947         /* zh_TW.big5 is not the same charset as zh_HK.big5! */
1948         name = &quot;hkbig5&quot;;
1949     }
1950     else if (uprv_strcmp(name, &quot;eucJP&quot;) == 0) {
1951         /*
1952         ibm-1350 is the best match, but unavailable.
1953         ibm-954 is mostly a superset of ibm-1350.
1954         ibm-33722 is the default for eucJP (similar to Windows).
1955         */
1956         name = &quot;eucjis&quot;;
1957     }
1958 #elif U_PLATFORM == U_PF_LINUX
1959     if (locale != NULL &amp;&amp; uprv_strcmp(name, &quot;euc&quot;) == 0) {
1960         /* Linux underspecifies the &quot;EUC&quot; name. */
1961         if (uprv_strcmp(locale, &quot;korean&quot;) == 0) {
1962             name = &quot;EUC-KR&quot;;
1963         }
1964         else if (uprv_strcmp(locale, &quot;japanese&quot;) == 0) {
1965             /* See comment below about eucJP */
1966             name = &quot;eucjis&quot;;
1967         }
1968     }
1969     else if (uprv_strcmp(name, &quot;eucjp&quot;) == 0) {
1970         /*
1971         ibm-1350 is the best match, but unavailable.
1972         ibm-954 is mostly a superset of ibm-1350.
1973         ibm-33722 is the default for eucJP (similar to Windows).
1974         */
1975         name = &quot;eucjis&quot;;
1976     }
1977     else if (locale != NULL &amp;&amp; uprv_strcmp(locale, &quot;en_US_POSIX&quot;) != 0 &amp;&amp;
1978             (uprv_strcmp(name, &quot;ANSI_X3.4-1968&quot;) == 0 || uprv_strcmp(name, &quot;US-ASCII&quot;) == 0)) {
1979         /*
1980          * For non C/POSIX locale, default the code page to UTF-8 instead of US-ASCII.
1981          */
1982         name = &quot;UTF-8&quot;;
1983     }
1984     /*
1985      * Linux returns ANSI_X3.4-1968 for C/POSIX, but the call site takes care of
1986      * it by falling back to &#39;US-ASCII&#39; when NULL is returned from this
1987      * function. So, we don&#39;t have to worry about it here.
1988      */
1989 #endif
1990     /* return NULL when &quot;&quot; is passed in */
1991     if (*name == 0) {
1992         name = NULL;
1993     }
1994     return name;
1995 }
1996 
1997 static const char*
1998 getCodepageFromPOSIXID(const char *localeName, char * buffer, int32_t buffCapacity)
1999 {
2000     char localeBuf[100];
2001     const char *name = NULL;
2002     char *variant = NULL;
2003 
2004     if (localeName != NULL &amp;&amp; (name = (uprv_strchr(localeName, &#39;.&#39;))) != NULL) {
2005         size_t localeCapacity = uprv_min(sizeof(localeBuf), (name-localeName)+1);
2006         uprv_strncpy(localeBuf, localeName, localeCapacity);
2007         localeBuf[localeCapacity-1] = 0; /* ensure NULL termination */
2008         name = uprv_strncpy(buffer, name+1, buffCapacity);
2009         buffer[buffCapacity-1] = 0; /* ensure NULL termination */
2010         if ((variant = const_cast&lt;char *&gt;(uprv_strchr(name, &#39;@&#39;))) != NULL) {
2011             *variant = 0;
2012         }
2013         name = remapPlatformDependentCodepage(localeBuf, name);
2014     }
2015     return name;
2016 }
2017 #endif
2018 
2019 static const char*
2020 int_getDefaultCodepage()
2021 {
2022 #if U_PLATFORM == U_PF_OS400
2023     uint32_t ccsid = 37; /* Default to ibm-37 */
2024     static char codepage[64];
2025     Qwc_JOBI0400_t jobinfo;
2026     Qus_EC_t error = { sizeof(Qus_EC_t) }; /* SPI error code */
2027 
2028     EPT_CALL(QUSRJOBI)(&amp;jobinfo, sizeof(jobinfo), &quot;JOBI0400&quot;,
2029         &quot;*                         &quot;, &quot;                &quot;, &amp;error);
2030 
2031     if (error.Bytes_Available == 0) {
2032         if (jobinfo.Coded_Char_Set_ID != 0xFFFF) {
2033             ccsid = (uint32_t)jobinfo.Coded_Char_Set_ID;
2034         }
2035         else if (jobinfo.Default_Coded_Char_Set_Id != 0xFFFF) {
2036             ccsid = (uint32_t)jobinfo.Default_Coded_Char_Set_Id;
2037         }
2038         /* else use the default */
2039     }
2040     sprintf(codepage,&quot;ibm-%d&quot;, ccsid);
2041     return codepage;
2042 
2043 #elif U_PLATFORM == U_PF_OS390
2044     static char codepage[64];
2045 
2046     strncpy(codepage, nl_langinfo(CODESET),63-strlen(UCNV_SWAP_LFNL_OPTION_STRING));
2047     strcat(codepage,UCNV_SWAP_LFNL_OPTION_STRING);
2048     codepage[63] = 0; /* NULL terminate */
2049 
2050     return codepage;
2051 
2052 #elif U_PLATFORM_USES_ONLY_WIN32_API
2053     static char codepage[64];
2054     DWORD codepageNumber = 0;
2055 
2056 #if U_PLATFORM_HAS_WINUWP_API &gt; 0
2057     // UWP doesn&#39;t have a direct API to get the default ACP as Microsoft would rather
2058     // have folks use Unicode than a &quot;system&quot; code page, however this is the same
2059     // codepage as the system default locale codepage.  (FWIW, the system locale is
2060     // ONLY used for codepage, it should never be used for anything else)
2061     GetLocaleInfoEx(LOCALE_NAME_SYSTEM_DEFAULT, LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
2062         (LPWSTR)&amp;codepageNumber, sizeof(codepageNumber) / sizeof(WCHAR));
2063 #else
2064     // Win32 apps can call GetACP
2065     codepageNumber = GetACP();
2066 #endif
2067     // Special case for UTF-8
2068     if (codepageNumber == 65001)
2069     {
2070         return &quot;UTF-8&quot;;
2071     }
2072     // Windows codepages can look like windows-1252, so format the found number
2073     // the numbers are eclectic, however all valid system code pages, besides UTF-8
2074     // are between 3 and 19999
2075     if (codepageNumber &gt; 0 &amp;&amp; codepageNumber &lt; 20000)
2076     {
2077         sprintf(codepage, &quot;windows-%ld&quot;, codepageNumber);
2078         return codepage;
2079     }
2080     // If the codepage number call failed then return UTF-8
2081     return &quot;UTF-8&quot;;
2082 
2083 #elif U_POSIX_LOCALE
2084     static char codesetName[100];
2085     const char *localeName = NULL;
2086     const char *name = NULL;
2087 
2088     localeName = uprv_getPOSIXIDForDefaultCodepage();
2089     uprv_memset(codesetName, 0, sizeof(codesetName));
2090     /* On Solaris nl_langinfo returns C locale values unless setlocale
2091      * was called earlier.
2092      */
2093 #if (U_HAVE_NL_LANGINFO_CODESET &amp;&amp; U_PLATFORM != U_PF_SOLARIS)
2094     /* When available, check nl_langinfo first because it usually gives more
2095        useful names. It depends on LC_CTYPE.
2096        nl_langinfo may use the same buffer as setlocale. */
2097     {
2098         const char *codeset = nl_langinfo(U_NL_LANGINFO_CODESET);
2099 #if U_PLATFORM_IS_DARWIN_BASED || U_PLATFORM_IS_LINUX_BASED
2100         /*
2101          * On Linux and MacOSX, ensure that default codepage for non C/POSIX locale is UTF-8
2102          * instead of ASCII.
2103          */
2104         if (uprv_strcmp(localeName, &quot;en_US_POSIX&quot;) != 0) {
2105             codeset = remapPlatformDependentCodepage(localeName, codeset);
2106         } else
2107 #endif
2108         {
2109             codeset = remapPlatformDependentCodepage(NULL, codeset);
2110         }
2111 
2112         if (codeset != NULL) {
2113             uprv_strncpy(codesetName, codeset, sizeof(codesetName));
2114             codesetName[sizeof(codesetName)-1] = 0;
2115             return codesetName;
2116         }
2117     }
2118 #endif
2119 
2120     /* Use setlocale in a nice way, and then check some environment variables.
2121        Maybe the application used setlocale already.
2122     */
2123     uprv_memset(codesetName, 0, sizeof(codesetName));
2124     name = getCodepageFromPOSIXID(localeName, codesetName, sizeof(codesetName));
2125     if (name) {
2126         /* if we can find the codeset name from setlocale, return that. */
2127         return name;
2128     }
2129 
2130     if (*codesetName == 0)
2131     {
2132         /* Everything failed. Return US ASCII (ISO 646). */
2133         (void)uprv_strcpy(codesetName, &quot;US-ASCII&quot;);
2134     }
2135     return codesetName;
2136 #else
2137     return &quot;US-ASCII&quot;;
2138 #endif
2139 }
2140 
2141 
2142 U_CAPI const char*  U_EXPORT2
2143 uprv_getDefaultCodepage()
2144 {
2145     static char const  *name = NULL;
2146     umtx_lock(NULL);
2147     if (name == NULL) {
2148         name = int_getDefaultCodepage();
2149     }
2150     umtx_unlock(NULL);
2151     return name;
2152 }
2153 #endif  /* !U_CHARSET_IS_UTF8 */
2154 
2155 
2156 /* end of platform-specific implementation -------------- */
2157 
2158 /* version handling --------------------------------------------------------- */
2159 
2160 U_CAPI void U_EXPORT2
2161 u_versionFromString(UVersionInfo versionArray, const char *versionString) {
2162     char *end;
2163     uint16_t part=0;
2164 
2165     if(versionArray==NULL) {
2166         return;
2167     }
2168 
2169     if(versionString!=NULL) {
2170         for(;;) {
2171             versionArray[part]=(uint8_t)uprv_strtoul(versionString, &amp;end, 10);
2172             if(end==versionString || ++part==U_MAX_VERSION_LENGTH || *end!=U_VERSION_DELIMITER) {
2173                 break;
2174             }
2175             versionString=end+1;
2176         }
2177     }
2178 
2179     while(part&lt;U_MAX_VERSION_LENGTH) {
2180         versionArray[part++]=0;
2181     }
2182 }
2183 
2184 U_CAPI void U_EXPORT2
2185 u_versionFromUString(UVersionInfo versionArray, const UChar *versionString) {
2186     if(versionArray!=NULL &amp;&amp; versionString!=NULL) {
2187         char versionChars[U_MAX_VERSION_STRING_LENGTH+1];
2188         int32_t len = u_strlen(versionString);
2189         if(len&gt;U_MAX_VERSION_STRING_LENGTH) {
2190             len = U_MAX_VERSION_STRING_LENGTH;
2191         }
2192         u_UCharsToChars(versionString, versionChars, len);
2193         versionChars[len]=0;
2194         u_versionFromString(versionArray, versionChars);
2195     }
2196 }
2197 
2198 U_CAPI void U_EXPORT2
2199 u_versionToString(const UVersionInfo versionArray, char *versionString) {
2200     uint16_t count, part;
2201     uint8_t field;
2202 
2203     if(versionString==NULL) {
2204         return;
2205     }
2206 
2207     if(versionArray==NULL) {
2208         versionString[0]=0;
2209         return;
2210     }
2211 
2212     /* count how many fields need to be written */
2213     for(count=4; count&gt;0 &amp;&amp; versionArray[count-1]==0; --count) {
2214     }
2215 
2216     if(count &lt;= 1) {
2217         count = 2;
2218     }
2219 
2220     /* write the first part */
2221     /* write the decimal field value */
2222     field=versionArray[0];
2223     if(field&gt;=100) {
2224         *versionString++=(char)(&#39;0&#39;+field/100);
2225         field%=100;
2226     }
2227     if(field&gt;=10) {
2228         *versionString++=(char)(&#39;0&#39;+field/10);
2229         field%=10;
2230     }
2231     *versionString++=(char)(&#39;0&#39;+field);
2232 
2233     /* write the following parts */
2234     for(part=1; part&lt;count; ++part) {
2235         /* write a dot first */
2236         *versionString++=U_VERSION_DELIMITER;
2237 
2238         /* write the decimal field value */
2239         field=versionArray[part];
2240         if(field&gt;=100) {
2241             *versionString++=(char)(&#39;0&#39;+field/100);
2242             field%=100;
2243         }
2244         if(field&gt;=10) {
2245             *versionString++=(char)(&#39;0&#39;+field/10);
2246             field%=10;
2247         }
2248         *versionString++=(char)(&#39;0&#39;+field);
2249     }
2250 
2251     /* NUL-terminate */
2252     *versionString=0;
2253 }
2254 
2255 U_CAPI void U_EXPORT2
2256 u_getVersion(UVersionInfo versionArray) {
2257     (void)copyright;   // Suppress unused variable warning from clang.
2258     u_versionFromString(versionArray, U_ICU_VERSION);
2259 }
2260 
2261 /**
2262  * icucfg.h dependent code
2263  */
2264 
2265 #if U_ENABLE_DYLOAD &amp;&amp; HAVE_DLOPEN &amp;&amp; !U_PLATFORM_USES_ONLY_WIN32_API
2266 
2267 #if HAVE_DLFCN_H
2268 #ifdef __MVS__
2269 #ifndef __SUSV3
2270 #define __SUSV3 1
2271 #endif
2272 #endif
2273 #include &lt;dlfcn.h&gt;
2274 #endif /* HAVE_DLFCN_H */
2275 
2276 U_INTERNAL void * U_EXPORT2
2277 uprv_dl_open(const char *libName, UErrorCode *status) {
2278   void *ret = NULL;
2279   if(U_FAILURE(*status)) return ret;
2280   ret =  dlopen(libName, RTLD_NOW|RTLD_GLOBAL);
2281   if(ret==NULL) {
2282 #ifdef U_TRACE_DYLOAD
2283     printf(&quot;dlerror on dlopen(%s): %s\n&quot;, libName, dlerror());
2284 #endif
2285     *status = U_MISSING_RESOURCE_ERROR;
2286   }
2287   return ret;
2288 }
2289 
2290 U_INTERNAL void U_EXPORT2
2291 uprv_dl_close(void *lib, UErrorCode *status) {
2292   if(U_FAILURE(*status)) return;
2293   dlclose(lib);
2294 }
2295 
2296 U_INTERNAL UVoidFunction* U_EXPORT2
2297 uprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {
2298   union {
2299       UVoidFunction *fp;
2300       void *vp;
2301   } uret;
2302   uret.fp = NULL;
2303   if(U_FAILURE(*status)) return uret.fp;
2304   uret.vp = dlsym(lib, sym);
2305   if(uret.vp == NULL) {
2306 #ifdef U_TRACE_DYLOAD
2307     printf(&quot;dlerror on dlsym(%p,%s): %s\n&quot;, lib,sym, dlerror());
2308 #endif
2309     *status = U_MISSING_RESOURCE_ERROR;
2310   }
2311   return uret.fp;
2312 }
2313 
2314 #elif U_ENABLE_DYLOAD &amp;&amp; U_PLATFORM_USES_ONLY_WIN32_API &amp;&amp; !U_PLATFORM_HAS_WINUWP_API
2315 
2316 /* Windows API implementation. */
2317 // Note: UWP does not expose/allow these APIs, so the UWP version gets the null implementation. */
2318 
2319 U_INTERNAL void * U_EXPORT2
2320 uprv_dl_open(const char *libName, UErrorCode *status) {
2321   HMODULE lib = NULL;
2322 
2323   if(U_FAILURE(*status)) return NULL;
2324 
2325   lib = LoadLibraryA(libName);
2326 
2327   if(lib==NULL) {
2328     *status = U_MISSING_RESOURCE_ERROR;
2329   }
2330 
2331   return (void*)lib;
2332 }
2333 
2334 U_INTERNAL void U_EXPORT2
2335 uprv_dl_close(void *lib, UErrorCode *status) {
2336   HMODULE handle = (HMODULE)lib;
2337   if(U_FAILURE(*status)) return;
2338 
2339   FreeLibrary(handle);
2340 
2341   return;
2342 }
2343 
2344 U_INTERNAL UVoidFunction* U_EXPORT2
2345 uprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {
2346   HMODULE handle = (HMODULE)lib;
2347   UVoidFunction* addr = NULL;
2348 
2349   if(U_FAILURE(*status) || lib==NULL) return NULL;
2350 
2351   addr = (UVoidFunction*)GetProcAddress(handle, sym);
2352 
2353   if(addr==NULL) {
2354     DWORD lastError = GetLastError();
2355     if(lastError == ERROR_PROC_NOT_FOUND) {
2356       *status = U_MISSING_RESOURCE_ERROR;
2357     } else {
2358       *status = U_UNSUPPORTED_ERROR; /* other unknown error. */
2359     }
2360   }
2361 
2362   return addr;
2363 }
2364 
2365 #else
2366 
2367 /* No dynamic loading, null (nonexistent) implementation. */
2368 
2369 U_INTERNAL void * U_EXPORT2
2370 uprv_dl_open(const char *libName, UErrorCode *status) {
2371     (void)libName;
2372     if(U_FAILURE(*status)) return NULL;
2373     *status = U_UNSUPPORTED_ERROR;
2374     return NULL;
2375 }
2376 
2377 U_INTERNAL void U_EXPORT2
2378 uprv_dl_close(void *lib, UErrorCode *status) {
2379     (void)lib;
2380     if(U_FAILURE(*status)) return;
2381     *status = U_UNSUPPORTED_ERROR;
2382     return;
2383 }
2384 
2385 U_INTERNAL UVoidFunction* U_EXPORT2
2386 uprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {
2387   (void)lib;
2388   (void)sym;
2389   if(U_SUCCESS(*status)) {
2390     *status = U_UNSUPPORTED_ERROR;
2391   }
2392   return (UVoidFunction*)NULL;
2393 }
2394 
2395 #endif
2396 
2397 /*
2398  * Hey, Emacs, please set the following:
2399  *
2400  * Local Variables:
2401  * indent-tabs-mode: nil
2402  * End:
2403  *
2404  */
    </pre>
  </body>
</html>