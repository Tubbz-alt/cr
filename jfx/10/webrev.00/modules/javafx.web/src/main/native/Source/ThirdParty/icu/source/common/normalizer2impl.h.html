<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/normalizer2impl.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 *******************************************************************************
  5 *
  6 *   Copyright (C) 2009-2014, International Business Machines
  7 *   Corporation and others.  All Rights Reserved.
  8 *
  9 *******************************************************************************
 10 *   file name:  normalizer2impl.h
 11 *   encoding:   UTF-8
 12 *   tab size:   8 (not used)
 13 *   indentation:4
 14 *
 15 *   created on: 2009nov22
 16 *   created by: Markus W. Scherer
 17 */
 18 
 19 #ifndef __NORMALIZER2IMPL_H__
 20 #define __NORMALIZER2IMPL_H__
 21 
 22 #include &quot;unicode/utypes.h&quot;
 23 
 24 #if !UCONFIG_NO_NORMALIZATION
 25 
 26 #include &quot;unicode/normalizer2.h&quot;
 27 #include &quot;unicode/ucptrie.h&quot;
 28 #include &quot;unicode/unistr.h&quot;
 29 #include &quot;unicode/unorm.h&quot;
 30 #include &quot;unicode/utf.h&quot;
 31 #include &quot;unicode/utf16.h&quot;
 32 #include &quot;mutex.h&quot;
 33 #include &quot;udataswp.h&quot;
 34 #include &quot;uset_imp.h&quot;
 35 
 36 // When the nfc.nrm data is *not* hardcoded into the common library
 37 // (with this constant set to 0),
 38 // then it needs to be built into the data package:
 39 // Add nfc.nrm to icu4c/source/data/Makefile.in DAT_FILES_SHORT
 40 #define NORM2_HARDCODE_NFC_DATA 1
 41 
 42 U_NAMESPACE_BEGIN
 43 
 44 struct CanonIterData;
 45 
 46 class ByteSink;
 47 class Edits;
 48 class InitCanonIterData;
 49 class LcccContext;
 50 
 51 class U_COMMON_API Hangul {
 52 public:
 53     /* Korean Hangul and Jamo constants */
 54     enum {
 55         JAMO_L_BASE=0x1100,     /* &quot;lead&quot; jamo */
 56         JAMO_L_END=0x1112,
 57         JAMO_V_BASE=0x1161,     /* &quot;vowel&quot; jamo */
 58         JAMO_V_END=0x1175,
 59         JAMO_T_BASE=0x11a7,     /* &quot;trail&quot; jamo */
 60         JAMO_T_END=0x11c2,
 61 
 62         HANGUL_BASE=0xac00,
 63         HANGUL_END=0xd7a3,
 64 
 65         JAMO_L_COUNT=19,
 66         JAMO_V_COUNT=21,
 67         JAMO_T_COUNT=28,
 68 
 69         JAMO_VT_COUNT=JAMO_V_COUNT*JAMO_T_COUNT,
 70 
 71         HANGUL_COUNT=JAMO_L_COUNT*JAMO_V_COUNT*JAMO_T_COUNT,
 72         HANGUL_LIMIT=HANGUL_BASE+HANGUL_COUNT
 73     };
 74 
 75     static inline UBool isHangul(UChar32 c) {
 76         return HANGUL_BASE&lt;=c &amp;&amp; c&lt;HANGUL_LIMIT;
 77     }
 78     static inline UBool
 79     isHangulLV(UChar32 c) {
 80         c-=HANGUL_BASE;
 81         return 0&lt;=c &amp;&amp; c&lt;HANGUL_COUNT &amp;&amp; c%JAMO_T_COUNT==0;
 82     }
 83     static inline UBool isJamoL(UChar32 c) {
 84         return (uint32_t)(c-JAMO_L_BASE)&lt;JAMO_L_COUNT;
 85     }
 86     static inline UBool isJamoV(UChar32 c) {
 87         return (uint32_t)(c-JAMO_V_BASE)&lt;JAMO_V_COUNT;
 88     }
 89     static inline UBool isJamoT(UChar32 c) {
 90         int32_t t=c-JAMO_T_BASE;
 91         return 0&lt;t &amp;&amp; t&lt;JAMO_T_COUNT;  // not JAMO_T_BASE itself
 92     }
 93     static UBool isJamo(UChar32 c) {
 94         return JAMO_L_BASE&lt;=c &amp;&amp; c&lt;=JAMO_T_END &amp;&amp;
 95             (c&lt;=JAMO_L_END || (JAMO_V_BASE&lt;=c &amp;&amp; c&lt;=JAMO_V_END) || JAMO_T_BASE&lt;c);
 96     }
 97 
 98     /**
 99      * Decomposes c, which must be a Hangul syllable, into buffer
100      * and returns the length of the decomposition (2 or 3).
101      */
102     static inline int32_t decompose(UChar32 c, UChar buffer[3]) {
103         c-=HANGUL_BASE;
104         UChar32 c2=c%JAMO_T_COUNT;
105         c/=JAMO_T_COUNT;
106         buffer[0]=(UChar)(JAMO_L_BASE+c/JAMO_V_COUNT);
107         buffer[1]=(UChar)(JAMO_V_BASE+c%JAMO_V_COUNT);
108         if(c2==0) {
109             return 2;
110         } else {
111             buffer[2]=(UChar)(JAMO_T_BASE+c2);
112             return 3;
113         }
114     }
115 
116     /**
117      * Decomposes c, which must be a Hangul syllable, into buffer.
118      * This is the raw, not recursive, decomposition. Its length is always 2.
119      */
120     static inline void getRawDecomposition(UChar32 c, UChar buffer[2]) {
121         UChar32 orig=c;
122         c-=HANGUL_BASE;
123         UChar32 c2=c%JAMO_T_COUNT;
124         if(c2==0) {
125             c/=JAMO_T_COUNT;
126             buffer[0]=(UChar)(JAMO_L_BASE+c/JAMO_V_COUNT);
127             buffer[1]=(UChar)(JAMO_V_BASE+c%JAMO_V_COUNT);
128         } else {
129             buffer[0]=(UChar)(orig-c2);  // LV syllable
130             buffer[1]=(UChar)(JAMO_T_BASE+c2);
131         }
132     }
133 private:
134     Hangul();  // no instantiation
135 };
136 
137 class Normalizer2Impl;
138 
139 class U_COMMON_API ReorderingBuffer : public UMemory {
140 public:
141     /** Constructs only; init() should be called. */
142     ReorderingBuffer(const Normalizer2Impl &amp;ni, UnicodeString &amp;dest) :
143         impl(ni), str(dest),
144         start(NULL), reorderStart(NULL), limit(NULL),
145         remainingCapacity(0), lastCC(0) {}
146     /** Constructs, removes the string contents, and initializes for a small initial capacity. */
147     ReorderingBuffer(const Normalizer2Impl &amp;ni, UnicodeString &amp;dest, UErrorCode &amp;errorCode);
148     ~ReorderingBuffer() {
149         if(start!=NULL) {
150             str.releaseBuffer((int32_t)(limit-start));
151         }
152     }
153     UBool init(int32_t destCapacity, UErrorCode &amp;errorCode);
154 
155     UBool isEmpty() const { return start==limit; }
156     int32_t length() const { return (int32_t)(limit-start); }
157     UChar *getStart() { return start; }
158     UChar *getLimit() { return limit; }
159     uint8_t getLastCC() const { return lastCC; }
160 
161     UBool equals(const UChar *start, const UChar *limit) const;
162     UBool equals(const uint8_t *otherStart, const uint8_t *otherLimit) const;
163 
164     UBool append(UChar32 c, uint8_t cc, UErrorCode &amp;errorCode) {
165         return (c&lt;=0xffff) ?
166             appendBMP((UChar)c, cc, errorCode) :
167             appendSupplementary(c, cc, errorCode);
168     }
169     UBool append(const UChar *s, int32_t length, UBool isNFD,
170                  uint8_t leadCC, uint8_t trailCC,
171                  UErrorCode &amp;errorCode);
172     UBool appendBMP(UChar c, uint8_t cc, UErrorCode &amp;errorCode) {
173         if(remainingCapacity==0 &amp;&amp; !resize(1, errorCode)) {
174             return FALSE;
175         }
176         if(lastCC&lt;=cc || cc==0) {
177             *limit++=c;
178             lastCC=cc;
179             if(cc&lt;=1) {
180                 reorderStart=limit;
181             }
182         } else {
183             insert(c, cc);
184         }
185         --remainingCapacity;
186         return TRUE;
187     }
188     UBool appendZeroCC(UChar32 c, UErrorCode &amp;errorCode);
189     UBool appendZeroCC(const UChar *s, const UChar *sLimit, UErrorCode &amp;errorCode);
190     void remove();
191     void removeSuffix(int32_t suffixLength);
192     void setReorderingLimit(UChar *newLimit) {
193         remainingCapacity+=(int32_t)(limit-newLimit);
194         reorderStart=limit=newLimit;
195         lastCC=0;
196     }
197     void copyReorderableSuffixTo(UnicodeString &amp;s) const {
198         s.setTo(ConstChar16Ptr(reorderStart), (int32_t)(limit-reorderStart));
199     }
200 private:
201     /*
202      * TODO: Revisit whether it makes sense to track reorderStart.
203      * It is set to after the last known character with cc&lt;=1,
204      * which stops previousCC() before it reads that character and looks up its cc.
205      * previousCC() is normally only called from insert().
206      * In other words, reorderStart speeds up the insertion of a combining mark
207      * into a multi-combining mark sequence where it does not belong at the end.
208      * This might not be worth the trouble.
209      * On the other hand, it&#39;s not a huge amount of trouble.
210      *
211      * We probably need it for UNORM_SIMPLE_APPEND.
212      */
213 
214     UBool appendSupplementary(UChar32 c, uint8_t cc, UErrorCode &amp;errorCode);
215     void insert(UChar32 c, uint8_t cc);
216     static void writeCodePoint(UChar *p, UChar32 c) {
217         if(c&lt;=0xffff) {
218             *p=(UChar)c;
219         } else {
220             p[0]=U16_LEAD(c);
221             p[1]=U16_TRAIL(c);
222         }
223     }
224     UBool resize(int32_t appendLength, UErrorCode &amp;errorCode);
225 
226     const Normalizer2Impl &amp;impl;
227     UnicodeString &amp;str;
228     UChar *start, *reorderStart, *limit;
229     int32_t remainingCapacity;
230     uint8_t lastCC;
231 
232     // private backward iterator
233     void setIterator() { codePointStart=limit; }
234     void skipPrevious();  // Requires start&lt;codePointStart.
235     uint8_t previousCC();  // Returns 0 if there is no previous character.
236 
237     UChar *codePointStart, *codePointLimit;
238 };
239 
240 /**
241  * Low-level implementation of the Unicode Normalization Algorithm.
242  * For the data structure and details see the documentation at the end of
243  * this normalizer2impl.h and in the design doc at
244  * http://site.icu-project.org/design/normalization/custom
245  */
246 class U_COMMON_API Normalizer2Impl : public UObject {
247 public:
248     Normalizer2Impl() : normTrie(NULL), fCanonIterData(NULL) {
249         fCanonIterDataInitOnce.reset();
250     }
251     virtual ~Normalizer2Impl();
252 
253     void init(const int32_t *inIndexes, const UCPTrie *inTrie,
254               const uint16_t *inExtraData, const uint8_t *inSmallFCD);
255 
256     void addLcccChars(UnicodeSet &amp;set) const;
257     void addPropertyStarts(const USetAdder *sa, UErrorCode &amp;errorCode) const;
258     void addCanonIterPropertyStarts(const USetAdder *sa, UErrorCode &amp;errorCode) const;
259 
260     // low-level properties ------------------------------------------------ ***
261 
262     UBool ensureCanonIterData(UErrorCode &amp;errorCode) const;
263 
264     // The trie stores values for lead surrogate code *units*.
265     // Surrogate code *points* are inert.
266     uint16_t getNorm16(UChar32 c) const {
267         return U_IS_LEAD(c) ?
268             static_cast&lt;uint16_t&gt;(INERT) :
269             UCPTRIE_FAST_GET(normTrie, UCPTRIE_16, c);
270     }
271     uint16_t getRawNorm16(UChar32 c) const { return UCPTRIE_FAST_GET(normTrie, UCPTRIE_16, c); }
272 
273     UNormalizationCheckResult getCompQuickCheck(uint16_t norm16) const {
274         if(norm16&lt;minNoNo || MIN_YES_YES_WITH_CC&lt;=norm16) {
275             return UNORM_YES;
276         } else if(minMaybeYes&lt;=norm16) {
277             return UNORM_MAYBE;
278         } else {
279             return UNORM_NO;
280         }
281     }
282     UBool isAlgorithmicNoNo(uint16_t norm16) const { return limitNoNo&lt;=norm16 &amp;&amp; norm16&lt;minMaybeYes; }
283     UBool isCompNo(uint16_t norm16) const { return minNoNo&lt;=norm16 &amp;&amp; norm16&lt;minMaybeYes; }
284     UBool isDecompYes(uint16_t norm16) const { return norm16&lt;minYesNo || minMaybeYes&lt;=norm16; }
285 
286     uint8_t getCC(uint16_t norm16) const {
287         if(norm16&gt;=MIN_NORMAL_MAYBE_YES) {
288             return getCCFromNormalYesOrMaybe(norm16);
289         }
290         if(norm16&lt;minNoNo || limitNoNo&lt;=norm16) {
291             return 0;
292         }
293         return getCCFromNoNo(norm16);
294     }
295     static uint8_t getCCFromNormalYesOrMaybe(uint16_t norm16) {
296         return (uint8_t)(norm16 &gt;&gt; OFFSET_SHIFT);
297     }
298     static uint8_t getCCFromYesOrMaybe(uint16_t norm16) {
299         return norm16&gt;=MIN_NORMAL_MAYBE_YES ? getCCFromNormalYesOrMaybe(norm16) : 0;
300     }
301     uint8_t getCCFromYesOrMaybeCP(UChar32 c) const {
302         if (c &lt; minCompNoMaybeCP) { return 0; }
303         return getCCFromYesOrMaybe(getNorm16(c));
304     }
305 
306     /**
307      * Returns the FCD data for code point c.
308      * @param c A Unicode code point.
309      * @return The lccc(c) in bits 15..8 and tccc(c) in bits 7..0.
310      */
311     uint16_t getFCD16(UChar32 c) const {
312         if(c&lt;minDecompNoCP) {
313             return 0;
314         } else if(c&lt;=0xffff) {
315             if(!singleLeadMightHaveNonZeroFCD16(c)) { return 0; }
316         }
317         return getFCD16FromNormData(c);
318     }
319     /**
320      * Returns the FCD data for the next code point (post-increment).
321      * Might skip only a lead surrogate rather than the whole surrogate pair if none of
322      * the supplementary code points associated with the lead surrogate have non-zero FCD data.
323      * @param s A valid pointer into a string. Requires s!=limit.
324      * @param limit The end of the string, or NULL.
325      * @return The lccc(c) in bits 15..8 and tccc(c) in bits 7..0.
326      */
327     uint16_t nextFCD16(const UChar *&amp;s, const UChar *limit) const {
328         UChar32 c=*s++;
329         if(c&lt;minDecompNoCP || !singleLeadMightHaveNonZeroFCD16(c)) {
330             return 0;
331         }
332         UChar c2;
333         if(U16_IS_LEAD(c) &amp;&amp; s!=limit &amp;&amp; U16_IS_TRAIL(c2=*s)) {
334             c=U16_GET_SUPPLEMENTARY(c, c2);
335             ++s;
336         }
337         return getFCD16FromNormData(c);
338     }
339     /**
340      * Returns the FCD data for the previous code point (pre-decrement).
341      * @param start The start of the string.
342      * @param s A valid pointer into a string. Requires start&lt;s.
343      * @return The lccc(c) in bits 15..8 and tccc(c) in bits 7..0.
344      */
345     uint16_t previousFCD16(const UChar *start, const UChar *&amp;s) const {
346         UChar32 c=*--s;
347         if(c&lt;minDecompNoCP) {
348             return 0;
349         }
350         if(!U16_IS_TRAIL(c)) {
351             if(!singleLeadMightHaveNonZeroFCD16(c)) {
352                 return 0;
353             }
354         } else {
355             UChar c2;
356             if(start&lt;s &amp;&amp; U16_IS_LEAD(c2=*(s-1))) {
357                 c=U16_GET_SUPPLEMENTARY(c2, c);
358                 --s;
359             }
360         }
361         return getFCD16FromNormData(c);
362     }
363 
364     /** Returns TRUE if the single-or-lead code unit c might have non-zero FCD data. */
365     UBool singleLeadMightHaveNonZeroFCD16(UChar32 lead) const {
366         // 0&lt;=lead&lt;=0xffff
367         uint8_t bits=smallFCD[lead&gt;&gt;8];
368         if(bits==0) { return false; }
369         return (UBool)((bits&gt;&gt;((lead&gt;&gt;5)&amp;7))&amp;1);
370     }
371     /** Returns the FCD value from the regular normalization data. */
372     uint16_t getFCD16FromNormData(UChar32 c) const;
373 
374     /**
375      * Gets the decomposition for one code point.
376      * @param c code point
377      * @param buffer out-only buffer for algorithmic decompositions
378      * @param length out-only, takes the length of the decomposition, if any
379      * @return pointer to the decomposition, or NULL if none
380      */
381     const UChar *getDecomposition(UChar32 c, UChar buffer[4], int32_t &amp;length) const;
382 
383     /**
384      * Gets the raw decomposition for one code point.
385      * @param c code point
386      * @param buffer out-only buffer for algorithmic decompositions
387      * @param length out-only, takes the length of the decomposition, if any
388      * @return pointer to the decomposition, or NULL if none
389      */
390     const UChar *getRawDecomposition(UChar32 c, UChar buffer[30], int32_t &amp;length) const;
391 
392     UChar32 composePair(UChar32 a, UChar32 b) const;
393 
394     UBool isCanonSegmentStarter(UChar32 c) const;
395     UBool getCanonStartSet(UChar32 c, UnicodeSet &amp;set) const;
396 
397     enum {
398         // Fixed norm16 values.
399         MIN_YES_YES_WITH_CC=0xfe02,
400         JAMO_VT=0xfe00,
401         MIN_NORMAL_MAYBE_YES=0xfc00,
402         JAMO_L=2,  // offset=1 hasCompBoundaryAfter=FALSE
403         INERT=1,  // offset=0 hasCompBoundaryAfter=TRUE
404 
405         // norm16 bit 0 is comp-boundary-after.
406         HAS_COMP_BOUNDARY_AFTER=1,
407         OFFSET_SHIFT=1,
408 
409         // For algorithmic one-way mappings, norm16 bits 2..1 indicate the
410         // tccc (0, 1, &gt;1) for quick FCC boundary-after tests.
411         DELTA_TCCC_0=0,
412         DELTA_TCCC_1=2,
413         DELTA_TCCC_GT_1=4,
414         DELTA_TCCC_MASK=6,
415         DELTA_SHIFT=3,
416 
417         MAX_DELTA=0x40
418     };
419 
420     enum {
421         // Byte offsets from the start of the data, after the generic header.
422         IX_NORM_TRIE_OFFSET,
423         IX_EXTRA_DATA_OFFSET,
424         IX_SMALL_FCD_OFFSET,
425         IX_RESERVED3_OFFSET,
426         IX_RESERVED4_OFFSET,
427         IX_RESERVED5_OFFSET,
428         IX_RESERVED6_OFFSET,
429         IX_TOTAL_SIZE,
430 
431         // Code point thresholds for quick check codes.
432         IX_MIN_DECOMP_NO_CP,
433         IX_MIN_COMP_NO_MAYBE_CP,
434 
435         // Norm16 value thresholds for quick check combinations and types of extra data.
436 
437         /** Mappings &amp; compositions in [minYesNo..minYesNoMappingsOnly[. */
438         IX_MIN_YES_NO,
439         /** Mappings are comp-normalized. */
440         IX_MIN_NO_NO,
441         IX_LIMIT_NO_NO,
442         IX_MIN_MAYBE_YES,
443 
444         /** Mappings only in [minYesNoMappingsOnly..minNoNo[. */
445         IX_MIN_YES_NO_MAPPINGS_ONLY,
446         /** Mappings are not comp-normalized but have a comp boundary before. */
447         IX_MIN_NO_NO_COMP_BOUNDARY_BEFORE,
448         /** Mappings do not have a comp boundary before. */
449         IX_MIN_NO_NO_COMP_NO_MAYBE_CC,
450         /** Mappings to the empty string. */
451         IX_MIN_NO_NO_EMPTY,
452 
453         IX_MIN_LCCC_CP,
454         IX_RESERVED19,
455         IX_COUNT
456     };
457 
458     enum {
459         MAPPING_HAS_CCC_LCCC_WORD=0x80,
460         MAPPING_HAS_RAW_MAPPING=0x40,
461         // unused bit 0x20,
462         MAPPING_LENGTH_MASK=0x1f
463     };
464 
465     enum {
466         COMP_1_LAST_TUPLE=0x8000,
467         COMP_1_TRIPLE=1,
468         COMP_1_TRAIL_LIMIT=0x3400,
469         COMP_1_TRAIL_MASK=0x7ffe,
470         COMP_1_TRAIL_SHIFT=9,  // 10-1 for the &quot;triple&quot; bit
471         COMP_2_TRAIL_SHIFT=6,
472         COMP_2_TRAIL_MASK=0xffc0
473     };
474 
475     // higher-level functionality ------------------------------------------ ***
476 
477     // NFD without an NFD Normalizer2 instance.
478     UnicodeString &amp;decompose(const UnicodeString &amp;src, UnicodeString &amp;dest,
479                              UErrorCode &amp;errorCode) const;
480     /**
481      * Decomposes [src, limit[ and writes the result to dest.
482      * limit can be NULL if src is NUL-terminated.
483      * destLengthEstimate is the initial dest buffer capacity and can be -1.
484      */
485     void decompose(const UChar *src, const UChar *limit,
486                    UnicodeString &amp;dest, int32_t destLengthEstimate,
487                    UErrorCode &amp;errorCode) const;
488 
489     const UChar *decompose(const UChar *src, const UChar *limit,
490                            ReorderingBuffer *buffer, UErrorCode &amp;errorCode) const;
491     void decomposeAndAppend(const UChar *src, const UChar *limit,
492                             UBool doDecompose,
493                             UnicodeString &amp;safeMiddle,
494                             ReorderingBuffer &amp;buffer,
495                             UErrorCode &amp;errorCode) const;
496     UBool compose(const UChar *src, const UChar *limit,
497                   UBool onlyContiguous,
498                   UBool doCompose,
499                   ReorderingBuffer &amp;buffer,
500                   UErrorCode &amp;errorCode) const;
501     const UChar *composeQuickCheck(const UChar *src, const UChar *limit,
502                                    UBool onlyContiguous,
503                                    UNormalizationCheckResult *pQCResult) const;
504     void composeAndAppend(const UChar *src, const UChar *limit,
505                           UBool doCompose,
506                           UBool onlyContiguous,
507                           UnicodeString &amp;safeMiddle,
508                           ReorderingBuffer &amp;buffer,
509                           UErrorCode &amp;errorCode) const;
510 
511     /** sink==nullptr: isNormalized() */
512     UBool composeUTF8(uint32_t options, UBool onlyContiguous,
513                       const uint8_t *src, const uint8_t *limit,
514                       ByteSink *sink, icu::Edits *edits, UErrorCode &amp;errorCode) const;
515 
516     const UChar *makeFCD(const UChar *src, const UChar *limit,
517                          ReorderingBuffer *buffer, UErrorCode &amp;errorCode) const;
518     void makeFCDAndAppend(const UChar *src, const UChar *limit,
519                           UBool doMakeFCD,
520                           UnicodeString &amp;safeMiddle,
521                           ReorderingBuffer &amp;buffer,
522                           UErrorCode &amp;errorCode) const;
523 
524     UBool hasDecompBoundaryBefore(UChar32 c) const;
525     UBool norm16HasDecompBoundaryBefore(uint16_t norm16) const;
526     UBool hasDecompBoundaryAfter(UChar32 c) const;
527     UBool norm16HasDecompBoundaryAfter(uint16_t norm16) const;
528     UBool isDecompInert(UChar32 c) const { return isDecompYesAndZeroCC(getNorm16(c)); }
529 
530     UBool hasCompBoundaryBefore(UChar32 c) const {
531         return c&lt;minCompNoMaybeCP || norm16HasCompBoundaryBefore(getNorm16(c));
532     }
533     UBool hasCompBoundaryAfter(UChar32 c, UBool onlyContiguous) const {
534         return norm16HasCompBoundaryAfter(getNorm16(c), onlyContiguous);
535     }
536     UBool isCompInert(UChar32 c, UBool onlyContiguous) const {
537         uint16_t norm16=getNorm16(c);
538         return isCompYesAndZeroCC(norm16) &amp;&amp;
539             (norm16 &amp; HAS_COMP_BOUNDARY_AFTER) != 0 &amp;&amp;
540             (!onlyContiguous || isInert(norm16) || *getMapping(norm16) &lt;= 0x1ff);
541     }
542 
543     UBool hasFCDBoundaryBefore(UChar32 c) const { return hasDecompBoundaryBefore(c); }
544     UBool hasFCDBoundaryAfter(UChar32 c) const { return hasDecompBoundaryAfter(c); }
545     UBool isFCDInert(UChar32 c) const { return getFCD16(c)&lt;=1; }
546 private:
547     friend class InitCanonIterData;
548     friend class LcccContext;
549 
550     UBool isMaybe(uint16_t norm16) const { return minMaybeYes&lt;=norm16 &amp;&amp; norm16&lt;=JAMO_VT; }
551     UBool isMaybeOrNonZeroCC(uint16_t norm16) const { return norm16&gt;=minMaybeYes; }
552     static UBool isInert(uint16_t norm16) { return norm16==INERT; }
553     static UBool isJamoL(uint16_t norm16) { return norm16==JAMO_L; }
554     static UBool isJamoVT(uint16_t norm16) { return norm16==JAMO_VT; }
555     uint16_t hangulLVT() const { return minYesNoMappingsOnly|HAS_COMP_BOUNDARY_AFTER; }
556     UBool isHangulLV(uint16_t norm16) const { return norm16==minYesNo; }
557     UBool isHangulLVT(uint16_t norm16) const {
558         return norm16==hangulLVT();
559     }
560     UBool isCompYesAndZeroCC(uint16_t norm16) const { return norm16&lt;minNoNo; }
561     // UBool isCompYes(uint16_t norm16) const {
562     //     return norm16&gt;=MIN_YES_YES_WITH_CC || norm16&lt;minNoNo;
563     // }
564     // UBool isCompYesOrMaybe(uint16_t norm16) const {
565     //     return norm16&lt;minNoNo || minMaybeYes&lt;=norm16;
566     // }
567     // UBool hasZeroCCFromDecompYes(uint16_t norm16) const {
568     //     return norm16&lt;=MIN_NORMAL_MAYBE_YES || norm16==JAMO_VT;
569     // }
570     UBool isDecompYesAndZeroCC(uint16_t norm16) const {
571         return norm16&lt;minYesNo ||
572                norm16==JAMO_VT ||
573                (minMaybeYes&lt;=norm16 &amp;&amp; norm16&lt;=MIN_NORMAL_MAYBE_YES);
574     }
575     /**
576      * A little faster and simpler than isDecompYesAndZeroCC() but does not include
577      * the MaybeYes which combine-forward and have ccc=0.
578      * (Standard Unicode 10 normalization does not have such characters.)
579      */
580     UBool isMostDecompYesAndZeroCC(uint16_t norm16) const {
581         return norm16&lt;minYesNo || norm16==MIN_NORMAL_MAYBE_YES || norm16==JAMO_VT;
582     }
583     UBool isDecompNoAlgorithmic(uint16_t norm16) const { return norm16&gt;=limitNoNo; }
584 
585     // For use with isCompYes().
586     // Perhaps the compiler can combine the two tests for MIN_YES_YES_WITH_CC.
587     // static uint8_t getCCFromYes(uint16_t norm16) {
588     //     return norm16&gt;=MIN_YES_YES_WITH_CC ? getCCFromNormalYesOrMaybe(norm16) : 0;
589     // }
590     uint8_t getCCFromNoNo(uint16_t norm16) const {
591         const uint16_t *mapping=getMapping(norm16);
592         if(*mapping&amp;MAPPING_HAS_CCC_LCCC_WORD) {
593             return (uint8_t)*(mapping-1);
594         } else {
595             return 0;
596         }
597     }
598     // requires that the [cpStart..cpLimit[ character passes isCompYesAndZeroCC()
599     uint8_t getTrailCCFromCompYesAndZeroCC(uint16_t norm16) const {
600         if(norm16&lt;=minYesNo) {
601             return 0;  // yesYes and Hangul LV have ccc=tccc=0
602         } else {
603             // For Hangul LVT we harmlessly fetch a firstUnit with tccc=0 here.
604             return (uint8_t)(*getMapping(norm16)&gt;&gt;8);  // tccc from yesNo
605         }
606     }
607     uint8_t getPreviousTrailCC(const UChar *start, const UChar *p) const;
608     uint8_t getPreviousTrailCC(const uint8_t *start, const uint8_t *p) const;
609 
610     // Requires algorithmic-NoNo.
611     UChar32 mapAlgorithmic(UChar32 c, uint16_t norm16) const {
612         return c+(norm16&gt;&gt;DELTA_SHIFT)-centerNoNoDelta;
613     }
614     UChar32 getAlgorithmicDelta(uint16_t norm16) const {
615         return (norm16&gt;&gt;DELTA_SHIFT)-centerNoNoDelta;
616     }
617 
618     // Requires minYesNo&lt;norm16&lt;limitNoNo.
619     const uint16_t *getMapping(uint16_t norm16) const { return extraData+(norm16&gt;&gt;OFFSET_SHIFT); }
620     const uint16_t *getCompositionsListForDecompYes(uint16_t norm16) const {
621         if(norm16&lt;JAMO_L || MIN_NORMAL_MAYBE_YES&lt;=norm16) {
622             return NULL;
623         } else if(norm16&lt;minMaybeYes) {
624             return getMapping(norm16);  // for yesYes; if Jamo L: harmless empty list
625         } else {
626             return maybeYesCompositions+norm16-minMaybeYes;
627         }
628     }
629     const uint16_t *getCompositionsListForComposite(uint16_t norm16) const {
630         // A composite has both mapping &amp; compositions list.
631         const uint16_t *list=getMapping(norm16);
632         return list+  // mapping pointer
633             1+  // +1 to skip the first unit with the mapping length
634             (*list&amp;MAPPING_LENGTH_MASK);  // + mapping length
635     }
636     const uint16_t *getCompositionsListForMaybe(uint16_t norm16) const {
637         // minMaybeYes&lt;=norm16&lt;MIN_NORMAL_MAYBE_YES
638         return maybeYesCompositions+((norm16-minMaybeYes)&gt;&gt;OFFSET_SHIFT);
639     }
640     /**
641      * @param c code point must have compositions
642      * @return compositions list pointer
643      */
644     const uint16_t *getCompositionsList(uint16_t norm16) const {
645         return isDecompYes(norm16) ?
646                 getCompositionsListForDecompYes(norm16) :
647                 getCompositionsListForComposite(norm16);
648     }
649 
650     const UChar *copyLowPrefixFromNulTerminated(const UChar *src,
651                                                 UChar32 minNeedDataCP,
652                                                 ReorderingBuffer *buffer,
653                                                 UErrorCode &amp;errorCode) const;
654     const UChar *decomposeShort(const UChar *src, const UChar *limit,
655                                 UBool stopAtCompBoundary, UBool onlyContiguous,
656                                 ReorderingBuffer &amp;buffer, UErrorCode &amp;errorCode) const;
657     UBool decompose(UChar32 c, uint16_t norm16,
658                     ReorderingBuffer &amp;buffer, UErrorCode &amp;errorCode) const;
659 
660     const uint8_t *decomposeShort(const uint8_t *src, const uint8_t *limit,
661                                   UBool stopAtCompBoundary, UBool onlyContiguous,
662                                   ReorderingBuffer &amp;buffer, UErrorCode &amp;errorCode) const;
663 
664     static int32_t combine(const uint16_t *list, UChar32 trail);
665     void addComposites(const uint16_t *list, UnicodeSet &amp;set) const;
666     void recompose(ReorderingBuffer &amp;buffer, int32_t recomposeStartIndex,
667                    UBool onlyContiguous) const;
668 
669     UBool hasCompBoundaryBefore(UChar32 c, uint16_t norm16) const {
670         return c&lt;minCompNoMaybeCP || norm16HasCompBoundaryBefore(norm16);
671     }
672     UBool norm16HasCompBoundaryBefore(uint16_t norm16) const  {
673         return norm16 &lt; minNoNoCompNoMaybeCC || isAlgorithmicNoNo(norm16);
674     }
675     UBool hasCompBoundaryBefore(const UChar *src, const UChar *limit) const;
676     UBool hasCompBoundaryBefore(const uint8_t *src, const uint8_t *limit) const;
677     UBool hasCompBoundaryAfter(const UChar *start, const UChar *p,
678                                UBool onlyContiguous) const;
679     UBool hasCompBoundaryAfter(const uint8_t *start, const uint8_t *p,
680                                UBool onlyContiguous) const;
681     UBool norm16HasCompBoundaryAfter(uint16_t norm16, UBool onlyContiguous) const {
682         return (norm16 &amp; HAS_COMP_BOUNDARY_AFTER) != 0 &amp;&amp;
683             (!onlyContiguous || isTrailCC01ForCompBoundaryAfter(norm16));
684     }
685     /** For FCC: Given norm16 HAS_COMP_BOUNDARY_AFTER, does it have tccc&lt;=1? */
686     UBool isTrailCC01ForCompBoundaryAfter(uint16_t norm16) const {
687         return isInert(norm16) || (isDecompNoAlgorithmic(norm16) ?
688             (norm16 &amp; DELTA_TCCC_MASK) &lt;= DELTA_TCCC_1 : *getMapping(norm16) &lt;= 0x1ff);
689     }
690 
691     const UChar *findPreviousCompBoundary(const UChar *start, const UChar *p, UBool onlyContiguous) const;
692     const UChar *findNextCompBoundary(const UChar *p, const UChar *limit, UBool onlyContiguous) const;
693 
694     const UChar *findPreviousFCDBoundary(const UChar *start, const UChar *p) const;
695     const UChar *findNextFCDBoundary(const UChar *p, const UChar *limit) const;
696 
697     void makeCanonIterDataFromNorm16(UChar32 start, UChar32 end, const uint16_t norm16,
698                                      CanonIterData &amp;newData, UErrorCode &amp;errorCode) const;
699 
700     int32_t getCanonValue(UChar32 c) const;
701     const UnicodeSet &amp;getCanonStartSet(int32_t n) const;
702 
703     // UVersionInfo dataVersion;
704 
705     // BMP code point thresholds for quick check loops looking at single UTF-16 code units.
706     UChar minDecompNoCP;
707     UChar minCompNoMaybeCP;
708     UChar minLcccCP;
709 
710     // Norm16 value thresholds for quick check combinations and types of extra data.
711     uint16_t minYesNo;
712     uint16_t minYesNoMappingsOnly;
713     uint16_t minNoNo;
714     uint16_t minNoNoCompBoundaryBefore;
715     uint16_t minNoNoCompNoMaybeCC;
716     uint16_t minNoNoEmpty;
717     uint16_t limitNoNo;
718     uint16_t centerNoNoDelta;
719     uint16_t minMaybeYes;
720 
721     const UCPTrie *normTrie;
722     const uint16_t *maybeYesCompositions;
723     const uint16_t *extraData;  // mappings and/or compositions for yesYes, yesNo &amp; noNo characters
724     const uint8_t *smallFCD;  // [0x100] one bit per 32 BMP code points, set if any FCD!=0
725 
726     UInitOnce       fCanonIterDataInitOnce;
727     CanonIterData  *fCanonIterData;
728 };
729 
730 // bits in canonIterData
731 #define CANON_NOT_SEGMENT_STARTER 0x80000000
732 #define CANON_HAS_COMPOSITIONS 0x40000000
733 #define CANON_HAS_SET 0x200000
734 #define CANON_VALUE_MASK 0x1fffff
735 
736 /**
737  * ICU-internal shortcut for quick access to standard Unicode normalization.
738  */
739 class U_COMMON_API Normalizer2Factory {
740 public:
741     static const Normalizer2 *getFCDInstance(UErrorCode &amp;errorCode);
742     static const Normalizer2 *getFCCInstance(UErrorCode &amp;errorCode);
743     static const Normalizer2 *getNoopInstance(UErrorCode &amp;errorCode);
744 
745     static const Normalizer2 *getInstance(UNormalizationMode mode, UErrorCode &amp;errorCode);
746 
747     static const Normalizer2Impl *getNFCImpl(UErrorCode &amp;errorCode);
748     static const Normalizer2Impl *getNFKCImpl(UErrorCode &amp;errorCode);
749     static const Normalizer2Impl *getNFKC_CFImpl(UErrorCode &amp;errorCode);
750 
751     // Get the Impl instance of the Normalizer2.
752     // Must be used only when it is known that norm2 is a Normalizer2WithImpl instance.
753     static const Normalizer2Impl *getImpl(const Normalizer2 *norm2);
754 private:
755     Normalizer2Factory();  // No instantiation.
756 };
757 
758 U_NAMESPACE_END
759 
760 U_CAPI int32_t U_EXPORT2
761 unorm2_swap(const UDataSwapper *ds,
762             const void *inData, int32_t length, void *outData,
763             UErrorCode *pErrorCode);
764 
765 /**
766  * Get the NF*_QC property for a code point, for u_getIntPropertyValue().
767  * @internal
768  */
769 U_CFUNC UNormalizationCheckResult
770 unorm_getQuickCheck(UChar32 c, UNormalizationMode mode);
771 
772 /**
773  * Gets the 16-bit FCD value (lead &amp; trail CCs) for a code point, for u_getIntPropertyValue().
774  * @internal
775  */
776 U_CFUNC uint16_t
777 unorm_getFCD16(UChar32 c);
778 
779 /**
780  * Format of Normalizer2 .nrm data files.
781  * Format version 4.0.
782  *
783  * Normalizer2 .nrm data files provide data for the Unicode Normalization algorithms.
784  * ICU ships with data files for standard Unicode Normalization Forms
785  * NFC and NFD (nfc.nrm), NFKC and NFKD (nfkc.nrm) and NFKC_Casefold (nfkc_cf.nrm).
786  * Custom (application-specific) data can be built into additional .nrm files
787  * with the gennorm2 build tool.
788  * ICU ships with one such file, uts46.nrm, for the implementation of UTS #46.
789  *
790  * Normalizer2.getInstance() causes a .nrm file to be loaded, unless it has been
791  * cached already. Internally, Normalizer2Impl.load() reads the .nrm file.
792  *
793  * A .nrm file begins with a standard ICU data file header
794  * (DataHeader, see ucmndata.h and unicode/udata.h).
795  * The UDataInfo.dataVersion field usually contains the Unicode version
796  * for which the data was generated.
797  *
798  * After the header, the file contains the following parts.
799  * Constants are defined as enum values of the Normalizer2Impl class.
800  *
801  * Many details of the data structures are described in the design doc
802  * which is at http://site.icu-project.org/design/normalization/custom
803  *
804  * int32_t indexes[indexesLength]; -- indexesLength=indexes[IX_NORM_TRIE_OFFSET]/4;
805  *
806  *      The first eight indexes are byte offsets in ascending order.
807  *      Each byte offset marks the start of the next part in the data file,
808  *      and the end of the previous one.
809  *      When two consecutive byte offsets are the same, then the corresponding part is empty.
810  *      Byte offsets are offsets from after the header,
811  *      that is, from the beginning of the indexes[].
812  *      Each part starts at an offset with proper alignment for its data.
813  *      If necessary, the previous part may include padding bytes to achieve this alignment.
814  *
815  *      minDecompNoCP=indexes[IX_MIN_DECOMP_NO_CP] is the lowest code point
816  *      with a decomposition mapping, that is, with NF*D_QC=No.
817  *      minCompNoMaybeCP=indexes[IX_MIN_COMP_NO_MAYBE_CP] is the lowest code point
818  *      with NF*C_QC=No (has a one-way mapping) or Maybe (combines backward).
819  *      minLcccCP=indexes[IX_MIN_LCCC_CP] (index 18, new in formatVersion 3)
820  *      is the lowest code point with lccc!=0.
821  *
822  *      The next eight indexes are thresholds of 16-bit trie values for ranges of
823  *      values indicating multiple normalization properties.
824  *      They are listed here in threshold order, not in the order they are stored in the indexes.
825  *          minYesNo=indexes[IX_MIN_YES_NO];
826  *          minYesNoMappingsOnly=indexes[IX_MIN_YES_NO_MAPPINGS_ONLY];
827  *          minNoNo=indexes[IX_MIN_NO_NO];
828  *          minNoNoCompBoundaryBefore=indexes[IX_MIN_NO_NO_COMP_BOUNDARY_BEFORE];
829  *          minNoNoCompNoMaybeCC=indexes[IX_MIN_NO_NO_COMP_NO_MAYBE_CC];
830  *          minNoNoEmpty=indexes[IX_MIN_NO_NO_EMPTY];
831  *          limitNoNo=indexes[IX_LIMIT_NO_NO];
832  *          minMaybeYes=indexes[IX_MIN_MAYBE_YES];
833  *      See the normTrie description below and the design doc for details.
834  *
835  * UCPTrie normTrie; -- see ucptrie_impl.h and ucptrie.h, same as Java CodePointTrie
836  *
837  *      The trie holds the main normalization data. Each code point is mapped to a 16-bit value.
838  *      Rather than using independent bits in the value (which would require more than 16 bits),
839  *      information is extracted primarily via range checks.
840  *      Except, format version 3 uses bit 0 for hasCompBoundaryAfter().
841  *      For example, a 16-bit value norm16 in the range minYesNo&lt;=norm16&lt;minNoNo
842  *      means that the character has NF*C_QC=Yes and NF*D_QC=No properties,
843  *      which means it has a two-way (round-trip) decomposition mapping.
844  *      Values in the range 2&lt;=norm16&lt;limitNoNo are also directly indexes into the extraData
845  *      pointing to mappings, compositions lists, or both.
846  *      Value norm16==INERT (0 in versions 1 &amp; 2, 1 in version 3)
847  *      means that the character is normalization-inert, that is,
848  *      it does not have a mapping, does not participate in composition, has a zero
849  *      canonical combining class, and forms a boundary where text before it and after it
850  *      can be normalized independently.
851  *      For details about how multiple properties are encoded in 16-bit values
852  *      see the design doc.
853  *      Note that the encoding cannot express all combinations of the properties involved;
854  *      it only supports those combinations that are allowed by
855  *      the Unicode Normalization algorithms. Details are in the design doc as well.
856  *      The gennorm2 tool only builds .nrm files for data that conforms to the limitations.
857  *
858  *      The trie has a value for each lead surrogate code unit representing the &quot;worst case&quot;
859  *      properties of the 1024 supplementary characters whose UTF-16 form starts with
860  *      the lead surrogate. If all of the 1024 supplementary characters are normalization-inert,
861  *      then their lead surrogate code unit has the trie value INERT.
862  *      When the lead surrogate unit&#39;s value exceeds the quick check minimum during processing,
863  *      the properties for the full supplementary code point need to be looked up.
864  *
865  * uint16_t maybeYesCompositions[MIN_NORMAL_MAYBE_YES-minMaybeYes];
866  * uint16_t extraData[];
867  *
868  *      There is only one byte offset for the end of these two arrays.
869  *      The split between them is given by the constant and variable mentioned above.
870  *      In version 3, the difference must be shifted right by OFFSET_SHIFT.
871  *
872  *      The maybeYesCompositions array contains compositions lists for characters that
873  *      combine both forward (as starters in composition pairs)
874  *      and backward (as trailing characters in composition pairs).
875  *      Such characters do not occur in Unicode 5.2 but are allowed by
876  *      the Unicode Normalization algorithms.
877  *      If there are no such characters, then minMaybeYes==MIN_NORMAL_MAYBE_YES
878  *      and the maybeYesCompositions array is empty.
879  *      If there are such characters, then minMaybeYes is subtracted from their norm16 values
880  *      to get the index into this array.
881  *
882  *      The extraData array contains compositions lists for &quot;YesYes&quot; characters,
883  *      followed by mappings and optional compositions lists for &quot;YesNo&quot; characters,
884  *      followed by only mappings for &quot;NoNo&quot; characters.
885  *      (Referring to pairs of NFC/NFD quick check values.)
886  *      The norm16 values of those characters are directly indexes into the extraData array.
887  *      In version 3, the norm16 values must be shifted right by OFFSET_SHIFT
888  *      for accessing extraData.
889  *
890  *      The data structures for compositions lists and mappings are described in the design doc.
891  *
892  * uint8_t smallFCD[0x100]; -- new in format version 2
893  *
894  *      This is a bit set to help speed up FCD value lookups in the absence of a full
895  *      UTrie2 or other large data structure with the full FCD value mapping.
896  *
897  *      Each smallFCD bit is set if any of the corresponding 32 BMP code points
898  *      has a non-zero FCD value (lccc!=0 or tccc!=0).
899  *      Bit 0 of smallFCD[0] is for U+0000..U+001F. Bit 7 of smallFCD[0xff] is for U+FFE0..U+FFFF.
900  *      A bit for 32 lead surrogates is set if any of the 32k corresponding
901  *      _supplementary_ code points has a non-zero FCD value.
902  *
903  *      This bit set is most useful for the large blocks of CJK characters with FCD=0.
904  *
905  * Changes from format version 1 to format version 2 ---------------------------
906  *
907  * - Addition of data for raw (not recursively decomposed) mappings.
908  *   + The MAPPING_NO_COMP_BOUNDARY_AFTER bit in the extraData is now also set when
909  *     the mapping is to an empty string or when the character combines-forward.
910  *     This subsumes the one actual use of the MAPPING_PLUS_COMPOSITION_LIST bit which
911  *     is then repurposed for the MAPPING_HAS_RAW_MAPPING bit.
912  *   + For details see the design doc.
913  * - Addition of indexes[IX_MIN_YES_NO_MAPPINGS_ONLY] and separation of the yesNo extraData into
914  *   distinct ranges (combines-forward vs. not)
915  *   so that a range check can be used to find out if there is a compositions list.
916  *   This is fully equivalent with formatVersion 1&#39;s MAPPING_PLUS_COMPOSITION_LIST flag.
917  *   It is needed for the new (in ICU 49) composePair(), not for other normalization.
918  * - Addition of the smallFCD[] bit set.
919  *
920  * Changes from format version 2 to format version 3 (ICU 60) ------------------
921  *
922  * - norm16 bit 0 indicates hasCompBoundaryAfter(),
923  *   except that for contiguous composition (FCC) the tccc must be checked as well.
924  *   Data indexes and ccc values are shifted left by one (OFFSET_SHIFT).
925  *   Thresholds like minNoNo are tested before shifting.
926  *
927  * - Algorithmic mapping deltas are shifted left by two more bits (total DELTA_SHIFT),
928  *   to make room for two bits (three values) indicating whether the tccc is 0, 1, or greater.
929  *   See DELTA_TCCC_MASK etc.
930  *   This helps with fetching tccc/FCD values and FCC hasCompBoundaryAfter().
931  *   minMaybeYes is 8-aligned so that the DELTA_TCCC_MASK bits can be tested directly.
932  *
933  * - Algorithmic mappings are only used for mapping to &quot;comp yes and ccc=0&quot; characters,
934  *   and ASCII characters are mapped algorithmically only to other ASCII characters.
935  *   This helps with hasCompBoundaryBefore() and compose() fast paths.
936  *   It is never necessary any more to loop for algorithmic mappings.
937  *
938  * - Addition of indexes[IX_MIN_NO_NO_COMP_BOUNDARY_BEFORE],
939  *   indexes[IX_MIN_NO_NO_COMP_NO_MAYBE_CC], and indexes[IX_MIN_NO_NO_EMPTY],
940  *   and separation of the noNo extraData into distinct ranges.
941  *   With this, the noNo norm16 value indicates whether the mapping is
942  *   compose-normalized, not normalized but hasCompBoundaryBefore(),
943  *   not even that, or maps to an empty string.
944  *   hasCompBoundaryBefore() can be determined solely from the norm16 value.
945  *
946  * - The norm16 value for Hangul LVT is now different from that for Hangul LV,
947  *   so that hasCompBoundaryAfter() need not check for the syllable type.
948  *   For Hangul LV, minYesNo continues to be used (no comp-boundary-after).
949  *   For Hangul LVT, minYesNoMappingsOnly|HAS_COMP_BOUNDARY_AFTER is used.
950  *   The extraData units at these indexes are set to firstUnit=2 and firstUnit=3, respectively,
951  *   to simplify some code.
952  *
953  * - The extraData firstUnit bit 5 is no longer necessary
954  *   (norm16 bit 0 used instead of firstUnit MAPPING_NO_COMP_BOUNDARY_AFTER),
955  *   is reserved again, and always set to 0.
956  *
957  * - Addition of indexes[IX_MIN_LCCC_CP], the first code point where lccc!=0.
958  *   This used to be hardcoded to U+0300, but in data like NFKC_Casefold it is lower:
959  *   U+00AD Soft Hyphen maps to an empty string,
960  *   which is artificially assigned &quot;worst case&quot; values lccc=1 and tccc=255.
961  *
962  * - A mapping to an empty string has explicit lccc=1 and tccc=255 values.
963  *
964  * Changes from format version 3 to format version 4 (ICU 63) ------------------
965  *
966  * Switched from UTrie2 to UCPTrie/CodePointTrie.
967  *
968  * The new trie no longer stores different values for surrogate code *units* vs.
969  * surrogate code *points*.
970  * Lead surrogates still have values for optimized UTF-16 string processing.
971  * When looking up code point properties, the code now checks for lead surrogates and
972  * treats them as inert.
973  *
974  * gennorm2 now has to reject mappings for surrogate code points.
975  * UTS #46 maps unpaired surrogates to U+FFFD in code rather than via its
976  * custom normalization data file.
977  */
978 
979 #endif  /* !UCONFIG_NO_NORMALIZATION */
980 #endif  /* __NORMALIZER2IMPL_H__ */
    </pre>
  </body>
</html>