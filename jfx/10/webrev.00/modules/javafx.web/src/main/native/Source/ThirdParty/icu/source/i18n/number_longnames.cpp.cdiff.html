<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_longnames.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="number_integerwidth.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_longnames.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_longnames.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 12,10 ***</span>
<span class="line-new-header">--- 12,11 ---</span>
  #include &quot;uresimp.h&quot;
  #include &quot;number_longnames.h&quot;
  #include &quot;number_microprops.h&quot;
  #include &lt;algorithm&gt;
  #include &quot;cstring.h&quot;
<span class="line-added">+ #include &quot;util.h&quot;</span>
  
  using namespace icu;
  using namespace icu::number;
  using namespace icu::number::impl;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 37,11 ***</span>
      }
  }
  
  static UnicodeString getWithPlural(
          const UnicodeString* strings,
<span class="line-modified">!         int32_t plural,</span>
          UErrorCode&amp; status) {
      UnicodeString result = strings[plural];
      if (result.isBogus()) {
          result = strings[StandardPlural::Form::OTHER];
      }
<span class="line-new-header">--- 38,11 ---</span>
      }
  }
  
  static UnicodeString getWithPlural(
          const UnicodeString* strings,
<span class="line-modified">!         StandardPlural::Form plural,</span>
          UErrorCode&amp; status) {
      UnicodeString result = strings[plural];
      if (result.isBogus()) {
          result = strings[StandardPlural::Form::OTHER];
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,21 ***</span>
  void getMeasureData(const Locale &amp;locale, const MeasureUnit &amp;unit, const UNumberUnitWidth &amp;width,
                      UnicodeString *outArray, UErrorCode &amp;status) {
      PluralTableSink sink(outArray);
      LocalUResourceBundlePointer unitsBundle(ures_open(U_ICUDATA_UNIT, locale.getName(), &amp;status));
      if (U_FAILURE(status)) { return; }
      CharString key;
      key.append(&quot;units&quot;, status);
      if (width == UNUM_UNIT_WIDTH_NARROW) {
          key.append(&quot;Narrow&quot;, status);
      } else if (width == UNUM_UNIT_WIDTH_SHORT) {
          key.append(&quot;Short&quot;, status);
      }
      key.append(&quot;/&quot;, status);
      key.append(unit.getType(), status);
      key.append(&quot;/&quot;, status);
<span class="line-modified">!     key.append(unit.getSubtype(), status);</span>
      ures_getAllItemsWithFallback(unitsBundle.getAlias(), key.data(), sink, status);
  }
  
  void getCurrencyLongNameData(const Locale &amp;locale, const CurrencyUnit &amp;currency, UnicodeString *outArray,
                               UErrorCode &amp;status) {
<span class="line-new-header">--- 90,49 ---</span>
  void getMeasureData(const Locale &amp;locale, const MeasureUnit &amp;unit, const UNumberUnitWidth &amp;width,
                      UnicodeString *outArray, UErrorCode &amp;status) {
      PluralTableSink sink(outArray);
      LocalUResourceBundlePointer unitsBundle(ures_open(U_ICUDATA_UNIT, locale.getName(), &amp;status));
      if (U_FAILURE(status)) { return; }
<span class="line-added">+ </span>
<span class="line-added">+     // Map duration-year-person, duration-week-person, etc. to duration-year, duration-week, ...</span>
<span class="line-added">+     // TODO(ICU-20400): Get duration-*-person data properly with aliases.</span>
<span class="line-added">+     StringPiece subtypeForResource;</span>
<span class="line-added">+     int32_t subtypeLen = static_cast&lt;int32_t&gt;(uprv_strlen(unit.getSubtype()));</span>
<span class="line-added">+     if (subtypeLen &gt; 7 &amp;&amp; uprv_strcmp(unit.getSubtype() + subtypeLen - 7, &quot;-person&quot;) == 0) {</span>
<span class="line-added">+         subtypeForResource = {unit.getSubtype(), subtypeLen - 7};</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         subtypeForResource = unit.getSubtype();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      CharString key;
      key.append(&quot;units&quot;, status);
      if (width == UNUM_UNIT_WIDTH_NARROW) {
          key.append(&quot;Narrow&quot;, status);
      } else if (width == UNUM_UNIT_WIDTH_SHORT) {
          key.append(&quot;Short&quot;, status);
      }
      key.append(&quot;/&quot;, status);
      key.append(unit.getType(), status);
      key.append(&quot;/&quot;, status);
<span class="line-modified">!     key.append(subtypeForResource, status);</span>
<span class="line-added">+ </span>
<span class="line-added">+     UErrorCode localStatus = U_ZERO_ERROR;</span>
<span class="line-added">+     ures_getAllItemsWithFallback(unitsBundle.getAlias(), key.data(), sink, localStatus);</span>
<span class="line-added">+     if (width == UNUM_UNIT_WIDTH_SHORT) {</span>
<span class="line-added">+         if (U_FAILURE(localStatus)) {</span>
<span class="line-added">+             status = localStatus;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // TODO(ICU-13353): The fallback to short does not work in ICU4C.</span>
<span class="line-added">+     // Manually fall back to short (this is done automatically in Java).</span>
<span class="line-added">+     key.clear();</span>
<span class="line-added">+     key.append(&quot;unitsShort/&quot;, status);</span>
<span class="line-added">+     key.append(unit.getType(), status);</span>
<span class="line-added">+     key.append(&quot;/&quot;, status);</span>
<span class="line-added">+     key.append(subtypeForResource, status);</span>
      ures_getAllItemsWithFallback(unitsBundle.getAlias(), key.data(), sink, status);
  }
  
  void getCurrencyLongNameData(const Locale &amp;locale, const CurrencyUnit &amp;currency, UnicodeString *outArray,
                               UErrorCode &amp;status) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 154,11 ***</span>
  /// END DATA LOADING ///
  ////////////////////////
  
  } // namespace
  
<span class="line-modified">! LongNameHandler</span>
  LongNameHandler::forMeasureUnit(const Locale &amp;loc, const MeasureUnit &amp;unitRef, const MeasureUnit &amp;perUnit,
                                  const UNumberUnitWidth &amp;width, const PluralRules *rules,
                                  const MicroPropsGenerator *parent, UErrorCode &amp;status) {
      MeasureUnit unit = unitRef;
      if (uprv_strcmp(perUnit.getType(), &quot;none&quot;) != 0) {
<span class="line-new-header">--- 183,11 ---</span>
  /// END DATA LOADING ///
  ////////////////////////
  
  } // namespace
  
<span class="line-modified">! LongNameHandler*</span>
  LongNameHandler::forMeasureUnit(const Locale &amp;loc, const MeasureUnit &amp;unitRef, const MeasureUnit &amp;perUnit,
                                  const UNumberUnitWidth &amp;width, const PluralRules *rules,
                                  const MicroPropsGenerator *parent, UErrorCode &amp;status) {
      MeasureUnit unit = unitRef;
      if (uprv_strcmp(perUnit.getType(), &quot;none&quot;) != 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 171,24 ***</span>
              // No simplified form is available.
              return forCompoundUnit(loc, unit, perUnit, width, rules, parent, status);
          }
      }
  
<span class="line-modified">!     LongNameHandler result(rules, parent);</span>
      UnicodeString simpleFormats[ARRAY_LENGTH];
      getMeasureData(loc, unit, width, simpleFormats, status);
      if (U_FAILURE(status)) { return result; }
<span class="line-modified">!     // TODO: What field to use for units?</span>
<span class="line-removed">-     simpleFormatsToModifiers(simpleFormats, UNUM_FIELD_COUNT, result.fModifiers, status);</span>
      return result;
  }
  
<span class="line-modified">! LongNameHandler</span>
  LongNameHandler::forCompoundUnit(const Locale &amp;loc, const MeasureUnit &amp;unit, const MeasureUnit &amp;perUnit,
                                   const UNumberUnitWidth &amp;width, const PluralRules *rules,
                                   const MicroPropsGenerator *parent, UErrorCode &amp;status) {
<span class="line-modified">!     LongNameHandler result(rules, parent);</span>
      UnicodeString primaryData[ARRAY_LENGTH];
      getMeasureData(loc, unit, width, primaryData, status);
      if (U_FAILURE(status)) { return result; }
      UnicodeString secondaryData[ARRAY_LENGTH];
      getMeasureData(loc, perUnit, width, secondaryData, status);
<span class="line-new-header">--- 200,31 ---</span>
              // No simplified form is available.
              return forCompoundUnit(loc, unit, perUnit, width, rules, parent, status);
          }
      }
  
<span class="line-modified">!     auto* result = new LongNameHandler(rules, parent);</span>
<span class="line-added">+     if (result == nullptr) {</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
      UnicodeString simpleFormats[ARRAY_LENGTH];
      getMeasureData(loc, unit, width, simpleFormats, status);
      if (U_FAILURE(status)) { return result; }
<span class="line-modified">!     result-&gt;simpleFormatsToModifiers(simpleFormats, UNUM_MEASURE_UNIT_FIELD, status);</span>
      return result;
  }
  
<span class="line-modified">! LongNameHandler*</span>
  LongNameHandler::forCompoundUnit(const Locale &amp;loc, const MeasureUnit &amp;unit, const MeasureUnit &amp;perUnit,
                                   const UNumberUnitWidth &amp;width, const PluralRules *rules,
                                   const MicroPropsGenerator *parent, UErrorCode &amp;status) {
<span class="line-modified">!     auto* result = new LongNameHandler(rules, parent);</span>
<span class="line-added">+     if (result == nullptr) {</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
      UnicodeString primaryData[ARRAY_LENGTH];
      getMeasureData(loc, unit, width, primaryData, status);
      if (U_FAILURE(status)) { return result; }
      UnicodeString secondaryData[ARRAY_LENGTH];
      getMeasureData(loc, perUnit, width, secondaryData, status);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 210,59 ***</span>
          UnicodeString secondaryString = secondaryCompiled.getTextWithNoArguments().trim();
          // TODO: Why does UnicodeString need to be explicit in the following line?
          compiled.format(UnicodeString(u&quot;{0}&quot;), secondaryString, perUnitFormat, status);
          if (U_FAILURE(status)) { return result; }
      }
<span class="line-modified">!     // TODO: What field to use for units?</span>
<span class="line-removed">-     multiSimpleFormatsToModifiers(primaryData, perUnitFormat, UNUM_FIELD_COUNT, result.fModifiers, status);</span>
      return result;
  }
  
<span class="line-modified">! LongNameHandler LongNameHandler::forCurrencyLongNames(const Locale &amp;loc, const CurrencyUnit &amp;currency,</span>
                                                        const PluralRules *rules,
                                                        const MicroPropsGenerator *parent,
                                                        UErrorCode &amp;status) {
<span class="line-modified">!     LongNameHandler result(rules, parent);</span>
      UnicodeString simpleFormats[ARRAY_LENGTH];
      getCurrencyLongNameData(loc, currency, simpleFormats, status);
<span class="line-modified">!     if (U_FAILURE(status)) { return result; }</span>
<span class="line-modified">!     simpleFormatsToModifiers(simpleFormats, UNUM_CURRENCY_FIELD, result.fModifiers, status);</span>
      return result;
  }
  
  void LongNameHandler::simpleFormatsToModifiers(const UnicodeString *simpleFormats, Field field,
<span class="line-modified">!                                                SimpleModifier *output, UErrorCode &amp;status) {</span>
      for (int32_t i = 0; i &lt; StandardPlural::Form::COUNT; i++) {
<span class="line-modified">!         UnicodeString simpleFormat = getWithPlural(simpleFormats, i, status);</span>
          if (U_FAILURE(status)) { return; }
          SimpleFormatter compiledFormatter(simpleFormat, 0, 1, status);
          if (U_FAILURE(status)) { return; }
<span class="line-modified">!         output[i] = SimpleModifier(compiledFormatter, field, false);</span>
      }
  }
  
  void LongNameHandler::multiSimpleFormatsToModifiers(const UnicodeString *leadFormats, UnicodeString trailFormat,
<span class="line-modified">!                                                     Field field, SimpleModifier *output, UErrorCode &amp;status) {</span>
      SimpleFormatter trailCompiled(trailFormat, 1, 1, status);
      if (U_FAILURE(status)) { return; }
      for (int32_t i = 0; i &lt; StandardPlural::Form::COUNT; i++) {
<span class="line-modified">!         UnicodeString leadFormat = getWithPlural(leadFormats, i, status);</span>
          if (U_FAILURE(status)) { return; }
          UnicodeString compoundFormat;
          trailCompiled.format(leadFormat, compoundFormat, status);
          if (U_FAILURE(status)) { return; }
          SimpleFormatter compoundCompiled(compoundFormat, 0, 1, status);
          if (U_FAILURE(status)) { return; }
<span class="line-modified">!         output[i] = SimpleModifier(compoundCompiled, field, false);</span>
      }
  }
  
  void LongNameHandler::processQuantity(DecimalQuantity &amp;quantity, MicroProps &amp;micros,
                                        UErrorCode &amp;status) const {
      parent-&gt;processQuantity(quantity, micros, status);
<span class="line-modified">!     // TODO: Avoid the copy here?</span>
<span class="line-modified">!     DecimalQuantity copy(quantity);</span>
<span class="line-modified">!     micros.rounder.apply(copy, status);</span>
<span class="line-modified">!     micros.modOuter = &amp;fModifiers[utils::getStandardPlural(rules, copy)];</span>
  }
  
  #endif /* #if !UCONFIG_NO_FORMATTING */
<span class="line-new-header">--- 246,79 ---</span>
          UnicodeString secondaryString = secondaryCompiled.getTextWithNoArguments().trim();
          // TODO: Why does UnicodeString need to be explicit in the following line?
          compiled.format(UnicodeString(u&quot;{0}&quot;), secondaryString, perUnitFormat, status);
          if (U_FAILURE(status)) { return result; }
      }
<span class="line-modified">!     result-&gt;multiSimpleFormatsToModifiers(primaryData, perUnitFormat, UNUM_MEASURE_UNIT_FIELD, status);</span>
      return result;
  }
  
<span class="line-modified">! UnicodeString LongNameHandler::getUnitDisplayName(</span>
<span class="line-added">+         const Locale&amp; loc,</span>
<span class="line-added">+         const MeasureUnit&amp; unit,</span>
<span class="line-added">+         UNumberUnitWidth width,</span>
<span class="line-added">+         UErrorCode&amp; status) {</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return ICU_Utility::makeBogusString();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     UnicodeString simpleFormats[ARRAY_LENGTH];</span>
<span class="line-added">+     getMeasureData(loc, unit, width, simpleFormats, status);</span>
<span class="line-added">+     return simpleFormats[DNAM_INDEX];</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ LongNameHandler* LongNameHandler::forCurrencyLongNames(const Locale &amp;loc, const CurrencyUnit &amp;currency,</span>
                                                        const PluralRules *rules,
                                                        const MicroPropsGenerator *parent,
                                                        UErrorCode &amp;status) {
<span class="line-modified">!     auto* result = new LongNameHandler(rules, parent);</span>
<span class="line-added">+     if (result == nullptr) {</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
      UnicodeString simpleFormats[ARRAY_LENGTH];
      getCurrencyLongNameData(loc, currency, simpleFormats, status);
<span class="line-modified">!     if (U_FAILURE(status)) { return nullptr; }</span>
<span class="line-modified">!     result-&gt;simpleFormatsToModifiers(simpleFormats, UNUM_CURRENCY_FIELD, status);</span>
      return result;
  }
  
  void LongNameHandler::simpleFormatsToModifiers(const UnicodeString *simpleFormats, Field field,
<span class="line-modified">!                                                UErrorCode &amp;status) {</span>
      for (int32_t i = 0; i &lt; StandardPlural::Form::COUNT; i++) {
<span class="line-modified">!         StandardPlural::Form plural = static_cast&lt;StandardPlural::Form&gt;(i);</span>
<span class="line-added">+         UnicodeString simpleFormat = getWithPlural(simpleFormats, plural, status);</span>
          if (U_FAILURE(status)) { return; }
          SimpleFormatter compiledFormatter(simpleFormat, 0, 1, status);
          if (U_FAILURE(status)) { return; }
<span class="line-modified">!         fModifiers[i] = SimpleModifier(compiledFormatter, field, false, {this, 0, plural});</span>
      }
  }
  
  void LongNameHandler::multiSimpleFormatsToModifiers(const UnicodeString *leadFormats, UnicodeString trailFormat,
<span class="line-modified">!                                                     Field field, UErrorCode &amp;status) {</span>
      SimpleFormatter trailCompiled(trailFormat, 1, 1, status);
      if (U_FAILURE(status)) { return; }
      for (int32_t i = 0; i &lt; StandardPlural::Form::COUNT; i++) {
<span class="line-modified">!         StandardPlural::Form plural = static_cast&lt;StandardPlural::Form&gt;(i);</span>
<span class="line-added">+         UnicodeString leadFormat = getWithPlural(leadFormats, plural, status);</span>
          if (U_FAILURE(status)) { return; }
          UnicodeString compoundFormat;
          trailCompiled.format(leadFormat, compoundFormat, status);
          if (U_FAILURE(status)) { return; }
          SimpleFormatter compoundCompiled(compoundFormat, 0, 1, status);
          if (U_FAILURE(status)) { return; }
<span class="line-modified">!         fModifiers[i] = SimpleModifier(compoundCompiled, field, false, {this, 0, plural});</span>
      }
  }
  
  void LongNameHandler::processQuantity(DecimalQuantity &amp;quantity, MicroProps &amp;micros,
                                        UErrorCode &amp;status) const {
      parent-&gt;processQuantity(quantity, micros, status);
<span class="line-modified">!     StandardPlural::Form pluralForm = utils::getPluralSafe(micros.rounder, rules, quantity, status);</span>
<span class="line-modified">!     micros.modOuter = &amp;fModifiers[pluralForm];</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-added">+ const Modifier* LongNameHandler::getModifier(int8_t /*signum*/, StandardPlural::Form plural) const {</span>
<span class="line-added">+     return &amp;fModifiers[plural];</span>
  }
  
  #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
<center><a href="number_integerwidth.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_longnames.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>