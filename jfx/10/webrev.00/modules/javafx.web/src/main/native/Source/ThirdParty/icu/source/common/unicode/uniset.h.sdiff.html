<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/uniset.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="umachine.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="unistr.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/uniset.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ***************************************************************************
   5 * Copyright (C) 1999-2016, International Business Machines Corporation
   6 * and others. All Rights Reserved.
   7 ***************************************************************************
   8 *   Date        Name        Description
   9 *   10/20/99    alan        Creation.
  10 ***************************************************************************
  11 */
  12 
  13 #ifndef UNICODESET_H
  14 #define UNICODESET_H
  15 

  16 #include &quot;unicode/unifilt.h&quot;
  17 #include &quot;unicode/unistr.h&quot;
  18 #include &quot;unicode/uset.h&quot;
  19 
  20 /**
  21  * \file
  22  * \brief C++ API: Unicode Set
  23  */
  24 
  25 U_NAMESPACE_BEGIN
  26 
  27 // Forward Declarations.
<span class="line-removed">  28 void U_CALLCONV UnicodeSet_initInclusion(int32_t src, UErrorCode &amp;status); /**&lt; @internal */</span>
<span class="line-removed">  29 </span>
  30 class BMPSet;
  31 class ParsePosition;
  32 class RBBIRuleScanner;
  33 class SymbolTable;
  34 class UnicodeSetStringSpan;
  35 class UVector;
  36 class RuleCharacterIterator;
  37 
  38 /**
  39  * A mutable set of Unicode characters and multicharacter strings.  Objects of this class
  40  * represent &lt;em&gt;character classes&lt;/em&gt; used in regular expressions.
  41  * A character specifies a subset of Unicode code points.  Legal
  42  * code points are U+0000 to U+10FFFF, inclusive.
  43  *
  44  * &lt;p&gt;The UnicodeSet class is not designed to be subclassed.
  45  *
  46  * &lt;p&gt;&lt;code&gt;UnicodeSet&lt;/code&gt; supports two APIs. The first is the
  47  * &lt;em&gt;operand&lt;/em&gt; API that allows the caller to modify the value of
  48  * a &lt;code&gt;UnicodeSet&lt;/code&gt; object. It conforms to Java 2&#39;s
  49  * &lt;code&gt;java.util.Set&lt;/code&gt; interface, although
</pre>
<hr />
<pre>
 259  *         &lt;/tr&gt;
 260  *       &lt;/table&gt;
 261  *       &lt;/td&gt;
 262  *     &lt;/tr&gt;
 263  *   &lt;/table&gt;
 264  * \htmlonly&lt;/blockquote&gt;\endhtmlonly
 265  *
 266  * &lt;p&gt;Note:
 267  *  - Most UnicodeSet methods do not take a UErrorCode parameter because
 268  *   there are usually very few opportunities for failure other than a shortage
 269  *   of memory, error codes in low-level C++ string methods would be inconvenient,
 270  *   and the error code as the last parameter (ICU convention) would prevent
 271  *   the use of default parameter values.
 272  *   Instead, such methods set the UnicodeSet into a &quot;bogus&quot; state
 273  *   (see isBogus()) if an error occurs.
 274  *
 275  * @author Alan Liu
 276  * @stable ICU 2.0
 277  */
 278 class U_COMMON_API UnicodeSet U_FINAL : public UnicodeFilter {








 279 
<span class="line-modified"> 280     int32_t len; // length of list used; 0 &lt;= len &lt;= capacity</span>
<span class="line-modified"> 281     int32_t capacity; // capacity of list</span>
<span class="line-modified"> 282     UChar32* list; // MUST be terminated with HIGH</span>
<span class="line-modified"> 283     BMPSet *bmpSet; // The set is frozen iff either bmpSet or stringSpan is not NULL.</span>
<span class="line-modified"> 284     UChar32* buffer; // internal buffer, may be NULL</span>
<span class="line-modified"> 285     int32_t bufferCapacity; // capacity of buffer</span>
<span class="line-modified"> 286     int32_t patLen;</span>

 287 
 288     /**
 289      * The pattern representation of this set.  This may not be the
 290      * most economical pattern.  It is the pattern supplied to
 291      * applyPattern(), with variables substituted and whitespace
 292      * removed.  For sets constructed without applyPattern(), or
 293      * modified using the non-pattern API, this string will be empty,
 294      * indicating that toPattern() must generate a pattern
 295      * representation from the inversion list.
 296      */
<span class="line-modified"> 297     char16_t *pat;</span>
<span class="line-modified"> 298     UVector* strings; // maintained in sorted order</span>
<span class="line-modified"> 299     UnicodeSetStringSpan *stringSpan;</span>









 300 
<span class="line-removed"> 301 private:</span>
<span class="line-removed"> 302     enum { // constants</span>
<span class="line-removed"> 303         kIsBogus = 1       // This set is bogus (i.e. not valid)</span>
<span class="line-removed"> 304     };</span>
<span class="line-removed"> 305     uint8_t fFlags;         // Bit flag (see constants above)</span>
 306 public:
 307     /**
 308      * Determine if this object contains a valid set.
 309      * A bogus set has no value. It is different from an empty set.
 310      * It can be used to indicate that no set value is available.
 311      *
 312      * @return TRUE if the set is bogus/invalid, FALSE otherwise
 313      * @see setToBogus()
 314      * @stable ICU 4.0
 315      */
 316     inline UBool isBogus(void) const;
 317 
 318     /**
 319      * Make this UnicodeSet object invalid.
 320      * The string will test TRUE with isBogus().
 321      *
 322      * A bogus set has no value. It is different from an empty set.
 323      * It can be used to indicate that no set value is available.
 324      *
 325      * This utility function is used throughout the UnicodeSet
</pre>
<hr />
<pre>
 461     UnicodeSet&amp; operator=(const UnicodeSet&amp; o);
 462 
 463     /**
 464      * Compares the specified object with this set for equality.  Returns
 465      * &lt;tt&gt;true&lt;/tt&gt; if the two sets
 466      * have the same size, and every member of the specified set is
 467      * contained in this set (or equivalently, every member of this set is
 468      * contained in the specified set).
 469      *
 470      * @param o set to be compared for equality with this set.
 471      * @return &lt;tt&gt;true&lt;/tt&gt; if the specified set is equal to this set.
 472      * @stable ICU 2.0
 473      */
 474     virtual UBool operator==(const UnicodeSet&amp; o) const;
 475 
 476     /**
 477      * Compares the specified object with this set for equality.  Returns
 478      * &lt;tt&gt;true&lt;/tt&gt; if the specified set is not equal to this set.
 479      * @stable ICU 2.0
 480      */
<span class="line-modified"> 481     UBool operator!=(const UnicodeSet&amp; o) const;</span>
 482 
 483     /**
 484      * Returns a copy of this object.  All UnicodeFunctor objects have
 485      * to support cloning in order to allow classes using
 486      * UnicodeFunctors, such as Transliterator, to implement cloning.
 487      * If this set is frozen, then the clone will be frozen as well.
 488      * Use cloneAsThawed() for a mutable clone of a frozen set.
 489      * @see cloneAsThawed
 490      * @stable ICU 2.0
 491      */
 492     virtual UnicodeFunctor* clone() const;
 493 
 494     /**
 495      * Returns the hash code value for this set.
 496      *
 497      * @return the hash code value for this set.
 498      * @see Object#hashCode()
 499      * @stable ICU 2.0
 500      */
 501     virtual int32_t hashCode(void) const;
</pre>
<hr />
<pre>
 567      * @see cloneAsThawed
 568      * @stable ICU 3.8
 569      */
 570     UnicodeFunctor *freeze();
 571 
 572     /**
 573      * Clone the set and make the clone mutable.
 574      * See the ICU4J Freezable interface for details.
 575      * @return the mutable clone
 576      * @see freeze
 577      * @see isFrozen
 578      * @stable ICU 3.8
 579      */
 580     UnicodeFunctor *cloneAsThawed() const;
 581 
 582     //----------------------------------------------------------------
 583     // Public API
 584     //----------------------------------------------------------------
 585 
 586     /**
<span class="line-modified"> 587      * Make this object represent the range &lt;code&gt;start - end&lt;/code&gt;.</span>
<span class="line-modified"> 588      * If &lt;code&gt;end &gt; start&lt;/code&gt; then this object is set to an</span>
<span class="line-removed"> 589      * an empty range.</span>
 590      * A frozen set will not be modified.
 591      *
 592      * @param start first character in the set, inclusive
 593      * @param end last character in the set, inclusive
 594      * @stable ICU 2.4
 595      */
 596     UnicodeSet&amp; set(UChar32 start, UChar32 end);
 597 
 598     /**
 599      * Return true if the given position, in the given pattern, appears
 600      * to be the start of a UnicodeSet pattern.
 601      * @stable ICU 2.4
 602      */
 603     static UBool resemblesPattern(const UnicodeString&amp; pattern,
 604                                   int32_t pos);
 605 
 606     /**
 607      * Modifies this set to represent the set specified by the given
 608      * pattern, ignoring Unicode Pattern_White_Space characters.
 609      * See the class description for the syntax of the pattern language.
</pre>
<hr />
<pre>
1464      * @stable ICU 2.0
1465      */
1466     static UClassID U_EXPORT2 getStaticClassID(void);
1467 
1468     /**
1469      * Implement UnicodeFunctor API.
1470      *
1471      * @return The class ID for this object. All objects of a given
1472      * class have the same class ID.  Objects of other classes have
1473      * different class IDs.
1474      * @stable ICU 2.4
1475      */
1476     virtual UClassID getDynamicClassID(void) const;
1477 
1478 private:
1479 
1480     // Private API for the USet API
1481 
1482     friend class USetAccess;
1483 
<span class="line-removed">1484     int32_t getStringCount() const;</span>
<span class="line-removed">1485 </span>
1486     const UnicodeString* getString(int32_t index) const;
1487 
1488     //----------------------------------------------------------------
1489     // RuleBasedTransliterator support
1490     //----------------------------------------------------------------
1491 
1492 private:
1493 
1494     /**
1495      * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains any character whose low byte
1496      * is the given value.  This is used by &lt;tt&gt;RuleBasedTransliterator&lt;/tt&gt; for
1497      * indexing.
1498      */
1499     virtual UBool matchesIndexValue(uint8_t v) const;
1500 
1501 private:
1502     friend class RBBIRuleScanner;
1503 
1504     //----------------------------------------------------------------
1505     // Implementation: Clone as thawed (see ICU4J Freezable)
1506     //----------------------------------------------------------------
1507 
1508     UnicodeSet(const UnicodeSet&amp; o, UBool /* asThawed */);

1509 
1510     //----------------------------------------------------------------
1511     // Implementation: Pattern parsing
1512     //----------------------------------------------------------------
1513 
1514     void applyPatternIgnoreSpace(const UnicodeString&amp; pattern,
1515                                  ParsePosition&amp; pos,
1516                                  const SymbolTable* symbols,
1517                                  UErrorCode&amp; status);
1518 
1519     void applyPattern(RuleCharacterIterator&amp; chars,
1520                       const SymbolTable* symbols,
1521                       UnicodeString&amp; rebuiltPat,
1522                       uint32_t options,
1523                       UnicodeSet&amp; (UnicodeSet::*caseClosure)(int32_t attribute),
1524                       int32_t depth,
1525                       UErrorCode&amp; ec);
1526 
1527     //----------------------------------------------------------------
1528     // Implementation: Utility methods
1529     //----------------------------------------------------------------
1530 
<span class="line-modified">1531     void ensureCapacity(int32_t newLen, UErrorCode&amp; ec);</span>


1532 
<span class="line-modified">1533     void ensureBufferCapacity(int32_t newLen, UErrorCode&amp; ec);</span>
1534 
1535     void swapBuffers(void);
1536 
1537     UBool allocateStrings(UErrorCode &amp;status);



1538 
1539     UnicodeString&amp; _toPattern(UnicodeString&amp; result,
1540                               UBool escapeUnprintable) const;
1541 
1542     UnicodeString&amp; _generatePattern(UnicodeString&amp; result,
1543                                     UBool escapeUnprintable) const;
1544 
1545     static void _appendToPat(UnicodeString&amp; buf, const UnicodeString&amp; s, UBool escapeUnprintable);
1546 
1547     static void _appendToPat(UnicodeString&amp; buf, UChar32 c, UBool escapeUnprintable);
1548 
1549     //----------------------------------------------------------------
1550     // Implementation: Fundamental operators
1551     //----------------------------------------------------------------
1552 
1553     void exclusiveOr(const UChar32* other, int32_t otherLen, int8_t polarity);
1554 
1555     void add(const UChar32* other, int32_t otherLen, int8_t polarity);
1556 
1557     void retain(const UChar32* other, int32_t otherLen, int8_t polarity);
</pre>
<hr />
<pre>
1597      * @param ppos on entry, the position at which to begin parsing.
1598      * This should be one of the locations marked &#39;^&#39;:
1599      *
1600      *   [:blah:]     \\p{blah}     \\P{blah}     \\N{name}
1601      *   ^       %    ^       %    ^       %    ^       %
1602      *
1603      * On return, the position after the last character parsed, that is,
1604      * the locations marked &#39;%&#39;.  If the parse fails, ppos is returned
1605      * unchanged.
1606      * @param ec status
1607      * @return a reference to this.
1608      */
1609     UnicodeSet&amp; applyPropertyPattern(const UnicodeString&amp; pattern,
1610                                      ParsePosition&amp; ppos,
1611                                      UErrorCode &amp;ec);
1612 
1613     void applyPropertyPattern(RuleCharacterIterator&amp; chars,
1614                               UnicodeString&amp; rebuiltPat,
1615                               UErrorCode&amp; ec);
1616 
<span class="line-removed">1617     friend void U_CALLCONV UnicodeSet_initInclusion(int32_t src, UErrorCode &amp;status);</span>
1618     static const UnicodeSet* getInclusions(int32_t src, UErrorCode &amp;status);
1619 
1620     /**
1621      * A filter that returns TRUE if the given code point should be
1622      * included in the UnicodeSet being constructed.
1623      */
1624     typedef UBool (*Filter)(UChar32 codePoint, void* context);
1625 
1626     /**
1627      * Given a filter, set this UnicodeSet to the code points
1628      * contained by that filter.  The filter MUST be
1629      * property-conformant.  That is, if it returns value v for one
1630      * code point, then it must return v for all affiliated code
1631      * points, as defined by the inclusions list.  See
1632      * getInclusions().
1633      * src is a UPropertySource value.
1634      */
1635     void applyFilter(Filter filter,
1636                      void* context,
<span class="line-modified">1637                      int32_t src,</span>
1638                      UErrorCode &amp;status);
1639 






1640     /**
1641      * Set the new pattern to cache.
1642      */
<span class="line-modified">1643     void setPattern(const UnicodeString&amp; newPat);</span>



1644     /**
1645      * Release existing cached pattern.
1646      */
1647     void releasePattern();
1648 
1649     friend class UnicodeSetIterator;
1650 };
1651 
1652 
1653 
1654 inline UBool UnicodeSet::operator!=(const UnicodeSet&amp; o) const {
1655     return !operator==(o);
1656 }
1657 
1658 inline UBool UnicodeSet::isFrozen() const {
1659     return (UBool)(bmpSet!=NULL || stringSpan!=NULL);
1660 }
1661 
1662 inline UBool UnicodeSet::containsSome(UChar32 start, UChar32 end) const {
1663     return !containsNone(start, end);
</pre>
</td>
<td>
<hr />
<pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ***************************************************************************
   5 * Copyright (C) 1999-2016, International Business Machines Corporation
   6 * and others. All Rights Reserved.
   7 ***************************************************************************
   8 *   Date        Name        Description
   9 *   10/20/99    alan        Creation.
  10 ***************************************************************************
  11 */
  12 
  13 #ifndef UNICODESET_H
  14 #define UNICODESET_H
  15 
<span class="line-added">  16 #include &quot;unicode/ucpmap.h&quot;</span>
  17 #include &quot;unicode/unifilt.h&quot;
  18 #include &quot;unicode/unistr.h&quot;
  19 #include &quot;unicode/uset.h&quot;
  20 
  21 /**
  22  * \file
  23  * \brief C++ API: Unicode Set
  24  */
  25 
  26 U_NAMESPACE_BEGIN
  27 
  28 // Forward Declarations.


  29 class BMPSet;
  30 class ParsePosition;
  31 class RBBIRuleScanner;
  32 class SymbolTable;
  33 class UnicodeSetStringSpan;
  34 class UVector;
  35 class RuleCharacterIterator;
  36 
  37 /**
  38  * A mutable set of Unicode characters and multicharacter strings.  Objects of this class
  39  * represent &lt;em&gt;character classes&lt;/em&gt; used in regular expressions.
  40  * A character specifies a subset of Unicode code points.  Legal
  41  * code points are U+0000 to U+10FFFF, inclusive.
  42  *
  43  * &lt;p&gt;The UnicodeSet class is not designed to be subclassed.
  44  *
  45  * &lt;p&gt;&lt;code&gt;UnicodeSet&lt;/code&gt; supports two APIs. The first is the
  46  * &lt;em&gt;operand&lt;/em&gt; API that allows the caller to modify the value of
  47  * a &lt;code&gt;UnicodeSet&lt;/code&gt; object. It conforms to Java 2&#39;s
  48  * &lt;code&gt;java.util.Set&lt;/code&gt; interface, although
</pre>
<hr />
<pre>
 258  *         &lt;/tr&gt;
 259  *       &lt;/table&gt;
 260  *       &lt;/td&gt;
 261  *     &lt;/tr&gt;
 262  *   &lt;/table&gt;
 263  * \htmlonly&lt;/blockquote&gt;\endhtmlonly
 264  *
 265  * &lt;p&gt;Note:
 266  *  - Most UnicodeSet methods do not take a UErrorCode parameter because
 267  *   there are usually very few opportunities for failure other than a shortage
 268  *   of memory, error codes in low-level C++ string methods would be inconvenient,
 269  *   and the error code as the last parameter (ICU convention) would prevent
 270  *   the use of default parameter values.
 271  *   Instead, such methods set the UnicodeSet into a &quot;bogus&quot; state
 272  *   (see isBogus()) if an error occurs.
 273  *
 274  * @author Alan Liu
 275  * @stable ICU 2.0
 276  */
 277 class U_COMMON_API UnicodeSet U_FINAL : public UnicodeFilter {
<span class="line-added"> 278 private:</span>
<span class="line-added"> 279     /**</span>
<span class="line-added"> 280      * Enough for sets with few ranges.</span>
<span class="line-added"> 281      * For example, White_Space has 10 ranges, list length 21.</span>
<span class="line-added"> 282      */</span>
<span class="line-added"> 283     static constexpr int32_t INITIAL_CAPACITY = 25;</span>
<span class="line-added"> 284     // fFlags constant</span>
<span class="line-added"> 285     static constexpr uint8_t kIsBogus = 1;  // This set is bogus (i.e. not valid)</span>
 286 
<span class="line-modified"> 287     UChar32* list = stackList; // MUST be terminated with HIGH</span>
<span class="line-modified"> 288     int32_t capacity = INITIAL_CAPACITY; // capacity of list</span>
<span class="line-modified"> 289     int32_t len = 1; // length of list used; 1 &lt;= len &lt;= capacity</span>
<span class="line-modified"> 290     uint8_t fFlags = 0;         // Bit flag (see constants above)</span>
<span class="line-modified"> 291 </span>
<span class="line-modified"> 292     BMPSet *bmpSet = nullptr; // The set is frozen iff either bmpSet or stringSpan is not NULL.</span>
<span class="line-modified"> 293     UChar32* buffer = nullptr; // internal buffer, may be NULL</span>
<span class="line-added"> 294     int32_t bufferCapacity = 0; // capacity of buffer</span>
 295 
 296     /**
 297      * The pattern representation of this set.  This may not be the
 298      * most economical pattern.  It is the pattern supplied to
 299      * applyPattern(), with variables substituted and whitespace
 300      * removed.  For sets constructed without applyPattern(), or
 301      * modified using the non-pattern API, this string will be empty,
 302      * indicating that toPattern() must generate a pattern
 303      * representation from the inversion list.
 304      */
<span class="line-modified"> 305     char16_t *pat = nullptr;</span>
<span class="line-modified"> 306     int32_t patLen = 0;</span>
<span class="line-modified"> 307 </span>
<span class="line-added"> 308     UVector* strings = nullptr; // maintained in sorted order</span>
<span class="line-added"> 309     UnicodeSetStringSpan *stringSpan = nullptr;</span>
<span class="line-added"> 310 </span>
<span class="line-added"> 311     /**</span>
<span class="line-added"> 312      * Initial list array.</span>
<span class="line-added"> 313      * Avoids some heap allocations, and list is never nullptr.</span>
<span class="line-added"> 314      * Increases the object size a bit.</span>
<span class="line-added"> 315      */</span>
<span class="line-added"> 316     UChar32 stackList[INITIAL_CAPACITY];</span>
 317 





 318 public:
 319     /**
 320      * Determine if this object contains a valid set.
 321      * A bogus set has no value. It is different from an empty set.
 322      * It can be used to indicate that no set value is available.
 323      *
 324      * @return TRUE if the set is bogus/invalid, FALSE otherwise
 325      * @see setToBogus()
 326      * @stable ICU 4.0
 327      */
 328     inline UBool isBogus(void) const;
 329 
 330     /**
 331      * Make this UnicodeSet object invalid.
 332      * The string will test TRUE with isBogus().
 333      *
 334      * A bogus set has no value. It is different from an empty set.
 335      * It can be used to indicate that no set value is available.
 336      *
 337      * This utility function is used throughout the UnicodeSet
</pre>
<hr />
<pre>
 473     UnicodeSet&amp; operator=(const UnicodeSet&amp; o);
 474 
 475     /**
 476      * Compares the specified object with this set for equality.  Returns
 477      * &lt;tt&gt;true&lt;/tt&gt; if the two sets
 478      * have the same size, and every member of the specified set is
 479      * contained in this set (or equivalently, every member of this set is
 480      * contained in the specified set).
 481      *
 482      * @param o set to be compared for equality with this set.
 483      * @return &lt;tt&gt;true&lt;/tt&gt; if the specified set is equal to this set.
 484      * @stable ICU 2.0
 485      */
 486     virtual UBool operator==(const UnicodeSet&amp; o) const;
 487 
 488     /**
 489      * Compares the specified object with this set for equality.  Returns
 490      * &lt;tt&gt;true&lt;/tt&gt; if the specified set is not equal to this set.
 491      * @stable ICU 2.0
 492      */
<span class="line-modified"> 493     inline UBool operator!=(const UnicodeSet&amp; o) const;</span>
 494 
 495     /**
 496      * Returns a copy of this object.  All UnicodeFunctor objects have
 497      * to support cloning in order to allow classes using
 498      * UnicodeFunctors, such as Transliterator, to implement cloning.
 499      * If this set is frozen, then the clone will be frozen as well.
 500      * Use cloneAsThawed() for a mutable clone of a frozen set.
 501      * @see cloneAsThawed
 502      * @stable ICU 2.0
 503      */
 504     virtual UnicodeFunctor* clone() const;
 505 
 506     /**
 507      * Returns the hash code value for this set.
 508      *
 509      * @return the hash code value for this set.
 510      * @see Object#hashCode()
 511      * @stable ICU 2.0
 512      */
 513     virtual int32_t hashCode(void) const;
</pre>
<hr />
<pre>
 579      * @see cloneAsThawed
 580      * @stable ICU 3.8
 581      */
 582     UnicodeFunctor *freeze();
 583 
 584     /**
 585      * Clone the set and make the clone mutable.
 586      * See the ICU4J Freezable interface for details.
 587      * @return the mutable clone
 588      * @see freeze
 589      * @see isFrozen
 590      * @stable ICU 3.8
 591      */
 592     UnicodeFunctor *cloneAsThawed() const;
 593 
 594     //----------------------------------------------------------------
 595     // Public API
 596     //----------------------------------------------------------------
 597 
 598     /**
<span class="line-modified"> 599      * Make this object represent the range `start - end`.</span>
<span class="line-modified"> 600      * If `end &gt; start` then this object is set to an empty range.</span>

 601      * A frozen set will not be modified.
 602      *
 603      * @param start first character in the set, inclusive
 604      * @param end last character in the set, inclusive
 605      * @stable ICU 2.4
 606      */
 607     UnicodeSet&amp; set(UChar32 start, UChar32 end);
 608 
 609     /**
 610      * Return true if the given position, in the given pattern, appears
 611      * to be the start of a UnicodeSet pattern.
 612      * @stable ICU 2.4
 613      */
 614     static UBool resemblesPattern(const UnicodeString&amp; pattern,
 615                                   int32_t pos);
 616 
 617     /**
 618      * Modifies this set to represent the set specified by the given
 619      * pattern, ignoring Unicode Pattern_White_Space characters.
 620      * See the class description for the syntax of the pattern language.
</pre>
<hr />
<pre>
1475      * @stable ICU 2.0
1476      */
1477     static UClassID U_EXPORT2 getStaticClassID(void);
1478 
1479     /**
1480      * Implement UnicodeFunctor API.
1481      *
1482      * @return The class ID for this object. All objects of a given
1483      * class have the same class ID.  Objects of other classes have
1484      * different class IDs.
1485      * @stable ICU 2.4
1486      */
1487     virtual UClassID getDynamicClassID(void) const;
1488 
1489 private:
1490 
1491     // Private API for the USet API
1492 
1493     friend class USetAccess;
1494 


1495     const UnicodeString* getString(int32_t index) const;
1496 
1497     //----------------------------------------------------------------
1498     // RuleBasedTransliterator support
1499     //----------------------------------------------------------------
1500 
1501 private:
1502 
1503     /**
1504      * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains any character whose low byte
1505      * is the given value.  This is used by &lt;tt&gt;RuleBasedTransliterator&lt;/tt&gt; for
1506      * indexing.
1507      */
1508     virtual UBool matchesIndexValue(uint8_t v) const;
1509 
1510 private:
1511     friend class RBBIRuleScanner;
1512 
1513     //----------------------------------------------------------------
1514     // Implementation: Clone as thawed (see ICU4J Freezable)
1515     //----------------------------------------------------------------
1516 
1517     UnicodeSet(const UnicodeSet&amp; o, UBool /* asThawed */);
<span class="line-added">1518     UnicodeSet&amp; copyFrom(const UnicodeSet&amp; o, UBool asThawed);</span>
1519 
1520     //----------------------------------------------------------------
1521     // Implementation: Pattern parsing
1522     //----------------------------------------------------------------
1523 
1524     void applyPatternIgnoreSpace(const UnicodeString&amp; pattern,
1525                                  ParsePosition&amp; pos,
1526                                  const SymbolTable* symbols,
1527                                  UErrorCode&amp; status);
1528 
1529     void applyPattern(RuleCharacterIterator&amp; chars,
1530                       const SymbolTable* symbols,
1531                       UnicodeString&amp; rebuiltPat,
1532                       uint32_t options,
1533                       UnicodeSet&amp; (UnicodeSet::*caseClosure)(int32_t attribute),
1534                       int32_t depth,
1535                       UErrorCode&amp; ec);
1536 
1537     //----------------------------------------------------------------
1538     // Implementation: Utility methods
1539     //----------------------------------------------------------------
1540 
<span class="line-modified">1541     static int32_t nextCapacity(int32_t minCapacity);</span>
<span class="line-added">1542 </span>
<span class="line-added">1543     bool ensureCapacity(int32_t newLen);</span>
1544 
<span class="line-modified">1545     bool ensureBufferCapacity(int32_t newLen);</span>
1546 
1547     void swapBuffers(void);
1548 
1549     UBool allocateStrings(UErrorCode &amp;status);
<span class="line-added">1550     UBool hasStrings() const;</span>
<span class="line-added">1551     int32_t stringsSize() const;</span>
<span class="line-added">1552     UBool stringsContains(const UnicodeString &amp;s) const;</span>
1553 
1554     UnicodeString&amp; _toPattern(UnicodeString&amp; result,
1555                               UBool escapeUnprintable) const;
1556 
1557     UnicodeString&amp; _generatePattern(UnicodeString&amp; result,
1558                                     UBool escapeUnprintable) const;
1559 
1560     static void _appendToPat(UnicodeString&amp; buf, const UnicodeString&amp; s, UBool escapeUnprintable);
1561 
1562     static void _appendToPat(UnicodeString&amp; buf, UChar32 c, UBool escapeUnprintable);
1563 
1564     //----------------------------------------------------------------
1565     // Implementation: Fundamental operators
1566     //----------------------------------------------------------------
1567 
1568     void exclusiveOr(const UChar32* other, int32_t otherLen, int8_t polarity);
1569 
1570     void add(const UChar32* other, int32_t otherLen, int8_t polarity);
1571 
1572     void retain(const UChar32* other, int32_t otherLen, int8_t polarity);
</pre>
<hr />
<pre>
1612      * @param ppos on entry, the position at which to begin parsing.
1613      * This should be one of the locations marked &#39;^&#39;:
1614      *
1615      *   [:blah:]     \\p{blah}     \\P{blah}     \\N{name}
1616      *   ^       %    ^       %    ^       %    ^       %
1617      *
1618      * On return, the position after the last character parsed, that is,
1619      * the locations marked &#39;%&#39;.  If the parse fails, ppos is returned
1620      * unchanged.
1621      * @param ec status
1622      * @return a reference to this.
1623      */
1624     UnicodeSet&amp; applyPropertyPattern(const UnicodeString&amp; pattern,
1625                                      ParsePosition&amp; ppos,
1626                                      UErrorCode &amp;ec);
1627 
1628     void applyPropertyPattern(RuleCharacterIterator&amp; chars,
1629                               UnicodeString&amp; rebuiltPat,
1630                               UErrorCode&amp; ec);
1631 

1632     static const UnicodeSet* getInclusions(int32_t src, UErrorCode &amp;status);
1633 
1634     /**
1635      * A filter that returns TRUE if the given code point should be
1636      * included in the UnicodeSet being constructed.
1637      */
1638     typedef UBool (*Filter)(UChar32 codePoint, void* context);
1639 
1640     /**
1641      * Given a filter, set this UnicodeSet to the code points
1642      * contained by that filter.  The filter MUST be
1643      * property-conformant.  That is, if it returns value v for one
1644      * code point, then it must return v for all affiliated code
1645      * points, as defined by the inclusions list.  See
1646      * getInclusions().
1647      * src is a UPropertySource value.
1648      */
1649     void applyFilter(Filter filter,
1650                      void* context,
<span class="line-modified">1651                      const UnicodeSet* inclusions,</span>
1652                      UErrorCode &amp;status);
1653 
<span class="line-added">1654 #ifndef U_HIDE_DRAFT_API   // Skipped: ucpmap.h is draft only.</span>
<span class="line-added">1655     void applyIntPropertyValue(const UCPMap *map,</span>
<span class="line-added">1656                                UCPMapValueFilter *filter, const void *context,</span>
<span class="line-added">1657                                UErrorCode &amp;errorCode);</span>
<span class="line-added">1658 #endif  /* U_HIDE_DRAFT_API */</span>
<span class="line-added">1659 </span>
1660     /**
1661      * Set the new pattern to cache.
1662      */
<span class="line-modified">1663     void setPattern(const UnicodeString&amp; newPat) {</span>
<span class="line-added">1664         setPattern(newPat.getBuffer(), newPat.length());</span>
<span class="line-added">1665     }</span>
<span class="line-added">1666     void setPattern(const char16_t *newPat, int32_t newPatLen);</span>
1667     /**
1668      * Release existing cached pattern.
1669      */
1670     void releasePattern();
1671 
1672     friend class UnicodeSetIterator;
1673 };
1674 
1675 
1676 
1677 inline UBool UnicodeSet::operator!=(const UnicodeSet&amp; o) const {
1678     return !operator==(o);
1679 }
1680 
1681 inline UBool UnicodeSet::isFrozen() const {
1682     return (UBool)(bmpSet!=NULL || stringSpan!=NULL);
1683 }
1684 
1685 inline UBool UnicodeSet::containsSome(UChar32 start, UChar32 end) const {
1686     return !containsNone(start, end);
</pre>
</td>
</tr>
</table>
<center><a href="umachine.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="unistr.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>