<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/smpdtfmt.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 * Copyright (C) 1997-2016, International Business Machines Corporation and
   5 * others. All Rights Reserved.
   6 *******************************************************************************
   7 *
   8 * File SMPDTFMT.H
   9 *
  10 * Modification History:
  11 *
  12 *   Date        Name        Description
  13 *   02/19/97    aliu        Converted from java.
  14 *   07/09/97    helena      Make ParsePosition into a class.
  15 *   07/21/98    stephen     Added GMT_PLUS, GMT_MINUS
  16 *                            Changed setTwoDigitStartDate to set2DigitYearStart
  17 *                            Changed getTwoDigitStartDate to get2DigitYearStart
  18 *                            Removed subParseLong
  19 *                            Removed getZoneIndex (added in DateFormatSymbols)
  20 *   06/14/99    stephen     Removed fgTimeZoneDataSuffix
  21 *   10/14/99    aliu        Updated class doc to describe 2-digit year parsing
  22 *                           {j28 4182066}.
  23 *******************************************************************************
  24 */
  25 
  26 #ifndef SMPDTFMT_H
  27 #define SMPDTFMT_H
  28 
  29 #include &quot;unicode/utypes.h&quot;
  30 
  31 /**
  32  * \file
  33  * \brief C++ API: Format and parse dates in a language-independent manner.
  34  */
  35 
  36 #if !UCONFIG_NO_FORMATTING
  37 
  38 #include &quot;unicode/datefmt.h&quot;
  39 #include &quot;unicode/udisplaycontext.h&quot;
  40 #include &quot;unicode/tzfmt.h&quot;  /* for UTimeZoneFormatTimeType */
  41 #include &quot;unicode/brkiter.h&quot;
  42 
  43 U_NAMESPACE_BEGIN
  44 
  45 class DateFormatSymbols;
  46 class DateFormat;
  47 class MessageFormat;
  48 class FieldPositionHandler;
  49 class TimeZoneFormat;
  50 class SharedNumberFormat;
  51 class SimpleDateFormatMutableNFs;
<a name="1" id="anc1"></a>
  52 
  53 namespace number {
  54 class LocalizedNumberFormatter;
  55 }
  56 
  57 /**
  58  *
  59  * SimpleDateFormat is a concrete class for formatting and parsing dates in a
  60  * language-independent manner. It allows for formatting (millis -&gt; text),
  61  * parsing (text -&gt; millis), and normalization. Formats/Parses a date or time,
  62  * which is the standard milliseconds since 24:00 GMT, Jan 1, 1970.
  63  * &lt;P&gt;
  64  * Clients are encouraged to create a date-time formatter using DateFormat::getInstance(),
  65  * getDateInstance(), getDateInstance(), or getDateTimeInstance() rather than
  66  * explicitly constructing an instance of SimpleDateFormat.  This way, the client
  67  * is guaranteed to get an appropriate formatting pattern for whatever locale the
  68  * program is running in.  However, if the client needs something more unusual than
  69  * the default patterns in the locales, he can construct a SimpleDateFormat directly
  70  * and give it an appropriate pattern (or use one of the factory methods on DateFormat
  71  * and modify the pattern after the fact with toPattern() and applyPattern().
  72  *
  73  * &lt;p&gt;&lt;strong&gt;Date and Time Patterns:&lt;/strong&gt;&lt;/p&gt;
  74  *
  75  * &lt;p&gt;Date and time formats are specified by &lt;em&gt;date and time pattern&lt;/em&gt; strings.
  76  * Within date and time pattern strings, all unquoted ASCII letters [A-Za-z] are reserved
  77  * as pattern letters representing calendar fields. &lt;code&gt;SimpleDateFormat&lt;/code&gt; supports
  78  * the date and time formatting algorithm and pattern letters defined by
  79  * &lt;a href=&quot;http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table&quot;&gt;UTS#35
  80  * Unicode Locale Data Markup Language (LDML)&lt;/a&gt; and further documented for ICU in the
  81  * &lt;a href=&quot;https://sites.google.com/site/icuprojectuserguide/formatparse/datetime?pli=1#TOC-Date-Field-Symbol-Table&quot;&gt;ICU
  82  * User Guide&lt;/a&gt;. The following pattern letters are currently available (note that the actual
  83  * values depend on CLDR and may change from the examples shown here):&lt;/p&gt;
  84  *
  85  * &lt;table border=&quot;1&quot;&gt;
  86  *     &lt;tr&gt;
  87  *         &lt;th&gt;Field&lt;/th&gt;
  88  *         &lt;th style=&quot;text-align: center&quot;&gt;Sym.&lt;/th&gt;
  89  *         &lt;th style=&quot;text-align: center&quot;&gt;No.&lt;/th&gt;
  90  *         &lt;th&gt;Example&lt;/th&gt;
  91  *         &lt;th&gt;Description&lt;/th&gt;
  92  *     &lt;/tr&gt;
  93  *     &lt;tr&gt;
  94  *         &lt;th rowspan=&quot;3&quot;&gt;era&lt;/th&gt;
  95  *         &lt;td style=&quot;text-align: center&quot; rowspan=&quot;3&quot;&gt;G&lt;/td&gt;
  96  *         &lt;td style=&quot;text-align: center&quot;&gt;1..3&lt;/td&gt;
  97  *         &lt;td&gt;AD&lt;/td&gt;
  98  *         &lt;td rowspan=&quot;3&quot;&gt;Era - Replaced with the Era string for the current date. One to three letters for the
  99  *         abbreviated form, four letters for the long (wide) form, five for the narrow form.&lt;/td&gt;
 100  *     &lt;/tr&gt;
 101  *     &lt;tr&gt;
 102  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 103  *         &lt;td&gt;Anno Domini&lt;/td&gt;
 104  *     &lt;/tr&gt;
 105  *     &lt;tr&gt;
 106  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 107  *         &lt;td&gt;A&lt;/td&gt;
 108  *     &lt;/tr&gt;
 109  *     &lt;tr&gt;
 110  *         &lt;th rowspan=&quot;6&quot;&gt;year&lt;/th&gt;
 111  *         &lt;td style=&quot;text-align: center&quot;&gt;y&lt;/td&gt;
 112  *         &lt;td style=&quot;text-align: center&quot;&gt;1..n&lt;/td&gt;
 113  *         &lt;td&gt;1996&lt;/td&gt;
 114  *         &lt;td&gt;Year. Normally the length specifies the padding, but for two letters it also specifies the maximum
 115  *         length. Example:&lt;div align=&quot;center&quot;&gt;
 116  *             &lt;center&gt;
 117  *             &lt;table border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;0&quot;&gt;
 118  *                 &lt;tr&gt;
 119  *                     &lt;th&gt;Year&lt;/th&gt;
 120  *                     &lt;th style=&quot;text-align: right&quot;&gt;y&lt;/th&gt;
 121  *                     &lt;th style=&quot;text-align: right&quot;&gt;yy&lt;/th&gt;
 122  *                     &lt;th style=&quot;text-align: right&quot;&gt;yyy&lt;/th&gt;
 123  *                     &lt;th style=&quot;text-align: right&quot;&gt;yyyy&lt;/th&gt;
 124  *                     &lt;th style=&quot;text-align: right&quot;&gt;yyyyy&lt;/th&gt;
 125  *                 &lt;/tr&gt;
 126  *                 &lt;tr&gt;
 127  *                     &lt;td&gt;AD 1&lt;/td&gt;
 128  *                     &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
 129  *                     &lt;td style=&quot;text-align: right&quot;&gt;01&lt;/td&gt;
 130  *                     &lt;td style=&quot;text-align: right&quot;&gt;001&lt;/td&gt;
 131  *                     &lt;td style=&quot;text-align: right&quot;&gt;0001&lt;/td&gt;
 132  *                     &lt;td style=&quot;text-align: right&quot;&gt;00001&lt;/td&gt;
 133  *                 &lt;/tr&gt;
 134  *                 &lt;tr&gt;
 135  *                     &lt;td&gt;AD 12&lt;/td&gt;
 136  *                     &lt;td style=&quot;text-align: right&quot;&gt;12&lt;/td&gt;
 137  *                     &lt;td style=&quot;text-align: right&quot;&gt;12&lt;/td&gt;
 138  *                     &lt;td style=&quot;text-align: right&quot;&gt;012&lt;/td&gt;
 139  *                     &lt;td style=&quot;text-align: right&quot;&gt;0012&lt;/td&gt;
 140  *                     &lt;td style=&quot;text-align: right&quot;&gt;00012&lt;/td&gt;
 141  *                 &lt;/tr&gt;
 142  *                 &lt;tr&gt;
 143  *                     &lt;td&gt;AD 123&lt;/td&gt;
 144  *                     &lt;td style=&quot;text-align: right&quot;&gt;123&lt;/td&gt;
 145  *                     &lt;td style=&quot;text-align: right&quot;&gt;23&lt;/td&gt;
 146  *                     &lt;td style=&quot;text-align: right&quot;&gt;123&lt;/td&gt;
 147  *                     &lt;td style=&quot;text-align: right&quot;&gt;0123&lt;/td&gt;
 148  *                     &lt;td style=&quot;text-align: right&quot;&gt;00123&lt;/td&gt;
 149  *                 &lt;/tr&gt;
 150  *                 &lt;tr&gt;
 151  *                     &lt;td&gt;AD 1234&lt;/td&gt;
 152  *                     &lt;td style=&quot;text-align: right&quot;&gt;1234&lt;/td&gt;
 153  *                     &lt;td style=&quot;text-align: right&quot;&gt;34&lt;/td&gt;
 154  *                     &lt;td style=&quot;text-align: right&quot;&gt;1234&lt;/td&gt;
 155  *                     &lt;td style=&quot;text-align: right&quot;&gt;1234&lt;/td&gt;
 156  *                     &lt;td style=&quot;text-align: right&quot;&gt;01234&lt;/td&gt;
 157  *                 &lt;/tr&gt;
 158  *                 &lt;tr&gt;
 159  *                     &lt;td&gt;AD 12345&lt;/td&gt;
 160  *                     &lt;td style=&quot;text-align: right&quot;&gt;12345&lt;/td&gt;
 161  *                     &lt;td style=&quot;text-align: right&quot;&gt;45&lt;/td&gt;
 162  *                     &lt;td style=&quot;text-align: right&quot;&gt;12345&lt;/td&gt;
 163  *                     &lt;td style=&quot;text-align: right&quot;&gt;12345&lt;/td&gt;
 164  *                     &lt;td style=&quot;text-align: right&quot;&gt;12345&lt;/td&gt;
 165  *                 &lt;/tr&gt;
 166  *             &lt;/table&gt;
 167  *             &lt;/center&gt;&lt;/div&gt;
 168  *         &lt;/td&gt;
 169  *     &lt;/tr&gt;
 170  *     &lt;tr&gt;
 171  *         &lt;td style=&quot;text-align: center&quot;&gt;Y&lt;/td&gt;
 172  *         &lt;td style=&quot;text-align: center&quot;&gt;1..n&lt;/td&gt;
 173  *         &lt;td&gt;1997&lt;/td&gt;
 174  *         &lt;td&gt;Year (in &quot;Week of Year&quot; based calendars). Normally the length specifies the padding,
 175  *         but for two letters it also specifies the maximum length. This year designation is used in ISO
 176  *         year-week calendar as defined by ISO 8601, but can be used in non-Gregorian based calendar systems
 177  *         where week date processing is desired. May not always be the same value as calendar year.&lt;/td&gt;
 178  *     &lt;/tr&gt;
 179  *     &lt;tr&gt;
 180  *         &lt;td style=&quot;text-align: center&quot;&gt;u&lt;/td&gt;
 181  *         &lt;td style=&quot;text-align: center&quot;&gt;1..n&lt;/td&gt;
 182  *         &lt;td&gt;4601&lt;/td&gt;
 183  *         &lt;td&gt;Extended year. This is a single number designating the year of this calendar system, encompassing
 184  *         all supra-year fields. For example, for the Julian calendar system, year numbers are positive, with an
 185  *         era of BCE or CE. An extended year value for the Julian calendar system assigns positive values to CE
 186  *         years and negative values to BCE years, with 1 BCE being year 0.&lt;/td&gt;
 187  *     &lt;/tr&gt;
 188  *     &lt;tr&gt;
 189  *         &lt;td style=&quot;text-align: center&quot; rowspan=&quot;3&quot;&gt;U&lt;/td&gt;
 190  *         &lt;td style=&quot;text-align: center&quot;&gt;1..3&lt;/td&gt;
 191  *         &lt;td&gt;&amp;#30002;&amp;#23376;&lt;/td&gt;
 192  *         &lt;td rowspan=&quot;3&quot;&gt;Cyclic year name. Calendars such as the Chinese lunar calendar (and related calendars)
 193  *         and the Hindu calendars use 60-year cycles of year names. Use one through three letters for the abbreviated
 194  *         name, four for the full (wide) name, or five for the narrow name (currently the data only provides abbreviated names,
 195  *         which will be used for all requested name widths). If the calendar does not provide cyclic year name data,
 196  *         or if the year value to be formatted is out of the range of years for which cyclic name data is provided,
 197  *         then numeric formatting is used (behaves like &#39;y&#39;).&lt;/td&gt;
 198  *     &lt;/tr&gt;
 199  *     &lt;tr&gt;
 200  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 201  *         &lt;td&gt;(currently also &amp;#30002;&amp;#23376;)&lt;/td&gt;
 202  *     &lt;/tr&gt;
 203  *     &lt;tr&gt;
 204  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 205  *         &lt;td&gt;(currently also &amp;#30002;&amp;#23376;)&lt;/td&gt;
 206  *     &lt;/tr&gt;
 207  *     &lt;tr&gt;
 208  *         &lt;th rowspan=&quot;6&quot;&gt;quarter&lt;/th&gt;
 209  *         &lt;td rowspan=&quot;3&quot; style=&quot;text-align: center&quot;&gt;Q&lt;/td&gt;
 210  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 211  *         &lt;td&gt;02&lt;/td&gt;
 212  *         &lt;td rowspan=&quot;3&quot;&gt;Quarter - Use one or two for the numerical quarter, three for the abbreviation, or four for the
 213  *         full (wide) name (five for the narrow name is not yet supported).&lt;/td&gt;
 214  *     &lt;/tr&gt;
 215  *     &lt;tr&gt;
 216  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 217  *         &lt;td&gt;Q2&lt;/td&gt;
 218  *     &lt;/tr&gt;
 219  *     &lt;tr&gt;
 220  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 221  *         &lt;td&gt;2nd quarter&lt;/td&gt;
 222  *     &lt;/tr&gt;
 223  *     &lt;tr&gt;
 224  *         &lt;td rowspan=&quot;3&quot; style=&quot;text-align: center&quot;&gt;q&lt;/td&gt;
 225  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 226  *         &lt;td&gt;02&lt;/td&gt;
 227  *         &lt;td rowspan=&quot;3&quot;&gt;&lt;b&gt;Stand-Alone&lt;/b&gt; Quarter - Use one or two for the numerical quarter, three for the abbreviation,
 228  *         or four for the full name (five for the narrow name is not yet supported).&lt;/td&gt;
 229  *     &lt;/tr&gt;
 230  *     &lt;tr&gt;
 231  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 232  *         &lt;td&gt;Q2&lt;/td&gt;
 233  *     &lt;/tr&gt;
 234  *     &lt;tr&gt;
 235  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 236  *         &lt;td&gt;2nd quarter&lt;/td&gt;
 237  *     &lt;/tr&gt;
 238  *     &lt;tr&gt;
 239  *         &lt;th rowspan=&quot;8&quot;&gt;month&lt;/th&gt;
 240  *         &lt;td rowspan=&quot;4&quot; style=&quot;text-align: center&quot;&gt;M&lt;/td&gt;
 241  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 242  *         &lt;td&gt;09&lt;/td&gt;
 243  *         &lt;td rowspan=&quot;4&quot;&gt;Month - Use one or two for the numerical month, three for the abbreviation, four for
 244  *         the full (wide) name, or five for the narrow name. With two (&quot;MM&quot;), the month number is zero-padded
 245  *         if necessary (e.g. &quot;08&quot;)&lt;/td&gt;
 246  *     &lt;/tr&gt;
 247  *     &lt;tr&gt;
 248  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 249  *         &lt;td&gt;Sep&lt;/td&gt;
 250  *     &lt;/tr&gt;
 251  *     &lt;tr&gt;
 252  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 253  *         &lt;td&gt;September&lt;/td&gt;
 254  *     &lt;/tr&gt;
 255  *     &lt;tr&gt;
 256  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 257  *         &lt;td&gt;S&lt;/td&gt;
 258  *     &lt;/tr&gt;
 259  *     &lt;tr&gt;
 260  *         &lt;td rowspan=&quot;4&quot; style=&quot;text-align: center&quot;&gt;L&lt;/td&gt;
 261  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 262  *         &lt;td&gt;09&lt;/td&gt;
 263  *         &lt;td rowspan=&quot;4&quot;&gt;&lt;b&gt;Stand-Alone&lt;/b&gt; Month - Use one or two for the numerical month, three for the abbreviation,
 264  *         four for the full (wide) name, or 5 for the narrow name. With two (&quot;LL&quot;), the month number is zero-padded if
 265  *         necessary (e.g. &quot;08&quot;)&lt;/td&gt;
 266  *     &lt;/tr&gt;
 267  *     &lt;tr&gt;
 268  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 269  *         &lt;td&gt;Sep&lt;/td&gt;
 270  *     &lt;/tr&gt;
 271  *     &lt;tr&gt;
 272  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 273  *         &lt;td&gt;September&lt;/td&gt;
 274  *     &lt;/tr&gt;
 275  *     &lt;tr&gt;
 276  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 277  *         &lt;td&gt;S&lt;/td&gt;
 278  *     &lt;/tr&gt;
 279  *     &lt;tr&gt;
 280  *         &lt;th rowspan=&quot;2&quot;&gt;week&lt;/th&gt;
 281  *         &lt;td style=&quot;text-align: center&quot;&gt;w&lt;/td&gt;
 282  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 283  *         &lt;td&gt;27&lt;/td&gt;
 284  *         &lt;td&gt;Week of Year. Use &quot;w&quot; to show the minimum number of digits, or &quot;ww&quot; to always show two digits
 285  *         (zero-padding if necessary, e.g. &quot;08&quot;).&lt;/td&gt;
 286  *     &lt;/tr&gt;
 287  *     &lt;tr&gt;
 288  *         &lt;td style=&quot;text-align: center&quot;&gt;W&lt;/td&gt;
 289  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 290  *         &lt;td&gt;3&lt;/td&gt;
 291  *         &lt;td&gt;Week of Month&lt;/td&gt;
 292  *     &lt;/tr&gt;
 293  *     &lt;tr&gt;
 294  *         &lt;th rowspan=&quot;4&quot;&gt;day&lt;/th&gt;
 295  *         &lt;td style=&quot;text-align: center&quot;&gt;d&lt;/td&gt;
 296  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 297  *         &lt;td&gt;1&lt;/td&gt;
 298  *         &lt;td&gt;Date - Day of the month. Use &quot;d&quot; to show the minimum number of digits, or &quot;dd&quot; to always show
 299  *         two digits (zero-padding if necessary, e.g. &quot;08&quot;).&lt;/td&gt;
 300  *     &lt;/tr&gt;
 301  *     &lt;tr&gt;
 302  *         &lt;td style=&quot;text-align: center&quot;&gt;D&lt;/td&gt;
 303  *         &lt;td style=&quot;text-align: center&quot;&gt;1..3&lt;/td&gt;
 304  *         &lt;td&gt;345&lt;/td&gt;
 305  *         &lt;td&gt;Day of year&lt;/td&gt;
 306  *     &lt;/tr&gt;
 307  *     &lt;tr&gt;
 308  *         &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
 309  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 310  *         &lt;td&gt;2&lt;/td&gt;
 311  *         &lt;td&gt;Day of Week in Month. The example is for the 2nd Wed in July&lt;/td&gt;
 312  *     &lt;/tr&gt;
 313  *     &lt;tr&gt;
 314  *         &lt;td style=&quot;text-align: center&quot;&gt;g&lt;/td&gt;
 315  *         &lt;td style=&quot;text-align: center&quot;&gt;1..n&lt;/td&gt;
 316  *         &lt;td&gt;2451334&lt;/td&gt;
 317  *         &lt;td&gt;Modified Julian day. This is different from the conventional Julian day number in two regards.
 318  *         First, it demarcates days at local zone midnight, rather than noon GMT. Second, it is a local number;
 319  *         that is, it depends on the local time zone. It can be thought of as a single number that encompasses
 320  *         all the date-related fields.&lt;/td&gt;
 321  *     &lt;/tr&gt;
 322  *     &lt;tr&gt;
 323  *         &lt;th rowspan=&quot;14&quot;&gt;week&lt;br&gt;
 324  *         day&lt;/th&gt;
 325  *         &lt;td rowspan=&quot;4&quot; style=&quot;text-align: center&quot;&gt;E&lt;/td&gt;
 326  *         &lt;td style=&quot;text-align: center&quot;&gt;1..3&lt;/td&gt;
 327  *         &lt;td&gt;Tue&lt;/td&gt;
 328  *         &lt;td rowspan=&quot;4&quot;&gt;Day of week - Use one through three letters for the short day, four for the full (wide) name,
 329  *         five for the narrow name, or six for the short name.&lt;/td&gt;
 330  *     &lt;/tr&gt;
 331  *     &lt;tr&gt;
 332  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 333  *         &lt;td&gt;Tuesday&lt;/td&gt;
 334  *     &lt;/tr&gt;
 335  *     &lt;tr&gt;
 336  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 337  *         &lt;td&gt;T&lt;/td&gt;
 338  *     &lt;/tr&gt;
 339  *     &lt;tr&gt;
 340  *         &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
 341  *         &lt;td&gt;Tu&lt;/td&gt;
 342  *     &lt;/tr&gt;
 343  *     &lt;tr&gt;
 344  *         &lt;td rowspan=&quot;5&quot; style=&quot;text-align: center&quot;&gt;e&lt;/td&gt;
 345  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 346  *         &lt;td&gt;2&lt;/td&gt;
 347  *         &lt;td rowspan=&quot;5&quot;&gt;Local day of week. Same as E except adds a numeric value that will depend on the local
 348  *         starting day of the week, using one or two letters. For this example, Monday is the first day of the week.&lt;/td&gt;
 349  *     &lt;/tr&gt;
 350  *     &lt;tr&gt;
 351  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 352  *         &lt;td&gt;Tue&lt;/td&gt;
 353  *     &lt;/tr&gt;
 354  *     &lt;tr&gt;
 355  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 356  *         &lt;td&gt;Tuesday&lt;/td&gt;
 357  *     &lt;/tr&gt;
 358  *     &lt;tr&gt;
 359  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 360  *         &lt;td&gt;T&lt;/td&gt;
 361  *     &lt;/tr&gt;
 362  *     &lt;tr&gt;
 363  *         &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
 364  *         &lt;td&gt;Tu&lt;/td&gt;
 365  *     &lt;/tr&gt;
 366  *     &lt;tr&gt;
 367  *         &lt;td rowspan=&quot;5&quot; style=&quot;text-align: center&quot;&gt;c&lt;/td&gt;
 368  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 369  *         &lt;td&gt;2&lt;/td&gt;
 370  *         &lt;td rowspan=&quot;5&quot;&gt;&lt;b&gt;Stand-Alone&lt;/b&gt; local day of week - Use one letter for the local numeric value (same
 371  *         as &#39;e&#39;), three for the short day, four for the full (wide) name, five for the narrow name, or six for
 372  *         the short name.&lt;/td&gt;
 373  *     &lt;/tr&gt;
 374  *     &lt;tr&gt;
 375  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 376  *         &lt;td&gt;Tue&lt;/td&gt;
 377  *     &lt;/tr&gt;
 378  *     &lt;tr&gt;
 379  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 380  *         &lt;td&gt;Tuesday&lt;/td&gt;
 381  *     &lt;/tr&gt;
 382  *     &lt;tr&gt;
 383  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 384  *         &lt;td&gt;T&lt;/td&gt;
 385  *     &lt;/tr&gt;
 386  *     &lt;tr&gt;
 387  *         &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
 388  *         &lt;td&gt;Tu&lt;/td&gt;
 389  *     &lt;/tr&gt;
 390  *     &lt;tr&gt;
 391  *         &lt;th&gt;period&lt;/th&gt;
 392  *         &lt;td style=&quot;text-align: center&quot;&gt;a&lt;/td&gt;
 393  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 394  *         &lt;td&gt;AM&lt;/td&gt;
 395  *         &lt;td&gt;AM or PM&lt;/td&gt;
 396  *     &lt;/tr&gt;
 397  *     &lt;tr&gt;
 398  *         &lt;th rowspan=&quot;4&quot;&gt;hour&lt;/th&gt;
 399  *         &lt;td style=&quot;text-align: center&quot;&gt;h&lt;/td&gt;
 400  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 401  *         &lt;td&gt;11&lt;/td&gt;
 402  *         &lt;td&gt;Hour [1-12]. When used in skeleton data or in a skeleton passed in an API for flexible data pattern
 403  *         generation, it should match the 12-hour-cycle format preferred by the locale (h or K); it should not match
 404  *         a 24-hour-cycle format (H or k). Use hh for zero padding.&lt;/td&gt;
 405  *     &lt;/tr&gt;
 406  *     &lt;tr&gt;
 407  *         &lt;td style=&quot;text-align: center&quot;&gt;H&lt;/td&gt;
 408  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 409  *         &lt;td&gt;13&lt;/td&gt;
 410  *         &lt;td&gt;Hour [0-23]. When used in skeleton data or in a skeleton passed in an API for flexible data pattern
 411  *         generation, it should match the 24-hour-cycle format preferred by the locale (H or k); it should not match a
 412  *         12-hour-cycle format (h or K). Use HH for zero padding.&lt;/td&gt;
 413  *     &lt;/tr&gt;
 414  *     &lt;tr&gt;
 415  *         &lt;td style=&quot;text-align: center&quot;&gt;K&lt;/td&gt;
 416  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 417  *         &lt;td&gt;0&lt;/td&gt;
 418  *         &lt;td&gt;Hour [0-11]. When used in a skeleton, only matches K or h, see above. Use KK for zero padding.&lt;/td&gt;
 419  *     &lt;/tr&gt;
 420  *     &lt;tr&gt;
 421  *         &lt;td style=&quot;text-align: center&quot;&gt;k&lt;/td&gt;
 422  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 423  *         &lt;td&gt;24&lt;/td&gt;
 424  *         &lt;td&gt;Hour [1-24]. When used in a skeleton, only matches k or H, see above. Use kk for zero padding.&lt;/td&gt;
 425  *     &lt;/tr&gt;
 426  *     &lt;tr&gt;
 427  *         &lt;th&gt;minute&lt;/th&gt;
 428  *         &lt;td style=&quot;text-align: center&quot;&gt;m&lt;/td&gt;
 429  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 430  *         &lt;td&gt;59&lt;/td&gt;
 431  *         &lt;td&gt;Minute. Use &quot;m&quot; to show the minimum number of digits, or &quot;mm&quot; to always show two digits
 432  *         (zero-padding if necessary, e.g. &quot;08&quot;).&lt;/td&gt;
 433  *     &lt;/tr&gt;
 434  *     &lt;tr&gt;
 435  *         &lt;th rowspan=&quot;3&quot;&gt;second&lt;/th&gt;
 436  *         &lt;td style=&quot;text-align: center&quot;&gt;s&lt;/td&gt;
 437  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 438  *         &lt;td&gt;12&lt;/td&gt;
 439  *         &lt;td&gt;Second. Use &quot;s&quot; to show the minimum number of digits, or &quot;ss&quot; to always show two digits
 440  *         (zero-padding if necessary, e.g. &quot;08&quot;).&lt;/td&gt;
 441  *     &lt;/tr&gt;
 442  *     &lt;tr&gt;
 443  *         &lt;td style=&quot;text-align: center&quot;&gt;S&lt;/td&gt;
 444  *         &lt;td style=&quot;text-align: center&quot;&gt;1..n&lt;/td&gt;
 445  *         &lt;td&gt;3450&lt;/td&gt;
 446  *         &lt;td&gt;Fractional Second - truncates (like other time fields) to the count of letters when formatting.
 447  *         Appends zeros if more than 3 letters specified. Truncates at three significant digits when parsing.
 448  *         (example shows display using pattern SSSS for seconds value 12.34567)&lt;/td&gt;
 449  *     &lt;/tr&gt;
 450  *     &lt;tr&gt;
 451  *         &lt;td style=&quot;text-align: center&quot;&gt;A&lt;/td&gt;
 452  *         &lt;td style=&quot;text-align: center&quot;&gt;1..n&lt;/td&gt;
 453  *         &lt;td&gt;69540000&lt;/td&gt;
 454  *         &lt;td&gt;Milliseconds in day. This field behaves &lt;i&gt;exactly&lt;/i&gt; like a composite of all time-related fields,
 455  *         not including the zone fields. As such, it also reflects discontinuities of those fields on DST transition
 456  *         days. On a day of DST onset, it will jump forward. On a day of DST cessation, it will jump backward. This
 457  *         reflects the fact that is must be combined with the offset field to obtain a unique local time value.&lt;/td&gt;
 458  *     &lt;/tr&gt;
 459  *     &lt;tr&gt;
 460  *         &lt;th rowspan=&quot;23&quot;&gt;zone&lt;/th&gt;
 461  *         &lt;td rowspan=&quot;2&quot; style=&quot;text-align: center&quot;&gt;z&lt;/td&gt;
 462  *         &lt;td style=&quot;text-align: center&quot;&gt;1..3&lt;/td&gt;
 463  *         &lt;td&gt;PDT&lt;/td&gt;
 464  *         &lt;td&gt;The &lt;i&gt;short specific non-location format&lt;/i&gt;.
 465  *         Where that is unavailable, falls back to the &lt;i&gt;short localized GMT format&lt;/i&gt; (&quot;O&quot;).&lt;/td&gt;
 466  *     &lt;/tr&gt;
 467  *     &lt;tr&gt;
 468  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 469  *         &lt;td&gt;Pacific Daylight Time&lt;/td&gt;
 470  *         &lt;td&gt;The &lt;i&gt;long specific non-location format&lt;/i&gt;.
 471  *         Where that is unavailable, falls back to the &lt;i&gt;long localized GMT format&lt;/i&gt; (&quot;OOOO&quot;).&lt;/td&gt;
 472  *     &lt;/tr&gt;
 473  *     &lt;tr&gt;
 474  *         &lt;td rowspan=&quot;3&quot; style=&quot;text-align: center&quot;&gt;Z&lt;/td&gt;
 475  *         &lt;td style=&quot;text-align: center&quot;&gt;1..3&lt;/td&gt;
 476  *         &lt;td&gt;-0800&lt;/td&gt;
 477  *         &lt;td&gt;The &lt;i&gt;ISO8601 basic format&lt;/i&gt; with hours, minutes and optional seconds fields.
 478  *         The format is equivalent to RFC 822 zone format (when optional seconds field is absent).
 479  *         This is equivalent to the &quot;xxxx&quot; specifier.&lt;/td&gt;
 480  *     &lt;/tr&gt;
 481  *     &lt;tr&gt;
 482  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 483  *         &lt;td&gt;GMT-8:00&lt;/td&gt;
 484  *         &lt;td&gt;The &lt;i&gt;long localized GMT format&lt;/i&gt;.
 485  *         This is equivalent to the &quot;OOOO&quot; specifier.&lt;/td&gt;
 486  *     &lt;/tr&gt;
 487  *     &lt;tr&gt;
 488  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 489  *         &lt;td&gt;-08:00&lt;br&gt;
 490  *         -07:52:58&lt;/td&gt;
 491  *         &lt;td&gt;The &lt;i&gt;ISO8601 extended format&lt;/i&gt; with hours, minutes and optional seconds fields.
 492  *         The ISO8601 UTC indicator &quot;Z&quot; is used when local time offset is 0.
 493  *         This is equivalent to the &quot;XXXXX&quot; specifier.&lt;/td&gt;
 494  *     &lt;/tr&gt;
 495  *     &lt;tr&gt;
 496  *         &lt;td rowspan=&quot;2&quot; style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
 497  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 498  *         &lt;td&gt;GMT-8&lt;/td&gt;
 499  *         &lt;td&gt;The &lt;i&gt;short localized GMT format&lt;/i&gt;.&lt;/td&gt;
 500  *     &lt;/tr&gt;
 501  *     &lt;tr&gt;
 502  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 503  *         &lt;td&gt;GMT-08:00&lt;/td&gt;
 504  *         &lt;td&gt;The &lt;i&gt;long localized GMT format&lt;/i&gt;.&lt;/td&gt;
 505  *     &lt;/tr&gt;
 506  *     &lt;tr&gt;
 507  *         &lt;td rowspan=&quot;2&quot; style=&quot;text-align: center&quot;&gt;v&lt;/td&gt;
 508  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 509  *         &lt;td&gt;PT&lt;/td&gt;
 510  *         &lt;td&gt;The &lt;i&gt;short generic non-location format&lt;/i&gt;.
 511  *         Where that is unavailable, falls back to the &lt;i&gt;generic location format&lt;/i&gt; (&quot;VVVV&quot;),
 512  *         then the &lt;i&gt;short localized GMT format&lt;/i&gt; as the final fallback.&lt;/td&gt;
 513  *     &lt;/tr&gt;
 514  *     &lt;tr&gt;
 515  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 516  *         &lt;td&gt;Pacific Time&lt;/td&gt;
 517  *         &lt;td&gt;The &lt;i&gt;long generic non-location format&lt;/i&gt;.
 518  *         Where that is unavailable, falls back to &lt;i&gt;generic location format&lt;/i&gt; (&quot;VVVV&quot;).
 519  *     &lt;/tr&gt;
 520  *     &lt;tr&gt;
 521  *         &lt;td rowspan=&quot;4&quot; style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
 522  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 523  *         &lt;td&gt;uslax&lt;/td&gt;
 524  *         &lt;td&gt;The short time zone ID.
 525  *         Where that is unavailable, the special short time zone ID &lt;i&gt;unk&lt;/i&gt; (Unknown Zone) is used.&lt;br&gt;
 526  *         &lt;i&gt;&lt;b&gt;Note&lt;/b&gt;: This specifier was originally used for a variant of the short specific non-location format,
 527  *         but it was deprecated in the later version of the LDML specification. In CLDR 23/ICU 51, the definition of
 528  *         the specifier was changed to designate a short time zone ID.&lt;/i&gt;&lt;/td&gt;
 529  *     &lt;/tr&gt;
 530  *     &lt;tr&gt;
 531  *         &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
 532  *         &lt;td&gt;America/Los_Angeles&lt;/td&gt;
 533  *         &lt;td&gt;The long time zone ID.&lt;/td&gt;
 534  *     &lt;/tr&gt;
 535  *     &lt;tr&gt;
 536  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 537  *         &lt;td&gt;Los Angeles&lt;/td&gt;
 538  *         &lt;td&gt;The exemplar city (location) for the time zone.
 539  *         Where that is unavailable, the localized exemplar city name for the special zone &lt;i&gt;Etc/Unknown&lt;/i&gt; is used
 540  *         as the fallback (for example, &quot;Unknown City&quot;). &lt;/td&gt;
 541  *     &lt;/tr&gt;
 542  *     &lt;tr&gt;
 543  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 544  *         &lt;td&gt;Los Angeles Time&lt;/td&gt;
 545  *         &lt;td&gt;The &lt;i&gt;generic location format&lt;/i&gt;.
 546  *         Where that is unavailable, falls back to the &lt;i&gt;long localized GMT format&lt;/i&gt; (&quot;OOOO&quot;;
 547  *         Note: Fallback is only necessary with a GMT-style Time Zone ID, like Etc/GMT-830.)&lt;br&gt;
 548  *         This is especially useful when presenting possible timezone choices for user selection,
 549  *         since the naming is more uniform than the &quot;v&quot; format.&lt;/td&gt;
 550  *     &lt;/tr&gt;
 551  *     &lt;tr&gt;
 552  *         &lt;td rowspan=&quot;5&quot; style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
 553  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 554  *         &lt;td&gt;-08&lt;br&gt;
 555  *         +0530&lt;br&gt;
 556  *         Z&lt;/td&gt;
 557  *         &lt;td&gt;The &lt;i&gt;ISO8601 basic format&lt;/i&gt; with hours field and optional minutes field.
 558  *         The ISO8601 UTC indicator &quot;Z&quot; is used when local time offset is 0.&lt;/td&gt;
 559  *     &lt;/tr&gt;
 560  *     &lt;tr&gt;
 561  *         &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
 562  *         &lt;td&gt;-0800&lt;br&gt;
 563  *         Z&lt;/td&gt;
 564  *         &lt;td&gt;The &lt;i&gt;ISO8601 basic format&lt;/i&gt; with hours and minutes fields.
 565  *         The ISO8601 UTC indicator &quot;Z&quot; is used when local time offset is 0.&lt;/td&gt;
 566  *     &lt;/tr&gt;
 567  *     &lt;tr&gt;
 568  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 569  *         &lt;td&gt;-08:00&lt;br&gt;
 570  *         Z&lt;/td&gt;
 571  *         &lt;td&gt;The &lt;i&gt;ISO8601 extended format&lt;/i&gt; with hours and minutes fields.
 572  *         The ISO8601 UTC indicator &quot;Z&quot; is used when local time offset is 0.&lt;/td&gt;
 573  *     &lt;/tr&gt;
 574  *     &lt;tr&gt;
 575  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 576  *         &lt;td&gt;-0800&lt;br&gt;
 577  *         -075258&lt;br&gt;
 578  *         Z&lt;/td&gt;
 579  *         &lt;td&gt;The &lt;i&gt;ISO8601 basic format&lt;/i&gt; with hours, minutes and optional seconds fields.
 580  *         (Note: The seconds field is not supported by the ISO8601 specification.)
 581  *         The ISO8601 UTC indicator &quot;Z&quot; is used when local time offset is 0.&lt;/td&gt;
 582  *     &lt;/tr&gt;
 583  *     &lt;tr&gt;
 584  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 585  *         &lt;td&gt;-08:00&lt;br&gt;
 586  *         -07:52:58&lt;br&gt;
 587  *         Z&lt;/td&gt;
 588  *         &lt;td&gt;The &lt;i&gt;ISO8601 extended format&lt;/i&gt; with hours, minutes and optional seconds fields.
 589  *         (Note: The seconds field is not supported by the ISO8601 specification.)
 590  *         The ISO8601 UTC indicator &quot;Z&quot; is used when local time offset is 0.&lt;/td&gt;
 591  *     &lt;/tr&gt;
 592  *     &lt;tr&gt;
 593  *         &lt;td rowspan=&quot;5&quot; style=&quot;text-align: center&quot;&gt;x&lt;/td&gt;
 594  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 595  *         &lt;td&gt;-08&lt;br&gt;
 596  *         +0530&lt;/td&gt;
 597  *         &lt;td&gt;The &lt;i&gt;ISO8601 basic format&lt;/i&gt; with hours field and optional minutes field.&lt;/td&gt;
 598  *     &lt;/tr&gt;
 599  *     &lt;tr&gt;
 600  *         &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
 601  *         &lt;td&gt;-0800&lt;/td&gt;
 602  *         &lt;td&gt;The &lt;i&gt;ISO8601 basic format&lt;/i&gt; with hours and minutes fields.&lt;/td&gt;
 603  *     &lt;/tr&gt;
 604  *     &lt;tr&gt;
 605  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 606  *         &lt;td&gt;-08:00&lt;/td&gt;
 607  *         &lt;td&gt;The &lt;i&gt;ISO8601 extended format&lt;/i&gt; with hours and minutes fields.&lt;/td&gt;
 608  *     &lt;/tr&gt;
 609  *     &lt;tr&gt;
 610  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 611  *         &lt;td&gt;-0800&lt;br&gt;
 612  *         -075258&lt;/td&gt;
 613  *         &lt;td&gt;The &lt;i&gt;ISO8601 basic format&lt;/i&gt; with hours, minutes and optional seconds fields.
 614  *         (Note: The seconds field is not supported by the ISO8601 specification.)&lt;/td&gt;
 615  *     &lt;/tr&gt;
 616  *     &lt;tr&gt;
 617  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 618  *         &lt;td&gt;-08:00&lt;br&gt;
 619  *         -07:52:58&lt;/td&gt;
 620  *         &lt;td&gt;The &lt;i&gt;ISO8601 extended format&lt;/i&gt; with hours, minutes and optional seconds fields.
 621  *         (Note: The seconds field is not supported by the ISO8601 specification.)&lt;/td&gt;
 622  *     &lt;/tr&gt;
 623  * &lt;/table&gt;
 624  *
 625  * &lt;P&gt;
 626  * Any characters in the pattern that are not in the ranges of [&#39;a&#39;..&#39;z&#39;] and
 627  * [&#39;A&#39;..&#39;Z&#39;] will be treated as quoted text. For instance, characters
 628  * like &#39;:&#39;, &#39;.&#39;, &#39; &#39;, &#39;#&#39; and &#39;@&#39; will appear in the resulting time text
 629  * even they are not embraced within single quotes.
 630  * &lt;P&gt;
 631  * A pattern containing any invalid pattern letter will result in a failing
 632  * UErrorCode result during formatting or parsing.
 633  * &lt;P&gt;
 634  * Examples using the US locale:
 635  * &lt;pre&gt;
 636  * \code
 637  *    Format Pattern                         Result
 638  *    --------------                         -------
 639  *    &quot;yyyy.MM.dd G &#39;at&#39; HH:mm:ss vvvv&quot; -&gt;&gt;  1996.07.10 AD at 15:08:56 Pacific Time
 640  *    &quot;EEE, MMM d, &#39;&#39;yy&quot;                -&gt;&gt;  Wed, July 10, &#39;96
 641  *    &quot;h:mm a&quot;                          -&gt;&gt;  12:08 PM
 642  *    &quot;hh &#39;o&#39;&#39;clock&#39; a, zzzz&quot;           -&gt;&gt;  12 o&#39;clock PM, Pacific Daylight Time
 643  *    &quot;K:mm a, vvv&quot;                     -&gt;&gt;  0:00 PM, PT
 644  *    &quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;    -&gt;&gt;  1996.July.10 AD 12:08 PM
 645  * \endcode
 646  * &lt;/pre&gt;
 647  * Code Sample:
 648  * &lt;pre&gt;
 649  * \code
 650  *     UErrorCode success = U_ZERO_ERROR;
 651  *     SimpleTimeZone* pdt = new SimpleTimeZone(-8 * 60 * 60 * 1000, &quot;PST&quot;);
 652  *     pdt-&gt;setStartRule( Calendar::APRIL, 1, Calendar::SUNDAY, 2*60*60*1000);
 653  *     pdt-&gt;setEndRule( Calendar::OCTOBER, -1, Calendar::SUNDAY, 2*60*60*1000);
 654  *
 655  *     // Format the current time.
 656  *     SimpleDateFormat* formatter
 657  *         = new SimpleDateFormat (&quot;yyyy.MM.dd G &#39;at&#39; hh:mm:ss a zzz&quot;, success );
 658  *     GregorianCalendar cal(success);
 659  *     UDate currentTime_1 = cal.getTime(success);
 660  *     FieldPosition fp(FieldPosition::DONT_CARE);
 661  *     UnicodeString dateString;
 662  *     formatter-&gt;format( currentTime_1, dateString, fp );
 663  *     cout &lt;&lt; &quot;result: &quot; &lt;&lt; dateString &lt;&lt; endl;
 664  *
 665  *     // Parse the previous string back into a Date.
 666  *     ParsePosition pp(0);
 667  *     UDate currentTime_2 = formatter-&gt;parse(dateString, pp );
 668  * \endcode
 669  * &lt;/pre&gt;
 670  * In the above example, the time value &quot;currentTime_2&quot; obtained from parsing
 671  * will be equal to currentTime_1. However, they may not be equal if the am/pm
 672  * marker &#39;a&#39; is left out from the format pattern while the &quot;hour in am/pm&quot;
 673  * pattern symbol is used. This information loss can happen when formatting the
 674  * time in PM.
 675  *
 676  * &lt;p&gt;
 677  * When parsing a date string using the abbreviated year pattern (&quot;y&quot; or &quot;yy&quot;),
 678  * SimpleDateFormat must interpret the abbreviated year
 679  * relative to some century.  It does this by adjusting dates to be
 680  * within 80 years before and 20 years after the time the SimpleDateFormat
 681  * instance is created. For example, using a pattern of &quot;MM/dd/yy&quot; and a
 682  * SimpleDateFormat instance created on Jan 1, 1997,  the string
 683  * &quot;01/11/12&quot; would be interpreted as Jan 11, 2012 while the string &quot;05/04/64&quot;
 684  * would be interpreted as May 4, 1964.
 685  * During parsing, only strings consisting of exactly two digits, as defined by
 686  * &lt;code&gt;Unicode::isDigit()&lt;/code&gt;, will be parsed into the default century.
 687  * Any other numeric string, such as a one digit string, a three or more digit
 688  * string, or a two digit string that isn&#39;t all digits (for example, &quot;-1&quot;), is
 689  * interpreted literally.  So &quot;01/02/3&quot; or &quot;01/02/003&quot; are parsed (for the
 690  * Gregorian calendar), using the same pattern, as Jan 2, 3 AD.  Likewise (but
 691  * only in lenient parse mode, the default) &quot;01/02/-3&quot; is parsed as Jan 2, 4 BC.
 692  *
 693  * &lt;p&gt;
 694  * If the year pattern has more than two &#39;y&#39; characters, the year is
 695  * interpreted literally, regardless of the number of digits.  So using the
 696  * pattern &quot;MM/dd/yyyy&quot;, &quot;01/11/12&quot; parses to Jan 11, 12 A.D.
 697  *
 698  * &lt;p&gt;
 699  * When numeric fields abut one another directly, with no intervening delimiter
 700  * characters, they constitute a run of abutting numeric fields.  Such runs are
 701  * parsed specially.  For example, the format &quot;HHmmss&quot; parses the input text
 702  * &quot;123456&quot; to 12:34:56, parses the input text &quot;12345&quot; to 1:23:45, and fails to
 703  * parse &quot;1234&quot;.  In other words, the leftmost field of the run is flexible,
 704  * while the others keep a fixed width.  If the parse fails anywhere in the run,
 705  * then the leftmost field is shortened by one character, and the entire run is
 706  * parsed again. This is repeated until either the parse succeeds or the
 707  * leftmost field is one character in length.  If the parse still fails at that
 708  * point, the parse of the run fails.
 709  *
 710  * &lt;P&gt;
 711  * For time zones that have no names, SimpleDateFormat uses strings GMT+hours:minutes or
 712  * GMT-hours:minutes.
 713  * &lt;P&gt;
 714  * The calendar defines what is the first day of the week, the first week of the
 715  * year, whether hours are zero based or not (0 vs 12 or 24), and the timezone.
 716  * There is one common number format to handle all the numbers; the digit count
 717  * is handled programmatically according to the pattern.
 718  *
 719  * &lt;p&gt;&lt;em&gt;User subclasses are not supported.&lt;/em&gt; While clients may write
 720  * subclasses, such code will not necessarily work and will not be
 721  * guaranteed to work stably from release to release.
 722  */
 723 class U_I18N_API SimpleDateFormat: public DateFormat {
 724 public:
 725     /**
 726      * Construct a SimpleDateFormat using the default pattern for the default
 727      * locale.
 728      * &lt;P&gt;
 729      * [Note:] Not all locales support SimpleDateFormat; for full generality,
 730      * use the factory methods in the DateFormat class.
 731      * @param status    Output param set to success/failure code.
 732      * @stable ICU 2.0
 733      */
 734     SimpleDateFormat(UErrorCode&amp; status);
 735 
 736     /**
 737      * Construct a SimpleDateFormat using the given pattern and the default locale.
 738      * The locale is used to obtain the symbols used in formatting (e.g., the
 739      * names of the months), but not to provide the pattern.
 740      * &lt;P&gt;
 741      * [Note:] Not all locales support SimpleDateFormat; for full generality,
 742      * use the factory methods in the DateFormat class.
 743      * @param pattern    the pattern for the format.
 744      * @param status     Output param set to success/failure code.
 745      * @stable ICU 2.0
 746      */
 747     SimpleDateFormat(const UnicodeString&amp; pattern,
 748                      UErrorCode&amp; status);
 749 
 750     /**
 751      * Construct a SimpleDateFormat using the given pattern, numbering system override, and the default locale.
 752      * The locale is used to obtain the symbols used in formatting (e.g., the
 753      * names of the months), but not to provide the pattern.
 754      * &lt;P&gt;
 755      * A numbering system override is a string containing either the name of a known numbering system,
 756      * or a set of field and numbering system pairs that specify which fields are to be formattied with
 757      * the alternate numbering system.  For example, to specify that all numeric fields in the specified
 758      * date or time pattern are to be rendered using Thai digits, simply specify the numbering system override
 759      * as &quot;thai&quot;.  To specify that just the year portion of the date be formatted using Hebrew numbering,
 760      * use the override string &quot;y=hebrew&quot;.  Numbering system overrides can be combined using a semi-colon
 761      * character in the override string, such as &quot;d=decimal;M=arabic;y=hebrew&quot;, etc.
 762      *
 763      * &lt;P&gt;
 764      * [Note:] Not all locales support SimpleDateFormat; for full generality,
 765      * use the factory methods in the DateFormat class.
 766      * @param pattern    the pattern for the format.
 767      * @param override   the override string.
 768      * @param status     Output param set to success/failure code.
 769      * @stable ICU 4.2
 770      */
 771     SimpleDateFormat(const UnicodeString&amp; pattern,
 772                      const UnicodeString&amp; override,
 773                      UErrorCode&amp; status);
 774 
 775     /**
 776      * Construct a SimpleDateFormat using the given pattern and locale.
 777      * The locale is used to obtain the symbols used in formatting (e.g., the
 778      * names of the months), but not to provide the pattern.
 779      * &lt;P&gt;
 780      * [Note:] Not all locales support SimpleDateFormat; for full generality,
 781      * use the factory methods in the DateFormat class.
 782      * @param pattern    the pattern for the format.
 783      * @param locale     the given locale.
 784      * @param status     Output param set to success/failure code.
 785      * @stable ICU 2.0
 786      */
 787     SimpleDateFormat(const UnicodeString&amp; pattern,
 788                      const Locale&amp; locale,
 789                      UErrorCode&amp; status);
 790 
 791     /**
 792      * Construct a SimpleDateFormat using the given pattern, numbering system override, and locale.
 793      * The locale is used to obtain the symbols used in formatting (e.g., the
 794      * names of the months), but not to provide the pattern.
 795      * &lt;P&gt;
 796      * A numbering system override is a string containing either the name of a known numbering system,
 797      * or a set of field and numbering system pairs that specify which fields are to be formattied with
 798      * the alternate numbering system.  For example, to specify that all numeric fields in the specified
 799      * date or time pattern are to be rendered using Thai digits, simply specify the numbering system override
 800      * as &quot;thai&quot;.  To specify that just the year portion of the date be formatted using Hebrew numbering,
 801      * use the override string &quot;y=hebrew&quot;.  Numbering system overrides can be combined using a semi-colon
 802      * character in the override string, such as &quot;d=decimal;M=arabic;y=hebrew&quot;, etc.
 803      * &lt;P&gt;
 804      * [Note:] Not all locales support SimpleDateFormat; for full generality,
 805      * use the factory methods in the DateFormat class.
 806      * @param pattern    the pattern for the format.
 807      * @param override   the numbering system override.
 808      * @param locale     the given locale.
 809      * @param status     Output param set to success/failure code.
 810      * @stable ICU 4.2
 811      */
 812     SimpleDateFormat(const UnicodeString&amp; pattern,
 813                      const UnicodeString&amp; override,
 814                      const Locale&amp; locale,
 815                      UErrorCode&amp; status);
 816 
 817     /**
 818      * Construct a SimpleDateFormat using the given pattern and locale-specific
 819      * symbol data.  The formatter takes ownership of the DateFormatSymbols object;
 820      * the caller is no longer responsible for deleting it.
 821      * @param pattern           the given pattern for the format.
 822      * @param formatDataToAdopt the symbols to be adopted.
 823      * @param status            Output param set to success/faulure code.
 824      * @stable ICU 2.0
 825      */
 826     SimpleDateFormat(const UnicodeString&amp; pattern,
 827                      DateFormatSymbols* formatDataToAdopt,
 828                      UErrorCode&amp; status);
 829 
 830     /**
 831      * Construct a SimpleDateFormat using the given pattern and locale-specific
 832      * symbol data.  The DateFormatSymbols object is NOT adopted; the caller
 833      * remains responsible for deleting it.
 834      * @param pattern           the given pattern for the format.
 835      * @param formatData        the formatting symbols to be use.
 836      * @param status            Output param set to success/faulure code.
 837      * @stable ICU 2.0
 838      */
 839     SimpleDateFormat(const UnicodeString&amp; pattern,
 840                      const DateFormatSymbols&amp; formatData,
 841                      UErrorCode&amp; status);
 842 
 843     /**
 844      * Copy constructor.
 845      * @stable ICU 2.0
 846      */
 847     SimpleDateFormat(const SimpleDateFormat&amp;);
 848 
 849     /**
 850      * Assignment operator.
 851      * @stable ICU 2.0
 852      */
 853     SimpleDateFormat&amp; operator=(const SimpleDateFormat&amp;);
 854 
 855     /**
 856      * Destructor.
 857      * @stable ICU 2.0
 858      */
 859     virtual ~SimpleDateFormat();
 860 
 861     /**
 862      * Clone this Format object polymorphically. The caller owns the result and
 863      * should delete it when done.
 864      * @return    A copy of the object.
 865      * @stable ICU 2.0
 866      */
 867     virtual Format* clone(void) const;
 868 
 869     /**
 870      * Return true if the given Format objects are semantically equal. Objects
 871      * of different subclasses are considered unequal.
 872      * @param other    the object to be compared with.
 873      * @return         true if the given Format objects are semantically equal.
 874      * @stable ICU 2.0
 875      */
 876     virtual UBool operator==(const Format&amp; other) const;
 877 
 878 
 879     using DateFormat::format;
 880 
 881     /**
 882      * Format a date or time, which is the standard millis since 24:00 GMT, Jan
 883      * 1, 1970. Overrides DateFormat pure virtual method.
 884      * &lt;P&gt;
 885      * Example: using the US locale: &quot;yyyy.MM.dd e &#39;at&#39; HH:mm:ss zzz&quot; -&gt;&gt;
 886      * 1996.07.10 AD at 15:08:56 PDT
 887      *
 888      * @param cal       Calendar set to the date and time to be formatted
 889      *                  into a date/time string.
 890      * @param appendTo  Output parameter to receive result.
 891      *                  Result is appended to existing contents.
 892      * @param pos       The formatting position. On input: an alignment field,
 893      *                  if desired. On output: the offsets of the alignment field.
 894      * @return          Reference to &#39;appendTo&#39; parameter.
 895      * @stable ICU 2.1
 896      */
 897     virtual UnicodeString&amp; format(  Calendar&amp; cal,
 898                                     UnicodeString&amp; appendTo,
 899                                     FieldPosition&amp; pos) const;
 900 
 901     /**
 902      * Format a date or time, which is the standard millis since 24:00 GMT, Jan
 903      * 1, 1970. Overrides DateFormat pure virtual method.
 904      * &lt;P&gt;
 905      * Example: using the US locale: &quot;yyyy.MM.dd e &#39;at&#39; HH:mm:ss zzz&quot; -&gt;&gt;
 906      * 1996.07.10 AD at 15:08:56 PDT
 907      *
 908      * @param cal       Calendar set to the date and time to be formatted
 909      *                  into a date/time string.
 910      * @param appendTo  Output parameter to receive result.
 911      *                  Result is appended to existing contents.
 912      * @param posIter   On return, can be used to iterate over positions
 913      *                  of fields generated by this format call.  Field values
 914      *                  are defined in UDateFormatField.
 915      * @param status    Input/output param set to success/failure code.
 916      * @return          Reference to &#39;appendTo&#39; parameter.
 917      * @stable ICU 4.4
 918      */
 919     virtual UnicodeString&amp; format(  Calendar&amp; cal,
 920                                     UnicodeString&amp; appendTo,
 921                                     FieldPositionIterator* posIter,
 922                                     UErrorCode&amp; status) const;
 923 
 924     using DateFormat::parse;
 925 
 926     /**
 927      * Parse a date/time string beginning at the given parse position. For
 928      * example, a time text &quot;07/10/96 4:5 PM, PDT&quot; will be parsed into a Date
 929      * that is equivalent to Date(837039928046).
 930      * &lt;P&gt;
 931      * By default, parsing is lenient: If the input is not in the form used by
 932      * this object&#39;s format method but can still be parsed as a date, then the
 933      * parse succeeds. Clients may insist on strict adherence to the format by
 934      * calling setLenient(false).
 935      * @see DateFormat::setLenient(boolean)
 936      *
 937      * @param text  The date/time string to be parsed
 938      * @param cal   A Calendar set on input to the date and time to be used for
 939      *              missing values in the date/time string being parsed, and set
 940      *              on output to the parsed date/time. When the calendar type is
 941      *              different from the internal calendar held by this SimpleDateFormat
 942      *              instance, the internal calendar will be cloned to a work
 943      *              calendar set to the same milliseconds and time zone as the
 944      *              cal parameter, field values will be parsed based on the work
 945      *              calendar, then the result (milliseconds and time zone) will
 946      *              be set in this calendar.
 947      * @param pos   On input, the position at which to start parsing; on
 948      *              output, the position at which parsing terminated, or the
 949      *              start position if the parse failed.
 950      * @stable ICU 2.1
 951      */
 952     virtual void parse( const UnicodeString&amp; text,
 953                         Calendar&amp; cal,
 954                         ParsePosition&amp; pos) const;
 955 
 956 
 957     /**
 958      * Set the start UDate used to interpret two-digit year strings.
 959      * When dates are parsed having 2-digit year strings, they are placed within
 960      * a assumed range of 100 years starting on the two digit start date.  For
 961      * example, the string &quot;24-Jan-17&quot; may be in the year 1817, 1917, 2017, or
 962      * some other year.  SimpleDateFormat chooses a year so that the resultant
 963      * date is on or after the two digit start date and within 100 years of the
 964      * two digit start date.
 965      * &lt;P&gt;
 966      * By default, the two digit start date is set to 80 years before the current
 967      * time at which a SimpleDateFormat object is created.
 968      * @param d      start UDate used to interpret two-digit year strings.
 969      * @param status Filled in with U_ZERO_ERROR if the parse was successful, and with
 970      *               an error value if there was a parse error.
 971      * @stable ICU 2.0
 972      */
 973     virtual void set2DigitYearStart(UDate d, UErrorCode&amp; status);
 974 
 975     /**
 976      * Get the start UDate used to interpret two-digit year strings.
 977      * When dates are parsed having 2-digit year strings, they are placed within
 978      * a assumed range of 100 years starting on the two digit start date.  For
 979      * example, the string &quot;24-Jan-17&quot; may be in the year 1817, 1917, 2017, or
 980      * some other year.  SimpleDateFormat chooses a year so that the resultant
 981      * date is on or after the two digit start date and within 100 years of the
 982      * two digit start date.
 983      * &lt;P&gt;
 984      * By default, the two digit start date is set to 80 years before the current
 985      * time at which a SimpleDateFormat object is created.
 986      * @param status Filled in with U_ZERO_ERROR if the parse was successful, and with
 987      *               an error value if there was a parse error.
 988      * @stable ICU 2.0
 989      */
 990     UDate get2DigitYearStart(UErrorCode&amp; status) const;
 991 
 992     /**
 993      * Return a pattern string describing this date format.
 994      * @param result Output param to receive the pattern.
 995      * @return       A reference to &#39;result&#39;.
 996      * @stable ICU 2.0
 997      */
 998     virtual UnicodeString&amp; toPattern(UnicodeString&amp; result) const;
 999 
1000     /**
1001      * Return a localized pattern string describing this date format.
1002      * In most cases, this will return the same thing as toPattern(),
1003      * but a locale can specify characters to use in pattern descriptions
1004      * in place of the ones described in this class&#39;s class documentation.
1005      * (Presumably, letters that would be more mnemonic in that locale&#39;s
1006      * language.)  This function would produce a pattern using those
1007      * letters.
1008      * &lt;p&gt;
1009      * &lt;b&gt;Note:&lt;/b&gt; This implementation depends on DateFormatSymbols::getLocalPatternChars()
1010      * to get localized format pattern characters. ICU does not include
1011      * localized pattern character data, therefore, unless user sets localized
1012      * pattern characters manually, this method returns the same result as
1013      * toPattern().
1014      *
1015      * @param result    Receives the localized pattern.
1016      * @param status    Output param set to success/failure code on
1017      *                  exit. If the pattern is invalid, this will be
1018      *                  set to a failure result.
1019      * @return          A reference to &#39;result&#39;.
1020      * @stable ICU 2.0
1021      */
1022     virtual UnicodeString&amp; toLocalizedPattern(UnicodeString&amp; result,
1023                                               UErrorCode&amp; status) const;
1024 
1025     /**
1026      * Apply the given unlocalized pattern string to this date format.
1027      * (i.e., after this call, this formatter will format dates according to
1028      * the new pattern)
1029      *
1030      * @param pattern   The pattern to be applied.
1031      * @stable ICU 2.0
1032      */
1033     virtual void applyPattern(const UnicodeString&amp; pattern);
1034 
1035     /**
1036      * Apply the given localized pattern string to this date format.
1037      * (see toLocalizedPattern() for more information on localized patterns.)
1038      *
1039      * @param pattern   The localized pattern to be applied.
1040      * @param status    Output param set to success/failure code on
1041      *                  exit. If the pattern is invalid, this will be
1042      *                  set to a failure result.
1043      * @stable ICU 2.0
1044      */
1045     virtual void applyLocalizedPattern(const UnicodeString&amp; pattern,
1046                                        UErrorCode&amp; status);
1047 
1048     /**
1049      * Gets the date/time formatting symbols (this is an object carrying
1050      * the various strings and other symbols used in formatting: e.g., month
1051      * names and abbreviations, time zone names, AM/PM strings, etc.)
1052      * @return a copy of the date-time formatting data associated
1053      * with this date-time formatter.
1054      * @stable ICU 2.0
1055      */
1056     virtual const DateFormatSymbols* getDateFormatSymbols(void) const;
1057 
1058     /**
1059      * Set the date/time formatting symbols.  The caller no longer owns the
1060      * DateFormatSymbols object and should not delete it after making this call.
1061      * @param newFormatSymbols the given date-time formatting symbols to copy.
1062      * @stable ICU 2.0
1063      */
1064     virtual void adoptDateFormatSymbols(DateFormatSymbols* newFormatSymbols);
1065 
1066     /**
1067      * Set the date/time formatting data.
1068      * @param newFormatSymbols the given date-time formatting symbols to copy.
1069      * @stable ICU 2.0
1070      */
1071     virtual void setDateFormatSymbols(const DateFormatSymbols&amp; newFormatSymbols);
1072 
1073     /**
1074      * Return the class ID for this class. This is useful only for comparing to
1075      * a return value from getDynamicClassID(). For example:
1076      * &lt;pre&gt;
1077      * .   Base* polymorphic_pointer = createPolymorphicObject();
1078      * .   if (polymorphic_pointer-&gt;getDynamicClassID() ==
1079      * .       erived::getStaticClassID()) ...
1080      * &lt;/pre&gt;
1081      * @return          The class ID for all objects of this class.
1082      * @stable ICU 2.0
1083      */
1084     static UClassID U_EXPORT2 getStaticClassID(void);
1085 
1086     /**
1087      * Returns a unique class ID POLYMORPHICALLY. Pure virtual override. This
1088      * method is to implement a simple version of RTTI, since not all C++
1089      * compilers support genuine RTTI. Polymorphic operator==() and clone()
1090      * methods call this method.
1091      *
1092      * @return          The class ID for this object. All objects of a
1093      *                  given class have the same class ID.  Objects of
1094      *                  other classes have different class IDs.
1095      * @stable ICU 2.0
1096      */
1097     virtual UClassID getDynamicClassID(void) const;
1098 
1099     /**
1100      * Set the calendar to be used by this date format. Initially, the default
1101      * calendar for the specified or default locale is used.  The caller should
1102      * not delete the Calendar object after it is adopted by this call.
1103      * Adopting a new calendar will change to the default symbols.
1104      *
1105      * @param calendarToAdopt    Calendar object to be adopted.
1106      * @stable ICU 2.0
1107      */
1108     virtual void adoptCalendar(Calendar* calendarToAdopt);
1109 
1110     /* Cannot use #ifndef U_HIDE_INTERNAL_API for the following methods since they are virtual */
1111     /**
1112      * Sets the TimeZoneFormat to be used by this date/time formatter.
1113      * The caller should not delete the TimeZoneFormat object after
1114      * it is adopted by this call.
1115      * @param timeZoneFormatToAdopt The TimeZoneFormat object to be adopted.
1116      * @internal ICU 49 technology preview
1117      */
1118     virtual void adoptTimeZoneFormat(TimeZoneFormat* timeZoneFormatToAdopt);
1119 
1120     /**
1121      * Sets the TimeZoneFormat to be used by this date/time formatter.
1122      * @param newTimeZoneFormat The TimeZoneFormat object to copy.
1123      * @internal ICU 49 technology preview
1124      */
1125     virtual void setTimeZoneFormat(const TimeZoneFormat&amp; newTimeZoneFormat);
1126 
1127     /**
1128      * Gets the time zone format object associated with this date/time formatter.
1129      * @return the time zone format associated with this date/time formatter.
1130      * @internal ICU 49 technology preview
1131      */
1132     virtual const TimeZoneFormat* getTimeZoneFormat(void) const;
1133 
1134     /**
1135      * Set a particular UDisplayContext value in the formatter, such as
1136      * UDISPCTX_CAPITALIZATION_FOR_STANDALONE. Note: For getContext, see
1137      * DateFormat.
1138      * @param value The UDisplayContext value to set.
1139      * @param status Input/output status. If at entry this indicates a failure
1140      *               status, the function will do nothing; otherwise this will be
1141      *               updated with any new status from the function.
1142      * @stable ICU 53
1143      */
1144     virtual void setContext(UDisplayContext value, UErrorCode&amp; status);
1145 
1146     /**
1147      * Overrides base class method and
1148      * This method clears per field NumberFormat instances
1149      * previously set by {@see adoptNumberFormat(const UnicodeString&amp;, NumberFormat*, UErrorCode)}
<a name="2" id="anc2"></a><span class="line-modified">1150      * @param adoptNF the NumbeferFormat used</span>
1151      * @stable ICU 54
1152      */
1153     void adoptNumberFormat(NumberFormat *formatToAdopt);
1154 
1155     /**
1156      * Allow the user to set the NumberFormat for several fields
1157      * It can be a single field like: &quot;y&quot;(year) or &quot;M&quot;(month)
1158      * It can be several field combined together: &quot;yM&quot;(year and month)
1159      * Note:
1160      * 1 symbol field is enough for multiple symbol field (so &quot;y&quot; will override &quot;yy&quot;, &quot;yyy&quot;)
1161      * If the field is not numeric, then override has no effect (like &quot;MMM&quot; will use abbreviation, not numerical field)
1162      * Per field NumberFormat can also be cleared in {@see DateFormat::setNumberFormat(const NumberFormat&amp; newNumberFormat)}
1163      *
1164      * @param fields  the fields to override(like y)
<a name="3" id="anc3"></a><span class="line-modified">1165      * @param adoptNF the NumbeferFormat used</span>
1166      * @param status  Receives a status code, which will be U_ZERO_ERROR
1167      *                if the operation succeeds.
1168      * @stable ICU 54
1169      */
1170     void adoptNumberFormat(const UnicodeString&amp; fields, NumberFormat *formatToAdopt, UErrorCode &amp;status);
1171 
1172     /**
1173      * Get the numbering system to be used for a particular field.
1174      * @param field The UDateFormatField to get
1175      * @stable ICU 54
1176      */
1177     const NumberFormat * getNumberFormatForField(char16_t field) const;
1178 
1179 #ifndef U_HIDE_INTERNAL_API
1180     /**
1181      * This is for ICU internal use only. Please do not use.
1182      * Check whether the &#39;field&#39; is smaller than all the fields covered in
1183      * pattern, return TRUE if it is. The sequence of calendar field,
1184      * from large to small is: ERA, YEAR, MONTH, DATE, AM_PM, HOUR, MINUTE,...
1185      * @param field    the calendar field need to check against
1186      * @return         TRUE if the &#39;field&#39; is smaller than all the fields
1187      *                 covered in pattern. FALSE otherwise.
1188      * @internal ICU 4.0
1189      */
1190     UBool isFieldUnitIgnored(UCalendarDateFields field) const;
1191 
1192 
1193     /**
1194      * This is for ICU internal use only. Please do not use.
1195      * Check whether the &#39;field&#39; is smaller than all the fields covered in
1196      * pattern, return TRUE if it is. The sequence of calendar field,
1197      * from large to small is: ERA, YEAR, MONTH, DATE, AM_PM, HOUR, MINUTE,...
1198      * @param pattern  the pattern to check against
1199      * @param field    the calendar field need to check against
1200      * @return         TRUE if the &#39;field&#39; is smaller than all the fields
1201      *                 covered in pattern. FALSE otherwise.
1202      * @internal ICU 4.0
1203      */
1204     static UBool isFieldUnitIgnored(const UnicodeString&amp; pattern,
1205                                     UCalendarDateFields field);
1206 
1207     /**
1208      * This is for ICU internal use only. Please do not use.
1209      * Get the locale of this simple date formatter.
1210      * It is used in DateIntervalFormat.
1211      *
1212      * @return   locale in this simple date formatter
1213      * @internal ICU 4.0
1214      */
1215     const Locale&amp; getSmpFmtLocale(void) const;
1216 #endif  /* U_HIDE_INTERNAL_API */
1217 
1218 private:
1219     friend class DateFormat;
<a name="4" id="anc4"></a>
1220 
1221     void initializeDefaultCentury(void);
1222 
1223     void initializeBooleanAttributes(void);
1224 
1225     SimpleDateFormat(); // default constructor not implemented
1226 
1227     /**
1228      * Used by the DateFormat factory methods to construct a SimpleDateFormat.
1229      * @param timeStyle the time style.
1230      * @param dateStyle the date style.
1231      * @param locale    the given locale.
1232      * @param status    Output param set to success/failure code on
1233      *                  exit.
1234      */
1235     SimpleDateFormat(EStyle timeStyle, EStyle dateStyle, const Locale&amp; locale, UErrorCode&amp; status);
1236 
1237     /**
1238      * Construct a SimpleDateFormat for the given locale.  If no resource data
1239      * is available, create an object of last resort, using hard-coded strings.
1240      * This is an internal method, called by DateFormat.  It should never fail.
1241      * @param locale    the given locale.
1242      * @param status    Output param set to success/failure code on
1243      *                  exit.
1244      */
1245     SimpleDateFormat(const Locale&amp; locale, UErrorCode&amp; status); // Use default pattern
1246 
1247     /**
1248      * Hook called by format(... FieldPosition&amp; ...) and format(...FieldPositionIterator&amp;...)
1249      */
1250     UnicodeString&amp; _format(Calendar&amp; cal, UnicodeString&amp; appendTo, FieldPositionHandler&amp; handler, UErrorCode&amp; status) const;
1251 
1252     /**
1253      * Called by format() to format a single field.
1254      *
1255      * @param appendTo  Output parameter to receive result.
1256      *                  Result is appended to existing contents.
1257      * @param ch        The format character we encountered in the pattern.
1258      * @param count     Number of characters in the current pattern symbol (e.g.,
1259      *                  &quot;yyyy&quot; in the pattern would result in a call to this function
1260      *                  with ch equal to &#39;y&#39; and count equal to 4)
1261      * @param capitalizationContext Capitalization context for this date format.
1262      * @param fieldNum  Zero-based numbering of current field within the overall format.
1263      * @param handler   Records information about field positions.
1264      * @param cal       Calendar to use
1265      * @param status    Receives a status code, which will be U_ZERO_ERROR if the operation
1266      *                  succeeds.
1267      */
1268     void subFormat(UnicodeString &amp;appendTo,
1269                    char16_t ch,
1270                    int32_t count,
1271                    UDisplayContext capitalizationContext,
1272                    int32_t fieldNum,
1273                    FieldPositionHandler&amp; handler,
1274                    Calendar&amp; cal,
1275                    UErrorCode&amp; status) const; // in case of illegal argument
1276 
1277     /**
1278      * Used by subFormat() to format a numeric value.
1279      * Appends to toAppendTo a string representation of &quot;value&quot;
1280      * having a number of digits between &quot;minDigits&quot; and
1281      * &quot;maxDigits&quot;.  Uses the DateFormat&#39;s NumberFormat.
1282      *
1283      * @param currentNumberFormat
1284      * @param appendTo  Output parameter to receive result.
1285      *                  Formatted number is appended to existing contents.
1286      * @param value     Value to format.
1287      * @param minDigits Minimum number of digits the result should have
1288      * @param maxDigits Maximum number of digits the result should have
1289      */
1290     void zeroPaddingNumber(const NumberFormat *currentNumberFormat,
1291                            UnicodeString &amp;appendTo,
1292                            int32_t value,
1293                            int32_t minDigits,
1294                            int32_t maxDigits) const;
1295 
1296     /**
1297      * Return true if the given format character, occuring count
1298      * times, represents a numeric field.
1299      */
1300     static UBool isNumeric(char16_t formatChar, int32_t count);
1301 
1302     /**
1303      * Returns TRUE if the patternOffset is at the start of a numeric field.
1304      */
1305     static UBool isAtNumericField(const UnicodeString &amp;pattern, int32_t patternOffset);
1306 
1307     /**
1308      * Returns TRUE if the patternOffset is right after a non-numeric field.
1309      */
1310     static UBool isAfterNonNumericField(const UnicodeString &amp;pattern, int32_t patternOffset);
1311 
1312     /**
1313      * initializes fCalendar from parameters.  Returns fCalendar as a convenience.
1314      * @param adoptZone  Zone to be adopted, or NULL for TimeZone::createDefault().
1315      * @param locale Locale of the calendar
1316      * @param status Error code
1317      * @return the newly constructed fCalendar
1318      */
1319     Calendar *initializeCalendar(TimeZone* adoptZone, const Locale&amp; locale, UErrorCode&amp; status);
1320 
1321     /**
1322      * Called by several of the constructors to load pattern data and formatting symbols
1323      * out of a resource bundle and initialize the locale based on it.
1324      * @param timeStyle     The time style, as passed to DateFormat::createDateInstance().
1325      * @param dateStyle     The date style, as passed to DateFormat::createTimeInstance().
1326      * @param locale        The locale to load the patterns from.
1327      * @param status        Filled in with an error code if loading the data from the
1328      *                      resources fails.
1329      */
1330     void construct(EStyle timeStyle, EStyle dateStyle, const Locale&amp; locale, UErrorCode&amp; status);
1331 
1332     /**
1333      * Called by construct() and the various constructors to set up the SimpleDateFormat&#39;s
1334      * Calendar and NumberFormat objects.
1335      * @param locale    The locale for which we want a Calendar and a NumberFormat.
1336      * @param status    Filled in with an error code if creating either subobject fails.
1337      */
1338     void initialize(const Locale&amp; locale, UErrorCode&amp; status);
1339 
1340     /**
1341      * Private code-size reduction function used by subParse.
1342      * @param text the time text being parsed.
1343      * @param start where to start parsing.
1344      * @param field the date field being parsed.
1345      * @param stringArray the string array to parsed.
1346      * @param stringArrayCount the size of the array.
1347      * @param monthPattern pointer to leap month pattern, or NULL if none.
1348      * @param cal a Calendar set to the date and time to be formatted
1349      *            into a date/time string.
1350      * @return the new start position if matching succeeded; a negative number
1351      * indicating matching failure, otherwise.
1352      */
1353     int32_t matchString(const UnicodeString&amp; text, int32_t start, UCalendarDateFields field,
1354                         const UnicodeString* stringArray, int32_t stringArrayCount,
1355                         const UnicodeString* monthPattern, Calendar&amp; cal) const;
1356 
1357     /**
1358      * Private code-size reduction function used by subParse.
1359      * @param text the time text being parsed.
1360      * @param start where to start parsing.
1361      * @param field the date field being parsed.
1362      * @param stringArray the string array to parsed.
1363      * @param stringArrayCount the size of the array.
1364      * @param cal a Calendar set to the date and time to be formatted
1365      *            into a date/time string.
1366      * @return the new start position if matching succeeded; a negative number
1367      * indicating matching failure, otherwise.
1368      */
1369     int32_t matchQuarterString(const UnicodeString&amp; text, int32_t start, UCalendarDateFields field,
1370                                const UnicodeString* stringArray, int32_t stringArrayCount, Calendar&amp; cal) const;
1371 
1372     /**
1373      * Used by subParse() to match localized day period strings.
1374      */
1375     int32_t matchDayPeriodStrings(const UnicodeString&amp; text, int32_t start,
1376                                   const UnicodeString* stringArray, int32_t stringArrayCount,
1377                                   int32_t &amp;dayPeriod) const;
1378 
1379     /**
1380      * Private function used by subParse to match literal pattern text.
1381      *
1382      * @param pattern the pattern string
1383      * @param patternOffset the starting offset into the pattern text. On
1384      *        outupt will be set the offset of the first non-literal character in the pattern
1385      * @param text the text being parsed
1386      * @param textOffset the starting offset into the text. On output
1387      *                   will be set to the offset of the character after the match
1388      * @param whitespaceLenient &lt;code&gt;TRUE&lt;/code&gt; if whitespace parse is lenient, &lt;code&gt;FALSE&lt;/code&gt; otherwise.
1389      * @param partialMatchLenient &lt;code&gt;TRUE&lt;/code&gt; if partial match parse is lenient, &lt;code&gt;FALSE&lt;/code&gt; otherwise.
1390      * @param oldLeniency &lt;code&gt;TRUE&lt;/code&gt; if old leniency control is lenient, &lt;code&gt;FALSE&lt;/code&gt; otherwise.
1391      *
1392      * @return &lt;code&gt;TRUE&lt;/code&gt; if the literal text could be matched, &lt;code&gt;FALSE&lt;/code&gt; otherwise.
1393      */
1394     static UBool matchLiterals(const UnicodeString &amp;pattern, int32_t &amp;patternOffset,
1395                                const UnicodeString &amp;text, int32_t &amp;textOffset,
1396                                UBool whitespaceLenient, UBool partialMatchLenient, UBool oldLeniency);
1397 
1398     /**
1399      * Private member function that converts the parsed date strings into
1400      * timeFields. Returns -start (for ParsePosition) if failed.
1401      * @param text the time text to be parsed.
1402      * @param start where to start parsing.
1403      * @param ch the pattern character for the date field text to be parsed.
1404      * @param count the count of a pattern character.
1405      * @param obeyCount if true then the count is strictly obeyed.
1406      * @param allowNegative
1407      * @param ambiguousYear If true then the two-digit year == the default start year.
1408      * @param saveHebrewMonth Used to hang onto month until year is known.
1409      * @param cal a Calendar set to the date and time to be formatted
1410      *            into a date/time string.
1411      * @param patLoc
1412      * @param numericLeapMonthFormatter If non-null, used to parse numeric leap months.
1413      * @param tzTimeType the type of parsed time zone - standard, daylight or unknown (output).
1414      *      This parameter can be NULL if caller does not need the information.
1415      * @return the new start position if matching succeeded; a negative number
1416      * indicating matching failure, otherwise.
1417      */
1418     int32_t subParse(const UnicodeString&amp; text, int32_t&amp; start, char16_t ch, int32_t count,
1419                      UBool obeyCount, UBool allowNegative, UBool ambiguousYear[], int32_t&amp; saveHebrewMonth, Calendar&amp; cal,
1420                      int32_t patLoc, MessageFormat * numericLeapMonthFormatter, UTimeZoneFormatTimeType *tzTimeType,
1421                      int32_t *dayPeriod=NULL) const;
1422 
1423     void parseInt(const UnicodeString&amp; text,
1424                   Formattable&amp; number,
1425                   ParsePosition&amp; pos,
1426                   UBool allowNegative,
1427                   const NumberFormat *fmt) const;
1428 
1429     void parseInt(const UnicodeString&amp; text,
1430                   Formattable&amp; number,
1431                   int32_t maxDigits,
1432                   ParsePosition&amp; pos,
1433                   UBool allowNegative,
1434                   const NumberFormat *fmt) const;
1435 
1436     int32_t checkIntSuffix(const UnicodeString&amp; text, int32_t start,
1437                            int32_t patLoc, UBool isNegative) const;
1438 
1439     /**
1440      * Counts number of digit code points in the specified text.
1441      *
1442      * @param text  input text
1443      * @param start start index, inclusive
1444      * @param end   end index, exclusive
1445      * @return  number of digits found in the text in the specified range.
1446     */
1447     int32_t countDigits(const UnicodeString&amp; text, int32_t start, int32_t end) const;
1448 
1449     /**
1450      * Translate a pattern, mapping each character in the from string to the
1451      * corresponding character in the to string. Return an error if the original
1452      * pattern contains an unmapped character, or if a quote is unmatched.
1453      * Quoted (single quotes only) material is not translated.
1454      * @param originalPattern   the original pattern.
1455      * @param translatedPattern Output param to receive the translited pattern.
1456      * @param from              the characters to be translited from.
1457      * @param to                the characters to be translited to.
1458      * @param status            Receives a status code, which will be U_ZERO_ERROR
1459      *                          if the operation succeeds.
1460      */
1461     static void translatePattern(const UnicodeString&amp; originalPattern,
1462                                 UnicodeString&amp; translatedPattern,
1463                                 const UnicodeString&amp; from,
1464                                 const UnicodeString&amp; to,
1465                                 UErrorCode&amp; status);
1466 
1467     /**
1468      * Sets the starting date of the 100-year window that dates with 2-digit years
1469      * are considered to fall within.
1470      * @param startDate the start date
1471      * @param status    Receives a status code, which will be U_ZERO_ERROR
1472      *                  if the operation succeeds.
1473      */
1474     void         parseAmbiguousDatesAsAfter(UDate startDate, UErrorCode&amp; status);
1475 
1476     /**
1477      * Return the length matched by the given affix, or -1 if none.
1478      * Runs of white space in the affix, match runs of white space in
1479      * the input.
1480      * @param affix pattern string, taken as a literal
1481      * @param input input text
1482      * @param pos offset into input at which to begin matching
1483      * @return length of input that matches, or -1 if match failure
1484      */
1485     int32_t compareSimpleAffix(const UnicodeString&amp; affix,
1486                    const UnicodeString&amp; input,
1487                    int32_t pos) const;
1488 
1489     /**
1490      * Skip over a run of zero or more Pattern_White_Space characters at
1491      * pos in text.
1492      */
1493     int32_t skipPatternWhiteSpace(const UnicodeString&amp; text, int32_t pos) const;
1494 
1495     /**
1496      * Skip over a run of zero or more isUWhiteSpace() characters at pos
1497      * in text.
1498      */
1499     int32_t skipUWhiteSpace(const UnicodeString&amp; text, int32_t pos) const;
1500 
1501     /**
1502      * Initialize LocalizedNumberFormatter instances used for speedup.
1503      */
1504     void initFastNumberFormatters(UErrorCode&amp; status);
1505 
1506     /**
1507      * Delete the LocalizedNumberFormatter instances used for speedup.
1508      */
1509     void freeFastNumberFormatters();
1510 
1511     /**
1512      * Initialize NumberFormat instances used for numbering system overrides.
1513      */
1514     void initNumberFormatters(const Locale &amp;locale,UErrorCode &amp;status);
1515 
1516     /**
1517      * Parse the given override string and set up structures for number formats
1518      */
1519     void processOverrideString(const Locale &amp;locale, const UnicodeString &amp;str, int8_t type, UErrorCode &amp;status);
1520 
1521     /**
1522      * Used to map pattern characters to Calendar field identifiers.
1523      */
1524     static const UCalendarDateFields fgPatternIndexToCalendarField[];
1525 
1526     /**
1527      * Map index into pattern character string to DateFormat field number
1528      */
1529     static const UDateFormatField fgPatternIndexToDateFormatField[];
1530 
1531     /**
1532      * Lazy TimeZoneFormat instantiation, semantically const
1533      */
1534     TimeZoneFormat *tzFormat(UErrorCode &amp;status) const;
1535 
1536     const NumberFormat* getNumberFormatByIndex(UDateFormatField index) const;
1537 
1538     /**
1539      * Used to map Calendar field to field level.
1540      * The larger the level, the smaller the field unit.
1541      * For example, UCAL_ERA level is 0, UCAL_YEAR level is 10,
1542      * UCAL_MONTH level is 20.
1543      */
1544     static const int32_t fgCalendarFieldToLevel[];
1545 
1546     /**
1547      * Map calendar field letter into calendar field level.
1548      */
1549     static int32_t getLevelFromChar(char16_t ch);
1550 
1551     /**
1552      * Tell if a character can be used to define a field in a format string.
1553      */
1554     static UBool isSyntaxChar(char16_t ch);
1555 
1556     /**
1557      * The formatting pattern for this formatter.
1558      */
1559     UnicodeString       fPattern;
1560 
1561     /**
1562      * The numbering system override for dates.
1563      */
1564     UnicodeString       fDateOverride;
1565 
1566     /**
1567      * The numbering system override for times.
1568      */
1569     UnicodeString       fTimeOverride;
1570 
1571 
1572     /**
1573      * The original locale used (for reloading symbols)
1574      */
1575     Locale              fLocale;
1576 
1577     /**
1578      * A pointer to an object containing the strings to use in formatting (e.g.,
1579      * month and day names, AM and PM strings, time zone names, etc.)
1580      */
1581     DateFormatSymbols*  fSymbols;   // Owned
1582 
1583     /**
1584      * The time zone formatter
1585      */
1586     TimeZoneFormat* fTimeZoneFormat;
1587 
1588     /**
1589      * If dates have ambiguous years, we map them into the century starting
1590      * at defaultCenturyStart, which may be any date.  If defaultCenturyStart is
1591      * set to SYSTEM_DEFAULT_CENTURY, which it is by default, then the system
1592      * values are used.  The instance values defaultCenturyStart and
1593      * defaultCenturyStartYear are only used if explicitly set by the user
1594      * through the API method parseAmbiguousDatesAsAfter().
1595      */
1596     UDate                fDefaultCenturyStart;
1597 
1598     UBool                fHasMinute;
1599     UBool                fHasSecond;
<a name="5" id="anc5"></a>
1600 
1601     /**
1602      * Sets fHasMinutes and fHasSeconds.
1603      */
1604     void                 parsePattern();
1605 
1606     /**
1607      * See documentation for defaultCenturyStart.
1608      */
1609     /*transient*/ int32_t   fDefaultCenturyStartYear;
1610 
1611     struct NSOverride : public UMemory {
1612         const SharedNumberFormat *snf;
1613         int32_t hash;
1614         NSOverride *next;
1615         void free();
1616         NSOverride() : snf(NULL), hash(0), next(NULL) {
1617         }
1618         ~NSOverride();
1619     };
1620 
1621     /**
1622      * The number format in use for each date field. NULL means fall back
1623      * to fNumberFormat in DateFormat.
1624      */
1625     const SharedNumberFormat    **fSharedNumberFormatters;
1626 
1627     enum NumberFormatterKey {
1628         SMPDTFMT_NF_1x10,
1629         SMPDTFMT_NF_2x10,
1630         SMPDTFMT_NF_3x10,
1631         SMPDTFMT_NF_4x10,
1632         SMPDTFMT_NF_2x2,
1633         SMPDTFMT_NF_COUNT
1634     };
1635 
1636     /**
1637      * Number formatters pre-allocated for fast performance on the most common integer lengths.
1638      */
1639     const number::LocalizedNumberFormatter* fFastNumberFormatters[SMPDTFMT_NF_COUNT] = {};
1640 
1641     UBool fHaveDefaultCentury;
1642 
1643     BreakIterator* fCapitalizationBrkIter;
1644 };
1645 
1646 inline UDate
1647 SimpleDateFormat::get2DigitYearStart(UErrorCode&amp; /*status*/) const
1648 {
1649     return fDefaultCenturyStart;
1650 }
1651 
1652 U_NAMESPACE_END
1653 
1654 #endif /* #if !UCONFIG_NO_FORMATTING */
1655 
1656 #endif // _SMPDTFMT
1657 //eof
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>