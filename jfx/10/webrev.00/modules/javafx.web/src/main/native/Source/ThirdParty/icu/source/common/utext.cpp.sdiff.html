<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/utext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ustrcase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="utrace.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/utext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1179     u8b-&gt;bufNativeStart   = ix;
1180     u8b-&gt;bufNativeLimit   = ix;
1181     u8b-&gt;bufStartIdx      = 0;
1182     u8b-&gt;bufLimitIdx      = 0;
1183     u8b-&gt;bufNILimit       = 0;
1184     u8b-&gt;toUCharsMapStart = ix;
1185     u8b-&gt;mapToNative[0]   = 0;
1186     u8b-&gt;mapToUChars[0]   = 0;
1187     goto swapBuffersAndFail;
1188 
1189 
1190 
1191 fillForward:
1192     {
1193         // Move the incoming index to a code point boundary.
1194         U8_SET_CP_START(s8, 0, ix);
1195 
1196         // Swap the UText buffers.
1197         //  We want to fill what was previously the alternate buffer,
1198         //  and make what was the current buffer be the new alternate.
<span class="line-modified">1199         UTF8Buf *u8b = (UTF8Buf *)ut-&gt;q;</span>
1200         ut-&gt;q = ut-&gt;p;
<span class="line-modified">1201         ut-&gt;p = u8b;</span>
1202 
1203         int32_t strLen = ut-&gt;b;
1204         UBool   nulTerminated = FALSE;
1205         if (strLen &lt; 0) {
1206             strLen = 0x7fffffff;
1207             nulTerminated = TRUE;
1208         }
1209 
<span class="line-modified">1210         UChar   *buf = u8b-&gt;buf;</span>
<span class="line-modified">1211         uint8_t *mapToNative  = u8b-&gt;mapToNative;</span>
<span class="line-modified">1212         uint8_t *mapToUChars  = u8b-&gt;mapToUChars;</span>
1213         int32_t  destIx       = 0;
1214         int32_t  srcIx        = ix;
1215         UBool    seenNonAscii = FALSE;
1216         UChar32  c = 0;
1217 
1218         // Fill the chunk buffer and mapping arrays.
1219         while (destIx&lt;UTF8_TEXT_CHUNK_SIZE) {
1220             c = s8[srcIx];
1221             if (c&gt;0 &amp;&amp; c&lt;0x80) {
1222                 // Special case ASCII range for speed.
1223                 //   zero is excluded to simplify bounds checking.
1224                 buf[destIx] = (UChar)c;
1225                 mapToNative[destIx]    = (uint8_t)(srcIx - ix);
1226                 mapToUChars[srcIx-ix]  = (uint8_t)destIx;
1227                 srcIx++;
1228                 destIx++;
1229             } else {
1230                 // General case, handle everything.
1231                 if (seenNonAscii == FALSE) {
1232                     seenNonAscii = TRUE;
<span class="line-modified">1233                     u8b-&gt;bufNILimit = destIx;</span>
1234                 }
1235 
1236                 int32_t  cIx      = srcIx;
1237                 int32_t  dIx      = destIx;
1238                 int32_t  dIxSaved = destIx;
1239                 U8_NEXT_OR_FFFD(s8, srcIx, strLen, c);
1240                 if (c==0 &amp;&amp; nulTerminated) {
1241                     srcIx--;
1242                     break;
1243                 }
1244 
1245                 U16_APPEND_UNSAFE(buf, destIx, c);
1246                 do {
1247                     mapToNative[dIx++] = (uint8_t)(cIx - ix);
1248                 } while (dIx &lt; destIx);
1249 
1250                 do {
1251                     mapToUChars[cIx++ - ix] = (uint8_t)dIxSaved;
1252                 } while (cIx &lt; srcIx);
1253             }
1254             if (srcIx&gt;=strLen) {
1255                 break;
1256             }
1257 
1258         }
1259 
1260         //  store Native &lt;--&gt; Chunk Map entries for the end of the buffer.
1261         //    There is no actual character here, but the index position is valid.
1262         mapToNative[destIx]     = (uint8_t)(srcIx - ix);
1263         mapToUChars[srcIx - ix] = (uint8_t)destIx;
1264 
1265         //  fill in Buffer descriptor
<span class="line-modified">1266         u8b-&gt;bufNativeStart     = ix;</span>
<span class="line-modified">1267         u8b-&gt;bufNativeLimit     = srcIx;</span>
<span class="line-modified">1268         u8b-&gt;bufStartIdx        = 0;</span>
<span class="line-modified">1269         u8b-&gt;bufLimitIdx        = destIx;</span>
1270         if (seenNonAscii == FALSE) {
<span class="line-modified">1271             u8b-&gt;bufNILimit     = destIx;</span>
1272         }
<span class="line-modified">1273         u8b-&gt;toUCharsMapStart   = u8b-&gt;bufNativeStart;</span>
1274 
1275         // Set UText chunk to refer to this buffer.
1276         ut-&gt;chunkContents       = buf;
1277         ut-&gt;chunkOffset         = 0;
<span class="line-modified">1278         ut-&gt;chunkLength         = u8b-&gt;bufLimitIdx;</span>
<span class="line-modified">1279         ut-&gt;chunkNativeStart    = u8b-&gt;bufNativeStart;</span>
<span class="line-modified">1280         ut-&gt;chunkNativeLimit    = u8b-&gt;bufNativeLimit;</span>
<span class="line-modified">1281         ut-&gt;nativeIndexingLimit = u8b-&gt;bufNILimit;</span>
1282 
1283         // For zero terminated strings, keep track of the maximum point
1284         //   scanned so far.
1285         if (nulTerminated &amp;&amp; srcIx&gt;ut-&gt;c) {
1286             ut-&gt;c = srcIx;
1287             if (c==0) {
1288                 // We scanned to the end.
1289                 //   Remember the actual length.
1290                 ut-&gt;b = srcIx;
1291                 ut-&gt;providerProperties &amp;= ~I32_FLAG(UTEXT_PROVIDER_LENGTH_IS_EXPENSIVE);
1292             }
1293         }
1294         return TRUE;
1295     }
1296 
1297 
1298 fillReverse:
1299     {
1300         // Move the incoming index to a code point boundary.
1301         // Can only do this if the incoming index is somewhere in the interior of the string.
1302         //   If index is at the end, there is no character there to look at.
1303         if (ix != ut-&gt;b) {
1304             // Note: this function will only move the index back if it is on a trail byte
1305             //       and there is a preceding lead byte and the sequence from the lead
1306             //       through this trail could be part of a valid UTF-8 sequence
1307             //       Otherwise the index remains unchanged.
1308             U8_SET_CP_START(s8, 0, ix);
1309         }
1310 
1311         // Swap the UText buffers.
1312         //  We want to fill what was previously the alternate buffer,
1313         //  and make what was the current buffer be the new alternate.
<span class="line-modified">1314         UTF8Buf *u8b = (UTF8Buf *)ut-&gt;q;</span>
1315         ut-&gt;q = ut-&gt;p;
<span class="line-modified">1316         ut-&gt;p = u8b;</span>
1317 
<span class="line-modified">1318         UChar   *buf = u8b-&gt;buf;</span>
<span class="line-modified">1319         uint8_t *mapToNative = u8b-&gt;mapToNative;</span>
<span class="line-modified">1320         uint8_t *mapToUChars = u8b-&gt;mapToUChars;</span>
1321         int32_t  toUCharsMapStart = ix - sizeof(UTF8Buf::mapToUChars) + 1;
1322         // Note that toUCharsMapStart can be negative. Happens when the remaining
1323         // text from current position to the beginning is less than the buffer size.
1324         // + 1 because mapToUChars must have a slot at the end for the bufNativeLimit entry.
1325         int32_t  destIx = UTF8_TEXT_CHUNK_SIZE+2;   // Start in the overflow region
1326                                                     //   at end of buffer to leave room
1327                                                     //   for a surrogate pair at the
1328                                                     //   buffer start.
1329         int32_t  srcIx  = ix;
1330         int32_t  bufNILimit = destIx;
1331         UChar32   c;
1332 
1333         // Map to/from Native Indexes, fill in for the position at the end of
1334         //   the buffer.
1335         //
1336         mapToNative[destIx] = (uint8_t)(srcIx - toUCharsMapStart);
1337         mapToUChars[srcIx - toUCharsMapStart] = (uint8_t)destIx;
1338 
1339         // Fill the chunk buffer
1340         // Work backwards, filling from the end of the buffer towards the front.
</pre>
<hr />
<pre>
1370                 } else {
1371                     buf[destIx]         = U16_TRAIL(c);
1372                     mapToNative[destIx] = (uint8_t)(srcIx - toUCharsMapStart);
1373                     buf[--destIx]       = U16_LEAD(c);
1374                     mapToNative[destIx] = (uint8_t)(srcIx - toUCharsMapStart);
1375                 }
1376 
1377                 // Fill in the map from native indexes to UChars buf index.
1378                 do {
1379                     mapToUChars[sIx-- - toUCharsMapStart] = (uint8_t)destIx;
1380                 } while (sIx &gt;= srcIx);
1381                 U_ASSERT(toUCharsMapStart &lt;= (srcIx+1));
1382 
1383                 // Set native indexing limit to be the current position.
1384                 //   We are processing a non-ascii, non-native-indexing char now;
1385                 //     the limit will be here if the rest of the chars to be
1386                 //     added to this buffer are ascii.
1387                 bufNILimit = destIx;
1388             }
1389         }
<span class="line-modified">1390         u8b-&gt;bufNativeStart     = srcIx;</span>
<span class="line-modified">1391         u8b-&gt;bufNativeLimit     = ix;</span>
<span class="line-modified">1392         u8b-&gt;bufStartIdx        = destIx;</span>
<span class="line-modified">1393         u8b-&gt;bufLimitIdx        = UTF8_TEXT_CHUNK_SIZE+2;</span>
<span class="line-modified">1394         u8b-&gt;bufNILimit         = bufNILimit - u8b-&gt;bufStartIdx;</span>
<span class="line-modified">1395         u8b-&gt;toUCharsMapStart   = toUCharsMapStart;</span>
<span class="line-modified">1396 </span>
<span class="line-modified">1397         ut-&gt;chunkContents       = &amp;buf[u8b-&gt;bufStartIdx];</span>
<span class="line-modified">1398         ut-&gt;chunkLength         = u8b-&gt;bufLimitIdx - u8b-&gt;bufStartIdx;</span>
1399         ut-&gt;chunkOffset         = ut-&gt;chunkLength;
<span class="line-modified">1400         ut-&gt;chunkNativeStart    = u8b-&gt;bufNativeStart;</span>
<span class="line-modified">1401         ut-&gt;chunkNativeLimit    = u8b-&gt;bufNativeLimit;</span>
<span class="line-modified">1402         ut-&gt;nativeIndexingLimit = u8b-&gt;bufNILimit;</span>
1403         return TRUE;
1404     }
1405 
1406 }
1407 
1408 
1409 
1410 //
1411 //  This is a slightly modified copy of u_strFromUTF8,
1412 //     Inserts a Replacement Char rather than failing on invalid UTF-8
1413 //     Removes unnecessary features.
1414 //
1415 static UChar*
1416 utext_strFromUTF8(UChar *dest,
1417               int32_t destCapacity,
1418               int32_t *pDestLength,
1419               const char* src,
1420               int32_t srcLength,        // required.  NUL terminated not supported.
1421               UErrorCode *pErrorCode
1422               )
</pre>
</td>
<td>
<hr />
<pre>
1179     u8b-&gt;bufNativeStart   = ix;
1180     u8b-&gt;bufNativeLimit   = ix;
1181     u8b-&gt;bufStartIdx      = 0;
1182     u8b-&gt;bufLimitIdx      = 0;
1183     u8b-&gt;bufNILimit       = 0;
1184     u8b-&gt;toUCharsMapStart = ix;
1185     u8b-&gt;mapToNative[0]   = 0;
1186     u8b-&gt;mapToUChars[0]   = 0;
1187     goto swapBuffersAndFail;
1188 
1189 
1190 
1191 fillForward:
1192     {
1193         // Move the incoming index to a code point boundary.
1194         U8_SET_CP_START(s8, 0, ix);
1195 
1196         // Swap the UText buffers.
1197         //  We want to fill what was previously the alternate buffer,
1198         //  and make what was the current buffer be the new alternate.
<span class="line-modified">1199         UTF8Buf *u8b_swap = (UTF8Buf *)ut-&gt;q;</span>
1200         ut-&gt;q = ut-&gt;p;
<span class="line-modified">1201         ut-&gt;p = u8b_swap;</span>
1202 
1203         int32_t strLen = ut-&gt;b;
1204         UBool   nulTerminated = FALSE;
1205         if (strLen &lt; 0) {
1206             strLen = 0x7fffffff;
1207             nulTerminated = TRUE;
1208         }
1209 
<span class="line-modified">1210         UChar   *buf = u8b_swap-&gt;buf;</span>
<span class="line-modified">1211         uint8_t *mapToNative  = u8b_swap-&gt;mapToNative;</span>
<span class="line-modified">1212         uint8_t *mapToUChars  = u8b_swap-&gt;mapToUChars;</span>
1213         int32_t  destIx       = 0;
1214         int32_t  srcIx        = ix;
1215         UBool    seenNonAscii = FALSE;
1216         UChar32  c = 0;
1217 
1218         // Fill the chunk buffer and mapping arrays.
1219         while (destIx&lt;UTF8_TEXT_CHUNK_SIZE) {
1220             c = s8[srcIx];
1221             if (c&gt;0 &amp;&amp; c&lt;0x80) {
1222                 // Special case ASCII range for speed.
1223                 //   zero is excluded to simplify bounds checking.
1224                 buf[destIx] = (UChar)c;
1225                 mapToNative[destIx]    = (uint8_t)(srcIx - ix);
1226                 mapToUChars[srcIx-ix]  = (uint8_t)destIx;
1227                 srcIx++;
1228                 destIx++;
1229             } else {
1230                 // General case, handle everything.
1231                 if (seenNonAscii == FALSE) {
1232                     seenNonAscii = TRUE;
<span class="line-modified">1233                     u8b_swap-&gt;bufNILimit = destIx;</span>
1234                 }
1235 
1236                 int32_t  cIx      = srcIx;
1237                 int32_t  dIx      = destIx;
1238                 int32_t  dIxSaved = destIx;
1239                 U8_NEXT_OR_FFFD(s8, srcIx, strLen, c);
1240                 if (c==0 &amp;&amp; nulTerminated) {
1241                     srcIx--;
1242                     break;
1243                 }
1244 
1245                 U16_APPEND_UNSAFE(buf, destIx, c);
1246                 do {
1247                     mapToNative[dIx++] = (uint8_t)(cIx - ix);
1248                 } while (dIx &lt; destIx);
1249 
1250                 do {
1251                     mapToUChars[cIx++ - ix] = (uint8_t)dIxSaved;
1252                 } while (cIx &lt; srcIx);
1253             }
1254             if (srcIx&gt;=strLen) {
1255                 break;
1256             }
1257 
1258         }
1259 
1260         //  store Native &lt;--&gt; Chunk Map entries for the end of the buffer.
1261         //    There is no actual character here, but the index position is valid.
1262         mapToNative[destIx]     = (uint8_t)(srcIx - ix);
1263         mapToUChars[srcIx - ix] = (uint8_t)destIx;
1264 
1265         //  fill in Buffer descriptor
<span class="line-modified">1266         u8b_swap-&gt;bufNativeStart     = ix;</span>
<span class="line-modified">1267         u8b_swap-&gt;bufNativeLimit     = srcIx;</span>
<span class="line-modified">1268         u8b_swap-&gt;bufStartIdx        = 0;</span>
<span class="line-modified">1269         u8b_swap-&gt;bufLimitIdx        = destIx;</span>
1270         if (seenNonAscii == FALSE) {
<span class="line-modified">1271             u8b_swap-&gt;bufNILimit     = destIx;</span>
1272         }
<span class="line-modified">1273         u8b_swap-&gt;toUCharsMapStart   = u8b_swap-&gt;bufNativeStart;</span>
1274 
1275         // Set UText chunk to refer to this buffer.
1276         ut-&gt;chunkContents       = buf;
1277         ut-&gt;chunkOffset         = 0;
<span class="line-modified">1278         ut-&gt;chunkLength         = u8b_swap-&gt;bufLimitIdx;</span>
<span class="line-modified">1279         ut-&gt;chunkNativeStart    = u8b_swap-&gt;bufNativeStart;</span>
<span class="line-modified">1280         ut-&gt;chunkNativeLimit    = u8b_swap-&gt;bufNativeLimit;</span>
<span class="line-modified">1281         ut-&gt;nativeIndexingLimit = u8b_swap-&gt;bufNILimit;</span>
1282 
1283         // For zero terminated strings, keep track of the maximum point
1284         //   scanned so far.
1285         if (nulTerminated &amp;&amp; srcIx&gt;ut-&gt;c) {
1286             ut-&gt;c = srcIx;
1287             if (c==0) {
1288                 // We scanned to the end.
1289                 //   Remember the actual length.
1290                 ut-&gt;b = srcIx;
1291                 ut-&gt;providerProperties &amp;= ~I32_FLAG(UTEXT_PROVIDER_LENGTH_IS_EXPENSIVE);
1292             }
1293         }
1294         return TRUE;
1295     }
1296 
1297 
1298 fillReverse:
1299     {
1300         // Move the incoming index to a code point boundary.
1301         // Can only do this if the incoming index is somewhere in the interior of the string.
1302         //   If index is at the end, there is no character there to look at.
1303         if (ix != ut-&gt;b) {
1304             // Note: this function will only move the index back if it is on a trail byte
1305             //       and there is a preceding lead byte and the sequence from the lead
1306             //       through this trail could be part of a valid UTF-8 sequence
1307             //       Otherwise the index remains unchanged.
1308             U8_SET_CP_START(s8, 0, ix);
1309         }
1310 
1311         // Swap the UText buffers.
1312         //  We want to fill what was previously the alternate buffer,
1313         //  and make what was the current buffer be the new alternate.
<span class="line-modified">1314         UTF8Buf *u8b_swap = (UTF8Buf *)ut-&gt;q;</span>
1315         ut-&gt;q = ut-&gt;p;
<span class="line-modified">1316         ut-&gt;p = u8b_swap;</span>
1317 
<span class="line-modified">1318         UChar   *buf = u8b_swap-&gt;buf;</span>
<span class="line-modified">1319         uint8_t *mapToNative = u8b_swap-&gt;mapToNative;</span>
<span class="line-modified">1320         uint8_t *mapToUChars = u8b_swap-&gt;mapToUChars;</span>
1321         int32_t  toUCharsMapStart = ix - sizeof(UTF8Buf::mapToUChars) + 1;
1322         // Note that toUCharsMapStart can be negative. Happens when the remaining
1323         // text from current position to the beginning is less than the buffer size.
1324         // + 1 because mapToUChars must have a slot at the end for the bufNativeLimit entry.
1325         int32_t  destIx = UTF8_TEXT_CHUNK_SIZE+2;   // Start in the overflow region
1326                                                     //   at end of buffer to leave room
1327                                                     //   for a surrogate pair at the
1328                                                     //   buffer start.
1329         int32_t  srcIx  = ix;
1330         int32_t  bufNILimit = destIx;
1331         UChar32   c;
1332 
1333         // Map to/from Native Indexes, fill in for the position at the end of
1334         //   the buffer.
1335         //
1336         mapToNative[destIx] = (uint8_t)(srcIx - toUCharsMapStart);
1337         mapToUChars[srcIx - toUCharsMapStart] = (uint8_t)destIx;
1338 
1339         // Fill the chunk buffer
1340         // Work backwards, filling from the end of the buffer towards the front.
</pre>
<hr />
<pre>
1370                 } else {
1371                     buf[destIx]         = U16_TRAIL(c);
1372                     mapToNative[destIx] = (uint8_t)(srcIx - toUCharsMapStart);
1373                     buf[--destIx]       = U16_LEAD(c);
1374                     mapToNative[destIx] = (uint8_t)(srcIx - toUCharsMapStart);
1375                 }
1376 
1377                 // Fill in the map from native indexes to UChars buf index.
1378                 do {
1379                     mapToUChars[sIx-- - toUCharsMapStart] = (uint8_t)destIx;
1380                 } while (sIx &gt;= srcIx);
1381                 U_ASSERT(toUCharsMapStart &lt;= (srcIx+1));
1382 
1383                 // Set native indexing limit to be the current position.
1384                 //   We are processing a non-ascii, non-native-indexing char now;
1385                 //     the limit will be here if the rest of the chars to be
1386                 //     added to this buffer are ascii.
1387                 bufNILimit = destIx;
1388             }
1389         }
<span class="line-modified">1390         u8b_swap-&gt;bufNativeStart     = srcIx;</span>
<span class="line-modified">1391         u8b_swap-&gt;bufNativeLimit     = ix;</span>
<span class="line-modified">1392         u8b_swap-&gt;bufStartIdx        = destIx;</span>
<span class="line-modified">1393         u8b_swap-&gt;bufLimitIdx        = UTF8_TEXT_CHUNK_SIZE+2;</span>
<span class="line-modified">1394         u8b_swap-&gt;bufNILimit         = bufNILimit - u8b_swap-&gt;bufStartIdx;</span>
<span class="line-modified">1395         u8b_swap-&gt;toUCharsMapStart   = toUCharsMapStart;</span>
<span class="line-modified">1396 </span>
<span class="line-modified">1397         ut-&gt;chunkContents       = &amp;buf[u8b_swap-&gt;bufStartIdx];</span>
<span class="line-modified">1398         ut-&gt;chunkLength         = u8b_swap-&gt;bufLimitIdx - u8b_swap-&gt;bufStartIdx;</span>
1399         ut-&gt;chunkOffset         = ut-&gt;chunkLength;
<span class="line-modified">1400         ut-&gt;chunkNativeStart    = u8b_swap-&gt;bufNativeStart;</span>
<span class="line-modified">1401         ut-&gt;chunkNativeLimit    = u8b_swap-&gt;bufNativeLimit;</span>
<span class="line-modified">1402         ut-&gt;nativeIndexingLimit = u8b_swap-&gt;bufNILimit;</span>
1403         return TRUE;
1404     }
1405 
1406 }
1407 
1408 
1409 
1410 //
1411 //  This is a slightly modified copy of u_strFromUTF8,
1412 //     Inserts a Replacement Char rather than failing on invalid UTF-8
1413 //     Removes unnecessary features.
1414 //
1415 static UChar*
1416 utext_strFromUTF8(UChar *dest,
1417               int32_t destCapacity,
1418               int32_t *pDestLength,
1419               const char* src,
1420               int32_t srcLength,        // required.  NUL terminated not supported.
1421               UErrorCode *pErrorCode
1422               )
</pre>
</td>
</tr>
</table>
<center><a href="ustrcase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="utrace.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>