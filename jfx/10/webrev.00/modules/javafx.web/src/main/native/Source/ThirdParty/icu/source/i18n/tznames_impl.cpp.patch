diff a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tznames_impl.cpp b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tznames_impl.cpp
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tznames_impl.cpp
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tznames_impl.cpp
@@ -47,12 +47,14 @@
 
 // stuff for TZDBTimeZoneNames
 static const char* TZDBNAMES_KEYS[]               = {"ss", "sd"};
 static const int32_t TZDBNAMES_KEYS_SIZE = UPRV_LENGTHOF(TZDBNAMES_KEYS);
 
-static UMutex gTZDBNamesMapLock = U_MUTEX_INITIALIZER;
-static UMutex gDataMutex = U_MUTEX_INITIALIZER;
+static UMutex *gDataMutex() {
+    static UMutex m = U_MUTEX_INITIALIZER;
+    return &m;
+}
 
 static UHashtable* gTZDBNamesMap = NULL;
 static icu::UInitOnce gTZDBNamesMapInitOnce = U_INITONCE_INITIALIZER;
 
 static TextTrieMap* gTZDBNamesTrie = NULL;
@@ -355,12 +357,10 @@
         nodeIndex = current->fNextSibling;
     }
     return NULL;
 }
 
-// Mutex for protecting the lazy creation of the Trie node structure on the first call to search().
-static UMutex TextTrieMutex = U_MUTEX_INITIALIZER;
 
 // buildTrie() - The Trie node structure is needed.  Create it from the data that was
 //               saved at the time the ZoneStringFormatter was created.  The Trie is only
 //               needed for parsing operations, which are less common than formatting,
 //               and the Trie is big, which is why its creation is deferred until first use.
@@ -384,10 +384,14 @@
         // TODO: if locking the mutex for each check proves to be a performance problem,
         //       add a flag of type atomic_int32_t to class TextTrieMap, and use only
         //       the ICU atomic safe functions for assigning and testing.
         //       Don't test the pointer fLazyContents.
         //       Don't do unless it's really required.
+
+        // Mutex for protecting the lazy creation of the Trie node structure on the first call to search().
+        static UMutex TextTrieMutex = U_MUTEX_INITIALIZER;
+
         Mutex lock(&TextTrieMutex);
         if (fLazyContents != NULL) {
             TextTrieMap *nonConstThis = const_cast<TextTrieMap *>(this);
             nonConstThis->buildTrie(status);
         }
@@ -1208,11 +1212,11 @@
 
     ZNames *znames = NULL;
     TimeZoneNamesImpl *nonConstThis = const_cast<TimeZoneNamesImpl *>(this);
 
     {
-        Mutex lock(&gDataMutex);
+        Mutex lock(gDataMutex());
         UErrorCode status = U_ZERO_ERROR;
         znames = nonConstThis->loadMetaZoneNames(mzID, status);
         if (U_FAILURE(status)) { return name; }
     }
 
@@ -1234,11 +1238,11 @@
 
     ZNames *tznames = NULL;
     TimeZoneNamesImpl *nonConstThis = const_cast<TimeZoneNamesImpl *>(this);
 
     {
-        Mutex lock(&gDataMutex);
+        Mutex lock(gDataMutex());
         UErrorCode status = U_ZERO_ERROR;
         tznames = nonConstThis->loadTimeZoneNames(tzID, status);
         if (U_FAILURE(status)) { return name; }
     }
 
@@ -1257,11 +1261,11 @@
     const UChar* locName = NULL;
     ZNames *tznames = NULL;
     TimeZoneNamesImpl *nonConstThis = const_cast<TimeZoneNamesImpl *>(this);
 
     {
-        Mutex lock(&gDataMutex);
+        Mutex lock(gDataMutex());
         UErrorCode status = U_ZERO_ERROR;
         tznames = nonConstThis->loadTimeZoneNames(tzID, status);
         if (U_FAILURE(status)) { return name; }
     }
 
@@ -1283,11 +1287,11 @@
         return;
     }
 
     char mzIdChar[ZID_KEY_MAX + 1];
     int32_t keyLen;
-    int32_t prefixLen = uprv_strlen(gMZPrefix);
+    int32_t prefixLen = static_cast<int32_t>(uprv_strlen(gMZPrefix));
     keyLen = mzID.extract(0, mzID.length(), mzIdChar, ZID_KEY_MAX + 1, US_INV);
     uprv_memcpy((void *)result, (void *)gMZPrefix, prefixLen);
     uprv_memcpy((void *)(result + prefixLen), (void *)mzIdChar, keyLen);
     result[keyLen + prefixLen] = '\0';
 }
@@ -1352,11 +1356,11 @@
     TimeZoneNamesImpl* nonConstThis = const_cast<TimeZoneNamesImpl*>(this);
 
     // Synchronize so that data is not loaded multiple times.
     // TODO: Consider more fine-grained synchronization.
     {
-        Mutex lock(&gDataMutex);
+        Mutex lock(gDataMutex());
 
         // First try of lookup.
         matches = doFind(handler, text, start, status);
         if (U_FAILURE(status)) { return NULL; }
         if (matches != NULL) {
@@ -1451,11 +1455,11 @@
         uhash_setValueDeleter(keyToLoader, deleteZNamesLoader);
     }
     virtual ~ZoneStringsLoader();
 
     void* createKey(const char* key, UErrorCode& status) {
-        int32_t len = sizeof(char) * (uprv_strlen(key) + 1);
+        int32_t len = sizeof(char) * (static_cast<int32_t>(uprv_strlen(key)) + 1);
         char* newKey = (char*) uprv_malloc(len);
         if (newKey == NULL) {
             status = U_MEMORY_ALLOCATION_ERROR;
             return NULL;
         }
@@ -1467,11 +1471,11 @@
     UBool isMetaZone(const char* key) {
         return (uprv_strlen(key) >= MZ_PREFIX_LEN && uprv_memcmp(key, gMZPrefix, MZ_PREFIX_LEN) == 0);
     }
 
     UnicodeString mzIDFromKey(const char* key) {
-        return UnicodeString(key + MZ_PREFIX_LEN, uprv_strlen(key) - MZ_PREFIX_LEN, US_INV);
+        return UnicodeString(key + MZ_PREFIX_LEN, static_cast<int32_t>(uprv_strlen(key)) - MZ_PREFIX_LEN, US_INV);
     }
 
     UnicodeString tzIDFromKey(const char* key) {
         UnicodeString tzID(key, -1, US_INV);
         // Replace all colons ':' with slashes '/'
@@ -1579,11 +1583,11 @@
 
 void TimeZoneNamesImpl::loadAllDisplayNames(UErrorCode& status) {
     if (U_FAILURE(status)) return;
 
     {
-        Mutex lock(&gDataMutex);
+        Mutex lock(gDataMutex());
         internalLoadAllDisplayNames(status);
     }
 }
 
 void TimeZoneNamesImpl::getDisplayNames(const UnicodeString& tzID,
@@ -1596,11 +1600,11 @@
     void* mznames = NULL;
     TimeZoneNamesImpl *nonConstThis = const_cast<TimeZoneNamesImpl*>(this);
 
     // Load the time zone strings
     {
-        Mutex lock(&gDataMutex);
+        Mutex lock(gDataMutex());
         tznames = (void*) nonConstThis->loadTimeZoneNames(tzID, status);
         if (U_FAILURE(status)) { return; }
     }
     U_ASSERT(tznames != NULL);
 
@@ -1616,11 +1620,11 @@
                 if (mzID.isEmpty()) {
                     mznames = (void*) EMPTY;
                 } else {
                     // Load the meta zone strings
                     // Mutex is scoped to the "else" statement
-                    Mutex lock(&gDataMutex);
+                    Mutex lock(gDataMutex());
                     mznames = (void*) nonConstThis->loadMetaZoneNames(mzID, status);
                     if (U_FAILURE(status)) { return; }
                     // Note: when the metazone doesn't exist, in Java, loadMetaZoneNames returns
                     // a dummy object instead of NULL.
                     if (mznames == NULL) {
@@ -1942,12 +1946,12 @@
                     // non-default metazone mapping for an abbreviation
                     // comes with applicable regions. For example, the default
                     // metazone mapping for "CST" is America_Central,
                     // but if region is one of CN/MO/TW, "CST" is parsed
                     // as metazone China (China Standard Time).
-                    for (int32_t i = 0; i < ninfo->nRegions; i++) {
-                        const char *region = ninfo->parseRegions[i];
+                    for (int32_t j = 0; j < ninfo->nRegions; j++) {
+                        const char *region = ninfo->parseRegions[j];
                         if (uprv_strcmp(fRegion, region) == 0) {
                             match = ninfo;
                             matchRegion = TRUE;
                             break;
                         }
@@ -2057,11 +2061,11 @@
     }
 
     const UnicodeString *mzID;
     StringEnumeration *mzIDs = TimeZoneNamesImpl::_getAvailableMetaZoneIDs(status);
     if (U_SUCCESS(status)) {
-        while ((mzID = mzIDs->snext(status)) && U_SUCCESS(status)) {
+        while ((mzID = mzIDs->snext(status)) != 0 && U_SUCCESS(status)) {
             const TZDBNames *names = TZDBTimeZoneNames::getMetaZoneNames(*mzID, status);
             if (U_FAILURE(status)) {
                 break;
             }
             if (names == NULL) {
@@ -2126,11 +2130,11 @@
 
 TZDBTimeZoneNames::TZDBTimeZoneNames(const Locale& locale)
 : fLocale(locale) {
     UBool useWorld = TRUE;
     const char* region = fLocale.getCountry();
-    int32_t regionLen = uprv_strlen(region);
+    int32_t regionLen = static_cast<int32_t>(uprv_strlen(region));
     if (regionLen == 0) {
         UErrorCode status = U_ZERO_ERROR;
         char loc[ULOC_FULLNAME_CAPACITY];
         uloc_addLikelySubtags(fLocale.getName(), loc, sizeof(loc), &status);
         regionLen = uloc_getCountry(loc, fRegion, sizeof(fRegion), &status);
@@ -2241,10 +2245,11 @@
     UChar mzIDKey[ZID_KEY_MAX + 1];
     mzID.extract(mzIDKey, ZID_KEY_MAX + 1, status);
     U_ASSERT(status == U_ZERO_ERROR);   // already checked length above
     mzIDKey[mzID.length()] = 0;
 
+    static UMutex gTZDBNamesMapLock = U_MUTEX_INITIALIZER;
     umtx_lock(&gTZDBNamesMapLock);
     {
         void *cacheVal = uhash_get(gTZDBNamesMap, mzIDKey);
         if (cacheVal == NULL) {
             UResourceBundle *zoneStringsRes = ures_openDirect(U_ICUDATA_ZONE, "tzdbNames", &status);
