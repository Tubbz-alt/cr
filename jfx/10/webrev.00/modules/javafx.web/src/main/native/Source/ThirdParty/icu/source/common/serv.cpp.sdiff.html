<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/serv.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="resbund.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="servls.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/serv.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
316 }
317 
318 StringPair::StringPair(const UnicodeString&amp; _displayName,
319                        const UnicodeString&amp; _id)
320 : displayName(_displayName)
321 , id(_id)
322 {
323 }
324 
325 U_CDECL_BEGIN
326 static void U_CALLCONV
327 userv_deleteStringPair(void *obj) {
328     U_NAMESPACE_USE delete (StringPair*) obj;
329 }
330 U_CDECL_END
331 
332 /*
333 ******************************************************************
334 */
335 
<span class="line-modified">336 static UMutex lock = U_MUTEX_INITIALIZER;</span>



337 
338 ICUService::ICUService()
339 : name()
340 , timestamp(0)
341 , factories(NULL)
342 , serviceCache(NULL)
343 , idCache(NULL)
344 , dnCache(NULL)
345 {
346 }
347 
348 ICUService::ICUService(const UnicodeString&amp; newName)
349 : name(newName)
350 , timestamp(0)
351 , factories(NULL)
352 , serviceCache(NULL)
353 , idCache(NULL)
354 , dnCache(NULL)
355 {
356 }
357 
358 ICUService::~ICUService()
359 {
360     {
<span class="line-modified">361         Mutex mutex(&amp;lock);</span>
362         clearCaches();
363         delete factories;
364         factories = NULL;
365     }
366 }
367 
368 UObject*
369 ICUService::get(const UnicodeString&amp; descriptor, UErrorCode&amp; status) const
370 {
371     return get(descriptor, NULL, status);
372 }
373 
374 UObject*
375 ICUService::get(const UnicodeString&amp; descriptor, UnicodeString* actualReturn, UErrorCode&amp; status) const
376 {
377     UObject* result = NULL;
378     ICUServiceKey* key = createKey(&amp;descriptor, status);
379     if (key) {
380         result = getKey(*key, actualReturn, status);
381         delete key;
</pre>
<hr />
<pre>
432         return NULL;
433     }
434 
435     if (isDefault()) {
436         return handleDefault(key, actualReturn, status);
437     }
438 
439     ICUService* ncthis = (ICUService*)this; // cast away semantic const
440 
441     CacheEntry* result = NULL;
442     {
443         // The factory list can&#39;t be modified until we&#39;re done,
444         // otherwise we might update the cache with an invalid result.
445         // The cache has to stay in synch with the factory list.
446         // ICU doesn&#39;t have monitors so we can&#39;t use rw locks, so
447         // we single-thread everything using this service, for now.
448 
449         // if factory is not null, we&#39;re calling from within the mutex,
450         // and since some unix machines don&#39;t have reentrant mutexes we
451         // need to make sure not to try to lock it again.
<span class="line-modified">452         XMutex mutex(&amp;lock, factory != NULL);</span>
453 
454         if (serviceCache == NULL) {
455             ncthis-&gt;serviceCache = new Hashtable(status);
456             if (ncthis-&gt;serviceCache == NULL) {
457                 return NULL;
458             }
459             if (U_FAILURE(status)) {
460                 delete serviceCache;
461                 return NULL;
462             }
463             serviceCache-&gt;setValueDeleter(cacheDeleter);
464         }
465 
466         UnicodeString currentDescriptor;
467         UVectorDeleter cacheDescriptorList;
468         UBool putInCache = FALSE;
469 
470         int32_t startIndex = 0;
471         int32_t limit = factories-&gt;size();
472         UBool cacheResult = TRUE;
</pre>
<hr />
<pre>
598 ICUService::handleDefault(const ICUServiceKey&amp; /* key */, UnicodeString* /* actualIDReturn */, UErrorCode&amp; /* status */) const
599 {
600     return NULL;
601 }
602 
603 UVector&amp;
604 ICUService::getVisibleIDs(UVector&amp; result, UErrorCode&amp; status) const {
605     return getVisibleIDs(result, NULL, status);
606 }
607 
608 UVector&amp;
609 ICUService::getVisibleIDs(UVector&amp; result, const UnicodeString* matchID, UErrorCode&amp; status) const
610 {
611     result.removeAllElements();
612 
613     if (U_FAILURE(status)) {
614         return result;
615     }
616 
617     {
<span class="line-modified">618         Mutex mutex(&amp;lock);</span>
619         const Hashtable* map = getVisibleIDMap(status);
620         if (map != NULL) {
621             ICUServiceKey* fallbackKey = createKey(matchID, status);
622 
623             for (int32_t pos = UHASH_FIRST;;) {
624                 const UHashElement* e = map-&gt;nextElement(pos);
625                 if (e == NULL) {
626                     break;
627                 }
628 
629                 const UnicodeString* id = (const UnicodeString*)e-&gt;key.pointer;
630                 if (fallbackKey != NULL) {
631                     if (!fallbackKey-&gt;isFallbackOf(*id)) {
632                         continue;
633                     }
634                 }
635 
636                 UnicodeString* idClone = new UnicodeString(*id);
637                 if (idClone == NULL || idClone-&gt;isBogus()) {
638                     delete idClone;
</pre>
<hr />
<pre>
675                 ncthis-&gt;idCache = NULL;
676             }
677         }
678     }
679 
680     return idCache;
681 }
682 
683 
684 UnicodeString&amp;
685 ICUService::getDisplayName(const UnicodeString&amp; id, UnicodeString&amp; result) const
686 {
687     return getDisplayName(id, result, Locale::getDefault());
688 }
689 
690 UnicodeString&amp;
691 ICUService::getDisplayName(const UnicodeString&amp; id, UnicodeString&amp; result, const Locale&amp; locale) const
692 {
693     {
694         UErrorCode status = U_ZERO_ERROR;
<span class="line-modified">695         Mutex mutex(&amp;lock);</span>
696         const Hashtable* map = getVisibleIDMap(status);
697         if (map != NULL) {
698             ICUServiceFactory* f = (ICUServiceFactory*)map-&gt;get(id);
699             if (f != NULL) {
700                 f-&gt;getDisplayName(id, locale, result);
701                 return result;
702             }
703 
704             // fallback
<span class="line-modified">705             UErrorCode status = U_ZERO_ERROR;</span>
706             ICUServiceKey* fallbackKey = createKey(&amp;id, status);
<span class="line-modified">707             while (fallbackKey-&gt;fallback()) {</span>
708                 UnicodeString us;
709                 fallbackKey-&gt;currentID(us);
710                 f = (ICUServiceFactory*)map-&gt;get(us);
711                 if (f != NULL) {
712                     f-&gt;getDisplayName(id, locale, result);
713                     delete fallbackKey;
714                     return result;
715                 }
716             }
717             delete fallbackKey;
718         }
719     }
720     result.setToBogus();
721     return result;
722 }
723 
724 UVector&amp;
725 ICUService::getDisplayNames(UVector&amp; result, UErrorCode&amp; status) const
726 {
727     return getDisplayNames(result, Locale::getDefault(), NULL, status);
728 }
729 
730 
731 UVector&amp;
732 ICUService::getDisplayNames(UVector&amp; result, const Locale&amp; locale, UErrorCode&amp; status) const
733 {
734     return getDisplayNames(result, locale, NULL, status);
735 }
736 
737 UVector&amp;
738 ICUService::getDisplayNames(UVector&amp; result,
739                             const Locale&amp; locale,
740                             const UnicodeString* matchID,
741                             UErrorCode&amp; status) const
742 {
743     result.removeAllElements();
744     result.setDeleter(userv_deleteStringPair);
745     if (U_SUCCESS(status)) {
746         ICUService* ncthis = (ICUService*)this; // cast away semantic const
<span class="line-modified">747         Mutex mutex(&amp;lock);</span>
748 
749         if (dnCache != NULL &amp;&amp; dnCache-&gt;locale != locale) {
750             delete dnCache;
751             ncthis-&gt;dnCache = NULL;
752         }
753 
754         if (dnCache == NULL) {
755             const Hashtable* m = getVisibleIDMap(status);
756             if (U_FAILURE(status)) {
757                 return result;
758             }
759             ncthis-&gt;dnCache = new DNCache(locale);
760             if (dnCache == NULL) {
761                 status = U_MEMORY_ALLOCATION_ERROR;
762                 return result;
763             }
764 
765             int32_t pos = UHASH_FIRST;
766             const UHashElement* entry = NULL;
767             while ((entry = m-&gt;nextElement(pos)) != NULL) {
</pre>
<hr />
<pre>
832     delete objToAdopt;
833     return NULL;
834 }
835 
836 ICUServiceFactory*
837 ICUService::createSimpleFactory(UObject* objToAdopt, const UnicodeString&amp; id, UBool visible, UErrorCode&amp; status)
838 {
839     if (U_SUCCESS(status)) {
840         if ((objToAdopt != NULL) &amp;&amp; (!id.isBogus())) {
841             return new SimpleFactory(objToAdopt, id, visible);
842         }
843         status = U_ILLEGAL_ARGUMENT_ERROR;
844     }
845     return NULL;
846 }
847 
848 URegistryKey
849 ICUService::registerFactory(ICUServiceFactory* factoryToAdopt, UErrorCode&amp; status)
850 {
851     if (U_SUCCESS(status) &amp;&amp; factoryToAdopt != NULL) {
<span class="line-modified">852         Mutex mutex(&amp;lock);</span>
853 
854         if (factories == NULL) {
855             factories = new UVector(deleteUObject, NULL, status);
856             if (U_FAILURE(status)) {
857                 delete factories;
858                 return NULL;
859             }
860         }
861         factories-&gt;insertElementAt(factoryToAdopt, 0, status);
862         if (U_SUCCESS(status)) {
863             clearCaches();
864         } else {
865             delete factoryToAdopt;
866             factoryToAdopt = NULL;
867         }
868     }
869 
870     if (factoryToAdopt != NULL) {
871         notifyChanged();
872     }
873 
874     return (URegistryKey)factoryToAdopt;
875 }
876 
877 UBool
878 ICUService::unregister(URegistryKey rkey, UErrorCode&amp; status)
879 {
880     ICUServiceFactory *factory = (ICUServiceFactory*)rkey;
881     UBool result = FALSE;
882     if (factory != NULL &amp;&amp; factories != NULL) {
<span class="line-modified">883         Mutex mutex(&amp;lock);</span>
884 
885         if (factories-&gt;removeElement(factory)) {
886             clearCaches();
887             result = TRUE;
888         } else {
889             status = U_ILLEGAL_ARGUMENT_ERROR;
890             delete factory;
891         }
892     }
893     if (result) {
894         notifyChanged();
895     }
896     return result;
897 }
898 
899 void
900 ICUService::reset()
901 {
902     {
<span class="line-modified">903         Mutex mutex(&amp;lock);</span>
904         reInitializeFactories();
905         clearCaches();
906     }
907     notifyChanged();
908 }
909 
910 void
911 ICUService::reInitializeFactories()
912 {
913     if (factories != NULL) {
914         factories-&gt;removeAllElements();
915     }
916 }
917 
918 UBool
919 ICUService::isDefault() const
920 {
921     return countFactories() == 0;
922 }
923 
</pre>
</td>
<td>
<hr />
<pre>
316 }
317 
318 StringPair::StringPair(const UnicodeString&amp; _displayName,
319                        const UnicodeString&amp; _id)
320 : displayName(_displayName)
321 , id(_id)
322 {
323 }
324 
325 U_CDECL_BEGIN
326 static void U_CALLCONV
327 userv_deleteStringPair(void *obj) {
328     U_NAMESPACE_USE delete (StringPair*) obj;
329 }
330 U_CDECL_END
331 
332 /*
333 ******************************************************************
334 */
335 
<span class="line-modified">336 static UMutex *lock() {</span>
<span class="line-added">337     static UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added">338     return &amp;m;</span>
<span class="line-added">339 }</span>
340 
341 ICUService::ICUService()
342 : name()
343 , timestamp(0)
344 , factories(NULL)
345 , serviceCache(NULL)
346 , idCache(NULL)
347 , dnCache(NULL)
348 {
349 }
350 
351 ICUService::ICUService(const UnicodeString&amp; newName)
352 : name(newName)
353 , timestamp(0)
354 , factories(NULL)
355 , serviceCache(NULL)
356 , idCache(NULL)
357 , dnCache(NULL)
358 {
359 }
360 
361 ICUService::~ICUService()
362 {
363     {
<span class="line-modified">364         Mutex mutex(lock());</span>
365         clearCaches();
366         delete factories;
367         factories = NULL;
368     }
369 }
370 
371 UObject*
372 ICUService::get(const UnicodeString&amp; descriptor, UErrorCode&amp; status) const
373 {
374     return get(descriptor, NULL, status);
375 }
376 
377 UObject*
378 ICUService::get(const UnicodeString&amp; descriptor, UnicodeString* actualReturn, UErrorCode&amp; status) const
379 {
380     UObject* result = NULL;
381     ICUServiceKey* key = createKey(&amp;descriptor, status);
382     if (key) {
383         result = getKey(*key, actualReturn, status);
384         delete key;
</pre>
<hr />
<pre>
435         return NULL;
436     }
437 
438     if (isDefault()) {
439         return handleDefault(key, actualReturn, status);
440     }
441 
442     ICUService* ncthis = (ICUService*)this; // cast away semantic const
443 
444     CacheEntry* result = NULL;
445     {
446         // The factory list can&#39;t be modified until we&#39;re done,
447         // otherwise we might update the cache with an invalid result.
448         // The cache has to stay in synch with the factory list.
449         // ICU doesn&#39;t have monitors so we can&#39;t use rw locks, so
450         // we single-thread everything using this service, for now.
451 
452         // if factory is not null, we&#39;re calling from within the mutex,
453         // and since some unix machines don&#39;t have reentrant mutexes we
454         // need to make sure not to try to lock it again.
<span class="line-modified">455         XMutex mutex(lock(), factory != NULL);</span>
456 
457         if (serviceCache == NULL) {
458             ncthis-&gt;serviceCache = new Hashtable(status);
459             if (ncthis-&gt;serviceCache == NULL) {
460                 return NULL;
461             }
462             if (U_FAILURE(status)) {
463                 delete serviceCache;
464                 return NULL;
465             }
466             serviceCache-&gt;setValueDeleter(cacheDeleter);
467         }
468 
469         UnicodeString currentDescriptor;
470         UVectorDeleter cacheDescriptorList;
471         UBool putInCache = FALSE;
472 
473         int32_t startIndex = 0;
474         int32_t limit = factories-&gt;size();
475         UBool cacheResult = TRUE;
</pre>
<hr />
<pre>
601 ICUService::handleDefault(const ICUServiceKey&amp; /* key */, UnicodeString* /* actualIDReturn */, UErrorCode&amp; /* status */) const
602 {
603     return NULL;
604 }
605 
606 UVector&amp;
607 ICUService::getVisibleIDs(UVector&amp; result, UErrorCode&amp; status) const {
608     return getVisibleIDs(result, NULL, status);
609 }
610 
611 UVector&amp;
612 ICUService::getVisibleIDs(UVector&amp; result, const UnicodeString* matchID, UErrorCode&amp; status) const
613 {
614     result.removeAllElements();
615 
616     if (U_FAILURE(status)) {
617         return result;
618     }
619 
620     {
<span class="line-modified">621         Mutex mutex(lock());</span>
622         const Hashtable* map = getVisibleIDMap(status);
623         if (map != NULL) {
624             ICUServiceKey* fallbackKey = createKey(matchID, status);
625 
626             for (int32_t pos = UHASH_FIRST;;) {
627                 const UHashElement* e = map-&gt;nextElement(pos);
628                 if (e == NULL) {
629                     break;
630                 }
631 
632                 const UnicodeString* id = (const UnicodeString*)e-&gt;key.pointer;
633                 if (fallbackKey != NULL) {
634                     if (!fallbackKey-&gt;isFallbackOf(*id)) {
635                         continue;
636                     }
637                 }
638 
639                 UnicodeString* idClone = new UnicodeString(*id);
640                 if (idClone == NULL || idClone-&gt;isBogus()) {
641                     delete idClone;
</pre>
<hr />
<pre>
678                 ncthis-&gt;idCache = NULL;
679             }
680         }
681     }
682 
683     return idCache;
684 }
685 
686 
687 UnicodeString&amp;
688 ICUService::getDisplayName(const UnicodeString&amp; id, UnicodeString&amp; result) const
689 {
690     return getDisplayName(id, result, Locale::getDefault());
691 }
692 
693 UnicodeString&amp;
694 ICUService::getDisplayName(const UnicodeString&amp; id, UnicodeString&amp; result, const Locale&amp; locale) const
695 {
696     {
697         UErrorCode status = U_ZERO_ERROR;
<span class="line-modified">698         Mutex mutex(lock());</span>
699         const Hashtable* map = getVisibleIDMap(status);
700         if (map != NULL) {
701             ICUServiceFactory* f = (ICUServiceFactory*)map-&gt;get(id);
702             if (f != NULL) {
703                 f-&gt;getDisplayName(id, locale, result);
704                 return result;
705             }
706 
707             // fallback
<span class="line-modified">708             status = U_ZERO_ERROR;</span>
709             ICUServiceKey* fallbackKey = createKey(&amp;id, status);
<span class="line-modified">710             while (fallbackKey != NULL &amp;&amp; fallbackKey-&gt;fallback()) {</span>
711                 UnicodeString us;
712                 fallbackKey-&gt;currentID(us);
713                 f = (ICUServiceFactory*)map-&gt;get(us);
714                 if (f != NULL) {
715                     f-&gt;getDisplayName(id, locale, result);
716                     delete fallbackKey;
717                     return result;
718                 }
719             }
720             delete fallbackKey;
721         }
722     }
723     result.setToBogus();
724     return result;
725 }
726 
727 UVector&amp;
728 ICUService::getDisplayNames(UVector&amp; result, UErrorCode&amp; status) const
729 {
730     return getDisplayNames(result, Locale::getDefault(), NULL, status);
731 }
732 
733 
734 UVector&amp;
735 ICUService::getDisplayNames(UVector&amp; result, const Locale&amp; locale, UErrorCode&amp; status) const
736 {
737     return getDisplayNames(result, locale, NULL, status);
738 }
739 
740 UVector&amp;
741 ICUService::getDisplayNames(UVector&amp; result,
742                             const Locale&amp; locale,
743                             const UnicodeString* matchID,
744                             UErrorCode&amp; status) const
745 {
746     result.removeAllElements();
747     result.setDeleter(userv_deleteStringPair);
748     if (U_SUCCESS(status)) {
749         ICUService* ncthis = (ICUService*)this; // cast away semantic const
<span class="line-modified">750         Mutex mutex(lock());</span>
751 
752         if (dnCache != NULL &amp;&amp; dnCache-&gt;locale != locale) {
753             delete dnCache;
754             ncthis-&gt;dnCache = NULL;
755         }
756 
757         if (dnCache == NULL) {
758             const Hashtable* m = getVisibleIDMap(status);
759             if (U_FAILURE(status)) {
760                 return result;
761             }
762             ncthis-&gt;dnCache = new DNCache(locale);
763             if (dnCache == NULL) {
764                 status = U_MEMORY_ALLOCATION_ERROR;
765                 return result;
766             }
767 
768             int32_t pos = UHASH_FIRST;
769             const UHashElement* entry = NULL;
770             while ((entry = m-&gt;nextElement(pos)) != NULL) {
</pre>
<hr />
<pre>
835     delete objToAdopt;
836     return NULL;
837 }
838 
839 ICUServiceFactory*
840 ICUService::createSimpleFactory(UObject* objToAdopt, const UnicodeString&amp; id, UBool visible, UErrorCode&amp; status)
841 {
842     if (U_SUCCESS(status)) {
843         if ((objToAdopt != NULL) &amp;&amp; (!id.isBogus())) {
844             return new SimpleFactory(objToAdopt, id, visible);
845         }
846         status = U_ILLEGAL_ARGUMENT_ERROR;
847     }
848     return NULL;
849 }
850 
851 URegistryKey
852 ICUService::registerFactory(ICUServiceFactory* factoryToAdopt, UErrorCode&amp; status)
853 {
854     if (U_SUCCESS(status) &amp;&amp; factoryToAdopt != NULL) {
<span class="line-modified">855         Mutex mutex(lock());</span>
856 
857         if (factories == NULL) {
858             factories = new UVector(deleteUObject, NULL, status);
859             if (U_FAILURE(status)) {
860                 delete factories;
861                 return NULL;
862             }
863         }
864         factories-&gt;insertElementAt(factoryToAdopt, 0, status);
865         if (U_SUCCESS(status)) {
866             clearCaches();
867         } else {
868             delete factoryToAdopt;
869             factoryToAdopt = NULL;
870         }
871     }
872 
873     if (factoryToAdopt != NULL) {
874         notifyChanged();
875     }
876 
877     return (URegistryKey)factoryToAdopt;
878 }
879 
880 UBool
881 ICUService::unregister(URegistryKey rkey, UErrorCode&amp; status)
882 {
883     ICUServiceFactory *factory = (ICUServiceFactory*)rkey;
884     UBool result = FALSE;
885     if (factory != NULL &amp;&amp; factories != NULL) {
<span class="line-modified">886         Mutex mutex(lock());</span>
887 
888         if (factories-&gt;removeElement(factory)) {
889             clearCaches();
890             result = TRUE;
891         } else {
892             status = U_ILLEGAL_ARGUMENT_ERROR;
893             delete factory;
894         }
895     }
896     if (result) {
897         notifyChanged();
898     }
899     return result;
900 }
901 
902 void
903 ICUService::reset()
904 {
905     {
<span class="line-modified">906         Mutex mutex(lock());</span>
907         reInitializeFactories();
908         clearCaches();
909     }
910     notifyChanged();
911 }
912 
913 void
914 ICUService::reInitializeFactories()
915 {
916     if (factories != NULL) {
917         factories-&gt;removeAllElements();
918     }
919 }
920 
921 UBool
922 ICUService::isDefault() const
923 {
924     return countFactories() == 0;
925 }
926 
</pre>
</td>
</tr>
</table>
<center><a href="resbund.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="servls.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>