<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc_keytype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="uloc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uloc_tag.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc_keytype.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 **********************************************************************
  5 *   Copyright (C) 2014-2016, International Business Machines
  6 *   Corporation and others.  All Rights Reserved.
  7 **********************************************************************
  8 */


  9 #include &quot;unicode/utypes.h&quot;


 10 


 11 #include &quot;cstring.h&quot;
 12 #include &quot;uassert.h&quot;
 13 #include &quot;ucln_cmn.h&quot;
 14 #include &quot;uhash.h&quot;
 15 #include &quot;umutex.h&quot;
 16 #include &quot;uresimp.h&quot;
 17 #include &quot;uvector.h&quot;
 18 #include &quot;udataswp.h&quot; /* for InvChar functions */
 19 
 20 static UHashtable* gLocExtKeyMap = NULL;
 21 static icu::UInitOnce gLocExtKeyMapInitOnce = U_INITONCE_INITIALIZER;
<span class="line-removed"> 22 static icu::UVector* gKeyTypeStringPool = NULL;</span>
<span class="line-removed"> 23 static icu::UVector* gLocExtKeyDataEntries = NULL;</span>
<span class="line-removed"> 24 static icu::UVector* gLocExtTypeEntries = NULL;</span>
 25 
 26 // bit flags for special types
 27 typedef enum {
 28     SPECIALTYPE_NONE = 0,
 29     SPECIALTYPE_CODEPOINTS = 1,
 30     SPECIALTYPE_REORDER_CODE = 2,
 31     SPECIALTYPE_RG_KEY_VALUE = 4
 32 } SpecialType;
 33 
<span class="line-modified"> 34 typedef struct LocExtKeyData {</span>
 35     const char*     legacyId;
 36     const char*     bcpId;
<span class="line-modified"> 37     UHashtable*     typeMap;</span>
 38     uint32_t        specialTypes;
<span class="line-modified"> 39 } LocExtKeyData;</span>
 40 
<span class="line-modified"> 41 typedef struct LocExtType {</span>
 42     const char*     legacyId;
 43     const char*     bcpId;
<span class="line-modified"> 44 } LocExtType;</span>




 45 
 46 U_CDECL_BEGIN
 47 
 48 static UBool U_CALLCONV
 49 uloc_key_type_cleanup(void) {
 50     if (gLocExtKeyMap != NULL) {
 51         uhash_close(gLocExtKeyMap);
 52         gLocExtKeyMap = NULL;
 53     }
 54 
 55     delete gLocExtKeyDataEntries;
 56     gLocExtKeyDataEntries = NULL;
 57 
 58     delete gLocExtTypeEntries;
 59     gLocExtTypeEntries = NULL;
 60 
 61     delete gKeyTypeStringPool;
 62     gKeyTypeStringPool = NULL;
 63 
 64     gLocExtKeyMapInitOnce.reset();
 65     return TRUE;
 66 }
 67 
<span class="line-removed"> 68 static void U_CALLCONV</span>
<span class="line-removed"> 69 uloc_deleteKeyTypeStringPoolEntry(void* obj) {</span>
<span class="line-removed"> 70     uprv_free(obj);</span>
<span class="line-removed"> 71 }</span>
<span class="line-removed"> 72 </span>
<span class="line-removed"> 73 static void U_CALLCONV</span>
<span class="line-removed"> 74 uloc_deleteKeyDataEntry(void* obj) {</span>
<span class="line-removed"> 75     LocExtKeyData* keyData = (LocExtKeyData*)obj;</span>
<span class="line-removed"> 76     if (keyData-&gt;typeMap != NULL) {</span>
<span class="line-removed"> 77         uhash_close(keyData-&gt;typeMap);</span>
<span class="line-removed"> 78     }</span>
<span class="line-removed"> 79     uprv_free(keyData);</span>
<span class="line-removed"> 80 }</span>
<span class="line-removed"> 81 </span>
<span class="line-removed"> 82 static void U_CALLCONV</span>
<span class="line-removed"> 83 uloc_deleteTypeEntry(void* obj) {</span>
<span class="line-removed"> 84     uprv_free(obj);</span>
<span class="line-removed"> 85 }</span>
<span class="line-removed"> 86 </span>
 87 U_CDECL_END
 88 
 89 
 90 static void U_CALLCONV
 91 initFromResourceBundle(UErrorCode&amp; sts) {
 92     U_NAMESPACE_USE
 93     ucln_common_registerCleanup(UCLN_COMMON_LOCALE_KEY_TYPE, uloc_key_type_cleanup);
 94 
 95     gLocExtKeyMap = uhash_open(uhash_hashIChars, uhash_compareIChars, NULL, &amp;sts);
 96 
 97     LocalUResourceBundlePointer keyTypeDataRes(ures_openDirect(NULL, &quot;keyTypeData&quot;, &amp;sts));
 98     LocalUResourceBundlePointer keyMapRes(ures_getByKey(keyTypeDataRes.getAlias(), &quot;keyMap&quot;, NULL, &amp;sts));
 99     LocalUResourceBundlePointer typeMapRes(ures_getByKey(keyTypeDataRes.getAlias(), &quot;typeMap&quot;, NULL, &amp;sts));
100 
101     if (U_FAILURE(sts)) {
102         return;
103     }
104 
105     UErrorCode tmpSts = U_ZERO_ERROR;
106     LocalUResourceBundlePointer typeAliasRes(ures_getByKey(keyTypeDataRes.getAlias(), &quot;typeAlias&quot;, NULL, &amp;tmpSts));
107     tmpSts = U_ZERO_ERROR;
108     LocalUResourceBundlePointer bcpTypeAliasRes(ures_getByKey(keyTypeDataRes.getAlias(), &quot;bcpTypeAlias&quot;, NULL, &amp;tmpSts));
109 
<span class="line-modified">110     // initialize vectors storing dynamically allocated objects</span>
<span class="line-modified">111     gKeyTypeStringPool = new UVector(uloc_deleteKeyTypeStringPoolEntry, NULL, sts);</span>
112     if (gKeyTypeStringPool == NULL) {
<span class="line-modified">113         if (U_SUCCESS(sts)) {</span>
<span class="line-removed">114             sts = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">115         }</span>
<span class="line-removed">116     }</span>
<span class="line-removed">117     if (U_FAILURE(sts)) {</span>
118         return;
119     }
<span class="line-modified">120     gLocExtKeyDataEntries = new UVector(uloc_deleteKeyDataEntry, NULL, sts);</span>
121     if (gLocExtKeyDataEntries == NULL) {
<span class="line-modified">122         if (U_SUCCESS(sts)) {</span>
<span class="line-removed">123             sts = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">124         }</span>
<span class="line-removed">125     }</span>
<span class="line-removed">126     if (U_FAILURE(sts)) {</span>
127         return;
128     }
<span class="line-modified">129     gLocExtTypeEntries = new UVector(uloc_deleteTypeEntry, NULL, sts);</span>
130     if (gLocExtTypeEntries == NULL) {
<span class="line-modified">131         if (U_SUCCESS(sts)) {</span>
<span class="line-removed">132             sts = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">133         }</span>
<span class="line-removed">134     }</span>
<span class="line-removed">135     if (U_FAILURE(sts)) {</span>
136         return;
137     }
138 
139     // iterate through keyMap resource
140     LocalUResourceBundlePointer keyMapEntry;
141 
142     while (ures_hasNext(keyMapRes.getAlias())) {
143         keyMapEntry.adoptInstead(ures_getNextResource(keyMapRes.getAlias(), keyMapEntry.orphan(), &amp;sts));
144         if (U_FAILURE(sts)) {
145             break;
146         }
147         const char* legacyKeyId = ures_getKey(keyMapEntry.getAlias());
<span class="line-modified">148         int32_t bcpKeyIdLen = 0;</span>
<span class="line-removed">149         const UChar* uBcpKeyId = ures_getString(keyMapEntry.getAlias(), &amp;bcpKeyIdLen, &amp;sts);</span>
150         if (U_FAILURE(sts)) {
151             break;
152         }
153 
154         // empty value indicates that BCP key is same with the legacy key.
155         const char* bcpKeyId = legacyKeyId;
<span class="line-modified">156         if (bcpKeyIdLen &gt; 0) {</span>
<span class="line-modified">157             char* bcpKeyIdBuf = (char*)uprv_malloc(bcpKeyIdLen + 1);</span>
158             if (bcpKeyIdBuf == NULL) {
159                 sts = U_MEMORY_ALLOCATION_ERROR;
160                 break;
161             }
<span class="line-modified">162             u_UCharsToChars(uBcpKeyId, bcpKeyIdBuf, bcpKeyIdLen);</span>
<span class="line-removed">163             bcpKeyIdBuf[bcpKeyIdLen] = 0;</span>
<span class="line-removed">164             gKeyTypeStringPool-&gt;addElement(bcpKeyIdBuf, sts);</span>
165             if (U_FAILURE(sts)) {
166                 break;
167             }
<span class="line-modified">168             bcpKeyId = bcpKeyIdBuf;</span>
169         }
170 
171         UBool isTZ = uprv_strcmp(legacyKeyId, &quot;timezone&quot;) == 0;
172 
173         UHashtable* typeDataMap = uhash_open(uhash_hashIChars, uhash_compareIChars, NULL, &amp;sts);
174         if (U_FAILURE(sts)) {
175             break;
176         }
177         uint32_t specialTypes = SPECIALTYPE_NONE;
178 
179         LocalUResourceBundlePointer typeAliasResByKey;
180         LocalUResourceBundlePointer bcpTypeAliasResByKey;
181 
182         if (typeAliasRes.isValid()) {
183             tmpSts = U_ZERO_ERROR;
184             typeAliasResByKey.adoptInstead(ures_getByKey(typeAliasRes.getAlias(), legacyKeyId, NULL, &amp;tmpSts));
185             if (U_FAILURE(tmpSts)) {
186                 typeAliasResByKey.orphan();
187             }
188         }
189         if (bcpTypeAliasRes.isValid()) {
190             tmpSts = U_ZERO_ERROR;
191             bcpTypeAliasResByKey.adoptInstead(ures_getByKey(bcpTypeAliasRes.getAlias(), bcpKeyId, NULL, &amp;tmpSts));
192             if (U_FAILURE(tmpSts)) {
193                 bcpTypeAliasResByKey.orphan();
194             }
195         }
196 
197         // look up type map for the key, and walk through the mapping data
198         tmpSts = U_ZERO_ERROR;
199         LocalUResourceBundlePointer typeMapResByKey(ures_getByKey(typeMapRes.getAlias(), legacyKeyId, NULL, &amp;tmpSts));
200         if (U_FAILURE(tmpSts)) {
201             // type map for each key must exist
<span class="line-modified">202             U_ASSERT(FALSE);</span>
203         } else {
204             LocalUResourceBundlePointer typeMapEntry;
205 
206             while (ures_hasNext(typeMapResByKey.getAlias())) {
207                 typeMapEntry.adoptInstead(ures_getNextResource(typeMapResByKey.getAlias(), typeMapEntry.orphan(), &amp;sts));
208                 if (U_FAILURE(sts)) {
209                     break;
210                 }
211                 const char* legacyTypeId = ures_getKey(typeMapEntry.getAlias());
212 
213                 // special types
214                 if (uprv_strcmp(legacyTypeId, &quot;CODEPOINTS&quot;) == 0) {
215                     specialTypes |= SPECIALTYPE_CODEPOINTS;
216                     continue;
217                 }
218                 if (uprv_strcmp(legacyTypeId, &quot;REORDER_CODE&quot;) == 0) {
219                     specialTypes |= SPECIALTYPE_REORDER_CODE;
220                     continue;
221                 }
222                 if (uprv_strcmp(legacyTypeId, &quot;RG_KEY_VALUE&quot;) == 0) {
223                     specialTypes |= SPECIALTYPE_RG_KEY_VALUE;
224                     continue;
225                 }
226 
227                 if (isTZ) {
228                     // a timezone key uses a colon instead of a slash in the resource.
229                     // e.g. America:Los_Angeles
230                     if (uprv_strchr(legacyTypeId, &#39;:&#39;) != NULL) {
<span class="line-modified">231                         int32_t legacyTypeIdLen = uprv_strlen(legacyTypeId);</span>
<span class="line-modified">232                         char* legacyTypeIdBuf = (char*)uprv_malloc(legacyTypeIdLen + 1);</span>
233                         if (legacyTypeIdBuf == NULL) {
234                             sts = U_MEMORY_ALLOCATION_ERROR;
235                             break;
236                         }
<span class="line-removed">237                         const char* p = legacyTypeId;</span>
<span class="line-removed">238                         char* q = legacyTypeIdBuf;</span>
<span class="line-removed">239                         while (*p) {</span>
<span class="line-removed">240                             if (*p == &#39;:&#39;) {</span>
<span class="line-removed">241                                 *q++ = &#39;/&#39;;</span>
<span class="line-removed">242                             } else {</span>
<span class="line-removed">243                                 *q++ = *p;</span>
<span class="line-removed">244                             }</span>
<span class="line-removed">245                             p++;</span>
<span class="line-removed">246                         }</span>
<span class="line-removed">247                         *q = 0;</span>
<span class="line-removed">248 </span>
<span class="line-removed">249                         gKeyTypeStringPool-&gt;addElement(legacyTypeIdBuf, sts);</span>
250                         if (U_FAILURE(sts)) {
251                             break;
252                         }
<span class="line-modified">253                         legacyTypeId = legacyTypeIdBuf;</span>




254                     }
255                 }
256 
<span class="line-modified">257                 int32_t bcpTypeIdLen = 0;</span>
<span class="line-removed">258                 const UChar* uBcpTypeId = ures_getString(typeMapEntry.getAlias(), &amp;bcpTypeIdLen, &amp;sts);</span>
259                 if (U_FAILURE(sts)) {
260                     break;
261                 }
262 
263                 // empty value indicates that BCP type is same with the legacy type.
264                 const char* bcpTypeId = legacyTypeId;
<span class="line-modified">265                 if (bcpTypeIdLen &gt; 0) {</span>
<span class="line-modified">266                     char* bcpTypeIdBuf = (char*)uprv_malloc(bcpTypeIdLen + 1);</span>
267                     if (bcpTypeIdBuf == NULL) {
268                         sts = U_MEMORY_ALLOCATION_ERROR;
269                         break;
270                     }
<span class="line-modified">271                     u_UCharsToChars(uBcpTypeId, bcpTypeIdBuf, bcpTypeIdLen);</span>
<span class="line-removed">272                     bcpTypeIdBuf[bcpTypeIdLen] = 0;</span>
<span class="line-removed">273                     gKeyTypeStringPool-&gt;addElement(bcpTypeIdBuf, sts);</span>
274                     if (U_FAILURE(sts)) {
275                         break;
276                     }
<span class="line-modified">277                     bcpTypeId = bcpTypeIdBuf;</span>
278                 }
279 
280                 // Note: legacy type value should never be
281                 // equivalent to bcp type value of a different
282                 // type under the same key. So we use a single
283                 // map for lookup.
<span class="line-modified">284                 LocExtType* t = (LocExtType*)uprv_malloc(sizeof(LocExtType));</span>
285                 if (t == NULL) {
286                     sts = U_MEMORY_ALLOCATION_ERROR;
287                     break;
288                 }
289                 t-&gt;bcpId = bcpTypeId;
290                 t-&gt;legacyId = legacyTypeId;
<span class="line-removed">291                 gLocExtTypeEntries-&gt;addElement((void*)t, sts);</span>
<span class="line-removed">292                 if (U_FAILURE(sts)) {</span>
<span class="line-removed">293                     break;</span>
<span class="line-removed">294                 }</span>
295 
296                 uhash_put(typeDataMap, (void*)legacyTypeId, t, &amp;sts);
297                 if (bcpTypeId != legacyTypeId) {
298                     // different type value
299                     uhash_put(typeDataMap, (void*)bcpTypeId, t, &amp;sts);
300                 }
301                 if (U_FAILURE(sts)) {
302                     break;
303                 }
304 
305                 // also put aliases in the map
306                 if (typeAliasResByKey.isValid()) {
307                     LocalUResourceBundlePointer typeAliasDataEntry;
308 
309                     ures_resetIterator(typeAliasResByKey.getAlias());
310                     while (ures_hasNext(typeAliasResByKey.getAlias()) &amp;&amp; U_SUCCESS(sts)) {
311                         int32_t toLen;
312                         typeAliasDataEntry.adoptInstead(ures_getNextResource(typeAliasResByKey.getAlias(), typeAliasDataEntry.orphan(), &amp;sts));
313                         const UChar* to = ures_getString(typeAliasDataEntry.getAlias(), &amp;toLen, &amp;sts);
314                         if (U_FAILURE(sts)) {
315                             break;
316                         }
317                         // check if this is an alias of canoncal legacy type
318                         if (uprv_compareInvWithUChar(NULL, legacyTypeId, -1, to, toLen) == 0) {
319                             const char* from = ures_getKey(typeAliasDataEntry.getAlias());
320                             if (isTZ) {
321                                 // replace colon with slash if necessary
322                                 if (uprv_strchr(from, &#39;:&#39;) != NULL) {
<span class="line-modified">323                                     int32_t fromLen = uprv_strlen(from);</span>
<span class="line-modified">324                                     char* fromBuf = (char*)uprv_malloc(fromLen + 1);</span>
325                                     if (fromBuf == NULL) {
326                                         sts = U_MEMORY_ALLOCATION_ERROR;
327                                         break;
328                                     }
<span class="line-removed">329                                     const char* p = from;</span>
<span class="line-removed">330                                     char* q = fromBuf;</span>
<span class="line-removed">331                                     while (*p) {</span>
<span class="line-removed">332                                         if (*p == &#39;:&#39;) {</span>
<span class="line-removed">333                                             *q++ = &#39;/&#39;;</span>
<span class="line-removed">334                                         } else {</span>
<span class="line-removed">335                                             *q++ = *p;</span>
<span class="line-removed">336                                         }</span>
<span class="line-removed">337                                         p++;</span>
<span class="line-removed">338                                     }</span>
<span class="line-removed">339                                     *q = 0;</span>
<span class="line-removed">340 </span>
<span class="line-removed">341                                     gKeyTypeStringPool-&gt;addElement(fromBuf, sts);</span>
342                                     if (U_FAILURE(sts)) {
343                                         break;
344                                     }
<span class="line-modified">345                                     from = fromBuf;</span>




346                                 }
347                             }
348                             uhash_put(typeDataMap, (void*)from, t, &amp;sts);
349                         }
350                     }
351                     if (U_FAILURE(sts)) {
352                         break;
353                     }
354                 }
355 
356                 if (bcpTypeAliasResByKey.isValid()) {
357                     LocalUResourceBundlePointer bcpTypeAliasDataEntry;
358 
359                     ures_resetIterator(bcpTypeAliasResByKey.getAlias());
360                     while (ures_hasNext(bcpTypeAliasResByKey.getAlias()) &amp;&amp; U_SUCCESS(sts)) {
361                         int32_t toLen;
362                         bcpTypeAliasDataEntry.adoptInstead(ures_getNextResource(bcpTypeAliasResByKey.getAlias(), bcpTypeAliasDataEntry.orphan(), &amp;sts));
363                         const UChar* to = ures_getString(bcpTypeAliasDataEntry.getAlias(), &amp;toLen, &amp;sts);
364                         if (U_FAILURE(sts)) {
365                             break;
366                         }
367                         // check if this is an alias of bcp type
368                         if (uprv_compareInvWithUChar(NULL, bcpTypeId, -1, to, toLen) == 0) {
369                             const char* from = ures_getKey(bcpTypeAliasDataEntry.getAlias());
370                             uhash_put(typeDataMap, (void*)from, t, &amp;sts);
371                         }
372                     }
373                     if (U_FAILURE(sts)) {
374                         break;
375                     }
376                 }
377             }
378         }
379         if (U_FAILURE(sts)) {
380             break;
381         }
382 
<span class="line-modified">383         LocExtKeyData* keyData = (LocExtKeyData*)uprv_malloc(sizeof(LocExtKeyData));</span>
384         if (keyData == NULL) {
385             sts = U_MEMORY_ALLOCATION_ERROR;
386             break;
387         }
388         keyData-&gt;bcpId = bcpKeyId;
389         keyData-&gt;legacyId = legacyKeyId;
390         keyData-&gt;specialTypes = specialTypes;
<span class="line-modified">391         keyData-&gt;typeMap = typeDataMap;</span>
<span class="line-removed">392 </span>
<span class="line-removed">393         gLocExtKeyDataEntries-&gt;addElement((void*)keyData, sts);</span>
<span class="line-removed">394         if (U_FAILURE(sts)) {</span>
<span class="line-removed">395             break;</span>
<span class="line-removed">396         }</span>
397 
398         uhash_put(gLocExtKeyMap, (void*)legacyKeyId, keyData, &amp;sts);
399         if (legacyKeyId != bcpKeyId) {
400             // different key value
401             uhash_put(gLocExtKeyMap, (void*)bcpKeyId, keyData, &amp;sts);
402         }
403         if (U_FAILURE(sts)) {
404             break;
405         }
406     }
407 }
408 
409 static UBool
410 init() {
411     UErrorCode sts = U_ZERO_ERROR;
412     umtx_initOnce(gLocExtKeyMapInitOnce, &amp;initFromResourceBundle, sts);
413     if (U_FAILURE(sts)) {
414         return FALSE;
415     }
416     return TRUE;
</pre>
<hr />
<pre>
455         }
456         p++;
457     }
458     return (subtagLen &gt;=3 &amp;&amp; subtagLen &lt;=8);
459 }
460 
461 static UBool
462 isSpecialTypeRgKeyValue(const char* val) {
463     int32_t subtagLen = 0;
464     const char* p = val;
465     while (*p) {
466         if ( (subtagLen &lt; 2 &amp;&amp; uprv_isASCIILetter(*p)) ||
467                     (subtagLen &gt;= 2 &amp;&amp; (*p == &#39;Z&#39; || *p == &#39;z&#39;)) ) {
468             subtagLen++;
469         } else {
470             return FALSE;
471         }
472         p++;
473     }
474     return (subtagLen == 6);
<span class="line-removed">475     return TRUE;</span>
476 }
477 
478 U_CFUNC const char*
479 ulocimp_toBcpKey(const char* key) {
480     if (!init()) {
481         return NULL;
482     }
483 
484     LocExtKeyData* keyData = (LocExtKeyData*)uhash_get(gLocExtKeyMap, key);
485     if (keyData != NULL) {
486         return keyData-&gt;bcpId;
487     }
488     return NULL;
489 }
490 
491 U_CFUNC const char*
492 ulocimp_toLegacyKey(const char* key) {
493     if (!init()) {
494         return NULL;
495     }
</pre>
<hr />
<pre>
502 }
503 
504 U_CFUNC const char*
505 ulocimp_toBcpType(const char* key, const char* type, UBool* isKnownKey, UBool* isSpecialType) {
506     if (isKnownKey != NULL) {
507         *isKnownKey = FALSE;
508     }
509     if (isSpecialType != NULL) {
510         *isSpecialType = FALSE;
511     }
512 
513     if (!init()) {
514         return NULL;
515     }
516 
517     LocExtKeyData* keyData = (LocExtKeyData*)uhash_get(gLocExtKeyMap, key);
518     if (keyData != NULL) {
519         if (isKnownKey != NULL) {
520             *isKnownKey = TRUE;
521         }
<span class="line-modified">522         LocExtType* t = (LocExtType*)uhash_get(keyData-&gt;typeMap, type);</span>
523         if (t != NULL) {
524             return t-&gt;bcpId;
525         }
526         if (keyData-&gt;specialTypes != SPECIALTYPE_NONE) {
527             UBool matched = FALSE;
528             if (keyData-&gt;specialTypes &amp; SPECIALTYPE_CODEPOINTS) {
529                 matched = isSpecialTypeCodepoints(type);
530             }
531             if (!matched &amp;&amp; keyData-&gt;specialTypes &amp; SPECIALTYPE_REORDER_CODE) {
532                 matched = isSpecialTypeReorderCode(type);
533             }
534             if (!matched &amp;&amp; keyData-&gt;specialTypes &amp; SPECIALTYPE_RG_KEY_VALUE) {
535                 matched = isSpecialTypeRgKeyValue(type);
536             }
537             if (matched) {
538                 if (isSpecialType != NULL) {
539                     *isSpecialType = TRUE;
540                 }
541                 return type;
542             }
</pre>
<hr />
<pre>
547 
548 
549 U_CFUNC const char*
550 ulocimp_toLegacyType(const char* key, const char* type, UBool* isKnownKey, UBool* isSpecialType) {
551     if (isKnownKey != NULL) {
552         *isKnownKey = FALSE;
553     }
554     if (isSpecialType != NULL) {
555         *isSpecialType = FALSE;
556     }
557 
558     if (!init()) {
559         return NULL;
560     }
561 
562     LocExtKeyData* keyData = (LocExtKeyData*)uhash_get(gLocExtKeyMap, key);
563     if (keyData != NULL) {
564         if (isKnownKey != NULL) {
565             *isKnownKey = TRUE;
566         }
<span class="line-modified">567         LocExtType* t = (LocExtType*)uhash_get(keyData-&gt;typeMap, type);</span>
568         if (t != NULL) {
569             return t-&gt;legacyId;
570         }
571         if (keyData-&gt;specialTypes != SPECIALTYPE_NONE) {
572             UBool matched = FALSE;
573             if (keyData-&gt;specialTypes &amp; SPECIALTYPE_CODEPOINTS) {
574                 matched = isSpecialTypeCodepoints(type);
575             }
576             if (!matched &amp;&amp; keyData-&gt;specialTypes &amp; SPECIALTYPE_REORDER_CODE) {
577                 matched = isSpecialTypeReorderCode(type);
578             }
579             if (!matched &amp;&amp; keyData-&gt;specialTypes &amp; SPECIALTYPE_RG_KEY_VALUE) {
580                 matched = isSpecialTypeRgKeyValue(type);
581             }
582             if (matched) {
583                 if (isSpecialType != NULL) {
584                     *isSpecialType = TRUE;
585                 }
586                 return type;
587             }
</pre>
</td>
<td>
<hr />
<pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 **********************************************************************
  5 *   Copyright (C) 2014-2016, International Business Machines
  6 *   Corporation and others.  All Rights Reserved.
  7 **********************************************************************
  8 */
<span class="line-added">  9 #include &lt;algorithm&gt;</span>
<span class="line-added"> 10 </span>
 11 #include &quot;unicode/utypes.h&quot;
<span class="line-added"> 12 #include &quot;unicode/unistr.h&quot;</span>
<span class="line-added"> 13 #include &quot;unicode/uobject.h&quot;</span>
 14 
<span class="line-added"> 15 #include &quot;charstr.h&quot;</span>
<span class="line-added"> 16 #include &quot;cmemory.h&quot;</span>
 17 #include &quot;cstring.h&quot;
 18 #include &quot;uassert.h&quot;
 19 #include &quot;ucln_cmn.h&quot;
 20 #include &quot;uhash.h&quot;
 21 #include &quot;umutex.h&quot;
 22 #include &quot;uresimp.h&quot;
 23 #include &quot;uvector.h&quot;
 24 #include &quot;udataswp.h&quot; /* for InvChar functions */
 25 
 26 static UHashtable* gLocExtKeyMap = NULL;
 27 static icu::UInitOnce gLocExtKeyMapInitOnce = U_INITONCE_INITIALIZER;



 28 
 29 // bit flags for special types
 30 typedef enum {
 31     SPECIALTYPE_NONE = 0,
 32     SPECIALTYPE_CODEPOINTS = 1,
 33     SPECIALTYPE_REORDER_CODE = 2,
 34     SPECIALTYPE_RG_KEY_VALUE = 4
 35 } SpecialType;
 36 
<span class="line-modified"> 37 struct LocExtKeyData : public icu::UMemory {</span>
 38     const char*     legacyId;
 39     const char*     bcpId;
<span class="line-modified"> 40     icu::LocalUHashtablePointer typeMap;</span>
 41     uint32_t        specialTypes;
<span class="line-modified"> 42 };</span>
 43 
<span class="line-modified"> 44 struct LocExtType : public icu::UMemory {</span>
 45     const char*     legacyId;
 46     const char*     bcpId;
<span class="line-modified"> 47 };</span>
<span class="line-added"> 48 </span>
<span class="line-added"> 49 static icu::MemoryPool&lt;icu::CharString&gt;* gKeyTypeStringPool = NULL;</span>
<span class="line-added"> 50 static icu::MemoryPool&lt;LocExtKeyData&gt;* gLocExtKeyDataEntries = NULL;</span>
<span class="line-added"> 51 static icu::MemoryPool&lt;LocExtType&gt;* gLocExtTypeEntries = NULL;</span>
 52 
 53 U_CDECL_BEGIN
 54 
 55 static UBool U_CALLCONV
 56 uloc_key_type_cleanup(void) {
 57     if (gLocExtKeyMap != NULL) {
 58         uhash_close(gLocExtKeyMap);
 59         gLocExtKeyMap = NULL;
 60     }
 61 
 62     delete gLocExtKeyDataEntries;
 63     gLocExtKeyDataEntries = NULL;
 64 
 65     delete gLocExtTypeEntries;
 66     gLocExtTypeEntries = NULL;
 67 
 68     delete gKeyTypeStringPool;
 69     gKeyTypeStringPool = NULL;
 70 
 71     gLocExtKeyMapInitOnce.reset();
 72     return TRUE;
 73 }
 74 



















 75 U_CDECL_END
 76 
 77 
 78 static void U_CALLCONV
 79 initFromResourceBundle(UErrorCode&amp; sts) {
 80     U_NAMESPACE_USE
 81     ucln_common_registerCleanup(UCLN_COMMON_LOCALE_KEY_TYPE, uloc_key_type_cleanup);
 82 
 83     gLocExtKeyMap = uhash_open(uhash_hashIChars, uhash_compareIChars, NULL, &amp;sts);
 84 
 85     LocalUResourceBundlePointer keyTypeDataRes(ures_openDirect(NULL, &quot;keyTypeData&quot;, &amp;sts));
 86     LocalUResourceBundlePointer keyMapRes(ures_getByKey(keyTypeDataRes.getAlias(), &quot;keyMap&quot;, NULL, &amp;sts));
 87     LocalUResourceBundlePointer typeMapRes(ures_getByKey(keyTypeDataRes.getAlias(), &quot;typeMap&quot;, NULL, &amp;sts));
 88 
 89     if (U_FAILURE(sts)) {
 90         return;
 91     }
 92 
 93     UErrorCode tmpSts = U_ZERO_ERROR;
 94     LocalUResourceBundlePointer typeAliasRes(ures_getByKey(keyTypeDataRes.getAlias(), &quot;typeAlias&quot;, NULL, &amp;tmpSts));
 95     tmpSts = U_ZERO_ERROR;
 96     LocalUResourceBundlePointer bcpTypeAliasRes(ures_getByKey(keyTypeDataRes.getAlias(), &quot;bcpTypeAlias&quot;, NULL, &amp;tmpSts));
 97 
<span class="line-modified"> 98     // initialize pools storing dynamically allocated objects</span>
<span class="line-modified"> 99     gKeyTypeStringPool = new icu::MemoryPool&lt;icu::CharString&gt;;</span>
100     if (gKeyTypeStringPool == NULL) {
<span class="line-modified">101         sts = U_MEMORY_ALLOCATION_ERROR;</span>




102         return;
103     }
<span class="line-modified">104     gLocExtKeyDataEntries = new icu::MemoryPool&lt;LocExtKeyData&gt;;</span>
105     if (gLocExtKeyDataEntries == NULL) {
<span class="line-modified">106         sts = U_MEMORY_ALLOCATION_ERROR;</span>




107         return;
108     }
<span class="line-modified">109     gLocExtTypeEntries = new icu::MemoryPool&lt;LocExtType&gt;;</span>
110     if (gLocExtTypeEntries == NULL) {
<span class="line-modified">111         sts = U_MEMORY_ALLOCATION_ERROR;</span>




112         return;
113     }
114 
115     // iterate through keyMap resource
116     LocalUResourceBundlePointer keyMapEntry;
117 
118     while (ures_hasNext(keyMapRes.getAlias())) {
119         keyMapEntry.adoptInstead(ures_getNextResource(keyMapRes.getAlias(), keyMapEntry.orphan(), &amp;sts));
120         if (U_FAILURE(sts)) {
121             break;
122         }
123         const char* legacyKeyId = ures_getKey(keyMapEntry.getAlias());
<span class="line-modified">124         UnicodeString uBcpKeyId = ures_getUnicodeString(keyMapEntry.getAlias(), &amp;sts);</span>

125         if (U_FAILURE(sts)) {
126             break;
127         }
128 
129         // empty value indicates that BCP key is same with the legacy key.
130         const char* bcpKeyId = legacyKeyId;
<span class="line-modified">131         if (!uBcpKeyId.isEmpty()) {</span>
<span class="line-modified">132             icu::CharString* bcpKeyIdBuf = gKeyTypeStringPool-&gt;create();</span>
133             if (bcpKeyIdBuf == NULL) {
134                 sts = U_MEMORY_ALLOCATION_ERROR;
135                 break;
136             }
<span class="line-modified">137             bcpKeyIdBuf-&gt;appendInvariantChars(uBcpKeyId, sts);</span>


138             if (U_FAILURE(sts)) {
139                 break;
140             }
<span class="line-modified">141             bcpKeyId = bcpKeyIdBuf-&gt;data();</span>
142         }
143 
144         UBool isTZ = uprv_strcmp(legacyKeyId, &quot;timezone&quot;) == 0;
145 
146         UHashtable* typeDataMap = uhash_open(uhash_hashIChars, uhash_compareIChars, NULL, &amp;sts);
147         if (U_FAILURE(sts)) {
148             break;
149         }
150         uint32_t specialTypes = SPECIALTYPE_NONE;
151 
152         LocalUResourceBundlePointer typeAliasResByKey;
153         LocalUResourceBundlePointer bcpTypeAliasResByKey;
154 
155         if (typeAliasRes.isValid()) {
156             tmpSts = U_ZERO_ERROR;
157             typeAliasResByKey.adoptInstead(ures_getByKey(typeAliasRes.getAlias(), legacyKeyId, NULL, &amp;tmpSts));
158             if (U_FAILURE(tmpSts)) {
159                 typeAliasResByKey.orphan();
160             }
161         }
162         if (bcpTypeAliasRes.isValid()) {
163             tmpSts = U_ZERO_ERROR;
164             bcpTypeAliasResByKey.adoptInstead(ures_getByKey(bcpTypeAliasRes.getAlias(), bcpKeyId, NULL, &amp;tmpSts));
165             if (U_FAILURE(tmpSts)) {
166                 bcpTypeAliasResByKey.orphan();
167             }
168         }
169 
170         // look up type map for the key, and walk through the mapping data
171         tmpSts = U_ZERO_ERROR;
172         LocalUResourceBundlePointer typeMapResByKey(ures_getByKey(typeMapRes.getAlias(), legacyKeyId, NULL, &amp;tmpSts));
173         if (U_FAILURE(tmpSts)) {
174             // type map for each key must exist
<span class="line-modified">175             UPRV_UNREACHABLE;</span>
176         } else {
177             LocalUResourceBundlePointer typeMapEntry;
178 
179             while (ures_hasNext(typeMapResByKey.getAlias())) {
180                 typeMapEntry.adoptInstead(ures_getNextResource(typeMapResByKey.getAlias(), typeMapEntry.orphan(), &amp;sts));
181                 if (U_FAILURE(sts)) {
182                     break;
183                 }
184                 const char* legacyTypeId = ures_getKey(typeMapEntry.getAlias());
185 
186                 // special types
187                 if (uprv_strcmp(legacyTypeId, &quot;CODEPOINTS&quot;) == 0) {
188                     specialTypes |= SPECIALTYPE_CODEPOINTS;
189                     continue;
190                 }
191                 if (uprv_strcmp(legacyTypeId, &quot;REORDER_CODE&quot;) == 0) {
192                     specialTypes |= SPECIALTYPE_REORDER_CODE;
193                     continue;
194                 }
195                 if (uprv_strcmp(legacyTypeId, &quot;RG_KEY_VALUE&quot;) == 0) {
196                     specialTypes |= SPECIALTYPE_RG_KEY_VALUE;
197                     continue;
198                 }
199 
200                 if (isTZ) {
201                     // a timezone key uses a colon instead of a slash in the resource.
202                     // e.g. America:Los_Angeles
203                     if (uprv_strchr(legacyTypeId, &#39;:&#39;) != NULL) {
<span class="line-modified">204                         icu::CharString* legacyTypeIdBuf =</span>
<span class="line-modified">205                                 gKeyTypeStringPool-&gt;create(legacyTypeId, sts);</span>
206                         if (legacyTypeIdBuf == NULL) {
207                             sts = U_MEMORY_ALLOCATION_ERROR;
208                             break;
209                         }













210                         if (U_FAILURE(sts)) {
211                             break;
212                         }
<span class="line-modified">213                         std::replace(</span>
<span class="line-added">214                                 legacyTypeIdBuf-&gt;data(),</span>
<span class="line-added">215                                 legacyTypeIdBuf-&gt;data() + legacyTypeIdBuf-&gt;length(),</span>
<span class="line-added">216                                 &#39;:&#39;, &#39;/&#39;);</span>
<span class="line-added">217                         legacyTypeId = legacyTypeIdBuf-&gt;data();</span>
218                     }
219                 }
220 
<span class="line-modified">221                 UnicodeString uBcpTypeId = ures_getUnicodeString(typeMapEntry.getAlias(), &amp;sts);</span>

222                 if (U_FAILURE(sts)) {
223                     break;
224                 }
225 
226                 // empty value indicates that BCP type is same with the legacy type.
227                 const char* bcpTypeId = legacyTypeId;
<span class="line-modified">228                 if (!uBcpTypeId.isEmpty()) {</span>
<span class="line-modified">229                     icu::CharString* bcpTypeIdBuf = gKeyTypeStringPool-&gt;create();</span>
230                     if (bcpTypeIdBuf == NULL) {
231                         sts = U_MEMORY_ALLOCATION_ERROR;
232                         break;
233                     }
<span class="line-modified">234                     bcpTypeIdBuf-&gt;appendInvariantChars(uBcpTypeId, sts);</span>


235                     if (U_FAILURE(sts)) {
236                         break;
237                     }
<span class="line-modified">238                     bcpTypeId = bcpTypeIdBuf-&gt;data();</span>
239                 }
240 
241                 // Note: legacy type value should never be
242                 // equivalent to bcp type value of a different
243                 // type under the same key. So we use a single
244                 // map for lookup.
<span class="line-modified">245                 LocExtType* t = gLocExtTypeEntries-&gt;create();</span>
246                 if (t == NULL) {
247                     sts = U_MEMORY_ALLOCATION_ERROR;
248                     break;
249                 }
250                 t-&gt;bcpId = bcpTypeId;
251                 t-&gt;legacyId = legacyTypeId;




252 
253                 uhash_put(typeDataMap, (void*)legacyTypeId, t, &amp;sts);
254                 if (bcpTypeId != legacyTypeId) {
255                     // different type value
256                     uhash_put(typeDataMap, (void*)bcpTypeId, t, &amp;sts);
257                 }
258                 if (U_FAILURE(sts)) {
259                     break;
260                 }
261 
262                 // also put aliases in the map
263                 if (typeAliasResByKey.isValid()) {
264                     LocalUResourceBundlePointer typeAliasDataEntry;
265 
266                     ures_resetIterator(typeAliasResByKey.getAlias());
267                     while (ures_hasNext(typeAliasResByKey.getAlias()) &amp;&amp; U_SUCCESS(sts)) {
268                         int32_t toLen;
269                         typeAliasDataEntry.adoptInstead(ures_getNextResource(typeAliasResByKey.getAlias(), typeAliasDataEntry.orphan(), &amp;sts));
270                         const UChar* to = ures_getString(typeAliasDataEntry.getAlias(), &amp;toLen, &amp;sts);
271                         if (U_FAILURE(sts)) {
272                             break;
273                         }
274                         // check if this is an alias of canoncal legacy type
275                         if (uprv_compareInvWithUChar(NULL, legacyTypeId, -1, to, toLen) == 0) {
276                             const char* from = ures_getKey(typeAliasDataEntry.getAlias());
277                             if (isTZ) {
278                                 // replace colon with slash if necessary
279                                 if (uprv_strchr(from, &#39;:&#39;) != NULL) {
<span class="line-modified">280                                     icu::CharString* fromBuf =</span>
<span class="line-modified">281                                             gKeyTypeStringPool-&gt;create(from, sts);</span>
282                                     if (fromBuf == NULL) {
283                                         sts = U_MEMORY_ALLOCATION_ERROR;
284                                         break;
285                                     }













286                                     if (U_FAILURE(sts)) {
287                                         break;
288                                     }
<span class="line-modified">289                                     std::replace(</span>
<span class="line-added">290                                             fromBuf-&gt;data(),</span>
<span class="line-added">291                                             fromBuf-&gt;data() + fromBuf-&gt;length(),</span>
<span class="line-added">292                                             &#39;:&#39;, &#39;/&#39;);</span>
<span class="line-added">293                                     from = fromBuf-&gt;data();</span>
294                                 }
295                             }
296                             uhash_put(typeDataMap, (void*)from, t, &amp;sts);
297                         }
298                     }
299                     if (U_FAILURE(sts)) {
300                         break;
301                     }
302                 }
303 
304                 if (bcpTypeAliasResByKey.isValid()) {
305                     LocalUResourceBundlePointer bcpTypeAliasDataEntry;
306 
307                     ures_resetIterator(bcpTypeAliasResByKey.getAlias());
308                     while (ures_hasNext(bcpTypeAliasResByKey.getAlias()) &amp;&amp; U_SUCCESS(sts)) {
309                         int32_t toLen;
310                         bcpTypeAliasDataEntry.adoptInstead(ures_getNextResource(bcpTypeAliasResByKey.getAlias(), bcpTypeAliasDataEntry.orphan(), &amp;sts));
311                         const UChar* to = ures_getString(bcpTypeAliasDataEntry.getAlias(), &amp;toLen, &amp;sts);
312                         if (U_FAILURE(sts)) {
313                             break;
314                         }
315                         // check if this is an alias of bcp type
316                         if (uprv_compareInvWithUChar(NULL, bcpTypeId, -1, to, toLen) == 0) {
317                             const char* from = ures_getKey(bcpTypeAliasDataEntry.getAlias());
318                             uhash_put(typeDataMap, (void*)from, t, &amp;sts);
319                         }
320                     }
321                     if (U_FAILURE(sts)) {
322                         break;
323                     }
324                 }
325             }
326         }
327         if (U_FAILURE(sts)) {
328             break;
329         }
330 
<span class="line-modified">331         LocExtKeyData* keyData = gLocExtKeyDataEntries-&gt;create();</span>
332         if (keyData == NULL) {
333             sts = U_MEMORY_ALLOCATION_ERROR;
334             break;
335         }
336         keyData-&gt;bcpId = bcpKeyId;
337         keyData-&gt;legacyId = legacyKeyId;
338         keyData-&gt;specialTypes = specialTypes;
<span class="line-modified">339         keyData-&gt;typeMap.adoptInstead(typeDataMap);</span>





340 
341         uhash_put(gLocExtKeyMap, (void*)legacyKeyId, keyData, &amp;sts);
342         if (legacyKeyId != bcpKeyId) {
343             // different key value
344             uhash_put(gLocExtKeyMap, (void*)bcpKeyId, keyData, &amp;sts);
345         }
346         if (U_FAILURE(sts)) {
347             break;
348         }
349     }
350 }
351 
352 static UBool
353 init() {
354     UErrorCode sts = U_ZERO_ERROR;
355     umtx_initOnce(gLocExtKeyMapInitOnce, &amp;initFromResourceBundle, sts);
356     if (U_FAILURE(sts)) {
357         return FALSE;
358     }
359     return TRUE;
</pre>
<hr />
<pre>
398         }
399         p++;
400     }
401     return (subtagLen &gt;=3 &amp;&amp; subtagLen &lt;=8);
402 }
403 
404 static UBool
405 isSpecialTypeRgKeyValue(const char* val) {
406     int32_t subtagLen = 0;
407     const char* p = val;
408     while (*p) {
409         if ( (subtagLen &lt; 2 &amp;&amp; uprv_isASCIILetter(*p)) ||
410                     (subtagLen &gt;= 2 &amp;&amp; (*p == &#39;Z&#39; || *p == &#39;z&#39;)) ) {
411             subtagLen++;
412         } else {
413             return FALSE;
414         }
415         p++;
416     }
417     return (subtagLen == 6);

418 }
419 
420 U_CFUNC const char*
421 ulocimp_toBcpKey(const char* key) {
422     if (!init()) {
423         return NULL;
424     }
425 
426     LocExtKeyData* keyData = (LocExtKeyData*)uhash_get(gLocExtKeyMap, key);
427     if (keyData != NULL) {
428         return keyData-&gt;bcpId;
429     }
430     return NULL;
431 }
432 
433 U_CFUNC const char*
434 ulocimp_toLegacyKey(const char* key) {
435     if (!init()) {
436         return NULL;
437     }
</pre>
<hr />
<pre>
444 }
445 
446 U_CFUNC const char*
447 ulocimp_toBcpType(const char* key, const char* type, UBool* isKnownKey, UBool* isSpecialType) {
448     if (isKnownKey != NULL) {
449         *isKnownKey = FALSE;
450     }
451     if (isSpecialType != NULL) {
452         *isSpecialType = FALSE;
453     }
454 
455     if (!init()) {
456         return NULL;
457     }
458 
459     LocExtKeyData* keyData = (LocExtKeyData*)uhash_get(gLocExtKeyMap, key);
460     if (keyData != NULL) {
461         if (isKnownKey != NULL) {
462             *isKnownKey = TRUE;
463         }
<span class="line-modified">464         LocExtType* t = (LocExtType*)uhash_get(keyData-&gt;typeMap.getAlias(), type);</span>
465         if (t != NULL) {
466             return t-&gt;bcpId;
467         }
468         if (keyData-&gt;specialTypes != SPECIALTYPE_NONE) {
469             UBool matched = FALSE;
470             if (keyData-&gt;specialTypes &amp; SPECIALTYPE_CODEPOINTS) {
471                 matched = isSpecialTypeCodepoints(type);
472             }
473             if (!matched &amp;&amp; keyData-&gt;specialTypes &amp; SPECIALTYPE_REORDER_CODE) {
474                 matched = isSpecialTypeReorderCode(type);
475             }
476             if (!matched &amp;&amp; keyData-&gt;specialTypes &amp; SPECIALTYPE_RG_KEY_VALUE) {
477                 matched = isSpecialTypeRgKeyValue(type);
478             }
479             if (matched) {
480                 if (isSpecialType != NULL) {
481                     *isSpecialType = TRUE;
482                 }
483                 return type;
484             }
</pre>
<hr />
<pre>
489 
490 
491 U_CFUNC const char*
492 ulocimp_toLegacyType(const char* key, const char* type, UBool* isKnownKey, UBool* isSpecialType) {
493     if (isKnownKey != NULL) {
494         *isKnownKey = FALSE;
495     }
496     if (isSpecialType != NULL) {
497         *isSpecialType = FALSE;
498     }
499 
500     if (!init()) {
501         return NULL;
502     }
503 
504     LocExtKeyData* keyData = (LocExtKeyData*)uhash_get(gLocExtKeyMap, key);
505     if (keyData != NULL) {
506         if (isKnownKey != NULL) {
507             *isKnownKey = TRUE;
508         }
<span class="line-modified">509         LocExtType* t = (LocExtType*)uhash_get(keyData-&gt;typeMap.getAlias(), type);</span>
510         if (t != NULL) {
511             return t-&gt;legacyId;
512         }
513         if (keyData-&gt;specialTypes != SPECIALTYPE_NONE) {
514             UBool matched = FALSE;
515             if (keyData-&gt;specialTypes &amp; SPECIALTYPE_CODEPOINTS) {
516                 matched = isSpecialTypeCodepoints(type);
517             }
518             if (!matched &amp;&amp; keyData-&gt;specialTypes &amp; SPECIALTYPE_REORDER_CODE) {
519                 matched = isSpecialTypeReorderCode(type);
520             }
521             if (!matched &amp;&amp; keyData-&gt;specialTypes &amp; SPECIALTYPE_RG_KEY_VALUE) {
522                 matched = isSpecialTypeRgKeyValue(type);
523             }
524             if (matched) {
525                 if (isSpecialType != NULL) {
526                     *isSpecialType = TRUE;
527                 }
528                 return type;
529             }
</pre>
</td>
</tr>
</table>
<center><a href="uloc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uloc_tag.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>