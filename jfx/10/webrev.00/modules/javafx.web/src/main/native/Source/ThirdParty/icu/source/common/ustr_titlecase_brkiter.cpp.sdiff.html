<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/ustr_titlecase_brkiter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ustr_cnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ustrcase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/ustr_titlecase_brkiter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 60     int32_t current() const U_OVERRIDE;
 61     int32_t following(int32_t offset) U_OVERRIDE;
 62     int32_t preceding(int32_t offset) U_OVERRIDE;
 63     UBool isBoundary(int32_t offset) U_OVERRIDE;
 64     int32_t next(int32_t n) U_OVERRIDE;
 65     BreakIterator *createBufferClone(void *stackBuffer, int32_t &amp;BufferSize,
 66                                      UErrorCode &amp;errorCode) U_OVERRIDE;
 67     BreakIterator &amp;refreshInputText(UText *input, UErrorCode &amp;errorCode) U_OVERRIDE;
 68 
 69 private:
 70     int32_t length;
 71 };
 72 
 73 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(WholeStringBreakIterator)
 74 
 75 WholeStringBreakIterator::~WholeStringBreakIterator() {}
 76 UBool WholeStringBreakIterator::operator==(const BreakIterator&amp;) const { return FALSE; }
 77 BreakIterator *WholeStringBreakIterator::clone() const { return nullptr; }
 78 
 79 CharacterIterator &amp;WholeStringBreakIterator::getText() const {
<span class="line-modified"> 80     U_ASSERT(FALSE);  // really should not be called</span>
<span class="line-removed"> 81     // Returns a null reference.</span>
<span class="line-removed"> 82     // Otherwise we would have to define a dummy CharacterIterator,</span>
<span class="line-removed"> 83     // and either have it as a field and const_cast it to a non-const reference,</span>
<span class="line-removed"> 84     // or have it via a pointer and return a reference to that.</span>
<span class="line-removed"> 85     CharacterIterator *none = nullptr;</span>
<span class="line-removed"> 86     return *none;</span>
 87 }
 88 UText *WholeStringBreakIterator::getUText(UText * /*fillIn*/, UErrorCode &amp;errorCode) const {
 89     if (U_SUCCESS(errorCode)) {
 90         errorCode = U_UNSUPPORTED_ERROR;
 91     }
 92     return nullptr;
 93 }
 94 
 95 void  WholeStringBreakIterator::setText(const UnicodeString &amp;text) {
 96     length = text.length();
 97 }
 98 void  WholeStringBreakIterator::setText(UText *text, UErrorCode &amp;errorCode) {
 99     if (U_SUCCESS(errorCode)) {
100         int64_t length64 = utext_nativeLength(text);
101         if (length64 &lt;= INT32_MAX) {
102             length = (int32_t)length64;
103         } else {
104             errorCode = U_INDEX_OUTOFBOUNDS_ERROR;
105         }
106     }
107 }
<span class="line-modified">108 void  WholeStringBreakIterator::adoptText(CharacterIterator* it) {</span>
<span class="line-modified">109     U_ASSERT(FALSE);  // should not be called</span>
<span class="line-removed">110     length = it-&gt;getLength();</span>
<span class="line-removed">111     delete it;</span>
112 }
113 
114 int32_t WholeStringBreakIterator::first() { return 0; }
115 int32_t WholeStringBreakIterator::last() { return length; }
116 int32_t WholeStringBreakIterator::previous() { return 0; }
117 int32_t WholeStringBreakIterator::next() { return length; }
118 int32_t WholeStringBreakIterator::current() const { return 0; }
119 int32_t WholeStringBreakIterator::following(int32_t /*offset*/) { return length; }
120 int32_t WholeStringBreakIterator::preceding(int32_t /*offset*/) { return 0; }
121 UBool WholeStringBreakIterator::isBoundary(int32_t /*offset*/) { return FALSE; }
122 int32_t WholeStringBreakIterator::next(int32_t /*n*/) { return length; }
123 
124 BreakIterator *WholeStringBreakIterator::createBufferClone(
125         void * /*stackBuffer*/, int32_t &amp; /*BufferSize*/, UErrorCode &amp;errorCode) {
126     if (U_SUCCESS(errorCode)) {
127         errorCode = U_UNSUPPORTED_ERROR;
128     }
129     return nullptr;
130 }
131 BreakIterator &amp;WholeStringBreakIterator::refreshInputText(
</pre>
</td>
<td>
<hr />
<pre>
 60     int32_t current() const U_OVERRIDE;
 61     int32_t following(int32_t offset) U_OVERRIDE;
 62     int32_t preceding(int32_t offset) U_OVERRIDE;
 63     UBool isBoundary(int32_t offset) U_OVERRIDE;
 64     int32_t next(int32_t n) U_OVERRIDE;
 65     BreakIterator *createBufferClone(void *stackBuffer, int32_t &amp;BufferSize,
 66                                      UErrorCode &amp;errorCode) U_OVERRIDE;
 67     BreakIterator &amp;refreshInputText(UText *input, UErrorCode &amp;errorCode) U_OVERRIDE;
 68 
 69 private:
 70     int32_t length;
 71 };
 72 
 73 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(WholeStringBreakIterator)
 74 
 75 WholeStringBreakIterator::~WholeStringBreakIterator() {}
 76 UBool WholeStringBreakIterator::operator==(const BreakIterator&amp;) const { return FALSE; }
 77 BreakIterator *WholeStringBreakIterator::clone() const { return nullptr; }
 78 
 79 CharacterIterator &amp;WholeStringBreakIterator::getText() const {
<span class="line-modified"> 80     UPRV_UNREACHABLE;  // really should not be called</span>






 81 }
 82 UText *WholeStringBreakIterator::getUText(UText * /*fillIn*/, UErrorCode &amp;errorCode) const {
 83     if (U_SUCCESS(errorCode)) {
 84         errorCode = U_UNSUPPORTED_ERROR;
 85     }
 86     return nullptr;
 87 }
 88 
 89 void  WholeStringBreakIterator::setText(const UnicodeString &amp;text) {
 90     length = text.length();
 91 }
 92 void  WholeStringBreakIterator::setText(UText *text, UErrorCode &amp;errorCode) {
 93     if (U_SUCCESS(errorCode)) {
 94         int64_t length64 = utext_nativeLength(text);
 95         if (length64 &lt;= INT32_MAX) {
 96             length = (int32_t)length64;
 97         } else {
 98             errorCode = U_INDEX_OUTOFBOUNDS_ERROR;
 99         }
100     }
101 }
<span class="line-modified">102 void  WholeStringBreakIterator::adoptText(CharacterIterator*) {</span>
<span class="line-modified">103     UPRV_UNREACHABLE;  // should not be called</span>


104 }
105 
106 int32_t WholeStringBreakIterator::first() { return 0; }
107 int32_t WholeStringBreakIterator::last() { return length; }
108 int32_t WholeStringBreakIterator::previous() { return 0; }
109 int32_t WholeStringBreakIterator::next() { return length; }
110 int32_t WholeStringBreakIterator::current() const { return 0; }
111 int32_t WholeStringBreakIterator::following(int32_t /*offset*/) { return length; }
112 int32_t WholeStringBreakIterator::preceding(int32_t /*offset*/) { return 0; }
113 UBool WholeStringBreakIterator::isBoundary(int32_t /*offset*/) { return FALSE; }
114 int32_t WholeStringBreakIterator::next(int32_t /*n*/) { return length; }
115 
116 BreakIterator *WholeStringBreakIterator::createBufferClone(
117         void * /*stackBuffer*/, int32_t &amp; /*BufferSize*/, UErrorCode &amp;errorCode) {
118     if (U_SUCCESS(errorCode)) {
119         errorCode = U_UNSUPPORTED_ERROR;
120     }
121     return nullptr;
122 }
123 BreakIterator &amp;WholeStringBreakIterator::refreshInputText(
</pre>
</td>
</tr>
</table>
<center><a href="ustr_cnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ustrcase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>