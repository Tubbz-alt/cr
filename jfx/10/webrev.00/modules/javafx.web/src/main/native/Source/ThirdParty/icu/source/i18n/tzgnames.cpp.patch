diff a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tzgnames.cpp b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tzgnames.cpp
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tzgnames.cpp
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tzgnames.cpp
@@ -267,11 +267,14 @@
     fResults = NULL;
     fMaxMatchLen = 0;
     return results;
 }
 
-static UMutex gLock = U_MUTEX_INITIALIZER;
+static UMutex *gLock() {
+    static UMutex m = U_MUTEX_INITIALIZER;
+    return &m;
+}
 
 class TZGNCore : public UMemory {
 public:
     TZGNCore(const Locale& locale, UErrorCode& status);
     virtual ~TZGNCore();
@@ -405,11 +408,11 @@
     uhash_setKeyDeleter(fPartialLocationNamesMap, uprv_free);
     // no value deleter
 
     // target region
     const char* region = fLocale.getCountry();
-    int32_t regionLen = uprv_strlen(region);
+    int32_t regionLen = static_cast<int32_t>(uprv_strlen(region));
     if (regionLen == 0) {
         char loc[ULOC_FULLNAME_CAPACITY];
         uloc_addLikelySubtags(fLocale.getName(), loc, sizeof(loc), &status);
 
         regionLen = uloc_getCountry(loc, fTargetRegion, sizeof(fTargetRegion), &status);
@@ -483,15 +486,15 @@
         return name;
     }
 
     const UChar *locname = NULL;
     TZGNCore *nonConstThis = const_cast<TZGNCore *>(this);
-    umtx_lock(&gLock);
+    umtx_lock(gLock());
     {
         locname = nonConstThis->getGenericLocationName(tzCanonicalID);
     }
-    umtx_unlock(&gLock);
+    umtx_unlock(gLock());
 
     if (locname == NULL) {
         name.setToBogus();
     } else {
         name.setTo(locname, u_strlen(locname));
@@ -738,15 +741,15 @@
         return name;
     }
 
     const UChar *uplname = NULL;
     TZGNCore *nonConstThis = const_cast<TZGNCore *>(this);
-    umtx_lock(&gLock);
+    umtx_lock(gLock());
     {
         uplname = nonConstThis->getPartialLocationName(tzCanonicalID, mzID, isLong, mzDisplayName);
     }
-    umtx_unlock(&gLock);
+    umtx_unlock(gLock());
 
     if (uplname == NULL) {
         name.setToBogus();
     } else {
         name.setTo(TRUE, uplname, -1);
@@ -1005,15 +1008,15 @@
 TZGNCore::findLocal(const UnicodeString& text, int32_t start, uint32_t types, UErrorCode& status) const {
     GNameSearchHandler handler(types);
 
     TZGNCore *nonConstThis = const_cast<TZGNCore *>(this);
 
-    umtx_lock(&gLock);
+    umtx_lock(gLock());
     {
         fGNamesTrie.search(text, start, (TextTrieMapSearchResultHandler *)&handler, status);
     }
-    umtx_unlock(&gLock);
+    umtx_unlock(gLock());
 
     if (U_FAILURE(status)) {
         return NULL;
     }
 
@@ -1036,11 +1039,11 @@
         delete results;
     }
 
     // All names are not yet loaded into the local trie.
     // Load all available names into the trie. This could be very heavy.
-    umtx_lock(&gLock);
+    umtx_lock(gLock());
     {
         if (!fGNamesTrieFullyLoaded) {
             StringEnumeration *tzIDs = TimeZone::createTimeZoneIDEnumeration(UCAL_ZONE_TYPE_CANONICAL, NULL, NULL, status);
             if (U_SUCCESS(status)) {
                 const UnicodeString *tzID;
@@ -1058,22 +1061,22 @@
             if (U_SUCCESS(status)) {
                 nonConstThis->fGNamesTrieFullyLoaded = TRUE;
             }
         }
     }
-    umtx_unlock(&gLock);
+    umtx_unlock(gLock());
 
     if (U_FAILURE(status)) {
         return NULL;
     }
 
-    umtx_lock(&gLock);
+    umtx_lock(gLock());
     {
         // now try it again
         fGNamesTrie.search(text, start, (TextTrieMapSearchResultHandler *)&handler, status);
     }
-    umtx_unlock(&gLock);
+    umtx_unlock(gLock());
 
     results = handler.getMatches(maxLen);
     if (results != NULL && maxLen > 0) {
         gmatchInfo = new TimeZoneGenericNameMatchInfo(results);
         if (gmatchInfo == NULL) {
@@ -1110,11 +1113,14 @@
     int32_t         refCount;
     double          lastAccess;
 } TZGNCoreRef;
 
 // TZGNCore object cache handling
-static UMutex gTZGNLock = U_MUTEX_INITIALIZER;
+static UMutex *gTZGNLock() {
+    static UMutex m = U_MUTEX_INITIALIZER;
+    return &m;
+}
 static UHashtable *gTZGNCoreCache = NULL;
 static UBool gTZGNCoreCacheInitialized = FALSE;
 
 // Access count - incremented every time up to SWEEP_INTERVAL,
 // then reset to 0
@@ -1176,17 +1182,17 @@
 TimeZoneGenericNames::TimeZoneGenericNames()
 : fRef(0) {
 }
 
 TimeZoneGenericNames::~TimeZoneGenericNames() {
-    umtx_lock(&gTZGNLock);
+    umtx_lock(gTZGNLock());
     {
         U_ASSERT(fRef->refCount > 0);
         // Just decrement the reference count
         fRef->refCount--;
     }
-    umtx_unlock(&gTZGNLock);
+    umtx_unlock(gTZGNLock());
 }
 
 TimeZoneGenericNames*
 TimeZoneGenericNames::createInstance(const Locale& locale, UErrorCode& status) {
     if (U_FAILURE(status)) {
@@ -1198,11 +1204,11 @@
         return NULL;
     }
 
     TZGNCoreRef *cacheEntry = NULL;
     {
-        Mutex lock(&gTZGNLock);
+        Mutex lock(gTZGNLock());
 
         if (!gTZGNCoreCacheInitialized) {
             // Create empty hashtable
             gTZGNCoreCache = uhash_open(uhash_hashChars, uhash_compareChars, NULL, &status);
             if (U_SUCCESS(status)) {
@@ -1290,17 +1296,17 @@
 
 TimeZoneGenericNames*
 TimeZoneGenericNames::clone() const {
     TimeZoneGenericNames* other = new TimeZoneGenericNames();
     if (other) {
-        umtx_lock(&gTZGNLock);
+        umtx_lock(gTZGNLock());
         {
             // Just increments the reference count
             fRef->refCount++;
             other->fRef = fRef;
         }
-        umtx_unlock(&gTZGNLock);
+        umtx_unlock(gTZGNLock());
     }
     return other;
 }
 
 UnicodeString&
