<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/region.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="regexcst.txt.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="reldatefmt.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/region.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
151                 LocalPointer&lt;UnicodeString&gt; newRegion(new UnicodeString(buf), status);
152                 allRegions-&gt;addElement(newRegion.orphan(),status);
153                 buf[rangeMarkerLocation-1]++;
154             }
155         } else {
156             LocalPointer&lt;UnicodeString&gt; newRegion(new UnicodeString(regionName), status);
157             allRegions-&gt;addElement(newRegion.orphan(),status);
158         }
159     }
160 
161     while ( ures_hasNext(regionUnknown.getAlias()) ) {
162         LocalPointer&lt;UnicodeString&gt; regionName (new UnicodeString(ures_getNextUnicodeString(regionUnknown.getAlias(),NULL,&amp;status),status));
163         allRegions-&gt;addElement(regionName.orphan(),status);
164     }
165 
166     while ( ures_hasNext(worldContainment.getAlias()) ) {
167         UnicodeString *continentName = new UnicodeString(ures_getNextUnicodeString(worldContainment.getAlias(),NULL,&amp;status));
168         continents-&gt;addElement(continentName,status);
169     }
170 

171     while ( ures_hasNext(groupingContainment.getAlias()) ) {
<span class="line-modified">172         UnicodeString *groupingName = new UnicodeString(ures_getNextUnicodeString(groupingContainment.getAlias(),NULL,&amp;status));</span>
<span class="line-modified">173         groupings-&gt;addElement(groupingName,status);</span>






174     }

175 
176     for ( int32_t i = 0 ; i &lt; allRegions-&gt;size() ; i++ ) {
177         LocalPointer&lt;Region&gt; r(new Region(), status);
178         if ( U_FAILURE(status) ) {
179            return;
180         }
181         UnicodeString *regionName = (UnicodeString *)allRegions-&gt;elementAt(i);
182         r-&gt;idStr = *regionName;
183 
184         r-&gt;idStr.extract(0,r-&gt;idStr.length(),r-&gt;id,sizeof(r-&gt;id),US_INV);
<span class="line-modified">185         r-&gt;type = URGN_TERRITORY; // Only temporary - figure out the real type later once the aliases are known.</span>
186 
187         Formattable result;
188         UErrorCode ps = U_ZERO_ERROR;
189         df-&gt;parse(r-&gt;idStr,result,ps);
190         if ( U_SUCCESS(ps) ) {
191             r-&gt;code = result.getLong(); // Convert string to number
192             uhash_iput(newNumericCodeMap.getAlias(),r-&gt;code,(void *)(r.getAlias()),&amp;status);
<span class="line-modified">193             r-&gt;type = URGN_SUBCONTINENT;</span>
194         } else {
195             r-&gt;code = -1;
196         }
197         void* idStrAlias = (void*)&amp;(r-&gt;idStr); // about to orphan &#39;r&#39;. Save this off.
198         uhash_put(newRegionIDMap.getAlias(),idStrAlias,(void *)(r.orphan()),&amp;status); // regionIDMap takes ownership
199     }
200 
201     // Process the territory aliases
202     while ( ures_hasNext(territoryAlias.getAlias()) ) {
203         LocalUResourceBundlePointer res(ures_getNextResource(territoryAlias.getAlias(),NULL,&amp;status));
204         const char *aliasFrom = ures_getKey(res.getAlias());
205         LocalPointer&lt;UnicodeString&gt; aliasFromStr(new UnicodeString(aliasFrom, -1, US_INV), status);
206         UnicodeString aliasTo = ures_getUnicodeStringByKey(res.getAlias(),&quot;replacement&quot;,&amp;status);
207         res.adoptInstead(NULL);
208 
209         const Region *aliasToRegion = (Region *) uhash_get(newRegionIDMap.getAlias(),&amp;aliasTo);
210         Region *aliasFromRegion = (Region *)uhash_get(newRegionIDMap.getAlias(),aliasFromStr.getAlias());
211 
212         if ( aliasToRegion != NULL &amp;&amp; aliasFromRegion == NULL ) { // This is just an alias from some string to a region
213             uhash_put(newRegionAliases.getAlias(),(void *)aliasFromStr.orphan(), (void *)aliasToRegion,&amp;status);
214         } else {
215             if ( aliasFromRegion == NULL ) { // Deprecated region code not in the master codes list - so need to create a deprecated region for it.
216                 LocalPointer&lt;Region&gt; newRgn(new Region, status);
217                 if ( U_SUCCESS(status) ) {
218                     aliasFromRegion = newRgn.orphan();
219                 } else {
220                     return; // error out
221                 }
222                 aliasFromRegion-&gt;idStr.setTo(*aliasFromStr);
223                 aliasFromRegion-&gt;idStr.extract(0,aliasFromRegion-&gt;idStr.length(),aliasFromRegion-&gt;id,sizeof(aliasFromRegion-&gt;id),US_INV);
224                 uhash_put(newRegionIDMap.getAlias(),(void *)&amp;(aliasFromRegion-&gt;idStr),(void *)aliasFromRegion,&amp;status);
225                 Formattable result;
226                 UErrorCode ps = U_ZERO_ERROR;
227                 df-&gt;parse(aliasFromRegion-&gt;idStr,result,ps);
228                 if ( U_SUCCESS(ps) ) {
229                     aliasFromRegion-&gt;code = result.getLong(); // Convert string to number
230                     uhash_iput(newNumericCodeMap.getAlias(),aliasFromRegion-&gt;code,(void *)aliasFromRegion,&amp;status);
231                 } else {
232                     aliasFromRegion-&gt;code = -1;
233                 }
<span class="line-modified">234                 aliasFromRegion-&gt;type = URGN_DEPRECATED;</span>
235             } else {
<span class="line-modified">236                 aliasFromRegion-&gt;type = URGN_DEPRECATED;</span>
237             }
238 
239             {
240                 LocalPointer&lt;UVector&gt; newPreferredValues(new UVector(uprv_deleteUObject, uhash_compareUnicodeString, status), status);
241                 aliasFromRegion-&gt;preferredValues = newPreferredValues.orphan();
242             }
243             if( U_FAILURE(status)) {
244                 return;
245             }
246             UnicodeString currentRegion;
247             //currentRegion.remove();   TODO: was already 0 length?
248             for (int32_t i = 0 ; i &lt; aliasTo.length() ; i++ ) {
249                 if ( aliasTo.charAt(i) != 0x0020 ) {
250                     currentRegion.append(aliasTo.charAt(i));
251                 }
252                 if ( aliasTo.charAt(i) == 0x0020 || i+1 == aliasTo.length() ) {
253                     Region *target = (Region *)uhash_get(newRegionIDMap.getAlias(),(void *)&amp;currentRegion);
254                     if (target) {
255                         LocalPointer&lt;UnicodeString&gt; preferredValue(new UnicodeString(target-&gt;idStr), status);
256                         aliasFromRegion-&gt;preferredValues-&gt;addElement((void *)preferredValue.orphan(),status);  // may add null if err
</pre>
<hr />
<pre>
273             if ( r ) {
274                 Formattable result;
275                 UErrorCode ps = U_ZERO_ERROR;
276                 df-&gt;parse(codeMappingNumber,result,ps);
277                 if ( U_SUCCESS(ps) ) {
278                     r-&gt;code = result.getLong(); // Convert string to number
279                     uhash_iput(newNumericCodeMap.getAlias(),r-&gt;code,(void *)r,&amp;status);
280                 }
281                 LocalPointer&lt;UnicodeString&gt; code3(new UnicodeString(codeMapping3Letter), status);
282                 uhash_put(newRegionAliases.getAlias(),(void *)code3.orphan(), (void *)r,&amp;status);
283             }
284         }
285         ures_close(mapping);
286     }
287 
288     // Now fill in the special cases for WORLD, UNKNOWN, CONTINENTS, and GROUPINGS
289     Region *r;
290     UnicodeString WORLD_ID_STRING(WORLD_ID);
291     r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;WORLD_ID_STRING);
292     if ( r ) {
<span class="line-modified">293         r-&gt;type = URGN_WORLD;</span>
294     }
295 
296     UnicodeString UNKNOWN_REGION_ID_STRING(UNKNOWN_REGION_ID);
297     r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;UNKNOWN_REGION_ID_STRING);
298     if ( r ) {
<span class="line-modified">299         r-&gt;type = URGN_UNKNOWN;</span>
300     }
301 
302     for ( int32_t i = 0 ; i &lt; continents-&gt;size() ; i++ ) {
303         r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)continents-&gt;elementAt(i));
304         if ( r ) {
<span class="line-modified">305             r-&gt;type = URGN_CONTINENT;</span>
306         }
307     }
308 
309     for ( int32_t i = 0 ; i &lt; groupings-&gt;size() ; i++ ) {
310         r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)groupings-&gt;elementAt(i));
311         if ( r ) {
<span class="line-modified">312             r-&gt;type = URGN_GROUPING;</span>
313         }
314     }
315 
316     // Special case: The region code &quot;QO&quot; (Outlying Oceania) is a subcontinent code added by CLDR
317     // even though it looks like a territory code.  Need to handle it here.
318 
319     UnicodeString OUTLYING_OCEANIA_REGION_ID_STRING(OUTLYING_OCEANIA_REGION_ID);
320     r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;OUTLYING_OCEANIA_REGION_ID_STRING);
321     if ( r ) {
<span class="line-modified">322         r-&gt;type = URGN_SUBCONTINENT;</span>
323     }
324 
325     // Load territory containment info from the supplemental data.
326     while ( ures_hasNext(territoryContainment.getAlias()) ) {
327         LocalUResourceBundlePointer mapping(ures_getNextResource(territoryContainment.getAlias(),NULL,&amp;status));
328         if( U_FAILURE(status) ) {
329             return;  // error out
330         }
331         const char *parent = ures_getKey(mapping.getAlias());
332         if (uprv_strcmp(parent, &quot;containedGroupings&quot;) == 0 || uprv_strcmp(parent, &quot;deprecated&quot;) == 0) {
333             continue; // handle new pseudo-parent types added in ICU data per cldrbug 7808; for now just skip.
334             // #11232 is to do something useful with these.
335         }
336         UnicodeString parentStr = UnicodeString(parent, -1 , US_INV);
337         Region *parentRegion = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;parentStr);
338 
339         for ( int j = 0 ; j &lt; ures_getSize(mapping.getAlias()); j++ ) {
340             UnicodeString child = ures_getUnicodeStringByIndex(mapping.getAlias(),j,&amp;status);
341             Region *childRegion = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;child);
342             if ( parentRegion != NULL &amp;&amp; childRegion != NULL ) {
343 
344                 // Add the child region to the set of regions contained by the parent
345                 if (parentRegion-&gt;containedRegions == NULL) {
346                     parentRegion-&gt;containedRegions = new UVector(uprv_deleteUObject, uhash_compareUnicodeString, status);
347                 }
348 
349                 LocalPointer&lt;UnicodeString&gt; childStr(new UnicodeString(), status);
350                 if( U_FAILURE(status) ) {
351                     return;  // error out
352                 }
353                 childStr-&gt;fastCopyFrom(childRegion-&gt;idStr);
354                 parentRegion-&gt;containedRegions-&gt;addElement((void *)childStr.orphan(),status);
355 
356                 // Set the parent region to be the containing region of the child.
357                 // Regions of type GROUPING can&#39;t be set as the parent, since another region
358                 // such as a SUBCONTINENT, CONTINENT, or WORLD must always be the parent.
<span class="line-modified">359                 if ( parentRegion-&gt;type != URGN_GROUPING) {</span>
360                     childRegion-&gt;containingRegion = parentRegion;
361                 }
362             }
363         }
364     }
365 
366     // Create the availableRegions lists
367     int32_t pos = UHASH_FIRST;
368     while ( const UHashElement* element = uhash_nextElement(newRegionIDMap.getAlias(),&amp;pos)) {
369         Region *ar = (Region *)element-&gt;value.pointer;
<span class="line-modified">370         if ( availableRegions[ar-&gt;type] == NULL ) {</span>
371             LocalPointer&lt;UVector&gt; newAr(new UVector(uprv_deleteUObject, uhash_compareUnicodeString, status), status);
<span class="line-modified">372             availableRegions[ar-&gt;type] = newAr.orphan();</span>
373         }
374         LocalPointer&lt;UnicodeString&gt; arString(new UnicodeString(ar-&gt;idStr), status);
375         if( U_FAILURE(status) ) {
376             return;  // error out
377         }
<span class="line-modified">378         availableRegions[ar-&gt;type]-&gt;addElement((void *)arString.orphan(),status);</span>
379     }
380 
381     ucln_i18n_registerCleanup(UCLN_I18N_REGION, region_cleanup);
382     // copy hashtables
383     numericCodeMap = newNumericCodeMap.orphan();
384     regionIDMap = newRegionIDMap.orphan();
385     regionAliases = newRegionAliases.orphan();
386 }
387 
388 void Region::cleanupRegionData() {
389     for (int32_t i = 0 ; i &lt; URGN_LIMIT ; i++ ) {
390         if ( availableRegions[i] ) {
391             delete availableRegions[i];
392         }
393     }
394 
395     if (regionAliases) {
396         uhash_close(regionAliases);
397     }
398 
399     if (numericCodeMap) {
400         uhash_close(numericCodeMap);
401     }
402 
403     if (regionIDMap) {
404         uhash_close(regionIDMap);
405     }
406     if (allRegions) {
407         allRegions-&gt;removeAllElements(); // Don&#39;t need the temporary list anymore.
408         delete allRegions;
409         allRegions = NULL;
410     }
411 
412     regionAliases = numericCodeMap = regionIDMap = NULL;
413 
414     gRegionDataInitOnce.reset();
415 }
416 
417 Region::Region ()
418         : code(-1),
<span class="line-modified">419           type(URGN_UNKNOWN),</span>
420           containingRegion(NULL),
421           containedRegions(NULL),
422           preferredValues(NULL) {
423     id[0] = 0;
424 }
425 
426 Region::~Region () {
427         if (containedRegions) {
428             delete containedRegions;
429         }
430         if (preferredValues) {
431             delete preferredValues;
432         }
433 }
434 
435 /**
436  * Returns true if the two regions are equal.
437  * Per PMC, just use pointer compare, since we have at most one instance of each Region.
438  */
439 UBool
</pre>
<hr />
<pre>
464         return NULL;
465     }
466 
467     if ( !region_code ) {
468         status = U_ILLEGAL_ARGUMENT_ERROR;
469         return NULL;
470     }
471 
472     UnicodeString regionCodeString = UnicodeString(region_code, -1, US_INV);
473     Region *r = (Region *)uhash_get(regionIDMap,(void *)&amp;regionCodeString);
474 
475     if ( !r ) {
476         r = (Region *)uhash_get(regionAliases,(void *)&amp;regionCodeString);
477     }
478 
479     if ( !r ) { // Unknown region code
480         status = U_ILLEGAL_ARGUMENT_ERROR;
481         return NULL;
482     }
483 
<span class="line-modified">484     if ( r-&gt;type == URGN_DEPRECATED &amp;&amp; r-&gt;preferredValues-&gt;size() == 1) {</span>
485         StringEnumeration *pv = r-&gt;getPreferredValues(status);
486         pv-&gt;reset(status);
487         const UnicodeString *ustr = pv-&gt;snext(status);
488         r = (Region *)uhash_get(regionIDMap,(void *)ustr);
489         delete pv;
490     }
491 
492     return r;
493 
494 }
495 
496 /**
497  * Returns a pointer to a Region using the given numeric region code. If the numeric region code is not recognized,
498  * the appropriate error code will be set ( U_ILLEGAL_ARGUMENT_ERROR ).
499  */
500 const Region* U_EXPORT2
501 Region::getInstance (int32_t code, UErrorCode &amp;status) {
502 
503     umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status);
504     if (U_FAILURE(status)) {
</pre>
<hr />
<pre>
512         LocalPointer&lt;DecimalFormat&gt; df(new DecimalFormat(pat,status), status);
513         if( U_FAILURE(status) ) {
514             return NULL;
515         }
516         UnicodeString id;
517         id.remove();
518         FieldPosition posIter;
519         df-&gt;format(code,id, posIter, status);
520         r = (Region *)uhash_get(regionAliases,&amp;id);
521     }
522 
523     if( U_FAILURE(status) ) {
524         return NULL;
525     }
526 
527     if ( !r ) {
528         status = U_ILLEGAL_ARGUMENT_ERROR;
529         return NULL;
530     }
531 
<span class="line-modified">532     if ( r-&gt;type == URGN_DEPRECATED &amp;&amp; r-&gt;preferredValues-&gt;size() == 1) {</span>
533         StringEnumeration *pv = r-&gt;getPreferredValues(status);
534         pv-&gt;reset(status);
535         const UnicodeString *ustr = pv-&gt;snext(status);
536         r = (Region *)uhash_get(regionIDMap,(void *)ustr);
537         delete pv;
538     }
539 
540     return r;
541 }
542 
543 
544 /**
545  * Returns an enumeration over the IDs of all known regions that match the given type.
546  */
547 StringEnumeration* U_EXPORT2
548 Region::getAvailable(URegionType type, UErrorCode &amp;status) {
549     umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status); // returns immediately if U_FAILURE(status)
550     if (U_FAILURE(status)) {
551         return NULL;
552     }
</pre>
<hr />
<pre>
563     UErrorCode status = U_ZERO_ERROR;
564     umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status);
565     return containingRegion;
566 }
567 
568 /**
569  * Return a pointer to the region that geographically contains this region and matches the given type,
570  * moving multiple steps up the containment chain if necessary.  Returns NULL if no containing region can be found
571  * that matches the given type. Note: The URegionTypes = &quot;URGN_GROUPING&quot;, &quot;URGN_DEPRECATED&quot;, or &quot;URGN_UNKNOWN&quot;
572  * are not appropriate for use in this API. NULL will be returned in this case. For example, calling this method
573  * with region &quot;IT&quot; (Italy) for type &quot;URGN_CONTINENT&quot; returns the region &quot;150&quot; ( Europe ).
574  */
575 const Region*
576 Region::getContainingRegion(URegionType type) const {
577     UErrorCode status = U_ZERO_ERROR;
578     umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status);
579     if ( containingRegion == NULL ) {
580         return NULL;
581     }
582 
<span class="line-modified">583     return ( containingRegion-&gt;type == type )? containingRegion: containingRegion-&gt;getContainingRegion(type);</span>
584 }
585 
586 /**
587  * Return an enumeration over the IDs of all the regions that are immediate children of this region in the
588  * region hierarchy. These returned regions could be either macro regions, territories, or a mixture of the two,
589  * depending on the containment data as defined in CLDR.  This API may return NULL if this region doesn&#39;t have
590  * any sub-regions. For example, calling this method with region &quot;150&quot; (Europe) returns an enumeration containing
591  * the various sub regions of Europe - &quot;039&quot; (Southern Europe) - &quot;151&quot; (Eastern Europe) - &quot;154&quot; (Northern Europe)
592  * and &quot;155&quot; (Western Europe).
593  */
594 StringEnumeration*
595 Region::getContainedRegions(UErrorCode &amp;status) const {
596     umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status); // returns immediately if U_FAILURE(status)
597     if (U_FAILURE(status)) {
598         return NULL;
599     }
600     return new RegionNameEnumeration(containedRegions,status);
601 }
602 
603 /**
604  * Returns an enumeration over the IDs of all the regions that are children of this region anywhere in the region
605  * hierarchy and match the given type.  This API may return an empty enumeration if this region doesn&#39;t have any
606  * sub-regions that match the given type. For example, calling this method with region &quot;150&quot; (Europe) and type
607  * &quot;URGN_TERRITORY&quot; returns a set containing all the territories in Europe ( &quot;FR&quot; (France) - &quot;IT&quot; (Italy) - &quot;DE&quot; (Germany) etc. )
608  */
609 StringEnumeration*
610 Region::getContainedRegions( URegionType type, UErrorCode &amp;status ) const {
611     umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status); // returns immediately if U_FAILURE(status)
612     if (U_FAILURE(status)) {
613         return NULL;
614     }
615 
616     UVector *result = new UVector(NULL, uhash_compareChars, status);
617 
618     StringEnumeration *cr = getContainedRegions(status);
619 
620     for ( int32_t i = 0 ; i &lt; cr-&gt;count(status) ; i++ ) {
<span class="line-modified">621         const char *id = cr-&gt;next(NULL,status);</span>
<span class="line-modified">622         const Region *r = Region::getInstance(id,status);</span>
<span class="line-modified">623         if ( r-&gt;getType() == type ) {</span>
624             result-&gt;addElement((void *)&amp;r-&gt;idStr,status);
625         } else {
626             StringEnumeration *children = r-&gt;getContainedRegions(type, status);
627             for ( int32_t j = 0 ; j &lt; children-&gt;count(status) ; j++ ) {
628                 const char *id2 = children-&gt;next(NULL,status);
629                 const Region *r2 = Region::getInstance(id2,status);
630                 result-&gt;addElement((void *)&amp;r2-&gt;idStr,status);
631             }
632             delete children;
633         }
634     }
635     delete cr;
636     StringEnumeration* resultEnumeration = new RegionNameEnumeration(result,status);
637     delete result;
638     return resultEnumeration;
639 }
640 
641 /**
642  * Returns true if this region contains the supplied other region anywhere in the region hierarchy.
643  */
</pre>
<hr />
<pre>
655         for ( int32_t i = 0 ; i &lt; containedRegions-&gt;size() ; i++ ) {
656             UnicodeString *crStr = (UnicodeString *)containedRegions-&gt;elementAt(i);
657             Region *cr = (Region *) uhash_get(regionIDMap,(void *)crStr);
658             if ( cr &amp;&amp; cr-&gt;contains(other) ) {
659                 return TRUE;
660             }
661         }
662     }
663 
664     return FALSE;
665 }
666 
667 /**
668  * For deprecated regions, return an enumeration over the IDs of the regions that are the preferred replacement
669  * regions for this region.  Returns NULL for a non-deprecated region.  For example, calling this method with region
670  * &quot;SU&quot; (Soviet Union) would return a list of the regions containing &quot;RU&quot; (Russia), &quot;AM&quot; (Armenia), &quot;AZ&quot; (Azerbaijan), etc...
671  */
672 StringEnumeration*
673 Region::getPreferredValues(UErrorCode &amp;status) const {
674     umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status); // returns immediately if U_FAILURE(status)
<span class="line-modified">675     if (U_FAILURE(status) ||  type != URGN_DEPRECATED) {</span>
676         return NULL;
677     }
678     return new RegionNameEnumeration(preferredValues,status);
679 }
680 
681 
682 /**
683  * Return this region&#39;s canonical region code.
684  */
685 const char*
686 Region::getRegionCode() const {
687     return id;
688 }
689 
690 int32_t
691 Region::getNumericCode() const {
692     return code;
693 }
694 
695 /**
696  * Returns the region type of this region.
697  */
698 URegionType
699 Region::getType() const {
<span class="line-modified">700     return type;</span>
701 }
702 
703 RegionNameEnumeration::RegionNameEnumeration(UVector *fNameList, UErrorCode&amp; status) {
704     pos=0;
705     if (fNameList &amp;&amp; U_SUCCESS(status)) {
706         fRegionNames = new UVector(uprv_deleteUObject, uhash_compareUnicodeString, fNameList-&gt;size(),status);
707         for ( int32_t i = 0 ; i &lt; fNameList-&gt;size() ; i++ ) {
708             UnicodeString* this_region_name = (UnicodeString *)fNameList-&gt;elementAt(i);
709             UnicodeString* new_region_name = new UnicodeString(*this_region_name);
710             fRegionNames-&gt;addElement((void *)new_region_name,status);
711         }
712     }
713     else {
714         fRegionNames = NULL;
715     }
716 }
717 
718 const UnicodeString*
719 RegionNameEnumeration::snext(UErrorCode&amp; status) {
720   if (U_FAILURE(status) || (fRegionNames==NULL)) {
</pre>
</td>
<td>
<hr />
<pre>
151                 LocalPointer&lt;UnicodeString&gt; newRegion(new UnicodeString(buf), status);
152                 allRegions-&gt;addElement(newRegion.orphan(),status);
153                 buf[rangeMarkerLocation-1]++;
154             }
155         } else {
156             LocalPointer&lt;UnicodeString&gt; newRegion(new UnicodeString(regionName), status);
157             allRegions-&gt;addElement(newRegion.orphan(),status);
158         }
159     }
160 
161     while ( ures_hasNext(regionUnknown.getAlias()) ) {
162         LocalPointer&lt;UnicodeString&gt; regionName (new UnicodeString(ures_getNextUnicodeString(regionUnknown.getAlias(),NULL,&amp;status),status));
163         allRegions-&gt;addElement(regionName.orphan(),status);
164     }
165 
166     while ( ures_hasNext(worldContainment.getAlias()) ) {
167         UnicodeString *continentName = new UnicodeString(ures_getNextUnicodeString(worldContainment.getAlias(),NULL,&amp;status));
168         continents-&gt;addElement(continentName,status);
169     }
170 
<span class="line-added">171     UResourceBundle *groupingBundle = nullptr;</span>
172     while ( ures_hasNext(groupingContainment.getAlias()) ) {
<span class="line-modified">173         groupingBundle = ures_getNextResource(groupingContainment.getAlias(), groupingBundle, &amp;status);</span>
<span class="line-modified">174         if (U_FAILURE(status)) {</span>
<span class="line-added">175             break;</span>
<span class="line-added">176         }</span>
<span class="line-added">177         UnicodeString *groupingName = new UnicodeString(ures_getKey(groupingBundle), -1, US_INV);</span>
<span class="line-added">178         if (groupingName) {</span>
<span class="line-added">179             groupings-&gt;addElement(groupingName,status);</span>
<span class="line-added">180         }</span>
181     }
<span class="line-added">182     ures_close(groupingBundle);</span>
183 
184     for ( int32_t i = 0 ; i &lt; allRegions-&gt;size() ; i++ ) {
185         LocalPointer&lt;Region&gt; r(new Region(), status);
186         if ( U_FAILURE(status) ) {
187            return;
188         }
189         UnicodeString *regionName = (UnicodeString *)allRegions-&gt;elementAt(i);
190         r-&gt;idStr = *regionName;
191 
192         r-&gt;idStr.extract(0,r-&gt;idStr.length(),r-&gt;id,sizeof(r-&gt;id),US_INV);
<span class="line-modified">193         r-&gt;fType = URGN_TERRITORY; // Only temporary - figure out the real type later once the aliases are known.</span>
194 
195         Formattable result;
196         UErrorCode ps = U_ZERO_ERROR;
197         df-&gt;parse(r-&gt;idStr,result,ps);
198         if ( U_SUCCESS(ps) ) {
199             r-&gt;code = result.getLong(); // Convert string to number
200             uhash_iput(newNumericCodeMap.getAlias(),r-&gt;code,(void *)(r.getAlias()),&amp;status);
<span class="line-modified">201             r-&gt;fType = URGN_SUBCONTINENT;</span>
202         } else {
203             r-&gt;code = -1;
204         }
205         void* idStrAlias = (void*)&amp;(r-&gt;idStr); // about to orphan &#39;r&#39;. Save this off.
206         uhash_put(newRegionIDMap.getAlias(),idStrAlias,(void *)(r.orphan()),&amp;status); // regionIDMap takes ownership
207     }
208 
209     // Process the territory aliases
210     while ( ures_hasNext(territoryAlias.getAlias()) ) {
211         LocalUResourceBundlePointer res(ures_getNextResource(territoryAlias.getAlias(),NULL,&amp;status));
212         const char *aliasFrom = ures_getKey(res.getAlias());
213         LocalPointer&lt;UnicodeString&gt; aliasFromStr(new UnicodeString(aliasFrom, -1, US_INV), status);
214         UnicodeString aliasTo = ures_getUnicodeStringByKey(res.getAlias(),&quot;replacement&quot;,&amp;status);
215         res.adoptInstead(NULL);
216 
217         const Region *aliasToRegion = (Region *) uhash_get(newRegionIDMap.getAlias(),&amp;aliasTo);
218         Region *aliasFromRegion = (Region *)uhash_get(newRegionIDMap.getAlias(),aliasFromStr.getAlias());
219 
220         if ( aliasToRegion != NULL &amp;&amp; aliasFromRegion == NULL ) { // This is just an alias from some string to a region
221             uhash_put(newRegionAliases.getAlias(),(void *)aliasFromStr.orphan(), (void *)aliasToRegion,&amp;status);
222         } else {
223             if ( aliasFromRegion == NULL ) { // Deprecated region code not in the master codes list - so need to create a deprecated region for it.
224                 LocalPointer&lt;Region&gt; newRgn(new Region, status);
225                 if ( U_SUCCESS(status) ) {
226                     aliasFromRegion = newRgn.orphan();
227                 } else {
228                     return; // error out
229                 }
230                 aliasFromRegion-&gt;idStr.setTo(*aliasFromStr);
231                 aliasFromRegion-&gt;idStr.extract(0,aliasFromRegion-&gt;idStr.length(),aliasFromRegion-&gt;id,sizeof(aliasFromRegion-&gt;id),US_INV);
232                 uhash_put(newRegionIDMap.getAlias(),(void *)&amp;(aliasFromRegion-&gt;idStr),(void *)aliasFromRegion,&amp;status);
233                 Formattable result;
234                 UErrorCode ps = U_ZERO_ERROR;
235                 df-&gt;parse(aliasFromRegion-&gt;idStr,result,ps);
236                 if ( U_SUCCESS(ps) ) {
237                     aliasFromRegion-&gt;code = result.getLong(); // Convert string to number
238                     uhash_iput(newNumericCodeMap.getAlias(),aliasFromRegion-&gt;code,(void *)aliasFromRegion,&amp;status);
239                 } else {
240                     aliasFromRegion-&gt;code = -1;
241                 }
<span class="line-modified">242                 aliasFromRegion-&gt;fType = URGN_DEPRECATED;</span>
243             } else {
<span class="line-modified">244                 aliasFromRegion-&gt;fType = URGN_DEPRECATED;</span>
245             }
246 
247             {
248                 LocalPointer&lt;UVector&gt; newPreferredValues(new UVector(uprv_deleteUObject, uhash_compareUnicodeString, status), status);
249                 aliasFromRegion-&gt;preferredValues = newPreferredValues.orphan();
250             }
251             if( U_FAILURE(status)) {
252                 return;
253             }
254             UnicodeString currentRegion;
255             //currentRegion.remove();   TODO: was already 0 length?
256             for (int32_t i = 0 ; i &lt; aliasTo.length() ; i++ ) {
257                 if ( aliasTo.charAt(i) != 0x0020 ) {
258                     currentRegion.append(aliasTo.charAt(i));
259                 }
260                 if ( aliasTo.charAt(i) == 0x0020 || i+1 == aliasTo.length() ) {
261                     Region *target = (Region *)uhash_get(newRegionIDMap.getAlias(),(void *)&amp;currentRegion);
262                     if (target) {
263                         LocalPointer&lt;UnicodeString&gt; preferredValue(new UnicodeString(target-&gt;idStr), status);
264                         aliasFromRegion-&gt;preferredValues-&gt;addElement((void *)preferredValue.orphan(),status);  // may add null if err
</pre>
<hr />
<pre>
281             if ( r ) {
282                 Formattable result;
283                 UErrorCode ps = U_ZERO_ERROR;
284                 df-&gt;parse(codeMappingNumber,result,ps);
285                 if ( U_SUCCESS(ps) ) {
286                     r-&gt;code = result.getLong(); // Convert string to number
287                     uhash_iput(newNumericCodeMap.getAlias(),r-&gt;code,(void *)r,&amp;status);
288                 }
289                 LocalPointer&lt;UnicodeString&gt; code3(new UnicodeString(codeMapping3Letter), status);
290                 uhash_put(newRegionAliases.getAlias(),(void *)code3.orphan(), (void *)r,&amp;status);
291             }
292         }
293         ures_close(mapping);
294     }
295 
296     // Now fill in the special cases for WORLD, UNKNOWN, CONTINENTS, and GROUPINGS
297     Region *r;
298     UnicodeString WORLD_ID_STRING(WORLD_ID);
299     r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;WORLD_ID_STRING);
300     if ( r ) {
<span class="line-modified">301         r-&gt;fType = URGN_WORLD;</span>
302     }
303 
304     UnicodeString UNKNOWN_REGION_ID_STRING(UNKNOWN_REGION_ID);
305     r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;UNKNOWN_REGION_ID_STRING);
306     if ( r ) {
<span class="line-modified">307         r-&gt;fType = URGN_UNKNOWN;</span>
308     }
309 
310     for ( int32_t i = 0 ; i &lt; continents-&gt;size() ; i++ ) {
311         r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)continents-&gt;elementAt(i));
312         if ( r ) {
<span class="line-modified">313             r-&gt;fType = URGN_CONTINENT;</span>
314         }
315     }
316 
317     for ( int32_t i = 0 ; i &lt; groupings-&gt;size() ; i++ ) {
318         r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)groupings-&gt;elementAt(i));
319         if ( r ) {
<span class="line-modified">320             r-&gt;fType = URGN_GROUPING;</span>
321         }
322     }
323 
324     // Special case: The region code &quot;QO&quot; (Outlying Oceania) is a subcontinent code added by CLDR
325     // even though it looks like a territory code.  Need to handle it here.
326 
327     UnicodeString OUTLYING_OCEANIA_REGION_ID_STRING(OUTLYING_OCEANIA_REGION_ID);
328     r = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;OUTLYING_OCEANIA_REGION_ID_STRING);
329     if ( r ) {
<span class="line-modified">330         r-&gt;fType = URGN_SUBCONTINENT;</span>
331     }
332 
333     // Load territory containment info from the supplemental data.
334     while ( ures_hasNext(territoryContainment.getAlias()) ) {
335         LocalUResourceBundlePointer mapping(ures_getNextResource(territoryContainment.getAlias(),NULL,&amp;status));
336         if( U_FAILURE(status) ) {
337             return;  // error out
338         }
339         const char *parent = ures_getKey(mapping.getAlias());
340         if (uprv_strcmp(parent, &quot;containedGroupings&quot;) == 0 || uprv_strcmp(parent, &quot;deprecated&quot;) == 0) {
341             continue; // handle new pseudo-parent types added in ICU data per cldrbug 7808; for now just skip.
342             // #11232 is to do something useful with these.
343         }
344         UnicodeString parentStr = UnicodeString(parent, -1 , US_INV);
345         Region *parentRegion = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;parentStr);
346 
347         for ( int j = 0 ; j &lt; ures_getSize(mapping.getAlias()); j++ ) {
348             UnicodeString child = ures_getUnicodeStringByIndex(mapping.getAlias(),j,&amp;status);
349             Region *childRegion = (Region *) uhash_get(newRegionIDMap.getAlias(),(void *)&amp;child);
350             if ( parentRegion != NULL &amp;&amp; childRegion != NULL ) {
351 
352                 // Add the child region to the set of regions contained by the parent
353                 if (parentRegion-&gt;containedRegions == NULL) {
354                     parentRegion-&gt;containedRegions = new UVector(uprv_deleteUObject, uhash_compareUnicodeString, status);
355                 }
356 
357                 LocalPointer&lt;UnicodeString&gt; childStr(new UnicodeString(), status);
358                 if( U_FAILURE(status) ) {
359                     return;  // error out
360                 }
361                 childStr-&gt;fastCopyFrom(childRegion-&gt;idStr);
362                 parentRegion-&gt;containedRegions-&gt;addElement((void *)childStr.orphan(),status);
363 
364                 // Set the parent region to be the containing region of the child.
365                 // Regions of type GROUPING can&#39;t be set as the parent, since another region
366                 // such as a SUBCONTINENT, CONTINENT, or WORLD must always be the parent.
<span class="line-modified">367                 if ( parentRegion-&gt;fType != URGN_GROUPING) {</span>
368                     childRegion-&gt;containingRegion = parentRegion;
369                 }
370             }
371         }
372     }
373 
374     // Create the availableRegions lists
375     int32_t pos = UHASH_FIRST;
376     while ( const UHashElement* element = uhash_nextElement(newRegionIDMap.getAlias(),&amp;pos)) {
377         Region *ar = (Region *)element-&gt;value.pointer;
<span class="line-modified">378         if ( availableRegions[ar-&gt;fType] == NULL ) {</span>
379             LocalPointer&lt;UVector&gt; newAr(new UVector(uprv_deleteUObject, uhash_compareUnicodeString, status), status);
<span class="line-modified">380             availableRegions[ar-&gt;fType] = newAr.orphan();</span>
381         }
382         LocalPointer&lt;UnicodeString&gt; arString(new UnicodeString(ar-&gt;idStr), status);
383         if( U_FAILURE(status) ) {
384             return;  // error out
385         }
<span class="line-modified">386         availableRegions[ar-&gt;fType]-&gt;addElement((void *)arString.orphan(),status);</span>
387     }
388 
389     ucln_i18n_registerCleanup(UCLN_I18N_REGION, region_cleanup);
390     // copy hashtables
391     numericCodeMap = newNumericCodeMap.orphan();
392     regionIDMap = newRegionIDMap.orphan();
393     regionAliases = newRegionAliases.orphan();
394 }
395 
396 void Region::cleanupRegionData() {
397     for (int32_t i = 0 ; i &lt; URGN_LIMIT ; i++ ) {
398         if ( availableRegions[i] ) {
399             delete availableRegions[i];
400         }
401     }
402 
403     if (regionAliases) {
404         uhash_close(regionAliases);
405     }
406 
407     if (numericCodeMap) {
408         uhash_close(numericCodeMap);
409     }
410 
411     if (regionIDMap) {
412         uhash_close(regionIDMap);
413     }
414     if (allRegions) {
415         allRegions-&gt;removeAllElements(); // Don&#39;t need the temporary list anymore.
416         delete allRegions;
417         allRegions = NULL;
418     }
419 
420     regionAliases = numericCodeMap = regionIDMap = NULL;
421 
422     gRegionDataInitOnce.reset();
423 }
424 
425 Region::Region ()
426         : code(-1),
<span class="line-modified">427           fType(URGN_UNKNOWN),</span>
428           containingRegion(NULL),
429           containedRegions(NULL),
430           preferredValues(NULL) {
431     id[0] = 0;
432 }
433 
434 Region::~Region () {
435         if (containedRegions) {
436             delete containedRegions;
437         }
438         if (preferredValues) {
439             delete preferredValues;
440         }
441 }
442 
443 /**
444  * Returns true if the two regions are equal.
445  * Per PMC, just use pointer compare, since we have at most one instance of each Region.
446  */
447 UBool
</pre>
<hr />
<pre>
472         return NULL;
473     }
474 
475     if ( !region_code ) {
476         status = U_ILLEGAL_ARGUMENT_ERROR;
477         return NULL;
478     }
479 
480     UnicodeString regionCodeString = UnicodeString(region_code, -1, US_INV);
481     Region *r = (Region *)uhash_get(regionIDMap,(void *)&amp;regionCodeString);
482 
483     if ( !r ) {
484         r = (Region *)uhash_get(regionAliases,(void *)&amp;regionCodeString);
485     }
486 
487     if ( !r ) { // Unknown region code
488         status = U_ILLEGAL_ARGUMENT_ERROR;
489         return NULL;
490     }
491 
<span class="line-modified">492     if ( r-&gt;fType == URGN_DEPRECATED &amp;&amp; r-&gt;preferredValues-&gt;size() == 1) {</span>
493         StringEnumeration *pv = r-&gt;getPreferredValues(status);
494         pv-&gt;reset(status);
495         const UnicodeString *ustr = pv-&gt;snext(status);
496         r = (Region *)uhash_get(regionIDMap,(void *)ustr);
497         delete pv;
498     }
499 
500     return r;
501 
502 }
503 
504 /**
505  * Returns a pointer to a Region using the given numeric region code. If the numeric region code is not recognized,
506  * the appropriate error code will be set ( U_ILLEGAL_ARGUMENT_ERROR ).
507  */
508 const Region* U_EXPORT2
509 Region::getInstance (int32_t code, UErrorCode &amp;status) {
510 
511     umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status);
512     if (U_FAILURE(status)) {
</pre>
<hr />
<pre>
520         LocalPointer&lt;DecimalFormat&gt; df(new DecimalFormat(pat,status), status);
521         if( U_FAILURE(status) ) {
522             return NULL;
523         }
524         UnicodeString id;
525         id.remove();
526         FieldPosition posIter;
527         df-&gt;format(code,id, posIter, status);
528         r = (Region *)uhash_get(regionAliases,&amp;id);
529     }
530 
531     if( U_FAILURE(status) ) {
532         return NULL;
533     }
534 
535     if ( !r ) {
536         status = U_ILLEGAL_ARGUMENT_ERROR;
537         return NULL;
538     }
539 
<span class="line-modified">540     if ( r-&gt;fType == URGN_DEPRECATED &amp;&amp; r-&gt;preferredValues-&gt;size() == 1) {</span>
541         StringEnumeration *pv = r-&gt;getPreferredValues(status);
542         pv-&gt;reset(status);
543         const UnicodeString *ustr = pv-&gt;snext(status);
544         r = (Region *)uhash_get(regionIDMap,(void *)ustr);
545         delete pv;
546     }
547 
548     return r;
549 }
550 
551 
552 /**
553  * Returns an enumeration over the IDs of all known regions that match the given type.
554  */
555 StringEnumeration* U_EXPORT2
556 Region::getAvailable(URegionType type, UErrorCode &amp;status) {
557     umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status); // returns immediately if U_FAILURE(status)
558     if (U_FAILURE(status)) {
559         return NULL;
560     }
</pre>
<hr />
<pre>
571     UErrorCode status = U_ZERO_ERROR;
572     umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status);
573     return containingRegion;
574 }
575 
576 /**
577  * Return a pointer to the region that geographically contains this region and matches the given type,
578  * moving multiple steps up the containment chain if necessary.  Returns NULL if no containing region can be found
579  * that matches the given type. Note: The URegionTypes = &quot;URGN_GROUPING&quot;, &quot;URGN_DEPRECATED&quot;, or &quot;URGN_UNKNOWN&quot;
580  * are not appropriate for use in this API. NULL will be returned in this case. For example, calling this method
581  * with region &quot;IT&quot; (Italy) for type &quot;URGN_CONTINENT&quot; returns the region &quot;150&quot; ( Europe ).
582  */
583 const Region*
584 Region::getContainingRegion(URegionType type) const {
585     UErrorCode status = U_ZERO_ERROR;
586     umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status);
587     if ( containingRegion == NULL ) {
588         return NULL;
589     }
590 
<span class="line-modified">591     return ( containingRegion-&gt;fType == type)? containingRegion: containingRegion-&gt;getContainingRegion(type);</span>
592 }
593 
594 /**
595  * Return an enumeration over the IDs of all the regions that are immediate children of this region in the
596  * region hierarchy. These returned regions could be either macro regions, territories, or a mixture of the two,
597  * depending on the containment data as defined in CLDR.  This API may return NULL if this region doesn&#39;t have
598  * any sub-regions. For example, calling this method with region &quot;150&quot; (Europe) returns an enumeration containing
599  * the various sub regions of Europe - &quot;039&quot; (Southern Europe) - &quot;151&quot; (Eastern Europe) - &quot;154&quot; (Northern Europe)
600  * and &quot;155&quot; (Western Europe).
601  */
602 StringEnumeration*
603 Region::getContainedRegions(UErrorCode &amp;status) const {
604     umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status); // returns immediately if U_FAILURE(status)
605     if (U_FAILURE(status)) {
606         return NULL;
607     }
608     return new RegionNameEnumeration(containedRegions,status);
609 }
610 
611 /**
612  * Returns an enumeration over the IDs of all the regions that are children of this region anywhere in the region
613  * hierarchy and match the given type.  This API may return an empty enumeration if this region doesn&#39;t have any
614  * sub-regions that match the given type. For example, calling this method with region &quot;150&quot; (Europe) and type
615  * &quot;URGN_TERRITORY&quot; returns a set containing all the territories in Europe ( &quot;FR&quot; (France) - &quot;IT&quot; (Italy) - &quot;DE&quot; (Germany) etc. )
616  */
617 StringEnumeration*
618 Region::getContainedRegions( URegionType type, UErrorCode &amp;status ) const {
619     umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status); // returns immediately if U_FAILURE(status)
620     if (U_FAILURE(status)) {
621         return NULL;
622     }
623 
624     UVector *result = new UVector(NULL, uhash_compareChars, status);
625 
626     StringEnumeration *cr = getContainedRegions(status);
627 
628     for ( int32_t i = 0 ; i &lt; cr-&gt;count(status) ; i++ ) {
<span class="line-modified">629         const char *regionId = cr-&gt;next(NULL,status);</span>
<span class="line-modified">630         const Region *r = Region::getInstance(regionId,status);</span>
<span class="line-modified">631         if ( r-&gt;getType() == type) {</span>
632             result-&gt;addElement((void *)&amp;r-&gt;idStr,status);
633         } else {
634             StringEnumeration *children = r-&gt;getContainedRegions(type, status);
635             for ( int32_t j = 0 ; j &lt; children-&gt;count(status) ; j++ ) {
636                 const char *id2 = children-&gt;next(NULL,status);
637                 const Region *r2 = Region::getInstance(id2,status);
638                 result-&gt;addElement((void *)&amp;r2-&gt;idStr,status);
639             }
640             delete children;
641         }
642     }
643     delete cr;
644     StringEnumeration* resultEnumeration = new RegionNameEnumeration(result,status);
645     delete result;
646     return resultEnumeration;
647 }
648 
649 /**
650  * Returns true if this region contains the supplied other region anywhere in the region hierarchy.
651  */
</pre>
<hr />
<pre>
663         for ( int32_t i = 0 ; i &lt; containedRegions-&gt;size() ; i++ ) {
664             UnicodeString *crStr = (UnicodeString *)containedRegions-&gt;elementAt(i);
665             Region *cr = (Region *) uhash_get(regionIDMap,(void *)crStr);
666             if ( cr &amp;&amp; cr-&gt;contains(other) ) {
667                 return TRUE;
668             }
669         }
670     }
671 
672     return FALSE;
673 }
674 
675 /**
676  * For deprecated regions, return an enumeration over the IDs of the regions that are the preferred replacement
677  * regions for this region.  Returns NULL for a non-deprecated region.  For example, calling this method with region
678  * &quot;SU&quot; (Soviet Union) would return a list of the regions containing &quot;RU&quot; (Russia), &quot;AM&quot; (Armenia), &quot;AZ&quot; (Azerbaijan), etc...
679  */
680 StringEnumeration*
681 Region::getPreferredValues(UErrorCode &amp;status) const {
682     umtx_initOnce(gRegionDataInitOnce, &amp;loadRegionData, status); // returns immediately if U_FAILURE(status)
<span class="line-modified">683     if (U_FAILURE(status) || fType != URGN_DEPRECATED) {</span>
684         return NULL;
685     }
686     return new RegionNameEnumeration(preferredValues,status);
687 }
688 
689 
690 /**
691  * Return this region&#39;s canonical region code.
692  */
693 const char*
694 Region::getRegionCode() const {
695     return id;
696 }
697 
698 int32_t
699 Region::getNumericCode() const {
700     return code;
701 }
702 
703 /**
704  * Returns the region type of this region.
705  */
706 URegionType
707 Region::getType() const {
<span class="line-modified">708     return fType;</span>
709 }
710 
711 RegionNameEnumeration::RegionNameEnumeration(UVector *fNameList, UErrorCode&amp; status) {
712     pos=0;
713     if (fNameList &amp;&amp; U_SUCCESS(status)) {
714         fRegionNames = new UVector(uprv_deleteUObject, uhash_compareUnicodeString, fNameList-&gt;size(),status);
715         for ( int32_t i = 0 ; i &lt; fNameList-&gt;size() ; i++ ) {
716             UnicodeString* this_region_name = (UnicodeString *)fNameList-&gt;elementAt(i);
717             UnicodeString* new_region_name = new UnicodeString(*this_region_name);
718             fRegionNames-&gt;addElement((void *)new_region_name,status);
719         }
720     }
721     else {
722         fRegionNames = NULL;
723     }
724 }
725 
726 const UnicodeString*
727 RegionNameEnumeration::snext(UErrorCode&amp; status) {
728   if (U_FAILURE(status) || (fRegionNames==NULL)) {
</pre>
</td>
</tr>
</table>
<center><a href="regexcst.txt.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="reldatefmt.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>