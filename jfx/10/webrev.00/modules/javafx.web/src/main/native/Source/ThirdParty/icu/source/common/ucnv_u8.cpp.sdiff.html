<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/ucnv_u8.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ucnv_u32.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ucnvhz.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/ucnv_u8.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 39 /* Keep these here to make finicky compilers happy */
 40 
 41 U_CFUNC void ucnv_fromUnicode_UTF8(UConverterFromUnicodeArgs *args,
 42                                            UErrorCode *err);
 43 U_CFUNC void ucnv_fromUnicode_UTF8_OFFSETS_LOGIC(UConverterFromUnicodeArgs *args,
 44                                                         UErrorCode *err);
 45 
 46 
 47 /* UTF-8 -------------------------------------------------------------------- */
 48 
 49 #define MAXIMUM_UCS2            0x0000FFFF
 50 
 51 static const uint32_t offsetsFromUTF8[5] = {0,
 52   (uint32_t) 0x00000000, (uint32_t) 0x00003080, (uint32_t) 0x000E2080,
 53   (uint32_t) 0x03C82080
 54 };
 55 
 56 static UBool hasCESU8Data(const UConverter *cnv)
 57 {
 58 #if UCONFIG_ONLY_HTML_CONVERSION
<span class="line-removed"> 59     (void) (cnv);</span>
 60     return FALSE;
 61 #else
 62     return (UBool)(cnv-&gt;sharedData == &amp;_CESU8Data);
 63 #endif
 64 }
 65 U_CDECL_BEGIN
 66 static void  U_CALLCONV ucnv_toUnicode_UTF8 (UConverterToUnicodeArgs * args,
 67                                   UErrorCode * err)
 68 {
 69     UConverter *cnv = args-&gt;converter;
 70     const unsigned char *mySource = (unsigned char *) args-&gt;source;
 71     UChar *myTarget = args-&gt;target;
 72     const unsigned char *sourceLimit = (unsigned char *) args-&gt;sourceLimit;
 73     const UChar *targetLimit = args-&gt;targetLimit;
 74     unsigned char *toUBytes = cnv-&gt;toUBytes;
 75     UBool isCESU8 = hasCESU8Data(cnv);
 76     uint32_t ch, ch2 = 0;
 77     int32_t i, inBytes;
 78 
 79     /* Restore size of current sequence */
</pre>
<hr />
<pre>
 92     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit)
 93     {
 94         ch = *(mySource++);
 95         if (U8_IS_SINGLE(ch))        /* Simple case */
 96         {
 97             *(myTarget++) = (UChar) ch;
 98         }
 99         else
100         {
101             /* store the first char */
102             toUBytes[0] = (char)ch;
103             inBytes = U8_COUNT_BYTES_NON_ASCII(ch); /* lookup current sequence length */
104             i = 1;
105 
106 morebytes:
107             while (i &lt; inBytes)
108             {
109                 if (mySource &lt; sourceLimit)
110                 {
111                     toUBytes[i] = (char) (ch2 = *mySource);
<span class="line-modified">112                     if (!icu::UTF8::isValidTrail(ch, ch2, i, inBytes) &amp;&amp;</span>
113                             !(isCESU8 &amp;&amp; i == 1 &amp;&amp; ch == 0xed &amp;&amp; U8_IS_TRAIL(ch2)))
114                     {
115                         break; /* i &lt; inBytes */
116                     }
117                     ch = (ch &lt;&lt; 6) + ch2;
118                     ++mySource;
119                     i++;
120                 }
121                 else
122                 {
123                     /* stores a partially calculated target*/
124                     cnv-&gt;toUnicodeStatus = ch;
125                     cnv-&gt;mode = inBytes;
126                     cnv-&gt;toULength = (int8_t) i;
127                     goto donefornow;
128                 }
129             }
130 
131             // In CESU-8, only surrogates, not supplementary code points, are encoded directly.
132             if (i == inBytes &amp;&amp; (!isCESU8 || i &lt;= 3))
</pre>
<hr />
<pre>
209     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit)
210     {
211         ch = *(mySource++);
212         if (U8_IS_SINGLE(ch))        /* Simple case */
213         {
214             *(myTarget++) = (UChar) ch;
215             *(myOffsets++) = offsetNum++;
216         }
217         else
218         {
219             toUBytes[0] = (char)ch;
220             inBytes = U8_COUNT_BYTES_NON_ASCII(ch);
221             i = 1;
222 
223 morebytes:
224             while (i &lt; inBytes)
225             {
226                 if (mySource &lt; sourceLimit)
227                 {
228                     toUBytes[i] = (char) (ch2 = *mySource);
<span class="line-modified">229                     if (!icu::UTF8::isValidTrail(ch, ch2, i, inBytes) &amp;&amp;</span>
230                             !(isCESU8 &amp;&amp; i == 1 &amp;&amp; ch == 0xed &amp;&amp; U8_IS_TRAIL(ch2)))
231                     {
232                         break; /* i &lt; inBytes */
233                     }
234                     ch = (ch &lt;&lt; 6) + ch2;
235                     ++mySource;
236                     i++;
237                 }
238                 else
239                 {
240                     cnv-&gt;toUnicodeStatus = ch;
241                     cnv-&gt;mode = inBytes;
242                     cnv-&gt;toULength = (int8_t)i;
243                     goto donefornow;
244                 }
245             }
246 
247             // In CESU-8, only surrogates, not supplementary code points, are encoded directly.
248             if (i == inBytes &amp;&amp; (!isCESU8 || i &lt;= 3))
249             {
</pre>
</td>
<td>
<hr />
<pre>
 39 /* Keep these here to make finicky compilers happy */
 40 
 41 U_CFUNC void ucnv_fromUnicode_UTF8(UConverterFromUnicodeArgs *args,
 42                                            UErrorCode *err);
 43 U_CFUNC void ucnv_fromUnicode_UTF8_OFFSETS_LOGIC(UConverterFromUnicodeArgs *args,
 44                                                         UErrorCode *err);
 45 
 46 
 47 /* UTF-8 -------------------------------------------------------------------- */
 48 
 49 #define MAXIMUM_UCS2            0x0000FFFF
 50 
 51 static const uint32_t offsetsFromUTF8[5] = {0,
 52   (uint32_t) 0x00000000, (uint32_t) 0x00003080, (uint32_t) 0x000E2080,
 53   (uint32_t) 0x03C82080
 54 };
 55 
 56 static UBool hasCESU8Data(const UConverter *cnv)
 57 {
 58 #if UCONFIG_ONLY_HTML_CONVERSION

 59     return FALSE;
 60 #else
 61     return (UBool)(cnv-&gt;sharedData == &amp;_CESU8Data);
 62 #endif
 63 }
 64 U_CDECL_BEGIN
 65 static void  U_CALLCONV ucnv_toUnicode_UTF8 (UConverterToUnicodeArgs * args,
 66                                   UErrorCode * err)
 67 {
 68     UConverter *cnv = args-&gt;converter;
 69     const unsigned char *mySource = (unsigned char *) args-&gt;source;
 70     UChar *myTarget = args-&gt;target;
 71     const unsigned char *sourceLimit = (unsigned char *) args-&gt;sourceLimit;
 72     const UChar *targetLimit = args-&gt;targetLimit;
 73     unsigned char *toUBytes = cnv-&gt;toUBytes;
 74     UBool isCESU8 = hasCESU8Data(cnv);
 75     uint32_t ch, ch2 = 0;
 76     int32_t i, inBytes;
 77 
 78     /* Restore size of current sequence */
</pre>
<hr />
<pre>
 91     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit)
 92     {
 93         ch = *(mySource++);
 94         if (U8_IS_SINGLE(ch))        /* Simple case */
 95         {
 96             *(myTarget++) = (UChar) ch;
 97         }
 98         else
 99         {
100             /* store the first char */
101             toUBytes[0] = (char)ch;
102             inBytes = U8_COUNT_BYTES_NON_ASCII(ch); /* lookup current sequence length */
103             i = 1;
104 
105 morebytes:
106             while (i &lt; inBytes)
107             {
108                 if (mySource &lt; sourceLimit)
109                 {
110                     toUBytes[i] = (char) (ch2 = *mySource);
<span class="line-modified">111                     if (!icu::UTF8::isValidTrail(ch, static_cast&lt;uint8_t&gt;(ch2), i, inBytes) &amp;&amp;</span>
112                             !(isCESU8 &amp;&amp; i == 1 &amp;&amp; ch == 0xed &amp;&amp; U8_IS_TRAIL(ch2)))
113                     {
114                         break; /* i &lt; inBytes */
115                     }
116                     ch = (ch &lt;&lt; 6) + ch2;
117                     ++mySource;
118                     i++;
119                 }
120                 else
121                 {
122                     /* stores a partially calculated target*/
123                     cnv-&gt;toUnicodeStatus = ch;
124                     cnv-&gt;mode = inBytes;
125                     cnv-&gt;toULength = (int8_t) i;
126                     goto donefornow;
127                 }
128             }
129 
130             // In CESU-8, only surrogates, not supplementary code points, are encoded directly.
131             if (i == inBytes &amp;&amp; (!isCESU8 || i &lt;= 3))
</pre>
<hr />
<pre>
208     while (mySource &lt; sourceLimit &amp;&amp; myTarget &lt; targetLimit)
209     {
210         ch = *(mySource++);
211         if (U8_IS_SINGLE(ch))        /* Simple case */
212         {
213             *(myTarget++) = (UChar) ch;
214             *(myOffsets++) = offsetNum++;
215         }
216         else
217         {
218             toUBytes[0] = (char)ch;
219             inBytes = U8_COUNT_BYTES_NON_ASCII(ch);
220             i = 1;
221 
222 morebytes:
223             while (i &lt; inBytes)
224             {
225                 if (mySource &lt; sourceLimit)
226                 {
227                     toUBytes[i] = (char) (ch2 = *mySource);
<span class="line-modified">228                     if (!icu::UTF8::isValidTrail(ch, static_cast&lt;uint8_t&gt;(ch2), i, inBytes) &amp;&amp;</span>
229                             !(isCESU8 &amp;&amp; i == 1 &amp;&amp; ch == 0xed &amp;&amp; U8_IS_TRAIL(ch2)))
230                     {
231                         break; /* i &lt; inBytes */
232                     }
233                     ch = (ch &lt;&lt; 6) + ch2;
234                     ++mySource;
235                     i++;
236                 }
237                 else
238                 {
239                     cnv-&gt;toUnicodeStatus = ch;
240                     cnv-&gt;mode = inBytes;
241                     cnv-&gt;toULength = (int8_t)i;
242                     goto donefornow;
243                 }
244             }
245 
246             // In CESU-8, only surrogates, not supplementary code points, are encoded directly.
247             if (i == inBytes &amp;&amp; (!isCESU8 || i &lt;= 3))
248             {
</pre>
</td>
</tr>
</table>
<center><a href="ucnv_u32.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ucnvhz.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>