<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/gender.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 *******************************************************************************
  5 * Copyright (C) 2008-2013, International Business Machines Corporation and
  6 * others. All Rights Reserved.
  7 *******************************************************************************
  8 *
  9 *
 10 * File GENDER.CPP
 11 *
 12 * Modification History:*
 13 *   Date        Name        Description
 14 *
 15 ********************************************************************************
 16 */
 17 
 18 #include &quot;unicode/utypes.h&quot;
 19 
 20 #if !UCONFIG_NO_FORMATTING
 21 
 22 #include &quot;unicode/gender.h&quot;
 23 #include &quot;unicode/ugender.h&quot;
 24 #include &quot;unicode/ures.h&quot;
 25 
 26 #include &quot;cmemory.h&quot;
 27 #include &quot;cstring.h&quot;
 28 #include &quot;mutex.h&quot;
 29 #include &quot;uassert.h&quot;
 30 #include &quot;ucln_in.h&quot;
 31 #include &quot;umutex.h&quot;
 32 #include &quot;uhash.h&quot;
 33 
 34 static UHashtable* gGenderInfoCache = NULL;
<a name="1" id="anc1"></a><span class="line-modified"> 35 static UMutex gGenderMetaLock = U_MUTEX_INITIALIZER;</span>
 36 static const char* gNeutralStr = &quot;neutral&quot;;
 37 static const char* gMailTaintsStr = &quot;maleTaints&quot;;
 38 static const char* gMixedNeutralStr = &quot;mixedNeutral&quot;;
 39 static icu::GenderInfo* gObjs = NULL;
 40 static icu::UInitOnce gGenderInitOnce = U_INITONCE_INITIALIZER;
 41 
 42 enum GenderStyle {
 43   NEUTRAL,
 44   MIXED_NEUTRAL,
 45   MALE_TAINTS,
 46   GENDER_STYLE_LENGTH
 47 };
 48 
 49 U_CDECL_BEGIN
 50 
 51 static UBool U_CALLCONV gender_cleanup(void) {
 52   if (gGenderInfoCache != NULL) {
 53     uhash_close(gGenderInfoCache);
 54     gGenderInfoCache = NULL;
 55     delete [] gObjs;
 56   }
 57   gGenderInitOnce.reset();
 58   return TRUE;
 59 }
 60 
 61 U_CDECL_END
 62 
 63 U_NAMESPACE_BEGIN
 64 
 65 void U_CALLCONV GenderInfo_initCache(UErrorCode &amp;status) {
 66   ucln_i18n_registerCleanup(UCLN_I18N_GENDERINFO, gender_cleanup);
 67   U_ASSERT(gGenderInfoCache == NULL);
 68   if (U_FAILURE(status)) {
 69       return;
 70   }
 71   gObjs = new GenderInfo[GENDER_STYLE_LENGTH];
 72   if (gObjs == NULL) {
 73     status = U_MEMORY_ALLOCATION_ERROR;
 74     return;
 75   }
 76   for (int i = 0; i &lt; GENDER_STYLE_LENGTH; i++) {
 77     gObjs[i]._style = i;
 78   }
 79   gGenderInfoCache = uhash_open(uhash_hashChars, uhash_compareChars, NULL, &amp;status);
 80   if (U_FAILURE(status)) {
 81     delete [] gObjs;
 82     return;
 83   }
 84   uhash_setKeyDeleter(gGenderInfoCache, uprv_free);
 85 }
 86 
 87 
 88 GenderInfo::GenderInfo() {
 89 }
 90 
 91 GenderInfo::~GenderInfo() {
 92 }
 93 
 94 const GenderInfo* GenderInfo::getInstance(const Locale&amp; locale, UErrorCode&amp; status) {
 95   // Make sure our cache exists.
 96   umtx_initOnce(gGenderInitOnce, &amp;GenderInfo_initCache, status);
 97   if (U_FAILURE(status)) {
 98     return NULL;
 99   }
100 
<a name="2" id="anc2"></a>
101   const GenderInfo* result = NULL;
102   const char* key = locale.getName();
103   {
104     Mutex lock(&amp;gGenderMetaLock);
105     result = (const GenderInfo*) uhash_get(gGenderInfoCache, key);
106   }
107   if (result) {
108     return result;
109   }
110 
111   // On cache miss, try to create GenderInfo from CLDR data
112   result = loadInstance(locale, status);
113   if (U_FAILURE(status)) {
114     return NULL;
115   }
116 
117   // Try to put our GenderInfo object in cache. If there is a race condition,
118   // favor the GenderInfo object that is already in the cache.
119   {
120     Mutex lock(&amp;gGenderMetaLock);
121     GenderInfo* temp = (GenderInfo*) uhash_get(gGenderInfoCache, key);
122     if (temp) {
123       result = temp;
124     } else {
125       uhash_put(gGenderInfoCache, uprv_strdup(key), (void*) result, &amp;status);
126       if (U_FAILURE(status)) {
127         return NULL;
128       }
129     }
130   }
131   return result;
132 }
133 
134 const GenderInfo* GenderInfo::loadInstance(const Locale&amp; locale, UErrorCode&amp; status) {
135   LocalUResourceBundlePointer rb(
136       ures_openDirect(NULL, &quot;genderList&quot;, &amp;status));
137   if (U_FAILURE(status)) {
138     return NULL;
139   }
140   LocalUResourceBundlePointer locRes(ures_getByKey(rb.getAlias(), &quot;genderList&quot;, NULL, &amp;status));
141   if (U_FAILURE(status)) {
142     return NULL;
143   }
144   int32_t resLen = 0;
145   const char* curLocaleName = locale.getName();
146   UErrorCode key_status = U_ZERO_ERROR;
147   const UChar* s = ures_getStringByKey(locRes.getAlias(), curLocaleName, &amp;resLen, &amp;key_status);
148   if (s == NULL) {
149     key_status = U_ZERO_ERROR;
150     char parentLocaleName[ULOC_FULLNAME_CAPACITY];
151     uprv_strcpy(parentLocaleName, curLocaleName);
152     while (s == NULL &amp;&amp; uloc_getParent(parentLocaleName, parentLocaleName, ULOC_FULLNAME_CAPACITY, &amp;key_status) &gt; 0) {
153       key_status = U_ZERO_ERROR;
154       resLen = 0;
155       s = ures_getStringByKey(locRes.getAlias(), parentLocaleName, &amp;resLen, &amp;key_status);
156       key_status = U_ZERO_ERROR;
157     }
158   }
159   if (s == NULL) {
160     return &amp;gObjs[NEUTRAL];
161   }
162   char type_str[256];
163   u_UCharsToChars(s, type_str, resLen + 1);
164   if (uprv_strcmp(type_str, gNeutralStr) == 0) {
165     return &amp;gObjs[NEUTRAL];
166   }
167   if (uprv_strcmp(type_str, gMixedNeutralStr) == 0) {
168     return &amp;gObjs[MIXED_NEUTRAL];
169   }
170   if (uprv_strcmp(type_str, gMailTaintsStr) == 0) {
171     return &amp;gObjs[MALE_TAINTS];
172   }
173   return &amp;gObjs[NEUTRAL];
174 }
175 
176 UGender GenderInfo::getListGender(const UGender* genders, int32_t length, UErrorCode&amp; status) const {
177   if (U_FAILURE(status)) {
178     return UGENDER_OTHER;
179   }
180   if (length == 0) {
181     return UGENDER_OTHER;
182   }
183   if (length == 1) {
184     return genders[0];
185   }
186   UBool has_female = FALSE;
187   UBool has_male = FALSE;
188   switch (_style) {
189     case NEUTRAL:
190       return UGENDER_OTHER;
191     case MIXED_NEUTRAL:
192       for (int32_t i = 0; i &lt; length; ++i) {
193         switch (genders[i]) {
194           case UGENDER_OTHER:
195             return UGENDER_OTHER;
196             break;
197           case UGENDER_FEMALE:
198             if (has_male) {
199               return UGENDER_OTHER;
200             }
201             has_female = TRUE;
202             break;
203           case UGENDER_MALE:
204             if (has_female) {
205               return UGENDER_OTHER;
206             }
207             has_male = TRUE;
208             break;
209           default:
210             break;
211         }
212       }
213       return has_male ? UGENDER_MALE : UGENDER_FEMALE;
214       break;
215     case MALE_TAINTS:
216       for (int32_t i = 0; i &lt; length; ++i) {
217         if (genders[i] != UGENDER_FEMALE) {
218           return UGENDER_MALE;
219         }
220       }
221       return UGENDER_FEMALE;
222       break;
223     default:
224       return UGENDER_OTHER;
225       break;
226   }
227 }
228 
229 const GenderInfo* GenderInfo::getNeutralInstance() {
230   return &amp;gObjs[NEUTRAL];
231 }
232 
233 const GenderInfo* GenderInfo::getMixedNeutralInstance() {
234   return &amp;gObjs[MIXED_NEUTRAL];
235 }
236 
237 const GenderInfo* GenderInfo::getMaleTaintsInstance() {
238   return &amp;gObjs[MALE_TAINTS];
239 }
240 
241 U_NAMESPACE_END
242 
243 U_CAPI const UGenderInfo* U_EXPORT2
244 ugender_getInstance(const char* locale, UErrorCode* status) {
245   return (const UGenderInfo*) icu::GenderInfo::getInstance(locale, *status);
246 }
247 
248 U_CAPI UGender U_EXPORT2
249 ugender_getListGender(const UGenderInfo* genderInfo, const UGender* genders, int32_t size, UErrorCode* status) {
250   return ((const icu::GenderInfo *)genderInfo)-&gt;getListGender(genders, size, *status);
251 }
252 
253 #endif /* #if !UCONFIG_NO_FORMATTING */
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>