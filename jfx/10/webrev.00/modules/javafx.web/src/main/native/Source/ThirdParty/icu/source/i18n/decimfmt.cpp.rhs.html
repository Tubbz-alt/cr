<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/decimfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2018 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 
   4 #include &quot;unicode/utypes.h&quot;
   5 
   6 #if !UCONFIG_NO_FORMATTING
   7 
   8 // Allow implicit conversion from char16_t* to UnicodeString for this file:
   9 // Helpful in toString methods and elsewhere.
  10 #define UNISTR_FROM_STRING_EXPLICIT
  11 
  12 #include &lt;cmath&gt;
  13 #include &lt;cstdlib&gt;
  14 #include &lt;stdlib.h&gt;
  15 #include &quot;unicode/errorcode.h&quot;
  16 #include &quot;unicode/decimfmt.h&quot;
  17 #include &quot;number_decimalquantity.h&quot;
  18 #include &quot;number_types.h&quot;
  19 #include &quot;numparse_impl.h&quot;
  20 #include &quot;number_mapper.h&quot;
  21 #include &quot;number_patternstring.h&quot;
  22 #include &quot;putilimp.h&quot;
  23 #include &quot;number_utils.h&quot;
  24 #include &quot;number_utypes.h&quot;
  25 
  26 using namespace icu;
  27 using namespace icu::number;
  28 using namespace icu::number::impl;
  29 using namespace icu::numparse;
  30 using namespace icu::numparse::impl;
  31 using ERoundingMode = icu::DecimalFormat::ERoundingMode;
  32 using EPadPosition = icu::DecimalFormat::EPadPosition;
  33 
<a name="1" id="anc1"></a><span class="line-modified">  34 // MSVC VS2015 warns C4805 when comparing bool with UBool, VS2017 no longer emits this warning.</span>
  35 // TODO: Move this macro into a better place?
  36 #if U_PF_WINDOWS &lt;= U_PLATFORM &amp;&amp; U_PLATFORM &lt;= U_PF_CYGWIN
  37 #define UBOOL_TO_BOOL(b) static_cast&lt;bool&gt;(b)
  38 #else
  39 #define UBOOL_TO_BOOL(b) b
  40 #endif
  41 
  42 
  43 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DecimalFormat)
  44 
  45 
  46 DecimalFormat::DecimalFormat(UErrorCode&amp; status)
  47         : DecimalFormat(nullptr, status) {
<a name="2" id="anc2"></a><span class="line-added">  48     if (U_FAILURE(status)) { return; }</span>
  49     // Use the default locale and decimal pattern.
  50     const char* localeName = Locale::getDefault().getName();
  51     LocalPointer&lt;NumberingSystem&gt; ns(NumberingSystem::createInstance(status));
  52     UnicodeString patternString = utils::getPatternForStyle(
  53             localeName,
  54             ns-&gt;getName(),
  55             CLDR_PATTERN_STYLE_DECIMAL,
  56             status);
  57     setPropertiesFromPattern(patternString, IGNORE_ROUNDING_IF_CURRENCY, status);
  58     touch(status);
  59 }
  60 
  61 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, UErrorCode&amp; status)
  62         : DecimalFormat(nullptr, status) {
<a name="3" id="anc3"></a><span class="line-added">  63     if (U_FAILURE(status)) { return; }</span>
  64     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
  65     touch(status);
  66 }
  67 
  68 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
  69                              UErrorCode&amp; status)
  70         : DecimalFormat(symbolsToAdopt, status) {
<a name="4" id="anc4"></a><span class="line-added">  71     if (U_FAILURE(status)) { return; }</span>
  72     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
  73     touch(status);
  74 }
  75 
  76 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
  77                              UNumberFormatStyle style, UErrorCode&amp; status)
  78         : DecimalFormat(symbolsToAdopt, status) {
<a name="5" id="anc5"></a><span class="line-added">  79     if (U_FAILURE(status)) { return; }</span>
  80     // If choice is a currency type, ignore the rounding information.
<a name="6" id="anc6"></a><span class="line-modified">  81     if (style == UNumberFormatStyle::UNUM_CURRENCY ||</span>
<span class="line-added">  82         style == UNumberFormatStyle::UNUM_CURRENCY_ISO ||</span>
  83         style == UNumberFormatStyle::UNUM_CURRENCY_ACCOUNTING ||
  84         style == UNumberFormatStyle::UNUM_CASH_CURRENCY ||
  85         style == UNumberFormatStyle::UNUM_CURRENCY_STANDARD ||
  86         style == UNumberFormatStyle::UNUM_CURRENCY_PLURAL) {
  87         setPropertiesFromPattern(pattern, IGNORE_ROUNDING_ALWAYS, status);
  88     } else {
  89         setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
  90     }
  91     // Note: in Java, CurrencyPluralInfo is set in NumberFormat.java, but in C++, it is not set there,
  92     // so we have to set it here.
  93     if (style == UNumberFormatStyle::UNUM_CURRENCY_PLURAL) {
  94         LocalPointer&lt;CurrencyPluralInfo&gt; cpi(
  95                 new CurrencyPluralInfo(fields-&gt;symbols-&gt;getLocale(), status),
  96                 status);
  97         if (U_FAILURE(status)) { return; }
  98         fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(cpi.orphan());
  99     }
 100     touch(status);
 101 }
 102 
 103 DecimalFormat::DecimalFormat(const DecimalFormatSymbols* symbolsToAdopt, UErrorCode&amp; status) {
<a name="7" id="anc7"></a><span class="line-added"> 104     // we must take ownership of symbolsToAdopt, even in a failure case.</span>
 105     LocalPointer&lt;const DecimalFormatSymbols&gt; adoptedSymbols(symbolsToAdopt);
<a name="8" id="anc8"></a>
 106     if (U_FAILURE(status)) {
 107         return;
 108     }
<a name="9" id="anc9"></a><span class="line-added"> 109     fields = new DecimalFormatFields();</span>
 110     if (fields == nullptr) {
 111         status = U_MEMORY_ALLOCATION_ERROR;
 112         return;
 113     }
<a name="10" id="anc10"></a><span class="line-added"> 114     fields-&gt;formatter.adoptInsteadAndCheckErrorCode(new LocalizedNumberFormatter(), status);</span>
 115     fields-&gt;properties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);
 116     fields-&gt;exportedProperties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);
 117     if (adoptedSymbols.isNull()) {
 118         fields-&gt;symbols.adoptInsteadAndCheckErrorCode(new DecimalFormatSymbols(status), status);
 119     } else {
 120         fields-&gt;symbols.adoptInsteadAndCheckErrorCode(adoptedSymbols.orphan(), status);
 121     }
<a name="11" id="anc11"></a><span class="line-added"> 122     // In order to simplify error handling logic in the various getters/setters/etc, we do not allow</span>
<span class="line-added"> 123     // any partially populated DecimalFormatFields object. We must have a fully complete fields object</span>
<span class="line-added"> 124     // or else we set it to nullptr.</span>
<span class="line-added"> 125     if (fields-&gt;formatter.isNull() || fields-&gt;properties.isNull() || fields-&gt;exportedProperties.isNull() || fields-&gt;symbols.isNull()) {</span>
<span class="line-added"> 126         delete fields;</span>
<span class="line-added"> 127         fields = nullptr;</span>
<span class="line-added"> 128         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 129     }</span>
 130 }
 131 
 132 #if UCONFIG_HAVE_PARSEALLINPUT
 133 
 134 void DecimalFormat::setParseAllInput(UNumberFormatAttributeValue value) {
<a name="12" id="anc12"></a><span class="line-added"> 135     if (fields == nullptr) { return; }</span>
 136     if (value == fields-&gt;properties-&gt;parseAllInput) { return; }
 137     fields-&gt;properties-&gt;parseAllInput = value;
 138 }
 139 
 140 #endif
 141 
 142 DecimalFormat&amp;
 143 DecimalFormat::setAttribute(UNumberFormatAttribute attr, int32_t newValue, UErrorCode&amp; status) {
 144     if (U_FAILURE(status)) { return *this; }
 145 
<a name="13" id="anc13"></a><span class="line-added"> 146     if (fields == nullptr) {</span>
<span class="line-added"> 147         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 148         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 149         return *this;</span>
<span class="line-added"> 150     }</span>
<span class="line-added"> 151 </span>
 152     switch (attr) {
 153         case UNUM_LENIENT_PARSE:
 154             setLenient(newValue != 0);
 155             break;
 156 
 157         case UNUM_PARSE_INT_ONLY:
 158             setParseIntegerOnly(newValue != 0);
 159             break;
 160 
 161         case UNUM_GROUPING_USED:
 162             setGroupingUsed(newValue != 0);
 163             break;
 164 
 165         case UNUM_DECIMAL_ALWAYS_SHOWN:
 166             setDecimalSeparatorAlwaysShown(newValue != 0);
 167             break;
 168 
 169         case UNUM_MAX_INTEGER_DIGITS:
 170             setMaximumIntegerDigits(newValue);
 171             break;
 172 
 173         case UNUM_MIN_INTEGER_DIGITS:
 174             setMinimumIntegerDigits(newValue);
 175             break;
 176 
 177         case UNUM_INTEGER_DIGITS:
 178             setMinimumIntegerDigits(newValue);
 179             setMaximumIntegerDigits(newValue);
 180             break;
 181 
 182         case UNUM_MAX_FRACTION_DIGITS:
 183             setMaximumFractionDigits(newValue);
 184             break;
 185 
 186         case UNUM_MIN_FRACTION_DIGITS:
 187             setMinimumFractionDigits(newValue);
 188             break;
 189 
 190         case UNUM_FRACTION_DIGITS:
 191             setMinimumFractionDigits(newValue);
 192             setMaximumFractionDigits(newValue);
 193             break;
 194 
 195         case UNUM_SIGNIFICANT_DIGITS_USED:
 196             setSignificantDigitsUsed(newValue != 0);
 197             break;
 198 
 199         case UNUM_MAX_SIGNIFICANT_DIGITS:
 200             setMaximumSignificantDigits(newValue);
 201             break;
 202 
 203         case UNUM_MIN_SIGNIFICANT_DIGITS:
 204             setMinimumSignificantDigits(newValue);
 205             break;
 206 
 207         case UNUM_MULTIPLIER:
 208             setMultiplier(newValue);
 209             break;
 210 
 211         case UNUM_SCALE:
 212             setMultiplierScale(newValue);
 213             break;
 214 
 215         case UNUM_GROUPING_SIZE:
 216             setGroupingSize(newValue);
 217             break;
 218 
 219         case UNUM_ROUNDING_MODE:
 220             setRoundingMode((DecimalFormat::ERoundingMode) newValue);
 221             break;
 222 
 223         case UNUM_FORMAT_WIDTH:
 224             setFormatWidth(newValue);
 225             break;
 226 
 227         case UNUM_PADDING_POSITION:
 228             /** The position at which padding will take place. */
 229             setPadPosition((DecimalFormat::EPadPosition) newValue);
 230             break;
 231 
 232         case UNUM_SECONDARY_GROUPING_SIZE:
 233             setSecondaryGroupingSize(newValue);
 234             break;
 235 
 236 #if UCONFIG_HAVE_PARSEALLINPUT
 237         case UNUM_PARSE_ALL_INPUT:
 238             setParseAllInput((UNumberFormatAttributeValue) newValue);
 239             break;
 240 #endif
 241 
 242         case UNUM_PARSE_NO_EXPONENT:
 243             setParseNoExponent((UBool) newValue);
 244             break;
 245 
 246         case UNUM_PARSE_DECIMAL_MARK_REQUIRED:
 247             setDecimalPatternMatchRequired((UBool) newValue);
 248             break;
 249 
 250         case UNUM_CURRENCY_USAGE:
 251             setCurrencyUsage((UCurrencyUsage) newValue, &amp;status);
 252             break;
 253 
 254         case UNUM_MINIMUM_GROUPING_DIGITS:
 255             setMinimumGroupingDigits(newValue);
 256             break;
 257 
 258         case UNUM_PARSE_CASE_SENSITIVE:
 259             setParseCaseSensitive(static_cast&lt;UBool&gt;(newValue));
 260             break;
 261 
 262         case UNUM_SIGN_ALWAYS_SHOWN:
 263             setSignAlwaysShown(static_cast&lt;UBool&gt;(newValue));
 264             break;
 265 
 266         case UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS:
 267             setFormatFailIfMoreThanMaxDigits(static_cast&lt;UBool&gt;(newValue));
 268             break;
 269 
 270         default:
 271             status = U_UNSUPPORTED_ERROR;
 272             break;
 273     }
 274     return *this;
 275 }
 276 
 277 int32_t DecimalFormat::getAttribute(UNumberFormatAttribute attr, UErrorCode&amp; status) const {
 278     if (U_FAILURE(status)) { return -1; }
<a name="14" id="anc14"></a><span class="line-added"> 279 </span>
<span class="line-added"> 280     if (fields == nullptr) {</span>
<span class="line-added"> 281         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 282         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 283         return -1;</span>
<span class="line-added"> 284     }</span>
<span class="line-added"> 285 </span>
 286     switch (attr) {
 287         case UNUM_LENIENT_PARSE:
 288             return isLenient();
 289 
 290         case UNUM_PARSE_INT_ONLY:
 291             return isParseIntegerOnly();
 292 
 293         case UNUM_GROUPING_USED:
 294             return isGroupingUsed();
 295 
 296         case UNUM_DECIMAL_ALWAYS_SHOWN:
 297             return isDecimalSeparatorAlwaysShown();
 298 
 299         case UNUM_MAX_INTEGER_DIGITS:
 300             return getMaximumIntegerDigits();
 301 
 302         case UNUM_MIN_INTEGER_DIGITS:
 303             return getMinimumIntegerDigits();
 304 
 305         case UNUM_INTEGER_DIGITS:
 306             // TBD: what should this return?
 307             return getMinimumIntegerDigits();
 308 
 309         case UNUM_MAX_FRACTION_DIGITS:
 310             return getMaximumFractionDigits();
 311 
 312         case UNUM_MIN_FRACTION_DIGITS:
 313             return getMinimumFractionDigits();
 314 
 315         case UNUM_FRACTION_DIGITS:
 316             // TBD: what should this return?
 317             return getMinimumFractionDigits();
 318 
 319         case UNUM_SIGNIFICANT_DIGITS_USED:
 320             return areSignificantDigitsUsed();
 321 
 322         case UNUM_MAX_SIGNIFICANT_DIGITS:
 323             return getMaximumSignificantDigits();
 324 
 325         case UNUM_MIN_SIGNIFICANT_DIGITS:
 326             return getMinimumSignificantDigits();
 327 
 328         case UNUM_MULTIPLIER:
 329             return getMultiplier();
 330 
 331         case UNUM_SCALE:
 332             return getMultiplierScale();
 333 
 334         case UNUM_GROUPING_SIZE:
 335             return getGroupingSize();
 336 
 337         case UNUM_ROUNDING_MODE:
 338             return getRoundingMode();
 339 
 340         case UNUM_FORMAT_WIDTH:
 341             return getFormatWidth();
 342 
 343         case UNUM_PADDING_POSITION:
 344             return getPadPosition();
 345 
 346         case UNUM_SECONDARY_GROUPING_SIZE:
 347             return getSecondaryGroupingSize();
 348 
 349         case UNUM_PARSE_NO_EXPONENT:
 350             return isParseNoExponent();
 351 
 352         case UNUM_PARSE_DECIMAL_MARK_REQUIRED:
 353             return isDecimalPatternMatchRequired();
 354 
 355         case UNUM_CURRENCY_USAGE:
 356             return getCurrencyUsage();
 357 
 358         case UNUM_MINIMUM_GROUPING_DIGITS:
 359             return getMinimumGroupingDigits();
 360 
 361         case UNUM_PARSE_CASE_SENSITIVE:
 362             return isParseCaseSensitive();
 363 
 364         case UNUM_SIGN_ALWAYS_SHOWN:
 365             return isSignAlwaysShown();
 366 
 367         case UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS:
 368             return isFormatFailIfMoreThanMaxDigits();
 369 
 370         default:
 371             status = U_UNSUPPORTED_ERROR;
 372             break;
 373     }
 374 
 375     return -1; /* undefined */
 376 }
 377 
 378 void DecimalFormat::setGroupingUsed(UBool enabled) {
<a name="15" id="anc15"></a><span class="line-added"> 379     if (fields == nullptr) {</span>
<span class="line-added"> 380         return;</span>
<span class="line-added"> 381     }</span>
 382     if (UBOOL_TO_BOOL(enabled) == fields-&gt;properties-&gt;groupingUsed) { return; }
 383     NumberFormat::setGroupingUsed(enabled); // to set field for compatibility
 384     fields-&gt;properties-&gt;groupingUsed = enabled;
 385     touchNoError();
 386 }
 387 
 388 void DecimalFormat::setParseIntegerOnly(UBool value) {
<a name="16" id="anc16"></a><span class="line-added"> 389     if (fields == nullptr) {</span>
<span class="line-added"> 390         return;</span>
<span class="line-added"> 391     }</span>
 392     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseIntegerOnly) { return; }
 393     NumberFormat::setParseIntegerOnly(value); // to set field for compatibility
 394     fields-&gt;properties-&gt;parseIntegerOnly = value;
 395     touchNoError();
 396 }
 397 
 398 void DecimalFormat::setLenient(UBool enable) {
<a name="17" id="anc17"></a><span class="line-added"> 399     if (fields == nullptr) {</span>
<span class="line-added"> 400         return;</span>
<span class="line-added"> 401     }</span>
 402     ParseMode mode = enable ? PARSE_MODE_LENIENT : PARSE_MODE_STRICT;
 403     if (!fields-&gt;properties-&gt;parseMode.isNull() &amp;&amp; mode == fields-&gt;properties-&gt;parseMode.getNoError()) { return; }
 404     NumberFormat::setLenient(enable); // to set field for compatibility
 405     fields-&gt;properties-&gt;parseMode = mode;
 406     touchNoError();
 407 }
 408 
 409 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, DecimalFormatSymbols* symbolsToAdopt,
 410                              UParseError&amp;, UErrorCode&amp; status)
 411         : DecimalFormat(symbolsToAdopt, status) {
<a name="18" id="anc18"></a><span class="line-added"> 412     if (U_FAILURE(status)) { return; }</span>
 413     // TODO: What is parseError for?
 414     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
 415     touch(status);
 416 }
 417 
 418 DecimalFormat::DecimalFormat(const UnicodeString&amp; pattern, const DecimalFormatSymbols&amp; symbols,
 419                              UErrorCode&amp; status)
<a name="19" id="anc19"></a><span class="line-modified"> 420         : DecimalFormat(nullptr, status) {</span>
<span class="line-added"> 421     if (U_FAILURE(status)) { return; }</span>
<span class="line-added"> 422     LocalPointer&lt;DecimalFormatSymbols&gt; dfs(new DecimalFormatSymbols(symbols), status);</span>
<span class="line-added"> 423     if (U_FAILURE(status)) {</span>
<span class="line-added"> 424         // If we failed to allocate DecimalFormatSymbols, then release fields and its members.</span>
<span class="line-added"> 425         // We must have a fully complete fields object, we cannot have partially populated members.</span>
<span class="line-added"> 426         delete fields;</span>
<span class="line-added"> 427         fields = nullptr;</span>
<span class="line-added"> 428         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 429         return;</span>
<span class="line-added"> 430     }</span>
<span class="line-added"> 431     fields-&gt;symbols.adoptInstead(dfs.orphan());</span>
 432     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_IF_CURRENCY, status);
 433     touch(status);
 434 }
 435 
 436 DecimalFormat::DecimalFormat(const DecimalFormat&amp; source) : NumberFormat(source) {
<a name="20" id="anc20"></a><span class="line-added"> 437     // If the object that we are copying from is invalid, no point in going further.</span>
<span class="line-added"> 438     if (source.fields == nullptr) {</span>
<span class="line-added"> 439         return;</span>
<span class="line-added"> 440     }</span>
 441     // Note: it is not safe to copy fields-&gt;formatter or fWarehouse directly because fields-&gt;formatter might have
 442     // dangling pointers to fields inside fWarehouse. The safe thing is to re-construct fields-&gt;formatter from
 443     // the property bag, despite being somewhat slower.
 444     fields = new DecimalFormatFields();
 445     if (fields == nullptr) {
<a name="21" id="anc21"></a><span class="line-modified"> 446         return; // no way to report an error.</span>
 447     }
<a name="22" id="anc22"></a><span class="line-modified"> 448     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified"> 449     fields-&gt;formatter.adoptInsteadAndCheckErrorCode(new LocalizedNumberFormatter(), status);</span>
<span class="line-modified"> 450     fields-&gt;properties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(*source.fields-&gt;properties), status);</span>
<span class="line-modified"> 451     fields-&gt;symbols.adoptInsteadAndCheckErrorCode(new DecimalFormatSymbols(*source.fields-&gt;symbols), status);</span>
<span class="line-added"> 452     fields-&gt;exportedProperties.adoptInsteadAndCheckErrorCode(new DecimalFormatProperties(), status);</span>
<span class="line-added"> 453     // In order to simplify error handling logic in the various getters/setters/etc, we do not allow</span>
<span class="line-added"> 454     // any partially populated DecimalFormatFields object. We must have a fully complete fields object</span>
<span class="line-added"> 455     // or else we set it to nullptr.</span>
<span class="line-added"> 456     if (fields-&gt;formatter.isNull() || fields-&gt;properties.isNull() || fields-&gt;exportedProperties.isNull() || fields-&gt;symbols.isNull()) {</span>
<span class="line-added"> 457         delete fields;</span>
<span class="line-added"> 458         fields = nullptr;</span>
 459         return;
 460     }
<a name="23" id="anc23"></a><span class="line-modified"> 461     touch(status);</span>
 462 }
 463 
 464 DecimalFormat&amp; DecimalFormat::operator=(const DecimalFormat&amp; rhs) {
<a name="24" id="anc24"></a><span class="line-added"> 465     // guard against self-assignment</span>
<span class="line-added"> 466     if (this == &amp;rhs) {</span>
<span class="line-added"> 467         return *this;</span>
<span class="line-added"> 468     }</span>
<span class="line-added"> 469     // Make sure both objects are valid.</span>
<span class="line-added"> 470     if (fields == nullptr || rhs.fields == nullptr) {</span>
<span class="line-added"> 471         return *this; // unfortunately, no way to report an error.</span>
<span class="line-added"> 472     }</span>
 473     *fields-&gt;properties = *rhs.fields-&gt;properties;
 474     fields-&gt;exportedProperties-&gt;clear();
<a name="25" id="anc25"></a><span class="line-modified"> 475     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified"> 476     LocalPointer&lt;DecimalFormatSymbols&gt; dfs(new DecimalFormatSymbols(*rhs.fields-&gt;symbols), status);</span>
<span class="line-added"> 477     if (U_FAILURE(status)) {</span>
<span class="line-added"> 478         // We failed to allocate DecimalFormatSymbols, release fields and its members.</span>
<span class="line-added"> 479         // We must have a fully complete fields object, we cannot have partially populated members.</span>
<span class="line-added"> 480         delete fields;</span>
<span class="line-added"> 481         fields = nullptr;</span>
<span class="line-added"> 482         return *this;</span>
<span class="line-added"> 483     }</span>
<span class="line-added"> 484     fields-&gt;symbols.adoptInstead(dfs.orphan());</span>
<span class="line-added"> 485     touch(status);</span>
<span class="line-added"> 486 </span>
 487     return *this;
 488 }
 489 
 490 DecimalFormat::~DecimalFormat() {
<a name="26" id="anc26"></a><span class="line-added"> 491     if (fields == nullptr) { return; }</span>
<span class="line-added"> 492 </span>
 493     delete fields-&gt;atomicParser.exchange(nullptr);
 494     delete fields-&gt;atomicCurrencyParser.exchange(nullptr);
 495     delete fields;
 496 }
 497 
 498 Format* DecimalFormat::clone() const {
<a name="27" id="anc27"></a><span class="line-modified"> 499     // can only clone valid objects.</span>
<span class="line-added"> 500     if (fields == nullptr) {</span>
<span class="line-added"> 501         return nullptr;</span>
<span class="line-added"> 502     }</span>
<span class="line-added"> 503     LocalPointer&lt;DecimalFormat&gt; df(new DecimalFormat(*this));</span>
<span class="line-added"> 504     if (df.isValid() &amp;&amp; df-&gt;fields != nullptr) {</span>
<span class="line-added"> 505         return df.orphan();</span>
<span class="line-added"> 506     }</span>
<span class="line-added"> 507     return nullptr;</span>
 508 }
 509 
 510 UBool DecimalFormat::operator==(const Format&amp; other) const {
 511     auto* otherDF = dynamic_cast&lt;const DecimalFormat*&gt;(&amp;other);
 512     if (otherDF == nullptr) {
 513         return false;
 514     }
<a name="28" id="anc28"></a><span class="line-added"> 515     // If either object is in an invalid state, prevent dereferencing nullptr below.</span>
<span class="line-added"> 516     // Additionally, invalid objects should not be considered equal to anything.</span>
<span class="line-added"> 517     if (fields == nullptr || otherDF-&gt;fields == nullptr) {</span>
<span class="line-added"> 518         return false;</span>
<span class="line-added"> 519     }</span>
 520     return *fields-&gt;properties == *otherDF-&gt;fields-&gt;properties &amp;&amp; *fields-&gt;symbols == *otherDF-&gt;fields-&gt;symbols;
 521 }
 522 
 523 UnicodeString&amp; DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
<a name="29" id="anc29"></a><span class="line-added"> 524     if (fields == nullptr) {</span>
<span class="line-added"> 525         appendTo.setToBogus();</span>
<span class="line-added"> 526         return appendTo;</span>
<span class="line-added"> 527     }</span>
 528     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatDouble(number, appendTo)) {
 529         return appendTo;
 530     }
 531     UErrorCode localStatus = U_ZERO_ERROR;
 532     FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, localStatus);
 533     fieldPositionHelper(output, pos, appendTo.length(), localStatus);
 534     auto appendable = UnicodeStringAppendable(appendTo);
<a name="30" id="anc30"></a><span class="line-modified"> 535     output.appendTo(appendable, localStatus);</span>
 536     return appendTo;
 537 }
 538 
 539 UnicodeString&amp; DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 540                                      UErrorCode&amp; status) const {
<a name="31" id="anc31"></a><span class="line-added"> 541     if (U_FAILURE(status)) {</span>
<span class="line-added"> 542         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added"> 543     }</span>
<span class="line-added"> 544     if (fields == nullptr) {</span>
<span class="line-added"> 545         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 546         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 547         appendTo.setToBogus();</span>
<span class="line-added"> 548         return appendTo;</span>
<span class="line-added"> 549     }</span>
 550     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatDouble(number, appendTo)) {
 551         return appendTo;
 552     }
 553     FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, status);
 554     fieldPositionHelper(output, pos, appendTo.length(), status);
 555     auto appendable = UnicodeStringAppendable(appendTo);
<a name="32" id="anc32"></a><span class="line-modified"> 556     output.appendTo(appendable, status);</span>
 557     return appendTo;
 558 }
 559 
 560 UnicodeString&amp;
 561 DecimalFormat::format(double number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 562                       UErrorCode&amp; status) const {
<a name="33" id="anc33"></a><span class="line-added"> 563     if (U_FAILURE(status)) {</span>
<span class="line-added"> 564         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added"> 565     }</span>
<span class="line-added"> 566     if (fields == nullptr) {</span>
<span class="line-added"> 567         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 568         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 569         appendTo.setToBogus();</span>
<span class="line-added"> 570         return appendTo;</span>
<span class="line-added"> 571     }</span>
 572     if (posIter == nullptr &amp;&amp; fastFormatDouble(number, appendTo)) {
 573         return appendTo;
 574     }
 575     FormattedNumber output = fields-&gt;formatter-&gt;formatDouble(number, status);
 576     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 577     auto appendable = UnicodeStringAppendable(appendTo);
<a name="34" id="anc34"></a><span class="line-modified"> 578     output.appendTo(appendable, status);</span>
 579     return appendTo;
 580 }
 581 
 582 UnicodeString&amp; DecimalFormat::format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
 583     return format(static_cast&lt;int64_t&gt; (number), appendTo, pos);
 584 }
 585 
 586 UnicodeString&amp; DecimalFormat::format(int32_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 587                                      UErrorCode&amp; status) const {
 588     return format(static_cast&lt;int64_t&gt; (number), appendTo, pos, status);
 589 }
 590 
 591 UnicodeString&amp;
 592 DecimalFormat::format(int32_t number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 593                       UErrorCode&amp; status) const {
 594     return format(static_cast&lt;int64_t&gt; (number), appendTo, posIter, status);
 595 }
 596 
 597 UnicodeString&amp; DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const {
<a name="35" id="anc35"></a><span class="line-added"> 598     if (fields == nullptr) {</span>
<span class="line-added"> 599         appendTo.setToBogus();</span>
<span class="line-added"> 600         return appendTo;</span>
<span class="line-added"> 601     }</span>
 602     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatInt64(number, appendTo)) {
 603         return appendTo;
 604     }
 605     UErrorCode localStatus = U_ZERO_ERROR;
 606     FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, localStatus);
 607     fieldPositionHelper(output, pos, appendTo.length(), localStatus);
 608     auto appendable = UnicodeStringAppendable(appendTo);
<a name="36" id="anc36"></a><span class="line-modified"> 609     output.appendTo(appendable, localStatus);</span>
 610     return appendTo;
 611 }
 612 
 613 UnicodeString&amp; DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 614                                      UErrorCode&amp; status) const {
<a name="37" id="anc37"></a><span class="line-added"> 615     if (U_FAILURE(status)) {</span>
<span class="line-added"> 616         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added"> 617     }</span>
<span class="line-added"> 618     if (fields == nullptr) {</span>
<span class="line-added"> 619         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 620         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 621         appendTo.setToBogus();</span>
<span class="line-added"> 622         return appendTo;</span>
<span class="line-added"> 623     }</span>
 624     if (pos.getField() == FieldPosition::DONT_CARE &amp;&amp; fastFormatInt64(number, appendTo)) {
 625         return appendTo;
 626     }
 627     FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, status);
 628     fieldPositionHelper(output, pos, appendTo.length(), status);
 629     auto appendable = UnicodeStringAppendable(appendTo);
<a name="38" id="anc38"></a><span class="line-modified"> 630     output.appendTo(appendable, status);</span>
 631     return appendTo;
 632 }
 633 
 634 UnicodeString&amp;
 635 DecimalFormat::format(int64_t number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 636                       UErrorCode&amp; status) const {
<a name="39" id="anc39"></a><span class="line-added"> 637     if (U_FAILURE(status)) {</span>
<span class="line-added"> 638         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added"> 639     }</span>
<span class="line-added"> 640     if (fields == nullptr) {</span>
<span class="line-added"> 641         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 642         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 643         appendTo.setToBogus();</span>
<span class="line-added"> 644         return appendTo;</span>
<span class="line-added"> 645     }</span>
 646     if (posIter == nullptr &amp;&amp; fastFormatInt64(number, appendTo)) {
 647         return appendTo;
 648     }
 649     FormattedNumber output = fields-&gt;formatter-&gt;formatInt(number, status);
 650     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 651     auto appendable = UnicodeStringAppendable(appendTo);
<a name="40" id="anc40"></a><span class="line-modified"> 652     output.appendTo(appendable, status);</span>
 653     return appendTo;
 654 }
 655 
 656 UnicodeString&amp;
 657 DecimalFormat::format(StringPiece number, UnicodeString&amp; appendTo, FieldPositionIterator* posIter,
 658                       UErrorCode&amp; status) const {
<a name="41" id="anc41"></a><span class="line-added"> 659     if (U_FAILURE(status)) {</span>
<span class="line-added"> 660         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added"> 661     }</span>
<span class="line-added"> 662     if (fields == nullptr) {</span>
<span class="line-added"> 663         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 664         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 665         appendTo.setToBogus();</span>
<span class="line-added"> 666         return appendTo;</span>
<span class="line-added"> 667     }</span>
 668     FormattedNumber output = fields-&gt;formatter-&gt;formatDecimal(number, status);
 669     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 670     auto appendable = UnicodeStringAppendable(appendTo);
<a name="42" id="anc42"></a><span class="line-modified"> 671     output.appendTo(appendable, status);</span>
 672     return appendTo;
 673 }
 674 
 675 UnicodeString&amp; DecimalFormat::format(const DecimalQuantity&amp; number, UnicodeString&amp; appendTo,
 676                                      FieldPositionIterator* posIter, UErrorCode&amp; status) const {
<a name="43" id="anc43"></a><span class="line-added"> 677     if (U_FAILURE(status)) {</span>
<span class="line-added"> 678         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added"> 679     }</span>
<span class="line-added"> 680     if (fields == nullptr) {</span>
<span class="line-added"> 681         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 682         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 683         appendTo.setToBogus();</span>
<span class="line-added"> 684         return appendTo;</span>
<span class="line-added"> 685     }</span>
 686     FormattedNumber output = fields-&gt;formatter-&gt;formatDecimalQuantity(number, status);
 687     fieldPositionIteratorHelper(output, posIter, appendTo.length(), status);
 688     auto appendable = UnicodeStringAppendable(appendTo);
<a name="44" id="anc44"></a><span class="line-modified"> 689     output.appendTo(appendable, status);</span>
 690     return appendTo;
 691 }
 692 
 693 UnicodeString&amp;
 694 DecimalFormat::format(const DecimalQuantity&amp; number, UnicodeString&amp; appendTo, FieldPosition&amp; pos,
 695                       UErrorCode&amp; status) const {
<a name="45" id="anc45"></a><span class="line-added"> 696     if (U_FAILURE(status)) {</span>
<span class="line-added"> 697         return appendTo; // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added"> 698     }</span>
<span class="line-added"> 699     if (fields == nullptr) {</span>
<span class="line-added"> 700         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added"> 701         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 702         appendTo.setToBogus();</span>
<span class="line-added"> 703         return appendTo;</span>
<span class="line-added"> 704     }</span>
 705     FormattedNumber output = fields-&gt;formatter-&gt;formatDecimalQuantity(number, status);
 706     fieldPositionHelper(output, pos, appendTo.length(), status);
 707     auto appendable = UnicodeStringAppendable(appendTo);
<a name="46" id="anc46"></a><span class="line-modified"> 708     output.appendTo(appendable, status);</span>
 709     return appendTo;
 710 }
 711 
 712 void DecimalFormat::parse(const UnicodeString&amp; text, Formattable&amp; output,
 713                           ParsePosition&amp; parsePosition) const {
<a name="47" id="anc47"></a><span class="line-added"> 714     if (fields == nullptr) {</span>
<span class="line-added"> 715         return;</span>
<span class="line-added"> 716     }</span>
 717     if (parsePosition.getIndex() &lt; 0 || parsePosition.getIndex() &gt;= text.length()) {
<a name="48" id="anc48"></a><span class="line-added"> 718         if (parsePosition.getIndex() == text.length()) {</span>
<span class="line-added"> 719             // If there is nothing to parse, it is an error</span>
<span class="line-added"> 720             parsePosition.setErrorIndex(parsePosition.getIndex());</span>
<span class="line-added"> 721         }</span>
 722         return;
 723     }
 724 
 725     ErrorCode status;
 726     ParsedNumber result;
 727     // Note: if this is a currency instance, currencies will be matched despite the fact that we are not in the
 728     // parseCurrency method (backwards compatibility)
 729     int32_t startIndex = parsePosition.getIndex();
 730     const NumberParserImpl* parser = getParser(status);
<a name="49" id="anc49"></a><span class="line-modified"> 731     if (U_FAILURE(status)) {</span>
<span class="line-added"> 732         return; // unfortunately no way to report back the error.</span>
<span class="line-added"> 733     }</span>
 734     parser-&gt;parse(text, startIndex, true, result, status);
<a name="50" id="anc50"></a><span class="line-added"> 735     if (U_FAILURE(status)) {</span>
<span class="line-added"> 736         return; // unfortunately no way to report back the error.</span>
<span class="line-added"> 737     }</span>
 738     // TODO: Do we need to check for fImpl-&gt;properties-&gt;parseAllInput (UCONFIG_HAVE_PARSEALLINPUT) here?
 739     if (result.success()) {
 740         parsePosition.setIndex(result.charEnd);
 741         result.populateFormattable(output, parser-&gt;getParseFlags());
 742     } else {
 743         parsePosition.setErrorIndex(startIndex + result.charEnd);
 744     }
 745 }
 746 
 747 CurrencyAmount* DecimalFormat::parseCurrency(const UnicodeString&amp; text, ParsePosition&amp; parsePosition) const {
<a name="51" id="anc51"></a><span class="line-added"> 748     if (fields == nullptr) {</span>
<span class="line-added"> 749         return nullptr;</span>
<span class="line-added"> 750     }</span>
 751     if (parsePosition.getIndex() &lt; 0 || parsePosition.getIndex() &gt;= text.length()) {
 752         return nullptr;
 753     }
 754 
 755     ErrorCode status;
 756     ParsedNumber result;
 757     // Note: if this is a currency instance, currencies will be matched despite the fact that we are not in the
 758     // parseCurrency method (backwards compatibility)
 759     int32_t startIndex = parsePosition.getIndex();
 760     const NumberParserImpl* parser = getCurrencyParser(status);
<a name="52" id="anc52"></a><span class="line-modified"> 761     if (U_FAILURE(status)) {</span>
<span class="line-added"> 762         return nullptr;</span>
<span class="line-added"> 763     }</span>
 764     parser-&gt;parse(text, startIndex, true, result, status);
<a name="53" id="anc53"></a><span class="line-added"> 765     if (U_FAILURE(status)) {</span>
<span class="line-added"> 766         return nullptr;</span>
<span class="line-added"> 767     }</span>
 768     // TODO: Do we need to check for fImpl-&gt;properties-&gt;parseAllInput (UCONFIG_HAVE_PARSEALLINPUT) here?
 769     if (result.success()) {
 770         parsePosition.setIndex(result.charEnd);
 771         Formattable formattable;
 772         result.populateFormattable(formattable, parser-&gt;getParseFlags());
<a name="54" id="anc54"></a><span class="line-modified"> 773         LocalPointer&lt;CurrencyAmount&gt; currencyAmount(</span>
<span class="line-added"> 774             new CurrencyAmount(formattable, result.currencyCode, status), status);</span>
<span class="line-added"> 775         if (U_FAILURE(status)) {</span>
<span class="line-added"> 776             return nullptr;</span>
<span class="line-added"> 777         }</span>
<span class="line-added"> 778         return currencyAmount.orphan();</span>
 779     } else {
 780         parsePosition.setErrorIndex(startIndex + result.charEnd);
 781         return nullptr;
 782     }
 783 }
 784 
 785 const DecimalFormatSymbols* DecimalFormat::getDecimalFormatSymbols(void) const {
<a name="55" id="anc55"></a><span class="line-added"> 786     if (fields == nullptr) {</span>
<span class="line-added"> 787         return nullptr;</span>
<span class="line-added"> 788     }</span>
 789     return fields-&gt;symbols.getAlias();
 790 }
 791 
 792 void DecimalFormat::adoptDecimalFormatSymbols(DecimalFormatSymbols* symbolsToAdopt) {
 793     if (symbolsToAdopt == nullptr) {
 794         return; // do not allow caller to set fields-&gt;symbols to NULL
 795     }
<a name="56" id="anc56"></a><span class="line-modified"> 796     // we must take ownership of symbolsToAdopt, even in a failure case.</span>
<span class="line-added"> 797     LocalPointer&lt;DecimalFormatSymbols&gt; dfs(symbolsToAdopt);</span>
<span class="line-added"> 798     if (fields == nullptr) {</span>
<span class="line-added"> 799         return;</span>
<span class="line-added"> 800     }</span>
<span class="line-added"> 801     fields-&gt;symbols.adoptInstead(dfs.orphan());</span>
 802     touchNoError();
 803 }
 804 
 805 void DecimalFormat::setDecimalFormatSymbols(const DecimalFormatSymbols&amp; symbols) {
<a name="57" id="anc57"></a><span class="line-modified"> 806     if (fields == nullptr) {</span>
<span class="line-added"> 807         return;</span>
<span class="line-added"> 808     }</span>
<span class="line-added"> 809     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added"> 810     LocalPointer&lt;DecimalFormatSymbols&gt; dfs(new DecimalFormatSymbols(symbols), status);</span>
<span class="line-added"> 811     if (U_FAILURE(status)) {</span>
<span class="line-added"> 812         // We failed to allocate DecimalFormatSymbols, release fields and its members.</span>
<span class="line-added"> 813         // We must have a fully complete fields object, we cannot have partially populated members.</span>
<span class="line-added"> 814         delete fields;</span>
<span class="line-added"> 815         fields = nullptr;</span>
<span class="line-added"> 816         return;</span>
<span class="line-added"> 817     }</span>
<span class="line-added"> 818     fields-&gt;symbols.adoptInstead(dfs.orphan());</span>
 819     touchNoError();
 820 }
 821 
 822 const CurrencyPluralInfo* DecimalFormat::getCurrencyPluralInfo(void) const {
<a name="58" id="anc58"></a><span class="line-added"> 823     if (fields == nullptr) {</span>
<span class="line-added"> 824         return nullptr;</span>
<span class="line-added"> 825     }</span>
 826     return fields-&gt;properties-&gt;currencyPluralInfo.fPtr.getAlias();
 827 }
 828 
 829 void DecimalFormat::adoptCurrencyPluralInfo(CurrencyPluralInfo* toAdopt) {
<a name="59" id="anc59"></a><span class="line-modified"> 830     // TODO: should we guard against nullptr input, like in adoptDecimalFormatSymbols?</span>
<span class="line-added"> 831     // we must take ownership of toAdopt, even in a failure case.</span>
<span class="line-added"> 832     LocalPointer&lt;CurrencyPluralInfo&gt; cpi(toAdopt);</span>
<span class="line-added"> 833     if (fields == nullptr) {</span>
<span class="line-added"> 834         return;</span>
<span class="line-added"> 835     }</span>
<span class="line-added"> 836     fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(cpi.orphan());</span>
 837     touchNoError();
 838 }
 839 
 840 void DecimalFormat::setCurrencyPluralInfo(const CurrencyPluralInfo&amp; info) {
<a name="60" id="anc60"></a><span class="line-added"> 841     if (fields == nullptr) {</span>
<span class="line-added"> 842         return;</span>
<span class="line-added"> 843     }</span>
 844     if (fields-&gt;properties-&gt;currencyPluralInfo.fPtr.isNull()) {
<a name="61" id="anc61"></a><span class="line-added"> 845         // Note: clone() can fail with OOM error, but we have no way to report it. :(</span>
 846         fields-&gt;properties-&gt;currencyPluralInfo.fPtr.adoptInstead(info.clone());
 847     } else {
 848         *fields-&gt;properties-&gt;currencyPluralInfo.fPtr = info; // copy-assignment operator
 849     }
 850     touchNoError();
 851 }
 852 
 853 UnicodeString&amp; DecimalFormat::getPositivePrefix(UnicodeString&amp; result) const {
<a name="62" id="anc62"></a><span class="line-modified"> 854     if (fields == nullptr) {</span>
<span class="line-modified"> 855         result.setToBogus();</span>
<span class="line-added"> 856         return result;</span>
<span class="line-added"> 857     }</span>
<span class="line-added"> 858     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added"> 859     fields-&gt;formatter-&gt;getAffixImpl(true, false, result, status);</span>
<span class="line-added"> 860     if (U_FAILURE(status)) { result.setToBogus(); }</span>
 861     return result;
 862 }
 863 
 864 void DecimalFormat::setPositivePrefix(const UnicodeString&amp; newValue) {
<a name="63" id="anc63"></a><span class="line-added"> 865     if (fields == nullptr) {</span>
<span class="line-added"> 866         return;</span>
<span class="line-added"> 867     }</span>
 868     if (newValue == fields-&gt;properties-&gt;positivePrefix) { return; }
 869     fields-&gt;properties-&gt;positivePrefix = newValue;
 870     touchNoError();
 871 }
 872 
 873 UnicodeString&amp; DecimalFormat::getNegativePrefix(UnicodeString&amp; result) const {
<a name="64" id="anc64"></a><span class="line-modified"> 874     if (fields == nullptr) {</span>
<span class="line-modified"> 875         result.setToBogus();</span>
<span class="line-added"> 876         return result;</span>
<span class="line-added"> 877     }</span>
<span class="line-added"> 878     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added"> 879     fields-&gt;formatter-&gt;getAffixImpl(true, true, result, status);</span>
<span class="line-added"> 880     if (U_FAILURE(status)) { result.setToBogus(); }</span>
 881     return result;
 882 }
 883 
 884 void DecimalFormat::setNegativePrefix(const UnicodeString&amp; newValue) {
<a name="65" id="anc65"></a><span class="line-added"> 885     if (fields == nullptr) {</span>
<span class="line-added"> 886         return;</span>
<span class="line-added"> 887     }</span>
 888     if (newValue == fields-&gt;properties-&gt;negativePrefix) { return; }
 889     fields-&gt;properties-&gt;negativePrefix = newValue;
 890     touchNoError();
 891 }
 892 
 893 UnicodeString&amp; DecimalFormat::getPositiveSuffix(UnicodeString&amp; result) const {
<a name="66" id="anc66"></a><span class="line-modified"> 894     if (fields == nullptr) {</span>
<span class="line-modified"> 895         result.setToBogus();</span>
<span class="line-added"> 896         return result;</span>
<span class="line-added"> 897     }</span>
<span class="line-added"> 898     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added"> 899     fields-&gt;formatter-&gt;getAffixImpl(false, false, result, status);</span>
<span class="line-added"> 900     if (U_FAILURE(status)) { result.setToBogus(); }</span>
 901     return result;
 902 }
 903 
 904 void DecimalFormat::setPositiveSuffix(const UnicodeString&amp; newValue) {
<a name="67" id="anc67"></a><span class="line-added"> 905     if (fields == nullptr) {</span>
<span class="line-added"> 906         return;</span>
<span class="line-added"> 907     }</span>
 908     if (newValue == fields-&gt;properties-&gt;positiveSuffix) { return; }
 909     fields-&gt;properties-&gt;positiveSuffix = newValue;
 910     touchNoError();
 911 }
 912 
 913 UnicodeString&amp; DecimalFormat::getNegativeSuffix(UnicodeString&amp; result) const {
<a name="68" id="anc68"></a><span class="line-modified"> 914     if (fields == nullptr) {</span>
<span class="line-modified"> 915         result.setToBogus();</span>
<span class="line-added"> 916         return result;</span>
<span class="line-added"> 917     }</span>
<span class="line-added"> 918     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added"> 919     fields-&gt;formatter-&gt;getAffixImpl(false, true, result, status);</span>
<span class="line-added"> 920     if (U_FAILURE(status)) { result.setToBogus(); }</span>
 921     return result;
 922 }
 923 
 924 void DecimalFormat::setNegativeSuffix(const UnicodeString&amp; newValue) {
<a name="69" id="anc69"></a><span class="line-added"> 925     if (fields == nullptr) {</span>
<span class="line-added"> 926         return;</span>
<span class="line-added"> 927     }</span>
 928     if (newValue == fields-&gt;properties-&gt;negativeSuffix) { return; }
 929     fields-&gt;properties-&gt;negativeSuffix = newValue;
 930     touchNoError();
 931 }
 932 
 933 UBool DecimalFormat::isSignAlwaysShown() const {
<a name="70" id="anc70"></a><span class="line-added"> 934     // Not much we can do to report an error.</span>
<span class="line-added"> 935     if (fields == nullptr) {</span>
<span class="line-added"> 936         return DecimalFormatProperties::getDefault().signAlwaysShown;</span>
<span class="line-added"> 937     }</span>
 938     return fields-&gt;properties-&gt;signAlwaysShown;
 939 }
 940 
 941 void DecimalFormat::setSignAlwaysShown(UBool value) {
<a name="71" id="anc71"></a><span class="line-added"> 942     if (fields == nullptr) { return; }</span>
 943     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;signAlwaysShown) { return; }
 944     fields-&gt;properties-&gt;signAlwaysShown = value;
 945     touchNoError();
 946 }
 947 
 948 int32_t DecimalFormat::getMultiplier(void) const {
<a name="72" id="anc72"></a><span class="line-modified"> 949     const DecimalFormatProperties *dfp;</span>
<span class="line-modified"> 950     // Not much we can do to report an error.</span>
<span class="line-modified"> 951     if (fields == nullptr) {</span>
<span class="line-modified"> 952         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added"> 953         dfp = &amp;(DecimalFormatProperties::getDefault());</span>
<span class="line-added"> 954     } else {</span>
<span class="line-added"> 955         dfp = fields-&gt;properties.getAlias();</span>
<span class="line-added"> 956     }</span>
<span class="line-added"> 957     if (dfp-&gt;multiplier != 1) {</span>
<span class="line-added"> 958         return dfp-&gt;multiplier;</span>
<span class="line-added"> 959     } else if (dfp-&gt;magnitudeMultiplier != 0) {</span>
<span class="line-added"> 960         return static_cast&lt;int32_t&gt;(uprv_pow10(dfp-&gt;magnitudeMultiplier));</span>
 961     } else {
 962         return 1;
 963     }
 964 }
 965 
 966 void DecimalFormat::setMultiplier(int32_t multiplier) {
<a name="73" id="anc73"></a><span class="line-added"> 967     if (fields == nullptr) {</span>
<span class="line-added"> 968          return;</span>
<span class="line-added"> 969     }</span>
 970     if (multiplier == 0) {
 971         multiplier = 1;     // one being the benign default value for a multiplier.
 972     }
 973 
 974     // Try to convert to a magnitude multiplier first
 975     int delta = 0;
 976     int value = multiplier;
 977     while (value != 1) {
 978         delta++;
 979         int temp = value / 10;
 980         if (temp * 10 != value) {
 981             delta = -1;
 982             break;
 983         }
 984         value = temp;
 985     }
 986     if (delta != -1) {
 987         fields-&gt;properties-&gt;magnitudeMultiplier = delta;
 988         fields-&gt;properties-&gt;multiplier = 1;
 989     } else {
 990         fields-&gt;properties-&gt;magnitudeMultiplier = 0;
 991         fields-&gt;properties-&gt;multiplier = multiplier;
 992     }
 993     touchNoError();
 994 }
 995 
 996 int32_t DecimalFormat::getMultiplierScale() const {
<a name="74" id="anc74"></a><span class="line-added"> 997     // Not much we can do to report an error.</span>
<span class="line-added"> 998     if (fields == nullptr) {</span>
<span class="line-added"> 999         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1000         return DecimalFormatProperties::getDefault().multiplierScale;</span>
<span class="line-added">1001     }</span>
1002     return fields-&gt;properties-&gt;multiplierScale;
1003 }
1004 
1005 void DecimalFormat::setMultiplierScale(int32_t newValue) {
<a name="75" id="anc75"></a><span class="line-added">1006     if (fields == nullptr) { return; }</span>
1007     if (newValue == fields-&gt;properties-&gt;multiplierScale) { return; }
1008     fields-&gt;properties-&gt;multiplierScale = newValue;
1009     touchNoError();
1010 }
1011 
1012 double DecimalFormat::getRoundingIncrement(void) const {
<a name="76" id="anc76"></a><span class="line-added">1013     // Not much we can do to report an error.</span>
<span class="line-added">1014     if (fields == nullptr) {</span>
<span class="line-added">1015         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1016         return DecimalFormatProperties::getDefault().roundingIncrement;</span>
<span class="line-added">1017     }</span>
1018     return fields-&gt;exportedProperties-&gt;roundingIncrement;
1019 }
1020 
1021 void DecimalFormat::setRoundingIncrement(double newValue) {
<a name="77" id="anc77"></a><span class="line-added">1022     if (fields == nullptr) { return; }</span>
1023     if (newValue == fields-&gt;properties-&gt;roundingIncrement) { return; }
1024     fields-&gt;properties-&gt;roundingIncrement = newValue;
1025     touchNoError();
1026 }
1027 
1028 ERoundingMode DecimalFormat::getRoundingMode(void) const {
<a name="78" id="anc78"></a><span class="line-added">1029     // Not much we can do to report an error.</span>
<span class="line-added">1030     if (fields == nullptr) {</span>
<span class="line-added">1031         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1032         return static_cast&lt;ERoundingMode&gt;(DecimalFormatProperties::getDefault().roundingMode.getNoError());</span>
<span class="line-added">1033     }</span>
1034     // UNumberFormatRoundingMode and ERoundingMode have the same values.
1035     return static_cast&lt;ERoundingMode&gt;(fields-&gt;exportedProperties-&gt;roundingMode.getNoError());
1036 }
1037 
1038 void DecimalFormat::setRoundingMode(ERoundingMode roundingMode) {
<a name="79" id="anc79"></a><span class="line-added">1039     if (fields == nullptr) { return; }</span>
1040     auto uRoundingMode = static_cast&lt;UNumberFormatRoundingMode&gt;(roundingMode);
1041     if (!fields-&gt;properties-&gt;roundingMode.isNull() &amp;&amp; uRoundingMode == fields-&gt;properties-&gt;roundingMode.getNoError()) {
1042         return;
1043     }
1044     NumberFormat::setMaximumIntegerDigits(roundingMode); // to set field for compatibility
1045     fields-&gt;properties-&gt;roundingMode = uRoundingMode;
1046     touchNoError();
1047 }
1048 
1049 int32_t DecimalFormat::getFormatWidth(void) const {
<a name="80" id="anc80"></a><span class="line-added">1050     // Not much we can do to report an error.</span>
<span class="line-added">1051     if (fields == nullptr) {</span>
<span class="line-added">1052         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1053         return DecimalFormatProperties::getDefault().formatWidth;</span>
<span class="line-added">1054     }</span>
1055     return fields-&gt;properties-&gt;formatWidth;
1056 }
1057 
1058 void DecimalFormat::setFormatWidth(int32_t width) {
<a name="81" id="anc81"></a><span class="line-added">1059     if (fields == nullptr) { return; }</span>
1060     if (width == fields-&gt;properties-&gt;formatWidth) { return; }
1061     fields-&gt;properties-&gt;formatWidth = width;
1062     touchNoError();
1063 }
1064 
1065 UnicodeString DecimalFormat::getPadCharacterString() const {
<a name="82" id="anc82"></a><span class="line-modified">1066     if (fields == nullptr || fields-&gt;properties-&gt;padString.isBogus()) {</span>
1067         // Readonly-alias the static string kFallbackPaddingString
1068         return {TRUE, kFallbackPaddingString, -1};
1069     } else {
1070         return fields-&gt;properties-&gt;padString;
1071     }
1072 }
1073 
1074 void DecimalFormat::setPadCharacter(const UnicodeString&amp; padChar) {
<a name="83" id="anc83"></a><span class="line-added">1075     if (fields == nullptr) { return; }</span>
1076     if (padChar == fields-&gt;properties-&gt;padString) { return; }
1077     if (padChar.length() &gt; 0) {
1078         fields-&gt;properties-&gt;padString = UnicodeString(padChar.char32At(0));
1079     } else {
1080         fields-&gt;properties-&gt;padString.setToBogus();
1081     }
1082     touchNoError();
1083 }
1084 
1085 EPadPosition DecimalFormat::getPadPosition(void) const {
<a name="84" id="anc84"></a><span class="line-modified">1086     if (fields == nullptr || fields-&gt;properties-&gt;padPosition.isNull()) {</span>
1087         return EPadPosition::kPadBeforePrefix;
1088     } else {
1089         // UNumberFormatPadPosition and EPadPosition have the same values.
1090         return static_cast&lt;EPadPosition&gt;(fields-&gt;properties-&gt;padPosition.getNoError());
1091     }
1092 }
1093 
1094 void DecimalFormat::setPadPosition(EPadPosition padPos) {
<a name="85" id="anc85"></a><span class="line-added">1095     if (fields == nullptr) { return; }</span>
1096     auto uPadPos = static_cast&lt;UNumberFormatPadPosition&gt;(padPos);
1097     if (!fields-&gt;properties-&gt;padPosition.isNull() &amp;&amp; uPadPos == fields-&gt;properties-&gt;padPosition.getNoError()) {
1098         return;
1099     }
1100     fields-&gt;properties-&gt;padPosition = uPadPos;
1101     touchNoError();
1102 }
1103 
1104 UBool DecimalFormat::isScientificNotation(void) const {
<a name="86" id="anc86"></a><span class="line-modified">1105     // Not much we can do to report an error.</span>
<span class="line-added">1106     if (fields == nullptr) {</span>
<span class="line-added">1107         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1108         return (DecimalFormatProperties::getDefault().minimumExponentDigits != -1);</span>
<span class="line-added">1109     }</span>
<span class="line-added">1110     return (fields-&gt;properties-&gt;minimumExponentDigits != -1);</span>
1111 }
1112 
1113 void DecimalFormat::setScientificNotation(UBool useScientific) {
<a name="87" id="anc87"></a><span class="line-added">1114     if (fields == nullptr) { return; }</span>
1115     int32_t minExp = useScientific ? 1 : -1;
1116     if (fields-&gt;properties-&gt;minimumExponentDigits == minExp) { return; }
1117     if (useScientific) {
1118         fields-&gt;properties-&gt;minimumExponentDigits = 1;
1119     } else {
1120         fields-&gt;properties-&gt;minimumExponentDigits = -1;
1121     }
1122     touchNoError();
1123 }
1124 
1125 int8_t DecimalFormat::getMinimumExponentDigits(void) const {
<a name="88" id="anc88"></a><span class="line-added">1126     // Not much we can do to report an error.</span>
<span class="line-added">1127     if (fields == nullptr) {</span>
<span class="line-added">1128         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1129         return static_cast&lt;int8_t&gt;(DecimalFormatProperties::getDefault().minimumExponentDigits);</span>
<span class="line-added">1130     }</span>
1131     return static_cast&lt;int8_t&gt;(fields-&gt;properties-&gt;minimumExponentDigits);
1132 }
1133 
1134 void DecimalFormat::setMinimumExponentDigits(int8_t minExpDig) {
<a name="89" id="anc89"></a><span class="line-added">1135     if (fields == nullptr) { return; }</span>
1136     if (minExpDig == fields-&gt;properties-&gt;minimumExponentDigits) { return; }
1137     fields-&gt;properties-&gt;minimumExponentDigits = minExpDig;
1138     touchNoError();
1139 }
1140 
1141 UBool DecimalFormat::isExponentSignAlwaysShown(void) const {
<a name="90" id="anc90"></a><span class="line-added">1142     // Not much we can do to report an error.</span>
<span class="line-added">1143     if (fields == nullptr) {</span>
<span class="line-added">1144         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1145         return DecimalFormatProperties::getDefault().exponentSignAlwaysShown;</span>
<span class="line-added">1146     }</span>
1147     return fields-&gt;properties-&gt;exponentSignAlwaysShown;
1148 }
1149 
1150 void DecimalFormat::setExponentSignAlwaysShown(UBool expSignAlways) {
<a name="91" id="anc91"></a><span class="line-added">1151     if (fields == nullptr) { return; }</span>
1152     if (UBOOL_TO_BOOL(expSignAlways) == fields-&gt;properties-&gt;exponentSignAlwaysShown) { return; }
1153     fields-&gt;properties-&gt;exponentSignAlwaysShown = expSignAlways;
1154     touchNoError();
1155 }
1156 
1157 int32_t DecimalFormat::getGroupingSize(void) const {
<a name="92" id="anc92"></a><span class="line-modified">1158     int32_t groupingSize;</span>
<span class="line-added">1159     // Not much we can do to report an error.</span>
<span class="line-added">1160     if (fields == nullptr) {</span>
<span class="line-added">1161         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1162         groupingSize = DecimalFormatProperties::getDefault().groupingSize;</span>
<span class="line-added">1163     } else {</span>
<span class="line-added">1164         groupingSize = fields-&gt;properties-&gt;groupingSize;</span>
<span class="line-added">1165     }</span>
<span class="line-added">1166     if (groupingSize &lt; 0) {</span>
1167         return 0;
1168     }
<a name="93" id="anc93"></a><span class="line-modified">1169     return groupingSize;</span>
1170 }
1171 
1172 void DecimalFormat::setGroupingSize(int32_t newValue) {
<a name="94" id="anc94"></a><span class="line-added">1173     if (fields == nullptr) { return; }</span>
1174     if (newValue == fields-&gt;properties-&gt;groupingSize) { return; }
1175     fields-&gt;properties-&gt;groupingSize = newValue;
1176     touchNoError();
1177 }
1178 
1179 int32_t DecimalFormat::getSecondaryGroupingSize(void) const {
<a name="95" id="anc95"></a><span class="line-modified">1180     int32_t grouping2;</span>
<span class="line-added">1181     // Not much we can do to report an error.</span>
<span class="line-added">1182     if (fields == nullptr) {</span>
<span class="line-added">1183         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1184         grouping2 = DecimalFormatProperties::getDefault().secondaryGroupingSize;</span>
<span class="line-added">1185     } else {</span>
<span class="line-added">1186         grouping2 = fields-&gt;properties-&gt;secondaryGroupingSize;</span>
<span class="line-added">1187     }</span>
1188     if (grouping2 &lt; 0) {
1189         return 0;
1190     }
1191     return grouping2;
1192 }
1193 
1194 void DecimalFormat::setSecondaryGroupingSize(int32_t newValue) {
<a name="96" id="anc96"></a><span class="line-added">1195     if (fields == nullptr) { return; }</span>
1196     if (newValue == fields-&gt;properties-&gt;secondaryGroupingSize) { return; }
1197     fields-&gt;properties-&gt;secondaryGroupingSize = newValue;
1198     touchNoError();
1199 }
1200 
1201 int32_t DecimalFormat::getMinimumGroupingDigits() const {
<a name="97" id="anc97"></a><span class="line-added">1202     // Not much we can do to report an error.</span>
<span class="line-added">1203     if (fields == nullptr) {</span>
<span class="line-added">1204         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1205         return DecimalFormatProperties::getDefault().minimumGroupingDigits;</span>
<span class="line-added">1206     }</span>
1207     return fields-&gt;properties-&gt;minimumGroupingDigits;
1208 }
1209 
1210 void DecimalFormat::setMinimumGroupingDigits(int32_t newValue) {
<a name="98" id="anc98"></a><span class="line-added">1211     if (fields == nullptr) { return; }</span>
1212     if (newValue == fields-&gt;properties-&gt;minimumGroupingDigits) { return; }
1213     fields-&gt;properties-&gt;minimumGroupingDigits = newValue;
1214     touchNoError();
1215 }
1216 
1217 UBool DecimalFormat::isDecimalSeparatorAlwaysShown(void) const {
<a name="99" id="anc99"></a><span class="line-added">1218     // Not much we can do to report an error.</span>
<span class="line-added">1219     if (fields == nullptr) {</span>
<span class="line-added">1220         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1221         return DecimalFormatProperties::getDefault().decimalSeparatorAlwaysShown;</span>
<span class="line-added">1222     }</span>
1223     return fields-&gt;properties-&gt;decimalSeparatorAlwaysShown;
1224 }
1225 
1226 void DecimalFormat::setDecimalSeparatorAlwaysShown(UBool newValue) {
<a name="100" id="anc100"></a><span class="line-added">1227     if (fields == nullptr) { return; }</span>
1228     if (UBOOL_TO_BOOL(newValue) == fields-&gt;properties-&gt;decimalSeparatorAlwaysShown) { return; }
1229     fields-&gt;properties-&gt;decimalSeparatorAlwaysShown = newValue;
1230     touchNoError();
1231 }
1232 
1233 UBool DecimalFormat::isDecimalPatternMatchRequired(void) const {
<a name="101" id="anc101"></a><span class="line-added">1234     // Not much we can do to report an error.</span>
<span class="line-added">1235     if (fields == nullptr) {</span>
<span class="line-added">1236         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1237         return DecimalFormatProperties::getDefault().decimalPatternMatchRequired;</span>
<span class="line-added">1238     }</span>
1239     return fields-&gt;properties-&gt;decimalPatternMatchRequired;
1240 }
1241 
1242 void DecimalFormat::setDecimalPatternMatchRequired(UBool newValue) {
<a name="102" id="anc102"></a><span class="line-added">1243     if (fields == nullptr) { return; }</span>
1244     if (UBOOL_TO_BOOL(newValue) == fields-&gt;properties-&gt;decimalPatternMatchRequired) { return; }
1245     fields-&gt;properties-&gt;decimalPatternMatchRequired = newValue;
1246     touchNoError();
1247 }
1248 
1249 UBool DecimalFormat::isParseNoExponent() const {
<a name="103" id="anc103"></a><span class="line-added">1250     // Not much we can do to report an error.</span>
<span class="line-added">1251     if (fields == nullptr) {</span>
<span class="line-added">1252         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1253         return DecimalFormatProperties::getDefault().parseNoExponent;</span>
<span class="line-added">1254     }</span>
1255     return fields-&gt;properties-&gt;parseNoExponent;
1256 }
1257 
1258 void DecimalFormat::setParseNoExponent(UBool value) {
<a name="104" id="anc104"></a><span class="line-added">1259     if (fields == nullptr) { return; }</span>
1260     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseNoExponent) { return; }
1261     fields-&gt;properties-&gt;parseNoExponent = value;
1262     touchNoError();
1263 }
1264 
1265 UBool DecimalFormat::isParseCaseSensitive() const {
<a name="105" id="anc105"></a><span class="line-added">1266     // Not much we can do to report an error.</span>
<span class="line-added">1267     if (fields == nullptr) {</span>
<span class="line-added">1268         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1269         return DecimalFormatProperties::getDefault().parseCaseSensitive;</span>
<span class="line-added">1270     }</span>
1271     return fields-&gt;properties-&gt;parseCaseSensitive;
1272 }
1273 
1274 void DecimalFormat::setParseCaseSensitive(UBool value) {
<a name="106" id="anc106"></a><span class="line-added">1275     if (fields == nullptr) { return; }</span>
1276     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;parseCaseSensitive) { return; }
1277     fields-&gt;properties-&gt;parseCaseSensitive = value;
1278     touchNoError();
1279 }
1280 
1281 UBool DecimalFormat::isFormatFailIfMoreThanMaxDigits() const {
<a name="107" id="anc107"></a><span class="line-added">1282     // Not much we can do to report an error.</span>
<span class="line-added">1283     if (fields == nullptr) {</span>
<span class="line-added">1284         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1285         return DecimalFormatProperties::getDefault().formatFailIfMoreThanMaxDigits;</span>
<span class="line-added">1286     }</span>
1287     return fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits;
1288 }
1289 
1290 void DecimalFormat::setFormatFailIfMoreThanMaxDigits(UBool value) {
<a name="108" id="anc108"></a><span class="line-added">1291     if (fields == nullptr) { return; }</span>
1292     if (UBOOL_TO_BOOL(value) == fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits) { return; }
1293     fields-&gt;properties-&gt;formatFailIfMoreThanMaxDigits = value;
1294     touchNoError();
1295 }
1296 
1297 UnicodeString&amp; DecimalFormat::toPattern(UnicodeString&amp; result) const {
<a name="109" id="anc109"></a><span class="line-added">1298     if (fields == nullptr) {</span>
<span class="line-added">1299         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1300         result.setToBogus();</span>
<span class="line-added">1301         return result;</span>
<span class="line-added">1302     }</span>
1303     // Pull some properties from exportedProperties and others from properties
1304     // to keep affix patterns intact.  In particular, pull rounding properties
1305     // so that CurrencyUsage is reflected properly.
1306     // TODO: Consider putting this logic in number_patternstring.cpp instead.
1307     ErrorCode localStatus;
1308     DecimalFormatProperties tprops(*fields-&gt;properties);
<a name="110" id="anc110"></a><span class="line-modified">1309     bool useCurrency = (</span>
<span class="line-modified">1310         !tprops.currency.isNull() ||</span>
<span class="line-modified">1311         !tprops.currencyPluralInfo.fPtr.isNull() ||</span>
<span class="line-modified">1312         !tprops.currencyUsage.isNull() ||</span>
<span class="line-modified">1313         AffixUtils::hasCurrencySymbols(tprops.positivePrefixPattern, localStatus) ||</span>
<span class="line-modified">1314         AffixUtils::hasCurrencySymbols(tprops.positiveSuffixPattern, localStatus) ||</span>
<span class="line-added">1315         AffixUtils::hasCurrencySymbols(tprops.negativePrefixPattern, localStatus) ||</span>
<span class="line-added">1316         AffixUtils::hasCurrencySymbols(tprops.negativeSuffixPattern, localStatus));</span>
1317     if (useCurrency) {
1318         tprops.minimumFractionDigits = fields-&gt;exportedProperties-&gt;minimumFractionDigits;
1319         tprops.maximumFractionDigits = fields-&gt;exportedProperties-&gt;maximumFractionDigits;
1320         tprops.roundingIncrement = fields-&gt;exportedProperties-&gt;roundingIncrement;
1321     }
1322     result = PatternStringUtils::propertiesToPatternString(tprops, localStatus);
1323     return result;
1324 }
1325 
1326 UnicodeString&amp; DecimalFormat::toLocalizedPattern(UnicodeString&amp; result) const {
<a name="111" id="anc111"></a><span class="line-added">1327     if (fields == nullptr) {</span>
<span class="line-added">1328         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1329         result.setToBogus();</span>
<span class="line-added">1330         return result;</span>
<span class="line-added">1331     }</span>
1332     ErrorCode localStatus;
1333     result = toPattern(result);
1334     result = PatternStringUtils::convertLocalized(result, *fields-&gt;symbols, true, localStatus);
1335     return result;
1336 }
1337 
1338 void DecimalFormat::applyPattern(const UnicodeString&amp; pattern, UParseError&amp;, UErrorCode&amp; status) {
1339     // TODO: What is parseError for?
1340     applyPattern(pattern, status);
1341 }
1342 
1343 void DecimalFormat::applyPattern(const UnicodeString&amp; pattern, UErrorCode&amp; status) {
<a name="112" id="anc112"></a><span class="line-added">1344     // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">1345     if (U_FAILURE(status)) { return; }</span>
<span class="line-added">1346     if (fields == nullptr) {</span>
<span class="line-added">1347         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1348         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1349         return;</span>
<span class="line-added">1350     }</span>
1351     setPropertiesFromPattern(pattern, IGNORE_ROUNDING_NEVER, status);
1352     touch(status);
1353 }
1354 
1355 void DecimalFormat::applyLocalizedPattern(const UnicodeString&amp; localizedPattern, UParseError&amp;,
1356                                           UErrorCode&amp; status) {
1357     // TODO: What is parseError for?
1358     applyLocalizedPattern(localizedPattern, status);
1359 }
1360 
1361 void DecimalFormat::applyLocalizedPattern(const UnicodeString&amp; localizedPattern, UErrorCode&amp; status) {
<a name="113" id="anc113"></a><span class="line-modified">1362     // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-modified">1363     if (U_FAILURE(status)) { return; }</span>
<span class="line-modified">1364     if (fields == nullptr) {</span>
<span class="line-modified">1365         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1366         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1367         return;</span>
1368     }
<a name="114" id="anc114"></a><span class="line-added">1369     UnicodeString pattern = PatternStringUtils::convertLocalized(</span>
<span class="line-added">1370             localizedPattern, *fields-&gt;symbols, false, status);</span>
<span class="line-added">1371     applyPattern(pattern, status);</span>
1372 }
1373 
1374 void DecimalFormat::setMaximumIntegerDigits(int32_t newValue) {
<a name="115" id="anc115"></a><span class="line-added">1375     if (fields == nullptr) { return; }</span>
1376     if (newValue == fields-&gt;properties-&gt;maximumIntegerDigits) { return; }
1377     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
1378     int32_t min = fields-&gt;properties-&gt;minimumIntegerDigits;
1379     if (min &gt;= 0 &amp;&amp; min &gt; newValue) {
1380         fields-&gt;properties-&gt;minimumIntegerDigits = newValue;
1381     }
1382     fields-&gt;properties-&gt;maximumIntegerDigits = newValue;
1383     touchNoError();
1384 }
1385 
1386 void DecimalFormat::setMinimumIntegerDigits(int32_t newValue) {
<a name="116" id="anc116"></a><span class="line-added">1387     if (fields == nullptr) { return; }</span>
1388     if (newValue == fields-&gt;properties-&gt;minimumIntegerDigits) { return; }
1389     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
1390     int32_t max = fields-&gt;properties-&gt;maximumIntegerDigits;
1391     if (max &gt;= 0 &amp;&amp; max &lt; newValue) {
1392         fields-&gt;properties-&gt;maximumIntegerDigits = newValue;
1393     }
1394     fields-&gt;properties-&gt;minimumIntegerDigits = newValue;
1395     touchNoError();
1396 }
1397 
1398 void DecimalFormat::setMaximumFractionDigits(int32_t newValue) {
<a name="117" id="anc117"></a><span class="line-added">1399     if (fields == nullptr) { return; }</span>
1400     if (newValue == fields-&gt;properties-&gt;maximumFractionDigits) { return; }
1401     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
1402     int32_t min = fields-&gt;properties-&gt;minimumFractionDigits;
1403     if (min &gt;= 0 &amp;&amp; min &gt; newValue) {
1404         fields-&gt;properties-&gt;minimumFractionDigits = newValue;
1405     }
1406     fields-&gt;properties-&gt;maximumFractionDigits = newValue;
1407     touchNoError();
1408 }
1409 
1410 void DecimalFormat::setMinimumFractionDigits(int32_t newValue) {
<a name="118" id="anc118"></a><span class="line-added">1411     if (fields == nullptr) { return; }</span>
1412     if (newValue == fields-&gt;properties-&gt;minimumFractionDigits) { return; }
1413     // For backwards compatibility, conflicting min/max need to keep the most recent setting.
1414     int32_t max = fields-&gt;properties-&gt;maximumFractionDigits;
1415     if (max &gt;= 0 &amp;&amp; max &lt; newValue) {
1416         fields-&gt;properties-&gt;maximumFractionDigits = newValue;
1417     }
1418     fields-&gt;properties-&gt;minimumFractionDigits = newValue;
1419     touchNoError();
1420 }
1421 
1422 int32_t DecimalFormat::getMinimumSignificantDigits() const {
<a name="119" id="anc119"></a><span class="line-added">1423     // Not much we can do to report an error.</span>
<span class="line-added">1424     if (fields == nullptr) {</span>
<span class="line-added">1425         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1426         return DecimalFormatProperties::getDefault().minimumSignificantDigits;</span>
<span class="line-added">1427     }</span>
1428     return fields-&gt;exportedProperties-&gt;minimumSignificantDigits;
1429 }
1430 
1431 int32_t DecimalFormat::getMaximumSignificantDigits() const {
<a name="120" id="anc120"></a><span class="line-added">1432     // Not much we can do to report an error.</span>
<span class="line-added">1433     if (fields == nullptr) {</span>
<span class="line-added">1434         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1435         return DecimalFormatProperties::getDefault().maximumSignificantDigits;</span>
<span class="line-added">1436     }</span>
1437     return fields-&gt;exportedProperties-&gt;maximumSignificantDigits;
1438 }
1439 
1440 void DecimalFormat::setMinimumSignificantDigits(int32_t value) {
<a name="121" id="anc121"></a><span class="line-added">1441     if (fields == nullptr) { return; }</span>
1442     if (value == fields-&gt;properties-&gt;minimumSignificantDigits) { return; }
1443     int32_t max = fields-&gt;properties-&gt;maximumSignificantDigits;
1444     if (max &gt;= 0 &amp;&amp; max &lt; value) {
1445         fields-&gt;properties-&gt;maximumSignificantDigits = value;
1446     }
1447     fields-&gt;properties-&gt;minimumSignificantDigits = value;
1448     touchNoError();
1449 }
1450 
1451 void DecimalFormat::setMaximumSignificantDigits(int32_t value) {
<a name="122" id="anc122"></a><span class="line-added">1452     if (fields == nullptr) { return; }</span>
1453     if (value == fields-&gt;properties-&gt;maximumSignificantDigits) { return; }
1454     int32_t min = fields-&gt;properties-&gt;minimumSignificantDigits;
1455     if (min &gt;= 0 &amp;&amp; min &gt; value) {
1456         fields-&gt;properties-&gt;minimumSignificantDigits = value;
1457     }
1458     fields-&gt;properties-&gt;maximumSignificantDigits = value;
1459     touchNoError();
1460 }
1461 
1462 UBool DecimalFormat::areSignificantDigitsUsed() const {
<a name="123" id="anc123"></a><span class="line-modified">1463     const DecimalFormatProperties* dfp;</span>
<span class="line-added">1464     // Not much we can do to report an error.</span>
<span class="line-added">1465     if (fields == nullptr) {</span>
<span class="line-added">1466         // Fallback to using the default instance of DecimalFormatProperties.</span>
<span class="line-added">1467         dfp = &amp;(DecimalFormatProperties::getDefault());</span>
<span class="line-added">1468     } else {</span>
<span class="line-added">1469         dfp = fields-&gt;properties.getAlias();</span>
<span class="line-added">1470     }</span>
<span class="line-added">1471     return dfp-&gt;minimumSignificantDigits != -1 || dfp-&gt;maximumSignificantDigits != -1;</span>
1472 }
1473 
1474 void DecimalFormat::setSignificantDigitsUsed(UBool useSignificantDigits) {
<a name="124" id="anc124"></a><span class="line-added">1475     if (fields == nullptr) { return; }</span>
<span class="line-added">1476 </span>
1477     // These are the default values from the old implementation.
<a name="125" id="anc125"></a><span class="line-added">1478     if (useSignificantDigits) {</span>
<span class="line-added">1479         if (fields-&gt;properties-&gt;minimumSignificantDigits != -1 ||</span>
<span class="line-added">1480             fields-&gt;properties-&gt;maximumSignificantDigits != -1) {</span>
<span class="line-added">1481             return;</span>
<span class="line-added">1482         }</span>
<span class="line-added">1483     } else {</span>
<span class="line-added">1484         if (fields-&gt;properties-&gt;minimumSignificantDigits == -1 &amp;&amp;</span>
<span class="line-added">1485             fields-&gt;properties-&gt;maximumSignificantDigits == -1) {</span>
<span class="line-added">1486             return;</span>
<span class="line-added">1487         }</span>
<span class="line-added">1488     }</span>
1489     int32_t minSig = useSignificantDigits ? 1 : -1;
1490     int32_t maxSig = useSignificantDigits ? 6 : -1;
<a name="126" id="anc126"></a>



1491     fields-&gt;properties-&gt;minimumSignificantDigits = minSig;
1492     fields-&gt;properties-&gt;maximumSignificantDigits = maxSig;
1493     touchNoError();
1494 }
1495 
1496 void DecimalFormat::setCurrency(const char16_t* theCurrency, UErrorCode&amp; ec) {
<a name="127" id="anc127"></a><span class="line-added">1497     // don&#39;t overwrite ec if it&#39;s already a failure.</span>
<span class="line-added">1498     if (U_FAILURE(ec)) { return; }</span>
<span class="line-added">1499     if (fields == nullptr) {</span>
<span class="line-added">1500         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1501         ec = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1502         return;</span>
<span class="line-added">1503     }</span>
1504     CurrencyUnit currencyUnit(theCurrency, ec);
1505     if (U_FAILURE(ec)) { return; }
1506     if (!fields-&gt;properties-&gt;currency.isNull() &amp;&amp; fields-&gt;properties-&gt;currency.getNoError() == currencyUnit) {
1507         return;
1508     }
1509     NumberFormat::setCurrency(theCurrency, ec); // to set field for compatibility
1510     fields-&gt;properties-&gt;currency = currencyUnit;
1511     // TODO: Set values in fields-&gt;symbols, too?
1512     touchNoError();
1513 }
1514 
1515 void DecimalFormat::setCurrency(const char16_t* theCurrency) {
1516     ErrorCode localStatus;
1517     setCurrency(theCurrency, localStatus);
1518 }
1519 
1520 void DecimalFormat::setCurrencyUsage(UCurrencyUsage newUsage, UErrorCode* ec) {
<a name="128" id="anc128"></a><span class="line-modified">1521     // don&#39;t overwrite ec if it&#39;s already a failure.</span>
<span class="line-added">1522     if (U_FAILURE(*ec)) { return; }</span>
<span class="line-added">1523     if (fields == nullptr) {</span>
<span class="line-added">1524         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1525         *ec = U_MEMORY_ALLOCATION_ERROR;</span>
1526         return;
1527     }
1528     if (!fields-&gt;properties-&gt;currencyUsage.isNull() &amp;&amp; newUsage == fields-&gt;properties-&gt;currencyUsage.getNoError()) {
1529         return;
1530     }
1531     fields-&gt;properties-&gt;currencyUsage = newUsage;
1532     touch(*ec);
1533 }
1534 
1535 UCurrencyUsage DecimalFormat::getCurrencyUsage() const {
1536     // CurrencyUsage is not exported, so we have to get it from the input property bag.
1537     // TODO: Should we export CurrencyUsage instead?
<a name="129" id="anc129"></a><span class="line-modified">1538     if (fields == nullptr || fields-&gt;properties-&gt;currencyUsage.isNull()) {</span>
1539         return UCURR_USAGE_STANDARD;
1540     }
1541     return fields-&gt;properties-&gt;currencyUsage.getNoError();
1542 }
1543 
1544 void
1545 DecimalFormat::formatToDecimalQuantity(double number, DecimalQuantity&amp; output, UErrorCode&amp; status) const {
<a name="130" id="anc130"></a><span class="line-added">1546     // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">1547     if (U_FAILURE(status)) { return; }</span>
<span class="line-added">1548     if (fields == nullptr) {</span>
<span class="line-added">1549         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1550         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1551         return;</span>
<span class="line-added">1552     }</span>
1553     fields-&gt;formatter-&gt;formatDouble(number, status).getDecimalQuantity(output, status);
1554 }
1555 
1556 void DecimalFormat::formatToDecimalQuantity(const Formattable&amp; number, DecimalQuantity&amp; output,
1557                                             UErrorCode&amp; status) const {
<a name="131" id="anc131"></a><span class="line-added">1558     // don&#39;t overwrite status if it&#39;s already a failure.</span>
<span class="line-added">1559     if (U_FAILURE(status)) { return; }</span>
<span class="line-added">1560     if (fields == nullptr) {</span>
<span class="line-added">1561         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1562         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1563         return;</span>
<span class="line-added">1564     }</span>
1565     UFormattedNumberData obj;
1566     number.populateDecimalQuantity(obj.quantity, status);
1567     fields-&gt;formatter-&gt;formatImpl(&amp;obj, status);
1568     output = std::move(obj.quantity);
1569 }
1570 
<a name="132" id="anc132"></a><span class="line-added">1571 const number::LocalizedNumberFormatter* DecimalFormat::toNumberFormatter(UErrorCode&amp; status) const {</span>
<span class="line-added">1572     // We sometimes need to return nullptr here (see ICU-20380)</span>
<span class="line-added">1573     if (U_FAILURE(status)) { return nullptr; }</span>
<span class="line-added">1574     if (fields == nullptr) {</span>
<span class="line-added">1575         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1576         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1577         return nullptr;</span>
<span class="line-added">1578     }</span>
<span class="line-added">1579     return &amp;*fields-&gt;formatter;</span>
<span class="line-added">1580 }</span>
<span class="line-added">1581 </span>
1582 const number::LocalizedNumberFormatter&amp; DecimalFormat::toNumberFormatter() const {
<a name="133" id="anc133"></a><span class="line-modified">1583     UErrorCode localStatus = U_ZERO_ERROR;</span>
<span class="line-added">1584     return *toNumberFormatter(localStatus);</span>
1585 }
1586 
1587 /** Rebuilds the formatter object from the property bag. */
1588 void DecimalFormat::touch(UErrorCode&amp; status) {
<a name="134" id="anc134"></a><span class="line-modified">1589     if (U_FAILURE(status)) {</span>
<span class="line-modified">1590         return;</span>
<span class="line-modified">1591     }</span>
<span class="line-added">1592     if (fields == nullptr) {</span>
<span class="line-added">1593         // We only get here if an OOM error happend during construction, copy construction, assignment, or modification.</span>
<span class="line-added">1594         // For regular construction, the caller should have checked the status variable for errors.</span>
<span class="line-added">1595         // For copy construction, there is unfortunately nothing to report the error, so we need to guard against</span>
<span class="line-added">1596         // this possible bad state here and set the status to an error.</span>
<span class="line-added">1597         status = U_MEMORY_ALLOCATION_ERROR;</span>
1598         return;
1599     }
1600 
1601     // In C++, fields-&gt;symbols is the source of truth for the locale.
1602     Locale locale = fields-&gt;symbols-&gt;getLocale();
1603 
1604     // Note: The formatter is relatively cheap to create, and we need it to populate fields-&gt;exportedProperties,
<a name="135" id="anc135"></a><span class="line-modified">1605     // so automatically recompute it here. The parser is a bit more expensive and is not needed until the</span>
1606     // parse method is called, so defer that until needed.
1607     // TODO: Only update the pieces that changed instead of re-computing the whole formatter?
<a name="136" id="anc136"></a><span class="line-modified">1608 </span>
<span class="line-modified">1609     // Since memory has already been allocated for the formatter, we can move assign a stack-allocated object</span>
<span class="line-modified">1610     // and don&#39;t need to call new. (Which is slower and could possibly fail).</span>
<span class="line-modified">1611     *fields-&gt;formatter = NumberPropertyMapper::create(</span>
<span class="line-modified">1612         *fields-&gt;properties, *fields-&gt;symbols, fields-&gt;warehouse, *fields-&gt;exportedProperties, status).locale(</span>
<span class="line-added">1613             locale);</span>
1614 
1615     // Do this after fields-&gt;exportedProperties are set up
1616     setupFastFormat();
1617 
1618     // Delete the parsers if they were made previously
1619     delete fields-&gt;atomicParser.exchange(nullptr);
1620     delete fields-&gt;atomicCurrencyParser.exchange(nullptr);
1621 
1622     // In order for the getters to work, we need to populate some fields in NumberFormat.
1623     NumberFormat::setCurrency(fields-&gt;exportedProperties-&gt;currency.get(status).getISOCurrency(), status);
1624     NumberFormat::setMaximumIntegerDigits(fields-&gt;exportedProperties-&gt;maximumIntegerDigits);
1625     NumberFormat::setMinimumIntegerDigits(fields-&gt;exportedProperties-&gt;minimumIntegerDigits);
1626     NumberFormat::setMaximumFractionDigits(fields-&gt;exportedProperties-&gt;maximumFractionDigits);
1627     NumberFormat::setMinimumFractionDigits(fields-&gt;exportedProperties-&gt;minimumFractionDigits);
1628     // fImpl-&gt;properties, not fields-&gt;exportedProperties, since this information comes from the pattern:
1629     NumberFormat::setGroupingUsed(fields-&gt;properties-&gt;groupingUsed);
1630 }
1631 
1632 void DecimalFormat::touchNoError() {
1633     UErrorCode localStatus = U_ZERO_ERROR;
1634     touch(localStatus);
1635 }
1636 
1637 void DecimalFormat::setPropertiesFromPattern(const UnicodeString&amp; pattern, int32_t ignoreRounding,
1638                                              UErrorCode&amp; status) {
1639     if (U_SUCCESS(status)) {
1640         // Cast workaround to get around putting the enum in the public header file
1641         auto actualIgnoreRounding = static_cast&lt;IgnoreRounding&gt;(ignoreRounding);
1642         PatternParser::parseToExistingProperties(pattern, *fields-&gt;properties,  actualIgnoreRounding, status);
1643     }
1644 }
1645 
1646 const numparse::impl::NumberParserImpl* DecimalFormat::getParser(UErrorCode&amp; status) const {
<a name="137" id="anc137"></a><span class="line-modified">1647     // TODO: Move this into umutex.h? (similar logic also in numrange_fluent.cpp)</span>
<span class="line-added">1648     // See ICU-20146</span>
<span class="line-added">1649 </span>
<span class="line-added">1650     if (U_FAILURE(status)) {</span>
<span class="line-added">1651         return nullptr;</span>
<span class="line-added">1652     }</span>
1653 
1654     // First try to get the pre-computed parser
1655     auto* ptr = fields-&gt;atomicParser.load();
1656     if (ptr != nullptr) {
1657         return ptr;
1658     }
1659 
1660     // Try computing the parser on our own
1661     auto* temp = NumberParserImpl::createParserFromProperties(*fields-&gt;properties, *fields-&gt;symbols, false, status);
<a name="138" id="anc138"></a><span class="line-added">1662     if (U_FAILURE(status)) {</span>
<span class="line-added">1663         return nullptr;</span>
<span class="line-added">1664     }</span>
1665     if (temp == nullptr) {
1666         status = U_MEMORY_ALLOCATION_ERROR;
<a name="139" id="anc139"></a><span class="line-modified">1667         return nullptr;</span>
1668     }
1669 
<a name="140" id="anc140"></a><span class="line-modified">1670     // Note: ptr starts as nullptr; during compare_exchange,</span>
<span class="line-modified">1671     // it is set to what is actually stored in the atomic</span>
<span class="line-added">1672     // if another thread beat us to computing the parser object.</span>
1673     auto* nonConstThis = const_cast&lt;DecimalFormat*&gt;(this);
1674     if (!nonConstThis-&gt;fields-&gt;atomicParser.compare_exchange_strong(ptr, temp)) {
1675         // Another thread beat us to computing the parser
1676         delete temp;
1677         return ptr;
1678     } else {
1679         // Our copy of the parser got stored in the atomic
1680         return temp;
1681     }
1682 }
1683 
1684 const numparse::impl::NumberParserImpl* DecimalFormat::getCurrencyParser(UErrorCode&amp; status) const {
1685     if (U_FAILURE(status)) { return nullptr; }
1686 
1687     // First try to get the pre-computed parser
1688     auto* ptr = fields-&gt;atomicCurrencyParser.load();
1689     if (ptr != nullptr) {
1690         return ptr;
1691     }
1692 
1693     // Try computing the parser on our own
1694     auto* temp = NumberParserImpl::createParserFromProperties(*fields-&gt;properties, *fields-&gt;symbols, true, status);
1695     if (temp == nullptr) {
1696         status = U_MEMORY_ALLOCATION_ERROR;
1697         // although we may still dereference, call sites should be guarded
1698     }
1699 
1700     // Note: ptr starts as nullptr; during compare_exchange, it is set to what is actually stored in the
1701     // atomic if another thread beat us to computing the parser object.
1702     auto* nonConstThis = const_cast&lt;DecimalFormat*&gt;(this);
1703     if (!nonConstThis-&gt;fields-&gt;atomicCurrencyParser.compare_exchange_strong(ptr, temp)) {
1704         // Another thread beat us to computing the parser
1705         delete temp;
1706         return ptr;
1707     } else {
1708         // Our copy of the parser got stored in the atomic
1709         return temp;
1710     }
1711 }
1712 
1713 void
1714 DecimalFormat::fieldPositionHelper(const number::FormattedNumber&amp; formatted, FieldPosition&amp; fieldPosition,
1715                                    int32_t offset, UErrorCode&amp; status) {
<a name="141" id="anc141"></a><span class="line-added">1716     if (U_FAILURE(status)) { return; }</span>
1717     // always return first occurrence:
1718     fieldPosition.setBeginIndex(0);
1719     fieldPosition.setEndIndex(0);
1720     bool found = formatted.nextFieldPosition(fieldPosition, status);
1721     if (found &amp;&amp; offset != 0) {
1722         FieldPositionOnlyHandler fpoh(fieldPosition);
1723         fpoh.shiftLast(offset);
1724     }
1725 }
1726 
1727 void
1728 DecimalFormat::fieldPositionIteratorHelper(const number::FormattedNumber&amp; formatted, FieldPositionIterator* fpi,
1729                                            int32_t offset, UErrorCode&amp; status) {
<a name="142" id="anc142"></a><span class="line-modified">1730     if (U_SUCCESS(status) &amp;&amp; (fpi != nullptr)) {</span>
1731         FieldPositionIteratorHandler fpih(fpi, status);
1732         fpih.setShift(offset);
1733         formatted.getAllFieldPositionsImpl(fpih, status);
1734     }
1735 }
1736 
1737 // To debug fast-format, change void(x) to printf(x)
1738 #define trace(x) void(x)
1739 
1740 void DecimalFormat::setupFastFormat() {
1741     // Check the majority of properties:
1742     if (!fields-&gt;properties-&gt;equalsDefaultExceptFastFormat()) {
1743         trace(&quot;no fast format: equality\n&quot;);
1744         fields-&gt;canUseFastFormat = false;
1745         return;
1746     }
1747 
1748     // Now check the remaining properties.
1749     // Nontrivial affixes:
1750     UBool trivialPP = fields-&gt;properties-&gt;positivePrefixPattern.isEmpty();
1751     UBool trivialPS = fields-&gt;properties-&gt;positiveSuffixPattern.isEmpty();
1752     UBool trivialNP = fields-&gt;properties-&gt;negativePrefixPattern.isBogus() || (
1753             fields-&gt;properties-&gt;negativePrefixPattern.length() == 1 &amp;&amp;
1754             fields-&gt;properties-&gt;negativePrefixPattern.charAt(0) == u&#39;-&#39;);
1755     UBool trivialNS = fields-&gt;properties-&gt;negativeSuffixPattern.isEmpty();
1756     if (!trivialPP || !trivialPS || !trivialNP || !trivialNS) {
1757         trace(&quot;no fast format: affixes\n&quot;);
1758         fields-&gt;canUseFastFormat = false;
1759         return;
1760     }
1761 
1762     // Grouping (secondary grouping is forbidden in equalsDefaultExceptFastFormat):
1763     bool groupingUsed = fields-&gt;properties-&gt;groupingUsed;
1764     int32_t groupingSize = fields-&gt;properties-&gt;groupingSize;
1765     bool unusualGroupingSize = groupingSize &gt; 0 &amp;&amp; groupingSize != 3;
1766     const UnicodeString&amp; groupingString = fields-&gt;symbols-&gt;getConstSymbol(DecimalFormatSymbols::kGroupingSeparatorSymbol);
1767     if (groupingUsed &amp;&amp; (unusualGroupingSize || groupingString.length() != 1)) {
1768         trace(&quot;no fast format: grouping\n&quot;);
1769         fields-&gt;canUseFastFormat = false;
1770         return;
1771     }
1772 
1773     // Integer length:
1774     int32_t minInt = fields-&gt;exportedProperties-&gt;minimumIntegerDigits;
1775     int32_t maxInt = fields-&gt;exportedProperties-&gt;maximumIntegerDigits;
1776     // Fastpath supports up to only 10 digits (length of INT32_MIN)
1777     if (minInt &gt; 10) {
1778         trace(&quot;no fast format: integer\n&quot;);
1779         fields-&gt;canUseFastFormat = false;
1780         return;
1781     }
1782 
1783     // Fraction length (no fraction part allowed in fast path):
1784     int32_t minFrac = fields-&gt;exportedProperties-&gt;minimumFractionDigits;
1785     if (minFrac &gt; 0) {
1786         trace(&quot;no fast format: fraction\n&quot;);
1787         fields-&gt;canUseFastFormat = false;
1788         return;
1789     }
1790 
1791     // Other symbols:
1792     const UnicodeString&amp; minusSignString = fields-&gt;symbols-&gt;getConstSymbol(DecimalFormatSymbols::kMinusSignSymbol);
1793     UChar32 codePointZero = fields-&gt;symbols-&gt;getCodePointZero();
1794     if (minusSignString.length() != 1 || U16_LENGTH(codePointZero) != 1) {
1795         trace(&quot;no fast format: symbols\n&quot;);
1796         fields-&gt;canUseFastFormat = false;
1797         return;
1798     }
1799 
1800     // Good to go!
1801     trace(&quot;can use fast format!\n&quot;);
1802     fields-&gt;canUseFastFormat = true;
1803     fields-&gt;fastData.cpZero = static_cast&lt;char16_t&gt;(codePointZero);
1804     fields-&gt;fastData.cpGroupingSeparator = groupingUsed &amp;&amp; groupingSize == 3 ? groupingString.charAt(0) : 0;
1805     fields-&gt;fastData.cpMinusSign = minusSignString.charAt(0);
1806     fields-&gt;fastData.minInt = (minInt &lt; 0 || minInt &gt; 127) ? 0 : static_cast&lt;int8_t&gt;(minInt);
1807     fields-&gt;fastData.maxInt = (maxInt &lt; 0 || maxInt &gt; 127) ? 127 : static_cast&lt;int8_t&gt;(maxInt);
1808 }
1809 
1810 bool DecimalFormat::fastFormatDouble(double input, UnicodeString&amp; output) const {
1811     if (!fields-&gt;canUseFastFormat) {
1812         return false;
1813     }
1814     if (std::isnan(input)
1815             || std::trunc(input) != input
1816             || input &lt;= INT32_MIN
1817             || input &gt; INT32_MAX) {
1818         return false;
1819     }
1820     doFastFormatInt32(static_cast&lt;int32_t&gt;(input), std::signbit(input), output);
1821     return true;
1822 }
1823 
1824 bool DecimalFormat::fastFormatInt64(int64_t input, UnicodeString&amp; output) const {
1825     if (!fields-&gt;canUseFastFormat) {
1826         return false;
1827     }
1828     if (input &lt;= INT32_MIN || input &gt; INT32_MAX) {
1829         return false;
1830     }
1831     doFastFormatInt32(static_cast&lt;int32_t&gt;(input), input &lt; 0, output);
1832     return true;
1833 }
1834 
1835 void DecimalFormat::doFastFormatInt32(int32_t input, bool isNegative, UnicodeString&amp; output) const {
1836     U_ASSERT(fields-&gt;canUseFastFormat);
1837     if (isNegative) {
1838         output.append(fields-&gt;fastData.cpMinusSign);
1839         U_ASSERT(input != INT32_MIN);  // handled by callers
1840         input = -input;
1841     }
1842     // Cap at int32_t to make the buffer small and operations fast.
1843     // Longest string: &quot;2,147,483,648&quot; (13 chars in length)
1844     static constexpr int32_t localCapacity = 13;
1845     char16_t localBuffer[localCapacity];
1846     char16_t* ptr = localBuffer + localCapacity;
1847     int8_t group = 0;
1848     for (int8_t i = 0; i &lt; fields-&gt;fastData.maxInt &amp;&amp; (input != 0 || i &lt; fields-&gt;fastData.minInt); i++) {
1849         if (group++ == 3 &amp;&amp; fields-&gt;fastData.cpGroupingSeparator != 0) {
1850             *(--ptr) = fields-&gt;fastData.cpGroupingSeparator;
1851             group = 1;
1852         }
1853         std::div_t res = std::div(input, 10);
1854         *(--ptr) = static_cast&lt;char16_t&gt;(fields-&gt;fastData.cpZero + res.rem);
1855         input = res.quot;
1856     }
1857     int32_t len = localCapacity - static_cast&lt;int32_t&gt;(ptr - localBuffer);
1858     output.append(ptr, len);
1859 }
1860 
1861 
1862 #endif /* #if !UCONFIG_NO_FORMATTING */
<a name="143" id="anc143"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="143" type="hidden" />
</body>
</html>