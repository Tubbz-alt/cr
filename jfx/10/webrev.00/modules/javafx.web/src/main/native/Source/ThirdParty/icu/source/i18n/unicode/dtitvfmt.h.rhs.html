<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/dtitvfmt.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /********************************************************************************
   4 * Copyright (C) 2008-2016, International Business Machines Corporation and
   5 * others. All Rights Reserved.
   6 *******************************************************************************
   7 *
   8 * File DTITVFMT.H
   9 *
  10 *******************************************************************************
  11 */
  12 
  13 #ifndef __DTITVFMT_H__
  14 #define __DTITVFMT_H__
  15 
  16 
  17 #include &quot;unicode/utypes.h&quot;
  18 
  19 /**
  20  * \file
  21  * \brief C++ API: Format and parse date interval in a language-independent manner.
  22  */
  23 
  24 #if !UCONFIG_NO_FORMATTING
  25 
  26 #include &quot;unicode/ucal.h&quot;
  27 #include &quot;unicode/smpdtfmt.h&quot;
  28 #include &quot;unicode/dtintrv.h&quot;
  29 #include &quot;unicode/dtitvinf.h&quot;
  30 #include &quot;unicode/dtptngen.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  31 #include &quot;unicode/formattedvalue.h&quot;</span>
  32 
  33 U_NAMESPACE_BEGIN
  34 
  35 
<a name="2" id="anc2"></a><span class="line-added">  36 class FormattedDateIntervalData;</span>
<span class="line-added">  37 class DateIntervalFormat;</span>
<span class="line-added">  38 </span>
<span class="line-added">  39 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added">  40 /**</span>
<span class="line-added">  41  * An immutable class containing the result of a date interval formatting operation.</span>
<span class="line-added">  42  *</span>
<span class="line-added">  43  * Instances of this class are immutable and thread-safe.</span>
<span class="line-added">  44  *</span>
<span class="line-added">  45  * When calling nextPosition():</span>
<span class="line-added">  46  * The fields are returned from left to right. The special field category</span>
<span class="line-added">  47  * UFIELD_CATEGORY_DATE_INTERVAL_SPAN is used to indicate which datetime</span>
<span class="line-added">  48  * primitives came from which arguments: 0 means fromCalendar, and 1 means</span>
<span class="line-added">  49  * toCalendar. The span category will always occur before the</span>
<span class="line-added">  50  * corresponding fields in UFIELD_CATEGORY_DATE</span>
<span class="line-added">  51  * in the nextPosition() iterator.</span>
<span class="line-added">  52  *</span>
<span class="line-added">  53  * Not intended for public subclassing.</span>
<span class="line-added">  54  *</span>
<span class="line-added">  55  * @draft ICU 64</span>
<span class="line-added">  56  */</span>
<span class="line-added">  57 class U_I18N_API FormattedDateInterval : public UMemory, public FormattedValue {</span>
<span class="line-added">  58   public:</span>
<span class="line-added">  59     /**</span>
<span class="line-added">  60      * Default constructor; makes an empty FormattedDateInterval.</span>
<span class="line-added">  61      * @draft ICU 64</span>
<span class="line-added">  62      */</span>
<span class="line-added">  63     FormattedDateInterval() : fData(nullptr), fErrorCode(U_INVALID_STATE_ERROR) {}</span>
<span class="line-added">  64 </span>
<span class="line-added">  65     /**</span>
<span class="line-added">  66      * Move constructor: Leaves the source FormattedDateInterval in an undefined state.</span>
<span class="line-added">  67      * @draft ICU 64</span>
<span class="line-added">  68      */</span>
<span class="line-added">  69     FormattedDateInterval(FormattedDateInterval&amp;&amp; src) U_NOEXCEPT;</span>
<span class="line-added">  70 </span>
<span class="line-added">  71     /**</span>
<span class="line-added">  72      * Destruct an instance of FormattedDateInterval.</span>
<span class="line-added">  73      * @draft ICU 64</span>
<span class="line-added">  74      */</span>
<span class="line-added">  75     virtual ~FormattedDateInterval() U_OVERRIDE;</span>
<span class="line-added">  76 </span>
<span class="line-added">  77     /** Copying not supported; use move constructor instead. */</span>
<span class="line-added">  78     FormattedDateInterval(const FormattedDateInterval&amp;) = delete;</span>
<span class="line-added">  79 </span>
<span class="line-added">  80     /** Copying not supported; use move assignment instead. */</span>
<span class="line-added">  81     FormattedDateInterval&amp; operator=(const FormattedDateInterval&amp;) = delete;</span>
<span class="line-added">  82 </span>
<span class="line-added">  83     /**</span>
<span class="line-added">  84      * Move assignment: Leaves the source FormattedDateInterval in an undefined state.</span>
<span class="line-added">  85      * @draft ICU 64</span>
<span class="line-added">  86      */</span>
<span class="line-added">  87     FormattedDateInterval&amp; operator=(FormattedDateInterval&amp;&amp; src) U_NOEXCEPT;</span>
<span class="line-added">  88 </span>
<span class="line-added">  89     /** @copydoc FormattedValue::toString() */</span>
<span class="line-added">  90     UnicodeString toString(UErrorCode&amp; status) const U_OVERRIDE;</span>
<span class="line-added">  91 </span>
<span class="line-added">  92     /** @copydoc FormattedValue::toTempString() */</span>
<span class="line-added">  93     UnicodeString toTempString(UErrorCode&amp; status) const U_OVERRIDE;</span>
<span class="line-added">  94 </span>
<span class="line-added">  95     /** @copydoc FormattedValue::appendTo() */</span>
<span class="line-added">  96     Appendable &amp;appendTo(Appendable&amp; appendable, UErrorCode&amp; status) const U_OVERRIDE;</span>
<span class="line-added">  97 </span>
<span class="line-added">  98     /** @copydoc FormattedValue::nextPosition() */</span>
<span class="line-added">  99     UBool nextPosition(ConstrainedFieldPosition&amp; cfpos, UErrorCode&amp; status) const U_OVERRIDE;</span>
<span class="line-added"> 100 </span>
<span class="line-added"> 101   private:</span>
<span class="line-added"> 102     FormattedDateIntervalData *fData;</span>
<span class="line-added"> 103     UErrorCode fErrorCode;</span>
<span class="line-added"> 104     explicit FormattedDateInterval(FormattedDateIntervalData *results)</span>
<span class="line-added"> 105         : fData(results), fErrorCode(U_ZERO_ERROR) {}</span>
<span class="line-added"> 106     explicit FormattedDateInterval(UErrorCode errorCode)</span>
<span class="line-added"> 107         : fData(nullptr), fErrorCode(errorCode) {}</span>
<span class="line-added"> 108     friend class DateIntervalFormat;</span>
<span class="line-added"> 109 };</span>
<span class="line-added"> 110 #endif /* U_HIDE_DRAFT_API */</span>
<span class="line-added"> 111 </span>
 112 
 113 /**
 114  * DateIntervalFormat is a class for formatting and parsing date
 115  * intervals in a language-independent manner.
 116  * Only formatting is supported, parsing is not supported.
 117  *
 118  * &lt;P&gt;
 119  * Date interval means from one date to another date,
 120  * for example, from &quot;Jan 11, 2008&quot; to &quot;Jan 18, 2008&quot;.
 121  * We introduced class DateInterval to represent it.
 122  * DateInterval is a pair of UDate, which is
 123  * the standard milliseconds since 24:00 GMT, Jan 1, 1970.
 124  *
 125  * &lt;P&gt;
 126  * DateIntervalFormat formats a DateInterval into
 127  * text as compactly as possible.
 128  * For example, the date interval format from &quot;Jan 11, 2008&quot; to &quot;Jan 18,. 2008&quot;
 129  * is &quot;Jan 11-18, 2008&quot; for English.
 130  * And it parses text into DateInterval,
 131  * although initially, parsing is not supported.
 132  *
 133  * &lt;P&gt;
 134  * There is no structural information in date time patterns.
 135  * For any punctuations and string literals inside a date time pattern,
 136  * we do not know whether it is just a separator, or a prefix, or a suffix.
 137  * Without such information, so, it is difficult to generate a sub-pattern
 138  * (or super-pattern) by algorithm.
 139  * So, formatting a DateInterval is pattern-driven. It is very
 140  * similar to formatting in SimpleDateFormat.
 141  * We introduce class DateIntervalInfo to save date interval
 142  * patterns, similar to date time pattern in SimpleDateFormat.
 143  *
 144  * &lt;P&gt;
 145  * Logically, the interval patterns are mappings
 146  * from (skeleton, the_largest_different_calendar_field)
 147  * to (date_interval_pattern).
 148  *
 149  * &lt;P&gt;
 150  * A skeleton
 151  * &lt;ol&gt;
 152  * &lt;li&gt;
 153  * only keeps the field pattern letter and ignores all other parts
 154  * in a pattern, such as space, punctuations, and string literals.
 155  * &lt;/li&gt;
 156  * &lt;li&gt;
 157  * hides the order of fields.
 158  * &lt;/li&gt;
 159  * &lt;li&gt;
 160  * might hide a field&#39;s pattern letter length.
 161  * &lt;/li&gt;
 162  * &lt;/ol&gt;
 163  *
 164  * For those non-digit calendar fields, the pattern letter length is
 165  * important, such as MMM, MMMM, and MMMMM; EEE and EEEE,
 166  * and the field&#39;s pattern letter length is honored.
 167  *
 168  * For the digit calendar fields,  such as M or MM, d or dd, yy or yyyy,
 169  * the field pattern length is ignored and the best match, which is defined
 170  * in date time patterns, will be returned without honor the field pattern
 171  * letter length in skeleton.
 172  *
 173  * &lt;P&gt;
 174  * The calendar fields we support for interval formatting are:
 175  * year, month, date, day-of-week, am-pm, hour, hour-of-day, minute, and second
 176  * (though we do not currently have specific intervalFormat date for skeletons
 177  * with seconds).
 178  * Those calendar fields can be defined in the following order:
 179  * year &gt;  month &gt; date &gt; hour (in day) &gt;  minute &gt; second
 180  *
 181  * The largest different calendar fields between 2 calendars is the
 182  * first different calendar field in above order.
 183  *
 184  * For example: the largest different calendar fields between &quot;Jan 10, 2007&quot;
 185  * and &quot;Feb 20, 2008&quot; is year.
 186  *
 187  * &lt;P&gt;
 188  * For other calendar fields, the compact interval formatting is not
 189  * supported. And the interval format will be fall back to fall-back
 190  * patterns, which is mostly &quot;{date0} - {date1}&quot;.
 191  *
 192  * &lt;P&gt;
 193  * There is a set of pre-defined static skeleton strings.
 194  * There are pre-defined interval patterns for those pre-defined skeletons
 195  * in locales&#39; resource files.
 196  * For example, for a skeleton UDAT_YEAR_ABBR_MONTH_DAY, which is  &amp;quot;yMMMd&amp;quot;,
 197  * in  en_US, if the largest different calendar field between date1 and date2
 198  * is &amp;quot;year&amp;quot;, the date interval pattern  is &amp;quot;MMM d, yyyy - MMM d, yyyy&amp;quot;,
 199  * such as &amp;quot;Jan 10, 2007 - Jan 10, 2008&amp;quot;.
 200  * If the largest different calendar field between date1 and date2 is &amp;quot;month&amp;quot;,
 201  * the date interval pattern is &amp;quot;MMM d - MMM d, yyyy&amp;quot;,
 202  * such as &amp;quot;Jan 10 - Feb 10, 2007&amp;quot;.
 203  * If the largest different calendar field between date1 and date2 is &amp;quot;day&amp;quot;,
 204  * the date interval pattern is &amp;quot;MMM d-d, yyyy&amp;quot;, such as &amp;quot;Jan 10-20, 2007&amp;quot;.
 205  *
 206  * For date skeleton, the interval patterns when year, or month, or date is
 207  * different are defined in resource files.
 208  * For time skeleton, the interval patterns when am/pm, or hour, or minute is
 209  * different are defined in resource files.
 210  *
 211  * &lt;P&gt;
 212  * If a skeleton is not found in a locale&#39;s DateIntervalInfo, which means
 213  * the interval patterns for the skeleton is not defined in resource file,
 214  * the interval pattern will falls back to the interval &quot;fallback&quot; pattern
 215  * defined in resource file.
 216  * If the interval &quot;fallback&quot; pattern is not defined, the default fall-back
 217  * is &quot;{date0} - {data1}&quot;.
 218  *
 219  * &lt;P&gt;
 220  * For the combination of date and time,
 221  * The rule to generate interval patterns are:
 222  * &lt;ol&gt;
 223  * &lt;li&gt;
 224  *    when the year, month, or day differs, falls back to fall-back
 225  *    interval pattern, which mostly is the concatenate the two original
 226  *    expressions with a separator between,
 227  *    For example, interval pattern from &quot;Jan 10, 2007 10:10 am&quot;
 228  *    to &quot;Jan 11, 2007 10:10am&quot; is
 229  *    &quot;Jan 10, 2007 10:10 am - Jan 11, 2007 10:10am&quot;
 230  * &lt;/li&gt;
 231  * &lt;li&gt;
 232  *    otherwise, present the date followed by the range expression
 233  *    for the time.
 234  *    For example, interval pattern from &quot;Jan 10, 2007 10:10 am&quot;
 235  *    to &quot;Jan 10, 2007 11:10am&quot; is &quot;Jan 10, 2007 10:10 am - 11:10am&quot;
 236  * &lt;/li&gt;
 237  * &lt;/ol&gt;
 238  *
 239  *
 240  * &lt;P&gt;
 241  * If two dates are the same, the interval pattern is the single date pattern.
 242  * For example, interval pattern from &quot;Jan 10, 2007&quot; to &quot;Jan 10, 2007&quot; is
 243  * &quot;Jan 10, 2007&quot;.
 244  *
 245  * Or if the presenting fields between 2 dates have the exact same values,
 246  * the interval pattern is the  single date pattern.
 247  * For example, if user only requests year and month,
 248  * the interval pattern from &quot;Jan 10, 2007&quot; to &quot;Jan 20, 2007&quot; is &quot;Jan 2007&quot;.
 249  *
 250  * &lt;P&gt;
 251  * DateIntervalFormat needs the following information for correct
 252  * formatting: time zone, calendar type, pattern, date format symbols,
 253  * and date interval patterns.
 254  * It can be instantiated in 2 ways:
 255  * &lt;ol&gt;
 256  * &lt;li&gt;
 257  *    create an instance using default or given locale plus given skeleton.
 258  *    Users are encouraged to created date interval formatter this way and
 259  *    to use the pre-defined skeleton macros, such as
 260  *    UDAT_YEAR_NUM_MONTH, which consists the calendar fields and
 261  *    the format style.
 262  * &lt;/li&gt;
 263  * &lt;li&gt;
 264  *    create an instance using default or given locale plus given skeleton
 265  *    plus a given DateIntervalInfo.
 266  *    This factory method is for powerful users who want to provide their own
 267  *    interval patterns.
 268  *    Locale provides the timezone, calendar, and format symbols information.
 269  *    Local plus skeleton provides full pattern information.
 270  *    DateIntervalInfo provides the date interval patterns.
 271  * &lt;/li&gt;
 272  * &lt;/ol&gt;
 273  *
 274  * &lt;P&gt;
 275  * For the calendar field pattern letter, such as G, y, M, d, a, h, H, m, s etc.
 276  * DateIntervalFormat uses the same syntax as that of
 277  * DateTime format.
 278  *
 279  * &lt;P&gt;
 280  * Code Sample: general usage
 281  * &lt;pre&gt;
 282  * \code
 283  *   // the date interval object which the DateIntervalFormat formats on
 284  *   // and parses into
 285  *   DateInterval*  dtInterval = new DateInterval(1000*3600*24, 1000*3600*24*2);
 286  *   UErrorCode status = U_ZERO_ERROR;
 287  *   DateIntervalFormat* dtIntervalFmt = DateIntervalFormat::createInstance(
 288  *                           UDAT_YEAR_MONTH_DAY,
 289  *                           Locale(&quot;en&quot;, &quot;GB&quot;, &quot;&quot;), status);
 290  *   UnicodeUnicodeString dateIntervalString;
 291  *   FieldPosition pos = 0;
 292  *   // formatting
 293  *   dtIntervalFmt-&gt;format(dtInterval, dateIntervalUnicodeString, pos, status);
 294  *   delete dtIntervalFmt;
 295  * \endcode
 296  * &lt;/pre&gt;
 297  */
<a name="3" id="anc3"></a>
 298 class U_I18N_API DateIntervalFormat : public Format {
 299 public:
 300 
 301     /**
 302      * Construct a DateIntervalFormat from skeleton and  the default locale.
 303      *
 304      * This is a convenient override of
 305      * createInstance(const UnicodeString&amp; skeleton, const Locale&amp; locale,
 306      *                UErrorCode&amp;)
 307      * with the value of locale as default locale.
 308      *
 309      * @param skeleton  the skeleton on which interval format based.
 310      * @param status    output param set to success/failure code on exit
 311      * @return          a date time interval formatter which the caller owns.
 312      * @stable ICU 4.0
 313      */
 314     static DateIntervalFormat* U_EXPORT2 createInstance(
 315                                                const UnicodeString&amp; skeleton,
 316                                                UErrorCode&amp; status);
 317 
 318     /**
 319      * Construct a DateIntervalFormat from skeleton and a given locale.
 320      * &lt;P&gt;
 321      * In this factory method,
 322      * the date interval pattern information is load from resource files.
 323      * Users are encouraged to created date interval formatter this way and
 324      * to use the pre-defined skeleton macros.
 325      *
 326      * &lt;P&gt;
 327      * There are pre-defined skeletons (defined in udate.h) having predefined
 328      * interval patterns in resource files.
 329      * Users are encouraged to use those macros.
 330      * For example:
 331      * DateIntervalFormat::createInstance(UDAT_MONTH_DAY, status)
 332      *
 333      * The given Locale provides the interval patterns.
 334      * For example, for en_GB, if skeleton is UDAT_YEAR_ABBR_MONTH_WEEKDAY_DAY,
 335      * which is &quot;yMMMEEEd&quot;,
 336      * the interval patterns defined in resource file to above skeleton are:
 337      * &quot;EEE, d MMM, yyyy - EEE, d MMM, yyyy&quot; for year differs,
 338      * &quot;EEE, d MMM - EEE, d MMM, yyyy&quot; for month differs,
 339      * &quot;EEE, d - EEE, d MMM, yyyy&quot; for day differs,
 340      * @param skeleton  the skeleton on which the interval format is based.
 341      * @param locale    the given locale
 342      * @param status    output param set to success/failure code on exit
 343      * @return          a date time interval formatter which the caller owns.
 344      * @stable ICU 4.0
 345      * &lt;p&gt;
 346      * &lt;h4&gt;Sample code&lt;/h4&gt;
 347      * \snippet samples/dtitvfmtsample/dtitvfmtsample.cpp dtitvfmtPreDefined1
 348      * \snippet samples/dtitvfmtsample/dtitvfmtsample.cpp dtitvfmtPreDefined
 349      * &lt;p&gt;
 350      */
 351 
 352     static DateIntervalFormat* U_EXPORT2 createInstance(
 353                                                const UnicodeString&amp; skeleton,
 354                                                const Locale&amp; locale,
 355                                                UErrorCode&amp; status);
 356 
 357     /**
 358      * Construct a DateIntervalFormat from skeleton
 359      *  DateIntervalInfo, and default locale.
 360      *
 361      * This is a convenient override of
 362      * createInstance(const UnicodeString&amp; skeleton, const Locale&amp; locale,
 363      *                const DateIntervalInfo&amp; dtitvinf, UErrorCode&amp;)
 364      * with the locale value as default locale.
 365      *
 366      * @param skeleton  the skeleton on which interval format based.
 367      * @param dtitvinf  the DateIntervalInfo object.
 368      * @param status    output param set to success/failure code on exit
 369      * @return          a date time interval formatter which the caller owns.
 370      * @stable ICU 4.0
 371      */
 372     static DateIntervalFormat* U_EXPORT2 createInstance(
 373                                               const UnicodeString&amp; skeleton,
 374                                               const DateIntervalInfo&amp; dtitvinf,
 375                                               UErrorCode&amp; status);
 376 
 377     /**
 378      * Construct a DateIntervalFormat from skeleton
 379      * a DateIntervalInfo, and the given locale.
 380      *
 381      * &lt;P&gt;
 382      * In this factory method, user provides its own date interval pattern
 383      * information, instead of using those pre-defined data in resource file.
 384      * This factory method is for powerful users who want to provide their own
 385      * interval patterns.
 386      * &lt;P&gt;
 387      * There are pre-defined skeletons (defined in udate.h) having predefined
 388      * interval patterns in resource files.
 389      * Users are encouraged to use those macros.
 390      * For example:
 391      * DateIntervalFormat::createInstance(UDAT_MONTH_DAY, status)
 392      *
 393      * The DateIntervalInfo provides the interval patterns.
 394      * and the DateIntervalInfo ownership remains to the caller.
 395      *
 396      * User are encouraged to set default interval pattern in DateIntervalInfo
 397      * as well, if they want to set other interval patterns ( instead of
 398      * reading the interval patterns from resource files).
 399      * When the corresponding interval pattern for a largest calendar different
 400      * field is not found ( if user not set it ), interval format fallback to
 401      * the default interval pattern.
 402      * If user does not provide default interval pattern, it fallback to
 403      * &quot;{date0} - {date1}&quot;
 404      *
 405      * @param skeleton  the skeleton on which interval format based.
 406      * @param locale    the given locale
 407      * @param dtitvinf  the DateIntervalInfo object.
 408      * @param status    output param set to success/failure code on exit
 409      * @return          a date time interval formatter which the caller owns.
 410      * @stable ICU 4.0
 411      * &lt;p&gt;
 412      * &lt;h4&gt;Sample code&lt;/h4&gt;
 413      * \snippet samples/dtitvfmtsample/dtitvfmtsample.cpp dtitvfmtPreDefined1
 414      * \snippet samples/dtitvfmtsample/dtitvfmtsample.cpp dtitvfmtCustomized
 415      * &lt;p&gt;
 416      */
 417     static DateIntervalFormat* U_EXPORT2 createInstance(
 418                                               const UnicodeString&amp; skeleton,
 419                                               const Locale&amp; locale,
 420                                               const DateIntervalInfo&amp; dtitvinf,
 421                                               UErrorCode&amp; status);
 422 
 423     /**
 424      * Destructor.
 425      * @stable ICU 4.0
 426      */
 427     virtual ~DateIntervalFormat();
 428 
 429     /**
 430      * Clone this Format object polymorphically. The caller owns the result and
 431      * should delete it when done.
 432      * @return    A copy of the object.
 433      * @stable ICU 4.0
 434      */
 435     virtual Format* clone(void) const;
 436 
 437     /**
 438      * Return true if the given Format objects are semantically equal. Objects
 439      * of different subclasses are considered unequal.
 440      * @param other    the object to be compared with.
 441      * @return         true if the given Format objects are semantically equal.
 442      * @stable ICU 4.0
 443      */
 444     virtual UBool operator==(const Format&amp; other) const;
 445 
 446     /**
 447      * Return true if the given Format objects are not semantically equal.
 448      * Objects of different subclasses are considered unequal.
 449      * @param other the object to be compared with.
 450      * @return      true if the given Format objects are not semantically equal.
 451      * @stable ICU 4.0
 452      */
 453     UBool operator!=(const Format&amp; other) const;
 454 
 455 
 456     using Format::format;
 457 
 458     /**
 459      * Format an object to produce a string. This method handles Formattable
 460      * objects with a DateInterval type.
 461      * If a the Formattable object type is not a DateInterval,
 462      * then it returns a failing UErrorCode.
 463      *
 464      * @param obj               The object to format.
 465      *                          Must be a DateInterval.
 466      * @param appendTo          Output parameter to receive result.
 467      *                          Result is appended to existing contents.
 468      * @param fieldPosition     On input: an alignment field, if desired.
 469      *                          On output: the offsets of the alignment field.
 470      *                          There may be multiple instances of a given field type
 471      *                          in an interval format; in this case the fieldPosition
 472      *                          offsets refer to the first instance.
 473      * @param status            Output param filled with success/failure status.
 474      * @return                  Reference to &#39;appendTo&#39; parameter.
 475      * @stable ICU 4.0
 476      */
 477     virtual UnicodeString&amp; format(const Formattable&amp; obj,
 478                                   UnicodeString&amp; appendTo,
 479                                   FieldPosition&amp; fieldPosition,
 480                                   UErrorCode&amp; status) const ;
 481 
 482 
 483 
 484     /**
 485      * Format a DateInterval to produce a string.
 486      *
 487      * @param dtInterval        DateInterval to be formatted.
 488      * @param appendTo          Output parameter to receive result.
 489      *                          Result is appended to existing contents.
 490      * @param fieldPosition     On input: an alignment field, if desired.
 491      *                          On output: the offsets of the alignment field.
 492      *                          There may be multiple instances of a given field type
 493      *                          in an interval format; in this case the fieldPosition
 494      *                          offsets refer to the first instance.
 495      * @param status            Output param filled with success/failure status.
 496      * @return                  Reference to &#39;appendTo&#39; parameter.
 497      * @stable ICU 4.0
 498      */
 499     UnicodeString&amp; format(const DateInterval* dtInterval,
 500                           UnicodeString&amp; appendTo,
 501                           FieldPosition&amp; fieldPosition,
 502                           UErrorCode&amp; status) const ;
 503 
<a name="4" id="anc4"></a><span class="line-added"> 504 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added"> 505     /**</span>
<span class="line-added"> 506      * Format a DateInterval to produce a FormattedDateInterval.</span>
<span class="line-added"> 507      *</span>
<span class="line-added"> 508      * The FormattedDateInterval exposes field information about the formatted string.</span>
<span class="line-added"> 509      *</span>
<span class="line-added"> 510      * @param dtInterval        DateInterval to be formatted.</span>
<span class="line-added"> 511      * @param status            Set if an error occurs.</span>
<span class="line-added"> 512      * @return                  A FormattedDateInterval containing the format result.</span>
<span class="line-added"> 513      * @draft ICU 64</span>
<span class="line-added"> 514      */</span>
<span class="line-added"> 515     FormattedDateInterval formatToValue(</span>
<span class="line-added"> 516         const DateInterval&amp; dtInterval,</span>
<span class="line-added"> 517         UErrorCode&amp; status) const;</span>
<span class="line-added"> 518 #endif /* U_HIDE_DRAFT_API */</span>
 519 
 520     /**
 521      * Format 2 Calendars to produce a string.
 522      *
 523      * Note: &quot;fromCalendar&quot; and &quot;toCalendar&quot; are not const,
 524      * since calendar is not const in  SimpleDateFormat::format(Calendar&amp;),
 525      *
 526      * @param fromCalendar      calendar set to the from date in date interval
 527      *                          to be formatted into date interval string
 528      * @param toCalendar        calendar set to the to date in date interval
 529      *                          to be formatted into date interval string
 530      * @param appendTo          Output parameter to receive result.
 531      *                          Result is appended to existing contents.
 532      * @param fieldPosition     On input: an alignment field, if desired.
 533      *                          On output: the offsets of the alignment field.
 534      *                          There may be multiple instances of a given field type
 535      *                          in an interval format; in this case the fieldPosition
 536      *                          offsets refer to the first instance.
 537      * @param status            Output param filled with success/failure status.
 538      *                          Caller needs to make sure it is SUCCESS
 539      *                          at the function entrance
 540      * @return                  Reference to &#39;appendTo&#39; parameter.
 541      * @stable ICU 4.0
 542      */
 543     UnicodeString&amp; format(Calendar&amp; fromCalendar,
 544                           Calendar&amp; toCalendar,
 545                           UnicodeString&amp; appendTo,
 546                           FieldPosition&amp; fieldPosition,
 547                           UErrorCode&amp; status) const ;
 548 
<a name="5" id="anc5"></a><span class="line-added"> 549 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added"> 550     /**</span>
<span class="line-added"> 551      * Format 2 Calendars to produce a FormattedDateInterval.</span>
<span class="line-added"> 552      *</span>
<span class="line-added"> 553      * The FormattedDateInterval exposes field information about the formatted string.</span>
<span class="line-added"> 554      *</span>
<span class="line-added"> 555      * Note: &quot;fromCalendar&quot; and &quot;toCalendar&quot; are not const,</span>
<span class="line-added"> 556      * since calendar is not const in  SimpleDateFormat::format(Calendar&amp;),</span>
<span class="line-added"> 557      *</span>
<span class="line-added"> 558      * @param fromCalendar      calendar set to the from date in date interval</span>
<span class="line-added"> 559      *                          to be formatted into date interval string</span>
<span class="line-added"> 560      * @param toCalendar        calendar set to the to date in date interval</span>
<span class="line-added"> 561      *                          to be formatted into date interval string</span>
<span class="line-added"> 562      * @param status            Set if an error occurs.</span>
<span class="line-added"> 563      * @return                  A FormattedDateInterval containing the format result.</span>
<span class="line-added"> 564      * @draft ICU 64</span>
<span class="line-added"> 565      */</span>
<span class="line-added"> 566     FormattedDateInterval formatToValue(</span>
<span class="line-added"> 567         Calendar&amp; fromCalendar,</span>
<span class="line-added"> 568         Calendar&amp; toCalendar,</span>
<span class="line-added"> 569         UErrorCode&amp; status) const;</span>
<span class="line-added"> 570 #endif /* U_HIDE_DRAFT_API */</span>
<span class="line-added"> 571 </span>
 572     /**
 573      * Date interval parsing is not supported. Please do not use.
 574      * &lt;P&gt;
 575      * This method should handle parsing of
 576      * date time interval strings into Formattable objects with
 577      * DateInterval type, which is a pair of UDate.
 578      * &lt;P&gt;
 579      * Before calling, set parse_pos.index to the offset you want to start
 580      * parsing at in the source. After calling, parse_pos.index is the end of
 581      * the text you parsed. If error occurs, index is unchanged.
 582      * &lt;P&gt;
 583      * When parsing, leading whitespace is discarded (with a successful parse),
 584      * while trailing whitespace is left as is.
 585      * &lt;P&gt;
 586      * See Format::parseObject() for more.
 587      *
 588      * @param source    The string to be parsed into an object.
 589      * @param result    Formattable to be set to the parse result.
 590      *                  If parse fails, return contents are undefined.
 591      * @param parse_pos The position to start parsing at. Since no parsing
 592      *                  is supported, upon return this param is unchanged.
 593      * @return          A newly created Formattable* object, or NULL
 594      *                  on failure.  The caller owns this and should
 595      *                  delete it when done.
 596      * @internal ICU 4.0
 597      */
 598     virtual void parseObject(const UnicodeString&amp; source,
 599                              Formattable&amp; result,
 600                              ParsePosition&amp; parse_pos) const;
 601 
 602 
 603     /**
 604      * Gets the date time interval patterns.
 605      * @return the date time interval patterns associated with
 606      * this date interval formatter.
 607      * @stable ICU 4.0
 608      */
 609     const DateIntervalInfo* getDateIntervalInfo(void) const;
 610 
 611 
 612     /**
 613      * Set the date time interval patterns.
 614      * @param newIntervalPatterns   the given interval patterns to copy.
 615      * @param status          output param set to success/failure code on exit
 616      * @stable ICU 4.0
 617      */
 618     void setDateIntervalInfo(const DateIntervalInfo&amp; newIntervalPatterns,
 619                              UErrorCode&amp; status);
 620 
 621 
 622     /**
 623      * Gets the date formatter. The DateIntervalFormat instance continues to own
 624      * the returned DateFormatter object, and will use and possibly modify it
 625      * during format operations. In a multi-threaded environment, the returned
 626      * DateFormat can only be used if it is certain that no other threads are
 627      * concurrently using this DateIntervalFormatter, even for nominally const
 628      * functions.
 629      *
 630      * @return the date formatter associated with this date interval formatter.
 631      * @stable ICU 4.0
 632      */
 633     const DateFormat* getDateFormat(void) const;
 634 
 635     /**
 636      * Returns a reference to the TimeZone used by this DateIntervalFormat&#39;s calendar.
 637      * @return the time zone associated with the calendar of DateIntervalFormat.
 638      * @stable ICU 4.8
 639      */
 640     virtual const TimeZone&amp; getTimeZone(void) const;
 641 
 642     /**
 643      * Sets the time zone for the calendar used by this DateIntervalFormat object. The
 644      * caller no longer owns the TimeZone object and should not delete it after this call.
 645      * @param zoneToAdopt the TimeZone to be adopted.
 646      * @stable ICU 4.8
 647      */
 648     virtual void adoptTimeZone(TimeZone* zoneToAdopt);
 649 
 650     /**
 651      * Sets the time zone for the calendar used by this DateIntervalFormat object.
 652      * @param zone the new time zone.
 653      * @stable ICU 4.8
 654      */
 655     virtual void setTimeZone(const TimeZone&amp; zone);
 656 
 657     /**
 658      * Return the class ID for this class. This is useful only for comparing to
 659      * a return value from getDynamicClassID(). For example:
 660      * &lt;pre&gt;
 661      * .   Base* polymorphic_pointer = createPolymorphicObject();
 662      * .   if (polymorphic_pointer-&gt;getDynamicClassID() ==
 663      * .       erived::getStaticClassID()) ...
 664      * &lt;/pre&gt;
 665      * @return          The class ID for all objects of this class.
 666      * @stable ICU 4.0
 667      */
 668     static UClassID U_EXPORT2 getStaticClassID(void);
 669 
 670     /**
 671      * Returns a unique class ID POLYMORPHICALLY. Pure virtual override. This
 672      * method is to implement a simple version of RTTI, since not all C++
 673      * compilers support genuine RTTI. Polymorphic operator==() and clone()
 674      * methods call this method.
 675      *
 676      * @return          The class ID for this object. All objects of a
 677      *                  given class have the same class ID.  Objects of
 678      *                  other classes have different class IDs.
 679      * @stable ICU 4.0
 680      */
 681     virtual UClassID getDynamicClassID(void) const;
 682 
 683 protected:
 684 
 685     /**
 686      * Copy constructor.
 687      * @stable ICU 4.0
 688      */
 689     DateIntervalFormat(const DateIntervalFormat&amp;);
 690 
 691     /**
 692      * Assignment operator.
 693      * @stable ICU 4.0
 694      */
 695     DateIntervalFormat&amp; operator=(const DateIntervalFormat&amp;);
 696 
 697 private:
 698 
 699     /*
 700      * This is for ICU internal use only. Please do not use.
 701      * Save the interval pattern information.
 702      * Interval pattern consists of 2 single date patterns and the separator.
 703      * For example, interval pattern &quot;MMM d - MMM d, yyyy&quot; consists
 704      * a single date pattern &quot;MMM d&quot;, another single date pattern &quot;MMM d, yyyy&quot;,
 705      * and a separator &quot;-&quot;.
 706      * The pattern is divided into 2 parts. For above example,
 707      * the first part is &quot;MMM d - &quot;, and the second part is &quot;MMM d, yyyy&quot;.
 708      * Also, the first date appears in an interval pattern could be
 709      * the earlier date or the later date.
 710      * And such information is saved in the interval pattern as well.
 711      */
 712     struct PatternInfo {
 713         UnicodeString firstPart;
 714         UnicodeString secondPart;
 715         /**
 716          * Whether the first date in interval pattern is later date or not.
 717          * Fallback format set the default ordering.
 718          * And for a particular interval pattern, the order can be
 719          * overriden by prefixing the interval pattern with &quot;latestFirst:&quot; or
 720          * &quot;earliestFirst:&quot;
 721          * For example, given 2 date, Jan 10, 2007 to Feb 10, 2007.
 722          * if the fallback format is &quot;{0} - {1}&quot;,
 723          * and the pattern is &quot;d MMM - d MMM yyyy&quot;, the interval format is
 724          * &quot;10 Jan - 10 Feb, 2007&quot;.
 725          * If the pattern is &quot;latestFirst:d MMM - d MMM yyyy&quot;,
 726          * the interval format is &quot;10 Feb - 10 Jan, 2007&quot;
 727          */
 728         UBool         laterDateFirst;
 729     };
 730 
 731 
 732     /**
 733      * default constructor
 734      * @internal (private)
 735      */
 736     DateIntervalFormat();
 737 
 738     /**
 739      * Construct a DateIntervalFormat from DateFormat,
 740      * a DateIntervalInfo, and skeleton.
 741      * DateFormat provides the timezone, calendar,
 742      * full pattern, and date format symbols information.
 743      * It should be a SimpleDateFormat object which
 744      * has a pattern in it.
 745      * the DateIntervalInfo provides the interval patterns.
 746      *
 747      * Note: the DateIntervalFormat takes ownership of both
 748      * DateFormat and DateIntervalInfo objects.
 749      * Caller should not delete them.
 750      *
 751      * @param locale    the locale of this date interval formatter.
 752      * @param dtItvInfo the DateIntervalInfo object to be adopted.
 753      * @param skeleton  the skeleton of the date formatter
 754      * @param status    output param set to success/failure code on exit
 755      */
 756     DateIntervalFormat(const Locale&amp; locale, DateIntervalInfo* dtItvInfo,
 757                        const UnicodeString* skeleton, UErrorCode&amp; status);
 758 
 759 
 760     /**
 761      * Construct a DateIntervalFormat from DateFormat
 762      * and a DateIntervalInfo.
 763      *
 764      * It is a wrapper of the constructor.
 765      *
 766      * @param locale    the locale of this date interval formatter.
 767      * @param dtitvinf  the DateIntervalInfo object to be adopted.
 768      * @param skeleton  the skeleton of this formatter.
 769      * @param status    Output param set to success/failure code.
 770      * @return          a date time interval formatter which the caller owns.
 771      */
 772     static DateIntervalFormat* U_EXPORT2 create(const Locale&amp; locale,
 773                                                 DateIntervalInfo* dtitvinf,
 774                                                 const UnicodeString* skeleton,
 775                                                 UErrorCode&amp; status);
 776 
 777     /**
 778      *  Below are for generating interval patterns local to the formatter
 779      */
 780 
<a name="6" id="anc6"></a><span class="line-modified"> 781     /** Like fallbackFormat, but only formats the range part of the fallback. */</span>
<span class="line-modified"> 782     void fallbackFormatRange(</span>
<span class="line-modified"> 783         Calendar&amp; fromCalendar,</span>
<span class="line-modified"> 784         Calendar&amp; toCalendar,</span>
<span class="line-modified"> 785         UnicodeString&amp; appendTo,</span>
<span class="line-modified"> 786         int8_t&amp; firstIndex,</span>
<span class="line-modified"> 787         FieldPositionHandler&amp; fphandler,</span>
<span class="line-modified"> 788         UErrorCode&amp; status) const;</span>














 789 
 790     /**
 791      * Format 2 Calendars using fall-back interval pattern
 792      *
 793      * The full pattern used in this fall-back format is the
 794      * full pattern of the date formatter.
 795      *
 796      * gFormatterMutex must already be locked when calling this function.
 797      *
 798      * @param fromCalendar      calendar set to the from date in date interval
 799      *                          to be formatted into date interval string
 800      * @param toCalendar        calendar set to the to date in date interval
 801      *                          to be formatted into date interval string
 802      * @param fromToOnSameDay   TRUE iff from and to dates are on the same day
 803      *                          (any difference is in ampm/hours or below)
 804      * @param appendTo          Output parameter to receive result.
 805      *                          Result is appended to existing contents.
<a name="7" id="anc7"></a><span class="line-modified"> 806      * @param firstIndex        See formatImpl for more information.</span>
<span class="line-modified"> 807      * @param fphandler         See formatImpl for more information.</span>
 808      * @param status            output param set to success/failure code on exit
 809      * @return                  Reference to &#39;appendTo&#39; parameter.
 810      * @internal (private)
 811      */
 812     UnicodeString&amp; fallbackFormat(Calendar&amp; fromCalendar,
 813                                   Calendar&amp; toCalendar,
 814                                   UBool fromToOnSameDay,
 815                                   UnicodeString&amp; appendTo,
<a name="8" id="anc8"></a><span class="line-modified"> 816                                   int8_t&amp; firstIndex,</span>
<span class="line-added"> 817                                   FieldPositionHandler&amp; fphandler,</span>
 818                                   UErrorCode&amp; status) const;
 819 
 820 
 821 
 822     /**
 823      * Initialize interval patterns locale to this formatter
 824      *
 825      * This code is a bit complicated since
 826      * 1. the interval patterns saved in resource bundle files are interval
 827      *    patterns based on date or time only.
 828      *    It does not have interval patterns based on both date and time.
 829      *    Interval patterns on both date and time are algorithm generated.
 830      *
 831      *    For example, it has interval patterns on skeleton &quot;dMy&quot; and &quot;hm&quot;,
 832      *    but it does not have interval patterns on skeleton &quot;dMyhm&quot;.
 833      *
 834      *    The rule to generate interval patterns for both date and time skeleton are
 835      *    1) when the year, month, or day differs, concatenate the two original
 836      *    expressions with a separator between,
 837      *    For example, interval pattern from &quot;Jan 10, 2007 10:10 am&quot;
 838      *    to &quot;Jan 11, 2007 10:10am&quot; is
 839      *    &quot;Jan 10, 2007 10:10 am - Jan 11, 2007 10:10am&quot;
 840      *
 841      *    2) otherwise, present the date followed by the range expression
 842      *    for the time.
 843      *    For example, interval pattern from &quot;Jan 10, 2007 10:10 am&quot;
 844      *    to &quot;Jan 10, 2007 11:10am&quot; is
 845      *    &quot;Jan 10, 2007 10:10 am - 11:10am&quot;
 846      *
 847      * 2. even a pattern does not request a certain calendar field,
 848      *    the interval pattern needs to include such field if such fields are
 849      *    different between 2 dates.
 850      *    For example, a pattern/skeleton is &quot;hm&quot;, but the interval pattern
 851      *    includes year, month, and date when year, month, and date differs.
 852      *
 853      *
 854      * @param status    output param set to success/failure code on exit
 855      */
 856     void initializePattern(UErrorCode&amp; status);
 857 
 858 
 859 
 860     /**
 861      * Set fall back interval pattern given a calendar field,
 862      * a skeleton, and a date time pattern generator.
 863      * @param field      the largest different calendar field
 864      * @param skeleton   a skeleton
 865      * @param status     output param set to success/failure code on exit
 866      */
 867     void setFallbackPattern(UCalendarDateFields field,
 868                             const UnicodeString&amp; skeleton,
 869                             UErrorCode&amp; status);
 870 
 871 
 872 
 873     /**
 874      * get separated date and time skeleton from a combined skeleton.
 875      *
 876      * The difference between date skeleton and normalizedDateSkeleton are:
 877      * 1. both &#39;y&#39; and &#39;d&#39; are appeared only once in normalizeDateSkeleton
 878      * 2. &#39;E&#39; and &#39;EE&#39; are normalized into &#39;EEE&#39;
 879      * 3. &#39;MM&#39; is normalized into &#39;M&#39;
 880      *
 881      ** the difference between time skeleton and normalizedTimeSkeleton are:
 882      * 1. both &#39;H&#39; and &#39;h&#39; are normalized as &#39;h&#39; in normalized time skeleton,
 883      * 2. &#39;a&#39; is omitted in normalized time skeleton.
 884      * 3. there is only one appearance for &#39;h&#39;, &#39;m&#39;,&#39;v&#39;, &#39;z&#39; in normalized time
 885      *    skeleton
 886      *
 887      *
 888      *  @param skeleton               given combined skeleton.
 889      *  @param date                   Output parameter for date only skeleton.
 890      *  @param normalizedDate         Output parameter for normalized date only
 891      *
 892      *  @param time                   Output parameter for time only skeleton.
 893      *  @param normalizedTime         Output parameter for normalized time only
 894      *                                skeleton.
 895      *
 896      */
 897     static void  U_EXPORT2 getDateTimeSkeleton(const UnicodeString&amp; skeleton,
 898                                     UnicodeString&amp; date,
 899                                     UnicodeString&amp; normalizedDate,
 900                                     UnicodeString&amp; time,
 901                                     UnicodeString&amp; normalizedTime);
 902 
 903 
 904 
 905     /**
 906      * Generate date or time interval pattern from resource,
 907      * and set them into the interval pattern locale to this formatter.
 908      *
 909      * It needs to handle the following:
 910      * 1. need to adjust field width.
 911      *    For example, the interval patterns saved in DateIntervalInfo
 912      *    includes &quot;dMMMy&quot;, but not &quot;dMMMMy&quot;.
 913      *    Need to get interval patterns for dMMMMy from dMMMy.
 914      *    Another example, the interval patterns saved in DateIntervalInfo
 915      *    includes &quot;hmv&quot;, but not &quot;hmz&quot;.
 916      *    Need to get interval patterns for &quot;hmz&#39; from &#39;hmv&#39;
 917      *
 918      * 2. there might be no pattern for &#39;y&#39; differ for skeleton &quot;Md&quot;,
 919      *    in order to get interval patterns for &#39;y&#39; differ,
 920      *    need to look for it from skeleton &#39;yMd&#39;
 921      *
 922      * @param dateSkeleton   normalized date skeleton
 923      * @param timeSkeleton   normalized time skeleton
 924      * @return               whether the resource is found for the skeleton.
 925      *                       TRUE if interval pattern found for the skeleton,
 926      *                       FALSE otherwise.
 927      */
 928     UBool setSeparateDateTimePtn(const UnicodeString&amp; dateSkeleton,
 929                                  const UnicodeString&amp; timeSkeleton);
 930 
 931 
 932 
 933 
 934     /**
 935      * Generate interval pattern from existing resource
 936      *
 937      * It not only save the interval patterns,
 938      * but also return the extended skeleton and its best match skeleton.
 939      *
 940      * @param field           largest different calendar field
 941      * @param skeleton        skeleton
 942      * @param bestSkeleton    the best match skeleton which has interval pattern
 943      *                        defined in resource
 944      * @param differenceInfo  the difference between skeleton and best skeleton
 945      *         0 means the best matched skeleton is the same as input skeleton
 946      *         1 means the fields are the same, but field width are different
 947      *         2 means the only difference between fields are v/z,
 948      *        -1 means there are other fields difference
 949      *
 950      * @param extendedSkeleton      extended skeleton
 951      * @param extendedBestSkeleton  extended best match skeleton
 952      * @return                      whether the interval pattern is found
 953      *                              through extending skeleton or not.
 954      *                              TRUE if interval pattern is found by
 955      *                              extending skeleton, FALSE otherwise.
 956      */
 957     UBool setIntervalPattern(UCalendarDateFields field,
 958                              const UnicodeString* skeleton,
 959                              const UnicodeString* bestSkeleton,
 960                              int8_t differenceInfo,
 961                              UnicodeString* extendedSkeleton = NULL,
 962                              UnicodeString* extendedBestSkeleton = NULL);
 963 
 964     /**
 965      * Adjust field width in best match interval pattern to match
 966      * the field width in input skeleton.
 967      *
 968      * TODO (xji) make a general solution
 969      * The adjusting rule can be:
 970      * 1. always adjust
 971      * 2. never adjust
 972      * 3. default adjust, which means adjust according to the following rules
 973      * 3.1 always adjust string, such as MMM and MMMM
 974      * 3.2 never adjust between string and numeric, such as MM and MMM
 975      * 3.3 always adjust year
 976      * 3.4 do not adjust &#39;d&#39;, &#39;h&#39;, or &#39;m&#39; if h presents
 977      * 3.5 do not adjust &#39;M&#39; if it is numeric(?)
 978      *
 979      * Since date interval format is well-formed format,
 980      * date and time skeletons are normalized previously,
 981      * till this stage, the adjust here is only &quot;adjust strings, such as MMM
 982      * and MMMM, EEE and EEEE.
 983      *
 984      * @param inputSkeleton            the input skeleton
 985      * @param bestMatchSkeleton        the best match skeleton
 986      * @param bestMatchIntervalPattern the best match interval pattern
 987      * @param differenceInfo           the difference between 2 skeletons
 988      *                                 1 means only field width differs
 989      *                                 2 means v/z exchange
 990      * @param adjustedIntervalPattern  adjusted interval pattern
 991      */
 992     static void U_EXPORT2 adjustFieldWidth(
 993                             const UnicodeString&amp; inputSkeleton,
 994                             const UnicodeString&amp; bestMatchSkeleton,
 995                             const UnicodeString&amp; bestMatchIntervalPattern,
 996                             int8_t differenceInfo,
 997                             UnicodeString&amp; adjustedIntervalPattern);
 998 
 999     /**
1000      * Concat a single date pattern with a time interval pattern,
1001      * set it into the intervalPatterns, while field is time field.
1002      * This is used to handle time interval patterns on skeleton with
1003      * both time and date. Present the date followed by
1004      * the range expression for the time.
1005      * @param format         date and time format
1006      * @param datePattern    date pattern
1007      * @param field          time calendar field: AM_PM, HOUR, MINUTE
1008      * @param status         output param set to success/failure code on exit
1009      */
1010     void concatSingleDate2TimeInterval(UnicodeString&amp; format,
1011                                        const UnicodeString&amp; datePattern,
1012                                        UCalendarDateFields field,
1013                                        UErrorCode&amp; status);
1014 
1015     /**
1016      * check whether a calendar field present in a skeleton.
1017      * @param field      calendar field need to check
1018      * @param skeleton   given skeleton on which to check the calendar field
1019      * @return           true if field present in a skeleton.
1020      */
1021     static UBool U_EXPORT2 fieldExistsInSkeleton(UCalendarDateFields field,
1022                                                  const UnicodeString&amp; skeleton);
1023 
1024 
1025     /**
1026      * Split interval patterns into 2 part.
1027      * @param intervalPattern  interval pattern
1028      * @return the index in interval pattern which split the pattern into 2 part
1029      */
1030     static int32_t  U_EXPORT2 splitPatternInto2Part(const UnicodeString&amp; intervalPattern);
1031 
1032 
1033     /**
1034      * Break interval patterns as 2 part and save them into pattern info.
1035      * @param field            calendar field
1036      * @param intervalPattern  interval pattern
1037      */
1038     void setIntervalPattern(UCalendarDateFields field,
1039                             const UnicodeString&amp; intervalPattern);
1040 
1041 
1042     /**
1043      * Break interval patterns as 2 part and save them into pattern info.
1044      * @param field            calendar field
1045      * @param intervalPattern  interval pattern
1046      * @param laterDateFirst   whether later date appear first in interval pattern
1047      */
1048     void setIntervalPattern(UCalendarDateFields field,
1049                             const UnicodeString&amp; intervalPattern,
1050                             UBool laterDateFirst);
1051 
1052 
1053     /**
1054      * Set pattern information.
1055      *
1056      * @param field            calendar field
1057      * @param firstPart        the first part in interval pattern
1058      * @param secondPart       the second part in interval pattern
1059      * @param laterDateFirst   whether the first date in intervalPattern
1060      *                         is earlier date or later date
1061      */
1062     void setPatternInfo(UCalendarDateFields field,
1063                         const UnicodeString* firstPart,
1064                         const UnicodeString* secondPart,
1065                         UBool laterDateFirst);
1066 
1067     /**
1068      * Format 2 Calendars to produce a string.
1069      * Implementation of the similar public format function.
1070      * Must be called with gFormatterMutex already locked.
1071      *
1072      * Note: &quot;fromCalendar&quot; and &quot;toCalendar&quot; are not const,
1073      * since calendar is not const in  SimpleDateFormat::format(Calendar&amp;),
1074      *
1075      * @param fromCalendar      calendar set to the from date in date interval
1076      *                          to be formatted into date interval string
1077      * @param toCalendar        calendar set to the to date in date interval
1078      *                          to be formatted into date interval string
1079      * @param appendTo          Output parameter to receive result.
1080      *                          Result is appended to existing contents.
<a name="9" id="anc9"></a><span class="line-modified">1081      * @param firstIndex        0 if the first output date is fromCalendar;</span>
<span class="line-modified">1082      *                          1 if it corresponds to toCalendar;</span>
<span class="line-modified">1083      *                          -1 if there is only one date printed.</span>
<span class="line-modified">1084      * @param fphandler         Handler for field position information.</span>
<span class="line-modified">1085      *                          The fields will be from the UDateFormatField enum.</span>
1086      * @param status            Output param filled with success/failure status.
1087      *                          Caller needs to make sure it is SUCCESS
1088      *                          at the function entrance
1089      * @return                  Reference to &#39;appendTo&#39; parameter.
1090      * @internal (private)
1091      */
1092     UnicodeString&amp; formatImpl(Calendar&amp; fromCalendar,
1093                               Calendar&amp; toCalendar,
1094                               UnicodeString&amp; appendTo,
<a name="10" id="anc10"></a><span class="line-modified">1095                               int8_t&amp; firstIndex,</span>
<span class="line-added">1096                               FieldPositionHandler&amp; fphandler,</span>
1097                               UErrorCode&amp; status) const ;
1098 
<a name="11" id="anc11"></a><span class="line-added">1099     /** Version of formatImpl for DateInterval. */</span>
<span class="line-added">1100     UnicodeString&amp; formatIntervalImpl(const DateInterval&amp; dtInterval,</span>
<span class="line-added">1101                               UnicodeString&amp; appendTo,</span>
<span class="line-added">1102                               int8_t&amp; firstIndex,</span>
<span class="line-added">1103                               FieldPositionHandler&amp; fphandler,</span>
<span class="line-added">1104                               UErrorCode&amp; status) const;</span>
<span class="line-added">1105 </span>
1106 
1107     // from calendar field to pattern letter
1108     static const char16_t fgCalendarFieldToPatternLetter[];
1109 
1110 
1111     /**
1112      * The interval patterns for this locale.
1113      */
1114     DateIntervalInfo*     fInfo;
1115 
1116     /**
1117      * The DateFormat object used to format single pattern
1118      */
1119     SimpleDateFormat*     fDateFormat;
1120 
1121     /**
1122      * The 2 calendars with the from and to date.
1123      * could re-use the calendar in fDateFormat,
1124      * but keeping 2 calendars make it clear and clean.
1125      */
1126     Calendar* fFromCalendar;
1127     Calendar* fToCalendar;
1128 
1129     Locale fLocale;
1130 
1131     /**
1132      * Following are interval information relevant (locale) to this formatter.
1133      */
1134     UnicodeString fSkeleton;
1135     PatternInfo fIntervalPatterns[DateIntervalInfo::kIPI_MAX_INDEX];
1136 
1137     /**
1138      * Patterns for fallback formatting.
1139      */
1140     UnicodeString* fDatePattern;
1141     UnicodeString* fTimePattern;
1142     UnicodeString* fDateTimeFormat;
1143 };
1144 
1145 inline UBool
1146 DateIntervalFormat::operator!=(const Format&amp; other) const  {
1147     return !operator==(other);
1148 }
1149 
1150 U_NAMESPACE_END
1151 
1152 #endif /* #if !UCONFIG_NO_FORMATTING */
1153 
1154 #endif // _DTITVFMT_H__
1155 //eof
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>