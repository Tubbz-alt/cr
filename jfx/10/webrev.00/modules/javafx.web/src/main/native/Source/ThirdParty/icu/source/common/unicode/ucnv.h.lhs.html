<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/ucnv.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 *   Copyright (C) 1999-2014, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8  *  ucnv.h:
   9  *  External APIs for the ICU&#39;s codeset conversion library
  10  *  Bertrand A. Damiba
  11  *
  12  * Modification History:
  13  *
  14  *   Date        Name        Description
  15  *   04/04/99    helena      Fixed internal header inclusion.
  16  *   05/11/00    helena      Added setFallback and usesFallback APIs.
  17  *   06/29/2000  helena      Major rewrite of the callback APIs.
  18  *   12/07/2000  srl         Update of documentation
  19  */
  20 
  21 /**
  22  * \file
  23  * \brief C API: Character conversion
  24  *
  25  * &lt;h2&gt;Character Conversion C API&lt;/h2&gt;
  26  *
  27  * &lt;p&gt;This API is used to convert codepage or character encoded data to and
  28  * from UTF-16. You can open a converter with {@link ucnv_open() }. With that
  29  * converter, you can get its properties, set options, convert your data and
  30  * close the converter.&lt;/p&gt;
  31  *
  32  * &lt;p&gt;Since many software programs recognize different converter names for
  33  * different types of converters, there are other functions in this API to
  34  * iterate over the converter aliases. The functions {@link ucnv_getAvailableName() },
  35  * {@link ucnv_getAlias() } and {@link ucnv_getStandardName() } are some of the
  36  * more frequently used alias functions to get this information.&lt;/p&gt;
  37  *
  38  * &lt;p&gt;When a converter encounters an illegal, irregular, invalid or unmappable character
  39  * its default behavior is to use a substitution character to replace the
  40  * bad byte sequence. This behavior can be changed by using {@link ucnv_setFromUCallBack() }
  41  * or {@link ucnv_setToUCallBack() } on the converter. The header ucnv_err.h defines
  42  * many other callback actions that can be used instead of a character substitution.&lt;/p&gt;
  43  *
  44  * &lt;p&gt;More information about this API can be found in our
  45  * &lt;a href=&quot;http://icu-project.org/userguide/conversion.html&quot;&gt;User&#39;s
  46  * Guide&lt;/a&gt;.&lt;/p&gt;
  47  */
  48 
  49 #ifndef UCNV_H
  50 #define UCNV_H
  51 
  52 #include &quot;unicode/ucnv_err.h&quot;
  53 #include &quot;unicode/uenum.h&quot;
  54 #include &quot;unicode/localpointer.h&quot;
  55 
<a name="1" id="anc1"></a><span class="line-modified">  56 #ifndef __USET_H__</span>


  57 
  58 /**
<a name="2" id="anc2"></a><span class="line-modified">  59  * USet is the C API type for Unicode sets.</span>
<span class="line-modified">  60  * It is forward-declared here to avoid including the header file if related</span>
  61  * conversion APIs are not used.
<a name="3" id="anc3"></a><span class="line-removed">  62  * See unicode/uset.h</span>
  63  *
  64  * @see ucnv_getUnicodeSet
<a name="4" id="anc4"></a><span class="line-modified">  65  * @stable ICU 2.6</span>
  66  */
<a name="5" id="anc5"></a><span class="line-removed">  67 struct USet;</span>
<span class="line-removed">  68 /** @stable ICU 2.6 */</span>
  69 typedef struct USet USet;
  70 
  71 #endif
  72 
  73 #if !UCONFIG_NO_CONVERSION
  74 
  75 U_CDECL_BEGIN
  76 
  77 /** Maximum length of a converter name including the terminating NULL @stable ICU 2.0 */
  78 #define UCNV_MAX_CONVERTER_NAME_LENGTH 60
  79 /** Maximum length of a converter name including path and terminating NULL @stable ICU 2.0 */
  80 #define UCNV_MAX_FULL_FILE_NAME_LENGTH (600+UCNV_MAX_CONVERTER_NAME_LENGTH)
  81 
  82 /** Shift in for EBDCDIC_STATEFUL and iso2022 states @stable ICU 2.0 */
  83 #define  UCNV_SI 0x0F
  84 /** Shift out for EBDCDIC_STATEFUL and iso2022 states @stable ICU 2.0 */
  85 #define  UCNV_SO 0x0E
  86 
  87 /**
  88  * Enum for specifying basic types of converters
  89  * @see ucnv_getType
  90  * @stable ICU 2.0
  91  */
  92 typedef enum {
  93     /** @stable ICU 2.0 */
  94     UCNV_UNSUPPORTED_CONVERTER = -1,
  95     /** @stable ICU 2.0 */
  96     UCNV_SBCS = 0,
  97     /** @stable ICU 2.0 */
  98     UCNV_DBCS = 1,
  99     /** @stable ICU 2.0 */
 100     UCNV_MBCS = 2,
 101     /** @stable ICU 2.0 */
 102     UCNV_LATIN_1 = 3,
 103     /** @stable ICU 2.0 */
 104     UCNV_UTF8 = 4,
 105     /** @stable ICU 2.0 */
 106     UCNV_UTF16_BigEndian = 5,
 107     /** @stable ICU 2.0 */
 108     UCNV_UTF16_LittleEndian = 6,
 109     /** @stable ICU 2.0 */
 110     UCNV_UTF32_BigEndian = 7,
 111     /** @stable ICU 2.0 */
 112     UCNV_UTF32_LittleEndian = 8,
 113     /** @stable ICU 2.0 */
 114     UCNV_EBCDIC_STATEFUL = 9,
 115     /** @stable ICU 2.0 */
 116     UCNV_ISO_2022 = 10,
 117 
 118     /** @stable ICU 2.0 */
 119     UCNV_LMBCS_1 = 11,
 120     /** @stable ICU 2.0 */
 121     UCNV_LMBCS_2,
 122     /** @stable ICU 2.0 */
 123     UCNV_LMBCS_3,
 124     /** @stable ICU 2.0 */
 125     UCNV_LMBCS_4,
 126     /** @stable ICU 2.0 */
 127     UCNV_LMBCS_5,
 128     /** @stable ICU 2.0 */
 129     UCNV_LMBCS_6,
 130     /** @stable ICU 2.0 */
 131     UCNV_LMBCS_8,
 132     /** @stable ICU 2.0 */
 133     UCNV_LMBCS_11,
 134     /** @stable ICU 2.0 */
 135     UCNV_LMBCS_16,
 136     /** @stable ICU 2.0 */
 137     UCNV_LMBCS_17,
 138     /** @stable ICU 2.0 */
 139     UCNV_LMBCS_18,
 140     /** @stable ICU 2.0 */
 141     UCNV_LMBCS_19,
 142     /** @stable ICU 2.0 */
 143     UCNV_LMBCS_LAST = UCNV_LMBCS_19,
 144     /** @stable ICU 2.0 */
 145     UCNV_HZ,
 146     /** @stable ICU 2.0 */
 147     UCNV_SCSU,
 148     /** @stable ICU 2.0 */
 149     UCNV_ISCII,
 150     /** @stable ICU 2.0 */
 151     UCNV_US_ASCII,
 152     /** @stable ICU 2.0 */
 153     UCNV_UTF7,
 154     /** @stable ICU 2.2 */
 155     UCNV_BOCU1,
 156     /** @stable ICU 2.2 */
 157     UCNV_UTF16,
 158     /** @stable ICU 2.2 */
 159     UCNV_UTF32,
 160     /** @stable ICU 2.2 */
 161     UCNV_CESU8,
 162     /** @stable ICU 2.4 */
 163     UCNV_IMAP_MAILBOX,
 164     /** @stable ICU 4.8 */
 165     UCNV_COMPOUND_TEXT,
 166 
 167     /* Number of converter types for which we have conversion routines. */
 168     UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES
 169 } UConverterType;
 170 
 171 /**
 172  * Enum for specifying which platform a converter ID refers to.
 173  * The use of platform/CCSID is not recommended. See ucnv_openCCSID().
 174  *
 175  * @see ucnv_getPlatform
 176  * @see ucnv_openCCSID
 177  * @see ucnv_getCCSID
 178  * @stable ICU 2.0
 179  */
 180 typedef enum {
 181     UCNV_UNKNOWN = -1,
 182     UCNV_IBM = 0
 183 } UConverterPlatform;
 184 
 185 /**
 186  * Function pointer for error callback in the codepage to unicode direction.
 187  * Called when an error has occurred in conversion to unicode, or on open/close of the callback (see reason).
 188  * @param context Pointer to the callback&#39;s private data
 189  * @param args Information about the conversion in progress
 190  * @param codeUnits Points to &#39;length&#39; bytes of the concerned codepage sequence
 191  * @param length Size (in bytes) of the concerned codepage sequence
 192  * @param reason Defines the reason the callback was invoked
 193  * @param pErrorCode    ICU error code in/out parameter.
 194  *                      For converter callback functions, set to a conversion error
 195  *                      before the call, and the callback may reset it to U_ZERO_ERROR.
 196  * @see ucnv_setToUCallBack
 197  * @see UConverterToUnicodeArgs
 198  * @stable ICU 2.0
 199  */
 200 typedef void (U_EXPORT2 *UConverterToUCallback) (
 201                   const void* context,
 202                   UConverterToUnicodeArgs *args,
 203                   const char *codeUnits,
 204                   int32_t length,
 205                   UConverterCallbackReason reason,
 206                   UErrorCode *pErrorCode);
 207 
 208 /**
 209  * Function pointer for error callback in the unicode to codepage direction.
 210  * Called when an error has occurred in conversion from unicode, or on open/close of the callback (see reason).
 211  * @param context Pointer to the callback&#39;s private data
 212  * @param args Information about the conversion in progress
 213  * @param codeUnits Points to &#39;length&#39; UChars of the concerned Unicode sequence
 214  * @param length Size (in bytes) of the concerned codepage sequence
 215  * @param codePoint Single UChar32 (UTF-32) containing the concerend Unicode codepoint.
 216  * @param reason Defines the reason the callback was invoked
 217  * @param pErrorCode    ICU error code in/out parameter.
 218  *                      For converter callback functions, set to a conversion error
 219  *                      before the call, and the callback may reset it to U_ZERO_ERROR.
 220  * @see ucnv_setFromUCallBack
 221  * @stable ICU 2.0
 222  */
 223 typedef void (U_EXPORT2 *UConverterFromUCallback) (
 224                     const void* context,
 225                     UConverterFromUnicodeArgs *args,
 226                     const UChar* codeUnits,
 227                     int32_t length,
 228                     UChar32 codePoint,
 229                     UConverterCallbackReason reason,
 230                     UErrorCode *pErrorCode);
 231 
 232 U_CDECL_END
 233 
 234 /**
 235  * Character that separates converter names from options and options from each other.
 236  * @see ucnv_open
 237  * @stable ICU 2.0
 238  */
 239 #define UCNV_OPTION_SEP_CHAR &#39;,&#39;
 240 
 241 /**
 242  * String version of UCNV_OPTION_SEP_CHAR.
 243  * @see ucnv_open
 244  * @stable ICU 2.0
 245  */
 246 #define UCNV_OPTION_SEP_STRING &quot;,&quot;
 247 
 248 /**
 249  * Character that separates a converter option from its value.
 250  * @see ucnv_open
 251  * @stable ICU 2.0
 252  */
 253 #define UCNV_VALUE_SEP_CHAR &#39;=&#39;
 254 
 255 /**
 256  * String version of UCNV_VALUE_SEP_CHAR.
 257  * @see ucnv_open
 258  * @stable ICU 2.0
 259  */
 260 #define UCNV_VALUE_SEP_STRING &quot;=&quot;
 261 
 262 /**
 263  * Converter option for specifying a locale.
 264  * For example, ucnv_open(&quot;SCSU,locale=ja&quot;, &amp;errorCode);
 265  * See convrtrs.txt.
 266  *
 267  * @see ucnv_open
 268  * @stable ICU 2.0
 269  */
 270 #define UCNV_LOCALE_OPTION_STRING &quot;,locale=&quot;
 271 
 272 /**
 273  * Converter option for specifying a version selector (0..9) for some converters.
 274  * For example,
 275  * \code
 276  *   ucnv_open(&quot;UTF-7,version=1&quot;, &amp;errorCode);
 277  * \endcode
 278  * See convrtrs.txt.
 279  *
 280  * @see ucnv_open
 281  * @stable ICU 2.4
 282  */
 283 #define UCNV_VERSION_OPTION_STRING &quot;,version=&quot;
 284 
 285 /**
 286  * Converter option for EBCDIC SBCS or mixed-SBCS/DBCS (stateful) codepages.
 287  * Swaps Unicode mappings for EBCDIC LF and NL codes, as used on
 288  * S/390 (z/OS) Unix System Services (Open Edition).
 289  * For example, ucnv_open(&quot;ibm-1047,swaplfnl&quot;, &amp;errorCode);
 290  * See convrtrs.txt.
 291  *
 292  * @see ucnv_open
 293  * @stable ICU 2.4
 294  */
 295 #define UCNV_SWAP_LFNL_OPTION_STRING &quot;,swaplfnl&quot;
 296 
 297 /**
 298  * Do a fuzzy compare of two converter/alias names.
 299  * The comparison is case-insensitive, ignores leading zeroes if they are not
 300  * followed by further digits, and ignores all but letters and digits.
 301  * Thus the strings &quot;UTF-8&quot;, &quot;utf_8&quot;, &quot;u*T@f08&quot; and &quot;Utf 8&quot; are exactly equivalent.
 302  * See section 1.4, Charset Alias Matching in Unicode Technical Standard #22
 303  * at http://www.unicode.org/reports/tr22/
 304  *
 305  * @param name1 a converter name or alias, zero-terminated
 306  * @param name2 a converter name or alias, zero-terminated
 307  * @return 0 if the names match, or a negative value if the name1
 308  * lexically precedes name2, or a positive value if the name1
 309  * lexically follows name2.
 310  * @stable ICU 2.0
 311  */
 312 U_STABLE int U_EXPORT2
 313 ucnv_compareNames(const char *name1, const char *name2);
 314 
 315 
 316 /**
 317  * Creates a UConverter object with the name of a coded character set specified as a C string.
 318  * The actual name will be resolved with the alias file
 319  * using a case-insensitive string comparison that ignores
 320  * leading zeroes and all non-alphanumeric characters.
 321  * E.g., the names &quot;UTF8&quot;, &quot;utf-8&quot;, &quot;u*T@f08&quot; and &quot;Utf 8&quot; are all equivalent.
 322  * (See also ucnv_compareNames().)
 323  * If &lt;code&gt;NULL&lt;/code&gt; is passed for the converter name, it will create one with the
 324  * getDefaultName return value.
 325  *
 326  * &lt;p&gt;A converter name for ICU 1.5 and above may contain options
 327  * like a locale specification to control the specific behavior of
 328  * the newly instantiated converter.
 329  * The meaning of the options depends on the particular converter.
 330  * If an option is not defined for or recognized by a given converter, then it is ignored.&lt;/p&gt;
 331  *
 332  * &lt;p&gt;Options are appended to the converter name string, with a
 333  * &lt;code&gt;UCNV_OPTION_SEP_CHAR&lt;/code&gt; between the name and the first option and
 334  * also between adjacent options.&lt;/p&gt;
 335  *
 336  * &lt;p&gt;If the alias is ambiguous, then the preferred converter is used
 337  * and the status is set to U_AMBIGUOUS_ALIAS_WARNING.&lt;/p&gt;
 338  *
 339  * &lt;p&gt;The conversion behavior and names can vary between platforms. ICU may
 340  * convert some characters differently from other platforms. Details on this topic
 341  * are in the &lt;a href=&quot;http://icu-project.org/userguide/conversion.html&quot;&gt;User&#39;s
 342  * Guide&lt;/a&gt;. Aliases starting with a &quot;cp&quot; prefix have no specific meaning
 343  * other than its an alias starting with the letters &quot;cp&quot;. Please do not
 344  * associate any meaning to these aliases.&lt;/p&gt;
 345  *
 346  * \snippet samples/ucnv/convsamp.cpp ucnv_open
 347  *
 348  * @param converterName Name of the coded character set table.
 349  *          This may have options appended to the string.
 350  *          IANA alias character set names, IBM CCSIDs starting with &quot;ibm-&quot;,
 351  *          Windows codepage numbers starting with &quot;windows-&quot; are frequently
 352  *          used for this parameter. See ucnv_getAvailableName and
 353  *          ucnv_getAlias for a complete list that is available.
 354  *          If this parameter is NULL, the default converter will be used.
 355  * @param err outgoing error status &lt;TT&gt;U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR&lt;/TT&gt;
 356  * @return the created Unicode converter object, or &lt;TT&gt;NULL&lt;/TT&gt; if an error occurred
 357  * @see ucnv_openU
 358  * @see ucnv_openCCSID
 359  * @see ucnv_getAvailableName
 360  * @see ucnv_getAlias
 361  * @see ucnv_getDefaultName
 362  * @see ucnv_close
 363  * @see ucnv_compareNames
 364  * @stable ICU 2.0
 365  */
 366 U_STABLE UConverter* U_EXPORT2
 367 ucnv_open(const char *converterName, UErrorCode *err);
 368 
 369 
 370 /**
 371  * Creates a Unicode converter with the names specified as unicode string.
 372  * The name should be limited to the ASCII-7 alphanumerics range.
 373  * The actual name will be resolved with the alias file
 374  * using a case-insensitive string comparison that ignores
 375  * leading zeroes and all non-alphanumeric characters.
 376  * E.g., the names &quot;UTF8&quot;, &quot;utf-8&quot;, &quot;u*T@f08&quot; and &quot;Utf 8&quot; are all equivalent.
 377  * (See also ucnv_compareNames().)
 378  * If &lt;TT&gt;NULL&lt;/TT&gt; is passed for the converter name, it will create
 379  * one with the ucnv_getDefaultName() return value.
 380  * If the alias is ambiguous, then the preferred converter is used
 381  * and the status is set to U_AMBIGUOUS_ALIAS_WARNING.
 382  *
 383  * &lt;p&gt;See ucnv_open for the complete details&lt;/p&gt;
 384  * @param name Name of the UConverter table in a zero terminated
 385  *        Unicode string
 386  * @param err outgoing error status &lt;TT&gt;U_MEMORY_ALLOCATION_ERROR,
 387  *        U_FILE_ACCESS_ERROR&lt;/TT&gt;
 388  * @return the created Unicode converter object, or &lt;TT&gt;NULL&lt;/TT&gt; if an
 389  *        error occurred
 390  * @see ucnv_open
 391  * @see ucnv_openCCSID
 392  * @see ucnv_close
 393  * @see ucnv_compareNames
 394  * @stable ICU 2.0
 395  */
 396 U_STABLE UConverter* U_EXPORT2
 397 ucnv_openU(const UChar *name,
 398            UErrorCode *err);
 399 
 400 /**
 401  * Creates a UConverter object from a CCSID number and platform pair.
 402  * Note that the usefulness of this function is limited to platforms with numeric
 403  * encoding IDs. Only IBM and Microsoft platforms use numeric (16-bit) identifiers for
 404  * encodings.
 405  *
 406  * In addition, IBM CCSIDs and Unicode conversion tables are not 1:1 related.
 407  * For many IBM CCSIDs there are multiple (up to six) Unicode conversion tables, and
 408  * for some Unicode conversion tables there are multiple CCSIDs.
 409  * Some &quot;alternate&quot; Unicode conversion tables are provided by the
 410  * IBM CDRA conversion table registry.
 411  * The most prominent example of a systematic modification of conversion tables that is
 412  * not provided in the form of conversion table files in the repository is
 413  * that S/390 Unix System Services swaps the codes for Line Feed and New Line in all
 414  * EBCDIC codepages, which requires such a swap in the Unicode conversion tables as well.
 415  *
 416  * Only IBM default conversion tables are accessible with ucnv_openCCSID().
 417  * ucnv_getCCSID() will return the same CCSID for all conversion tables that are associated
 418  * with that CCSID.
 419  *
 420  * Currently, the only &quot;platform&quot; supported in the ICU converter API is UCNV_IBM.
 421  *
 422  * In summary, the use of CCSIDs and the associated API functions is not recommended.
 423  *
 424  * In order to open a converter with the default IBM CDRA Unicode conversion table,
 425  * you can use this function or use the prefix &quot;ibm-&quot;:
 426  * \code
 427  *     char name[20];
 428  *     sprintf(name, &quot;ibm-%hu&quot;, ccsid);
 429  *     cnv=ucnv_open(name, &amp;errorCode);
 430  * \endcode
 431  *
 432  * In order to open a converter with the IBM S/390 Unix System Services variant
 433  * of a Unicode/EBCDIC conversion table,
 434  * you can use the prefix &quot;ibm-&quot; together with the option string UCNV_SWAP_LFNL_OPTION_STRING:
 435  * \code
 436  *     char name[20];
 437  *     sprintf(name, &quot;ibm-%hu&quot; UCNV_SWAP_LFNL_OPTION_STRING, ccsid);
 438  *     cnv=ucnv_open(name, &amp;errorCode);
 439  * \endcode
 440  *
 441  * In order to open a converter from a Microsoft codepage number, use the prefix &quot;cp&quot;:
 442  * \code
 443  *     char name[20];
 444  *     sprintf(name, &quot;cp%hu&quot;, codepageID);
 445  *     cnv=ucnv_open(name, &amp;errorCode);
 446  * \endcode
 447  *
 448  * If the alias is ambiguous, then the preferred converter is used
 449  * and the status is set to U_AMBIGUOUS_ALIAS_WARNING.
 450  *
 451  * @param codepage codepage number to create
 452  * @param platform the platform in which the codepage number exists
 453  * @param err error status &lt;TT&gt;U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR&lt;/TT&gt;
 454  * @return the created Unicode converter object, or &lt;TT&gt;NULL&lt;/TT&gt; if an error
 455  *   occurred.
 456  * @see ucnv_open
 457  * @see ucnv_openU
 458  * @see ucnv_close
 459  * @see ucnv_getCCSID
 460  * @see ucnv_getPlatform
 461  * @see UConverterPlatform
 462  * @stable ICU 2.0
 463  */
 464 U_STABLE UConverter* U_EXPORT2
 465 ucnv_openCCSID(int32_t codepage,
 466                UConverterPlatform platform,
 467                UErrorCode * err);
 468 
 469 /**
 470  * &lt;p&gt;Creates a UConverter object specified from a packageName and a converterName.&lt;/p&gt;
 471  *
 472  * &lt;p&gt;The packageName and converterName must point to an ICU udata object, as defined by
 473  *   &lt;code&gt; udata_open( packageName, &quot;cnv&quot;, converterName, err) &lt;/code&gt; or equivalent.
 474  * Typically, packageName will refer to a (.dat) file, or to a package registered with
 475  * udata_setAppData(). Using a full file or directory pathname for packageName is deprecated.&lt;/p&gt;
 476  *
 477  * &lt;p&gt;The name will NOT be looked up in the alias mechanism, nor will the converter be
 478  * stored in the converter cache or the alias table. The only way to open further converters
 479  * is call this function multiple times, or use the ucnv_safeClone() function to clone a
 480  * &#39;master&#39; converter.&lt;/p&gt;
 481  *
 482  * &lt;p&gt;A future version of ICU may add alias table lookups and/or caching
 483  * to this function.&lt;/p&gt;
 484  *
 485  * &lt;p&gt;Example Use:
 486  *      &lt;code&gt;cnv = ucnv_openPackage(&quot;myapp&quot;, &quot;myconverter&quot;, &amp;err);&lt;/code&gt;
 487  * &lt;/p&gt;
 488  *
 489  * @param packageName name of the package (equivalent to &#39;path&#39; in udata_open() call)
 490  * @param converterName name of the data item to be used, without suffix.
 491  * @param err outgoing error status &lt;TT&gt;U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR&lt;/TT&gt;
 492  * @return the created Unicode converter object, or &lt;TT&gt;NULL&lt;/TT&gt; if an error occurred
 493  * @see udata_open
 494  * @see ucnv_open
 495  * @see ucnv_safeClone
 496  * @see ucnv_close
 497  * @stable ICU 2.2
 498  */
 499 U_STABLE UConverter* U_EXPORT2
 500 ucnv_openPackage(const char *packageName, const char *converterName, UErrorCode *err);
 501 
 502 /**
 503  * Thread safe converter cloning operation.
 504  * For most efficient operation, pass in a stackBuffer (and a *pBufferSize)
 505  * with at least U_CNV_SAFECLONE_BUFFERSIZE bytes of space.
 506  * If the buffer size is sufficient, then the clone will use the stack buffer;
 507  * otherwise, it will be allocated, and *pBufferSize will indicate
 508  * the actual size. (This should not occur with U_CNV_SAFECLONE_BUFFERSIZE.)
 509  *
 510  * You must ucnv_close() the clone in any case.
 511  *
 512  * If *pBufferSize==0, (regardless of whether stackBuffer==NULL or not)
 513  * then *pBufferSize will be changed to a sufficient size
 514  * for cloning this converter,
 515  * without actually cloning the converter (&quot;pure pre-flighting&quot;).
 516  *
 517  * If *pBufferSize is greater than zero but not large enough for a stack-based
 518  * clone, then the converter is cloned using newly allocated memory
 519  * and *pBufferSize is changed to the necessary size.
 520  *
 521  * If the converter clone fits into the stack buffer but the stack buffer is not
 522  * sufficiently aligned for the clone, then the clone will use an
 523  * adjusted pointer and use an accordingly smaller buffer size.
 524  *
 525  * @param cnv converter to be cloned
 526  * @param stackBuffer &lt;em&gt;Deprecated functionality as of ICU 52, use NULL.&lt;/em&gt;&lt;br&gt;
 527  *  user allocated space for the new clone. If NULL new memory will be allocated.
 528  *  If buffer is not large enough, new memory will be allocated.
 529  *  Clients can use the U_CNV_SAFECLONE_BUFFERSIZE. This will probably be enough to avoid memory allocations.
 530  * @param pBufferSize &lt;em&gt;Deprecated functionality as of ICU 52, use NULL or 1.&lt;/em&gt;&lt;br&gt;
 531  *  pointer to size of allocated space.
 532  * @param status to indicate whether the operation went on smoothly or there were errors
 533  *  An informational status value, U_SAFECLONE_ALLOCATED_WARNING,
 534  *  is used if any allocations were necessary.
 535  *  However, it is better to check if *pBufferSize grew for checking for
 536  *  allocations because warning codes can be overridden by subsequent
 537  *  function calls.
 538  * @return pointer to the new clone
 539  * @stable ICU 2.0
 540  */
 541 U_STABLE UConverter * U_EXPORT2
 542 ucnv_safeClone(const UConverter *cnv,
 543                void             *stackBuffer,
 544                int32_t          *pBufferSize,
 545                UErrorCode       *status);
 546 
 547 #ifndef U_HIDE_DEPRECATED_API
 548 
 549 /**
 550  * \def U_CNV_SAFECLONE_BUFFERSIZE
 551  * Definition of a buffer size that is designed to be large enough for
 552  * converters to be cloned with ucnv_safeClone().
 553  * @deprecated ICU 52. Do not rely on ucnv_safeClone() cloning into any provided buffer.
 554  */
 555 #define U_CNV_SAFECLONE_BUFFERSIZE  1024
 556 
 557 #endif /* U_HIDE_DEPRECATED_API */
 558 
 559 /**
 560  * Deletes the unicode converter and releases resources associated
 561  * with just this instance.
 562  * Does not free up shared converter tables.
 563  *
 564  * @param converter the converter object to be deleted
 565  * @see ucnv_open
 566  * @see ucnv_openU
 567  * @see ucnv_openCCSID
 568  * @stable ICU 2.0
 569  */
 570 U_STABLE void  U_EXPORT2
 571 ucnv_close(UConverter * converter);
 572 
 573 #if U_SHOW_CPLUSPLUS_API
 574 
 575 U_NAMESPACE_BEGIN
 576 
 577 /**
 578  * \class LocalUConverterPointer
 579  * &quot;Smart pointer&quot; class, closes a UConverter via ucnv_close().
 580  * For most methods see the LocalPointerBase base class.
 581  *
 582  * @see LocalPointerBase
 583  * @see LocalPointer
 584  * @stable ICU 4.4
 585  */
 586 U_DEFINE_LOCAL_OPEN_POINTER(LocalUConverterPointer, UConverter, ucnv_close);
 587 
 588 U_NAMESPACE_END
 589 
 590 #endif
 591 
 592 /**
 593  * Fills in the output parameter, subChars, with the substitution characters
 594  * as multiple bytes.
 595  * If ucnv_setSubstString() set a Unicode string because the converter is
 596  * stateful, then subChars will be an empty string.
 597  *
 598  * @param converter the Unicode converter
 599  * @param subChars the substitution characters
 600  * @param len on input the capacity of subChars, on output the number
 601  * of bytes copied to it
 602  * @param  err the outgoing error status code.
 603  * If the substitution character array is too small, an
 604  * &lt;TT&gt;U_INDEX_OUTOFBOUNDS_ERROR&lt;/TT&gt; will be returned.
 605  * @see ucnv_setSubstString
 606  * @see ucnv_setSubstChars
 607  * @stable ICU 2.0
 608  */
 609 U_STABLE void U_EXPORT2
 610 ucnv_getSubstChars(const UConverter *converter,
 611                    char *subChars,
 612                    int8_t *len,
 613                    UErrorCode *err);
 614 
 615 /**
 616  * Sets the substitution chars when converting from unicode to a codepage. The
 617  * substitution is specified as a string of 1-4 bytes, and may contain
 618  * &lt;TT&gt;NULL&lt;/TT&gt; bytes.
 619  * The subChars must represent a single character. The caller needs to know the
 620  * byte sequence of a valid character in the converter&#39;s charset.
 621  * For some converters, for example some ISO 2022 variants, only single-byte
 622  * substitution characters may be supported.
 623  * The newer ucnv_setSubstString() function relaxes these limitations.
 624  *
 625  * @param converter the Unicode converter
 626  * @param subChars the substitution character byte sequence we want set
 627  * @param len the number of bytes in subChars
 628  * @param err the error status code.  &lt;TT&gt;U_INDEX_OUTOFBOUNDS_ERROR &lt;/TT&gt; if
 629  * len is bigger than the maximum number of bytes allowed in subchars
 630  * @see ucnv_setSubstString
 631  * @see ucnv_getSubstChars
 632  * @stable ICU 2.0
 633  */
 634 U_STABLE void U_EXPORT2
 635 ucnv_setSubstChars(UConverter *converter,
 636                    const char *subChars,
 637                    int8_t len,
 638                    UErrorCode *err);
 639 
 640 /**
 641  * Set a substitution string for converting from Unicode to a charset.
 642  * The caller need not know the charset byte sequence for each charset.
 643  *
 644  * Unlike ucnv_setSubstChars() which is designed to set a charset byte sequence
 645  * for a single character, this function takes a Unicode string with
 646  * zero, one or more characters, and immediately verifies that the string can be
 647  * converted to the charset.
 648  * If not, or if the result is too long (more than 32 bytes as of ICU 3.6),
 649  * then the function returns with an error accordingly.
 650  *
 651  * Also unlike ucnv_setSubstChars(), this function works for stateful charsets
 652  * by converting on the fly at the point of substitution rather than setting
 653  * a fixed byte sequence.
 654  *
 655  * @param cnv The UConverter object.
 656  * @param s The Unicode string.
 657  * @param length The number of UChars in s, or -1 for a NUL-terminated string.
 658  * @param err Pointer to a standard ICU error code. Its input value must
 659  *            pass the U_SUCCESS() test, or else the function returns
 660  *            immediately. Check for U_FAILURE() on output or use with
 661  *            function chaining. (See User Guide for details.)
 662  *
 663  * @see ucnv_setSubstChars
 664  * @see ucnv_getSubstChars
 665  * @stable ICU 3.6
 666  */
 667 U_STABLE void U_EXPORT2
 668 ucnv_setSubstString(UConverter *cnv,
 669                     const UChar *s,
 670                     int32_t length,
 671                     UErrorCode *err);
 672 
 673 /**
 674  * Fills in the output parameter, errBytes, with the error characters from the
 675  * last failing conversion.
 676  *
 677  * @param converter the Unicode converter
 678  * @param errBytes the codepage bytes which were in error
 679  * @param len on input the capacity of errBytes, on output the number of
 680  *  bytes which were copied to it
 681  * @param err the error status code.
 682  * If the substitution character array is too small, an
 683  * &lt;TT&gt;U_INDEX_OUTOFBOUNDS_ERROR&lt;/TT&gt; will be returned.
 684  * @stable ICU 2.0
 685  */
 686 U_STABLE void U_EXPORT2
 687 ucnv_getInvalidChars(const UConverter *converter,
 688                      char *errBytes,
 689                      int8_t *len,
 690                      UErrorCode *err);
 691 
 692 /**
 693  * Fills in the output parameter, errChars, with the error characters from the
 694  * last failing conversion.
 695  *
 696  * @param converter the Unicode converter
 697  * @param errUChars the UChars which were in error
 698  * @param len on input the capacity of errUChars, on output the number of
 699  *  UChars which were copied to it
 700  * @param err the error status code.
 701  * If the substitution character array is too small, an
 702  * &lt;TT&gt;U_INDEX_OUTOFBOUNDS_ERROR&lt;/TT&gt; will be returned.
 703  * @stable ICU 2.0
 704  */
 705 U_STABLE void U_EXPORT2
 706 ucnv_getInvalidUChars(const UConverter *converter,
 707                       UChar *errUChars,
 708                       int8_t *len,
 709                       UErrorCode *err);
 710 
 711 /**
 712  * Resets the state of a converter to the default state. This is used
 713  * in the case of an error, to restart a conversion from a known default state.
 714  * It will also empty the internal output buffers.
 715  * @param converter the Unicode converter
 716  * @stable ICU 2.0
 717  */
 718 U_STABLE void U_EXPORT2
 719 ucnv_reset(UConverter *converter);
 720 
 721 /**
 722  * Resets the to-Unicode part of a converter state to the default state.
 723  * This is used in the case of an error to restart a conversion to
 724  * Unicode to a known default state. It will also empty the internal
 725  * output buffers used for the conversion to Unicode codepoints.
 726  * @param converter the Unicode converter
 727  * @stable ICU 2.0
 728  */
 729 U_STABLE void U_EXPORT2
 730 ucnv_resetToUnicode(UConverter *converter);
 731 
 732 /**
 733  * Resets the from-Unicode part of a converter state to the default state.
 734  * This is used in the case of an error to restart a conversion from
 735  * Unicode to a known default state. It will also empty the internal output
 736  * buffers used for the conversion from Unicode codepoints.
 737  * @param converter the Unicode converter
 738  * @stable ICU 2.0
 739  */
 740 U_STABLE void U_EXPORT2
 741 ucnv_resetFromUnicode(UConverter *converter);
 742 
 743 /**
 744  * Returns the maximum number of bytes that are output per UChar in conversion
 745  * from Unicode using this converter.
 746  * The returned number can be used with UCNV_GET_MAX_BYTES_FOR_STRING
 747  * to calculate the size of a target buffer for conversion from Unicode.
 748  *
 749  * Note: Before ICU 2.8, this function did not return reliable numbers for
 750  * some stateful converters (EBCDIC_STATEFUL, ISO-2022) and LMBCS.
 751  *
 752  * This number may not be the same as the maximum number of bytes per
 753  * &quot;conversion unit&quot;. In other words, it may not be the intuitively expected
 754  * number of bytes per character that would be published for a charset,
 755  * and may not fulfill any other purpose than the allocation of an output
 756  * buffer of guaranteed sufficient size for a given input length and converter.
 757  *
 758  * Examples for special cases that are taken into account:
 759  * - Supplementary code points may convert to more bytes than BMP code points.
 760  *   This function returns bytes per UChar (UTF-16 code unit), not per
 761  *   Unicode code point, for efficient buffer allocation.
 762  * - State-shifting output (SI/SO, escapes, etc.) from stateful converters.
 763  * - When m input UChars are converted to n output bytes, then the maximum m/n
 764  *   is taken into account.
 765  *
 766  * The number returned here does not take into account
 767  * (see UCNV_GET_MAX_BYTES_FOR_STRING):
 768  * - callbacks which output more than one charset character sequence per call,
 769  *   like escape callbacks
 770  * - initial and final non-character bytes that are output by some converters
 771  *   (automatic BOMs, initial escape sequence, final SI, etc.)
 772  *
 773  * Examples for returned values:
 774  * - SBCS charsets: 1
 775  * - Shift-JIS: 2
 776  * - UTF-16: 2 (2 per BMP, 4 per surrogate _pair_, BOM not counted)
 777  * - UTF-8: 3 (3 per BMP, 4 per surrogate _pair_)
 778  * - EBCDIC_STATEFUL (EBCDIC mixed SBCS/DBCS): 3 (SO + DBCS)
 779  * - ISO-2022: 3 (always outputs UTF-8)
 780  * - ISO-2022-JP: 6 (4-byte escape sequences + DBCS)
 781  * - ISO-2022-CN: 8 (4-byte designator sequences + 2-byte SS2/SS3 + DBCS)
 782  *
 783  * @param converter The Unicode converter.
 784  * @return The maximum number of bytes per UChar (16 bit code unit)
 785  *    that are output by ucnv_fromUnicode(),
 786  *    to be used together with UCNV_GET_MAX_BYTES_FOR_STRING
 787  *    for buffer allocation.
 788  *
 789  * @see UCNV_GET_MAX_BYTES_FOR_STRING
 790  * @see ucnv_getMinCharSize
 791  * @stable ICU 2.0
 792  */
 793 U_STABLE int8_t U_EXPORT2
 794 ucnv_getMaxCharSize(const UConverter *converter);
 795 
 796 /**
 797  * Calculates the size of a buffer for conversion from Unicode to a charset.
 798  * The calculated size is guaranteed to be sufficient for this conversion.
 799  *
 800  * It takes into account initial and final non-character bytes that are output
 801  * by some converters.
 802  * It does not take into account callbacks which output more than one charset
 803  * character sequence per call, like escape callbacks.
 804  * The default (substitution) callback only outputs one charset character sequence.
 805  *
 806  * @param length Number of UChars to be converted.
 807  * @param maxCharSize Return value from ucnv_getMaxCharSize() for the converter
 808  *                    that will be used.
 809  * @return Size of a buffer that will be large enough to hold the output bytes of
 810  *         converting length UChars with the converter that returned the maxCharSize.
 811  *
 812  * @see ucnv_getMaxCharSize
 813  * @stable ICU 2.8
 814  */
 815 #define UCNV_GET_MAX_BYTES_FOR_STRING(length, maxCharSize) \
 816      (((int32_t)(length)+10)*(int32_t)(maxCharSize))
 817 
 818 /**
 819  * Returns the minimum byte length (per codepoint) for characters in this codepage.
 820  * This is usually either 1 or 2.
 821  * @param converter the Unicode converter
 822  * @return the minimum number of bytes per codepoint allowed by this particular converter
 823  * @see ucnv_getMaxCharSize
 824  * @stable ICU 2.0
 825  */
 826 U_STABLE int8_t U_EXPORT2
 827 ucnv_getMinCharSize(const UConverter *converter);
 828 
 829 /**
 830  * Returns the display name of the converter passed in based on the Locale
 831  * passed in. If the locale contains no display name, the internal ASCII
 832  * name will be filled in.
 833  *
 834  * @param converter the Unicode converter.
 835  * @param displayLocale is the specific Locale we want to localized for
 836  * @param displayName user provided buffer to be filled in
 837  * @param displayNameCapacity size of displayName Buffer
 838  * @param err error status code
 839  * @return displayNameLength number of UChar needed in displayName
 840  * @see ucnv_getName
 841  * @stable ICU 2.0
 842  */
 843 U_STABLE int32_t U_EXPORT2
 844 ucnv_getDisplayName(const UConverter *converter,
 845                     const char *displayLocale,
 846                     UChar *displayName,
 847                     int32_t displayNameCapacity,
 848                     UErrorCode *err);
 849 
 850 /**
 851  * Gets the internal, canonical name of the converter (zero-terminated).
 852  * The lifetime of the returned string will be that of the converter
 853  * passed to this function.
 854  * @param converter the Unicode converter
 855  * @param err UErrorCode status
 856  * @return the internal name of the converter
 857  * @see ucnv_getDisplayName
 858  * @stable ICU 2.0
 859  */
 860 U_STABLE const char * U_EXPORT2
 861 ucnv_getName(const UConverter *converter, UErrorCode *err);
 862 
 863 /**
 864  * Gets a codepage number associated with the converter. This is not guaranteed
 865  * to be the one used to create the converter. Some converters do not represent
 866  * platform registered codepages and return zero for the codepage number.
 867  * The error code fill-in parameter indicates if the codepage number
 868  * is available.
 869  * Does not check if the converter is &lt;TT&gt;NULL&lt;/TT&gt; or if converter&#39;s data
 870  * table is &lt;TT&gt;NULL&lt;/TT&gt;.
 871  *
 872  * Important: The use of CCSIDs is not recommended because it is limited
 873  * to only two platforms in principle and only one (UCNV_IBM) in the current
 874  * ICU converter API.
 875  * Also, CCSIDs are insufficient to identify IBM Unicode conversion tables precisely.
 876  * For more details see ucnv_openCCSID().
 877  *
 878  * @param converter the Unicode converter
 879  * @param err the error status code.
 880  * @return If any error occurs, -1 will be returned otherwise, the codepage number
 881  * will be returned
 882  * @see ucnv_openCCSID
 883  * @see ucnv_getPlatform
 884  * @stable ICU 2.0
 885  */
 886 U_STABLE int32_t U_EXPORT2
 887 ucnv_getCCSID(const UConverter *converter,
 888               UErrorCode *err);
 889 
 890 /**
 891  * Gets a codepage platform associated with the converter. Currently,
 892  * only &lt;TT&gt;UCNV_IBM&lt;/TT&gt; will be returned.
 893  * Does not test if the converter is &lt;TT&gt;NULL&lt;/TT&gt; or if converter&#39;s data
 894  * table is &lt;TT&gt;NULL&lt;/TT&gt;.
 895  * @param converter the Unicode converter
 896  * @param err the error status code.
 897  * @return The codepage platform
 898  * @stable ICU 2.0
 899  */
 900 U_STABLE UConverterPlatform U_EXPORT2
 901 ucnv_getPlatform(const UConverter *converter,
 902                  UErrorCode *err);
 903 
 904 /**
 905  * Gets the type of the converter
 906  * e.g. SBCS, MBCS, DBCS, UTF8, UTF16_BE, UTF16_LE, ISO_2022,
 907  * EBCDIC_STATEFUL, LATIN_1
 908  * @param converter a valid, opened converter
 909  * @return the type of the converter
 910  * @stable ICU 2.0
 911  */
 912 U_STABLE UConverterType U_EXPORT2
 913 ucnv_getType(const UConverter * converter);
 914 
 915 /**
 916  * Gets the &quot;starter&quot; (lead) bytes for converters of type MBCS.
 917  * Will fill in an &lt;TT&gt;U_ILLEGAL_ARGUMENT_ERROR&lt;/TT&gt; if converter passed in
 918  * is not MBCS. Fills in an array of type UBool, with the value of the byte
 919  * as offset to the array. For example, if (starters[0x20] == TRUE) at return,
 920  * it means that the byte 0x20 is a starter byte in this converter.
 921  * Context pointers are always owned by the caller.
 922  *
 923  * @param converter a valid, opened converter of type MBCS
 924  * @param starters an array of size 256 to be filled in
 925  * @param err error status, &lt;TT&gt;U_ILLEGAL_ARGUMENT_ERROR&lt;/TT&gt; if the
 926  * converter is not a type which can return starters.
 927  * @see ucnv_getType
 928  * @stable ICU 2.0
 929  */
 930 U_STABLE void U_EXPORT2
 931 ucnv_getStarters(const UConverter* converter,
 932                  UBool starters[256],
 933                  UErrorCode* err);
 934 
 935 
 936 /**
 937  * Selectors for Unicode sets that can be returned by ucnv_getUnicodeSet().
 938  * @see ucnv_getUnicodeSet
 939  * @stable ICU 2.6
 940  */
 941 typedef enum UConverterUnicodeSet {
 942     /** Select the set of roundtrippable Unicode code points. @stable ICU 2.6 */
 943     UCNV_ROUNDTRIP_SET,
 944     /** Select the set of Unicode code points with roundtrip or fallback mappings. @stable ICU 4.0 */
 945     UCNV_ROUNDTRIP_AND_FALLBACK_SET,
 946 #ifndef U_HIDE_DEPRECATED_API
 947     /**
 948      * Number of UConverterUnicodeSet selectors.
 949      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
 950      */
 951     UCNV_SET_COUNT
 952 #endif  // U_HIDE_DEPRECATED_API
 953 } UConverterUnicodeSet;
 954 
 955 
 956 /**
 957  * Returns the set of Unicode code points that can be converted by an ICU converter.
 958  *
 959  * Returns one of several kinds of set:
 960  *
 961  * 1. UCNV_ROUNDTRIP_SET
 962  *
 963  * The set of all Unicode code points that can be roundtrip-converted
 964  * (converted without any data loss) with the converter (ucnv_fromUnicode()).
 965  * This set will not include code points that have fallback mappings
 966  * or are only the result of reverse fallback mappings.
 967  * This set will also not include PUA code points with fallbacks, although
 968  * ucnv_fromUnicode() will always uses those mappings despite ucnv_setFallback().
 969  * See UTR #22 &quot;Character Mapping Markup Language&quot;
 970  * at http://www.unicode.org/reports/tr22/
 971  *
 972  * This is useful for example for
 973  * - checking that a string or document can be roundtrip-converted with a converter,
 974  *   without/before actually performing the conversion
 975  * - testing if a converter can be used for text for typical text for a certain locale,
 976  *   by comparing its roundtrip set with the set of ExemplarCharacters from
 977  *   ICU&#39;s locale data or other sources
 978  *
 979  * 2. UCNV_ROUNDTRIP_AND_FALLBACK_SET
 980  *
 981  * The set of all Unicode code points that can be converted with the converter (ucnv_fromUnicode())
 982  * when fallbacks are turned on (see ucnv_setFallback()).
 983  * This set includes all code points with roundtrips and fallbacks (but not reverse fallbacks).
 984  *
 985  * In the future, there may be more UConverterUnicodeSet choices to select
 986  * sets with different properties.
 987  *
 988  * @param cnv The converter for which a set is requested.
 989  * @param setFillIn A valid USet *. It will be cleared by this function before
 990  *            the converter&#39;s specific set is filled into the USet.
 991  * @param whichSet A UConverterUnicodeSet selector;
 992  *              currently UCNV_ROUNDTRIP_SET is the only supported value.
 993  * @param pErrorCode ICU error code in/out parameter.
 994  *                   Must fulfill U_SUCCESS before the function call.
 995  *
 996  * @see UConverterUnicodeSet
 997  * @see uset_open
 998  * @see uset_close
 999  * @stable ICU 2.6
1000  */
1001 U_STABLE void U_EXPORT2
1002 ucnv_getUnicodeSet(const UConverter *cnv,
1003                    USet *setFillIn,
1004                    UConverterUnicodeSet whichSet,
1005                    UErrorCode *pErrorCode);
1006 
1007 /**
1008  * Gets the current calback function used by the converter when an illegal
1009  *  or invalid codepage sequence is found.
1010  * Context pointers are always owned by the caller.
1011  *
1012  * @param converter the unicode converter
1013  * @param action fillin: returns the callback function pointer
1014  * @param context fillin: returns the callback&#39;s private void* context
1015  * @see ucnv_setToUCallBack
1016  * @stable ICU 2.0
1017  */
1018 U_STABLE void U_EXPORT2
1019 ucnv_getToUCallBack (const UConverter * converter,
1020                      UConverterToUCallback *action,
1021                      const void **context);
1022 
1023 /**
1024  * Gets the current callback function used by the converter when illegal
1025  * or invalid Unicode sequence is found.
1026  * Context pointers are always owned by the caller.
1027  *
1028  * @param converter the unicode converter
1029  * @param action fillin: returns the callback function pointer
1030  * @param context fillin: returns the callback&#39;s private void* context
1031  * @see ucnv_setFromUCallBack
1032  * @stable ICU 2.0
1033  */
1034 U_STABLE void U_EXPORT2
1035 ucnv_getFromUCallBack (const UConverter * converter,
1036                        UConverterFromUCallback *action,
1037                        const void **context);
1038 
1039 /**
1040  * Changes the callback function used by the converter when
1041  * an illegal or invalid sequence is found.
1042  * Context pointers are always owned by the caller.
1043  * Predefined actions and contexts can be found in the ucnv_err.h header.
1044  *
1045  * @param converter the unicode converter
1046  * @param newAction the new callback function
1047  * @param newContext the new toUnicode callback context pointer. This can be NULL.
1048  * @param oldAction fillin: returns the old callback function pointer. This can be NULL.
1049  * @param oldContext fillin: returns the old callback&#39;s private void* context. This can be NULL.
1050  * @param err The error code status
1051  * @see ucnv_getToUCallBack
1052  * @stable ICU 2.0
1053  */
1054 U_STABLE void U_EXPORT2
1055 ucnv_setToUCallBack (UConverter * converter,
1056                      UConverterToUCallback newAction,
1057                      const void* newContext,
1058                      UConverterToUCallback *oldAction,
1059                      const void** oldContext,
1060                      UErrorCode * err);
1061 
1062 /**
1063  * Changes the current callback function used by the converter when
1064  * an illegal or invalid sequence is found.
1065  * Context pointers are always owned by the caller.
1066  * Predefined actions and contexts can be found in the ucnv_err.h header.
1067  *
1068  * @param converter the unicode converter
1069  * @param newAction the new callback function
1070  * @param newContext the new fromUnicode callback context pointer. This can be NULL.
1071  * @param oldAction fillin: returns the old callback function pointer. This can be NULL.
1072  * @param oldContext fillin: returns the old callback&#39;s private void* context. This can be NULL.
1073  * @param err The error code status
1074  * @see ucnv_getFromUCallBack
1075  * @stable ICU 2.0
1076  */
1077 U_STABLE void U_EXPORT2
1078 ucnv_setFromUCallBack (UConverter * converter,
1079                        UConverterFromUCallback newAction,
1080                        const void *newContext,
1081                        UConverterFromUCallback *oldAction,
1082                        const void **oldContext,
1083                        UErrorCode * err);
1084 
1085 /**
1086  * Converts an array of unicode characters to an array of codepage
1087  * characters. This function is optimized for converting a continuous
1088  * stream of data in buffer-sized chunks, where the entire source and
1089  * target does not fit in available buffers.
1090  *
1091  * The source pointer is an in/out parameter. It starts out pointing where the
1092  * conversion is to begin, and ends up pointing after the last UChar consumed.
1093  *
1094  * Target similarly starts out pointer at the first available byte in the output
1095  * buffer, and ends up pointing after the last byte written to the output.
1096  *
1097  * The converter always attempts to consume the entire source buffer, unless
1098  * (1.) the target buffer is full, or (2.) a failing error is returned from the
1099  * current callback function.  When a successful error status has been
1100  * returned, it means that all of the source buffer has been
1101  *  consumed. At that point, the caller should reset the source and
1102  *  sourceLimit pointers to point to the next chunk.
1103  *
1104  * At the end of the stream (flush==TRUE), the input is completely consumed
1105  * when *source==sourceLimit and no error code is set.
1106  * The converter object is then automatically reset by this function.
1107  * (This means that a converter need not be reset explicitly between data
1108  * streams if it finishes the previous stream without errors.)
1109  *
1110  * This is a &lt;I&gt;stateful&lt;/I&gt; conversion. Additionally, even when all source data has
1111  * been consumed, some data may be in the converters&#39; internal state.
1112  * Call this function repeatedly, updating the target pointers with
1113  * the next empty chunk of target in case of a
1114  * &lt;TT&gt;U_BUFFER_OVERFLOW_ERROR&lt;/TT&gt;, and updating the source  pointers
1115  *  with the next chunk of source when a successful error status is
1116  * returned, until there are no more chunks of source data.
1117  * @param converter the Unicode converter
1118  * @param target I/O parameter. Input : Points to the beginning of the buffer to copy
1119  *  codepage characters to. Output : points to after the last codepage character copied
1120  *  to &lt;TT&gt;target&lt;/TT&gt;.
1121  * @param targetLimit the pointer just after last of the &lt;TT&gt;target&lt;/TT&gt; buffer
1122  * @param source I/O parameter, pointer to pointer to the source Unicode character buffer.
1123  * @param sourceLimit the pointer just after the last of the source buffer
1124  * @param offsets if NULL is passed, nothing will happen to it, otherwise it needs to have the same number
1125  * of allocated cells as &lt;TT&gt;target&lt;/TT&gt;. Will fill in offsets from target to source pointer
1126  * e.g: &lt;TT&gt;offsets[3]&lt;/TT&gt; is equal to 6, it means that the &lt;TT&gt;target[3]&lt;/TT&gt; was a result of transcoding &lt;TT&gt;source[6]&lt;/TT&gt;
1127  * For output data carried across calls, and other data without a specific source character
1128  * (such as from escape sequences or callbacks)  -1 will be placed for offsets.
1129  * @param flush set to &lt;TT&gt;TRUE&lt;/TT&gt; if the current source buffer is the last available
1130  * chunk of the source, &lt;TT&gt;FALSE&lt;/TT&gt; otherwise. Note that if a failing status is returned,
1131  * this function may have to be called multiple times with flush set to &lt;TT&gt;TRUE&lt;/TT&gt; until
1132  * the source buffer is consumed.
1133  * @param err the error status.  &lt;TT&gt;U_ILLEGAL_ARGUMENT_ERROR&lt;/TT&gt; will be set if the
1134  * converter is &lt;TT&gt;NULL&lt;/TT&gt;.
1135  * &lt;code&gt;U_BUFFER_OVERFLOW_ERROR&lt;/code&gt; will be set if the target is full and there is
1136  * still data to be written to the target.
1137  * @see ucnv_fromUChars
1138  * @see ucnv_convert
1139  * @see ucnv_getMinCharSize
1140  * @see ucnv_setToUCallBack
1141  * @stable ICU 2.0
1142  */
1143 U_STABLE void U_EXPORT2
1144 ucnv_fromUnicode (UConverter * converter,
1145                   char **target,
1146                   const char *targetLimit,
1147                   const UChar ** source,
1148                   const UChar * sourceLimit,
1149                   int32_t* offsets,
1150                   UBool flush,
1151                   UErrorCode * err);
1152 
1153 /**
1154  * Converts a buffer of codepage bytes into an array of unicode UChars
1155  * characters. This function is optimized for converting a continuous
1156  * stream of data in buffer-sized chunks, where the entire source and
1157  * target does not fit in available buffers.
1158  *
1159  * The source pointer is an in/out parameter. It starts out pointing where the
1160  * conversion is to begin, and ends up pointing after the last byte of source consumed.
1161  *
1162  * Target similarly starts out pointer at the first available UChar in the output
1163  * buffer, and ends up pointing after the last UChar written to the output.
1164  * It does NOT necessarily keep UChar sequences together.
1165  *
1166  * The converter always attempts to consume the entire source buffer, unless
1167  * (1.) the target buffer is full, or (2.) a failing error is returned from the
1168  * current callback function.  When a successful error status has been
1169  * returned, it means that all of the source buffer has been
1170  *  consumed. At that point, the caller should reset the source and
1171  *  sourceLimit pointers to point to the next chunk.
1172  *
1173  * At the end of the stream (flush==TRUE), the input is completely consumed
1174  * when *source==sourceLimit and no error code is set
1175  * The converter object is then automatically reset by this function.
1176  * (This means that a converter need not be reset explicitly between data
1177  * streams if it finishes the previous stream without errors.)
1178  *
1179  * This is a &lt;I&gt;stateful&lt;/I&gt; conversion. Additionally, even when all source data has
1180  * been consumed, some data may be in the converters&#39; internal state.
1181  * Call this function repeatedly, updating the target pointers with
1182  * the next empty chunk of target in case of a
1183  * &lt;TT&gt;U_BUFFER_OVERFLOW_ERROR&lt;/TT&gt;, and updating the source  pointers
1184  *  with the next chunk of source when a successful error status is
1185  * returned, until there are no more chunks of source data.
1186  * @param converter the Unicode converter
1187  * @param target I/O parameter. Input : Points to the beginning of the buffer to copy
1188  *  UChars into. Output : points to after the last UChar copied.
1189  * @param targetLimit the pointer just after the end of the &lt;TT&gt;target&lt;/TT&gt; buffer
1190  * @param source I/O parameter, pointer to pointer to the source codepage buffer.
1191  * @param sourceLimit the pointer to the byte after the end of the source buffer
1192  * @param offsets if NULL is passed, nothing will happen to it, otherwise it needs to have the same number
1193  * of allocated cells as &lt;TT&gt;target&lt;/TT&gt;. Will fill in offsets from target to source pointer
1194  * e.g: &lt;TT&gt;offsets[3]&lt;/TT&gt; is equal to 6, it means that the &lt;TT&gt;target[3]&lt;/TT&gt; was a result of transcoding &lt;TT&gt;source[6]&lt;/TT&gt;
1195  * For output data carried across calls, and other data without a specific source character
1196  * (such as from escape sequences or callbacks)  -1 will be placed for offsets.
1197  * @param flush set to &lt;TT&gt;TRUE&lt;/TT&gt; if the current source buffer is the last available
1198  * chunk of the source, &lt;TT&gt;FALSE&lt;/TT&gt; otherwise. Note that if a failing status is returned,
1199  * this function may have to be called multiple times with flush set to &lt;TT&gt;TRUE&lt;/TT&gt; until
1200  * the source buffer is consumed.
1201  * @param err the error status.  &lt;TT&gt;U_ILLEGAL_ARGUMENT_ERROR&lt;/TT&gt; will be set if the
1202  * converter is &lt;TT&gt;NULL&lt;/TT&gt;.
1203  * &lt;code&gt;U_BUFFER_OVERFLOW_ERROR&lt;/code&gt; will be set if the target is full and there is
1204  * still data to be written to the target.
1205  * @see ucnv_fromUChars
1206  * @see ucnv_convert
1207  * @see ucnv_getMinCharSize
1208  * @see ucnv_setFromUCallBack
1209  * @see ucnv_getNextUChar
1210  * @stable ICU 2.0
1211  */
1212 U_STABLE void U_EXPORT2
1213 ucnv_toUnicode(UConverter *converter,
1214                UChar **target,
1215                const UChar *targetLimit,
1216                const char **source,
1217                const char *sourceLimit,
1218                int32_t *offsets,
1219                UBool flush,
1220                UErrorCode *err);
1221 
1222 /**
1223  * Convert the Unicode string into a codepage string using an existing UConverter.
1224  * The output string is NUL-terminated if possible.
1225  *
1226  * This function is a more convenient but less powerful version of ucnv_fromUnicode().
1227  * It is only useful for whole strings, not for streaming conversion.
1228  *
1229  * The maximum output buffer capacity required (barring output from callbacks) will be
1230  * UCNV_GET_MAX_BYTES_FOR_STRING(srcLength, ucnv_getMaxCharSize(cnv)).
1231  *
1232  * @param cnv the converter object to be used (ucnv_resetFromUnicode() will be called)
1233  * @param src the input Unicode string
1234  * @param srcLength the input string length, or -1 if NUL-terminated
1235  * @param dest destination string buffer, can be NULL if destCapacity==0
1236  * @param destCapacity the number of chars available at dest
1237  * @param pErrorCode normal ICU error code;
1238  *                  common error codes that may be set by this function include
1239  *                  U_BUFFER_OVERFLOW_ERROR, U_STRING_NOT_TERMINATED_WARNING,
1240  *                  U_ILLEGAL_ARGUMENT_ERROR, and conversion errors
1241  * @return the length of the output string, not counting the terminating NUL;
1242  *         if the length is greater than destCapacity, then the string will not fit
1243  *         and a buffer of the indicated length would need to be passed in
1244  * @see ucnv_fromUnicode
1245  * @see ucnv_convert
1246  * @see UCNV_GET_MAX_BYTES_FOR_STRING
1247  * @stable ICU 2.0
1248  */
1249 U_STABLE int32_t U_EXPORT2
1250 ucnv_fromUChars(UConverter *cnv,
1251                 char *dest, int32_t destCapacity,
1252                 const UChar *src, int32_t srcLength,
1253                 UErrorCode *pErrorCode);
1254 
1255 /**
1256  * Convert the codepage string into a Unicode string using an existing UConverter.
1257  * The output string is NUL-terminated if possible.
1258  *
1259  * This function is a more convenient but less powerful version of ucnv_toUnicode().
1260  * It is only useful for whole strings, not for streaming conversion.
1261  *
1262  * The maximum output buffer capacity required (barring output from callbacks) will be
1263  * 2*srcLength (each char may be converted into a surrogate pair).
1264  *
1265  * @param cnv the converter object to be used (ucnv_resetToUnicode() will be called)
1266  * @param src the input codepage string
1267  * @param srcLength the input string length, or -1 if NUL-terminated
1268  * @param dest destination string buffer, can be NULL if destCapacity==0
1269  * @param destCapacity the number of UChars available at dest
1270  * @param pErrorCode normal ICU error code;
1271  *                  common error codes that may be set by this function include
1272  *                  U_BUFFER_OVERFLOW_ERROR, U_STRING_NOT_TERMINATED_WARNING,
1273  *                  U_ILLEGAL_ARGUMENT_ERROR, and conversion errors
1274  * @return the length of the output string, not counting the terminating NUL;
1275  *         if the length is greater than destCapacity, then the string will not fit
1276  *         and a buffer of the indicated length would need to be passed in
1277  * @see ucnv_toUnicode
1278  * @see ucnv_convert
1279  * @stable ICU 2.0
1280  */
1281 U_STABLE int32_t U_EXPORT2
1282 ucnv_toUChars(UConverter *cnv,
1283               UChar *dest, int32_t destCapacity,
1284               const char *src, int32_t srcLength,
1285               UErrorCode *pErrorCode);
1286 
1287 /**
1288  * Convert a codepage buffer into Unicode one character at a time.
1289  * The input is completely consumed when the U_INDEX_OUTOFBOUNDS_ERROR is set.
1290  *
1291  * Advantage compared to ucnv_toUnicode() or ucnv_toUChars():
1292  * - Faster for small amounts of data, for most converters, e.g.,
1293  *   US-ASCII, ISO-8859-1, UTF-8/16/32, and most &quot;normal&quot; charsets.
1294  *   (For complex converters, e.g., SCSU, UTF-7 and ISO 2022 variants,
1295  *    it uses ucnv_toUnicode() internally.)
1296  * - Convenient.
1297  *
1298  * Limitations compared to ucnv_toUnicode():
1299  * - Always assumes flush=TRUE.
1300  *   This makes ucnv_getNextUChar() unsuitable for &quot;streaming&quot; conversion,
1301  *   that is, for where the input is supplied in multiple buffers,
1302  *   because ucnv_getNextUChar() will assume the end of the input at the end
1303  *   of the first buffer.
1304  * - Does not provide offset output.
1305  *
1306  * It is possible to &quot;mix&quot; ucnv_getNextUChar() and ucnv_toUnicode() because
1307  * ucnv_getNextUChar() uses the current state of the converter
1308  * (unlike ucnv_toUChars() which always resets first).
1309  * However, if ucnv_getNextUChar() is called after ucnv_toUnicode()
1310  * stopped in the middle of a character sequence (with flush=FALSE),
1311  * then ucnv_getNextUChar() will always use the slower ucnv_toUnicode()
1312  * internally until the next character boundary.
1313  * (This is new in ICU 2.6. In earlier releases, ucnv_getNextUChar() had to
1314  * start at a character boundary.)
1315  *
1316  * Instead of using ucnv_getNextUChar(), it is recommended
1317  * to convert using ucnv_toUnicode() or ucnv_toUChars()
1318  * and then iterate over the text using U16_NEXT() or a UCharIterator (uiter.h)
1319  * or a C++ CharacterIterator or similar.
1320  * This allows streaming conversion and offset output, for example.
1321  *
1322  * &lt;p&gt;Handling of surrogate pairs and supplementary-plane code points:&lt;br&gt;
1323  * There are two different kinds of codepages that provide mappings for surrogate characters:
1324  * &lt;ul&gt;
1325  *   &lt;li&gt;Codepages like UTF-8, UTF-32, and GB 18030 provide direct representations for Unicode
1326  *       code points U+10000-U+10ffff as well as for single surrogates U+d800-U+dfff.
1327  *       Each valid sequence will result in exactly one returned code point.
1328  *       If a sequence results in a single surrogate, then that will be returned
1329  *       by itself, even if a neighboring sequence encodes the matching surrogate.&lt;/li&gt;
1330  *   &lt;li&gt;Codepages like SCSU and LMBCS (and UTF-16) provide direct representations only for BMP code points
1331  *       including surrogates. Code points in supplementary planes are represented with
1332  *       two sequences, each encoding a surrogate.
1333  *       For these codepages, matching pairs of surrogates will be combined into single
1334  *       code points for returning from this function.
1335  *       (Note that SCSU is actually a mix of these codepage types.)&lt;/li&gt;
1336  * &lt;/ul&gt;&lt;/p&gt;
1337  *
1338  * @param converter an open UConverter
1339  * @param source the address of a pointer to the codepage buffer, will be
1340  *  updated to point after the bytes consumed in the conversion call.
1341  * @param sourceLimit points to the end of the input buffer
1342  * @param err fills in error status (see ucnv_toUnicode)
1343  * &lt;code&gt;U_INDEX_OUTOFBOUNDS_ERROR&lt;/code&gt; will be set if the input
1344  * is empty or does not convert to any output (e.g.: pure state-change
1345  * codes SI/SO, escape sequences for ISO 2022,
1346  * or if the callback did not output anything, ...).
1347  * This function will not set a &lt;code&gt;U_BUFFER_OVERFLOW_ERROR&lt;/code&gt; because
1348  *  the &quot;buffer&quot; is the return code. However, there might be subsequent output
1349  *  stored in the converter object
1350  * that will be returned in following calls to this function.
1351  * @return a UChar32 resulting from the partial conversion of source
1352  * @see ucnv_toUnicode
1353  * @see ucnv_toUChars
1354  * @see ucnv_convert
1355  * @stable ICU 2.0
1356  */
1357 U_STABLE UChar32 U_EXPORT2
1358 ucnv_getNextUChar(UConverter * converter,
1359                   const char **source,
1360                   const char * sourceLimit,
1361                   UErrorCode * err);
1362 
1363 /**
1364  * Convert from one external charset to another using two existing UConverters.
1365  * Internally, two conversions - ucnv_toUnicode() and ucnv_fromUnicode() -
1366  * are used, &quot;pivoting&quot; through 16-bit Unicode.
1367  *
1368  * Important: For streaming conversion (multiple function calls for successive
1369  * parts of a text stream), the caller must provide a pivot buffer explicitly,
1370  * and must preserve the pivot buffer and associated pointers from one
1371  * call to another. (The buffer may be moved if its contents and the relative
1372  * pointer positions are preserved.)
1373  *
1374  * There is a similar function, ucnv_convert(),
1375  * which has the following limitations:
1376  * - it takes charset names, not converter objects, so that
1377  *   - two converters are opened for each call
1378  *   - only single-string conversion is possible, not streaming operation
1379  * - it does not provide enough information to find out,
1380  *   in case of failure, whether the toUnicode or
1381  *   the fromUnicode conversion failed
1382  *
1383  * By contrast, ucnv_convertEx()
1384  * - takes UConverter parameters instead of charset names
1385  * - fully exposes the pivot buffer for streaming conversion and complete error handling
1386  *
1387  * ucnv_convertEx() also provides further convenience:
1388  * - an option to reset the converters at the beginning
1389  *   (if reset==TRUE, see parameters;
1390  *    also sets *pivotTarget=*pivotSource=pivotStart)
1391  * - allow NUL-terminated input
1392  *   (only a single NUL byte, will not work for charsets with multi-byte NULs)
1393  *   (if sourceLimit==NULL, see parameters)
1394  * - terminate with a NUL on output
1395  *   (only a single NUL byte, not useful for charsets with multi-byte NULs),
1396  *   or set U_STRING_NOT_TERMINATED_WARNING if the output exactly fills
1397  *   the target buffer
1398  * - the pivot buffer can be provided internally;
1399  *   possible only for whole-string conversion, not streaming conversion;
1400  *   in this case, the caller will not be able to get details about where an
1401  *   error occurred
1402  *   (if pivotStart==NULL, see below)
1403  *
1404  * The function returns when one of the following is true:
1405  * - the entire source text has been converted successfully to the target buffer
1406  * - a target buffer overflow occurred (U_BUFFER_OVERFLOW_ERROR)
1407  * - a conversion error occurred
1408  *   (other U_FAILURE(), see description of pErrorCode)
1409  *
1410  * Limitation compared to the direct use of
1411  * ucnv_fromUnicode() and ucnv_toUnicode():
1412  * ucnv_convertEx() does not provide offset information.
1413  *
1414  * Limitation compared to ucnv_fromUChars() and ucnv_toUChars():
1415  * ucnv_convertEx() does not support preflighting directly.
1416  *
1417  * Sample code for converting a single string from
1418  * one external charset to UTF-8, ignoring the location of errors:
1419  *
1420  * \code
1421  * int32_t
1422  * myToUTF8(UConverter *cnv,
1423  *          const char *s, int32_t length,
1424  *          char *u8, int32_t capacity,
1425  *          UErrorCode *pErrorCode) {
1426  *     UConverter *utf8Cnv;
1427  *     char *target;
1428  *
1429  *     if(U_FAILURE(*pErrorCode)) {
1430  *         return 0;
1431  *     }
1432  *
1433  *     utf8Cnv=myGetCachedUTF8Converter(pErrorCode);
1434  *     if(U_FAILURE(*pErrorCode)) {
1435  *         return 0;
1436  *     }
1437  *
1438  *     if(length&lt;0) {
1439  *         length=strlen(s);
1440  *     }
1441  *     target=u8;
1442  *     ucnv_convertEx(utf8Cnv, cnv,
1443  *                    &amp;target, u8+capacity,
1444  *                    &amp;s, s+length,
1445  *                    NULL, NULL, NULL, NULL,
1446  *                    TRUE, TRUE,
1447  *                    pErrorCode);
1448  *
1449  *     myReleaseCachedUTF8Converter(utf8Cnv);
1450  *
1451  *     // return the output string length, but without preflighting
1452  *     return (int32_t)(target-u8);
1453  * }
1454  * \endcode
1455  *
1456  * @param targetCnv     Output converter, used to convert from the UTF-16 pivot
1457  *                      to the target using ucnv_fromUnicode().
1458  * @param sourceCnv     Input converter, used to convert from the source to
1459  *                      the UTF-16 pivot using ucnv_toUnicode().
1460  * @param target        I/O parameter, same as for ucnv_fromUChars().
1461  *                      Input: *target points to the beginning of the target buffer.
1462  *                      Output: *target points to the first unit after the last char written.
1463  * @param targetLimit   Pointer to the first unit after the target buffer.
1464  * @param source        I/O parameter, same as for ucnv_toUChars().
1465  *                      Input: *source points to the beginning of the source buffer.
1466  *                      Output: *source points to the first unit after the last char read.
1467  * @param sourceLimit   Pointer to the first unit after the source buffer.
1468  * @param pivotStart    Pointer to the UTF-16 pivot buffer. If pivotStart==NULL,
1469  *                      then an internal buffer is used and the other pivot
1470  *                      arguments are ignored and can be NULL as well.
1471  * @param pivotSource   I/O parameter, same as source in ucnv_fromUChars() for
1472  *                      conversion from the pivot buffer to the target buffer.
1473  * @param pivotTarget   I/O parameter, same as target in ucnv_toUChars() for
1474  *                      conversion from the source buffer to the pivot buffer.
1475  *                      It must be pivotStart&lt;=*pivotSource&lt;=*pivotTarget&lt;=pivotLimit
1476  *                      and pivotStart&lt;pivotLimit (unless pivotStart==NULL).
1477  * @param pivotLimit    Pointer to the first unit after the pivot buffer.
1478  * @param reset         If TRUE, then ucnv_resetToUnicode(sourceCnv) and
1479  *                      ucnv_resetFromUnicode(targetCnv) are called, and the
1480  *                      pivot pointers are reset (*pivotTarget=*pivotSource=pivotStart).
1481  * @param flush         If true, indicates the end of the input.
1482  *                      Passed directly to ucnv_toUnicode(), and carried over to
1483  *                      ucnv_fromUnicode() when the source is empty as well.
1484  * @param pErrorCode    ICU error code in/out parameter.
1485  *                      Must fulfill U_SUCCESS before the function call.
1486  *                      U_BUFFER_OVERFLOW_ERROR always refers to the target buffer
1487  *                      because overflows into the pivot buffer are handled internally.
1488  *                      Other conversion errors are from the source-to-pivot
1489  *                      conversion if *pivotSource==pivotStart, otherwise from
1490  *                      the pivot-to-target conversion.
1491  *
1492  * @see ucnv_convert
1493  * @see ucnv_fromAlgorithmic
1494  * @see ucnv_toAlgorithmic
1495  * @see ucnv_fromUnicode
1496  * @see ucnv_toUnicode
1497  * @see ucnv_fromUChars
1498  * @see ucnv_toUChars
1499  * @stable ICU 2.6
1500  */
1501 U_STABLE void U_EXPORT2
1502 ucnv_convertEx(UConverter *targetCnv, UConverter *sourceCnv,
1503                char **target, const char *targetLimit,
1504                const char **source, const char *sourceLimit,
1505                UChar *pivotStart, UChar **pivotSource,
1506                UChar **pivotTarget, const UChar *pivotLimit,
1507                UBool reset, UBool flush,
1508                UErrorCode *pErrorCode);
1509 
1510 /**
1511  * Convert from one external charset to another.
1512  * Internally, two converters are opened according to the name arguments,
1513  * then the text is converted to and from the 16-bit Unicode &quot;pivot&quot;
1514  * using ucnv_convertEx(), then the converters are closed again.
1515  *
1516  * This is a convenience function, not an efficient way to convert a lot of text:
1517  * ucnv_convert()
1518  * - takes charset names, not converter objects, so that
1519  *   - two converters are opened for each call
1520  *   - only single-string conversion is possible, not streaming operation
1521  * - does not provide enough information to find out,
1522  *   in case of failure, whether the toUnicode or
1523  *   the fromUnicode conversion failed
1524  * - allows NUL-terminated input
1525  *   (only a single NUL byte, will not work for charsets with multi-byte NULs)
1526  *   (if sourceLength==-1, see parameters)
1527  * - terminate with a NUL on output
1528  *   (only a single NUL byte, not useful for charsets with multi-byte NULs),
1529  *   or set U_STRING_NOT_TERMINATED_WARNING if the output exactly fills
1530  *   the target buffer
1531  * - a pivot buffer is provided internally
1532  *
1533  * The function returns when one of the following is true:
1534  * - the entire source text has been converted successfully to the target buffer
1535  *   and either the target buffer is terminated with a single NUL byte
1536  *   or the error code is set to U_STRING_NOT_TERMINATED_WARNING
1537  * - a target buffer overflow occurred (U_BUFFER_OVERFLOW_ERROR)
1538  *   and the full output string length is returned (&quot;preflighting&quot;)
1539  * - a conversion error occurred
1540  *   (other U_FAILURE(), see description of pErrorCode)
1541  *
1542  * @param toConverterName   The name of the converter that is used to convert
1543  *                          from the UTF-16 pivot buffer to the target.
1544  * @param fromConverterName The name of the converter that is used to convert
1545  *                          from the source to the UTF-16 pivot buffer.
1546  * @param target            Pointer to the output buffer.
1547  * @param targetCapacity    Capacity of the target, in bytes.
1548  * @param source            Pointer to the input buffer.
1549  * @param sourceLength      Length of the input text, in bytes, or -1 for NUL-terminated input.
1550  * @param pErrorCode        ICU error code in/out parameter.
1551  *                          Must fulfill U_SUCCESS before the function call.
1552  * @return Length of the complete output text in bytes, even if it exceeds the targetCapacity
1553  *         and a U_BUFFER_OVERFLOW_ERROR is set.
1554  *
1555  * @see ucnv_convertEx
1556  * @see ucnv_fromAlgorithmic
1557  * @see ucnv_toAlgorithmic
1558  * @see ucnv_fromUnicode
1559  * @see ucnv_toUnicode
1560  * @see ucnv_fromUChars
1561  * @see ucnv_toUChars
1562  * @see ucnv_getNextUChar
1563  * @stable ICU 2.0
1564  */
1565 U_STABLE int32_t U_EXPORT2
1566 ucnv_convert(const char *toConverterName,
1567              const char *fromConverterName,
1568              char *target,
1569              int32_t targetCapacity,
1570              const char *source,
1571              int32_t sourceLength,
1572              UErrorCode *pErrorCode);
1573 
1574 /**
1575  * Convert from one external charset to another.
1576  * Internally, the text is converted to and from the 16-bit Unicode &quot;pivot&quot;
1577  * using ucnv_convertEx(). ucnv_toAlgorithmic() works exactly like ucnv_convert()
1578  * except that the two converters need not be looked up and opened completely.
1579  *
1580  * The source-to-pivot conversion uses the cnv converter parameter.
1581  * The pivot-to-target conversion uses a purely algorithmic converter
1582  * according to the specified type, e.g., UCNV_UTF8 for a UTF-8 converter.
1583  *
1584  * Internally, the algorithmic converter is opened and closed for each
1585  * function call, which is more efficient than using the public ucnv_open()
1586  * but somewhat less efficient than only resetting an existing converter
1587  * and using ucnv_convertEx().
1588  *
1589  * This function is more convenient than ucnv_convertEx() for single-string
1590  * conversions, especially when &quot;preflighting&quot; is desired (returning the length
1591  * of the complete output even if it does not fit into the target buffer;
1592  * see the User Guide Strings chapter). See ucnv_convert() for details.
1593  *
1594  * @param algorithmicType   UConverterType constant identifying the desired target
1595  *                          charset as a purely algorithmic converter.
1596  *                          Those are converters for Unicode charsets like
1597  *                          UTF-8, BOCU-1, SCSU, UTF-7, IMAP-mailbox-name, etc.,
1598  *                          as well as US-ASCII and ISO-8859-1.
1599  * @param cnv               The converter that is used to convert
1600  *                          from the source to the UTF-16 pivot buffer.
1601  * @param target            Pointer to the output buffer.
1602  * @param targetCapacity    Capacity of the target, in bytes.
1603  * @param source            Pointer to the input buffer.
1604  * @param sourceLength      Length of the input text, in bytes
1605  * @param pErrorCode        ICU error code in/out parameter.
1606  *                          Must fulfill U_SUCCESS before the function call.
1607  * @return Length of the complete output text in bytes, even if it exceeds the targetCapacity
1608  *         and a U_BUFFER_OVERFLOW_ERROR is set.
1609  *
1610  * @see ucnv_fromAlgorithmic
1611  * @see ucnv_convert
1612  * @see ucnv_convertEx
1613  * @see ucnv_fromUnicode
1614  * @see ucnv_toUnicode
1615  * @see ucnv_fromUChars
1616  * @see ucnv_toUChars
1617  * @stable ICU 2.6
1618  */
1619 U_STABLE int32_t U_EXPORT2
1620 ucnv_toAlgorithmic(UConverterType algorithmicType,
1621                    UConverter *cnv,
1622                    char *target, int32_t targetCapacity,
1623                    const char *source, int32_t sourceLength,
1624                    UErrorCode *pErrorCode);
1625 
1626 /**
1627  * Convert from one external charset to another.
1628  * Internally, the text is converted to and from the 16-bit Unicode &quot;pivot&quot;
1629  * using ucnv_convertEx(). ucnv_fromAlgorithmic() works exactly like ucnv_convert()
1630  * except that the two converters need not be looked up and opened completely.
1631  *
1632  * The source-to-pivot conversion uses a purely algorithmic converter
1633  * according to the specified type, e.g., UCNV_UTF8 for a UTF-8 converter.
1634  * The pivot-to-target conversion uses the cnv converter parameter.
1635  *
1636  * Internally, the algorithmic converter is opened and closed for each
1637  * function call, which is more efficient than using the public ucnv_open()
1638  * but somewhat less efficient than only resetting an existing converter
1639  * and using ucnv_convertEx().
1640  *
1641  * This function is more convenient than ucnv_convertEx() for single-string
1642  * conversions, especially when &quot;preflighting&quot; is desired (returning the length
1643  * of the complete output even if it does not fit into the target buffer;
1644  * see the User Guide Strings chapter). See ucnv_convert() for details.
1645  *
1646  * @param cnv               The converter that is used to convert
1647  *                          from the UTF-16 pivot buffer to the target.
1648  * @param algorithmicType   UConverterType constant identifying the desired source
1649  *                          charset as a purely algorithmic converter.
1650  *                          Those are converters for Unicode charsets like
1651  *                          UTF-8, BOCU-1, SCSU, UTF-7, IMAP-mailbox-name, etc.,
1652  *                          as well as US-ASCII and ISO-8859-1.
1653  * @param target            Pointer to the output buffer.
1654  * @param targetCapacity    Capacity of the target, in bytes.
1655  * @param source            Pointer to the input buffer.
1656  * @param sourceLength      Length of the input text, in bytes
1657  * @param pErrorCode        ICU error code in/out parameter.
1658  *                          Must fulfill U_SUCCESS before the function call.
1659  * @return Length of the complete output text in bytes, even if it exceeds the targetCapacity
1660  *         and a U_BUFFER_OVERFLOW_ERROR is set.
1661  *
1662  * @see ucnv_fromAlgorithmic
1663  * @see ucnv_convert
1664  * @see ucnv_convertEx
1665  * @see ucnv_fromUnicode
1666  * @see ucnv_toUnicode
1667  * @see ucnv_fromUChars
1668  * @see ucnv_toUChars
1669  * @stable ICU 2.6
1670  */
1671 U_STABLE int32_t U_EXPORT2
1672 ucnv_fromAlgorithmic(UConverter *cnv,
1673                      UConverterType algorithmicType,
1674                      char *target, int32_t targetCapacity,
1675                      const char *source, int32_t sourceLength,
1676                      UErrorCode *pErrorCode);
1677 
1678 /**
1679  * Frees up memory occupied by unused, cached converter shared data.
1680  *
1681  * @return the number of cached converters successfully deleted
1682  * @see ucnv_close
1683  * @stable ICU 2.0
1684  */
1685 U_STABLE int32_t U_EXPORT2
1686 ucnv_flushCache(void);
1687 
1688 /**
1689  * Returns the number of available converters, as per the alias file.
1690  *
1691  * @return the number of available converters
1692  * @see ucnv_getAvailableName
1693  * @stable ICU 2.0
1694  */
1695 U_STABLE int32_t U_EXPORT2
1696 ucnv_countAvailable(void);
1697 
1698 /**
1699  * Gets the canonical converter name of the specified converter from a list of
1700  * all available converters contaied in the alias file. All converters
1701  * in this list can be opened.
1702  *
1703  * @param n the index to a converter available on the system (in the range &lt;TT&gt;[0..ucnv_countAvaiable()]&lt;/TT&gt;)
1704  * @return a pointer a string (library owned), or &lt;TT&gt;NULL&lt;/TT&gt; if the index is out of bounds.
1705  * @see ucnv_countAvailable
1706  * @stable ICU 2.0
1707  */
1708 U_STABLE const char* U_EXPORT2
1709 ucnv_getAvailableName(int32_t n);
1710 
1711 /**
1712  * Returns a UEnumeration to enumerate all of the canonical converter
1713  * names, as per the alias file, regardless of the ability to open each
1714  * converter.
1715  *
1716  * @return A UEnumeration object for getting all the recognized canonical
1717  *   converter names.
1718  * @see ucnv_getAvailableName
1719  * @see uenum_close
1720  * @see uenum_next
1721  * @stable ICU 2.4
1722  */
1723 U_STABLE UEnumeration * U_EXPORT2
1724 ucnv_openAllNames(UErrorCode *pErrorCode);
1725 
1726 /**
1727  * Gives the number of aliases for a given converter or alias name.
1728  * If the alias is ambiguous, then the preferred converter is used
1729  * and the status is set to U_AMBIGUOUS_ALIAS_WARNING.
1730  * This method only enumerates the listed entries in the alias file.
1731  * @param alias alias name
1732  * @param pErrorCode error status
1733  * @return number of names on alias list for given alias
1734  * @stable ICU 2.0
1735  */
1736 U_STABLE uint16_t U_EXPORT2
1737 ucnv_countAliases(const char *alias, UErrorCode *pErrorCode);
1738 
1739 /**
1740  * Gives the name of the alias at given index of alias list.
1741  * This method only enumerates the listed entries in the alias file.
1742  * If the alias is ambiguous, then the preferred converter is used
1743  * and the status is set to U_AMBIGUOUS_ALIAS_WARNING.
1744  * @param alias alias name
1745  * @param n index in alias list
1746  * @param pErrorCode result of operation
1747  * @return returns the name of the alias at given index
1748  * @see ucnv_countAliases
1749  * @stable ICU 2.0
1750  */
1751 U_STABLE const char * U_EXPORT2
1752 ucnv_getAlias(const char *alias, uint16_t n, UErrorCode *pErrorCode);
1753 
1754 /**
1755  * Fill-up the list of alias names for the given alias.
1756  * This method only enumerates the listed entries in the alias file.
1757  * If the alias is ambiguous, then the preferred converter is used
1758  * and the status is set to U_AMBIGUOUS_ALIAS_WARNING.
1759  * @param alias alias name
1760  * @param aliases fill-in list, aliases is a pointer to an array of
1761  *        &lt;code&gt;ucnv_countAliases()&lt;/code&gt; string-pointers
1762  *        (&lt;code&gt;const char *&lt;/code&gt;) that will be filled in.
1763  *        The strings themselves are owned by the library.
1764  * @param pErrorCode result of operation
1765  * @stable ICU 2.0
1766  */
1767 U_STABLE void U_EXPORT2
1768 ucnv_getAliases(const char *alias, const char **aliases, UErrorCode *pErrorCode);
1769 
1770 /**
1771  * Return a new UEnumeration object for enumerating all the
1772  * alias names for a given converter that are recognized by a standard.
1773  * This method only enumerates the listed entries in the alias file.
1774  * The convrtrs.txt file can be modified to change the results of
1775  * this function.
1776  * The first result in this list is the same result given by
1777  * &lt;code&gt;ucnv_getStandardName&lt;/code&gt;, which is the default alias for
1778  * the specified standard name. The returned object must be closed with
1779  * &lt;code&gt;uenum_close&lt;/code&gt; when you are done with the object.
1780  *
1781  * @param convName original converter name
1782  * @param standard name of the standard governing the names; MIME and IANA
1783  *      are such standards
1784  * @param pErrorCode The error code
1785  * @return A UEnumeration object for getting all aliases that are recognized
1786  *      by a standard. If any of the parameters are invalid, NULL
1787  *      is returned.
1788  * @see ucnv_getStandardName
1789  * @see uenum_close
1790  * @see uenum_next
1791  * @stable ICU 2.2
1792  */
1793 U_STABLE UEnumeration * U_EXPORT2
1794 ucnv_openStandardNames(const char *convName,
1795                        const char *standard,
1796                        UErrorCode *pErrorCode);
1797 
1798 /**
1799  * Gives the number of standards associated to converter names.
1800  * @return number of standards
1801  * @stable ICU 2.0
1802  */
1803 U_STABLE uint16_t U_EXPORT2
1804 ucnv_countStandards(void);
1805 
1806 /**
1807  * Gives the name of the standard at given index of standard list.
1808  * @param n index in standard list
1809  * @param pErrorCode result of operation
1810  * @return returns the name of the standard at given index. Owned by the library.
1811  * @stable ICU 2.0
1812  */
1813 U_STABLE const char * U_EXPORT2
1814 ucnv_getStandard(uint16_t n, UErrorCode *pErrorCode);
1815 
1816 /**
1817  * Returns a standard name for a given converter name.
1818  * &lt;p&gt;
1819  * Example alias table:&lt;br&gt;
1820  * conv alias1 { STANDARD1 } alias2 { STANDARD1* }
1821  * &lt;p&gt;
1822  * Result of ucnv_getStandardName(&quot;conv&quot;, &quot;STANDARD1&quot;) from example
1823  * alias table:&lt;br&gt;
1824  * &lt;b&gt;&quot;alias2&quot;&lt;/b&gt;
1825  *
1826  * @param name original converter name
1827  * @param standard name of the standard governing the names; MIME and IANA
1828  *        are such standards
1829  * @param pErrorCode result of operation
1830  * @return returns the standard converter name;
1831  *         if a standard converter name cannot be determined,
1832  *         then &lt;code&gt;NULL&lt;/code&gt; is returned. Owned by the library.
1833  * @stable ICU 2.0
1834  */
1835 U_STABLE const char * U_EXPORT2
1836 ucnv_getStandardName(const char *name, const char *standard, UErrorCode *pErrorCode);
1837 
1838 /**
1839  * This function will return the internal canonical converter name of the
1840  * tagged alias. This is the opposite of ucnv_openStandardNames, which
1841  * returns the tagged alias given the canonical name.
1842  * &lt;p&gt;
1843  * Example alias table:&lt;br&gt;
1844  * conv alias1 { STANDARD1 } alias2 { STANDARD1* }
1845  * &lt;p&gt;
1846  * Result of ucnv_getStandardName(&quot;alias1&quot;, &quot;STANDARD1&quot;) from example
1847  * alias table:&lt;br&gt;
1848  * &lt;b&gt;&quot;conv&quot;&lt;/b&gt;
1849  *
1850  * @return returns the canonical converter name;
1851  *         if a standard or alias name cannot be determined,
1852  *         then &lt;code&gt;NULL&lt;/code&gt; is returned. The returned string is
1853  *         owned by the library.
1854  * @see ucnv_getStandardName
1855  * @stable ICU 2.4
1856  */
1857 U_STABLE const char * U_EXPORT2
1858 ucnv_getCanonicalName(const char *alias, const char *standard, UErrorCode *pErrorCode);
1859 
1860 /**
1861  * Returns the current default converter name. If you want to open
1862  * a default converter, you do not need to use this function.
1863  * It is faster if you pass a NULL argument to ucnv_open the
1864  * default converter.
1865  *
1866  * If U_CHARSET_IS_UTF8 is defined to 1 in utypes.h then this function
1867  * always returns &quot;UTF-8&quot;.
1868  *
1869  * @return returns the current default converter name.
1870  *         Storage owned by the library
1871  * @see ucnv_setDefaultName
1872  * @stable ICU 2.0
1873  */
1874 U_STABLE const char * U_EXPORT2
1875 ucnv_getDefaultName(void);
1876 
1877 #ifndef U_HIDE_SYSTEM_API
1878 /**
1879  * This function is not thread safe. DO NOT call this function when ANY ICU
1880  * function is being used from more than one thread! This function sets the
1881  * current default converter name. If this function needs to be called, it
1882  * should be called during application initialization. Most of the time, the
1883  * results from ucnv_getDefaultName() or ucnv_open with a NULL string argument
1884  * is sufficient for your application.
1885  *
1886  * If U_CHARSET_IS_UTF8 is defined to 1 in utypes.h then this function
1887  * does nothing.
1888  *
1889  * @param name the converter name to be the default (must be known by ICU).
1890  * @see ucnv_getDefaultName
1891  * @system
1892  * @stable ICU 2.0
1893  */
1894 U_STABLE void U_EXPORT2
1895 ucnv_setDefaultName(const char *name);
1896 #endif  /* U_HIDE_SYSTEM_API */
1897 
1898 /**
1899  * Fixes the backslash character mismapping.  For example, in SJIS, the backslash
1900  * character in the ASCII portion is also used to represent the yen currency sign.
1901  * When mapping from Unicode character 0x005C, it&#39;s unclear whether to map the
1902  * character back to yen or backslash in SJIS.  This function will take the input
1903  * buffer and replace all the yen sign characters with backslash.  This is necessary
1904  * when the user tries to open a file with the input buffer on Windows.
1905  * This function will test the converter to see whether such mapping is
1906  * required.  You can sometimes avoid using this function by using the correct version
1907  * of Shift-JIS.
1908  *
1909  * @param cnv The converter representing the target codepage.
1910  * @param source the input buffer to be fixed
1911  * @param sourceLen the length of the input buffer
1912  * @see ucnv_isAmbiguous
1913  * @stable ICU 2.0
1914  */
1915 U_STABLE void U_EXPORT2
1916 ucnv_fixFileSeparator(const UConverter *cnv, UChar *source, int32_t sourceLen);
1917 
1918 /**
1919  * Determines if the converter contains ambiguous mappings of the same
1920  * character or not.
1921  * @param cnv the converter to be tested
1922  * @return TRUE if the converter contains ambiguous mapping of the same
1923  * character, FALSE otherwise.
1924  * @stable ICU 2.0
1925  */
1926 U_STABLE UBool U_EXPORT2
1927 ucnv_isAmbiguous(const UConverter *cnv);
1928 
1929 /**
1930  * Sets the converter to use fallback mappings or not.
1931  * Regardless of this flag, the converter will always use
1932  * fallbacks from Unicode Private Use code points, as well as
1933  * reverse fallbacks (to Unicode).
1934  * For details see &quot;.ucm File Format&quot;
1935  * in the Conversion Data chapter of the ICU User Guide:
1936  * http://www.icu-project.org/userguide/conversion-data.html#ucmformat
1937  *
1938  * @param cnv The converter to set the fallback mapping usage on.
1939  * @param usesFallback TRUE if the user wants the converter to take advantage of the fallback
1940  * mapping, FALSE otherwise.
1941  * @stable ICU 2.0
1942  * @see ucnv_usesFallback
1943  */
1944 U_STABLE void U_EXPORT2
1945 ucnv_setFallback(UConverter *cnv, UBool usesFallback);
1946 
1947 /**
1948  * Determines if the converter uses fallback mappings or not.
1949  * This flag has restrictions, see ucnv_setFallback().
1950  *
1951  * @param cnv The converter to be tested
1952  * @return TRUE if the converter uses fallback, FALSE otherwise.
1953  * @stable ICU 2.0
1954  * @see ucnv_setFallback
1955  */
1956 U_STABLE UBool U_EXPORT2
1957 ucnv_usesFallback(const UConverter *cnv);
1958 
1959 /**
1960  * Detects Unicode signature byte sequences at the start of the byte stream
1961  * and returns the charset name of the indicated Unicode charset.
1962  * NULL is returned when no Unicode signature is recognized.
1963  * The number of bytes in the signature is output as well.
1964  *
1965  * The caller can ucnv_open() a converter using the charset name.
1966  * The first code unit (UChar) from the start of the stream will be U+FEFF
1967  * (the Unicode BOM/signature character) and can usually be ignored.
1968  *
1969  * For most Unicode charsets it is also possible to ignore the indicated
1970  * number of initial stream bytes and start converting after them.
1971  * However, there are stateful Unicode charsets (UTF-7 and BOCU-1) for which
1972  * this will not work. Therefore, it is best to ignore the first output UChar
1973  * instead of the input signature bytes.
1974  * &lt;p&gt;
1975  * Usage:
1976  * \snippet samples/ucnv/convsamp.cpp ucnv_detectUnicodeSignature
1977  *
1978  * @param source            The source string in which the signature should be detected.
1979  * @param sourceLength      Length of the input string, or -1 if terminated with a NUL byte.
1980  * @param signatureLength   A pointer to int32_t to receive the number of bytes that make up the signature
1981  *                          of the detected UTF. 0 if not detected.
1982  *                          Can be a NULL pointer.
1983  * @param pErrorCode        ICU error code in/out parameter.
1984  *                          Must fulfill U_SUCCESS before the function call.
1985  * @return The name of the encoding detected. NULL if encoding is not detected.
1986  * @stable ICU 2.4
1987  */
1988 U_STABLE const char* U_EXPORT2
1989 ucnv_detectUnicodeSignature(const char* source,
1990                             int32_t sourceLength,
1991                             int32_t *signatureLength,
1992                             UErrorCode *pErrorCode);
1993 
1994 /**
1995  * Returns the number of UChars held in the converter&#39;s internal state
1996  * because more input is needed for completing the conversion. This function is
1997  * useful for mapping semantics of ICU&#39;s converter interface to those of iconv,
1998  * and this information is not needed for normal conversion.
1999  * @param cnv       The converter in which the input is held
2000  * @param status    ICU error code in/out parameter.
2001  *                  Must fulfill U_SUCCESS before the function call.
2002  * @return The number of UChars in the state. -1 if an error is encountered.
2003  * @stable ICU 3.4
2004  */
2005 U_STABLE int32_t U_EXPORT2
2006 ucnv_fromUCountPending(const UConverter* cnv, UErrorCode* status);
2007 
2008 /**
2009  * Returns the number of chars held in the converter&#39;s internal state
2010  * because more input is needed for completing the conversion. This function is
2011  * useful for mapping semantics of ICU&#39;s converter interface to those of iconv,
2012  * and this information is not needed for normal conversion.
2013  * @param cnv       The converter in which the input is held as internal state
2014  * @param status    ICU error code in/out parameter.
2015  *                  Must fulfill U_SUCCESS before the function call.
2016  * @return The number of chars in the state. -1 if an error is encountered.
2017  * @stable ICU 3.4
2018  */
2019 U_STABLE int32_t U_EXPORT2
2020 ucnv_toUCountPending(const UConverter* cnv, UErrorCode* status);
2021 
2022 /**
2023  * Returns whether or not the charset of the converter has a fixed number of bytes
2024  * per charset character.
2025  * An example of this are converters that are of the type UCNV_SBCS or UCNV_DBCS.
2026  * Another example is UTF-32 which is always 4 bytes per character.
2027  * A Unicode code point may be represented by more than one UTF-8 or UTF-16 code unit
2028  * but a UTF-32 converter encodes each code point with 4 bytes.
2029  * Note: This method is not intended to be used to determine whether the charset has a
2030  * fixed ratio of bytes to Unicode codes &lt;i&gt;units&lt;/i&gt; for any particular Unicode encoding form.
2031  * FALSE is returned with the UErrorCode if error occurs or cnv is NULL.
2032  * @param cnv       The converter to be tested
2033  * @param status    ICU error code in/out paramter
2034  * @return TRUE if the converter is fixed-width
2035  * @stable ICU 4.8
2036  */
2037 U_STABLE UBool U_EXPORT2
2038 ucnv_isFixedWidth(UConverter *cnv, UErrorCode *status);
2039 
2040 #endif
2041 
2042 #endif
2043 /*_UCNV*/
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>