<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/loclikely.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="locid.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="locmap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/loclikely.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 *
   6 *   Copyright (C) 1997-2016, International Business Machines
   7 *   Corporation and others.  All Rights Reserved.
   8 *
   9 *******************************************************************************
  10 *   file name:  loclikely.cpp
  11 *   encoding:   UTF-8
  12 *   tab size:   8 (not used)
  13 *   indentation:4
  14 *
  15 *   created on: 2010feb25
  16 *   created by: Markus W. Scherer
  17 *
  18 *   Code for likely and minimized locale subtags, separated out from other .cpp files
  19 *   that then do not depend on resource bundle code and likely-subtags data.
  20 */
  21 

  22 #include &quot;unicode/utypes.h&quot;
  23 #include &quot;unicode/locid.h&quot;
  24 #include &quot;unicode/putil.h&quot;
  25 #include &quot;unicode/uchar.h&quot;
  26 #include &quot;unicode/uloc.h&quot;
  27 #include &quot;unicode/ures.h&quot;
  28 #include &quot;unicode/uscript.h&quot;


  29 #include &quot;cmemory.h&quot;
  30 #include &quot;cstring.h&quot;
  31 #include &quot;ulocimp.h&quot;
  32 #include &quot;ustr_imp.h&quot;
  33 







  34 /**
  35  * This function looks for the localeID in the likelySubtags resource.
  36  *
  37  * @param localeID The tag to find.
  38  * @param buffer A buffer to hold the matching entry
  39  * @param bufferLength The length of the output buffer
  40  * @return A pointer to &quot;buffer&quot; if found, or a null pointer if not.
  41  */
  42 static const char*  U_CALLCONV
  43 findLikelySubtags(const char* localeID,
  44                   char* buffer,
  45                   int32_t bufferLength,
  46                   UErrorCode* err) {
  47     const char* result = NULL;
  48 
  49     if (!U_FAILURE(*err)) {
  50         int32_t resLen = 0;
  51         const UChar* s = NULL;
  52         UErrorCode tmpErr = U_ZERO_ERROR;
<span class="line-modified">  53         UResourceBundle* subtags = ures_openDirect(NULL, &quot;likelySubtags&quot;, &amp;tmpErr);</span>
  54         if (U_SUCCESS(tmpErr)) {
<span class="line-modified">  55             s = ures_getStringByKey(subtags, localeID, &amp;resLen, &amp;tmpErr);</span>













  56 
  57             if (U_FAILURE(tmpErr)) {
  58                 /*
  59                  * If a resource is missing, it&#39;s not really an error, it&#39;s
  60                  * just that we don&#39;t have any data for that particular locale ID.
  61                  */
  62                 if (tmpErr != U_MISSING_RESOURCE_ERROR) {
  63                     *err = tmpErr;
  64                 }
  65             }
  66             else if (resLen &gt;= bufferLength) {
  67                 /* The buffer should never overflow. */
  68                 *err = U_INTERNAL_PROGRAM_ERROR;
  69             }
  70             else {
  71                 u_UCharsToChars(s, buffer, resLen + 1);





  72                 result = buffer;
  73             }
<span class="line-removed">  74 </span>
<span class="line-removed">  75             ures_close(subtags);</span>
  76         } else {
  77             *err = tmpErr;
  78         }
  79     }
  80 
  81     return result;
  82 }
  83 
  84 /**
  85  * Append a tag to a buffer, adding the separator if necessary.  The buffer
  86  * must be large enough to contain the resulting tag plus any separator
  87  * necessary. The tag must not be a zero-length string.
  88  *
  89  * @param tag The tag to add.
  90  * @param tagLength The length of the tag.
  91  * @param buffer The output buffer.
  92  * @param bufferLength The length of the output buffer.  This is an input/ouput parameter.
  93  **/
  94 static void U_CALLCONV
  95 appendTag(
  96     const char* tag,
  97     int32_t tagLength,
  98     char* buffer,
<span class="line-modified">  99     int32_t* bufferLength) {</span>

 100 
<span class="line-modified"> 101     if (*bufferLength &gt; 0) {</span>
 102         buffer[*bufferLength] = &#39;_&#39;;
 103         ++(*bufferLength);
 104     }
 105 
 106     uprv_memmove(
 107         &amp;buffer[*bufferLength],
 108         tag,
 109         tagLength);
 110 
 111     *bufferLength += tagLength;
 112 }
 113 
<span class="line-removed"> 114 /**</span>
<span class="line-removed"> 115  * These are the canonical strings for unknown languages, scripts and regions.</span>
<span class="line-removed"> 116  **/</span>
<span class="line-removed"> 117 static const char* const unknownLanguage = &quot;und&quot;;</span>
<span class="line-removed"> 118 static const char* const unknownScript = &quot;Zzzz&quot;;</span>
<span class="line-removed"> 119 static const char* const unknownRegion = &quot;ZZ&quot;;</span>
<span class="line-removed"> 120 </span>
 121 /**
 122  * Create a tag string from the supplied parameters.  The lang, script and region
 123  * parameters may be NULL pointers. If they are, their corresponding length parameters
 124  * must be less than or equal to 0.
 125  *
 126  * If any of the language, script or region parameters are empty, and the alternateTags
 127  * parameter is not NULL, it will be parsed for potential language, script and region tags
 128  * to be used when constructing the new tag.  If the alternateTags parameter is NULL, or
 129  * it contains no language tag, the default tag for the unknown language is used.
 130  *
 131  * If the length of the new string exceeds the capacity of the output buffer,
 132  * the function copies as many bytes to the output buffer as it can, and returns
 133  * the error U_BUFFER_OVERFLOW_ERROR.
 134  *
 135  * If an illegal argument is provided, the function returns the error
 136  * U_ILLEGAL_ARGUMENT_ERROR.
 137  *
 138  * Note that this function can return the warning U_STRING_NOT_TERMINATED_WARNING if
 139  * the tag string fits in the output buffer, but the null terminator doesn&#39;t.
 140  *
 141  * @param lang The language tag to use.
 142  * @param langLength The length of the language tag.
 143  * @param script The script tag to use.
 144  * @param scriptLength The length of the script tag.
 145  * @param region The region tag to use.
 146  * @param regionLength The length of the region tag.
 147  * @param trailing Any trailing data to append to the new tag.
 148  * @param trailingLength The length of the trailing data.
 149  * @param alternateTags A string containing any alternate tags.
<span class="line-modified"> 150  * @param tag The output buffer.</span>
<span class="line-removed"> 151  * @param tagCapacity The capacity of the output buffer.</span>
 152  * @param err A pointer to a UErrorCode for error reporting.
<span class="line-removed"> 153  * @return The length of the tag string, which may be greater than tagCapacity, or -1 on error.</span>
 154  **/
<span class="line-modified"> 155 static int32_t U_CALLCONV</span>
 156 createTagStringWithAlternates(
 157     const char* lang,
 158     int32_t langLength,
 159     const char* script,
 160     int32_t scriptLength,
 161     const char* region,
 162     int32_t regionLength,
 163     const char* trailing,
 164     int32_t trailingLength,
 165     const char* alternateTags,
<span class="line-modified"> 166     char* tag,</span>
<span class="line-removed"> 167     int32_t tagCapacity,</span>
 168     UErrorCode* err) {
 169 
 170     if (U_FAILURE(*err)) {
 171         goto error;
 172     }
<span class="line-modified"> 173     else if (tag == NULL ||</span>
<span class="line-removed"> 174              tagCapacity &lt;= 0 ||</span>
<span class="line-removed"> 175              langLength &gt;= ULOC_LANG_CAPACITY ||</span>
 176              scriptLength &gt;= ULOC_SCRIPT_CAPACITY ||
 177              regionLength &gt;= ULOC_COUNTRY_CAPACITY) {
 178         goto error;
 179     }
 180     else {
 181         /**
 182          * ULOC_FULLNAME_CAPACITY will provide enough capacity
 183          * that we can build a string that contains the language,
 184          * script and region code without worrying about overrunning
 185          * the user-supplied buffer.
 186          **/
 187         char tagBuffer[ULOC_FULLNAME_CAPACITY];
 188         int32_t tagLength = 0;
<span class="line-removed"> 189         int32_t capacityRemaining = tagCapacity;</span>
 190         UBool regionAppended = FALSE;
 191 
 192         if (langLength &gt; 0) {
 193             appendTag(
 194                 lang,
 195                 langLength,
 196                 tagBuffer,
<span class="line-modified"> 197                 &amp;tagLength);</span>

 198         }
 199         else if (alternateTags == NULL) {
 200             /*
<span class="line-modified"> 201              * Append the value for an unknown language, if</span>
 202              * we found no language.
 203              */
<span class="line-removed"> 204             appendTag(</span>
<span class="line-removed"> 205                 unknownLanguage,</span>
<span class="line-removed"> 206                 (int32_t)uprv_strlen(unknownLanguage),</span>
<span class="line-removed"> 207                 tagBuffer,</span>
<span class="line-removed"> 208                 &amp;tagLength);</span>
 209         }
 210         else {
 211             /*
 212              * Parse the alternateTags string for the language.
 213              */
 214             char alternateLang[ULOC_LANG_CAPACITY];
 215             int32_t alternateLangLength = sizeof(alternateLang);
 216 
 217             alternateLangLength =
 218                 uloc_getLanguage(
 219                     alternateTags,
 220                     alternateLang,
 221                     alternateLangLength,
 222                     err);
 223             if(U_FAILURE(*err) ||
 224                 alternateLangLength &gt;= ULOC_LANG_CAPACITY) {
 225                 goto error;
 226             }
 227             else if (alternateLangLength == 0) {
 228                 /*
<span class="line-modified"> 229                  * Append the value for an unknown language, if</span>
 230                  * we found no language.
 231                  */
<span class="line-removed"> 232                 appendTag(</span>
<span class="line-removed"> 233                     unknownLanguage,</span>
<span class="line-removed"> 234                     (int32_t)uprv_strlen(unknownLanguage),</span>
<span class="line-removed"> 235                     tagBuffer,</span>
<span class="line-removed"> 236                     &amp;tagLength);</span>
 237             }
 238             else {
 239                 appendTag(
 240                     alternateLang,
 241                     alternateLangLength,
 242                     tagBuffer,
<span class="line-modified"> 243                     &amp;tagLength);</span>

 244             }
 245         }
 246 
 247         if (scriptLength &gt; 0) {
 248             appendTag(
 249                 script,
 250                 scriptLength,
 251                 tagBuffer,
<span class="line-modified"> 252                 &amp;tagLength);</span>

 253         }
 254         else if (alternateTags != NULL) {
 255             /*
 256              * Parse the alternateTags string for the script.
 257              */
 258             char alternateScript[ULOC_SCRIPT_CAPACITY];
 259 
 260             const int32_t alternateScriptLength =
 261                 uloc_getScript(
 262                     alternateTags,
 263                     alternateScript,
 264                     sizeof(alternateScript),
 265                     err);
 266 
 267             if (U_FAILURE(*err) ||
 268                 alternateScriptLength &gt;= ULOC_SCRIPT_CAPACITY) {
 269                 goto error;
 270             }
 271             else if (alternateScriptLength &gt; 0) {
 272                 appendTag(
 273                     alternateScript,
 274                     alternateScriptLength,
 275                     tagBuffer,
<span class="line-modified"> 276                     &amp;tagLength);</span>

 277             }
 278         }
 279 
 280         if (regionLength &gt; 0) {
 281             appendTag(
 282                 region,
 283                 regionLength,
 284                 tagBuffer,
<span class="line-modified"> 285                 &amp;tagLength);</span>

 286 
 287             regionAppended = TRUE;
 288         }
 289         else if (alternateTags != NULL) {
 290             /*
 291              * Parse the alternateTags string for the region.
 292              */
 293             char alternateRegion[ULOC_COUNTRY_CAPACITY];
 294 
 295             const int32_t alternateRegionLength =
 296                 uloc_getCountry(
 297                     alternateTags,
 298                     alternateRegion,
 299                     sizeof(alternateRegion),
 300                     err);
 301             if (U_FAILURE(*err) ||
 302                 alternateRegionLength &gt;= ULOC_COUNTRY_CAPACITY) {
 303                 goto error;
 304             }
 305             else if (alternateRegionLength &gt; 0) {
 306                 appendTag(
 307                     alternateRegion,
 308                     alternateRegionLength,
 309                     tagBuffer,
<span class="line-modified"> 310                     &amp;tagLength);</span>

 311 
 312                 regionAppended = TRUE;
 313             }
 314         }
 315 
<span class="line-modified"> 316         {</span>
<span class="line-modified"> 317             const int32_t toCopy =</span>
<span class="line-modified"> 318                 tagLength &gt;= tagCapacity ? tagCapacity : tagLength;</span>
<span class="line-modified"> 319 </span>
<span class="line-modified"> 320             /**</span>
<span class="line-removed"> 321              * Copy the partial tag from our internal buffer to the supplied</span>
<span class="line-removed"> 322              * target.</span>
<span class="line-removed"> 323              **/</span>
<span class="line-removed"> 324             uprv_memcpy(</span>
<span class="line-removed"> 325                 tag,</span>
<span class="line-removed"> 326                 tagBuffer,</span>
<span class="line-removed"> 327                 toCopy);</span>
<span class="line-removed"> 328 </span>
<span class="line-removed"> 329             capacityRemaining -= toCopy;</span>
<span class="line-removed"> 330         }</span>
 331 
 332         if (trailingLength &gt; 0) {
<span class="line-modified"> 333             if (*trailing != &#39;@&#39; &amp;&amp; capacityRemaining &gt; 0) {</span>
<span class="line-modified"> 334                 tag[tagLength++] = &#39;_&#39;;</span>
<span class="line-modified"> 335                 --capacityRemaining;</span>
<span class="line-removed"> 336                 if (capacityRemaining &gt; 0 &amp;&amp; !regionAppended) {</span>
 337                     /* extra separator is required */
<span class="line-modified"> 338                     tag[tagLength++] = &#39;_&#39;;</span>
<span class="line-removed"> 339                     --capacityRemaining;</span>
 340                 }
 341             }
 342 
<span class="line-modified"> 343             if (capacityRemaining &gt; 0) {</span>
<span class="line-modified"> 344                 /*</span>
<span class="line-modified"> 345                  * Copy the trailing data into the supplied buffer.  Use uprv_memmove, since we</span>
<span class="line-modified"> 346                  * don&#39;t know if the user-supplied buffers overlap.</span>
<span class="line-removed"> 347                  */</span>
<span class="line-removed"> 348                 const int32_t toCopy =</span>
<span class="line-removed"> 349                     trailingLength &gt;= capacityRemaining ? capacityRemaining : trailingLength;</span>
<span class="line-removed"> 350 </span>
<span class="line-removed"> 351                 uprv_memmove(</span>
<span class="line-removed"> 352                     &amp;tag[tagLength],</span>
<span class="line-removed"> 353                     trailing,</span>
<span class="line-removed"> 354                     toCopy);</span>
<span class="line-removed"> 355             }</span>
 356         }
 357 
<span class="line-modified"> 358         tagLength += trailingLength;</span>
<span class="line-removed"> 359 </span>
<span class="line-removed"> 360         return u_terminateChars(</span>
<span class="line-removed"> 361                     tag,</span>
<span class="line-removed"> 362                     tagCapacity,</span>
<span class="line-removed"> 363                     tagLength,</span>
<span class="line-removed"> 364                     err);</span>
 365     }
 366 
 367 error:
 368 
 369     /**
 370      * An overflow indicates the locale ID passed in
 371      * is ill-formed.  If we got here, and there was
 372      * no previous error, it&#39;s an implicit overflow.
 373      **/
 374     if (*err ==  U_BUFFER_OVERFLOW_ERROR ||
 375         U_SUCCESS(*err)) {
 376         *err = U_ILLEGAL_ARGUMENT_ERROR;
 377     }
<span class="line-removed"> 378 </span>
<span class="line-removed"> 379     return -1;</span>
 380 }
 381 
 382 /**
 383  * Create a tag string from the supplied parameters.  The lang, script and region
 384  * parameters may be NULL pointers. If they are, their corresponding length parameters
 385  * must be less than or equal to 0.  If the lang parameter is an empty string, the
 386  * default value for an unknown language is written to the output buffer.
 387  *
 388  * If the length of the new string exceeds the capacity of the output buffer,
 389  * the function copies as many bytes to the output buffer as it can, and returns
 390  * the error U_BUFFER_OVERFLOW_ERROR.
 391  *
 392  * If an illegal argument is provided, the function returns the error
 393  * U_ILLEGAL_ARGUMENT_ERROR.
 394  *
 395  * @param lang The language tag to use.
 396  * @param langLength The length of the language tag.
 397  * @param script The script tag to use.
 398  * @param scriptLength The length of the script tag.
 399  * @param region The region tag to use.
 400  * @param regionLength The length of the region tag.
 401  * @param trailing Any trailing data to append to the new tag.
 402  * @param trailingLength The length of the trailing data.
<span class="line-modified"> 403  * @param tag The output buffer.</span>
<span class="line-removed"> 404  * @param tagCapacity The capacity of the output buffer.</span>
 405  * @param err A pointer to a UErrorCode for error reporting.
<span class="line-removed"> 406  * @return The length of the tag string, which may be greater than tagCapacity.</span>
 407  **/
<span class="line-modified"> 408 static int32_t U_CALLCONV</span>
 409 createTagString(
 410     const char* lang,
 411     int32_t langLength,
 412     const char* script,
 413     int32_t scriptLength,
 414     const char* region,
 415     int32_t regionLength,
 416     const char* trailing,
 417     int32_t trailingLength,
<span class="line-modified"> 418     char* tag,</span>
<span class="line-removed"> 419     int32_t tagCapacity,</span>
 420     UErrorCode* err)
 421 {
<span class="line-modified"> 422     return createTagStringWithAlternates(</span>
 423                 lang,
 424                 langLength,
 425                 script,
 426                 scriptLength,
 427                 region,
 428                 regionLength,
 429                 trailing,
 430                 trailingLength,
 431                 NULL,
<span class="line-modified"> 432                 tag,</span>
<span class="line-removed"> 433                 tagCapacity,</span>
 434                 err);
 435 }
 436 
 437 /**
 438  * Parse the language, script, and region subtags from a tag string, and copy the
 439  * results into the corresponding output parameters. The buffers are null-terminated,
 440  * unless overflow occurs.
 441  *
 442  * The langLength, scriptLength, and regionLength parameters are input/output
 443  * parameters, and must contain the capacity of their corresponding buffers on
 444  * input.  On output, they will contain the actual length of the buffers, not
 445  * including the null terminator.
 446  *
 447  * If the length of any of the output subtags exceeds the capacity of the corresponding
 448  * buffer, the function copies as many bytes to the output buffer as it can, and returns
 449  * the error U_BUFFER_OVERFLOW_ERROR.  It will not parse any more subtags once overflow
 450  * occurs.
 451  *
 452  * If an illegal argument is provided, the function returns the error
 453  * U_ILLEGAL_ARGUMENT_ERROR.
</pre>
<hr />
<pre>
 485        region == NULL ||
 486        regionLength == NULL) {
 487         goto error;
 488     }
 489 
 490     subtagLength = ulocimp_getLanguage(position, lang, *langLength, &amp;position);
 491     u_terminateChars(lang, *langLength, subtagLength, err);
 492 
 493     /*
 494      * Note that we explicit consider U_STRING_NOT_TERMINATED_WARNING
 495      * to be an error, because it indicates the user-supplied tag is
 496      * not well-formed.
 497      */
 498     if(U_FAILURE(*err)) {
 499         goto error;
 500     }
 501 
 502     *langLength = subtagLength;
 503 
 504     /*
<span class="line-modified"> 505      * If no language was present, use the value of unknownLanguage</span>
<span class="line-modified"> 506      * instead.  Otherwise, move past any separator.</span>
 507      */
<span class="line-removed"> 508     if (*langLength == 0) {</span>
<span class="line-removed"> 509         uprv_strcpy(</span>
<span class="line-removed"> 510             lang,</span>
<span class="line-removed"> 511             unknownLanguage);</span>
<span class="line-removed"> 512         *langLength = (int32_t)uprv_strlen(lang);</span>
<span class="line-removed"> 513     }</span>
 514     if (_isIDSeparator(*position)) {
 515         ++position;
 516     }
 517 
 518     subtagLength = ulocimp_getScript(position, script, *scriptLength, &amp;position);
 519     u_terminateChars(script, *scriptLength, subtagLength, err);
 520 
 521     if(U_FAILURE(*err)) {
 522         goto error;
 523     }
 524 
 525     *scriptLength = subtagLength;
 526 
 527     if (*scriptLength &gt; 0) {
 528         if (uprv_strnicmp(script, unknownScript, *scriptLength) == 0) {
 529             /**
 530              * If the script part is the &quot;unknown&quot; script, then don&#39;t return it.
 531              **/
 532             *scriptLength = 0;
 533         }
</pre>
<hr />
<pre>
 561         --position;
 562     }
 563 
 564 exit:
 565 
 566     return (int32_t)(position - localeID);
 567 
 568 error:
 569 
 570     /**
 571      * If we get here, we have no explicit error, it&#39;s the result of an
 572      * illegal argument.
 573      **/
 574     if (!U_FAILURE(*err)) {
 575         *err = U_ILLEGAL_ARGUMENT_ERROR;
 576     }
 577 
 578     goto exit;
 579 }
 580 
<span class="line-modified"> 581 static int32_t U_CALLCONV</span>
 582 createLikelySubtagsString(
 583     const char* lang,
 584     int32_t langLength,
 585     const char* script,
 586     int32_t scriptLength,
 587     const char* region,
 588     int32_t regionLength,
 589     const char* variants,
 590     int32_t variantsLength,
<span class="line-modified"> 591     char* tag,</span>
<span class="line-modified"> 592     int32_t tagCapacity,</span>
<span class="line-removed"> 593     UErrorCode* err)</span>
<span class="line-removed"> 594 {</span>
 595     /**
 596      * ULOC_FULLNAME_CAPACITY will provide enough capacity
 597      * that we can build a string that contains the language,
 598      * script and region code without worrying about overrunning
 599      * the user-supplied buffer.
 600      **/
<span class="line-removed"> 601     char tagBuffer[ULOC_FULLNAME_CAPACITY];</span>
 602     char likelySubtagsBuffer[ULOC_FULLNAME_CAPACITY];
 603 
 604     if(U_FAILURE(*err)) {
 605         goto error;
 606     }
 607 
 608     /**
 609      * Try the language with the script and region first.
 610      **/
 611     if (scriptLength &gt; 0 &amp;&amp; regionLength &gt; 0) {
 612 
 613         const char* likelySubtags = NULL;
 614 
<span class="line-modified"> 615         createTagString(</span>
<span class="line-modified"> 616             lang,</span>
<span class="line-modified"> 617             langLength,</span>
<span class="line-modified"> 618             script,</span>
<span class="line-modified"> 619             scriptLength,</span>
<span class="line-modified"> 620             region,</span>
<span class="line-modified"> 621             regionLength,</span>
<span class="line-modified"> 622             NULL,</span>
<span class="line-modified"> 623             0,</span>
<span class="line-modified"> 624             tagBuffer,</span>
<span class="line-modified"> 625             sizeof(tagBuffer),</span>
<span class="line-modified"> 626             err);</span>



 627         if(U_FAILURE(*err)) {
 628             goto error;
 629         }
 630 
 631         likelySubtags =
 632             findLikelySubtags(
<span class="line-modified"> 633                 tagBuffer,</span>
 634                 likelySubtagsBuffer,
 635                 sizeof(likelySubtagsBuffer),
 636                 err);
 637         if(U_FAILURE(*err)) {
 638             goto error;
 639         }
 640 
 641         if (likelySubtags != NULL) {
 642             /* Always use the language tag from the
 643                maximal string, since it may be more
 644                specific than the one provided. */
<span class="line-modified"> 645             return createTagStringWithAlternates(</span>
 646                         NULL,
 647                         0,
 648                         NULL,
 649                         0,
 650                         NULL,
 651                         0,
 652                         variants,
 653                         variantsLength,
 654                         likelySubtags,
<span class="line-modified"> 655                         tag,</span>
<span class="line-removed"> 656                         tagCapacity,</span>
 657                         err);

 658         }
 659     }
 660 
 661     /**
 662      * Try the language with just the script.
 663      **/
 664     if (scriptLength &gt; 0) {
 665 
 666         const char* likelySubtags = NULL;
 667 
<span class="line-modified"> 668         createTagString(</span>
<span class="line-modified"> 669             lang,</span>
<span class="line-modified"> 670             langLength,</span>
<span class="line-modified"> 671             script,</span>
<span class="line-modified"> 672             scriptLength,</span>
<span class="line-modified"> 673             NULL,</span>
<span class="line-modified"> 674             0,</span>
<span class="line-modified"> 675             NULL,</span>
<span class="line-modified"> 676             0,</span>
<span class="line-modified"> 677             tagBuffer,</span>
<span class="line-modified"> 678             sizeof(tagBuffer),</span>
<span class="line-modified"> 679             err);</span>



 680         if(U_FAILURE(*err)) {
 681             goto error;
 682         }
 683 
 684         likelySubtags =
 685             findLikelySubtags(
<span class="line-modified"> 686                 tagBuffer,</span>
 687                 likelySubtagsBuffer,
 688                 sizeof(likelySubtagsBuffer),
 689                 err);
 690         if(U_FAILURE(*err)) {
 691             goto error;
 692         }
 693 
 694         if (likelySubtags != NULL) {
 695             /* Always use the language tag from the
 696                maximal string, since it may be more
 697                specific than the one provided. */
<span class="line-modified"> 698             return createTagStringWithAlternates(</span>
 699                         NULL,
 700                         0,
 701                         NULL,
 702                         0,
 703                         region,
 704                         regionLength,
 705                         variants,
 706                         variantsLength,
 707                         likelySubtags,
<span class="line-modified"> 708                         tag,</span>
<span class="line-removed"> 709                         tagCapacity,</span>
 710                         err);

 711         }
 712     }
 713 
 714     /**
 715      * Try the language with just the region.
 716      **/
 717     if (regionLength &gt; 0) {
 718 
 719         const char* likelySubtags = NULL;
 720 
<span class="line-modified"> 721         createTagString(</span>
<span class="line-modified"> 722             lang,</span>
<span class="line-modified"> 723             langLength,</span>
<span class="line-modified"> 724             NULL,</span>
<span class="line-modified"> 725             0,</span>
<span class="line-modified"> 726             region,</span>
<span class="line-modified"> 727             regionLength,</span>
<span class="line-modified"> 728             NULL,</span>
<span class="line-modified"> 729             0,</span>
<span class="line-modified"> 730             tagBuffer,</span>
<span class="line-modified"> 731             sizeof(tagBuffer),</span>
<span class="line-modified"> 732             err);</span>



 733         if(U_FAILURE(*err)) {
 734             goto error;
 735         }
 736 
 737         likelySubtags =
 738             findLikelySubtags(
<span class="line-modified"> 739                 tagBuffer,</span>
 740                 likelySubtagsBuffer,
 741                 sizeof(likelySubtagsBuffer),
 742                 err);
 743         if(U_FAILURE(*err)) {
 744             goto error;
 745         }
 746 
 747         if (likelySubtags != NULL) {
 748             /* Always use the language tag from the
 749                maximal string, since it may be more
 750                specific than the one provided. */
<span class="line-modified"> 751             return createTagStringWithAlternates(</span>
 752                         NULL,
 753                         0,
 754                         script,
 755                         scriptLength,
 756                         NULL,
 757                         0,
 758                         variants,
 759                         variantsLength,
 760                         likelySubtags,
<span class="line-modified"> 761                         tag,</span>
<span class="line-removed"> 762                         tagCapacity,</span>
 763                         err);

 764         }
 765     }
 766 
 767     /**
 768      * Finally, try just the language.
 769      **/
 770     {
 771         const char* likelySubtags = NULL;
 772 
<span class="line-modified"> 773         createTagString(</span>
<span class="line-modified"> 774             lang,</span>
<span class="line-modified"> 775             langLength,</span>
<span class="line-modified"> 776             NULL,</span>
<span class="line-modified"> 777             0,</span>
<span class="line-modified"> 778             NULL,</span>
<span class="line-modified"> 779             0,</span>
<span class="line-modified"> 780             NULL,</span>
<span class="line-modified"> 781             0,</span>
<span class="line-modified"> 782             tagBuffer,</span>
<span class="line-modified"> 783             sizeof(tagBuffer),</span>
<span class="line-modified"> 784             err);</span>



 785         if(U_FAILURE(*err)) {
 786             goto error;
 787         }
 788 
 789         likelySubtags =
 790             findLikelySubtags(
<span class="line-modified"> 791                 tagBuffer,</span>
 792                 likelySubtagsBuffer,
 793                 sizeof(likelySubtagsBuffer),
 794                 err);
 795         if(U_FAILURE(*err)) {
 796             goto error;
 797         }
 798 
 799         if (likelySubtags != NULL) {
 800             /* Always use the language tag from the
 801                maximal string, since it may be more
 802                specific than the one provided. */
<span class="line-modified"> 803             return createTagStringWithAlternates(</span>
 804                         NULL,
 805                         0,
 806                         script,
 807                         scriptLength,
 808                         region,
 809                         regionLength,
 810                         variants,
 811                         variantsLength,
 812                         likelySubtags,
<span class="line-modified"> 813                         tag,</span>
<span class="line-removed"> 814                         tagCapacity,</span>
 815                         err);

 816         }
 817     }
 818 
<span class="line-modified"> 819     return u_terminateChars(</span>
<span class="line-removed"> 820                 tag,</span>
<span class="line-removed"> 821                 tagCapacity,</span>
<span class="line-removed"> 822                 0,</span>
<span class="line-removed"> 823                 err);</span>
 824 
 825 error:
 826 
 827     if (!U_FAILURE(*err)) {
 828         *err = U_ILLEGAL_ARGUMENT_ERROR;
 829     }
 830 
<span class="line-modified"> 831     return -1;</span>
 832 }
 833 
 834 #define CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength) \
 835     {   int32_t count = 0; \
 836         int32_t i; \
 837         for (i = 0; i &lt; trailingLength; i++) { \
 838             if (trailing[i] == &#39;-&#39; || trailing[i] == &#39;_&#39;) { \
 839                 count = 0; \
 840                 if (count &gt; 8) { \
 841                     goto error; \
 842                 } \
 843             } else if (trailing[i] == &#39;@&#39;) { \
 844                 break; \
 845             } else if (count &gt; 8) { \
 846                 goto error; \
 847             } else { \
 848                 count++; \
 849             } \
 850         } \
 851     }
 852 
<span class="line-modified"> 853 static int32_t</span>
<span class="line-modified"> 854 _uloc_addLikelySubtags(const char*    localeID,</span>
<span class="line-modified"> 855          char* maximizedLocaleID,</span>
<span class="line-modified"> 856          int32_t maximizedLocaleIDCapacity,</span>
<span class="line-removed"> 857          UErrorCode* err)</span>
<span class="line-removed"> 858 {</span>
 859     char lang[ULOC_LANG_CAPACITY];
 860     int32_t langLength = sizeof(lang);
 861     char script[ULOC_SCRIPT_CAPACITY];
 862     int32_t scriptLength = sizeof(script);
 863     char region[ULOC_COUNTRY_CAPACITY];
 864     int32_t regionLength = sizeof(region);
 865     const char* trailing = &quot;&quot;;
 866     int32_t trailingLength = 0;
 867     int32_t trailingIndex = 0;
<span class="line-modified"> 868     int32_t resultLength = 0;</span>
 869 
 870     if(U_FAILURE(*err)) {
 871         goto error;
 872     }
<span class="line-modified"> 873     else if (localeID == NULL ||</span>
<span class="line-removed"> 874              maximizedLocaleID == NULL ||</span>
<span class="line-removed"> 875              maximizedLocaleIDCapacity &lt;= 0) {</span>
 876         goto error;
 877     }
 878 
 879     trailingIndex = parseTagString(
 880         localeID,
 881         lang,
 882         &amp;langLength,
 883         script,
 884         &amp;scriptLength,
 885         region,
 886         &amp;regionLength,
 887         err);
 888     if(U_FAILURE(*err)) {
 889         /* Overflow indicates an illegal argument error */
 890         if (*err == U_BUFFER_OVERFLOW_ERROR) {
 891             *err = U_ILLEGAL_ARGUMENT_ERROR;
 892         }
 893 
 894         goto error;
 895     }
 896 
 897     /* Find the length of the trailing portion. */
 898     while (_isIDSeparator(localeID[trailingIndex])) {
 899         trailingIndex++;
 900     }
 901     trailing = &amp;localeID[trailingIndex];
 902     trailingLength = (int32_t)uprv_strlen(trailing);
 903 
 904     CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength);
 905 
<span class="line-modified"> 906     resultLength =</span>
 907         createLikelySubtagsString(
 908             lang,
 909             langLength,
 910             script,
 911             scriptLength,
 912             region,
 913             regionLength,
 914             trailing,
 915             trailingLength,
<span class="line-modified"> 916             maximizedLocaleID,</span>
<span class="line-removed"> 917             maximizedLocaleIDCapacity,</span>
 918             err);
 919 
<span class="line-modified"> 920     if (resultLength == 0) {</span>
 921         const int32_t localIDLength = (int32_t)uprv_strlen(localeID);
 922 
 923         /*
 924          * If we get here, we need to return localeID.
 925          */
<span class="line-modified"> 926         uprv_memcpy(</span>
<span class="line-removed"> 927             maximizedLocaleID,</span>
<span class="line-removed"> 928             localeID,</span>
<span class="line-removed"> 929             localIDLength &lt;= maximizedLocaleIDCapacity ?</span>
<span class="line-removed"> 930                 localIDLength : maximizedLocaleIDCapacity);</span>
<span class="line-removed"> 931 </span>
<span class="line-removed"> 932         resultLength =</span>
<span class="line-removed"> 933             u_terminateChars(</span>
<span class="line-removed"> 934                 maximizedLocaleID,</span>
<span class="line-removed"> 935                 maximizedLocaleIDCapacity,</span>
<span class="line-removed"> 936                 localIDLength,</span>
<span class="line-removed"> 937                 err);</span>
 938     }
 939 
<span class="line-modified"> 940     return resultLength;</span>
 941 
 942 error:
 943 
 944     if (!U_FAILURE(*err)) {
 945         *err = U_ILLEGAL_ARGUMENT_ERROR;
 946     }
<span class="line-removed"> 947 </span>
<span class="line-removed"> 948     return -1;</span>
 949 }
 950 
<span class="line-modified"> 951 static int32_t</span>
<span class="line-modified"> 952 _uloc_minimizeSubtags(const char*    localeID,</span>
<span class="line-modified"> 953          char* minimizedLocaleID,</span>
<span class="line-modified"> 954          int32_t minimizedLocaleIDCapacity,</span>
<span class="line-modified"> 955          UErrorCode* err)</span>
<span class="line-removed"> 956 {</span>
<span class="line-removed"> 957     /**</span>
<span class="line-removed"> 958      * ULOC_FULLNAME_CAPACITY will provide enough capacity</span>
<span class="line-removed"> 959      * that we can build a string that contains the language,</span>
<span class="line-removed"> 960      * script and region code without worrying about overrunning</span>
<span class="line-removed"> 961      * the user-supplied buffer.</span>
<span class="line-removed"> 962      **/</span>
<span class="line-removed"> 963     char maximizedTagBuffer[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-removed"> 964     int32_t maximizedTagBufferLength = sizeof(maximizedTagBuffer);</span>
 965 
 966     char lang[ULOC_LANG_CAPACITY];
 967     int32_t langLength = sizeof(lang);
 968     char script[ULOC_SCRIPT_CAPACITY];
 969     int32_t scriptLength = sizeof(script);
 970     char region[ULOC_COUNTRY_CAPACITY];
 971     int32_t regionLength = sizeof(region);
 972     const char* trailing = &quot;&quot;;
 973     int32_t trailingLength = 0;
 974     int32_t trailingIndex = 0;
 975 
 976     if(U_FAILURE(*err)) {
 977         goto error;
 978     }
<span class="line-modified"> 979     else if (localeID == NULL ||</span>
<span class="line-removed"> 980              minimizedLocaleID == NULL ||</span>
<span class="line-removed"> 981              minimizedLocaleIDCapacity &lt;= 0) {</span>
 982         goto error;
 983     }
 984 
 985     trailingIndex =
 986         parseTagString(
 987             localeID,
 988             lang,
 989             &amp;langLength,
 990             script,
 991             &amp;scriptLength,
 992             region,
 993             &amp;regionLength,
 994             err);
 995     if(U_FAILURE(*err)) {
 996 
 997         /* Overflow indicates an illegal argument error */
 998         if (*err == U_BUFFER_OVERFLOW_ERROR) {
 999             *err = U_ILLEGAL_ARGUMENT_ERROR;
1000         }
1001 
1002         goto error;
1003     }
1004 
1005     /* Find the spot where the variants or the keywords begin, if any. */
1006     while (_isIDSeparator(localeID[trailingIndex])) {
1007         trailingIndex++;
1008     }
1009     trailing = &amp;localeID[trailingIndex];
1010     trailingLength = (int32_t)uprv_strlen(trailing);
1011 
1012     CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength);
1013 
<span class="line-modified">1014     createTagString(</span>
<span class="line-modified">1015         lang,</span>
<span class="line-modified">1016         langLength,</span>
<span class="line-modified">1017         script,</span>
<span class="line-modified">1018         scriptLength,</span>
<span class="line-modified">1019         region,</span>
<span class="line-modified">1020         regionLength,</span>
<span class="line-modified">1021         NULL,</span>
<span class="line-modified">1022         0,</span>
<span class="line-modified">1023         maximizedTagBuffer,</span>
<span class="line-modified">1024         maximizedTagBufferLength,</span>
<span class="line-modified">1025         err);</span>
<span class="line-modified">1026     if(U_FAILURE(*err)) {</span>
<span class="line-modified">1027         goto error;</span>
<span class="line-modified">1028     }</span>

1029 
<span class="line-modified">1030     /**</span>
<span class="line-modified">1031      * First, we need to first get the maximization</span>
<span class="line-modified">1032      * from AddLikelySubtags.</span>
<span class="line-modified">1033      **/</span>
<span class="line-modified">1034     maximizedTagBufferLength =</span>
<span class="line-modified">1035         uloc_addLikelySubtags(</span>
<span class="line-modified">1036             maximizedTagBuffer,</span>
<span class="line-modified">1037             maximizedTagBuffer,</span>
<span class="line-modified">1038             maximizedTagBufferLength,</span>
<span class="line-removed">1039             err);</span>
1040 
1041     if(U_FAILURE(*err)) {
1042         goto error;
1043     }
1044 
1045     /**
1046      * Start first with just the language.
1047      **/
1048     {
<span class="line-modified">1049         char tagBuffer[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-modified">1050 </span>
<span class="line-modified">1051         const int32_t tagBufferLength =</span>
1052             createLikelySubtagsString(
1053                 lang,
1054                 langLength,
1055                 NULL,
1056                 0,
1057                 NULL,
1058                 0,
1059                 NULL,
1060                 0,
<span class="line-modified">1061                 tagBuffer,</span>
<span class="line-removed">1062                 sizeof(tagBuffer),</span>
1063                 err);

1064 
1065         if(U_FAILURE(*err)) {
1066             goto error;
1067         }
<span class="line-modified">1068         else if (uprv_strnicmp(</span>
<span class="line-modified">1069                     maximizedTagBuffer,</span>
<span class="line-modified">1070                     tagBuffer,</span>
<span class="line-modified">1071                     tagBufferLength) == 0) {</span>
1072 
<span class="line-modified">1073             return createTagString(</span>
1074                         lang,
1075                         langLength,
1076                         NULL,
1077                         0,
1078                         NULL,
1079                         0,
1080                         trailing,
1081                         trailingLength,
<span class="line-modified">1082                         minimizedLocaleID,</span>
<span class="line-removed">1083                         minimizedLocaleIDCapacity,</span>
1084                         err);

1085         }
1086     }
1087 
1088     /**
1089      * Next, try the language and region.
1090      **/
1091     if (regionLength &gt; 0) {
1092 
<span class="line-modified">1093         char tagBuffer[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-modified">1094 </span>
<span class="line-modified">1095         const int32_t tagBufferLength =</span>
1096             createLikelySubtagsString(
1097                 lang,
1098                 langLength,
1099                 NULL,
1100                 0,
1101                 region,
1102                 regionLength,
1103                 NULL,
1104                 0,
<span class="line-modified">1105                 tagBuffer,</span>
<span class="line-removed">1106                 sizeof(tagBuffer),</span>
1107                 err);

1108 
1109         if(U_FAILURE(*err)) {
1110             goto error;
1111         }
1112         else if (uprv_strnicmp(
<span class="line-modified">1113                     maximizedTagBuffer,</span>
<span class="line-modified">1114                     tagBuffer,</span>
<span class="line-modified">1115                     tagBufferLength) == 0) {</span>
1116 
<span class="line-modified">1117             return createTagString(</span>
1118                         lang,
1119                         langLength,
1120                         NULL,
1121                         0,
1122                         region,
1123                         regionLength,
1124                         trailing,
1125                         trailingLength,
<span class="line-modified">1126                         minimizedLocaleID,</span>
<span class="line-removed">1127                         minimizedLocaleIDCapacity,</span>
1128                         err);

1129         }
1130     }
1131 
1132     /**
1133      * Finally, try the language and script.  This is our last chance,
1134      * since trying with all three subtags would only yield the
1135      * maximal version that we already have.
1136      **/
1137     if (scriptLength &gt; 0 &amp;&amp; regionLength &gt; 0) {
<span class="line-modified">1138         char tagBuffer[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-modified">1139 </span>
<span class="line-modified">1140         const int32_t tagBufferLength =</span>
1141             createLikelySubtagsString(
1142                 lang,
1143                 langLength,
1144                 script,
1145                 scriptLength,
1146                 NULL,
1147                 0,
1148                 NULL,
1149                 0,
<span class="line-modified">1150                 tagBuffer,</span>
<span class="line-removed">1151                 sizeof(tagBuffer),</span>
1152                 err);

1153 
1154         if(U_FAILURE(*err)) {
1155             goto error;
1156         }
1157         else if (uprv_strnicmp(
<span class="line-modified">1158                     maximizedTagBuffer,</span>
<span class="line-modified">1159                     tagBuffer,</span>
<span class="line-modified">1160                     tagBufferLength) == 0) {</span>
1161 
<span class="line-modified">1162             return createTagString(</span>
1163                         lang,
1164                         langLength,
1165                         script,
1166                         scriptLength,
1167                         NULL,
1168                         0,
1169                         trailing,
1170                         trailingLength,
<span class="line-modified">1171                         minimizedLocaleID,</span>
<span class="line-removed">1172                         minimizedLocaleIDCapacity,</span>
1173                         err);

1174         }
1175     }
1176 
1177     {
1178         /**
1179          * If we got here, return the locale ID parameter.
1180          **/
1181         const int32_t localeIDLength = (int32_t)uprv_strlen(localeID);
<span class="line-modified">1182 </span>
<span class="line-modified">1183         uprv_memcpy(</span>
<span class="line-removed">1184             minimizedLocaleID,</span>
<span class="line-removed">1185             localeID,</span>
<span class="line-removed">1186             localeIDLength &lt;= minimizedLocaleIDCapacity ?</span>
<span class="line-removed">1187                 localeIDLength : minimizedLocaleIDCapacity);</span>
<span class="line-removed">1188 </span>
<span class="line-removed">1189         return u_terminateChars(</span>
<span class="line-removed">1190                     minimizedLocaleID,</span>
<span class="line-removed">1191                     minimizedLocaleIDCapacity,</span>
<span class="line-removed">1192                     localeIDLength,</span>
<span class="line-removed">1193                     err);</span>
1194     }
1195 
1196 error:
1197 
1198     if (!U_FAILURE(*err)) {
1199         *err = U_ILLEGAL_ARGUMENT_ERROR;
1200     }
<span class="line-removed">1201 </span>
<span class="line-removed">1202     return -1;</span>
<span class="line-removed">1203 </span>
<span class="line-removed">1204 </span>
1205 }
1206 
1207 static UBool
1208 do_canonicalize(const char*    localeID,
1209          char* buffer,
1210          int32_t bufferCapacity,
1211          UErrorCode* err)
1212 {
1213     uloc_canonicalize(
1214         localeID,
1215         buffer,
1216         bufferCapacity,
1217         err);
1218 
1219     if (*err == U_STRING_NOT_TERMINATED_WARNING ||
1220         *err == U_BUFFER_OVERFLOW_ERROR) {
1221         *err = U_ILLEGAL_ARGUMENT_ERROR;
1222 
1223         return FALSE;
1224     }
1225     else if (U_FAILURE(*err)) {
1226 
1227         return FALSE;
1228     }
1229     else {
1230         return TRUE;
1231     }
1232 }
1233 
1234 U_CAPI int32_t U_EXPORT2
<span class="line-modified">1235 uloc_addLikelySubtags(const char*    localeID,</span>
<span class="line-modified">1236          char* maximizedLocaleID,</span>
<span class="line-modified">1237          int32_t maximizedLocaleIDCapacity,</span>
<span class="line-modified">1238          UErrorCode* err)</span>
<span class="line-modified">1239 {</span>
<span class="line-modified">1240     char localeBuffer[ULOC_FULLNAME_CAPACITY];</span>

1241 
<span class="line-modified">1242     if (!do_canonicalize(</span>
<span class="line-modified">1243         localeID,</span>
<span class="line-modified">1244         localeBuffer,</span>
<span class="line-modified">1245         sizeof(localeBuffer),</span>
<span class="line-modified">1246         err)) {</span>
<span class="line-modified">1247         return -1;</span>


1248     }
<span class="line-modified">1249     else {</span>
<span class="line-modified">1250         return _uloc_addLikelySubtags(</span>
<span class="line-modified">1251                     localeBuffer,</span>
<span class="line-modified">1252                     maximizedLocaleID,</span>
<span class="line-modified">1253                     maximizedLocaleIDCapacity,</span>
<span class="line-modified">1254                     err);</span>
1255     }


1256 }
1257 
<span class="line-modified">1258 U_CAPI int32_t U_EXPORT2</span>
<span class="line-modified">1259 uloc_minimizeSubtags(const char*    localeID,</span>
<span class="line-modified">1260          char* minimizedLocaleID,</span>
<span class="line-modified">1261          int32_t minimizedLocaleIDCapacity,</span>
<span class="line-removed">1262          UErrorCode* err)</span>
<span class="line-removed">1263 {</span>
1264     char localeBuffer[ULOC_FULLNAME_CAPACITY];
1265 
<span class="line-modified">1266     if (!do_canonicalize(</span>
<span class="line-modified">1267         localeID,</span>
<span class="line-removed">1268         localeBuffer,</span>
<span class="line-removed">1269         sizeof(localeBuffer),</span>
<span class="line-removed">1270         err)) {</span>
<span class="line-removed">1271         return -1;</span>
1272     }
<span class="line-modified">1273     else {</span>
<span class="line-modified">1274         return _uloc_minimizeSubtags(</span>
<span class="line-modified">1275                     localeBuffer,</span>
<span class="line-modified">1276                     minimizedLocaleID,</span>
<span class="line-modified">1277                     minimizedLocaleIDCapacity,</span>
<span class="line-modified">1278                     err);</span>

































1279     }
1280 }
1281 
1282 // Pairs of (language subtag, + or -) for finding out fast if common languages
1283 // are LTR (minus) or RTL (plus).
1284 static const char LANG_DIR_STRING[] =
1285         &quot;root-en-es-pt-zh-ja-ko-de-fr-it-ar+he+fa+ru-nl-pl-th-tr-&quot;;
1286 
<span class="line-modified">1287 // Implemented here because this calls uloc_addLikelySubtags().</span>
1288 U_CAPI UBool U_EXPORT2
1289 uloc_isRightToLeft(const char *locale) {
1290     UErrorCode errorCode = U_ZERO_ERROR;
1291     char script[8];
1292     int32_t scriptLength = uloc_getScript(locale, script, UPRV_LENGTHOF(script), &amp;errorCode);
1293     if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING ||
1294             scriptLength == 0) {
1295         // Fastpath: We know the likely scripts and their writing direction
1296         // for some common languages.
1297         errorCode = U_ZERO_ERROR;
1298         char lang[8];
1299         int32_t langLength = uloc_getLanguage(locale, lang, UPRV_LENGTHOF(lang), &amp;errorCode);
<span class="line-modified">1300         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING ||</span>
<span class="line-removed">1301                 langLength == 0) {</span>
1302             return FALSE;
1303         }
<span class="line-modified">1304         const char* langPtr = uprv_strstr(LANG_DIR_STRING, lang);</span>
<span class="line-modified">1305         if (langPtr != NULL) {</span>
<span class="line-modified">1306             switch (langPtr[langLength]) {</span>
<span class="line-modified">1307             case &#39;-&#39;: return FALSE;</span>
<span class="line-modified">1308             case &#39;+&#39;: return TRUE;</span>
<span class="line-modified">1309             default: break;  // partial match of a longer code</span>


1310             }
1311         }
1312         // Otherwise, find the likely script.
1313         errorCode = U_ZERO_ERROR;
<span class="line-modified">1314         char likely[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-modified">1315         (void)uloc_addLikelySubtags(locale, likely, UPRV_LENGTHOF(likely), &amp;errorCode);</span>



1316         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING) {
1317             return FALSE;
1318         }
<span class="line-modified">1319         scriptLength = uloc_getScript(likely, script, UPRV_LENGTHOF(script), &amp;errorCode);</span>
1320         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING ||
1321                 scriptLength == 0) {
1322             return FALSE;
1323         }
1324     }
1325     UScriptCode scriptCode = (UScriptCode)u_getPropertyValueEnum(UCHAR_SCRIPT, script);
1326     return uscript_isRightToLeft(scriptCode);
1327 }
1328 
1329 U_NAMESPACE_BEGIN
1330 
1331 UBool
1332 Locale::isRightToLeft() const {
1333     return uloc_isRightToLeft(getBaseName());
1334 }
1335 
1336 U_NAMESPACE_END
1337 
1338 // The following must at least allow for rg key value (6) plus terminator (1).
1339 #define ULOC_RG_BUFLEN 8
</pre>
<hr />
<pre>
1350     // First check for rg keyword value
1351     int32_t rgLen = uloc_getKeywordValue(localeID, &quot;rg&quot;, rgBuf, ULOC_RG_BUFLEN, &amp;rgStatus);
1352     if (U_FAILURE(rgStatus) || rgLen != 6) {
1353         rgLen = 0;
1354     } else {
1355         // rgBuf guaranteed to be zero terminated here, with text len 6
1356         char *rgPtr = rgBuf;
1357         for (; *rgPtr!= 0; rgPtr++) {
1358             *rgPtr = uprv_toupper(*rgPtr);
1359         }
1360         rgLen = (uprv_strcmp(rgBuf+2, &quot;ZZZZ&quot;) == 0)? 2: 0;
1361     }
1362 
1363     if (rgLen == 0) {
1364         // No valid rg keyword value, try for unicode_region_subtag
1365         rgLen = uloc_getCountry(localeID, rgBuf, ULOC_RG_BUFLEN, status);
1366         if (U_FAILURE(*status)) {
1367             rgLen = 0;
1368         } else if (rgLen == 0 &amp;&amp; inferRegion) {
1369             // no unicode_region_subtag but inferRegion TRUE, try likely subtags
<span class="line-removed">1370             char locBuf[ULOC_FULLNAME_CAPACITY];</span>
1371             rgStatus = U_ZERO_ERROR;
<span class="line-modified">1372             (void)uloc_addLikelySubtags(localeID, locBuf, ULOC_FULLNAME_CAPACITY, &amp;rgStatus);</span>




1373             if (U_SUCCESS(rgStatus)) {
<span class="line-modified">1374                 rgLen = uloc_getCountry(locBuf, rgBuf, ULOC_RG_BUFLEN, status);</span>
1375                 if (U_FAILURE(*status)) {
1376                     rgLen = 0;
1377                 }
1378             }
1379         }
1380     }
1381 
1382     rgBuf[rgLen] = 0;
1383     uprv_strncpy(region, rgBuf, regionCapacity);
1384     return u_terminateChars(region, regionCapacity, rgLen, status);
1385 }
1386 
</pre>
</td>
<td>
<hr />
<pre>
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 *
   6 *   Copyright (C) 1997-2016, International Business Machines
   7 *   Corporation and others.  All Rights Reserved.
   8 *
   9 *******************************************************************************
  10 *   file name:  loclikely.cpp
  11 *   encoding:   UTF-8
  12 *   tab size:   8 (not used)
  13 *   indentation:4
  14 *
  15 *   created on: 2010feb25
  16 *   created by: Markus W. Scherer
  17 *
  18 *   Code for likely and minimized locale subtags, separated out from other .cpp files
  19 *   that then do not depend on resource bundle code and likely-subtags data.
  20 */
  21 
<span class="line-added">  22 #include &quot;unicode/bytestream.h&quot;</span>
  23 #include &quot;unicode/utypes.h&quot;
  24 #include &quot;unicode/locid.h&quot;
  25 #include &quot;unicode/putil.h&quot;
  26 #include &quot;unicode/uchar.h&quot;
  27 #include &quot;unicode/uloc.h&quot;
  28 #include &quot;unicode/ures.h&quot;
  29 #include &quot;unicode/uscript.h&quot;
<span class="line-added">  30 #include &quot;bytesinkutil.h&quot;</span>
<span class="line-added">  31 #include &quot;charstr.h&quot;</span>
  32 #include &quot;cmemory.h&quot;
  33 #include &quot;cstring.h&quot;
  34 #include &quot;ulocimp.h&quot;
  35 #include &quot;ustr_imp.h&quot;
  36 
<span class="line-added">  37 /**</span>
<span class="line-added">  38  * These are the canonical strings for unknown languages, scripts and regions.</span>
<span class="line-added">  39  **/</span>
<span class="line-added">  40 static const char* const unknownLanguage = &quot;und&quot;;</span>
<span class="line-added">  41 static const char* const unknownScript = &quot;Zzzz&quot;;</span>
<span class="line-added">  42 static const char* const unknownRegion = &quot;ZZ&quot;;</span>
<span class="line-added">  43 </span>
  44 /**
  45  * This function looks for the localeID in the likelySubtags resource.
  46  *
  47  * @param localeID The tag to find.
  48  * @param buffer A buffer to hold the matching entry
  49  * @param bufferLength The length of the output buffer
  50  * @return A pointer to &quot;buffer&quot; if found, or a null pointer if not.
  51  */
  52 static const char*  U_CALLCONV
  53 findLikelySubtags(const char* localeID,
  54                   char* buffer,
  55                   int32_t bufferLength,
  56                   UErrorCode* err) {
  57     const char* result = NULL;
  58 
  59     if (!U_FAILURE(*err)) {
  60         int32_t resLen = 0;
  61         const UChar* s = NULL;
  62         UErrorCode tmpErr = U_ZERO_ERROR;
<span class="line-modified">  63         icu::LocalUResourceBundlePointer subtags(ures_openDirect(NULL, &quot;likelySubtags&quot;, &amp;tmpErr));</span>
  64         if (U_SUCCESS(tmpErr)) {
<span class="line-modified">  65             icu::CharString und;</span>
<span class="line-added">  66             if (localeID != NULL) {</span>
<span class="line-added">  67                 if (*localeID == &#39;\0&#39;) {</span>
<span class="line-added">  68                     localeID = unknownLanguage;</span>
<span class="line-added">  69                 } else if (*localeID == &#39;_&#39;) {</span>
<span class="line-added">  70                     und.append(unknownLanguage, *err);</span>
<span class="line-added">  71                     und.append(localeID, *err);</span>
<span class="line-added">  72                     if (U_FAILURE(*err)) {</span>
<span class="line-added">  73                         return NULL;</span>
<span class="line-added">  74                     }</span>
<span class="line-added">  75                     localeID = und.data();</span>
<span class="line-added">  76                 }</span>
<span class="line-added">  77             }</span>
<span class="line-added">  78             s = ures_getStringByKey(subtags.getAlias(), localeID, &amp;resLen, &amp;tmpErr);</span>
  79 
  80             if (U_FAILURE(tmpErr)) {
  81                 /*
  82                  * If a resource is missing, it&#39;s not really an error, it&#39;s
  83                  * just that we don&#39;t have any data for that particular locale ID.
  84                  */
  85                 if (tmpErr != U_MISSING_RESOURCE_ERROR) {
  86                     *err = tmpErr;
  87                 }
  88             }
  89             else if (resLen &gt;= bufferLength) {
  90                 /* The buffer should never overflow. */
  91                 *err = U_INTERNAL_PROGRAM_ERROR;
  92             }
  93             else {
  94                 u_UCharsToChars(s, buffer, resLen + 1);
<span class="line-added">  95                 if (resLen &gt;= 3 &amp;&amp;</span>
<span class="line-added">  96                     uprv_strnicmp(buffer, unknownLanguage, 3) == 0 &amp;&amp;</span>
<span class="line-added">  97                     (resLen == 3 || buffer[3] == &#39;_&#39;)) {</span>
<span class="line-added">  98                     uprv_memmove(buffer, buffer + 3, resLen - 3 + 1);</span>
<span class="line-added">  99                 }</span>
 100                 result = buffer;
 101             }


 102         } else {
 103             *err = tmpErr;
 104         }
 105     }
 106 
 107     return result;
 108 }
 109 
 110 /**
 111  * Append a tag to a buffer, adding the separator if necessary.  The buffer
 112  * must be large enough to contain the resulting tag plus any separator
 113  * necessary. The tag must not be a zero-length string.
 114  *
 115  * @param tag The tag to add.
 116  * @param tagLength The length of the tag.
 117  * @param buffer The output buffer.
 118  * @param bufferLength The length of the output buffer.  This is an input/ouput parameter.
 119  **/
 120 static void U_CALLCONV
 121 appendTag(
 122     const char* tag,
 123     int32_t tagLength,
 124     char* buffer,
<span class="line-modified"> 125     int32_t* bufferLength,</span>
<span class="line-added"> 126     UBool withSeparator) {</span>
 127 
<span class="line-modified"> 128     if (withSeparator) {</span>
 129         buffer[*bufferLength] = &#39;_&#39;;
 130         ++(*bufferLength);
 131     }
 132 
 133     uprv_memmove(
 134         &amp;buffer[*bufferLength],
 135         tag,
 136         tagLength);
 137 
 138     *bufferLength += tagLength;
 139 }
 140 







 141 /**
 142  * Create a tag string from the supplied parameters.  The lang, script and region
 143  * parameters may be NULL pointers. If they are, their corresponding length parameters
 144  * must be less than or equal to 0.
 145  *
 146  * If any of the language, script or region parameters are empty, and the alternateTags
 147  * parameter is not NULL, it will be parsed for potential language, script and region tags
 148  * to be used when constructing the new tag.  If the alternateTags parameter is NULL, or
 149  * it contains no language tag, the default tag for the unknown language is used.
 150  *
 151  * If the length of the new string exceeds the capacity of the output buffer,
 152  * the function copies as many bytes to the output buffer as it can, and returns
 153  * the error U_BUFFER_OVERFLOW_ERROR.
 154  *
 155  * If an illegal argument is provided, the function returns the error
 156  * U_ILLEGAL_ARGUMENT_ERROR.
 157  *
 158  * Note that this function can return the warning U_STRING_NOT_TERMINATED_WARNING if
 159  * the tag string fits in the output buffer, but the null terminator doesn&#39;t.
 160  *
 161  * @param lang The language tag to use.
 162  * @param langLength The length of the language tag.
 163  * @param script The script tag to use.
 164  * @param scriptLength The length of the script tag.
 165  * @param region The region tag to use.
 166  * @param regionLength The length of the region tag.
 167  * @param trailing Any trailing data to append to the new tag.
 168  * @param trailingLength The length of the trailing data.
 169  * @param alternateTags A string containing any alternate tags.
<span class="line-modified"> 170  * @param sink The output sink receiving the tag string.</span>

 171  * @param err A pointer to a UErrorCode for error reporting.

 172  **/
<span class="line-modified"> 173 static void U_CALLCONV</span>
 174 createTagStringWithAlternates(
 175     const char* lang,
 176     int32_t langLength,
 177     const char* script,
 178     int32_t scriptLength,
 179     const char* region,
 180     int32_t regionLength,
 181     const char* trailing,
 182     int32_t trailingLength,
 183     const char* alternateTags,
<span class="line-modified"> 184     icu::ByteSink&amp; sink,</span>

 185     UErrorCode* err) {
 186 
 187     if (U_FAILURE(*err)) {
 188         goto error;
 189     }
<span class="line-modified"> 190     else if (langLength &gt;= ULOC_LANG_CAPACITY ||</span>


 191              scriptLength &gt;= ULOC_SCRIPT_CAPACITY ||
 192              regionLength &gt;= ULOC_COUNTRY_CAPACITY) {
 193         goto error;
 194     }
 195     else {
 196         /**
 197          * ULOC_FULLNAME_CAPACITY will provide enough capacity
 198          * that we can build a string that contains the language,
 199          * script and region code without worrying about overrunning
 200          * the user-supplied buffer.
 201          **/
 202         char tagBuffer[ULOC_FULLNAME_CAPACITY];
 203         int32_t tagLength = 0;

 204         UBool regionAppended = FALSE;
 205 
 206         if (langLength &gt; 0) {
 207             appendTag(
 208                 lang,
 209                 langLength,
 210                 tagBuffer,
<span class="line-modified"> 211                 &amp;tagLength,</span>
<span class="line-added"> 212                 /*withSeparator=*/FALSE);</span>
 213         }
 214         else if (alternateTags == NULL) {
 215             /*
<span class="line-modified"> 216              * Use the empty string for an unknown language, if</span>
 217              * we found no language.
 218              */





 219         }
 220         else {
 221             /*
 222              * Parse the alternateTags string for the language.
 223              */
 224             char alternateLang[ULOC_LANG_CAPACITY];
 225             int32_t alternateLangLength = sizeof(alternateLang);
 226 
 227             alternateLangLength =
 228                 uloc_getLanguage(
 229                     alternateTags,
 230                     alternateLang,
 231                     alternateLangLength,
 232                     err);
 233             if(U_FAILURE(*err) ||
 234                 alternateLangLength &gt;= ULOC_LANG_CAPACITY) {
 235                 goto error;
 236             }
 237             else if (alternateLangLength == 0) {
 238                 /*
<span class="line-modified"> 239                  * Use the empty string for an unknown language, if</span>
 240                  * we found no language.
 241                  */





 242             }
 243             else {
 244                 appendTag(
 245                     alternateLang,
 246                     alternateLangLength,
 247                     tagBuffer,
<span class="line-modified"> 248                     &amp;tagLength,</span>
<span class="line-added"> 249                     /*withSeparator=*/FALSE);</span>
 250             }
 251         }
 252 
 253         if (scriptLength &gt; 0) {
 254             appendTag(
 255                 script,
 256                 scriptLength,
 257                 tagBuffer,
<span class="line-modified"> 258                 &amp;tagLength,</span>
<span class="line-added"> 259                 /*withSeparator=*/TRUE);</span>
 260         }
 261         else if (alternateTags != NULL) {
 262             /*
 263              * Parse the alternateTags string for the script.
 264              */
 265             char alternateScript[ULOC_SCRIPT_CAPACITY];
 266 
 267             const int32_t alternateScriptLength =
 268                 uloc_getScript(
 269                     alternateTags,
 270                     alternateScript,
 271                     sizeof(alternateScript),
 272                     err);
 273 
 274             if (U_FAILURE(*err) ||
 275                 alternateScriptLength &gt;= ULOC_SCRIPT_CAPACITY) {
 276                 goto error;
 277             }
 278             else if (alternateScriptLength &gt; 0) {
 279                 appendTag(
 280                     alternateScript,
 281                     alternateScriptLength,
 282                     tagBuffer,
<span class="line-modified"> 283                     &amp;tagLength,</span>
<span class="line-added"> 284                     /*withSeparator=*/TRUE);</span>
 285             }
 286         }
 287 
 288         if (regionLength &gt; 0) {
 289             appendTag(
 290                 region,
 291                 regionLength,
 292                 tagBuffer,
<span class="line-modified"> 293                 &amp;tagLength,</span>
<span class="line-added"> 294                 /*withSeparator=*/TRUE);</span>
 295 
 296             regionAppended = TRUE;
 297         }
 298         else if (alternateTags != NULL) {
 299             /*
 300              * Parse the alternateTags string for the region.
 301              */
 302             char alternateRegion[ULOC_COUNTRY_CAPACITY];
 303 
 304             const int32_t alternateRegionLength =
 305                 uloc_getCountry(
 306                     alternateTags,
 307                     alternateRegion,
 308                     sizeof(alternateRegion),
 309                     err);
 310             if (U_FAILURE(*err) ||
 311                 alternateRegionLength &gt;= ULOC_COUNTRY_CAPACITY) {
 312                 goto error;
 313             }
 314             else if (alternateRegionLength &gt; 0) {
 315                 appendTag(
 316                     alternateRegion,
 317                     alternateRegionLength,
 318                     tagBuffer,
<span class="line-modified"> 319                     &amp;tagLength,</span>
<span class="line-added"> 320                     /*withSeparator=*/TRUE);</span>
 321 
 322                 regionAppended = TRUE;
 323             }
 324         }
 325 
<span class="line-modified"> 326         /**</span>
<span class="line-modified"> 327          * Copy the partial tag from our internal buffer to the supplied</span>
<span class="line-modified"> 328          * target.</span>
<span class="line-modified"> 329          **/</span>
<span class="line-modified"> 330         sink.Append(tagBuffer, tagLength);</span>










 331 
 332         if (trailingLength &gt; 0) {
<span class="line-modified"> 333             if (*trailing != &#39;@&#39;) {</span>
<span class="line-modified"> 334                 sink.Append(&quot;_&quot;, 1);</span>
<span class="line-modified"> 335                 if (!regionAppended) {</span>

 336                     /* extra separator is required */
<span class="line-modified"> 337                     sink.Append(&quot;_&quot;, 1);</span>

 338                 }
 339             }
 340 
<span class="line-modified"> 341             /*</span>
<span class="line-modified"> 342              * Copy the trailing data into the supplied buffer.</span>
<span class="line-modified"> 343              */</span>
<span class="line-modified"> 344             sink.Append(trailing, trailingLength);</span>









 345         }
 346 
<span class="line-modified"> 347         return;</span>






 348     }
 349 
 350 error:
 351 
 352     /**
 353      * An overflow indicates the locale ID passed in
 354      * is ill-formed.  If we got here, and there was
 355      * no previous error, it&#39;s an implicit overflow.
 356      **/
 357     if (*err ==  U_BUFFER_OVERFLOW_ERROR ||
 358         U_SUCCESS(*err)) {
 359         *err = U_ILLEGAL_ARGUMENT_ERROR;
 360     }


 361 }
 362 
 363 /**
 364  * Create a tag string from the supplied parameters.  The lang, script and region
 365  * parameters may be NULL pointers. If they are, their corresponding length parameters
 366  * must be less than or equal to 0.  If the lang parameter is an empty string, the
 367  * default value for an unknown language is written to the output buffer.
 368  *
 369  * If the length of the new string exceeds the capacity of the output buffer,
 370  * the function copies as many bytes to the output buffer as it can, and returns
 371  * the error U_BUFFER_OVERFLOW_ERROR.
 372  *
 373  * If an illegal argument is provided, the function returns the error
 374  * U_ILLEGAL_ARGUMENT_ERROR.
 375  *
 376  * @param lang The language tag to use.
 377  * @param langLength The length of the language tag.
 378  * @param script The script tag to use.
 379  * @param scriptLength The length of the script tag.
 380  * @param region The region tag to use.
 381  * @param regionLength The length of the region tag.
 382  * @param trailing Any trailing data to append to the new tag.
 383  * @param trailingLength The length of the trailing data.
<span class="line-modified"> 384  * @param sink The output sink receiving the tag string.</span>

 385  * @param err A pointer to a UErrorCode for error reporting.

 386  **/
<span class="line-modified"> 387 static void U_CALLCONV</span>
 388 createTagString(
 389     const char* lang,
 390     int32_t langLength,
 391     const char* script,
 392     int32_t scriptLength,
 393     const char* region,
 394     int32_t regionLength,
 395     const char* trailing,
 396     int32_t trailingLength,
<span class="line-modified"> 397     icu::ByteSink&amp; sink,</span>

 398     UErrorCode* err)
 399 {
<span class="line-modified"> 400     createTagStringWithAlternates(</span>
 401                 lang,
 402                 langLength,
 403                 script,
 404                 scriptLength,
 405                 region,
 406                 regionLength,
 407                 trailing,
 408                 trailingLength,
 409                 NULL,
<span class="line-modified"> 410                 sink,</span>

 411                 err);
 412 }
 413 
 414 /**
 415  * Parse the language, script, and region subtags from a tag string, and copy the
 416  * results into the corresponding output parameters. The buffers are null-terminated,
 417  * unless overflow occurs.
 418  *
 419  * The langLength, scriptLength, and regionLength parameters are input/output
 420  * parameters, and must contain the capacity of their corresponding buffers on
 421  * input.  On output, they will contain the actual length of the buffers, not
 422  * including the null terminator.
 423  *
 424  * If the length of any of the output subtags exceeds the capacity of the corresponding
 425  * buffer, the function copies as many bytes to the output buffer as it can, and returns
 426  * the error U_BUFFER_OVERFLOW_ERROR.  It will not parse any more subtags once overflow
 427  * occurs.
 428  *
 429  * If an illegal argument is provided, the function returns the error
 430  * U_ILLEGAL_ARGUMENT_ERROR.
</pre>
<hr />
<pre>
 462        region == NULL ||
 463        regionLength == NULL) {
 464         goto error;
 465     }
 466 
 467     subtagLength = ulocimp_getLanguage(position, lang, *langLength, &amp;position);
 468     u_terminateChars(lang, *langLength, subtagLength, err);
 469 
 470     /*
 471      * Note that we explicit consider U_STRING_NOT_TERMINATED_WARNING
 472      * to be an error, because it indicates the user-supplied tag is
 473      * not well-formed.
 474      */
 475     if(U_FAILURE(*err)) {
 476         goto error;
 477     }
 478 
 479     *langLength = subtagLength;
 480 
 481     /*
<span class="line-modified"> 482      * If no language was present, use the empty string instead.</span>
<span class="line-modified"> 483      * Otherwise, move past any separator.</span>
 484      */






 485     if (_isIDSeparator(*position)) {
 486         ++position;
 487     }
 488 
 489     subtagLength = ulocimp_getScript(position, script, *scriptLength, &amp;position);
 490     u_terminateChars(script, *scriptLength, subtagLength, err);
 491 
 492     if(U_FAILURE(*err)) {
 493         goto error;
 494     }
 495 
 496     *scriptLength = subtagLength;
 497 
 498     if (*scriptLength &gt; 0) {
 499         if (uprv_strnicmp(script, unknownScript, *scriptLength) == 0) {
 500             /**
 501              * If the script part is the &quot;unknown&quot; script, then don&#39;t return it.
 502              **/
 503             *scriptLength = 0;
 504         }
</pre>
<hr />
<pre>
 532         --position;
 533     }
 534 
 535 exit:
 536 
 537     return (int32_t)(position - localeID);
 538 
 539 error:
 540 
 541     /**
 542      * If we get here, we have no explicit error, it&#39;s the result of an
 543      * illegal argument.
 544      **/
 545     if (!U_FAILURE(*err)) {
 546         *err = U_ILLEGAL_ARGUMENT_ERROR;
 547     }
 548 
 549     goto exit;
 550 }
 551 
<span class="line-modified"> 552 static UBool U_CALLCONV</span>
 553 createLikelySubtagsString(
 554     const char* lang,
 555     int32_t langLength,
 556     const char* script,
 557     int32_t scriptLength,
 558     const char* region,
 559     int32_t regionLength,
 560     const char* variants,
 561     int32_t variantsLength,
<span class="line-modified"> 562     icu::ByteSink&amp; sink,</span>
<span class="line-modified"> 563     UErrorCode* err) {</span>


 564     /**
 565      * ULOC_FULLNAME_CAPACITY will provide enough capacity
 566      * that we can build a string that contains the language,
 567      * script and region code without worrying about overrunning
 568      * the user-supplied buffer.
 569      **/

 570     char likelySubtagsBuffer[ULOC_FULLNAME_CAPACITY];
 571 
 572     if(U_FAILURE(*err)) {
 573         goto error;
 574     }
 575 
 576     /**
 577      * Try the language with the script and region first.
 578      **/
 579     if (scriptLength &gt; 0 &amp;&amp; regionLength &gt; 0) {
 580 
 581         const char* likelySubtags = NULL;
 582 
<span class="line-modified"> 583         icu::CharString tagBuffer;</span>
<span class="line-modified"> 584         {</span>
<span class="line-modified"> 585             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
<span class="line-modified"> 586             createTagString(</span>
<span class="line-modified"> 587                 lang,</span>
<span class="line-modified"> 588                 langLength,</span>
<span class="line-modified"> 589                 script,</span>
<span class="line-modified"> 590                 scriptLength,</span>
<span class="line-modified"> 591                 region,</span>
<span class="line-modified"> 592                 regionLength,</span>
<span class="line-modified"> 593                 NULL,</span>
<span class="line-modified"> 594                 0,</span>
<span class="line-added"> 595                 sink,</span>
<span class="line-added"> 596                 err);</span>
<span class="line-added"> 597         }</span>
 598         if(U_FAILURE(*err)) {
 599             goto error;
 600         }
 601 
 602         likelySubtags =
 603             findLikelySubtags(
<span class="line-modified"> 604                 tagBuffer.data(),</span>
 605                 likelySubtagsBuffer,
 606                 sizeof(likelySubtagsBuffer),
 607                 err);
 608         if(U_FAILURE(*err)) {
 609             goto error;
 610         }
 611 
 612         if (likelySubtags != NULL) {
 613             /* Always use the language tag from the
 614                maximal string, since it may be more
 615                specific than the one provided. */
<span class="line-modified"> 616             createTagStringWithAlternates(</span>
 617                         NULL,
 618                         0,
 619                         NULL,
 620                         0,
 621                         NULL,
 622                         0,
 623                         variants,
 624                         variantsLength,
 625                         likelySubtags,
<span class="line-modified"> 626                         sink,</span>

 627                         err);
<span class="line-added"> 628             return TRUE;</span>
 629         }
 630     }
 631 
 632     /**
 633      * Try the language with just the script.
 634      **/
 635     if (scriptLength &gt; 0) {
 636 
 637         const char* likelySubtags = NULL;
 638 
<span class="line-modified"> 639         icu::CharString tagBuffer;</span>
<span class="line-modified"> 640         {</span>
<span class="line-modified"> 641             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
<span class="line-modified"> 642             createTagString(</span>
<span class="line-modified"> 643                 lang,</span>
<span class="line-modified"> 644                 langLength,</span>
<span class="line-modified"> 645                 script,</span>
<span class="line-modified"> 646                 scriptLength,</span>
<span class="line-modified"> 647                 NULL,</span>
<span class="line-modified"> 648                 0,</span>
<span class="line-modified"> 649                 NULL,</span>
<span class="line-modified"> 650                 0,</span>
<span class="line-added"> 651                 sink,</span>
<span class="line-added"> 652                 err);</span>
<span class="line-added"> 653         }</span>
 654         if(U_FAILURE(*err)) {
 655             goto error;
 656         }
 657 
 658         likelySubtags =
 659             findLikelySubtags(
<span class="line-modified"> 660                 tagBuffer.data(),</span>
 661                 likelySubtagsBuffer,
 662                 sizeof(likelySubtagsBuffer),
 663                 err);
 664         if(U_FAILURE(*err)) {
 665             goto error;
 666         }
 667 
 668         if (likelySubtags != NULL) {
 669             /* Always use the language tag from the
 670                maximal string, since it may be more
 671                specific than the one provided. */
<span class="line-modified"> 672             createTagStringWithAlternates(</span>
 673                         NULL,
 674                         0,
 675                         NULL,
 676                         0,
 677                         region,
 678                         regionLength,
 679                         variants,
 680                         variantsLength,
 681                         likelySubtags,
<span class="line-modified"> 682                         sink,</span>

 683                         err);
<span class="line-added"> 684             return TRUE;</span>
 685         }
 686     }
 687 
 688     /**
 689      * Try the language with just the region.
 690      **/
 691     if (regionLength &gt; 0) {
 692 
 693         const char* likelySubtags = NULL;
 694 
<span class="line-modified"> 695         icu::CharString tagBuffer;</span>
<span class="line-modified"> 696         {</span>
<span class="line-modified"> 697             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
<span class="line-modified"> 698             createTagString(</span>
<span class="line-modified"> 699                 lang,</span>
<span class="line-modified"> 700                 langLength,</span>
<span class="line-modified"> 701                 NULL,</span>
<span class="line-modified"> 702                 0,</span>
<span class="line-modified"> 703                 region,</span>
<span class="line-modified"> 704                 regionLength,</span>
<span class="line-modified"> 705                 NULL,</span>
<span class="line-modified"> 706                 0,</span>
<span class="line-added"> 707                 sink,</span>
<span class="line-added"> 708                 err);</span>
<span class="line-added"> 709         }</span>
 710         if(U_FAILURE(*err)) {
 711             goto error;
 712         }
 713 
 714         likelySubtags =
 715             findLikelySubtags(
<span class="line-modified"> 716                 tagBuffer.data(),</span>
 717                 likelySubtagsBuffer,
 718                 sizeof(likelySubtagsBuffer),
 719                 err);
 720         if(U_FAILURE(*err)) {
 721             goto error;
 722         }
 723 
 724         if (likelySubtags != NULL) {
 725             /* Always use the language tag from the
 726                maximal string, since it may be more
 727                specific than the one provided. */
<span class="line-modified"> 728             createTagStringWithAlternates(</span>
 729                         NULL,
 730                         0,
 731                         script,
 732                         scriptLength,
 733                         NULL,
 734                         0,
 735                         variants,
 736                         variantsLength,
 737                         likelySubtags,
<span class="line-modified"> 738                         sink,</span>

 739                         err);
<span class="line-added"> 740             return TRUE;</span>
 741         }
 742     }
 743 
 744     /**
 745      * Finally, try just the language.
 746      **/
 747     {
 748         const char* likelySubtags = NULL;
 749 
<span class="line-modified"> 750         icu::CharString tagBuffer;</span>
<span class="line-modified"> 751         {</span>
<span class="line-modified"> 752             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
<span class="line-modified"> 753             createTagString(</span>
<span class="line-modified"> 754                 lang,</span>
<span class="line-modified"> 755                 langLength,</span>
<span class="line-modified"> 756                 NULL,</span>
<span class="line-modified"> 757                 0,</span>
<span class="line-modified"> 758                 NULL,</span>
<span class="line-modified"> 759                 0,</span>
<span class="line-modified"> 760                 NULL,</span>
<span class="line-modified"> 761                 0,</span>
<span class="line-added"> 762                 sink,</span>
<span class="line-added"> 763                 err);</span>
<span class="line-added"> 764         }</span>
 765         if(U_FAILURE(*err)) {
 766             goto error;
 767         }
 768 
 769         likelySubtags =
 770             findLikelySubtags(
<span class="line-modified"> 771                 tagBuffer.data(),</span>
 772                 likelySubtagsBuffer,
 773                 sizeof(likelySubtagsBuffer),
 774                 err);
 775         if(U_FAILURE(*err)) {
 776             goto error;
 777         }
 778 
 779         if (likelySubtags != NULL) {
 780             /* Always use the language tag from the
 781                maximal string, since it may be more
 782                specific than the one provided. */
<span class="line-modified"> 783             createTagStringWithAlternates(</span>
 784                         NULL,
 785                         0,
 786                         script,
 787                         scriptLength,
 788                         region,
 789                         regionLength,
 790                         variants,
 791                         variantsLength,
 792                         likelySubtags,
<span class="line-modified"> 793                         sink,</span>

 794                         err);
<span class="line-added"> 795             return TRUE;</span>
 796         }
 797     }
 798 
<span class="line-modified"> 799     return FALSE;</span>




 800 
 801 error:
 802 
 803     if (!U_FAILURE(*err)) {
 804         *err = U_ILLEGAL_ARGUMENT_ERROR;
 805     }
 806 
<span class="line-modified"> 807     return FALSE;</span>
 808 }
 809 
 810 #define CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength) \
 811     {   int32_t count = 0; \
 812         int32_t i; \
 813         for (i = 0; i &lt; trailingLength; i++) { \
 814             if (trailing[i] == &#39;-&#39; || trailing[i] == &#39;_&#39;) { \
 815                 count = 0; \
 816                 if (count &gt; 8) { \
 817                     goto error; \
 818                 } \
 819             } else if (trailing[i] == &#39;@&#39;) { \
 820                 break; \
 821             } else if (count &gt; 8) { \
 822                 goto error; \
 823             } else { \
 824                 count++; \
 825             } \
 826         } \
 827     }
 828 
<span class="line-modified"> 829 static void</span>
<span class="line-modified"> 830 _uloc_addLikelySubtags(const char* localeID,</span>
<span class="line-modified"> 831                        icu::ByteSink&amp; sink,</span>
<span class="line-modified"> 832                        UErrorCode* err) {</span>


 833     char lang[ULOC_LANG_CAPACITY];
 834     int32_t langLength = sizeof(lang);
 835     char script[ULOC_SCRIPT_CAPACITY];
 836     int32_t scriptLength = sizeof(script);
 837     char region[ULOC_COUNTRY_CAPACITY];
 838     int32_t regionLength = sizeof(region);
 839     const char* trailing = &quot;&quot;;
 840     int32_t trailingLength = 0;
 841     int32_t trailingIndex = 0;
<span class="line-modified"> 842     UBool success = FALSE;</span>
 843 
 844     if(U_FAILURE(*err)) {
 845         goto error;
 846     }
<span class="line-modified"> 847     if (localeID == NULL) {</span>


 848         goto error;
 849     }
 850 
 851     trailingIndex = parseTagString(
 852         localeID,
 853         lang,
 854         &amp;langLength,
 855         script,
 856         &amp;scriptLength,
 857         region,
 858         &amp;regionLength,
 859         err);
 860     if(U_FAILURE(*err)) {
 861         /* Overflow indicates an illegal argument error */
 862         if (*err == U_BUFFER_OVERFLOW_ERROR) {
 863             *err = U_ILLEGAL_ARGUMENT_ERROR;
 864         }
 865 
 866         goto error;
 867     }
 868 
 869     /* Find the length of the trailing portion. */
 870     while (_isIDSeparator(localeID[trailingIndex])) {
 871         trailingIndex++;
 872     }
 873     trailing = &amp;localeID[trailingIndex];
 874     trailingLength = (int32_t)uprv_strlen(trailing);
 875 
 876     CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength);
 877 
<span class="line-modified"> 878     success =</span>
 879         createLikelySubtagsString(
 880             lang,
 881             langLength,
 882             script,
 883             scriptLength,
 884             region,
 885             regionLength,
 886             trailing,
 887             trailingLength,
<span class="line-modified"> 888             sink,</span>

 889             err);
 890 
<span class="line-modified"> 891     if (!success) {</span>
 892         const int32_t localIDLength = (int32_t)uprv_strlen(localeID);
 893 
 894         /*
 895          * If we get here, we need to return localeID.
 896          */
<span class="line-modified"> 897         sink.Append(localeID, localIDLength);</span>











 898     }
 899 
<span class="line-modified"> 900     return;</span>
 901 
 902 error:
 903 
 904     if (!U_FAILURE(*err)) {
 905         *err = U_ILLEGAL_ARGUMENT_ERROR;
 906     }


 907 }
 908 
<span class="line-modified"> 909 static void</span>
<span class="line-modified"> 910 _uloc_minimizeSubtags(const char* localeID,</span>
<span class="line-modified"> 911                       icu::ByteSink&amp; sink,</span>
<span class="line-modified"> 912                       UErrorCode* err) {</span>
<span class="line-modified"> 913     icu::CharString maximizedTagBuffer;</span>









 914 
 915     char lang[ULOC_LANG_CAPACITY];
 916     int32_t langLength = sizeof(lang);
 917     char script[ULOC_SCRIPT_CAPACITY];
 918     int32_t scriptLength = sizeof(script);
 919     char region[ULOC_COUNTRY_CAPACITY];
 920     int32_t regionLength = sizeof(region);
 921     const char* trailing = &quot;&quot;;
 922     int32_t trailingLength = 0;
 923     int32_t trailingIndex = 0;
 924 
 925     if(U_FAILURE(*err)) {
 926         goto error;
 927     }
<span class="line-modified"> 928     else if (localeID == NULL) {</span>


 929         goto error;
 930     }
 931 
 932     trailingIndex =
 933         parseTagString(
 934             localeID,
 935             lang,
 936             &amp;langLength,
 937             script,
 938             &amp;scriptLength,
 939             region,
 940             &amp;regionLength,
 941             err);
 942     if(U_FAILURE(*err)) {
 943 
 944         /* Overflow indicates an illegal argument error */
 945         if (*err == U_BUFFER_OVERFLOW_ERROR) {
 946             *err = U_ILLEGAL_ARGUMENT_ERROR;
 947         }
 948 
 949         goto error;
 950     }
 951 
 952     /* Find the spot where the variants or the keywords begin, if any. */
 953     while (_isIDSeparator(localeID[trailingIndex])) {
 954         trailingIndex++;
 955     }
 956     trailing = &amp;localeID[trailingIndex];
 957     trailingLength = (int32_t)uprv_strlen(trailing);
 958 
 959     CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength);
 960 
<span class="line-modified"> 961     {</span>
<span class="line-modified"> 962         icu::CharString base;</span>
<span class="line-modified"> 963         {</span>
<span class="line-modified"> 964             icu::CharStringByteSink sink(&amp;base);</span>
<span class="line-modified"> 965             createTagString(</span>
<span class="line-modified"> 966                 lang,</span>
<span class="line-modified"> 967                 langLength,</span>
<span class="line-modified"> 968                 script,</span>
<span class="line-modified"> 969                 scriptLength,</span>
<span class="line-modified"> 970                 region,</span>
<span class="line-modified"> 971                 regionLength,</span>
<span class="line-modified"> 972                 NULL,</span>
<span class="line-modified"> 973                 0,</span>
<span class="line-modified"> 974                 sink,</span>
<span class="line-modified"> 975                 err);</span>
<span class="line-added"> 976         }</span>
 977 
<span class="line-modified"> 978         /**</span>
<span class="line-modified"> 979          * First, we need to first get the maximization</span>
<span class="line-modified"> 980          * from AddLikelySubtags.</span>
<span class="line-modified"> 981          **/</span>
<span class="line-modified"> 982         {</span>
<span class="line-modified"> 983             icu::CharStringByteSink sink(&amp;maximizedTagBuffer);</span>
<span class="line-modified"> 984             ulocimp_addLikelySubtags(base.data(), sink, err);</span>
<span class="line-modified"> 985         }</span>
<span class="line-modified"> 986     }</span>

 987 
 988     if(U_FAILURE(*err)) {
 989         goto error;
 990     }
 991 
 992     /**
 993      * Start first with just the language.
 994      **/
 995     {
<span class="line-modified"> 996         icu::CharString tagBuffer;</span>
<span class="line-modified"> 997         {</span>
<span class="line-modified"> 998             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
 999             createLikelySubtagsString(
1000                 lang,
1001                 langLength,
1002                 NULL,
1003                 0,
1004                 NULL,
1005                 0,
1006                 NULL,
1007                 0,
<span class="line-modified">1008                 sink,</span>

1009                 err);
<span class="line-added">1010         }</span>
1011 
1012         if(U_FAILURE(*err)) {
1013             goto error;
1014         }
<span class="line-modified">1015         else if (!tagBuffer.isEmpty() &amp;&amp; uprv_strnicmp(</span>
<span class="line-modified">1016                     maximizedTagBuffer.data(),</span>
<span class="line-modified">1017                     tagBuffer.data(),</span>
<span class="line-modified">1018                     tagBuffer.length()) == 0) {</span>
1019 
<span class="line-modified">1020             createTagString(</span>
1021                         lang,
1022                         langLength,
1023                         NULL,
1024                         0,
1025                         NULL,
1026                         0,
1027                         trailing,
1028                         trailingLength,
<span class="line-modified">1029                         sink,</span>

1030                         err);
<span class="line-added">1031             return;</span>
1032         }
1033     }
1034 
1035     /**
1036      * Next, try the language and region.
1037      **/
1038     if (regionLength &gt; 0) {
1039 
<span class="line-modified">1040         icu::CharString tagBuffer;</span>
<span class="line-modified">1041         {</span>
<span class="line-modified">1042             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
1043             createLikelySubtagsString(
1044                 lang,
1045                 langLength,
1046                 NULL,
1047                 0,
1048                 region,
1049                 regionLength,
1050                 NULL,
1051                 0,
<span class="line-modified">1052                 sink,</span>

1053                 err);
<span class="line-added">1054         }</span>
1055 
1056         if(U_FAILURE(*err)) {
1057             goto error;
1058         }
1059         else if (uprv_strnicmp(
<span class="line-modified">1060                     maximizedTagBuffer.data(),</span>
<span class="line-modified">1061                     tagBuffer.data(),</span>
<span class="line-modified">1062                     tagBuffer.length()) == 0) {</span>
1063 
<span class="line-modified">1064             createTagString(</span>
1065                         lang,
1066                         langLength,
1067                         NULL,
1068                         0,
1069                         region,
1070                         regionLength,
1071                         trailing,
1072                         trailingLength,
<span class="line-modified">1073                         sink,</span>

1074                         err);
<span class="line-added">1075             return;</span>
1076         }
1077     }
1078 
1079     /**
1080      * Finally, try the language and script.  This is our last chance,
1081      * since trying with all three subtags would only yield the
1082      * maximal version that we already have.
1083      **/
1084     if (scriptLength &gt; 0 &amp;&amp; regionLength &gt; 0) {
<span class="line-modified">1085         icu::CharString tagBuffer;</span>
<span class="line-modified">1086         {</span>
<span class="line-modified">1087             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
1088             createLikelySubtagsString(
1089                 lang,
1090                 langLength,
1091                 script,
1092                 scriptLength,
1093                 NULL,
1094                 0,
1095                 NULL,
1096                 0,
<span class="line-modified">1097                 sink,</span>

1098                 err);
<span class="line-added">1099         }</span>
1100 
1101         if(U_FAILURE(*err)) {
1102             goto error;
1103         }
1104         else if (uprv_strnicmp(
<span class="line-modified">1105                     maximizedTagBuffer.data(),</span>
<span class="line-modified">1106                     tagBuffer.data(),</span>
<span class="line-modified">1107                     tagBuffer.length()) == 0) {</span>
1108 
<span class="line-modified">1109             createTagString(</span>
1110                         lang,
1111                         langLength,
1112                         script,
1113                         scriptLength,
1114                         NULL,
1115                         0,
1116                         trailing,
1117                         trailingLength,
<span class="line-modified">1118                         sink,</span>

1119                         err);
<span class="line-added">1120             return;</span>
1121         }
1122     }
1123 
1124     {
1125         /**
1126          * If we got here, return the locale ID parameter.
1127          **/
1128         const int32_t localeIDLength = (int32_t)uprv_strlen(localeID);
<span class="line-modified">1129         sink.Append(localeID, localeIDLength);</span>
<span class="line-modified">1130         return;</span>










1131     }
1132 
1133 error:
1134 
1135     if (!U_FAILURE(*err)) {
1136         *err = U_ILLEGAL_ARGUMENT_ERROR;
1137     }




1138 }
1139 
1140 static UBool
1141 do_canonicalize(const char*    localeID,
1142          char* buffer,
1143          int32_t bufferCapacity,
1144          UErrorCode* err)
1145 {
1146     uloc_canonicalize(
1147         localeID,
1148         buffer,
1149         bufferCapacity,
1150         err);
1151 
1152     if (*err == U_STRING_NOT_TERMINATED_WARNING ||
1153         *err == U_BUFFER_OVERFLOW_ERROR) {
1154         *err = U_ILLEGAL_ARGUMENT_ERROR;
1155 
1156         return FALSE;
1157     }
1158     else if (U_FAILURE(*err)) {
1159 
1160         return FALSE;
1161     }
1162     else {
1163         return TRUE;
1164     }
1165 }
1166 
1167 U_CAPI int32_t U_EXPORT2
<span class="line-modified">1168 uloc_addLikelySubtags(const char* localeID,</span>
<span class="line-modified">1169                       char* maximizedLocaleID,</span>
<span class="line-modified">1170                       int32_t maximizedLocaleIDCapacity,</span>
<span class="line-modified">1171                       UErrorCode* status) {</span>
<span class="line-modified">1172     if (U_FAILURE(*status)) {</span>
<span class="line-modified">1173         return 0;</span>
<span class="line-added">1174     }</span>
1175 
<span class="line-modified">1176     icu::CheckedArrayByteSink sink(</span>
<span class="line-modified">1177             maximizedLocaleID, maximizedLocaleIDCapacity);</span>
<span class="line-modified">1178 </span>
<span class="line-modified">1179     ulocimp_addLikelySubtags(localeID, sink, status);</span>
<span class="line-modified">1180     int32_t reslen = sink.NumberOfBytesAppended();</span>
<span class="line-modified">1181 </span>
<span class="line-added">1182     if (U_FAILURE(*status)) {</span>
<span class="line-added">1183         return sink.Overflowed() ? reslen : -1;</span>
1184     }
<span class="line-modified">1185 </span>
<span class="line-modified">1186     if (sink.Overflowed()) {</span>
<span class="line-modified">1187         *status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-modified">1188     } else {</span>
<span class="line-modified">1189         u_terminateChars(</span>
<span class="line-modified">1190                 maximizedLocaleID, maximizedLocaleIDCapacity, reslen, status);</span>
1191     }
<span class="line-added">1192 </span>
<span class="line-added">1193     return reslen;</span>
1194 }
1195 
<span class="line-modified">1196 U_CAPI void U_EXPORT2</span>
<span class="line-modified">1197 ulocimp_addLikelySubtags(const char* localeID,</span>
<span class="line-modified">1198                          icu::ByteSink&amp; sink,</span>
<span class="line-modified">1199                          UErrorCode* status) {</span>


1200     char localeBuffer[ULOC_FULLNAME_CAPACITY];
1201 
<span class="line-modified">1202     if (do_canonicalize(localeID, localeBuffer, sizeof localeBuffer, status)) {</span>
<span class="line-modified">1203         _uloc_addLikelySubtags(localeBuffer, sink, status);</span>




1204     }
<span class="line-modified">1205 }</span>
<span class="line-modified">1206 </span>
<span class="line-modified">1207 U_CAPI int32_t U_EXPORT2</span>
<span class="line-modified">1208 uloc_minimizeSubtags(const char* localeID,</span>
<span class="line-modified">1209                      char* minimizedLocaleID,</span>
<span class="line-modified">1210                      int32_t minimizedLocaleIDCapacity,</span>
<span class="line-added">1211                      UErrorCode* status) {</span>
<span class="line-added">1212     if (U_FAILURE(*status)) {</span>
<span class="line-added">1213         return 0;</span>
<span class="line-added">1214     }</span>
<span class="line-added">1215 </span>
<span class="line-added">1216     icu::CheckedArrayByteSink sink(</span>
<span class="line-added">1217             minimizedLocaleID, minimizedLocaleIDCapacity);</span>
<span class="line-added">1218 </span>
<span class="line-added">1219     ulocimp_minimizeSubtags(localeID, sink, status);</span>
<span class="line-added">1220     int32_t reslen = sink.NumberOfBytesAppended();</span>
<span class="line-added">1221 </span>
<span class="line-added">1222     if (U_FAILURE(*status)) {</span>
<span class="line-added">1223         return sink.Overflowed() ? reslen : -1;</span>
<span class="line-added">1224     }</span>
<span class="line-added">1225 </span>
<span class="line-added">1226     if (sink.Overflowed()) {</span>
<span class="line-added">1227         *status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-added">1228     } else {</span>
<span class="line-added">1229         u_terminateChars(</span>
<span class="line-added">1230                 minimizedLocaleID, minimizedLocaleIDCapacity, reslen, status);</span>
<span class="line-added">1231     }</span>
<span class="line-added">1232 </span>
<span class="line-added">1233     return reslen;</span>
<span class="line-added">1234 }</span>
<span class="line-added">1235 </span>
<span class="line-added">1236 U_CAPI void U_EXPORT2</span>
<span class="line-added">1237 ulocimp_minimizeSubtags(const char* localeID,</span>
<span class="line-added">1238                         icu::ByteSink&amp; sink,</span>
<span class="line-added">1239                         UErrorCode* status) {</span>
<span class="line-added">1240     char localeBuffer[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-added">1241 </span>
<span class="line-added">1242     if (do_canonicalize(localeID, localeBuffer, sizeof localeBuffer, status)) {</span>
<span class="line-added">1243         _uloc_minimizeSubtags(localeBuffer, sink, status);</span>
1244     }
1245 }
1246 
1247 // Pairs of (language subtag, + or -) for finding out fast if common languages
1248 // are LTR (minus) or RTL (plus).
1249 static const char LANG_DIR_STRING[] =
1250         &quot;root-en-es-pt-zh-ja-ko-de-fr-it-ar+he+fa+ru-nl-pl-th-tr-&quot;;
1251 
<span class="line-modified">1252 // Implemented here because this calls ulocimp_addLikelySubtags().</span>
1253 U_CAPI UBool U_EXPORT2
1254 uloc_isRightToLeft(const char *locale) {
1255     UErrorCode errorCode = U_ZERO_ERROR;
1256     char script[8];
1257     int32_t scriptLength = uloc_getScript(locale, script, UPRV_LENGTHOF(script), &amp;errorCode);
1258     if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING ||
1259             scriptLength == 0) {
1260         // Fastpath: We know the likely scripts and their writing direction
1261         // for some common languages.
1262         errorCode = U_ZERO_ERROR;
1263         char lang[8];
1264         int32_t langLength = uloc_getLanguage(locale, lang, UPRV_LENGTHOF(lang), &amp;errorCode);
<span class="line-modified">1265         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING) {</span>

1266             return FALSE;
1267         }
<span class="line-modified">1268         if (langLength &gt; 0) {</span>
<span class="line-modified">1269             const char* langPtr = uprv_strstr(LANG_DIR_STRING, lang);</span>
<span class="line-modified">1270             if (langPtr != NULL) {</span>
<span class="line-modified">1271                 switch (langPtr[langLength]) {</span>
<span class="line-modified">1272                 case &#39;-&#39;: return FALSE;</span>
<span class="line-modified">1273                 case &#39;+&#39;: return TRUE;</span>
<span class="line-added">1274                 default: break;  // partial match of a longer code</span>
<span class="line-added">1275                 }</span>
1276             }
1277         }
1278         // Otherwise, find the likely script.
1279         errorCode = U_ZERO_ERROR;
<span class="line-modified">1280         icu::CharString likely;</span>
<span class="line-modified">1281         {</span>
<span class="line-added">1282             icu::CharStringByteSink sink(&amp;likely);</span>
<span class="line-added">1283             ulocimp_addLikelySubtags(locale, sink, &amp;errorCode);</span>
<span class="line-added">1284         }</span>
1285         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING) {
1286             return FALSE;
1287         }
<span class="line-modified">1288         scriptLength = uloc_getScript(likely.data(), script, UPRV_LENGTHOF(script), &amp;errorCode);</span>
1289         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING ||
1290                 scriptLength == 0) {
1291             return FALSE;
1292         }
1293     }
1294     UScriptCode scriptCode = (UScriptCode)u_getPropertyValueEnum(UCHAR_SCRIPT, script);
1295     return uscript_isRightToLeft(scriptCode);
1296 }
1297 
1298 U_NAMESPACE_BEGIN
1299 
1300 UBool
1301 Locale::isRightToLeft() const {
1302     return uloc_isRightToLeft(getBaseName());
1303 }
1304 
1305 U_NAMESPACE_END
1306 
1307 // The following must at least allow for rg key value (6) plus terminator (1).
1308 #define ULOC_RG_BUFLEN 8
</pre>
<hr />
<pre>
1319     // First check for rg keyword value
1320     int32_t rgLen = uloc_getKeywordValue(localeID, &quot;rg&quot;, rgBuf, ULOC_RG_BUFLEN, &amp;rgStatus);
1321     if (U_FAILURE(rgStatus) || rgLen != 6) {
1322         rgLen = 0;
1323     } else {
1324         // rgBuf guaranteed to be zero terminated here, with text len 6
1325         char *rgPtr = rgBuf;
1326         for (; *rgPtr!= 0; rgPtr++) {
1327             *rgPtr = uprv_toupper(*rgPtr);
1328         }
1329         rgLen = (uprv_strcmp(rgBuf+2, &quot;ZZZZ&quot;) == 0)? 2: 0;
1330     }
1331 
1332     if (rgLen == 0) {
1333         // No valid rg keyword value, try for unicode_region_subtag
1334         rgLen = uloc_getCountry(localeID, rgBuf, ULOC_RG_BUFLEN, status);
1335         if (U_FAILURE(*status)) {
1336             rgLen = 0;
1337         } else if (rgLen == 0 &amp;&amp; inferRegion) {
1338             // no unicode_region_subtag but inferRegion TRUE, try likely subtags

1339             rgStatus = U_ZERO_ERROR;
<span class="line-modified">1340             icu::CharString locBuf;</span>
<span class="line-added">1341             {</span>
<span class="line-added">1342                 icu::CharStringByteSink sink(&amp;locBuf);</span>
<span class="line-added">1343                 ulocimp_addLikelySubtags(localeID, sink, &amp;rgStatus);</span>
<span class="line-added">1344             }</span>
1345             if (U_SUCCESS(rgStatus)) {
<span class="line-modified">1346                 rgLen = uloc_getCountry(locBuf.data(), rgBuf, ULOC_RG_BUFLEN, status);</span>
1347                 if (U_FAILURE(*status)) {
1348                     rgLen = 0;
1349                 }
1350             }
1351         }
1352     }
1353 
1354     rgBuf[rgLen] = 0;
1355     uprv_strncpy(region, rgBuf, regionCapacity);
1356     return u_terminateChars(region, regionCapacity, rgLen, status);
1357 }
1358 
</pre>
</td>
</tr>
</table>
<center><a href="locid.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="locmap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>