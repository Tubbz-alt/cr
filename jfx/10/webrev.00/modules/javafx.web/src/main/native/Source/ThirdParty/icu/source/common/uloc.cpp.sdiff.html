<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="uinvchar.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uloc_keytype.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 440     &quot;SVK&quot;, &quot;SLE&quot;, &quot;SMR&quot;, &quot;SEN&quot;, &quot;SOM&quot;, &quot;SUR&quot;, &quot;SSD&quot;, &quot;STP&quot;, &quot;SLV&quot;,
 441 /*  &quot;SX&quot;,  &quot;SY&quot;,  &quot;SZ&quot;,  &quot;TC&quot;,  &quot;TD&quot;,  &quot;TF&quot;,  &quot;TG&quot;,  &quot;TH&quot;,  &quot;TJ&quot;,     */
 442     &quot;SXM&quot;, &quot;SYR&quot;, &quot;SWZ&quot;, &quot;TCA&quot;, &quot;TCD&quot;, &quot;ATF&quot;, &quot;TGO&quot;, &quot;THA&quot;, &quot;TJK&quot;,
 443 /*  &quot;TK&quot;,  &quot;TL&quot;,  &quot;TM&quot;,  &quot;TN&quot;,  &quot;TO&quot;,  &quot;TR&quot;,  &quot;TT&quot;,  &quot;TV&quot;,     */
 444     &quot;TKL&quot;, &quot;TLS&quot;, &quot;TKM&quot;, &quot;TUN&quot;, &quot;TON&quot;, &quot;TUR&quot;, &quot;TTO&quot;, &quot;TUV&quot;,
 445 /*  &quot;TW&quot;,  &quot;TZ&quot;,  &quot;UA&quot;,  &quot;UG&quot;,  &quot;UM&quot;,  &quot;US&quot;,  &quot;UY&quot;,  &quot;UZ&quot;,     */
 446     &quot;TWN&quot;, &quot;TZA&quot;, &quot;UKR&quot;, &quot;UGA&quot;, &quot;UMI&quot;, &quot;USA&quot;, &quot;URY&quot;, &quot;UZB&quot;,
 447 /*  &quot;VA&quot;,  &quot;VC&quot;,  &quot;VE&quot;,  &quot;VG&quot;,  &quot;VI&quot;,  &quot;VN&quot;,  &quot;VU&quot;,  &quot;WF&quot;,     */
 448     &quot;VAT&quot;, &quot;VCT&quot;, &quot;VEN&quot;, &quot;VGB&quot;, &quot;VIR&quot;, &quot;VNM&quot;, &quot;VUT&quot;, &quot;WLF&quot;,
 449 /*  &quot;WS&quot;,  &quot;YE&quot;,  &quot;YT&quot;,  &quot;ZA&quot;,  &quot;ZM&quot;,  &quot;ZW&quot;,          */
 450     &quot;WSM&quot;, &quot;YEM&quot;, &quot;MYT&quot;, &quot;ZAF&quot;, &quot;ZMB&quot;, &quot;ZWE&quot;,
 451 NULL,
 452 /*  &quot;AN&quot;,  &quot;BU&quot;,  &quot;CS&quot;,  &quot;FX&quot;,  &quot;RO&quot;, &quot;SU&quot;,  &quot;TP&quot;,  &quot;YD&quot;,  &quot;YU&quot;,  &quot;ZR&quot; */
 453     &quot;ANT&quot;, &quot;BUR&quot;, &quot;SCG&quot;, &quot;FXX&quot;, &quot;ROM&quot;, &quot;SUN&quot;, &quot;TMP&quot;, &quot;YMD&quot;, &quot;YUG&quot;, &quot;ZAR&quot;,
 454 NULL
 455 };
 456 
 457 typedef struct CanonicalizationMap {
 458     const char *id;          /* input ID */
 459     const char *canonicalID; /* canonicalized output ID */
<span class="line-removed"> 460     const char *keyword;     /* keyword, or NULL if none */</span>
<span class="line-removed"> 461     const char *value;       /* keyword value, or NULL if kw==NULL */</span>
 462 } CanonicalizationMap;
 463 
 464 /**
 465  * A map to canonicalize locale IDs.  This handles a variety of
 466  * different semantic kinds of transformations.
 467  */
 468 static const CanonicalizationMap CANONICALIZE_MAP[] = {
<span class="line-modified"> 469     { &quot;&quot;,               &quot;en_US_POSIX&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-modified"> 470     { &quot;c&quot;,              &quot;en_US_POSIX&quot;, NULL, NULL }, /* POSIX name */</span>
<span class="line-modified"> 471     { &quot;posix&quot;,          &quot;en_US_POSIX&quot;, NULL, NULL }, /* POSIX name (alias of C) */</span>
<span class="line-modified"> 472     { &quot;art_LOJBAN&quot;,     &quot;jbo&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-modified"> 473     { &quot;az_AZ_CYRL&quot;,     &quot;az_Cyrl_AZ&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-modified"> 474     { &quot;az_AZ_LATN&quot;,     &quot;az_Latn_AZ&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-modified"> 475     { &quot;ca_ES_PREEURO&quot;,  &quot;ca_ES&quot;, &quot;currency&quot;, &quot;ESP&quot; },</span>
<span class="line-modified"> 476     { &quot;de__PHONEBOOK&quot;,  &quot;de&quot;, &quot;collation&quot;, &quot;phonebook&quot; }, /* Old ICU name */</span>
<span class="line-modified"> 477     { &quot;de_AT_PREEURO&quot;,  &quot;de_AT&quot;, &quot;currency&quot;, &quot;ATS&quot; },</span>
<span class="line-modified"> 478     { &quot;de_DE_PREEURO&quot;,  &quot;de_DE&quot;, &quot;currency&quot;, &quot;DEM&quot; },</span>
<span class="line-removed"> 479     { &quot;de_LU_PREEURO&quot;,  &quot;de_LU&quot;, &quot;currency&quot;, &quot;LUF&quot; },</span>
<span class="line-removed"> 480     { &quot;el_GR_PREEURO&quot;,  &quot;el_GR&quot;, &quot;currency&quot;, &quot;GRD&quot; },</span>
<span class="line-removed"> 481     { &quot;en_BE_PREEURO&quot;,  &quot;en_BE&quot;, &quot;currency&quot;, &quot;BEF&quot; },</span>
<span class="line-removed"> 482     { &quot;en_IE_PREEURO&quot;,  &quot;en_IE&quot;, &quot;currency&quot;, &quot;IEP&quot; },</span>
<span class="line-removed"> 483     { &quot;es__TRADITIONAL&quot;, &quot;es&quot;, &quot;collation&quot;, &quot;traditional&quot; }, /* Old ICU name */</span>
<span class="line-removed"> 484     { &quot;es_ES_PREEURO&quot;,  &quot;es_ES&quot;, &quot;currency&quot;, &quot;ESP&quot; },</span>
<span class="line-removed"> 485     { &quot;eu_ES_PREEURO&quot;,  &quot;eu_ES&quot;, &quot;currency&quot;, &quot;ESP&quot; },</span>
<span class="line-removed"> 486     { &quot;fi_FI_PREEURO&quot;,  &quot;fi_FI&quot;, &quot;currency&quot;, &quot;FIM&quot; },</span>
<span class="line-removed"> 487     { &quot;fr_BE_PREEURO&quot;,  &quot;fr_BE&quot;, &quot;currency&quot;, &quot;BEF&quot; },</span>
<span class="line-removed"> 488     { &quot;fr_FR_PREEURO&quot;,  &quot;fr_FR&quot;, &quot;currency&quot;, &quot;FRF&quot; },</span>
<span class="line-removed"> 489     { &quot;fr_LU_PREEURO&quot;,  &quot;fr_LU&quot;, &quot;currency&quot;, &quot;LUF&quot; },</span>
<span class="line-removed"> 490     { &quot;ga_IE_PREEURO&quot;,  &quot;ga_IE&quot;, &quot;currency&quot;, &quot;IEP&quot; },</span>
<span class="line-removed"> 491     { &quot;gl_ES_PREEURO&quot;,  &quot;gl_ES&quot;, &quot;currency&quot;, &quot;ESP&quot; },</span>
<span class="line-removed"> 492     { &quot;hi__DIRECT&quot;,     &quot;hi&quot;, &quot;collation&quot;, &quot;direct&quot; }, /* Old ICU name */</span>
<span class="line-removed"> 493     { &quot;it_IT_PREEURO&quot;,  &quot;it_IT&quot;, &quot;currency&quot;, &quot;ITL&quot; },</span>
<span class="line-removed"> 494     { &quot;ja_JP_TRADITIONAL&quot;, &quot;ja_JP&quot;, &quot;calendar&quot;, &quot;japanese&quot; }, /* Old ICU name */</span>
<span class="line-removed"> 495     { &quot;nb_NO_NY&quot;,       &quot;nn_NO&quot;, NULL, NULL },  /* &quot;markus said this was ok&quot; :-) */</span>
<span class="line-removed"> 496     { &quot;nl_BE_PREEURO&quot;,  &quot;nl_BE&quot;, &quot;currency&quot;, &quot;BEF&quot; },</span>
<span class="line-removed"> 497     { &quot;nl_NL_PREEURO&quot;,  &quot;nl_NL&quot;, &quot;currency&quot;, &quot;NLG&quot; },</span>
<span class="line-removed"> 498     { &quot;pt_PT_PREEURO&quot;,  &quot;pt_PT&quot;, &quot;currency&quot;, &quot;PTE&quot; },</span>
<span class="line-removed"> 499     { &quot;sr_SP_CYRL&quot;,     &quot;sr_Cyrl_RS&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-removed"> 500     { &quot;sr_SP_LATN&quot;,     &quot;sr_Latn_RS&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-removed"> 501     { &quot;sr_YU_CYRILLIC&quot;, &quot;sr_Cyrl_RS&quot;, NULL, NULL }, /* Linux name */</span>
<span class="line-removed"> 502     { &quot;th_TH_TRADITIONAL&quot;, &quot;th_TH&quot;, &quot;calendar&quot;, &quot;buddhist&quot; }, /* Old ICU name */</span>
<span class="line-removed"> 503     { &quot;uz_UZ_CYRILLIC&quot;, &quot;uz_Cyrl_UZ&quot;, NULL, NULL }, /* Linux name */</span>
<span class="line-removed"> 504     { &quot;uz_UZ_CYRL&quot;,     &quot;uz_Cyrl_UZ&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-removed"> 505     { &quot;uz_UZ_LATN&quot;,     &quot;uz_Latn_UZ&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-removed"> 506     { &quot;zh_CHS&quot;,         &quot;zh_Hans&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-removed"> 507     { &quot;zh_CHT&quot;,         &quot;zh_Hant&quot;, NULL, NULL }, /* .NET name */</span>
<span class="line-removed"> 508     { &quot;zh_GAN&quot;,         &quot;gan&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-removed"> 509     { &quot;zh_GUOYU&quot;,       &quot;zh&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-removed"> 510     { &quot;zh_HAKKA&quot;,       &quot;hak&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-removed"> 511     { &quot;zh_MIN_NAN&quot;,     &quot;nan&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-removed"> 512     { &quot;zh_WUU&quot;,         &quot;wuu&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-removed"> 513     { &quot;zh_XIANG&quot;,       &quot;hsn&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-removed"> 514     { &quot;zh_YUE&quot;,         &quot;yue&quot;, NULL, NULL }, /* registered name */</span>
<span class="line-removed"> 515 };</span>
<span class="line-removed"> 516 </span>
<span class="line-removed"> 517 typedef struct VariantMap {</span>
<span class="line-removed"> 518     const char *variant;          /* input ID */</span>
<span class="line-removed"> 519     const char *keyword;     /* keyword, or NULL if none */</span>
<span class="line-removed"> 520     const char *value;       /* keyword value, or NULL if kw==NULL */</span>
<span class="line-removed"> 521 } VariantMap;</span>
<span class="line-removed"> 522 </span>
<span class="line-removed"> 523 static const VariantMap VARIANT_MAP[] = {</span>
<span class="line-removed"> 524     { &quot;EURO&quot;,   &quot;currency&quot;, &quot;EUR&quot; },</span>
<span class="line-removed"> 525     { &quot;PINYIN&quot;, &quot;collation&quot;, &quot;pinyin&quot; }, /* Solaris variant */</span>
<span class="line-removed"> 526     { &quot;STROKE&quot;, &quot;collation&quot;, &quot;stroke&quot; }  /* Solaris variant */</span>
 527 };
 528 
 529 /* ### BCP47 Conversion *******************************************/
 530 /* Test if the locale id has BCP47 u extension and does not have &#39;@&#39; */
 531 #define _hasBCP47Extension(id) (id &amp;&amp; uprv_strstr(id, &quot;@&quot;) == NULL &amp;&amp; getShortestSubtagLength(localeID) == 1)
 532 /* Converts the BCP47 id to Unicode id. Does nothing to id if conversion fails */
 533 #define _ConvertBCP47(finalID, id, buffer, length,err) \
 534         if (uloc_forLanguageTag(id, buffer, length, NULL, err) &lt;= 0 ||  \
 535                 U_FAILURE(*err) || *err == U_STRING_NOT_TERMINATED_WARNING) { \
 536             finalID=id; \
 537             if (*err == U_STRING_NOT_TERMINATED_WARNING) { *err = U_BUFFER_OVERFLOW_ERROR; } \
 538         } else { \
 539             finalID=buffer; \
 540         }
 541 /* Gets the size of the shortest subtag in the given localeID. */
 542 static int32_t getShortestSubtagLength(const char *localeID) {
 543     int32_t localeIDLength = static_cast&lt;int32_t&gt;(uprv_strlen(localeID));
 544     int32_t length = localeIDLength;
 545     int32_t tmpLength = 0;
 546     int32_t i;
</pre>
<hr />
<pre>
 626   }
 627   buf[keywordNameLen] = 0; /* terminate */
 628 
 629   return keywordNameLen;
 630 }
 631 
 632 typedef struct {
 633     char keyword[ULOC_KEYWORD_BUFFER_LEN];
 634     int32_t keywordLen;
 635     const char *valueStart;
 636     int32_t valueLen;
 637 } KeywordStruct;
 638 
 639 static int32_t U_CALLCONV
 640 compareKeywordStructs(const void * /*context*/, const void *left, const void *right) {
 641     const char* leftString = ((const KeywordStruct *)left)-&gt;keyword;
 642     const char* rightString = ((const KeywordStruct *)right)-&gt;keyword;
 643     return uprv_strcmp(leftString, rightString);
 644 }
 645 
<span class="line-removed"> 646 /**</span>
<span class="line-removed"> 647  * Both addKeyword and addValue must already be in canonical form.</span>
<span class="line-removed"> 648  * Either both addKeyword and addValue are NULL, or neither is NULL.</span>
<span class="line-removed"> 649  * If they are not NULL they must be zero terminated.</span>
<span class="line-removed"> 650  * If addKeyword is not NULL is must have length small enough to fit in KeywordStruct.keyword.</span>
<span class="line-removed"> 651  */</span>
 652 static int32_t
 653 _getKeywords(const char *localeID,
 654              char prev,
 655              char *keywords, int32_t keywordCapacity,
 656              char *values, int32_t valuesCapacity, int32_t *valLen,
 657              UBool valuesToo,
<span class="line-removed"> 658              const char* addKeyword,</span>
<span class="line-removed"> 659              const char* addValue,</span>
 660              UErrorCode *status)
 661 {
 662     KeywordStruct keywordList[ULOC_MAX_NO_KEYWORDS];
 663 
 664     int32_t maxKeywords = ULOC_MAX_NO_KEYWORDS;
 665     int32_t numKeywords = 0;
 666     const char* pos = localeID;
 667     const char* equalSign = NULL;
 668     const char* semicolon = NULL;
 669     int32_t i = 0, j, n;
 670     int32_t keywordsLen = 0;
 671     int32_t valuesLen = 0;
 672 
 673     if(prev == &#39;@&#39;) { /* start of keyword definition */
 674         /* we will grab pairs, trim spaces, lowercase keywords, sort and return */
 675         do {
 676             UBool duplicate = FALSE;
 677             /* skip leading spaces */
 678             while(*pos == &#39; &#39;) {
 679                 pos++;
</pre>
<hr />
<pre>
 738                 pos++;
 739             } else {
 740                 i = (int32_t)uprv_strlen(equalSign);
 741                 while(i &amp;&amp; equalSign[i-1] == &#39; &#39;) {
 742                     i--;
 743                 }
 744                 keywordList[numKeywords].valueLen = i;
 745             }
 746             /* If this is a duplicate keyword, then ignore it */
 747             for (j=0; j&lt;numKeywords; ++j) {
 748                 if (uprv_strcmp(keywordList[j].keyword, keywordList[numKeywords].keyword) == 0) {
 749                     duplicate = TRUE;
 750                     break;
 751                 }
 752             }
 753             if (!duplicate) {
 754                 ++numKeywords;
 755             }
 756         } while(pos);
 757 
<span class="line-removed"> 758         /* Handle addKeyword/addValue. */</span>
<span class="line-removed"> 759         if (addKeyword != NULL) {</span>
<span class="line-removed"> 760             UBool duplicate = FALSE;</span>
<span class="line-removed"> 761             U_ASSERT(addValue != NULL);</span>
<span class="line-removed"> 762             /* Search for duplicate; if found, do nothing. Explicit keyword</span>
<span class="line-removed"> 763                overrides addKeyword. */</span>
<span class="line-removed"> 764             for (j=0; j&lt;numKeywords; ++j) {</span>
<span class="line-removed"> 765                 if (uprv_strcmp(keywordList[j].keyword, addKeyword) == 0) {</span>
<span class="line-removed"> 766                     duplicate = TRUE;</span>
<span class="line-removed"> 767                     break;</span>
<span class="line-removed"> 768                 }</span>
<span class="line-removed"> 769             }</span>
<span class="line-removed"> 770             if (!duplicate) {</span>
<span class="line-removed"> 771                 if (numKeywords == maxKeywords) {</span>
<span class="line-removed"> 772                     *status = U_INTERNAL_PROGRAM_ERROR;</span>
<span class="line-removed"> 773                     return 0;</span>
<span class="line-removed"> 774                 }</span>
<span class="line-removed"> 775                 uprv_strcpy(keywordList[numKeywords].keyword, addKeyword);</span>
<span class="line-removed"> 776                 keywordList[numKeywords].keywordLen = (int32_t)uprv_strlen(addKeyword);</span>
<span class="line-removed"> 777                 keywordList[numKeywords].valueStart = addValue;</span>
<span class="line-removed"> 778                 keywordList[numKeywords].valueLen = (int32_t)uprv_strlen(addValue);</span>
<span class="line-removed"> 779                 ++numKeywords;</span>
<span class="line-removed"> 780             }</span>
<span class="line-removed"> 781         } else {</span>
<span class="line-removed"> 782             U_ASSERT(addValue == NULL);</span>
<span class="line-removed"> 783         }</span>
<span class="line-removed"> 784 </span>
 785         /* now we have a list of keywords */
 786         /* we need to sort it */
 787         uprv_sortArray(keywordList, numKeywords, sizeof(KeywordStruct), compareKeywordStructs, NULL, FALSE, status);
 788 
 789         /* Now construct the keyword part */
 790         for(i = 0; i &lt; numKeywords; i++) {
 791             if(keywordsLen + keywordList[i].keywordLen + 1&lt; keywordCapacity) {
 792                 uprv_strcpy(keywords+keywordsLen, keywordList[i].keyword);
 793                 if(valuesToo) {
 794                     keywords[keywordsLen + keywordList[i].keywordLen] = &#39;=&#39;;
 795                 } else {
 796                     keywords[keywordsLen + keywordList[i].keywordLen] = 0;
 797                 }
 798             }
 799             keywordsLen += keywordList[i].keywordLen + 1;
 800             if(valuesToo) {
<span class="line-modified"> 801                 if(keywordsLen + keywordList[i].valueLen &lt; keywordCapacity) {</span>
 802                     uprv_strncpy(keywords+keywordsLen, keywordList[i].valueStart, keywordList[i].valueLen);
 803                 }
 804                 keywordsLen += keywordList[i].valueLen;
 805 
 806                 if(i &lt; numKeywords - 1) {
 807                     if(keywordsLen &lt; keywordCapacity) {
 808                         keywords[keywordsLen] = &#39;;&#39;;
 809                     }
 810                     keywordsLen++;
 811                 }
 812             }
 813             if(values) {
 814                 if(valuesLen + keywordList[i].valueLen + 1&lt; valuesCapacity) {
 815                     uprv_strcpy(values+valuesLen, keywordList[i].valueStart);
 816                     values[valuesLen + keywordList[i].valueLen] = 0;
 817                 }
 818                 valuesLen += keywordList[i].valueLen + 1;
 819             }
 820         }
 821         if(values) {
 822             values[valuesLen] = 0;
 823             if(valLen) {
 824                 *valLen = valuesLen;
 825             }
 826         }
 827         return u_terminateChars(keywords, keywordCapacity, keywordsLen, status);
 828     } else {
 829         return 0;
 830     }
 831 }
 832 
 833 U_CFUNC int32_t
 834 locale_getKeywords(const char *localeID,
 835                    char prev,
 836                    char *keywords, int32_t keywordCapacity,
 837                    char *values, int32_t valuesCapacity, int32_t *valLen,
 838                    UBool valuesToo,
 839                    UErrorCode *status) {
 840     return _getKeywords(localeID, prev, keywords, keywordCapacity,
 841                         values, valuesCapacity, valLen, valuesToo,
<span class="line-modified"> 842                         NULL, NULL, status);</span>
 843 }
 844 
 845 U_CAPI int32_t U_EXPORT2
 846 uloc_getKeywordValue(const char* localeID,
 847                      const char* keywordName,
 848                      char* buffer, int32_t bufferCapacity,
 849                      UErrorCode* status)
 850 {
 851     const char* startSearchHere = NULL;
 852     const char* nextSeparator = NULL;
 853     char keywordNameBuffer[ULOC_KEYWORD_BUFFER_LEN];
 854     char localeKeywordNameBuffer[ULOC_KEYWORD_BUFFER_LEN];
 855     int32_t result = 0;
 856 
 857     if(status &amp;&amp; U_SUCCESS(*status) &amp;&amp; localeID) {
 858       char tempBuffer[ULOC_FULLNAME_CAPACITY];
 859       const char* tmpLocaleID;
 860 
 861       if (keywordName == NULL || keywordName[0] == 0) {
 862         *status = U_ILLEGAL_ARGUMENT_ERROR;
</pre>
<hr />
<pre>
1116                 updatedKeysAndValues.append(&#39;=&#39;, *status);
1117                 updatedKeysAndValues.append(keywordValueBuffer, keywordValueLen, *status);
1118             } /* else removing this entry, don&#39;t emit anything */
1119             handledInputKeyAndValue = TRUE;
1120         } else {
1121            /* input keyword sorts earlier than current entry, add before current entry */
1122             if (rc &lt; 0 &amp;&amp; keywordValueLen &gt; 0 &amp;&amp; !handledInputKeyAndValue) {
1123                 /* insert new entry at this location */
1124                 updatedKeysAndValues.append(keyValuePrefix, *status);
1125                 keyValuePrefix = &#39;;&#39;; /* for any subsequent key-value pair */
1126                 updatedKeysAndValues.append(keywordNameBuffer, keywordNameLen, *status);
1127                 updatedKeysAndValues.append(&#39;=&#39;, *status);
1128                 updatedKeysAndValues.append(keywordValueBuffer, keywordValueLen, *status);
1129                 handledInputKeyAndValue = TRUE;
1130             }
1131             /* copy the current entry */
1132             updatedKeysAndValues.append(keyValuePrefix, *status);
1133             keyValuePrefix = &#39;;&#39;; /* for any subsequent key-value pair */
1134             updatedKeysAndValues.append(localeKeywordNameBuffer, keyValueLen, *status);
1135             updatedKeysAndValues.append(&#39;=&#39;, *status);
<span class="line-modified">1136             updatedKeysAndValues.append(nextEqualsign, keyValueTail-nextEqualsign, *status);</span>
1137         }
1138         if (!nextSeparator &amp;&amp; keywordValueLen &gt; 0 &amp;&amp; !handledInputKeyAndValue) {
1139             /* append new entry at the end, it sorts later than existing entries */
1140             updatedKeysAndValues.append(keyValuePrefix, *status);
1141             /* skip keyValuePrefix update, no subsequent key-value pair */
1142             updatedKeysAndValues.append(keywordNameBuffer, keywordNameLen, *status);
1143             updatedKeysAndValues.append(&#39;=&#39;, *status);
1144             updatedKeysAndValues.append(keywordValueBuffer, keywordValueLen, *status);
1145             handledInputKeyAndValue = TRUE;
1146         }
1147         keywordStart = nextSeparator;
1148     } /* end loop searching */
1149 
1150     /* Any error from updatedKeysAndValues.append above would be internal and not due to
1151      * problems with the passed-in locale. So if we did encounter problems with the
1152      * passed-in locale above, those errors took precedence and overrode any error
1153      * status from updatedKeysAndValues.append, and also caused a return of 0. If there
1154      * are errors here they are from updatedKeysAndValues.append; they do cause an
1155      * error return but the passed-in locale is unmodified and the original bufLen is
1156      * returned.
</pre>
<hr />
<pre>
1171     if (updatedKeysAndValuesLen &gt; 0) {
1172         uprv_strncpy(startSearchHere, updatedKeysAndValues.data(), updatedKeysAndValuesLen);
1173     }
1174     buffer[needLen]=0;
1175     return needLen;
1176 }
1177 
1178 /* ### ID parsing implementation **************************************************/
1179 
1180 #define _isPrefixLetter(a) ((a==&#39;x&#39;)||(a==&#39;X&#39;)||(a==&#39;i&#39;)||(a==&#39;I&#39;))
1181 
1182 /*returns TRUE if one of the special prefixes is here (s=string)
1183   &#39;x-&#39; or &#39;i-&#39; */
1184 #define _isIDPrefix(s) (_isPrefixLetter(s[0])&amp;&amp;_isIDSeparator(s[1]))
1185 
1186 /* Dot terminates it because of POSIX form  where dot precedes the codepage
1187  * except for variant
1188  */
1189 #define _isTerminator(a)  ((a==0)||(a==&#39;.&#39;)||(a==&#39;@&#39;))
1190 
<span class="line-removed">1191 static char* _strnchr(const char* str, int32_t len, char c) {</span>
<span class="line-removed">1192     U_ASSERT(str != 0 &amp;&amp; len &gt;= 0);</span>
<span class="line-removed">1193     while (len-- != 0) {</span>
<span class="line-removed">1194         char d = *str;</span>
<span class="line-removed">1195         if (d == c) {</span>
<span class="line-removed">1196             return (char*) str;</span>
<span class="line-removed">1197         } else if (d == 0) {</span>
<span class="line-removed">1198             break;</span>
<span class="line-removed">1199         }</span>
<span class="line-removed">1200         ++str;</span>
<span class="line-removed">1201     }</span>
<span class="line-removed">1202     return NULL;</span>
<span class="line-removed">1203 }</span>
<span class="line-removed">1204 </span>
1205 /**
1206  * Lookup &#39;key&#39; in the array &#39;list&#39;.  The array &#39;list&#39; should contain
1207  * a NULL entry, followed by more entries, and a second NULL entry.
1208  *
1209  * The &#39;list&#39; param should be LANGUAGES, LANGUAGES_3, COUNTRIES, or
1210  * COUNTRIES_3.
1211  */
1212 static int16_t _findIndex(const char* const* list, const char* key)
1213 {
1214     const char* const* anchor = list;
1215     int32_t pass = 0;
1216 
1217     /* Make two passes through two NULL-terminated arrays at &#39;list&#39; */
1218     while (pass++ &lt; 2) {
1219         while (*list) {
1220             if (uprv_strcmp(key, *list) == 0) {
1221                 return (int16_t)(list - anchor);
1222             }
1223             list++;
1224         }
</pre>
<hr />
<pre>
1262         return REPLACEMENT_LANGUAGES[offset];
1263     }
1264     return oldID;
1265 }
1266 /*
1267  * the internal functions _getLanguage(), _getCountry(), _getVariant()
1268  * avoid duplicating code to handle the earlier locale ID pieces
1269  * in the functions for the later ones by
1270  * setting the *pEnd pointer to where they stopped parsing
1271  *
1272  * TODO try to use this in Locale
1273  */
1274 U_CFUNC int32_t
1275 ulocimp_getLanguage(const char *localeID,
1276                     char *language, int32_t languageCapacity,
1277                     const char **pEnd) {
1278     int32_t i=0;
1279     int32_t offset;
1280     char lang[4]={ 0, 0, 0, 0 }; /* temporary buffer to hold language code for searching */
1281 










1282     /* if it starts with i- or x- then copy that prefix */
1283     if(_isIDPrefix(localeID)) {
1284         if(i&lt;languageCapacity) {
1285             language[i]=(char)uprv_tolower(*localeID);
1286         }
1287         if(i&lt;languageCapacity) {
1288             language[i+1]=&#39;-&#39;;
1289         }
1290         i+=2;
1291         localeID+=2;
1292     }
1293 
1294     /* copy the language as far as possible and count its length */
1295     while(!_isTerminator(*localeID) &amp;&amp; !_isIDSeparator(*localeID)) {
1296         if(i&lt;languageCapacity) {
1297             language[i]=(char)uprv_tolower(*localeID);
1298         }
1299         if(i&lt;3) {
1300             U_ASSERT(i&gt;=0);
1301             lang[i]=(char)uprv_tolower(*localeID);
</pre>
<hr />
<pre>
1459                 variant[i]=(char)uprv_toupper(*localeID);
1460                 if(variant[i]==&#39;-&#39; || variant[i]==&#39;,&#39;) {
1461                     variant[i]=&#39;_&#39;;
1462                 }
1463             }
1464             i++;
1465             localeID++;
1466         }
1467     }
1468 
1469     return i;
1470 }
1471 
1472 static int32_t
1473 _getVariant(const char *localeID,
1474             char prev,
1475             char *variant, int32_t variantCapacity) {
1476     return _getVariantEx(localeID, prev, variant, variantCapacity, FALSE);
1477 }
1478 
<span class="line-removed">1479 /**</span>
<span class="line-removed">1480  * Delete ALL instances of a variant from the given list of one or</span>
<span class="line-removed">1481  * more variants.  Example: &quot;FOO_EURO_BAR_EURO&quot; =&gt; &quot;FOO_BAR&quot;.</span>
<span class="line-removed">1482  * @param variants the source string of one or more variants,</span>
<span class="line-removed">1483  * separated by &#39;_&#39;.  This will be MODIFIED IN PLACE.  Not zero</span>
<span class="line-removed">1484  * terminated; if it is, trailing zero will NOT be maintained.</span>
<span class="line-removed">1485  * @param variantsLen length of variants</span>
<span class="line-removed">1486  * @param toDelete variant to delete, without separators, e.g.  &quot;EURO&quot;</span>
<span class="line-removed">1487  * or &quot;PREEURO&quot;; not zero terminated</span>
<span class="line-removed">1488  * @param toDeleteLen length of toDelete</span>
<span class="line-removed">1489  * @return number of characters deleted from variants</span>
<span class="line-removed">1490  */</span>
<span class="line-removed">1491 static int32_t</span>
<span class="line-removed">1492 _deleteVariant(char* variants, int32_t variantsLen,</span>
<span class="line-removed">1493                const char* toDelete, int32_t toDeleteLen)</span>
<span class="line-removed">1494 {</span>
<span class="line-removed">1495     int32_t delta = 0; /* number of chars deleted */</span>
<span class="line-removed">1496     for (;;) {</span>
<span class="line-removed">1497         UBool flag = FALSE;</span>
<span class="line-removed">1498         if (variantsLen &lt; toDeleteLen) {</span>
<span class="line-removed">1499             return delta;</span>
<span class="line-removed">1500         }</span>
<span class="line-removed">1501         if (uprv_strncmp(variants, toDelete, toDeleteLen) == 0 &amp;&amp;</span>
<span class="line-removed">1502             (variantsLen == toDeleteLen ||</span>
<span class="line-removed">1503              (flag=(variants[toDeleteLen] == &#39;_&#39;))))</span>
<span class="line-removed">1504         {</span>
<span class="line-removed">1505             int32_t d = toDeleteLen + (flag?1:0);</span>
<span class="line-removed">1506             variantsLen -= d;</span>
<span class="line-removed">1507             delta += d;</span>
<span class="line-removed">1508             if (variantsLen &gt; 0) {</span>
<span class="line-removed">1509                 uprv_memmove(variants, variants+d, variantsLen);</span>
<span class="line-removed">1510             }</span>
<span class="line-removed">1511         } else {</span>
<span class="line-removed">1512             char* p = _strnchr(variants, variantsLen, &#39;_&#39;);</span>
<span class="line-removed">1513             if (p == NULL) {</span>
<span class="line-removed">1514                 return delta;</span>
<span class="line-removed">1515             }</span>
<span class="line-removed">1516             ++p;</span>
<span class="line-removed">1517             variantsLen -= (int32_t)(p - variants);</span>
<span class="line-removed">1518             variants = p;</span>
<span class="line-removed">1519         }</span>
<span class="line-removed">1520     }</span>
<span class="line-removed">1521 }</span>
<span class="line-removed">1522 </span>
1523 /* Keyword enumeration */
1524 
1525 typedef struct UKeywordsContext {
1526     char* keywords;
1527     char* current;
1528 } UKeywordsContext;
1529 
1530 U_CDECL_BEGIN
1531 
1532 static void U_CALLCONV
1533 uloc_kw_closeKeywords(UEnumeration *enumerator) {
1534     uprv_free(((UKeywordsContext *)enumerator-&gt;context)-&gt;keywords);
1535     uprv_free(enumerator-&gt;context);
1536     uprv_free(enumerator);
1537 }
1538 
1539 static int32_t U_CALLCONV
1540 uloc_kw_countKeywords(UEnumeration *en, UErrorCode * /*status*/) {
1541     char *kw = ((UKeywordsContext *)en-&gt;context)-&gt;keywords;
1542     int32_t result = 0;
</pre>
<hr />
<pre>
1681 /**
1682  * Canonicalize the given localeID, to level 1 or to level 2,
1683  * depending on the options.  To specify level 1, pass in options=0.
1684  * To specify level 2, pass in options=_ULOC_CANONICALIZE.
1685  *
1686  * This is the code underlying uloc_getName and uloc_canonicalize.
1687  */
1688 static int32_t
1689 _canonicalize(const char* localeID,
1690               char* result,
1691               int32_t resultCapacity,
1692               uint32_t options,
1693               UErrorCode* err) {
1694     int32_t j, len, fieldCount=0, scriptSize=0, variantSize=0, nameCapacity;
1695     char localeBuffer[ULOC_FULLNAME_CAPACITY];
1696     char tempBuffer[ULOC_FULLNAME_CAPACITY];
1697     const char* origLocaleID;
1698     const char* tmpLocaleID;
1699     const char* keywordAssign = NULL;
1700     const char* separatorIndicator = NULL;
<span class="line-removed">1701     const char* addKeyword = NULL;</span>
<span class="line-removed">1702     const char* addValue = NULL;</span>
1703     char* name;
1704     char* variant = NULL; /* pointer into name, or NULL */
1705 
1706     if (U_FAILURE(*err)) {
1707         return 0;
1708     }
1709 
1710     if (_hasBCP47Extension(localeID)) {
1711         _ConvertBCP47(tmpLocaleID, localeID, tempBuffer, sizeof(tempBuffer), err);
1712     } else {
1713         if (localeID==NULL) {
1714            localeID=uloc_getDefault();
1715         }
1716         tmpLocaleID=localeID;
1717     }
1718 
1719     origLocaleID=tmpLocaleID;
1720 
1721     /* if we are doing a full canonicalization, then put results in
1722        localeBuffer, if necessary; otherwise send them to result. */
1723     if (/*OPTION_SET(options, _ULOC_CANONICALIZE) &amp;&amp;*/
1724         (result == NULL || resultCapacity &lt; (int32_t)sizeof(localeBuffer))) {
1725         name = localeBuffer;
1726         nameCapacity = (int32_t)sizeof(localeBuffer);
1727     } else {
1728         name = result;
1729         nameCapacity = resultCapacity;
1730     }
1731 
1732     /* get all pieces, one after another, and separate with &#39;_&#39; */
1733     len=ulocimp_getLanguage(tmpLocaleID, name, nameCapacity, &amp;tmpLocaleID);
1734 
1735     if(len == I_DEFAULT_LENGTH &amp;&amp; uprv_strncmp(origLocaleID, i_default, len) == 0) {
1736         const char *d = uloc_getDefault();
1737 
1738         len = (int32_t)uprv_strlen(d);
1739 
1740         if (name != NULL) {
<span class="line-modified">1741             uprv_strncpy(name, d, len);</span>
1742         }
1743     } else if(_isIDSeparator(*tmpLocaleID)) {
1744         const char *scriptID;
1745 
1746         ++fieldCount;
1747         if(len&lt;nameCapacity) {
1748             name[len]=&#39;_&#39;;
1749         }
1750         ++len;
1751 
1752         scriptSize=ulocimp_getScript(tmpLocaleID+1,
1753             (len&lt;nameCapacity ? name+len : NULL), nameCapacity-len, &amp;scriptID);
1754         if(scriptSize &gt; 0) {
1755             /* Found optional script */
1756             tmpLocaleID = scriptID;
1757             ++fieldCount;
1758             len+=scriptSize;
1759             if (_isIDSeparator(*tmpLocaleID)) {
1760                 /* If there is something else, then we add the _ */
1761                 if(len&lt;nameCapacity) {
</pre>
<hr />
<pre>
1847             if (fieldCount &lt; 2 || (fieldCount &lt; 3 &amp;&amp; scriptSize &gt; 0)) {
1848                 do {
1849                     if(len&lt;nameCapacity) {
1850                         name[len]=&#39;_&#39;;
1851                     }
1852                     ++len;
1853                     ++fieldCount;
1854                 } while(fieldCount&lt;2);
1855             }
1856             posixVariantSize = _getVariantEx(tmpLocaleID+1, &#39;@&#39;, name+len, nameCapacity-len,
1857                                              (UBool)(variantSize &gt; 0));
1858             if (posixVariantSize &gt; 0) {
1859                 if (variant == NULL) {
1860                     variant = name+len;
1861                 }
1862                 len += posixVariantSize;
1863                 variantSize += posixVariantSize;
1864             }
1865         }
1866 
<span class="line-removed">1867         /* Handle generic variants first */</span>
<span class="line-removed">1868         if (variant) {</span>
<span class="line-removed">1869             for (j=0; j&lt;UPRV_LENGTHOF(VARIANT_MAP); j++) {</span>
<span class="line-removed">1870                 const char* variantToCompare = VARIANT_MAP[j].variant;</span>
<span class="line-removed">1871                 int32_t n = (int32_t)uprv_strlen(variantToCompare);</span>
<span class="line-removed">1872                 int32_t variantLen = _deleteVariant(variant, uprv_min(variantSize, (nameCapacity-len)), variantToCompare, n);</span>
<span class="line-removed">1873                 len -= variantLen;</span>
<span class="line-removed">1874                 if (variantLen &gt; 0) {</span>
<span class="line-removed">1875                     if (len &gt; 0 &amp;&amp; name[len-1] == &#39;_&#39;) { /* delete trailing &#39;_&#39; */</span>
<span class="line-removed">1876                         --len;</span>
<span class="line-removed">1877                     }</span>
<span class="line-removed">1878                     addKeyword = VARIANT_MAP[j].keyword;</span>
<span class="line-removed">1879                     addValue = VARIANT_MAP[j].value;</span>
<span class="line-removed">1880                     break;</span>
<span class="line-removed">1881                 }</span>
<span class="line-removed">1882             }</span>
<span class="line-removed">1883             if (len &gt; 0 &amp;&amp; len &lt;= nameCapacity &amp;&amp; name[len-1] == &#39;_&#39;) { /* delete trailing &#39;_&#39; */</span>
<span class="line-removed">1884                 --len;</span>
<span class="line-removed">1885             }</span>
<span class="line-removed">1886         }</span>
<span class="line-removed">1887 </span>
1888         /* Look up the ID in the canonicalization map */
1889         for (j=0; j&lt;UPRV_LENGTHOF(CANONICALIZE_MAP); j++) {
1890             const char* id = CANONICALIZE_MAP[j].id;
1891             int32_t n = (int32_t)uprv_strlen(id);
1892             if (len == n &amp;&amp; uprv_strncmp(name, id, n) == 0) {
1893                 if (n == 0 &amp;&amp; tmpLocaleID != NULL) {
1894                     break; /* Don&#39;t remap &quot;&quot; if keywords present */
1895                 }
1896                 len = _copyCount(name, nameCapacity, CANONICALIZE_MAP[j].canonicalID);
<span class="line-removed">1897                 if (CANONICALIZE_MAP[j].keyword) {</span>
<span class="line-removed">1898                     addKeyword = CANONICALIZE_MAP[j].keyword;</span>
<span class="line-removed">1899                     addValue = CANONICALIZE_MAP[j].value;</span>
<span class="line-removed">1900                 }</span>
1901                 break;
1902             }
1903         }
1904     }
1905 
1906     if (!OPTION_SET(options, _ULOC_STRIP_KEYWORDS)) {
1907         if (tmpLocaleID!=NULL &amp;&amp; keywordAssign!=NULL &amp;&amp;
1908             (!separatorIndicator || separatorIndicator &gt; keywordAssign)) {
1909             if(len&lt;nameCapacity) {
1910                 name[len]=&#39;@&#39;;
1911             }
1912             ++len;
1913             ++fieldCount;
1914             len += _getKeywords(tmpLocaleID+1, &#39;@&#39;, (len&lt;nameCapacity ? name+len : NULL), nameCapacity-len,
<span class="line-modified">1915                                 NULL, 0, NULL, TRUE, addKeyword, addValue, err);</span>
<span class="line-removed">1916         } else if (addKeyword != NULL) {</span>
<span class="line-removed">1917             U_ASSERT(addValue != NULL &amp;&amp; len &lt; nameCapacity);</span>
<span class="line-removed">1918             /* inelegant but works -- later make _getKeywords do this? */</span>
<span class="line-removed">1919             len += _copyCount(name+len, nameCapacity-len, &quot;@&quot;);</span>
<span class="line-removed">1920             len += _copyCount(name+len, nameCapacity-len, addKeyword);</span>
<span class="line-removed">1921             len += _copyCount(name+len, nameCapacity-len, &quot;=&quot;);</span>
<span class="line-removed">1922             len += _copyCount(name+len, nameCapacity-len, addValue);</span>
1923         }
1924     }
1925 
1926     if (U_SUCCESS(*err) &amp;&amp; result != NULL &amp;&amp; name == localeBuffer) {
1927         uprv_strncpy(result, localeBuffer, (len &gt; resultCapacity) ? resultCapacity : len);
1928     }
1929 
1930     return u_terminateChars(result, resultCapacity, len, err);
1931 }
1932 
1933 /* ### ID parsing API **************************************************/
1934 
1935 U_CAPI int32_t  U_EXPORT2
1936 uloc_getParent(const char*    localeID,
1937                char* parent,
1938                int32_t parentCapacity,
1939                UErrorCode* err)
1940 {
1941     const char *lastUnderscore;
1942     int32_t i;
1943 
1944     if (U_FAILURE(*err))
1945         return 0;
1946 
1947     if (localeID == NULL)
1948         localeID = uloc_getDefault();
1949 
1950     lastUnderscore=uprv_strrchr(localeID, &#39;_&#39;);
1951     if(lastUnderscore!=NULL) {
1952         i=(int32_t)(lastUnderscore-localeID);
1953     } else {
1954         i=0;
1955     }
1956 
<span class="line-modified">1957     if(i&gt;0 &amp;&amp; parent != localeID) {</span>
<span class="line-modified">1958         uprv_memcpy(parent, localeID, uprv_min(i, parentCapacity));</span>






1959     }

1960     return u_terminateChars(parent, parentCapacity, i, err);
1961 }
1962 
1963 U_CAPI int32_t U_EXPORT2
1964 uloc_getLanguage(const char*    localeID,
1965          char* language,
1966          int32_t languageCapacity,
1967          UErrorCode* err)
1968 {
1969     /* uloc_getLanguage will return a 2 character iso-639 code if one exists. *CWB*/
1970     int32_t i=0;
1971 
1972     if (err==NULL || U_FAILURE(*err)) {
1973         return 0;
1974     }
1975 
1976     if(localeID==NULL) {
1977         localeID=uloc_getDefault();
1978     }
1979 
</pre>
<hr />
<pre>
2162         return &quot;&quot;;
2163     offset = _findIndex(COUNTRIES, cntry);
2164     if (offset &lt; 0)
2165         return &quot;&quot;;
2166 
2167     return COUNTRIES_3[offset];
2168 }
2169 
2170 U_CAPI uint32_t  U_EXPORT2
2171 uloc_getLCID(const char* localeID)
2172 {
2173     UErrorCode status = U_ZERO_ERROR;
2174     char       langID[ULOC_FULLNAME_CAPACITY];
2175     uint32_t   lcid = 0;
2176 
2177     /* Check for incomplete id. */
2178     if (!localeID || uprv_strlen(localeID) &lt; 2) {
2179         return 0;
2180     }
2181 
<span class="line-modified">2182     // Attempt platform lookup if available</span>
<span class="line-modified">2183     lcid = uprv_convertToLCIDPlatform(localeID);</span>
<span class="line-modified">2184     if (lcid &gt; 0)</span>
<span class="line-modified">2185     {</span>



2186         // Windows found an LCID, return that
2187         return lcid;
2188     }
2189 
2190     uloc_getLanguage(localeID, langID, sizeof(langID), &amp;status);
<span class="line-modified">2191     if (U_FAILURE(status)) {</span>
2192         return 0;
2193     }
2194 
2195     if (uprv_strchr(localeID, &#39;@&#39;)) {
2196         // uprv_convertToLCID does not support keywords other than collation.
2197         // Remove all keywords except collation.
2198         int32_t len;
2199         char collVal[ULOC_KEYWORDS_CAPACITY];
2200         char tmpLocaleID[ULOC_FULLNAME_CAPACITY];
2201 
2202         len = uloc_getKeywordValue(localeID, &quot;collation&quot;, collVal,
2203             UPRV_LENGTHOF(collVal) - 1, &amp;status);
2204 
2205         if (U_SUCCESS(status) &amp;&amp; len &gt; 0) {
2206             collVal[len] = 0;
2207 
2208             len = uloc_getBaseName(localeID, tmpLocaleID,
2209                 UPRV_LENGTHOF(tmpLocaleID) - 1, &amp;status);
2210 
2211             if (U_SUCCESS(status) &amp;&amp; len &gt; 0) {
</pre>
<hr />
<pre>
2395             }
2396             while(isspace(*t)) {
2397                 t++;
2398             }
2399             if(*t==&#39;=&#39;) {
2400                 t++;
2401             }
2402             while(isspace(*t)) {
2403                 t++;
2404             }
2405             items[n].q = (float)_uloc_strtod(t,NULL);
2406         } else {
2407             /* no semicolon - it&#39;s 1.0 */
2408             items[n].q = 1.0f;
2409             paramEnd = itemEnd;
2410         }
2411         items[n].dummy=0;
2412         /* eat spaces prior to semi */
2413         for(t=(paramEnd-1);(paramEnd&gt;s)&amp;&amp;isspace(*t);t--)
2414             ;
<span class="line-modified">2415         int32_t slen = ((t+1)-s);</span>
2416         if(slen &gt; ULOC_FULLNAME_CAPACITY) {
2417           *status = U_BUFFER_OVERFLOW_ERROR;
2418           return -1; // too big
2419         }
2420         uprv_strncpy(items[n].locale, s, slen);
2421         items[n].locale[slen]=0; // terminate
2422         int32_t clen = uloc_canonicalize(items[n].locale, tmp, UPRV_LENGTHOF(tmp)-1, status);
2423         if(U_FAILURE(*status)) return -1;
2424         if((clen!=slen) || (uprv_strncmp(items[n].locale, tmp, slen))) {
2425             // canonicalization had an effect- copy back
2426             uprv_strncpy(items[n].locale, tmp, clen);
2427             items[n].locale[clen] = 0; // terminate
2428         }
2429 #if defined(ULOC_DEBUG)
2430         /*fprintf(stderr,&quot;%d: s &lt;%s&gt; q &lt;%g&gt;\n&quot;, n, j[n].locale, j[n].q);*/
2431 #endif
2432         n++;
2433         s = itemEnd;
2434         while(*s==&#39;,&#39;) { /* eat duplicate commas */
2435             s++;
</pre>
</td>
<td>
<hr />
<pre>
 440     &quot;SVK&quot;, &quot;SLE&quot;, &quot;SMR&quot;, &quot;SEN&quot;, &quot;SOM&quot;, &quot;SUR&quot;, &quot;SSD&quot;, &quot;STP&quot;, &quot;SLV&quot;,
 441 /*  &quot;SX&quot;,  &quot;SY&quot;,  &quot;SZ&quot;,  &quot;TC&quot;,  &quot;TD&quot;,  &quot;TF&quot;,  &quot;TG&quot;,  &quot;TH&quot;,  &quot;TJ&quot;,     */
 442     &quot;SXM&quot;, &quot;SYR&quot;, &quot;SWZ&quot;, &quot;TCA&quot;, &quot;TCD&quot;, &quot;ATF&quot;, &quot;TGO&quot;, &quot;THA&quot;, &quot;TJK&quot;,
 443 /*  &quot;TK&quot;,  &quot;TL&quot;,  &quot;TM&quot;,  &quot;TN&quot;,  &quot;TO&quot;,  &quot;TR&quot;,  &quot;TT&quot;,  &quot;TV&quot;,     */
 444     &quot;TKL&quot;, &quot;TLS&quot;, &quot;TKM&quot;, &quot;TUN&quot;, &quot;TON&quot;, &quot;TUR&quot;, &quot;TTO&quot;, &quot;TUV&quot;,
 445 /*  &quot;TW&quot;,  &quot;TZ&quot;,  &quot;UA&quot;,  &quot;UG&quot;,  &quot;UM&quot;,  &quot;US&quot;,  &quot;UY&quot;,  &quot;UZ&quot;,     */
 446     &quot;TWN&quot;, &quot;TZA&quot;, &quot;UKR&quot;, &quot;UGA&quot;, &quot;UMI&quot;, &quot;USA&quot;, &quot;URY&quot;, &quot;UZB&quot;,
 447 /*  &quot;VA&quot;,  &quot;VC&quot;,  &quot;VE&quot;,  &quot;VG&quot;,  &quot;VI&quot;,  &quot;VN&quot;,  &quot;VU&quot;,  &quot;WF&quot;,     */
 448     &quot;VAT&quot;, &quot;VCT&quot;, &quot;VEN&quot;, &quot;VGB&quot;, &quot;VIR&quot;, &quot;VNM&quot;, &quot;VUT&quot;, &quot;WLF&quot;,
 449 /*  &quot;WS&quot;,  &quot;YE&quot;,  &quot;YT&quot;,  &quot;ZA&quot;,  &quot;ZM&quot;,  &quot;ZW&quot;,          */
 450     &quot;WSM&quot;, &quot;YEM&quot;, &quot;MYT&quot;, &quot;ZAF&quot;, &quot;ZMB&quot;, &quot;ZWE&quot;,
 451 NULL,
 452 /*  &quot;AN&quot;,  &quot;BU&quot;,  &quot;CS&quot;,  &quot;FX&quot;,  &quot;RO&quot;, &quot;SU&quot;,  &quot;TP&quot;,  &quot;YD&quot;,  &quot;YU&quot;,  &quot;ZR&quot; */
 453     &quot;ANT&quot;, &quot;BUR&quot;, &quot;SCG&quot;, &quot;FXX&quot;, &quot;ROM&quot;, &quot;SUN&quot;, &quot;TMP&quot;, &quot;YMD&quot;, &quot;YUG&quot;, &quot;ZAR&quot;,
 454 NULL
 455 };
 456 
 457 typedef struct CanonicalizationMap {
 458     const char *id;          /* input ID */
 459     const char *canonicalID; /* canonicalized output ID */


 460 } CanonicalizationMap;
 461 
 462 /**
 463  * A map to canonicalize locale IDs.  This handles a variety of
 464  * different semantic kinds of transformations.
 465  */
 466 static const CanonicalizationMap CANONICALIZE_MAP[] = {
<span class="line-modified"> 467     { &quot;art_LOJBAN&quot;,     &quot;jbo&quot; }, /* registered name */</span>
<span class="line-modified"> 468     { &quot;hy__AREVELA&quot;,    &quot;hy&quot; }, /* Registered IANA variant */</span>
<span class="line-modified"> 469     { &quot;hy__AREVMDA&quot;,    &quot;hyw&quot; }, /* Registered IANA variant */</span>
<span class="line-modified"> 470     { &quot;zh_GAN&quot;,         &quot;gan&quot; }, /* registered name */</span>
<span class="line-modified"> 471     { &quot;zh_GUOYU&quot;,       &quot;zh&quot; }, /* registered name */</span>
<span class="line-modified"> 472     { &quot;zh_HAKKA&quot;,       &quot;hak&quot; }, /* registered name */</span>
<span class="line-modified"> 473     { &quot;zh_MIN_NAN&quot;,     &quot;nan&quot; }, /* registered name */</span>
<span class="line-modified"> 474     { &quot;zh_WUU&quot;,         &quot;wuu&quot; }, /* registered name */</span>
<span class="line-modified"> 475     { &quot;zh_XIANG&quot;,       &quot;hsn&quot; }, /* registered name */</span>
<span class="line-modified"> 476     { &quot;zh_YUE&quot;,         &quot;yue&quot; }, /* registered name */</span>
















































 477 };
 478 
 479 /* ### BCP47 Conversion *******************************************/
 480 /* Test if the locale id has BCP47 u extension and does not have &#39;@&#39; */
 481 #define _hasBCP47Extension(id) (id &amp;&amp; uprv_strstr(id, &quot;@&quot;) == NULL &amp;&amp; getShortestSubtagLength(localeID) == 1)
 482 /* Converts the BCP47 id to Unicode id. Does nothing to id if conversion fails */
 483 #define _ConvertBCP47(finalID, id, buffer, length,err) \
 484         if (uloc_forLanguageTag(id, buffer, length, NULL, err) &lt;= 0 ||  \
 485                 U_FAILURE(*err) || *err == U_STRING_NOT_TERMINATED_WARNING) { \
 486             finalID=id; \
 487             if (*err == U_STRING_NOT_TERMINATED_WARNING) { *err = U_BUFFER_OVERFLOW_ERROR; } \
 488         } else { \
 489             finalID=buffer; \
 490         }
 491 /* Gets the size of the shortest subtag in the given localeID. */
 492 static int32_t getShortestSubtagLength(const char *localeID) {
 493     int32_t localeIDLength = static_cast&lt;int32_t&gt;(uprv_strlen(localeID));
 494     int32_t length = localeIDLength;
 495     int32_t tmpLength = 0;
 496     int32_t i;
</pre>
<hr />
<pre>
 576   }
 577   buf[keywordNameLen] = 0; /* terminate */
 578 
 579   return keywordNameLen;
 580 }
 581 
 582 typedef struct {
 583     char keyword[ULOC_KEYWORD_BUFFER_LEN];
 584     int32_t keywordLen;
 585     const char *valueStart;
 586     int32_t valueLen;
 587 } KeywordStruct;
 588 
 589 static int32_t U_CALLCONV
 590 compareKeywordStructs(const void * /*context*/, const void *left, const void *right) {
 591     const char* leftString = ((const KeywordStruct *)left)-&gt;keyword;
 592     const char* rightString = ((const KeywordStruct *)right)-&gt;keyword;
 593     return uprv_strcmp(leftString, rightString);
 594 }
 595 






 596 static int32_t
 597 _getKeywords(const char *localeID,
 598              char prev,
 599              char *keywords, int32_t keywordCapacity,
 600              char *values, int32_t valuesCapacity, int32_t *valLen,
 601              UBool valuesToo,


 602              UErrorCode *status)
 603 {
 604     KeywordStruct keywordList[ULOC_MAX_NO_KEYWORDS];
 605 
 606     int32_t maxKeywords = ULOC_MAX_NO_KEYWORDS;
 607     int32_t numKeywords = 0;
 608     const char* pos = localeID;
 609     const char* equalSign = NULL;
 610     const char* semicolon = NULL;
 611     int32_t i = 0, j, n;
 612     int32_t keywordsLen = 0;
 613     int32_t valuesLen = 0;
 614 
 615     if(prev == &#39;@&#39;) { /* start of keyword definition */
 616         /* we will grab pairs, trim spaces, lowercase keywords, sort and return */
 617         do {
 618             UBool duplicate = FALSE;
 619             /* skip leading spaces */
 620             while(*pos == &#39; &#39;) {
 621                 pos++;
</pre>
<hr />
<pre>
 680                 pos++;
 681             } else {
 682                 i = (int32_t)uprv_strlen(equalSign);
 683                 while(i &amp;&amp; equalSign[i-1] == &#39; &#39;) {
 684                     i--;
 685                 }
 686                 keywordList[numKeywords].valueLen = i;
 687             }
 688             /* If this is a duplicate keyword, then ignore it */
 689             for (j=0; j&lt;numKeywords; ++j) {
 690                 if (uprv_strcmp(keywordList[j].keyword, keywordList[numKeywords].keyword) == 0) {
 691                     duplicate = TRUE;
 692                     break;
 693                 }
 694             }
 695             if (!duplicate) {
 696                 ++numKeywords;
 697             }
 698         } while(pos);
 699 



























 700         /* now we have a list of keywords */
 701         /* we need to sort it */
 702         uprv_sortArray(keywordList, numKeywords, sizeof(KeywordStruct), compareKeywordStructs, NULL, FALSE, status);
 703 
 704         /* Now construct the keyword part */
 705         for(i = 0; i &lt; numKeywords; i++) {
 706             if(keywordsLen + keywordList[i].keywordLen + 1&lt; keywordCapacity) {
 707                 uprv_strcpy(keywords+keywordsLen, keywordList[i].keyword);
 708                 if(valuesToo) {
 709                     keywords[keywordsLen + keywordList[i].keywordLen] = &#39;=&#39;;
 710                 } else {
 711                     keywords[keywordsLen + keywordList[i].keywordLen] = 0;
 712                 }
 713             }
 714             keywordsLen += keywordList[i].keywordLen + 1;
 715             if(valuesToo) {
<span class="line-modified"> 716                 if(keywordsLen + keywordList[i].valueLen &lt;= keywordCapacity) {</span>
 717                     uprv_strncpy(keywords+keywordsLen, keywordList[i].valueStart, keywordList[i].valueLen);
 718                 }
 719                 keywordsLen += keywordList[i].valueLen;
 720 
 721                 if(i &lt; numKeywords - 1) {
 722                     if(keywordsLen &lt; keywordCapacity) {
 723                         keywords[keywordsLen] = &#39;;&#39;;
 724                     }
 725                     keywordsLen++;
 726                 }
 727             }
 728             if(values) {
 729                 if(valuesLen + keywordList[i].valueLen + 1&lt; valuesCapacity) {
 730                     uprv_strcpy(values+valuesLen, keywordList[i].valueStart);
 731                     values[valuesLen + keywordList[i].valueLen] = 0;
 732                 }
 733                 valuesLen += keywordList[i].valueLen + 1;
 734             }
 735         }
 736         if(values) {
 737             values[valuesLen] = 0;
 738             if(valLen) {
 739                 *valLen = valuesLen;
 740             }
 741         }
 742         return u_terminateChars(keywords, keywordCapacity, keywordsLen, status);
 743     } else {
 744         return 0;
 745     }
 746 }
 747 
 748 U_CFUNC int32_t
 749 locale_getKeywords(const char *localeID,
 750                    char prev,
 751                    char *keywords, int32_t keywordCapacity,
 752                    char *values, int32_t valuesCapacity, int32_t *valLen,
 753                    UBool valuesToo,
 754                    UErrorCode *status) {
 755     return _getKeywords(localeID, prev, keywords, keywordCapacity,
 756                         values, valuesCapacity, valLen, valuesToo,
<span class="line-modified"> 757                         status);</span>
 758 }
 759 
 760 U_CAPI int32_t U_EXPORT2
 761 uloc_getKeywordValue(const char* localeID,
 762                      const char* keywordName,
 763                      char* buffer, int32_t bufferCapacity,
 764                      UErrorCode* status)
 765 {
 766     const char* startSearchHere = NULL;
 767     const char* nextSeparator = NULL;
 768     char keywordNameBuffer[ULOC_KEYWORD_BUFFER_LEN];
 769     char localeKeywordNameBuffer[ULOC_KEYWORD_BUFFER_LEN];
 770     int32_t result = 0;
 771 
 772     if(status &amp;&amp; U_SUCCESS(*status) &amp;&amp; localeID) {
 773       char tempBuffer[ULOC_FULLNAME_CAPACITY];
 774       const char* tmpLocaleID;
 775 
 776       if (keywordName == NULL || keywordName[0] == 0) {
 777         *status = U_ILLEGAL_ARGUMENT_ERROR;
</pre>
<hr />
<pre>
1031                 updatedKeysAndValues.append(&#39;=&#39;, *status);
1032                 updatedKeysAndValues.append(keywordValueBuffer, keywordValueLen, *status);
1033             } /* else removing this entry, don&#39;t emit anything */
1034             handledInputKeyAndValue = TRUE;
1035         } else {
1036            /* input keyword sorts earlier than current entry, add before current entry */
1037             if (rc &lt; 0 &amp;&amp; keywordValueLen &gt; 0 &amp;&amp; !handledInputKeyAndValue) {
1038                 /* insert new entry at this location */
1039                 updatedKeysAndValues.append(keyValuePrefix, *status);
1040                 keyValuePrefix = &#39;;&#39;; /* for any subsequent key-value pair */
1041                 updatedKeysAndValues.append(keywordNameBuffer, keywordNameLen, *status);
1042                 updatedKeysAndValues.append(&#39;=&#39;, *status);
1043                 updatedKeysAndValues.append(keywordValueBuffer, keywordValueLen, *status);
1044                 handledInputKeyAndValue = TRUE;
1045             }
1046             /* copy the current entry */
1047             updatedKeysAndValues.append(keyValuePrefix, *status);
1048             keyValuePrefix = &#39;;&#39;; /* for any subsequent key-value pair */
1049             updatedKeysAndValues.append(localeKeywordNameBuffer, keyValueLen, *status);
1050             updatedKeysAndValues.append(&#39;=&#39;, *status);
<span class="line-modified">1051             updatedKeysAndValues.append(nextEqualsign, static_cast&lt;int32_t&gt;(keyValueTail-nextEqualsign), *status);</span>
1052         }
1053         if (!nextSeparator &amp;&amp; keywordValueLen &gt; 0 &amp;&amp; !handledInputKeyAndValue) {
1054             /* append new entry at the end, it sorts later than existing entries */
1055             updatedKeysAndValues.append(keyValuePrefix, *status);
1056             /* skip keyValuePrefix update, no subsequent key-value pair */
1057             updatedKeysAndValues.append(keywordNameBuffer, keywordNameLen, *status);
1058             updatedKeysAndValues.append(&#39;=&#39;, *status);
1059             updatedKeysAndValues.append(keywordValueBuffer, keywordValueLen, *status);
1060             handledInputKeyAndValue = TRUE;
1061         }
1062         keywordStart = nextSeparator;
1063     } /* end loop searching */
1064 
1065     /* Any error from updatedKeysAndValues.append above would be internal and not due to
1066      * problems with the passed-in locale. So if we did encounter problems with the
1067      * passed-in locale above, those errors took precedence and overrode any error
1068      * status from updatedKeysAndValues.append, and also caused a return of 0. If there
1069      * are errors here they are from updatedKeysAndValues.append; they do cause an
1070      * error return but the passed-in locale is unmodified and the original bufLen is
1071      * returned.
</pre>
<hr />
<pre>
1086     if (updatedKeysAndValuesLen &gt; 0) {
1087         uprv_strncpy(startSearchHere, updatedKeysAndValues.data(), updatedKeysAndValuesLen);
1088     }
1089     buffer[needLen]=0;
1090     return needLen;
1091 }
1092 
1093 /* ### ID parsing implementation **************************************************/
1094 
1095 #define _isPrefixLetter(a) ((a==&#39;x&#39;)||(a==&#39;X&#39;)||(a==&#39;i&#39;)||(a==&#39;I&#39;))
1096 
1097 /*returns TRUE if one of the special prefixes is here (s=string)
1098   &#39;x-&#39; or &#39;i-&#39; */
1099 #define _isIDPrefix(s) (_isPrefixLetter(s[0])&amp;&amp;_isIDSeparator(s[1]))
1100 
1101 /* Dot terminates it because of POSIX form  where dot precedes the codepage
1102  * except for variant
1103  */
1104 #define _isTerminator(a)  ((a==0)||(a==&#39;.&#39;)||(a==&#39;@&#39;))
1105 














1106 /**
1107  * Lookup &#39;key&#39; in the array &#39;list&#39;.  The array &#39;list&#39; should contain
1108  * a NULL entry, followed by more entries, and a second NULL entry.
1109  *
1110  * The &#39;list&#39; param should be LANGUAGES, LANGUAGES_3, COUNTRIES, or
1111  * COUNTRIES_3.
1112  */
1113 static int16_t _findIndex(const char* const* list, const char* key)
1114 {
1115     const char* const* anchor = list;
1116     int32_t pass = 0;
1117 
1118     /* Make two passes through two NULL-terminated arrays at &#39;list&#39; */
1119     while (pass++ &lt; 2) {
1120         while (*list) {
1121             if (uprv_strcmp(key, *list) == 0) {
1122                 return (int16_t)(list - anchor);
1123             }
1124             list++;
1125         }
</pre>
<hr />
<pre>
1163         return REPLACEMENT_LANGUAGES[offset];
1164     }
1165     return oldID;
1166 }
1167 /*
1168  * the internal functions _getLanguage(), _getCountry(), _getVariant()
1169  * avoid duplicating code to handle the earlier locale ID pieces
1170  * in the functions for the later ones by
1171  * setting the *pEnd pointer to where they stopped parsing
1172  *
1173  * TODO try to use this in Locale
1174  */
1175 U_CFUNC int32_t
1176 ulocimp_getLanguage(const char *localeID,
1177                     char *language, int32_t languageCapacity,
1178                     const char **pEnd) {
1179     int32_t i=0;
1180     int32_t offset;
1181     char lang[4]={ 0, 0, 0, 0 }; /* temporary buffer to hold language code for searching */
1182 
<span class="line-added">1183     if (uprv_stricmp(localeID, &quot;root&quot;) == 0) {</span>
<span class="line-added">1184         localeID += 4;</span>
<span class="line-added">1185     } else if (uprv_strnicmp(localeID, &quot;und&quot;, 3) == 0 &amp;&amp;</span>
<span class="line-added">1186                (localeID[3] == &#39;\0&#39; ||</span>
<span class="line-added">1187                 localeID[3] == &#39;-&#39; ||</span>
<span class="line-added">1188                 localeID[3] == &#39;_&#39; ||</span>
<span class="line-added">1189                 localeID[3] == &#39;@&#39;)) {</span>
<span class="line-added">1190         localeID += 3;</span>
<span class="line-added">1191     }</span>
<span class="line-added">1192 </span>
1193     /* if it starts with i- or x- then copy that prefix */
1194     if(_isIDPrefix(localeID)) {
1195         if(i&lt;languageCapacity) {
1196             language[i]=(char)uprv_tolower(*localeID);
1197         }
1198         if(i&lt;languageCapacity) {
1199             language[i+1]=&#39;-&#39;;
1200         }
1201         i+=2;
1202         localeID+=2;
1203     }
1204 
1205     /* copy the language as far as possible and count its length */
1206     while(!_isTerminator(*localeID) &amp;&amp; !_isIDSeparator(*localeID)) {
1207         if(i&lt;languageCapacity) {
1208             language[i]=(char)uprv_tolower(*localeID);
1209         }
1210         if(i&lt;3) {
1211             U_ASSERT(i&gt;=0);
1212             lang[i]=(char)uprv_tolower(*localeID);
</pre>
<hr />
<pre>
1370                 variant[i]=(char)uprv_toupper(*localeID);
1371                 if(variant[i]==&#39;-&#39; || variant[i]==&#39;,&#39;) {
1372                     variant[i]=&#39;_&#39;;
1373                 }
1374             }
1375             i++;
1376             localeID++;
1377         }
1378     }
1379 
1380     return i;
1381 }
1382 
1383 static int32_t
1384 _getVariant(const char *localeID,
1385             char prev,
1386             char *variant, int32_t variantCapacity) {
1387     return _getVariantEx(localeID, prev, variant, variantCapacity, FALSE);
1388 }
1389 












































1390 /* Keyword enumeration */
1391 
1392 typedef struct UKeywordsContext {
1393     char* keywords;
1394     char* current;
1395 } UKeywordsContext;
1396 
1397 U_CDECL_BEGIN
1398 
1399 static void U_CALLCONV
1400 uloc_kw_closeKeywords(UEnumeration *enumerator) {
1401     uprv_free(((UKeywordsContext *)enumerator-&gt;context)-&gt;keywords);
1402     uprv_free(enumerator-&gt;context);
1403     uprv_free(enumerator);
1404 }
1405 
1406 static int32_t U_CALLCONV
1407 uloc_kw_countKeywords(UEnumeration *en, UErrorCode * /*status*/) {
1408     char *kw = ((UKeywordsContext *)en-&gt;context)-&gt;keywords;
1409     int32_t result = 0;
</pre>
<hr />
<pre>
1548 /**
1549  * Canonicalize the given localeID, to level 1 or to level 2,
1550  * depending on the options.  To specify level 1, pass in options=0.
1551  * To specify level 2, pass in options=_ULOC_CANONICALIZE.
1552  *
1553  * This is the code underlying uloc_getName and uloc_canonicalize.
1554  */
1555 static int32_t
1556 _canonicalize(const char* localeID,
1557               char* result,
1558               int32_t resultCapacity,
1559               uint32_t options,
1560               UErrorCode* err) {
1561     int32_t j, len, fieldCount=0, scriptSize=0, variantSize=0, nameCapacity;
1562     char localeBuffer[ULOC_FULLNAME_CAPACITY];
1563     char tempBuffer[ULOC_FULLNAME_CAPACITY];
1564     const char* origLocaleID;
1565     const char* tmpLocaleID;
1566     const char* keywordAssign = NULL;
1567     const char* separatorIndicator = NULL;


1568     char* name;
1569     char* variant = NULL; /* pointer into name, or NULL */
1570 
1571     if (U_FAILURE(*err)) {
1572         return 0;
1573     }
1574 
1575     if (_hasBCP47Extension(localeID)) {
1576         _ConvertBCP47(tmpLocaleID, localeID, tempBuffer, sizeof(tempBuffer), err);
1577     } else {
1578         if (localeID==NULL) {
1579            localeID=uloc_getDefault();
1580         }
1581         tmpLocaleID=localeID;
1582     }
1583 
1584     origLocaleID=tmpLocaleID;
1585 
1586     /* if we are doing a full canonicalization, then put results in
1587        localeBuffer, if necessary; otherwise send them to result. */
1588     if (/*OPTION_SET(options, _ULOC_CANONICALIZE) &amp;&amp;*/
1589         (result == NULL || resultCapacity &lt; (int32_t)sizeof(localeBuffer))) {
1590         name = localeBuffer;
1591         nameCapacity = (int32_t)sizeof(localeBuffer);
1592     } else {
1593         name = result;
1594         nameCapacity = resultCapacity;
1595     }
1596 
1597     /* get all pieces, one after another, and separate with &#39;_&#39; */
1598     len=ulocimp_getLanguage(tmpLocaleID, name, nameCapacity, &amp;tmpLocaleID);
1599 
1600     if(len == I_DEFAULT_LENGTH &amp;&amp; uprv_strncmp(origLocaleID, i_default, len) == 0) {
1601         const char *d = uloc_getDefault();
1602 
1603         len = (int32_t)uprv_strlen(d);
1604 
1605         if (name != NULL) {
<span class="line-modified">1606             uprv_memcpy(name, d, len);</span>
1607         }
1608     } else if(_isIDSeparator(*tmpLocaleID)) {
1609         const char *scriptID;
1610 
1611         ++fieldCount;
1612         if(len&lt;nameCapacity) {
1613             name[len]=&#39;_&#39;;
1614         }
1615         ++len;
1616 
1617         scriptSize=ulocimp_getScript(tmpLocaleID+1,
1618             (len&lt;nameCapacity ? name+len : NULL), nameCapacity-len, &amp;scriptID);
1619         if(scriptSize &gt; 0) {
1620             /* Found optional script */
1621             tmpLocaleID = scriptID;
1622             ++fieldCount;
1623             len+=scriptSize;
1624             if (_isIDSeparator(*tmpLocaleID)) {
1625                 /* If there is something else, then we add the _ */
1626                 if(len&lt;nameCapacity) {
</pre>
<hr />
<pre>
1712             if (fieldCount &lt; 2 || (fieldCount &lt; 3 &amp;&amp; scriptSize &gt; 0)) {
1713                 do {
1714                     if(len&lt;nameCapacity) {
1715                         name[len]=&#39;_&#39;;
1716                     }
1717                     ++len;
1718                     ++fieldCount;
1719                 } while(fieldCount&lt;2);
1720             }
1721             posixVariantSize = _getVariantEx(tmpLocaleID+1, &#39;@&#39;, name+len, nameCapacity-len,
1722                                              (UBool)(variantSize &gt; 0));
1723             if (posixVariantSize &gt; 0) {
1724                 if (variant == NULL) {
1725                     variant = name+len;
1726                 }
1727                 len += posixVariantSize;
1728                 variantSize += posixVariantSize;
1729             }
1730         }
1731 





















1732         /* Look up the ID in the canonicalization map */
1733         for (j=0; j&lt;UPRV_LENGTHOF(CANONICALIZE_MAP); j++) {
1734             const char* id = CANONICALIZE_MAP[j].id;
1735             int32_t n = (int32_t)uprv_strlen(id);
1736             if (len == n &amp;&amp; uprv_strncmp(name, id, n) == 0) {
1737                 if (n == 0 &amp;&amp; tmpLocaleID != NULL) {
1738                     break; /* Don&#39;t remap &quot;&quot; if keywords present */
1739                 }
1740                 len = _copyCount(name, nameCapacity, CANONICALIZE_MAP[j].canonicalID);




1741                 break;
1742             }
1743         }
1744     }
1745 
1746     if (!OPTION_SET(options, _ULOC_STRIP_KEYWORDS)) {
1747         if (tmpLocaleID!=NULL &amp;&amp; keywordAssign!=NULL &amp;&amp;
1748             (!separatorIndicator || separatorIndicator &gt; keywordAssign)) {
1749             if(len&lt;nameCapacity) {
1750                 name[len]=&#39;@&#39;;
1751             }
1752             ++len;
1753             ++fieldCount;
1754             len += _getKeywords(tmpLocaleID+1, &#39;@&#39;, (len&lt;nameCapacity ? name+len : NULL), nameCapacity-len,
<span class="line-modified">1755                                 NULL, 0, NULL, TRUE, err);</span>







1756         }
1757     }
1758 
1759     if (U_SUCCESS(*err) &amp;&amp; result != NULL &amp;&amp; name == localeBuffer) {
1760         uprv_strncpy(result, localeBuffer, (len &gt; resultCapacity) ? resultCapacity : len);
1761     }
1762 
1763     return u_terminateChars(result, resultCapacity, len, err);
1764 }
1765 
1766 /* ### ID parsing API **************************************************/
1767 
1768 U_CAPI int32_t  U_EXPORT2
1769 uloc_getParent(const char*    localeID,
1770                char* parent,
1771                int32_t parentCapacity,
1772                UErrorCode* err)
1773 {
1774     const char *lastUnderscore;
1775     int32_t i;
1776 
1777     if (U_FAILURE(*err))
1778         return 0;
1779 
1780     if (localeID == NULL)
1781         localeID = uloc_getDefault();
1782 
1783     lastUnderscore=uprv_strrchr(localeID, &#39;_&#39;);
1784     if(lastUnderscore!=NULL) {
1785         i=(int32_t)(lastUnderscore-localeID);
1786     } else {
1787         i=0;
1788     }
1789 
<span class="line-modified">1790     if (i &gt; 0) {</span>
<span class="line-modified">1791         if (uprv_strnicmp(localeID, &quot;und_&quot;, 4) == 0) {</span>
<span class="line-added">1792             localeID += 3;</span>
<span class="line-added">1793             i -= 3;</span>
<span class="line-added">1794             uprv_memmove(parent, localeID, uprv_min(i, parentCapacity));</span>
<span class="line-added">1795         } else if (parent != localeID) {</span>
<span class="line-added">1796             uprv_memcpy(parent, localeID, uprv_min(i, parentCapacity));</span>
<span class="line-added">1797         }</span>
1798     }
<span class="line-added">1799 </span>
1800     return u_terminateChars(parent, parentCapacity, i, err);
1801 }
1802 
1803 U_CAPI int32_t U_EXPORT2
1804 uloc_getLanguage(const char*    localeID,
1805          char* language,
1806          int32_t languageCapacity,
1807          UErrorCode* err)
1808 {
1809     /* uloc_getLanguage will return a 2 character iso-639 code if one exists. *CWB*/
1810     int32_t i=0;
1811 
1812     if (err==NULL || U_FAILURE(*err)) {
1813         return 0;
1814     }
1815 
1816     if(localeID==NULL) {
1817         localeID=uloc_getDefault();
1818     }
1819 
</pre>
<hr />
<pre>
2002         return &quot;&quot;;
2003     offset = _findIndex(COUNTRIES, cntry);
2004     if (offset &lt; 0)
2005         return &quot;&quot;;
2006 
2007     return COUNTRIES_3[offset];
2008 }
2009 
2010 U_CAPI uint32_t  U_EXPORT2
2011 uloc_getLCID(const char* localeID)
2012 {
2013     UErrorCode status = U_ZERO_ERROR;
2014     char       langID[ULOC_FULLNAME_CAPACITY];
2015     uint32_t   lcid = 0;
2016 
2017     /* Check for incomplete id. */
2018     if (!localeID || uprv_strlen(localeID) &lt; 2) {
2019         return 0;
2020     }
2021 
<span class="line-modified">2022     // First, attempt Windows platform lookup if available, but fall</span>
<span class="line-modified">2023     // through to catch any special cases (ICU vs Windows name differences).</span>
<span class="line-modified">2024     lcid = uprv_convertToLCIDPlatform(localeID, &amp;status);</span>
<span class="line-modified">2025     if (U_FAILURE(status)) {</span>
<span class="line-added">2026         return 0;</span>
<span class="line-added">2027     }</span>
<span class="line-added">2028     if (lcid &gt; 0) {</span>
2029         // Windows found an LCID, return that
2030         return lcid;
2031     }
2032 
2033     uloc_getLanguage(localeID, langID, sizeof(langID), &amp;status);
<span class="line-modified">2034     if (U_FAILURE(status) || status == U_STRING_NOT_TERMINATED_WARNING) {</span>
2035         return 0;
2036     }
2037 
2038     if (uprv_strchr(localeID, &#39;@&#39;)) {
2039         // uprv_convertToLCID does not support keywords other than collation.
2040         // Remove all keywords except collation.
2041         int32_t len;
2042         char collVal[ULOC_KEYWORDS_CAPACITY];
2043         char tmpLocaleID[ULOC_FULLNAME_CAPACITY];
2044 
2045         len = uloc_getKeywordValue(localeID, &quot;collation&quot;, collVal,
2046             UPRV_LENGTHOF(collVal) - 1, &amp;status);
2047 
2048         if (U_SUCCESS(status) &amp;&amp; len &gt; 0) {
2049             collVal[len] = 0;
2050 
2051             len = uloc_getBaseName(localeID, tmpLocaleID,
2052                 UPRV_LENGTHOF(tmpLocaleID) - 1, &amp;status);
2053 
2054             if (U_SUCCESS(status) &amp;&amp; len &gt; 0) {
</pre>
<hr />
<pre>
2238             }
2239             while(isspace(*t)) {
2240                 t++;
2241             }
2242             if(*t==&#39;=&#39;) {
2243                 t++;
2244             }
2245             while(isspace(*t)) {
2246                 t++;
2247             }
2248             items[n].q = (float)_uloc_strtod(t,NULL);
2249         } else {
2250             /* no semicolon - it&#39;s 1.0 */
2251             items[n].q = 1.0f;
2252             paramEnd = itemEnd;
2253         }
2254         items[n].dummy=0;
2255         /* eat spaces prior to semi */
2256         for(t=(paramEnd-1);(paramEnd&gt;s)&amp;&amp;isspace(*t);t--)
2257             ;
<span class="line-modified">2258         int32_t slen = static_cast&lt;int32_t&gt;(((t+1)-s));</span>
2259         if(slen &gt; ULOC_FULLNAME_CAPACITY) {
2260           *status = U_BUFFER_OVERFLOW_ERROR;
2261           return -1; // too big
2262         }
2263         uprv_strncpy(items[n].locale, s, slen);
2264         items[n].locale[slen]=0; // terminate
2265         int32_t clen = uloc_canonicalize(items[n].locale, tmp, UPRV_LENGTHOF(tmp)-1, status);
2266         if(U_FAILURE(*status)) return -1;
2267         if((clen!=slen) || (uprv_strncmp(items[n].locale, tmp, slen))) {
2268             // canonicalization had an effect- copy back
2269             uprv_strncpy(items[n].locale, tmp, clen);
2270             items[n].locale[clen] = 0; // terminate
2271         }
2272 #if defined(ULOC_DEBUG)
2273         /*fprintf(stderr,&quot;%d: s &lt;%s&gt; q &lt;%g&gt;\n&quot;, n, j[n].locale, j[n].q);*/
2274 #endif
2275         n++;
2276         s = itemEnd;
2277         while(*s==&#39;,&#39;) { /* eat duplicate commas */
2278             s++;
</pre>
</td>
</tr>
</table>
<center><a href="uinvchar.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uloc_keytype.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>