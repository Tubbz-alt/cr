<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/plurrule.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="plurfmt.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="plurrule_impl.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/plurrule.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,10 ***</span>
<span class="line-new-header">--- 33,11 ---</span>
  #include &quot;uassert.h&quot;
  #include &quot;uvectr32.h&quot;
  #include &quot;sharedpluralrules.h&quot;
  #include &quot;unifiedcache.h&quot;
  #include &quot;number_decimalquantity.h&quot;
<span class="line-added">+ #include &quot;util.h&quot;</span>
  
  #if !UCONFIG_NO_FORMATTING
  
  U_NAMESPACE_BEGIN
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,17 ***</span>
  UOBJECT_DEFINE_RTTI_IMPLEMENTATION(PluralRules)
  UOBJECT_DEFINE_RTTI_IMPLEMENTATION(PluralKeywordEnumeration)
  
  PluralRules::PluralRules(UErrorCode&amp; /*status*/)
  :   UObject(),
<span class="line-modified">!     mRules(NULL)</span>
  {
  }
  
  PluralRules::PluralRules(const PluralRules&amp; other)
  : UObject(other),
<span class="line-modified">!     mRules(NULL)</span>
  {
      *this=other;
  }
  
  PluralRules::~PluralRules() {
<span class="line-new-header">--- 64,19 ---</span>
  UOBJECT_DEFINE_RTTI_IMPLEMENTATION(PluralRules)
  UOBJECT_DEFINE_RTTI_IMPLEMENTATION(PluralKeywordEnumeration)
  
  PluralRules::PluralRules(UErrorCode&amp; /*status*/)
  :   UObject(),
<span class="line-modified">!     mRules(nullptr),</span>
<span class="line-added">+     mInternalStatus(U_ZERO_ERROR)</span>
  {
  }
  
  PluralRules::PluralRules(const PluralRules&amp; other)
  : UObject(other),
<span class="line-modified">!     mRules(nullptr),</span>
<span class="line-added">+     mInternalStatus(U_ZERO_ERROR)</span>
  {
      *this=other;
  }
  
  PluralRules::~PluralRules() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 84,58 ***</span>
      delete ptr;
  }
  
  PluralRules*
  PluralRules::clone() const {
<span class="line-modified">!     return new PluralRules(*this);</span>
  }
  
  PluralRules&amp;
  PluralRules::operator=(const PluralRules&amp; other) {
      if (this != &amp;other) {
          delete mRules;
<span class="line-modified">!         if (other.mRules==NULL) {</span>
<span class="line-modified">!             mRules = NULL;</span>
          }
<span class="line-modified">!         else {</span>
              mRules = new RuleChain(*other.mRules);
          }
      }
<span class="line-removed">- </span>
      return *this;
  }
  
  StringEnumeration* PluralRules::getAvailableLocales(UErrorCode &amp;status) {
<span class="line-modified">!     StringEnumeration *result = new PluralAvailableLocalesEnumeration(status);</span>
<span class="line-modified">!     if (result == NULL &amp;&amp; U_SUCCESS(status)) {</span>
<span class="line-removed">-         status = U_MEMORY_ALLOCATION_ERROR;</span>
      }
      if (U_FAILURE(status)) {
<span class="line-modified">!         delete result;</span>
<span class="line-removed">-         result = NULL;</span>
      }
<span class="line-modified">!     return result;</span>
  }
  
  
  PluralRules* U_EXPORT2
  PluralRules::createRules(const UnicodeString&amp; description, UErrorCode&amp; status) {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return NULL;</span>
      }
<span class="line-removed">- </span>
      PluralRuleParser parser;
<span class="line-modified">!     PluralRules *newRules = new PluralRules(status);</span>
<span class="line-modified">!     if (U_SUCCESS(status) &amp;&amp; newRules == NULL) {</span>
<span class="line-modified">!         status = U_MEMORY_ALLOCATION_ERROR;</span>
      }
<span class="line-modified">!     parser.parse(description, newRules, status);</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!         delete newRules;</span>
<span class="line-removed">-         newRules = NULL;</span>
      }
<span class="line-modified">!     return newRules;</span>
  }
  
  
  PluralRules* U_EXPORT2
  PluralRules::createDefaultRules(UErrorCode&amp; status) {
<span class="line-new-header">--- 87,71 ---</span>
      delete ptr;
  }
  
  PluralRules*
  PluralRules::clone() const {
<span class="line-modified">!     PluralRules* newObj = new PluralRules(*this);</span>
<span class="line-added">+     // Since clone doesn&#39;t have a &#39;status&#39; parameter, the best we can do is return nullptr if</span>
<span class="line-added">+     // the newly created object was not fully constructed properly (an error occurred).</span>
<span class="line-added">+     if (newObj != nullptr &amp;&amp; U_FAILURE(newObj-&gt;mInternalStatus)) {</span>
<span class="line-added">+         delete newObj;</span>
<span class="line-added">+         newObj = nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return newObj;</span>
  }
  
  PluralRules&amp;
  PluralRules::operator=(const PluralRules&amp; other) {
      if (this != &amp;other) {
          delete mRules;
<span class="line-modified">!         mRules = nullptr;</span>
<span class="line-modified">!         mInternalStatus = other.mInternalStatus;</span>
<span class="line-added">+         if (U_FAILURE(mInternalStatus)) {</span>
<span class="line-added">+             // bail out early if the object we were copying from was already &#39;invalid&#39;.</span>
<span class="line-added">+             return *this;</span>
          }
<span class="line-modified">!         if (other.mRules != nullptr) {</span>
              mRules = new RuleChain(*other.mRules);
<span class="line-added">+             if (mRules == nullptr) {</span>
<span class="line-added">+                 mInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             else if (U_FAILURE(mRules-&gt;fInternalStatus)) {</span>
<span class="line-added">+                 // If the RuleChain wasn&#39;t fully copied, then set our status to failure as well.</span>
<span class="line-added">+                 mInternalStatus = mRules-&gt;fInternalStatus;</span>
<span class="line-added">+             }</span>
          }
      }
      return *this;
  }
  
  StringEnumeration* PluralRules::getAvailableLocales(UErrorCode &amp;status) {
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
<span class="line-modified">!         return nullptr;</span>
      }
<span class="line-added">+     LocalPointer&lt;StringEnumeration&gt; result(new PluralAvailableLocalesEnumeration(status), status);</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
<span class="line-modified">!     return result.orphan();</span>
  }
  
  
  PluralRules* U_EXPORT2
  PluralRules::createRules(const UnicodeString&amp; description, UErrorCode&amp; status) {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
      PluralRuleParser parser;
<span class="line-modified">!     LocalPointer&lt;PluralRules&gt; newRules(new PluralRules(status), status);</span>
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
<span class="line-modified">!         return nullptr;</span>
      }
<span class="line-modified">!     parser.parse(description, newRules.getAlias(), status);</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!         newRules.adoptInstead(nullptr);</span>
      }
<span class="line-modified">!     return newRules.orphan();</span>
  }
  
  
  PluralRules* U_EXPORT2
  PluralRules::createDefaultRules(UErrorCode&amp; status) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 147,39 ***</span>
  
  template&lt;&gt; U_I18N_API
  const SharedPluralRules *LocaleCacheKey&lt;SharedPluralRules&gt;::createObject(
          const void * /*unused*/, UErrorCode &amp;status) const {
      const char *localeId = fLoc.getName();
<span class="line-modified">!     PluralRules *pr = PluralRules::internalForLocale(</span>
<span class="line-removed">-             localeId, UPLURAL_TYPE_CARDINAL, status);</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!         return NULL;</span>
      }
<span class="line-modified">!     SharedPluralRules *result = new SharedPluralRules(pr);</span>
<span class="line-modified">!     if (result == NULL) {</span>
<span class="line-modified">!         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">-         delete pr;</span>
<span class="line-removed">-         return NULL;</span>
      }
      result-&gt;addRef();
<span class="line-modified">!     return result;</span>
  }
  
  /* end plural rules cache */
  /******************************************************************************/
  
  const SharedPluralRules* U_EXPORT2
  PluralRules::createSharedInstance(
          const Locale&amp; locale, UPluralType type, UErrorCode&amp; status) {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return NULL;</span>
      }
      if (type != UPLURAL_TYPE_CARDINAL) {
          status = U_UNSUPPORTED_ERROR;
<span class="line-modified">!         return NULL;</span>
      }
<span class="line-modified">!     const SharedPluralRules *result = NULL;</span>
      UnifiedCache::getByLocale(locale, result, status);
      return result;
  }
  
  PluralRules* U_EXPORT2
<span class="line-new-header">--- 163,37 ---</span>
  
  template&lt;&gt; U_I18N_API
  const SharedPluralRules *LocaleCacheKey&lt;SharedPluralRules&gt;::createObject(
          const void * /*unused*/, UErrorCode &amp;status) const {
      const char *localeId = fLoc.getName();
<span class="line-modified">!     LocalPointer&lt;PluralRules&gt; pr(PluralRules::internalForLocale(localeId, UPLURAL_TYPE_CARDINAL, status), status);</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
<span class="line-modified">!     LocalPointer&lt;SharedPluralRules&gt; result(new SharedPluralRules(pr.getAlias()), status);</span>
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
<span class="line-modified">!         return nullptr;</span>
      }
<span class="line-added">+     pr.orphan(); // result was successfully created so it nows pr.</span>
      result-&gt;addRef();
<span class="line-modified">!     return result.orphan();</span>
  }
  
  /* end plural rules cache */
  /******************************************************************************/
  
  const SharedPluralRules* U_EXPORT2
  PluralRules::createSharedInstance(
          const Locale&amp; locale, UPluralType type, UErrorCode&amp; status) {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
      if (type != UPLURAL_TYPE_CARDINAL) {
          status = U_UNSUPPORTED_ERROR;
<span class="line-modified">!         return nullptr;</span>
      }
<span class="line-modified">!     const SharedPluralRules *result = nullptr;</span>
      UnifiedCache::getByLocale(locale, result, status);
      return result;
  }
  
  PluralRules* U_EXPORT2
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,51 ***</span>
          return internalForLocale(locale, type, status);
      }
      const SharedPluralRules *shared = createSharedInstance(
              locale, type, status);
      if (U_FAILURE(status)) {
<span class="line-modified">!         return NULL;</span>
      }
      PluralRules *result = (*shared)-&gt;clone();
      shared-&gt;removeRef();
<span class="line-modified">!     if (result == NULL) {</span>
          status = U_MEMORY_ALLOCATION_ERROR;
      }
      return result;
  }
  
  PluralRules* U_EXPORT2
  PluralRules::internalForLocale(const Locale&amp; locale, UPluralType type, UErrorCode&amp; status) {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return NULL;</span>
      }
      if (type &gt;= UPLURAL_TYPE_COUNT) {
          status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">!         return NULL;</span>
      }
<span class="line-modified">!     PluralRules *newObj = new PluralRules(status);</span>
<span class="line-modified">!     if (newObj==NULL || U_FAILURE(status)) {</span>
<span class="line-modified">!         delete newObj;</span>
<span class="line-removed">-         return NULL;</span>
      }
      UnicodeString locRule = newObj-&gt;getRuleFromResource(locale, type, status);
<span class="line-modified">!     // TODO: which errors, if any, should be returned?</span>
      if (locRule.length() == 0) {
          // Locales with no specific rules (all numbers have the &quot;other&quot; category
          //   will return a U_MISSING_RESOURCE_ERROR at this point. This is not
          //   an error.
          locRule =  UnicodeString(PLURAL_DEFAULT_RULE);
          status = U_ZERO_ERROR;
      }
      PluralRuleParser parser;
<span class="line-modified">!     parser.parse(locRule, newObj, status);</span>
          //  TODO: should rule parse errors be returned, or
          //        should we silently use default rules?
          //        Original impl used default rules.
          //        Ask the question to ICU Core.
  
<span class="line-modified">!     return newObj;</span>
  }
  
  UnicodeString
  PluralRules::select(int32_t number) const {
      return select(FixedDecimal(number));
<span class="line-new-header">--- 207,54 ---</span>
          return internalForLocale(locale, type, status);
      }
      const SharedPluralRules *shared = createSharedInstance(
              locale, type, status);
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
      PluralRules *result = (*shared)-&gt;clone();
      shared-&gt;removeRef();
<span class="line-modified">!     if (result == nullptr) {</span>
          status = U_MEMORY_ALLOCATION_ERROR;
      }
      return result;
  }
  
  PluralRules* U_EXPORT2
  PluralRules::internalForLocale(const Locale&amp; locale, UPluralType type, UErrorCode&amp; status) {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
      if (type &gt;= UPLURAL_TYPE_COUNT) {
          status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">!         return nullptr;</span>
      }
<span class="line-modified">!     LocalPointer&lt;PluralRules&gt; newObj(new PluralRules(status), status);</span>
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
<span class="line-modified">!         return nullptr;</span>
      }
      UnicodeString locRule = newObj-&gt;getRuleFromResource(locale, type, status);
<span class="line-modified">!     // TODO: which other errors, if any, should be returned?</span>
      if (locRule.length() == 0) {
<span class="line-added">+         // If an out-of-memory error occurred, then stop and report the failure.</span>
<span class="line-added">+         if (status == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added">+             return nullptr;</span>
<span class="line-added">+         }</span>
          // Locales with no specific rules (all numbers have the &quot;other&quot; category
          //   will return a U_MISSING_RESOURCE_ERROR at this point. This is not
          //   an error.
          locRule =  UnicodeString(PLURAL_DEFAULT_RULE);
          status = U_ZERO_ERROR;
      }
      PluralRuleParser parser;
<span class="line-modified">!     parser.parse(locRule, newObj.getAlias(), status);</span>
          //  TODO: should rule parse errors be returned, or
          //        should we silently use default rules?
          //        Original impl used default rules.
          //        Ask the question to ICU Core.
  
<span class="line-modified">!     return newObj.orphan();</span>
  }
  
  UnicodeString
  PluralRules::select(int32_t number) const {
      return select(FixedDecimal(number));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,13 ***</span>
  UnicodeString
  PluralRules::select(double number) const {
      return select(FixedDecimal(number));
  }
  
  UnicodeString
  PluralRules::select(const IFixedDecimal &amp;number) const {
<span class="line-modified">!     if (mRules == NULL) {</span>
          return UnicodeString(TRUE, PLURAL_DEFAULT_RULE, -1);
      }
      else {
          return mRules-&gt;select(number);
      }
<span class="line-new-header">--- 263,23 ---</span>
  UnicodeString
  PluralRules::select(double number) const {
      return select(FixedDecimal(number));
  }
  
<span class="line-added">+ UnicodeString</span>
<span class="line-added">+ PluralRules::select(const number::FormattedNumber&amp; number, UErrorCode&amp; status) const {</span>
<span class="line-added">+     DecimalQuantity dq;</span>
<span class="line-added">+     number.getDecimalQuantity(dq, status);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return ICU_Utility::makeBogusString();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return select(dq);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  UnicodeString
  PluralRules::select(const IFixedDecimal &amp;number) const {
<span class="line-modified">!     if (mRules == nullptr) {</span>
          return UnicodeString(TRUE, PLURAL_DEFAULT_RULE, -1);
      }
      else {
          return mRules-&gt;select(number);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 260,18 ***</span>
  
  
  
  StringEnumeration*
  PluralRules::getKeywords(UErrorCode&amp; status) const {
<span class="line-removed">-     if (U_FAILURE(status))  return NULL;</span>
<span class="line-removed">-     StringEnumeration* nameEnumerator = new PluralKeywordEnumeration(mRules, status);</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!       delete nameEnumerator;</span>
<span class="line-removed">-       return NULL;</span>
      }
<span class="line-modified">! </span>
<span class="line-modified">!     return nameEnumerator;</span>
  }
  
  double
  PluralRules::getUniqueKeywordValue(const UnicodeString&amp; /* keyword */) {
    // Not Implemented.
<span class="line-new-header">--- 287,22 ---</span>
  
  
  
  StringEnumeration*
  PluralRules::getKeywords(UErrorCode&amp; status) const {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
<span class="line-modified">!     if (U_FAILURE(mInternalStatus)) {</span>
<span class="line-modified">!         status = mInternalStatus;</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     LocalPointer&lt;StringEnumeration&gt; nameEnumerator(new PluralKeywordEnumeration(mRules, status), status);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return nameEnumerator.orphan();</span>
  }
  
  double
  PluralRules::getUniqueKeywordValue(const UnicodeString&amp; /* keyword */) {
    // Not Implemented.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 365,12 ***</span>
  
  
  int32_t
  PluralRules::getSamples(const UnicodeString &amp;keyword, double *dest,
                          int32_t destCapacity, UErrorCode&amp; status) {
      RuleChain *rc = rulesForKeyword(keyword);
<span class="line-modified">!     if (rc == NULL || destCapacity == 0 || U_FAILURE(status)) {</span>
          return 0;
      }
      int32_t numSamples = getSamplesFromString(rc-&gt;fIntegerSamples, dest, destCapacity, status);
      if (numSamples == 0) {
          numSamples = getSamplesFromString(rc-&gt;fDecimalSamples, dest, destCapacity, status);
<span class="line-new-header">--- 396,19 ---</span>
  
  
  int32_t
  PluralRules::getSamples(const UnicodeString &amp;keyword, double *dest,
                          int32_t destCapacity, UErrorCode&amp; status) {
<span class="line-added">+     if (destCapacity == 0 || U_FAILURE(status)) {</span>
<span class="line-added">+         return 0;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (U_FAILURE(mInternalStatus)) {</span>
<span class="line-added">+         status = mInternalStatus;</span>
<span class="line-added">+         return 0;</span>
<span class="line-added">+     }</span>
      RuleChain *rc = rulesForKeyword(keyword);
<span class="line-modified">!     if (rc == nullptr) {</span>
          return 0;
      }
      int32_t numSamples = getSamplesFromString(rc-&gt;fIntegerSamples, dest, destCapacity, status);
      if (numSamples == 0) {
          numSamples = getSamplesFromString(rc-&gt;fDecimalSamples, dest, destCapacity, status);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 379,11 ***</span>
  }
  
  
  RuleChain *PluralRules::rulesForKeyword(const UnicodeString &amp;keyword) const {
      RuleChain *rc;
<span class="line-modified">!     for (rc = mRules; rc != NULL; rc = rc-&gt;fNext) {</span>
          if (rc-&gt;fKeyword == keyword) {
              break;
          }
      }
      return rc;
<span class="line-new-header">--- 417,11 ---</span>
  }
  
  
  RuleChain *PluralRules::rulesForKeyword(const UnicodeString &amp;keyword) const {
      RuleChain *rc;
<span class="line-modified">!     for (rc = mRules; rc != nullptr; rc = rc-&gt;fNext) {</span>
          if (rc-&gt;fKeyword == keyword) {
              break;
          }
      }
      return rc;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 393,11 ***</span>
  UBool
  PluralRules::isKeyword(const UnicodeString&amp; keyword) const {
      if (0 == keyword.compare(PLURAL_KEYWORD_OTHER, 5)) {
          return true;
      }
<span class="line-modified">!     return rulesForKeyword(keyword) != NULL;</span>
  }
  
  UnicodeString
  PluralRules::getKeywordOther() const {
      return UnicodeString(TRUE, PLURAL_KEYWORD_OTHER, 5);
<span class="line-new-header">--- 431,11 ---</span>
  UBool
  PluralRules::isKeyword(const UnicodeString&amp; keyword) const {
      if (0 == keyword.compare(PLURAL_KEYWORD_OTHER, 5)) {
          return true;
      }
<span class="line-modified">!     return rulesForKeyword(keyword) != nullptr;</span>
  }
  
  UnicodeString
  PluralRules::getKeywordOther() const {
      return UnicodeString(TRUE, PLURAL_KEYWORD_OTHER, 5);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 419,17 ***</span>
  
      if (myKeywordList-&gt;count(status)!=otherKeywordList-&gt;count(status)) {
          return FALSE;
      }
      myKeywordList-&gt;reset(status);
<span class="line-modified">!     while ((ptrKeyword=myKeywordList-&gt;snext(status))!=NULL) {</span>
          if (!other.isKeyword(*ptrKeyword)) {
              return FALSE;
          }
      }
      otherKeywordList-&gt;reset(status);
<span class="line-modified">!     while ((ptrKeyword=otherKeywordList-&gt;snext(status))!=NULL) {</span>
          if (!this-&gt;isKeyword(*ptrKeyword)) {
              return FALSE;
          }
      }
      if (U_FAILURE(status)) {
<span class="line-new-header">--- 457,17 ---</span>
  
      if (myKeywordList-&gt;count(status)!=otherKeywordList-&gt;count(status)) {
          return FALSE;
      }
      myKeywordList-&gt;reset(status);
<span class="line-modified">!     while ((ptrKeyword=myKeywordList-&gt;snext(status))!=nullptr) {</span>
          if (!other.isKeyword(*ptrKeyword)) {
              return FALSE;
          }
      }
      otherKeywordList-&gt;reset(status);
<span class="line-modified">!     while ((ptrKeyword=otherKeywordList-&gt;snext(status))!=nullptr) {</span>
          if (!this-&gt;isKeyword(*ptrKeyword)) {
              return FALSE;
          }
      }
      if (U_FAILURE(status)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 458,59 ***</span>
          if (U_FAILURE(status)) {
              return;
          }
          switch (type) {
          case tAnd:
<span class="line-modified">!             U_ASSERT(curAndConstraint != NULL);</span>
<span class="line-modified">!             curAndConstraint = curAndConstraint-&gt;add();</span>
              break;
          case tOr:
              {
<span class="line-modified">!                 U_ASSERT(currentChain != NULL);</span>
                  OrConstraint *orNode=currentChain-&gt;ruleHeader;
<span class="line-modified">!                 while (orNode-&gt;next != NULL) {</span>
                      orNode = orNode-&gt;next;
                  }
                  orNode-&gt;next= new OrConstraint();
                  orNode=orNode-&gt;next;
<span class="line-modified">!                 orNode-&gt;next=NULL;</span>
<span class="line-modified">!                 curAndConstraint = orNode-&gt;add();</span>
              }
              break;
          case tIs:
<span class="line-modified">!             U_ASSERT(curAndConstraint != NULL);</span>
              U_ASSERT(curAndConstraint-&gt;value == -1);
<span class="line-modified">!             U_ASSERT(curAndConstraint-&gt;rangeList == NULL);</span>
              break;
          case tNot:
<span class="line-modified">!             U_ASSERT(curAndConstraint != NULL);</span>
              curAndConstraint-&gt;negated=TRUE;
              break;
  
          case tNotEqual:
              curAndConstraint-&gt;negated=TRUE;
              U_FALLTHROUGH;
          case tIn:
          case tWithin:
          case tEqual:
<span class="line-modified">!             U_ASSERT(curAndConstraint != NULL);</span>
<span class="line-modified">!             curAndConstraint-&gt;rangeList = new UVector32(status);</span>
<span class="line-modified">!             curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Low</span>
<span class="line-modified">!             curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Hi</span>
<span class="line-modified">!             rangeLowIdx = 0;</span>
<span class="line-modified">!             rangeHiIdx  = 1;</span>
<span class="line-modified">!             curAndConstraint-&gt;value=PLURAL_RANGE_HIGH;</span>
<span class="line-modified">!             curAndConstraint-&gt;integerOnly = (type != tWithin);</span>
              break;
          case tNumber:
<span class="line-modified">!             U_ASSERT(curAndConstraint != NULL);</span>
              if ( (curAndConstraint-&gt;op==AndConstraint::MOD)&amp;&amp;
                   (curAndConstraint-&gt;opNum == -1 ) ) {
                  curAndConstraint-&gt;opNum=getNumberValue(token);
              }
              else {
<span class="line-modified">!                 if (curAndConstraint-&gt;rangeList == NULL) {</span>
                      // this is for an &#39;is&#39; rule
                      curAndConstraint-&gt;value = getNumberValue(token);
                  } else {
                      // this is for an &#39;in&#39; or &#39;within&#39; rule
                      if (curAndConstraint-&gt;rangeList-&gt;elementAti(rangeLowIdx) == -1) {
<span class="line-new-header">--- 496,69 ---</span>
          if (U_FAILURE(status)) {
              return;
          }
          switch (type) {
          case tAnd:
<span class="line-modified">!             U_ASSERT(curAndConstraint != nullptr);</span>
<span class="line-modified">!             curAndConstraint = curAndConstraint-&gt;add(status);</span>
              break;
          case tOr:
              {
<span class="line-modified">!                 U_ASSERT(currentChain != nullptr);</span>
                  OrConstraint *orNode=currentChain-&gt;ruleHeader;
<span class="line-modified">!                 while (orNode-&gt;next != nullptr) {</span>
                      orNode = orNode-&gt;next;
                  }
                  orNode-&gt;next= new OrConstraint();
<span class="line-added">+                 if (orNode-&gt;next == nullptr) {</span>
<span class="line-added">+                     status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
                  orNode=orNode-&gt;next;
<span class="line-modified">!                 orNode-&gt;next=nullptr;</span>
<span class="line-modified">!                 curAndConstraint = orNode-&gt;add(status);</span>
              }
              break;
          case tIs:
<span class="line-modified">!             U_ASSERT(curAndConstraint != nullptr);</span>
              U_ASSERT(curAndConstraint-&gt;value == -1);
<span class="line-modified">!             U_ASSERT(curAndConstraint-&gt;rangeList == nullptr);</span>
              break;
          case tNot:
<span class="line-modified">!             U_ASSERT(curAndConstraint != nullptr);</span>
              curAndConstraint-&gt;negated=TRUE;
              break;
  
          case tNotEqual:
              curAndConstraint-&gt;negated=TRUE;
              U_FALLTHROUGH;
          case tIn:
          case tWithin:
          case tEqual:
<span class="line-modified">!             {</span>
<span class="line-modified">!                 U_ASSERT(curAndConstraint != nullptr);</span>
<span class="line-modified">!                 LocalPointer&lt;UVector32&gt; newRangeList(new UVector32(status), status);</span>
<span class="line-modified">!                 if (U_FAILURE(status)) {</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 curAndConstraint-&gt;rangeList = newRangeList.orphan();</span>
<span class="line-modified">!                 curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Low</span>
<span class="line-added">+                 curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Hi</span>
<span class="line-added">+                 rangeLowIdx = 0;</span>
<span class="line-added">+                 rangeHiIdx  = 1;</span>
<span class="line-added">+                 curAndConstraint-&gt;value=PLURAL_RANGE_HIGH;</span>
<span class="line-added">+                 curAndConstraint-&gt;integerOnly = (type != tWithin);</span>
<span class="line-added">+             }</span>
              break;
          case tNumber:
<span class="line-modified">!             U_ASSERT(curAndConstraint != nullptr);</span>
              if ( (curAndConstraint-&gt;op==AndConstraint::MOD)&amp;&amp;
                   (curAndConstraint-&gt;opNum == -1 ) ) {
                  curAndConstraint-&gt;opNum=getNumberValue(token);
              }
              else {
<span class="line-modified">!                 if (curAndConstraint-&gt;rangeList == nullptr) {</span>
                      // this is for an &#39;is&#39; rule
                      curAndConstraint-&gt;value = getNumberValue(token);
                  } else {
                      // this is for an &#39;in&#39; or &#39;within&#39; rule
                      if (curAndConstraint-&gt;rangeList-&gt;elementAti(rangeLowIdx) == -1) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 532,56 ***</span>
              }
              break;
          case tComma:
              // TODO: rule syntax checking is inadequate, can happen with badly formed rules.
              //       Catch cases like &quot;n mod 10, is 1&quot; here instead.
<span class="line-modified">!             if (curAndConstraint == NULL || curAndConstraint-&gt;rangeList == NULL) {</span>
                  status = U_UNEXPECTED_TOKEN;
                  break;
              }
              U_ASSERT(curAndConstraint-&gt;rangeList-&gt;size() &gt;= 2);
              rangeLowIdx = curAndConstraint-&gt;rangeList-&gt;size();
              curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Low
              rangeHiIdx = curAndConstraint-&gt;rangeList-&gt;size();
              curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Hi
              break;
          case tMod:
<span class="line-modified">!             U_ASSERT(curAndConstraint != NULL);</span>
              curAndConstraint-&gt;op=AndConstraint::MOD;
              break;
          case tVariableN:
          case tVariableI:
          case tVariableF:
          case tVariableT:
          case tVariableV:
<span class="line-modified">!             U_ASSERT(curAndConstraint != NULL);</span>
              curAndConstraint-&gt;digitsType = type;
              break;
          case tKeyword:
              {
              RuleChain *newChain = new RuleChain;
<span class="line-modified">!             if (newChain == NULL) {</span>
                  status = U_MEMORY_ALLOCATION_ERROR;
                  break;
              }
              newChain-&gt;fKeyword = token;
<span class="line-modified">!             if (prules-&gt;mRules == NULL) {</span>
                  prules-&gt;mRules = newChain;
              } else {
                  // The new rule chain goes at the end of the linked list of rule chains,
                  //   unless there is an &quot;other&quot; keyword &amp; chain. &quot;other&quot; must remain last.
                  RuleChain *insertAfter = prules-&gt;mRules;
<span class="line-modified">!                 while (insertAfter-&gt;fNext!=NULL &amp;&amp;</span>
                         insertAfter-&gt;fNext-&gt;fKeyword.compare(PLURAL_KEYWORD_OTHER, 5) != 0 ){
                      insertAfter=insertAfter-&gt;fNext;
                  }
                  newChain-&gt;fNext = insertAfter-&gt;fNext;
                  insertAfter-&gt;fNext = newChain;
              }
              OrConstraint *orNode = new OrConstraint();
              newChain-&gt;ruleHeader = orNode;
<span class="line-modified">!             curAndConstraint = orNode-&gt;add();</span>
              currentChain = newChain;
              }
              break;
  
          case tInteger:
<span class="line-new-header">--- 580,60 ---</span>
              }
              break;
          case tComma:
              // TODO: rule syntax checking is inadequate, can happen with badly formed rules.
              //       Catch cases like &quot;n mod 10, is 1&quot; here instead.
<span class="line-modified">!             if (curAndConstraint == nullptr || curAndConstraint-&gt;rangeList == nullptr) {</span>
                  status = U_UNEXPECTED_TOKEN;
                  break;
              }
              U_ASSERT(curAndConstraint-&gt;rangeList-&gt;size() &gt;= 2);
              rangeLowIdx = curAndConstraint-&gt;rangeList-&gt;size();
              curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Low
              rangeHiIdx = curAndConstraint-&gt;rangeList-&gt;size();
              curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Hi
              break;
          case tMod:
<span class="line-modified">!             U_ASSERT(curAndConstraint != nullptr);</span>
              curAndConstraint-&gt;op=AndConstraint::MOD;
              break;
          case tVariableN:
          case tVariableI:
          case tVariableF:
          case tVariableT:
          case tVariableV:
<span class="line-modified">!             U_ASSERT(curAndConstraint != nullptr);</span>
              curAndConstraint-&gt;digitsType = type;
              break;
          case tKeyword:
              {
              RuleChain *newChain = new RuleChain;
<span class="line-modified">!             if (newChain == nullptr) {</span>
                  status = U_MEMORY_ALLOCATION_ERROR;
                  break;
              }
              newChain-&gt;fKeyword = token;
<span class="line-modified">!             if (prules-&gt;mRules == nullptr) {</span>
                  prules-&gt;mRules = newChain;
              } else {
                  // The new rule chain goes at the end of the linked list of rule chains,
                  //   unless there is an &quot;other&quot; keyword &amp; chain. &quot;other&quot; must remain last.
                  RuleChain *insertAfter = prules-&gt;mRules;
<span class="line-modified">!                 while (insertAfter-&gt;fNext!=nullptr &amp;&amp;</span>
                         insertAfter-&gt;fNext-&gt;fKeyword.compare(PLURAL_KEYWORD_OTHER, 5) != 0 ){
                      insertAfter=insertAfter-&gt;fNext;
                  }
                  newChain-&gt;fNext = insertAfter-&gt;fNext;
                  insertAfter-&gt;fNext = newChain;
              }
              OrConstraint *orNode = new OrConstraint();
<span class="line-added">+             if (orNode == nullptr) {</span>
<span class="line-added">+                 status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
              newChain-&gt;ruleHeader = orNode;
<span class="line-modified">!             curAndConstraint = orNode-&gt;add(status);</span>
              currentChain = newChain;
              }
              break;
  
          case tInteger:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 627,11 ***</span>
      UnicodeString emptyStr;
  
      if (U_FAILURE(errCode)) {
          return emptyStr;
      }
<span class="line-modified">!     LocalUResourceBundlePointer rb(ures_openDirect(NULL, &quot;plurals&quot;, &amp;errCode));</span>
      if(U_FAILURE(errCode)) {
          return emptyStr;
      }
      const char *typeKey;
      switch (type) {
<span class="line-new-header">--- 679,11 ---</span>
      UnicodeString emptyStr;
  
      if (U_FAILURE(errCode)) {
          return emptyStr;
      }
<span class="line-modified">!     LocalUResourceBundlePointer rb(ures_openDirect(nullptr, &quot;plurals&quot;, &amp;errCode));</span>
      if(U_FAILURE(errCode)) {
          return emptyStr;
      }
      const char *typeKey;
      switch (type) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 644,56 ***</span>
      default:
          // Must not occur: The caller should have checked for valid types.
          errCode = U_ILLEGAL_ARGUMENT_ERROR;
          return emptyStr;
      }
<span class="line-modified">!     LocalUResourceBundlePointer locRes(ures_getByKey(rb.getAlias(), typeKey, NULL, &amp;errCode));</span>
      if(U_FAILURE(errCode)) {
          return emptyStr;
      }
      int32_t resLen=0;
<span class="line-modified">!     const char *curLocaleName=locale.getName();</span>
      const UChar* s = ures_getStringByKey(locRes.getAlias(), curLocaleName, &amp;resLen, &amp;errCode);
  
<span class="line-modified">!     if (s == NULL) {</span>
          // Check parent locales.
          UErrorCode status = U_ZERO_ERROR;
          char parentLocaleName[ULOC_FULLNAME_CAPACITY];
<span class="line-modified">!         const char *curLocaleName=locale.getName();</span>
<span class="line-modified">!         uprv_strcpy(parentLocaleName, curLocaleName);</span>
  
          while (uloc_getParent(parentLocaleName, parentLocaleName,
                                         ULOC_FULLNAME_CAPACITY, &amp;status) &gt; 0) {
              resLen=0;
              s = ures_getStringByKey(locRes.getAlias(), parentLocaleName, &amp;resLen, &amp;status);
<span class="line-modified">!             if (s != NULL) {</span>
                  errCode = U_ZERO_ERROR;
                  break;
              }
              status = U_ZERO_ERROR;
          }
      }
<span class="line-modified">!     if (s==NULL) {</span>
          return emptyStr;
      }
  
      char setKey[256];
      u_UCharsToChars(s, setKey, resLen + 1);
      // printf(&quot;\n PluralRule: %s\n&quot;, setKey);
  
<span class="line-modified">!     LocalUResourceBundlePointer ruleRes(ures_getByKey(rb.getAlias(), &quot;rules&quot;, NULL, &amp;errCode));</span>
      if(U_FAILURE(errCode)) {
          return emptyStr;
      }
<span class="line-modified">!     LocalUResourceBundlePointer setRes(ures_getByKey(ruleRes.getAlias(), setKey, NULL, &amp;errCode));</span>
      if (U_FAILURE(errCode)) {
          return emptyStr;
      }
  
      int32_t numberKeys = ures_getSize(setRes.getAlias());
      UnicodeString result;
<span class="line-modified">!     const char *key=NULL;</span>
      for(int32_t i=0; i&lt;numberKeys; ++i) {   // Keys are zero, one, few, ...
          UnicodeString rules = ures_getNextUnicodeString(setRes.getAlias(), &amp;key, &amp;errCode);
          UnicodeString uKey(key, -1, US_INV);
          result.append(uKey);
          result.append(COLON);
<span class="line-new-header">--- 696,56 ---</span>
      default:
          // Must not occur: The caller should have checked for valid types.
          errCode = U_ILLEGAL_ARGUMENT_ERROR;
          return emptyStr;
      }
<span class="line-modified">!     LocalUResourceBundlePointer locRes(ures_getByKey(rb.getAlias(), typeKey, nullptr, &amp;errCode));</span>
      if(U_FAILURE(errCode)) {
          return emptyStr;
      }
      int32_t resLen=0;
<span class="line-modified">!     const char *curLocaleName=locale.getBaseName();</span>
      const UChar* s = ures_getStringByKey(locRes.getAlias(), curLocaleName, &amp;resLen, &amp;errCode);
  
<span class="line-modified">!     if (s == nullptr) {</span>
          // Check parent locales.
          UErrorCode status = U_ZERO_ERROR;
          char parentLocaleName[ULOC_FULLNAME_CAPACITY];
<span class="line-modified">!         const char *curLocaleName2=locale.getBaseName();</span>
<span class="line-modified">!         uprv_strcpy(parentLocaleName, curLocaleName2);</span>
  
          while (uloc_getParent(parentLocaleName, parentLocaleName,
                                         ULOC_FULLNAME_CAPACITY, &amp;status) &gt; 0) {
              resLen=0;
              s = ures_getStringByKey(locRes.getAlias(), parentLocaleName, &amp;resLen, &amp;status);
<span class="line-modified">!             if (s != nullptr) {</span>
                  errCode = U_ZERO_ERROR;
                  break;
              }
              status = U_ZERO_ERROR;
          }
      }
<span class="line-modified">!     if (s==nullptr) {</span>
          return emptyStr;
      }
  
      char setKey[256];
      u_UCharsToChars(s, setKey, resLen + 1);
      // printf(&quot;\n PluralRule: %s\n&quot;, setKey);
  
<span class="line-modified">!     LocalUResourceBundlePointer ruleRes(ures_getByKey(rb.getAlias(), &quot;rules&quot;, nullptr, &amp;errCode));</span>
      if(U_FAILURE(errCode)) {
          return emptyStr;
      }
<span class="line-modified">!     LocalUResourceBundlePointer setRes(ures_getByKey(ruleRes.getAlias(), setKey, nullptr, &amp;errCode));</span>
      if (U_FAILURE(errCode)) {
          return emptyStr;
      }
  
      int32_t numberKeys = ures_getSize(setRes.getAlias());
      UnicodeString result;
<span class="line-modified">!     const char *key=nullptr;</span>
      for(int32_t i=0; i&lt;numberKeys; ++i) {   // Keys are zero, one, few, ...
          UnicodeString rules = ures_getNextUnicodeString(setRes.getAlias(), &amp;key, &amp;errCode);
          UnicodeString uKey(key, -1, US_INV);
          result.append(uKey);
          result.append(COLON);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 705,58 ***</span>
  
  
  UnicodeString
  PluralRules::getRules() const {
      UnicodeString rules;
<span class="line-modified">!     if (mRules != NULL) {</span>
          mRules-&gt;dumpRules(rules);
      }
      return rules;
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- AndConstraint::AndConstraint() {</span>
<span class="line-removed">-     op = AndConstraint::NONE;</span>
<span class="line-removed">-     opNum=-1;</span>
<span class="line-removed">-     value = -1;</span>
<span class="line-removed">-     rangeList = NULL;</span>
<span class="line-removed">-     negated = FALSE;</span>
<span class="line-removed">-     integerOnly = FALSE;</span>
<span class="line-removed">-     digitsType = none;</span>
<span class="line-removed">-     next=NULL;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  AndConstraint::AndConstraint(const AndConstraint&amp; other) {
      this-&gt;op = other.op;
      this-&gt;opNum=other.opNum;
      this-&gt;value=other.value;
<span class="line-modified">!     this-&gt;rangeList=NULL;</span>
<span class="line-modified">!     if (other.rangeList != NULL) {</span>
<span class="line-modified">!         UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified">!         this-&gt;rangeList = new UVector32(status);</span>
<span class="line-modified">!         this-&gt;rangeList-&gt;assign(*other.rangeList, status);</span>
      }
      this-&gt;integerOnly=other.integerOnly;
      this-&gt;negated=other.negated;
      this-&gt;digitsType = other.digitsType;
<span class="line-modified">!     if (other.next==NULL) {</span>
<span class="line-removed">-         this-&gt;next=NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     else {</span>
          this-&gt;next = new AndConstraint(*other.next);
      }
  }
  
  AndConstraint::~AndConstraint() {
      delete rangeList;
<span class="line-modified">!     if (next!=NULL) {</span>
<span class="line-modified">!         delete next;</span>
<span class="line-modified">!     }</span>
  }
  
<span class="line-removed">- </span>
  UBool
  AndConstraint::isFulfilled(const IFixedDecimal &amp;number) {
      UBool result = TRUE;
      if (digitsType == none) {
          // An empty AndConstraint, created by a rule with a keyword but no following expression.
<span class="line-new-header">--- 757,50 ---</span>
  
  
  UnicodeString
  PluralRules::getRules() const {
      UnicodeString rules;
<span class="line-modified">!     if (mRules != nullptr) {</span>
          mRules-&gt;dumpRules(rules);
      }
      return rules;
  }
  
  AndConstraint::AndConstraint(const AndConstraint&amp; other) {
<span class="line-added">+     this-&gt;fInternalStatus = other.fInternalStatus;</span>
<span class="line-added">+     if (U_FAILURE(fInternalStatus)) {</span>
<span class="line-added">+         return; // stop early if the object we are copying from is invalid.</span>
<span class="line-added">+     }</span>
      this-&gt;op = other.op;
      this-&gt;opNum=other.opNum;
      this-&gt;value=other.value;
<span class="line-modified">!     if (other.rangeList != nullptr) {</span>
<span class="line-modified">!         LocalPointer&lt;UVector32&gt; newRangeList(new UVector32(fInternalStatus), fInternalStatus);</span>
<span class="line-modified">!         if (U_FAILURE(fInternalStatus)) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-added">+         this-&gt;rangeList = newRangeList.orphan();</span>
<span class="line-added">+         this-&gt;rangeList-&gt;assign(*other.rangeList, fInternalStatus);</span>
      }
      this-&gt;integerOnly=other.integerOnly;
      this-&gt;negated=other.negated;
      this-&gt;digitsType = other.digitsType;
<span class="line-modified">!     if (other.next != nullptr) {</span>
          this-&gt;next = new AndConstraint(*other.next);
<span class="line-added">+         if (this-&gt;next == nullptr) {</span>
<span class="line-added">+             fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         }</span>
      }
  }
  
  AndConstraint::~AndConstraint() {
      delete rangeList;
<span class="line-modified">!     rangeList = nullptr;</span>
<span class="line-modified">!     delete next;</span>
<span class="line-modified">!     next = nullptr;</span>
  }
  
  UBool
  AndConstraint::isFulfilled(const IFixedDecimal &amp;number) {
      UBool result = TRUE;
      if (digitsType == none) {
          // An empty AndConstraint, created by a rule with a keyword but no following expression.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 774,11 ***</span>
          }
  
          if (op == MOD) {
              n = fmod(n, opNum);
          }
<span class="line-modified">!         if (rangeList == NULL) {</span>
              result = value == -1 ||    // empty rule
                       n == value;       //  &#39;is&#39; rule
              break;
          }
          result = FALSE;                // &#39;in&#39; or &#39;within&#39; rule
<span class="line-new-header">--- 818,11 ---</span>
          }
  
          if (op == MOD) {
              n = fmod(n, opNum);
          }
<span class="line-modified">!         if (rangeList == nullptr) {</span>
              result = value == -1 ||    // empty rule
                       n == value;       //  &#39;is&#39; rule
              break;
          }
          result = FALSE;                // &#39;in&#39; or &#39;within&#39; rule
</pre>
<hr />
<pre>
<span class="line-old-header">*** 794,106 ***</span>
          result = !result;
      }
      return result;
  }
  
<span class="line-removed">- </span>
  AndConstraint*
<span class="line-modified">! AndConstraint::add()</span>
<span class="line-modified">! {</span>
      this-&gt;next = new AndConstraint();
      return this-&gt;next;
  }
  
<span class="line-removed">- OrConstraint::OrConstraint() {</span>
<span class="line-removed">-     childNode=NULL;</span>
<span class="line-removed">-     next=NULL;</span>
<span class="line-removed">- }</span>
  
  OrConstraint::OrConstraint(const OrConstraint&amp; other) {
<span class="line-modified">!     if ( other.childNode == NULL ) {</span>
<span class="line-modified">!         this-&gt;childNode = NULL;</span>
      }
<span class="line-modified">!     else {</span>
          this-&gt;childNode = new AndConstraint(*(other.childNode));
      }
<span class="line-modified">!     if (other.next == NULL ) {</span>
<span class="line-removed">-         this-&gt;next = NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     else {</span>
          this-&gt;next = new OrConstraint(*(other.next));
      }
  }
  
  OrConstraint::~OrConstraint() {
<span class="line-modified">!     if (childNode!=NULL) {</span>
<span class="line-modified">!         delete childNode;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (next!=NULL) {</span>
<span class="line-removed">-         delete next;</span>
<span class="line-removed">-     }</span>
  }
  
  AndConstraint*
<span class="line-modified">! OrConstraint::add()</span>
<span class="line-modified">! {</span>
      OrConstraint *curOrConstraint=this;
      {
<span class="line-modified">!         while (curOrConstraint-&gt;next!=NULL) {</span>
              curOrConstraint = curOrConstraint-&gt;next;
          }
<span class="line-modified">!         U_ASSERT(curOrConstraint-&gt;childNode == NULL);</span>
          curOrConstraint-&gt;childNode = new AndConstraint();
      }
      return curOrConstraint-&gt;childNode;
  }
  
  UBool
  OrConstraint::isFulfilled(const IFixedDecimal &amp;number) {
      OrConstraint* orRule=this;
      UBool result=FALSE;
  
<span class="line-modified">!     while (orRule!=NULL &amp;&amp; !result) {</span>
          result=TRUE;
          AndConstraint* andRule = orRule-&gt;childNode;
<span class="line-modified">!         while (andRule!=NULL &amp;&amp; result) {</span>
              result = andRule-&gt;isFulfilled(number);
              andRule=andRule-&gt;next;
          }
          orRule = orRule-&gt;next;
      }
  
      return result;
  }
  
  
<span class="line-removed">- RuleChain::RuleChain(): fKeyword(), fNext(NULL), ruleHeader(NULL), fDecimalSamples(), fIntegerSamples(),</span>
<span class="line-removed">-                         fDecimalSamplesUnbounded(FALSE), fIntegerSamplesUnbounded(FALSE) {</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  RuleChain::RuleChain(const RuleChain&amp; other) :
<span class="line-modified">!         fKeyword(other.fKeyword), fNext(NULL), ruleHeader(NULL), fDecimalSamples(other.fDecimalSamples),</span>
          fIntegerSamples(other.fIntegerSamples), fDecimalSamplesUnbounded(other.fDecimalSamplesUnbounded),
<span class="line-modified">!         fIntegerSamplesUnbounded(other.fIntegerSamplesUnbounded) {</span>
<span class="line-modified">!     if (other.ruleHeader != NULL) {</span>
          this-&gt;ruleHeader = new OrConstraint(*(other.ruleHeader));
      }
<span class="line-modified">!     if (other.fNext != NULL ) {</span>
          this-&gt;fNext = new RuleChain(*other.fNext);
      }
  }
  
  RuleChain::~RuleChain() {
      delete fNext;
      delete ruleHeader;
  }
  
<span class="line-removed">- </span>
  UnicodeString
  RuleChain::select(const IFixedDecimal &amp;number) const {
      if (!number.isNaN() &amp;&amp; !number.isInfinite()) {
<span class="line-modified">!         for (const RuleChain *rules = this; rules != NULL; rules = rules-&gt;fNext) {</span>
               if (rules-&gt;ruleHeader-&gt;isFulfilled(number)) {
                   return rules-&gt;fKeyword;
               }
          }
      }
<span class="line-new-header">--- 838,133 ---</span>
          result = !result;
      }
      return result;
  }
  
  AndConstraint*
<span class="line-modified">! AndConstraint::add(UErrorCode&amp; status) {</span>
<span class="line-modified">!     if (U_FAILURE(fInternalStatus)) {</span>
<span class="line-added">+         status = fInternalStatus;</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
      this-&gt;next = new AndConstraint();
<span class="line-added">+     if (this-&gt;next == nullptr) {</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+     }</span>
      return this-&gt;next;
  }
  
  
  OrConstraint::OrConstraint(const OrConstraint&amp; other) {
<span class="line-modified">!     this-&gt;fInternalStatus = other.fInternalStatus;</span>
<span class="line-modified">!     if (U_FAILURE(fInternalStatus)) {</span>
<span class="line-added">+         return; // stop early if the object we are copying from is invalid.</span>
      }
<span class="line-modified">!     if ( other.childNode != nullptr ) {</span>
          this-&gt;childNode = new AndConstraint(*(other.childNode));
<span class="line-added">+         if (this-&gt;childNode == nullptr) {</span>
<span class="line-added">+             fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
      }
<span class="line-modified">!     if (other.next != nullptr ) {</span>
          this-&gt;next = new OrConstraint(*(other.next));
<span class="line-added">+         if (this-&gt;next == nullptr) {</span>
<span class="line-added">+             fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (U_FAILURE(this-&gt;next-&gt;fInternalStatus)) {</span>
<span class="line-added">+             this-&gt;fInternalStatus = this-&gt;next-&gt;fInternalStatus;</span>
<span class="line-added">+         }</span>
      }
  }
  
  OrConstraint::~OrConstraint() {
<span class="line-modified">!     delete childNode;</span>
<span class="line-modified">!     childNode = nullptr;</span>
<span class="line-modified">!     delete next;</span>
<span class="line-modified">!     next = nullptr;</span>
  }
  
  AndConstraint*
<span class="line-modified">! OrConstraint::add(UErrorCode&amp; status) {</span>
<span class="line-modified">!     if (U_FAILURE(fInternalStatus)) {</span>
<span class="line-added">+         status = fInternalStatus;</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
      OrConstraint *curOrConstraint=this;
      {
<span class="line-modified">!         while (curOrConstraint-&gt;next!=nullptr) {</span>
              curOrConstraint = curOrConstraint-&gt;next;
          }
<span class="line-modified">!         U_ASSERT(curOrConstraint-&gt;childNode == nullptr);</span>
          curOrConstraint-&gt;childNode = new AndConstraint();
<span class="line-added">+         if (curOrConstraint-&gt;childNode == nullptr) {</span>
<span class="line-added">+             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         }</span>
      }
      return curOrConstraint-&gt;childNode;
  }
  
  UBool
  OrConstraint::isFulfilled(const IFixedDecimal &amp;number) {
      OrConstraint* orRule=this;
      UBool result=FALSE;
  
<span class="line-modified">!     while (orRule!=nullptr &amp;&amp; !result) {</span>
          result=TRUE;
          AndConstraint* andRule = orRule-&gt;childNode;
<span class="line-modified">!         while (andRule!=nullptr &amp;&amp; result) {</span>
              result = andRule-&gt;isFulfilled(number);
              andRule=andRule-&gt;next;
          }
          orRule = orRule-&gt;next;
      }
  
      return result;
  }
  
  
  RuleChain::RuleChain(const RuleChain&amp; other) :
<span class="line-modified">!         fKeyword(other.fKeyword), fDecimalSamples(other.fDecimalSamples),</span>
          fIntegerSamples(other.fIntegerSamples), fDecimalSamplesUnbounded(other.fDecimalSamplesUnbounded),
<span class="line-modified">!         fIntegerSamplesUnbounded(other.fIntegerSamplesUnbounded), fInternalStatus(other.fInternalStatus) {</span>
<span class="line-modified">!     if (U_FAILURE(this-&gt;fInternalStatus)) {</span>
<span class="line-added">+         return; // stop early if the object we are copying from is invalid.</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (other.ruleHeader != nullptr) {</span>
          this-&gt;ruleHeader = new OrConstraint(*(other.ruleHeader));
<span class="line-added">+         if (this-&gt;ruleHeader == nullptr) {</span>
<span class="line-added">+             this-&gt;fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         else if (U_FAILURE(this-&gt;ruleHeader-&gt;fInternalStatus)) {</span>
<span class="line-added">+             // If the OrConstraint wasn&#39;t fully copied, then set our status to failure as well.</span>
<span class="line-added">+             this-&gt;fInternalStatus = this-&gt;ruleHeader-&gt;fInternalStatus;</span>
<span class="line-added">+             return; // exit early.</span>
<span class="line-added">+         }</span>
      }
<span class="line-modified">!     if (other.fNext != nullptr ) {</span>
          this-&gt;fNext = new RuleChain(*other.fNext);
<span class="line-added">+         if (this-&gt;fNext == nullptr) {</span>
<span class="line-added">+             this-&gt;fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         else if (U_FAILURE(this-&gt;fNext-&gt;fInternalStatus)) {</span>
<span class="line-added">+             // If the RuleChain wasn&#39;t fully copied, then set our status to failure as well.</span>
<span class="line-added">+             this-&gt;fInternalStatus = this-&gt;fNext-&gt;fInternalStatus;</span>
<span class="line-added">+         }</span>
      }
  }
  
  RuleChain::~RuleChain() {
      delete fNext;
      delete ruleHeader;
  }
  
  UnicodeString
  RuleChain::select(const IFixedDecimal &amp;number) const {
      if (!number.isNaN() &amp;&amp; !number.isInfinite()) {
<span class="line-modified">!         for (const RuleChain *rules = this; rules != nullptr; rules = rules-&gt;fNext) {</span>
               if (rules-&gt;ruleHeader-&gt;isFulfilled(number)) {
                   return rules-&gt;fKeyword;
               }
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 921,21 ***</span>
  
  void
  RuleChain::dumpRules(UnicodeString&amp; result) {
      UChar digitString[16];
  
<span class="line-modified">!     if ( ruleHeader != NULL ) {</span>
          result +=  fKeyword;
          result += COLON;
          result += SPACE;
          OrConstraint* orRule=ruleHeader;
<span class="line-modified">!         while ( orRule != NULL ) {</span>
              AndConstraint* andRule=orRule-&gt;childNode;
<span class="line-modified">!             while ( andRule != NULL ) {</span>
<span class="line-modified">!                 if ((andRule-&gt;op==AndConstraint::NONE) &amp;&amp;  (andRule-&gt;rangeList==NULL) &amp;&amp; (andRule-&gt;value == -1)) {</span>
                      // Empty Rules.
<span class="line-modified">!                 } else if ( (andRule-&gt;op==AndConstraint::NONE) &amp;&amp; (andRule-&gt;rangeList==NULL) ) {</span>
                      result += tokenString(andRule-&gt;digitsType);
                      result += UNICODE_STRING_SIMPLE(&quot; is &quot;);
                      if (andRule-&gt;negated) {
                          result += UNICODE_STRING_SIMPLE(&quot;not &quot;);
                      }
<span class="line-new-header">--- 992,21 ---</span>
  
  void
  RuleChain::dumpRules(UnicodeString&amp; result) {
      UChar digitString[16];
  
<span class="line-modified">!     if ( ruleHeader != nullptr ) {</span>
          result +=  fKeyword;
          result += COLON;
          result += SPACE;
          OrConstraint* orRule=ruleHeader;
<span class="line-modified">!         while ( orRule != nullptr ) {</span>
              AndConstraint* andRule=orRule-&gt;childNode;
<span class="line-modified">!             while ( andRule != nullptr ) {</span>
<span class="line-modified">!                 if ((andRule-&gt;op==AndConstraint::NONE) &amp;&amp;  (andRule-&gt;rangeList==nullptr) &amp;&amp; (andRule-&gt;value == -1)) {</span>
                      // Empty Rules.
<span class="line-modified">!                 } else if ( (andRule-&gt;op==AndConstraint::NONE) &amp;&amp; (andRule-&gt;rangeList==nullptr) ) {</span>
                      result += tokenString(andRule-&gt;digitsType);
                      result += UNICODE_STRING_SIMPLE(&quot; is &quot;);
                      if (andRule-&gt;negated) {
                          result += UNICODE_STRING_SIMPLE(&quot;not &quot;);
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 948,11 ***</span>
                      if (andRule-&gt;op==AndConstraint::MOD) {
                          result += UNICODE_STRING_SIMPLE(&quot;mod &quot;);
                          uprv_itou(digitString,16, andRule-&gt;opNum,10,0);
                          result += UnicodeString(digitString);
                      }
<span class="line-modified">!                     if (andRule-&gt;rangeList==NULL) {</span>
                          if (andRule-&gt;negated) {
                              result += UNICODE_STRING_SIMPLE(&quot; is not &quot;);
                              uprv_itou(digitString,16, andRule-&gt;value,10,0);
                              result += UnicodeString(digitString);
                          }
<span class="line-new-header">--- 1019,11 ---</span>
                      if (andRule-&gt;op==AndConstraint::MOD) {
                          result += UNICODE_STRING_SIMPLE(&quot;mod &quot;);
                          uprv_itou(digitString,16, andRule-&gt;opNum,10,0);
                          result += UnicodeString(digitString);
                      }
<span class="line-modified">!                     if (andRule-&gt;rangeList==nullptr) {</span>
                          if (andRule-&gt;negated) {
                              result += UNICODE_STRING_SIMPLE(&quot; is not &quot;);
                              uprv_itou(digitString,16, andRule-&gt;value,10,0);
                              result += UnicodeString(digitString);
                          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 991,36 ***</span>
                                  result += UNICODE_STRING_SIMPLE(&quot;, &quot;);
                              }
                          }
                      }
                  }
<span class="line-modified">!                 if ( (andRule=andRule-&gt;next) != NULL) {</span>
                      result += UNICODE_STRING_SIMPLE(&quot; and &quot;);
                  }
              }
<span class="line-modified">!             if ( (orRule = orRule-&gt;next) != NULL ) {</span>
                  result += UNICODE_STRING_SIMPLE(&quot; or &quot;);
              }
          }
      }
<span class="line-modified">!     if ( fNext != NULL ) {</span>
          result += UNICODE_STRING_SIMPLE(&quot;; &quot;);
          fNext-&gt;dumpRules(result);
      }
  }
  
  
  UErrorCode
  RuleChain::getKeywords(int32_t capacityOfKeywords, UnicodeString* keywords, int32_t&amp; arraySize) const {
      if ( arraySize &lt; capacityOfKeywords-1 ) {
          keywords[arraySize++]=fKeyword;
      }
      else {
          return U_BUFFER_OVERFLOW_ERROR;
      }
  
<span class="line-modified">!     if ( fNext != NULL ) {</span>
          return fNext-&gt;getKeywords(capacityOfKeywords, keywords, arraySize);
      }
      else {
          return U_ZERO_ERROR;
      }
<span class="line-new-header">--- 1062,39 ---</span>
                                  result += UNICODE_STRING_SIMPLE(&quot;, &quot;);
                              }
                          }
                      }
                  }
<span class="line-modified">!                 if ( (andRule=andRule-&gt;next) != nullptr) {</span>
                      result += UNICODE_STRING_SIMPLE(&quot; and &quot;);
                  }
              }
<span class="line-modified">!             if ( (orRule = orRule-&gt;next) != nullptr ) {</span>
                  result += UNICODE_STRING_SIMPLE(&quot; or &quot;);
              }
          }
      }
<span class="line-modified">!     if ( fNext != nullptr ) {</span>
          result += UNICODE_STRING_SIMPLE(&quot;; &quot;);
          fNext-&gt;dumpRules(result);
      }
  }
  
  
  UErrorCode
  RuleChain::getKeywords(int32_t capacityOfKeywords, UnicodeString* keywords, int32_t&amp; arraySize) const {
<span class="line-added">+     if (U_FAILURE(fInternalStatus)) {</span>
<span class="line-added">+         return fInternalStatus;</span>
<span class="line-added">+     }</span>
      if ( arraySize &lt; capacityOfKeywords-1 ) {
          keywords[arraySize++]=fKeyword;
      }
      else {
          return U_BUFFER_OVERFLOW_ERROR;
      }
  
<span class="line-modified">!     if ( fNext != nullptr ) {</span>
          return fNext-&gt;getKeywords(capacityOfKeywords, keywords, arraySize);
      }
      else {
          return U_ZERO_ERROR;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1030,22 ***</span>
  RuleChain::isKeyword(const UnicodeString&amp; keywordParam) const {
      if ( fKeyword == keywordParam ) {
          return TRUE;
      }
  
<span class="line-modified">!     if ( fNext != NULL ) {</span>
          return fNext-&gt;isKeyword(keywordParam);
      }
      else {
          return FALSE;
      }
  }
  
  
  PluralRuleParser::PluralRuleParser() :
          ruleIndex(0), token(), type(none), prevType(none),
<span class="line-modified">!         curAndConstraint(NULL), currentChain(NULL), rangeLowIdx(-1), rangeHiIdx(-1)</span>
  {
  }
  
  PluralRuleParser::~PluralRuleParser() {
  }
<span class="line-new-header">--- 1104,22 ---</span>
  RuleChain::isKeyword(const UnicodeString&amp; keywordParam) const {
      if ( fKeyword == keywordParam ) {
          return TRUE;
      }
  
<span class="line-modified">!     if ( fNext != nullptr ) {</span>
          return fNext-&gt;isKeyword(keywordParam);
      }
      else {
          return FALSE;
      }
  }
  
  
  PluralRuleParser::PluralRuleParser() :
          ruleIndex(0), token(), type(none), prevType(none),
<span class="line-modified">!         curAndConstraint(nullptr), currentChain(nullptr), rangeLowIdx(-1), rangeHiIdx(-1)</span>
  {
  }
  
  PluralRuleParser::~PluralRuleParser() {
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1339,44 ***</span>
          : pos(0), fKeywordNames(status) {
      if (U_FAILURE(status)) {
          return;
      }
      fKeywordNames.setDeleter(uprv_deleteUObject);
<span class="line-modified">!     UBool  addKeywordOther=TRUE;</span>
<span class="line-modified">!     RuleChain *node=header;</span>
<span class="line-modified">!     while(node!=NULL) {</span>
<span class="line-modified">!         fKeywordNames.addElement(new UnicodeString(node-&gt;fKeyword), status);</span>
          if (U_FAILURE(status)) {
              return;
          }
          if (0 == node-&gt;fKeyword.compare(PLURAL_KEYWORD_OTHER, 5)) {
<span class="line-modified">!             addKeywordOther= FALSE;</span>
          }
<span class="line-modified">!         node=node-&gt;fNext;</span>
      }
  
      if (addKeywordOther) {
<span class="line-modified">!         fKeywordNames.addElement(new UnicodeString(PLURAL_KEYWORD_OTHER), status);</span>
      }
  }
  
  const UnicodeString*
  PluralKeywordEnumeration::snext(UErrorCode&amp; status) {
      if (U_SUCCESS(status) &amp;&amp; pos &lt; fKeywordNames.size()) {
          return (const UnicodeString*)fKeywordNames.elementAt(pos++);
      }
<span class="line-modified">!     return NULL;</span>
  }
  
  void
  PluralKeywordEnumeration::reset(UErrorCode&amp; /*status*/) {
      pos=0;
  }
  
  int32_t
  PluralKeywordEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">!        return fKeywordNames.size();</span>
  }
  
  PluralKeywordEnumeration::~PluralKeywordEnumeration() {
  }
  
<span class="line-new-header">--- 1413,59 ---</span>
          : pos(0), fKeywordNames(status) {
      if (U_FAILURE(status)) {
          return;
      }
      fKeywordNames.setDeleter(uprv_deleteUObject);
<span class="line-modified">!     UBool  addKeywordOther = TRUE;</span>
<span class="line-modified">!     RuleChain *node = header;</span>
<span class="line-modified">!     while (node != nullptr) {</span>
<span class="line-modified">!         auto newElem = new UnicodeString(node-&gt;fKeyword);</span>
<span class="line-added">+         if (newElem == nullptr) {</span>
<span class="line-added">+             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         fKeywordNames.addElement(newElem, status);</span>
          if (U_FAILURE(status)) {
<span class="line-added">+             delete newElem;</span>
              return;
          }
          if (0 == node-&gt;fKeyword.compare(PLURAL_KEYWORD_OTHER, 5)) {
<span class="line-modified">!             addKeywordOther = FALSE;</span>
          }
<span class="line-modified">!         node = node-&gt;fNext;</span>
      }
  
      if (addKeywordOther) {
<span class="line-modified">!         auto newElem = new UnicodeString(PLURAL_KEYWORD_OTHER);</span>
<span class="line-added">+         if (newElem == nullptr) {</span>
<span class="line-added">+             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         fKeywordNames.addElement(newElem, status);</span>
<span class="line-added">+         if (U_FAILURE(status)) {</span>
<span class="line-added">+             delete newElem;</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
      }
  }
  
  const UnicodeString*
  PluralKeywordEnumeration::snext(UErrorCode&amp; status) {
      if (U_SUCCESS(status) &amp;&amp; pos &lt; fKeywordNames.size()) {
          return (const UnicodeString*)fKeywordNames.elementAt(pos++);
      }
<span class="line-modified">!     return nullptr;</span>
  }
  
  void
  PluralKeywordEnumeration::reset(UErrorCode&amp; /*status*/) {
      pos=0;
  }
  
  int32_t
  PluralKeywordEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">!     return fKeywordNames.size();</span>
  }
  
  PluralKeywordEnumeration::~PluralKeywordEnumeration() {
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1391,12 ***</span>
      case tVariableV:
          return PLURAL_OPERAND_V;
      case tVariableT:
          return PLURAL_OPERAND_T;
      default:
<span class="line-modified">!         U_ASSERT(FALSE);  // unexpected.</span>
<span class="line-removed">-         return PLURAL_OPERAND_N;</span>
      }
  }
  
  FixedDecimal::FixedDecimal(double n, int32_t v, int64_t f) {
      init(n, v, f);
<span class="line-new-header">--- 1480,11 ---</span>
      case tVariableV:
          return PLURAL_OPERAND_V;
      case tVariableT:
          return PLURAL_OPERAND_T;
      default:
<span class="line-modified">!         UPRV_UNREACHABLE;  // unexpected.</span>
      }
  }
  
  FixedDecimal::FixedDecimal(double n, int32_t v, int64_t f) {
      init(n, v, f);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1604,12 ***</span>
          case PLURAL_OPERAND_I: return static_cast&lt;double&gt;(intValue);
          case PLURAL_OPERAND_F: return static_cast&lt;double&gt;(decimalDigits);
          case PLURAL_OPERAND_T: return static_cast&lt;double&gt;(decimalDigitsWithoutTrailingZeros);
          case PLURAL_OPERAND_V: return visibleDecimalDigitCount;
          default:
<span class="line-modified">!              U_ASSERT(FALSE);  // unexpected.</span>
<span class="line-removed">-              return source;</span>
      }
  }
  
  bool FixedDecimal::isNaN() const {
      return _isNaN;
<span class="line-new-header">--- 1692,11 ---</span>
          case PLURAL_OPERAND_I: return static_cast&lt;double&gt;(intValue);
          case PLURAL_OPERAND_F: return static_cast&lt;double&gt;(decimalDigits);
          case PLURAL_OPERAND_T: return static_cast&lt;double&gt;(decimalDigitsWithoutTrailingZeros);
          case PLURAL_OPERAND_V: return visibleDecimalDigitCount;
          default:
<span class="line-modified">!              UPRV_UNREACHABLE;  // unexpected.</span>
      }
  }
  
  bool FixedDecimal::isNaN() const {
      return _isNaN;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1632,45 ***</span>
  }
  
  
  
  PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(UErrorCode &amp;status) {
<span class="line-removed">-     fLocales = NULL;</span>
<span class="line-removed">-     fRes = NULL;</span>
      fOpenStatus = status;
      if (U_FAILURE(status)) {
          return;
      }
<span class="line-modified">!     fOpenStatus = U_ZERO_ERROR;</span>
<span class="line-modified">!     LocalUResourceBundlePointer rb(ures_openDirect(NULL, &quot;plurals&quot;, &amp;fOpenStatus));</span>
<span class="line-modified">!     fLocales = ures_getByKey(rb.getAlias(), &quot;locales&quot;, NULL, &amp;fOpenStatus);</span>
  }
  
  PluralAvailableLocalesEnumeration::~PluralAvailableLocalesEnumeration() {
      ures_close(fLocales);
      ures_close(fRes);
<span class="line-modified">!     fLocales = NULL;</span>
<span class="line-modified">!     fRes = NULL;</span>
  }
  
  const char *PluralAvailableLocalesEnumeration::next(int32_t *resultLength, UErrorCode &amp;status) {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return NULL;</span>
      }
      if (U_FAILURE(fOpenStatus)) {
          status = fOpenStatus;
<span class="line-modified">!         return NULL;</span>
      }
      fRes = ures_getNextResource(fLocales, fRes, &amp;status);
<span class="line-modified">!     if (fRes == NULL || U_FAILURE(status)) {</span>
          if (status == U_INDEX_OUTOFBOUNDS_ERROR) {
              status = U_ZERO_ERROR;
          }
<span class="line-modified">!         return NULL;</span>
      }
      const char *result = ures_getKey(fRes);
<span class="line-modified">!     if (resultLength != NULL) {</span>
          *resultLength = static_cast&lt;int32_t&gt;(uprv_strlen(result));
      }
      return result;
  }
  
<span class="line-new-header">--- 1719,43 ---</span>
  }
  
  
  
  PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(UErrorCode &amp;status) {
      fOpenStatus = status;
      if (U_FAILURE(status)) {
          return;
      }
<span class="line-modified">!     fOpenStatus = U_ZERO_ERROR; // clear any warnings.</span>
<span class="line-modified">!     LocalUResourceBundlePointer rb(ures_openDirect(nullptr, &quot;plurals&quot;, &amp;fOpenStatus));</span>
<span class="line-modified">!     fLocales = ures_getByKey(rb.getAlias(), &quot;locales&quot;, nullptr, &amp;fOpenStatus);</span>
  }
  
  PluralAvailableLocalesEnumeration::~PluralAvailableLocalesEnumeration() {
      ures_close(fLocales);
      ures_close(fRes);
<span class="line-modified">!     fLocales = nullptr;</span>
<span class="line-modified">!     fRes = nullptr;</span>
  }
  
  const char *PluralAvailableLocalesEnumeration::next(int32_t *resultLength, UErrorCode &amp;status) {
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
      if (U_FAILURE(fOpenStatus)) {
          status = fOpenStatus;
<span class="line-modified">!         return nullptr;</span>
      }
      fRes = ures_getNextResource(fLocales, fRes, &amp;status);
<span class="line-modified">!     if (fRes == nullptr || U_FAILURE(status)) {</span>
          if (status == U_INDEX_OUTOFBOUNDS_ERROR) {
              status = U_ZERO_ERROR;
          }
<span class="line-modified">!         return nullptr;</span>
      }
      const char *result = ures_getKey(fRes);
<span class="line-modified">!     if (resultLength != nullptr) {</span>
          *resultLength = static_cast&lt;int32_t&gt;(uprv_strlen(result));
      }
      return result;
  }
  
</pre>
<center><a href="plurfmt.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="plurrule_impl.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>