<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_patternstring.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // © 2017 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 
   4 #include &quot;unicode/utypes.h&quot;
   5 
   6 #if !UCONFIG_NO_FORMATTING
   7 
   8 // Allow implicit conversion from char16_t* to UnicodeString for this file:
   9 // Helpful in toString methods and elsewhere.
  10 #define UNISTR_FROM_STRING_EXPLICIT
  11 #define UNISTR_FROM_CHAR_EXPLICIT
  12 
  13 #include &quot;uassert.h&quot;
  14 #include &quot;number_patternstring.h&quot;
  15 #include &quot;unicode/utf16.h&quot;
  16 #include &quot;number_utils.h&quot;
  17 #include &quot;number_roundingutils.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  18 #include &quot;number_mapper.h&quot;</span>
  19 
  20 using namespace icu;
  21 using namespace icu::number;
  22 using namespace icu::number::impl;
  23 
  24 
  25 void PatternParser::parseToPatternInfo(const UnicodeString&amp; patternString, ParsedPatternInfo&amp; patternInfo,
  26                                        UErrorCode&amp; status) {
  27     patternInfo.consumePattern(patternString, status);
  28 }
  29 
  30 DecimalFormatProperties
  31 PatternParser::parseToProperties(const UnicodeString&amp; pattern, IgnoreRounding ignoreRounding,
  32                                  UErrorCode&amp; status) {
  33     DecimalFormatProperties properties;
  34     parseToExistingPropertiesImpl(pattern, properties, ignoreRounding, status);
  35     return properties;
  36 }
  37 
  38 DecimalFormatProperties PatternParser::parseToProperties(const UnicodeString&amp; pattern,
  39                                                          UErrorCode&amp; status) {
  40     return parseToProperties(pattern, IGNORE_ROUNDING_NEVER, status);
  41 }
  42 
  43 void
  44 PatternParser::parseToExistingProperties(const UnicodeString&amp; pattern, DecimalFormatProperties&amp; properties,
  45                                          IgnoreRounding ignoreRounding, UErrorCode&amp; status) {
  46     parseToExistingPropertiesImpl(pattern, properties, ignoreRounding, status);
  47 }
  48 
  49 
  50 char16_t ParsedPatternInfo::charAt(int32_t flags, int32_t index) const {
  51     const Endpoints&amp; endpoints = getEndpoints(flags);
  52     if (index &lt; 0 || index &gt;= endpoints.end - endpoints.start) {
<a name="2" id="anc2"></a><span class="line-modified">  53         UPRV_UNREACHABLE;</span>
  54     }
  55     return pattern.charAt(endpoints.start + index);
  56 }
  57 
  58 int32_t ParsedPatternInfo::length(int32_t flags) const {
  59     return getLengthFromEndpoints(getEndpoints(flags));
  60 }
  61 
  62 int32_t ParsedPatternInfo::getLengthFromEndpoints(const Endpoints&amp; endpoints) {
  63     return endpoints.end - endpoints.start;
  64 }
  65 
  66 UnicodeString ParsedPatternInfo::getString(int32_t flags) const {
  67     const Endpoints&amp; endpoints = getEndpoints(flags);
  68     if (endpoints.start == endpoints.end) {
  69         return UnicodeString();
  70     }
  71     // Create a new UnicodeString
  72     return UnicodeString(pattern, endpoints.start, endpoints.end - endpoints.start);
  73 }
  74 
  75 const Endpoints&amp; ParsedPatternInfo::getEndpoints(int32_t flags) const {
  76     bool prefix = (flags &amp; AFFIX_PREFIX) != 0;
  77     bool isNegative = (flags &amp; AFFIX_NEGATIVE_SUBPATTERN) != 0;
  78     bool padding = (flags &amp; AFFIX_PADDING) != 0;
  79     if (isNegative &amp;&amp; padding) {
  80         return negative.paddingEndpoints;
  81     } else if (padding) {
  82         return positive.paddingEndpoints;
  83     } else if (prefix &amp;&amp; isNegative) {
  84         return negative.prefixEndpoints;
  85     } else if (prefix) {
  86         return positive.prefixEndpoints;
  87     } else if (isNegative) {
  88         return negative.suffixEndpoints;
  89     } else {
  90         return positive.suffixEndpoints;
  91     }
  92 }
  93 
  94 bool ParsedPatternInfo::positiveHasPlusSign() const {
  95     return positive.hasPlusSign;
  96 }
  97 
  98 bool ParsedPatternInfo::hasNegativeSubpattern() const {
  99     return fHasNegativeSubpattern;
 100 }
 101 
 102 bool ParsedPatternInfo::negativeHasMinusSign() const {
 103     return negative.hasMinusSign;
 104 }
 105 
 106 bool ParsedPatternInfo::hasCurrencySign() const {
 107     return positive.hasCurrencySign || (fHasNegativeSubpattern &amp;&amp; negative.hasCurrencySign);
 108 }
 109 
 110 bool ParsedPatternInfo::containsSymbolType(AffixPatternType type, UErrorCode&amp; status) const {
 111     return AffixUtils::containsType(pattern, type, status);
 112 }
 113 
 114 bool ParsedPatternInfo::hasBody() const {
 115     return positive.integerTotal &gt; 0;
 116 }
 117 
 118 /////////////////////////////////////////////////////
 119 /// BEGIN RECURSIVE DESCENT PARSER IMPLEMENTATION ///
 120 /////////////////////////////////////////////////////
 121 
 122 UChar32 ParsedPatternInfo::ParserState::peek() {
 123     if (offset == pattern.length()) {
 124         return -1;
 125     } else {
 126         return pattern.char32At(offset);
 127     }
 128 }
 129 
 130 UChar32 ParsedPatternInfo::ParserState::next() {
 131     int codePoint = peek();
 132     offset += U16_LENGTH(codePoint);
 133     return codePoint;
 134 }
 135 
 136 void ParsedPatternInfo::consumePattern(const UnicodeString&amp; patternString, UErrorCode&amp; status) {
 137     if (U_FAILURE(status)) { return; }
 138     this-&gt;pattern = patternString;
 139 
 140     // This class is not intended for writing twice!
 141     // Use move assignment to overwrite instead.
 142     U_ASSERT(state.offset == 0);
 143 
 144     // pattern := subpattern (&#39;;&#39; subpattern)?
 145     currentSubpattern = &amp;positive;
 146     consumeSubpattern(status);
 147     if (U_FAILURE(status)) { return; }
 148     if (state.peek() == u&#39;;&#39;) {
 149         state.next(); // consume the &#39;;&#39;
 150         // Don&#39;t consume the negative subpattern if it is empty (trailing &#39;;&#39;)
 151         if (state.peek() != -1) {
 152             fHasNegativeSubpattern = true;
 153             currentSubpattern = &amp;negative;
 154             consumeSubpattern(status);
 155             if (U_FAILURE(status)) { return; }
 156         }
 157     }
 158     if (state.peek() != -1) {
 159         state.toParseException(u&quot;Found unquoted special character&quot;);
 160         status = U_UNQUOTED_SPECIAL;
 161     }
 162 }
 163 
 164 void ParsedPatternInfo::consumeSubpattern(UErrorCode&amp; status) {
 165     // subpattern := literals? number exponent? literals?
 166     consumePadding(PadPosition::UNUM_PAD_BEFORE_PREFIX, status);
 167     if (U_FAILURE(status)) { return; }
 168     consumeAffix(currentSubpattern-&gt;prefixEndpoints, status);
 169     if (U_FAILURE(status)) { return; }
 170     consumePadding(PadPosition::UNUM_PAD_AFTER_PREFIX, status);
 171     if (U_FAILURE(status)) { return; }
 172     consumeFormat(status);
 173     if (U_FAILURE(status)) { return; }
 174     consumeExponent(status);
 175     if (U_FAILURE(status)) { return; }
 176     consumePadding(PadPosition::UNUM_PAD_BEFORE_SUFFIX, status);
 177     if (U_FAILURE(status)) { return; }
 178     consumeAffix(currentSubpattern-&gt;suffixEndpoints, status);
 179     if (U_FAILURE(status)) { return; }
 180     consumePadding(PadPosition::UNUM_PAD_AFTER_SUFFIX, status);
 181     if (U_FAILURE(status)) { return; }
 182 }
 183 
 184 void ParsedPatternInfo::consumePadding(PadPosition paddingLocation, UErrorCode&amp; status) {
 185     if (state.peek() != u&#39;*&#39;) {
 186         return;
 187     }
 188     if (currentSubpattern-&gt;hasPadding) {
 189         state.toParseException(u&quot;Cannot have multiple pad specifiers&quot;);
 190         status = U_MULTIPLE_PAD_SPECIFIERS;
 191         return;
 192     }
 193     currentSubpattern-&gt;paddingLocation = paddingLocation;
 194     currentSubpattern-&gt;hasPadding = true;
 195     state.next(); // consume the &#39;*&#39;
 196     currentSubpattern-&gt;paddingEndpoints.start = state.offset;
 197     consumeLiteral(status);
 198     currentSubpattern-&gt;paddingEndpoints.end = state.offset;
 199 }
 200 
 201 void ParsedPatternInfo::consumeAffix(Endpoints&amp; endpoints, UErrorCode&amp; status) {
 202     // literals := { literal }
 203     endpoints.start = state.offset;
 204     while (true) {
 205         switch (state.peek()) {
 206             case u&#39;#&#39;:
 207             case u&#39;@&#39;:
 208             case u&#39;;&#39;:
 209             case u&#39;*&#39;:
 210             case u&#39;.&#39;:
 211             case u&#39;,&#39;:
 212             case u&#39;0&#39;:
 213             case u&#39;1&#39;:
 214             case u&#39;2&#39;:
 215             case u&#39;3&#39;:
 216             case u&#39;4&#39;:
 217             case u&#39;5&#39;:
 218             case u&#39;6&#39;:
 219             case u&#39;7&#39;:
 220             case u&#39;8&#39;:
 221             case u&#39;9&#39;:
 222             case -1:
 223                 // Characters that cannot appear unquoted in a literal
 224                 // break outer;
 225                 goto after_outer;
 226 
 227             case u&#39;%&#39;:
 228                 currentSubpattern-&gt;hasPercentSign = true;
 229                 break;
 230 
 231             case u&#39;‰&#39;:
 232                 currentSubpattern-&gt;hasPerMilleSign = true;
 233                 break;
 234 
 235             case u&#39;¤&#39;:
 236                 currentSubpattern-&gt;hasCurrencySign = true;
 237                 break;
 238 
 239             case u&#39;-&#39;:
 240                 currentSubpattern-&gt;hasMinusSign = true;
 241                 break;
 242 
 243             case u&#39;+&#39;:
 244                 currentSubpattern-&gt;hasPlusSign = true;
 245                 break;
 246 
 247             default:
 248                 break;
 249         }
 250         consumeLiteral(status);
 251         if (U_FAILURE(status)) { return; }
 252     }
 253     after_outer:
 254     endpoints.end = state.offset;
 255 }
 256 
 257 void ParsedPatternInfo::consumeLiteral(UErrorCode&amp; status) {
 258     if (state.peek() == -1) {
 259         state.toParseException(u&quot;Expected unquoted literal but found EOL&quot;);
 260         status = U_PATTERN_SYNTAX_ERROR;
 261         return;
 262     } else if (state.peek() == u&#39;\&#39;&#39;) {
 263         state.next(); // consume the starting quote
 264         while (state.peek() != u&#39;\&#39;&#39;) {
 265             if (state.peek() == -1) {
 266                 state.toParseException(u&quot;Expected quoted literal but found EOL&quot;);
 267                 status = U_PATTERN_SYNTAX_ERROR;
 268                 return;
 269             } else {
 270                 state.next(); // consume a quoted character
 271             }
 272         }
 273         state.next(); // consume the ending quote
 274     } else {
 275         // consume a non-quoted literal character
 276         state.next();
 277     }
 278 }
 279 
 280 void ParsedPatternInfo::consumeFormat(UErrorCode&amp; status) {
 281     consumeIntegerFormat(status);
 282     if (U_FAILURE(status)) { return; }
 283     if (state.peek() == u&#39;.&#39;) {
 284         state.next(); // consume the decimal point
 285         currentSubpattern-&gt;hasDecimal = true;
 286         currentSubpattern-&gt;widthExceptAffixes += 1;
 287         consumeFractionFormat(status);
 288         if (U_FAILURE(status)) { return; }
 289     }
 290 }
 291 
 292 void ParsedPatternInfo::consumeIntegerFormat(UErrorCode&amp; status) {
 293     // Convenience reference:
 294     ParsedSubpatternInfo&amp; result = *currentSubpattern;
 295 
 296     while (true) {
 297         switch (state.peek()) {
 298             case u&#39;,&#39;:
 299                 result.widthExceptAffixes += 1;
 300                 result.groupingSizes &lt;&lt;= 16;
 301                 break;
 302 
 303             case u&#39;#&#39;:
 304                 if (result.integerNumerals &gt; 0) {
 305                     state.toParseException(u&quot;# cannot follow 0 before decimal point&quot;);
 306                     status = U_UNEXPECTED_TOKEN;
 307                     return;
 308                 }
 309                 result.widthExceptAffixes += 1;
 310                 result.groupingSizes += 1;
 311                 if (result.integerAtSigns &gt; 0) {
 312                     result.integerTrailingHashSigns += 1;
 313                 } else {
 314                     result.integerLeadingHashSigns += 1;
 315                 }
 316                 result.integerTotal += 1;
 317                 break;
 318 
 319             case u&#39;@&#39;:
 320                 if (result.integerNumerals &gt; 0) {
 321                     state.toParseException(u&quot;Cannot mix 0 and @&quot;);
 322                     status = U_UNEXPECTED_TOKEN;
 323                     return;
 324                 }
 325                 if (result.integerTrailingHashSigns &gt; 0) {
 326                     state.toParseException(u&quot;Cannot nest # inside of a run of @&quot;);
 327                     status = U_UNEXPECTED_TOKEN;
 328                     return;
 329                 }
 330                 result.widthExceptAffixes += 1;
 331                 result.groupingSizes += 1;
 332                 result.integerAtSigns += 1;
 333                 result.integerTotal += 1;
 334                 break;
 335 
 336             case u&#39;0&#39;:
 337             case u&#39;1&#39;:
 338             case u&#39;2&#39;:
 339             case u&#39;3&#39;:
 340             case u&#39;4&#39;:
 341             case u&#39;5&#39;:
 342             case u&#39;6&#39;:
 343             case u&#39;7&#39;:
 344             case u&#39;8&#39;:
 345             case u&#39;9&#39;:
 346                 if (result.integerAtSigns &gt; 0) {
 347                     state.toParseException(u&quot;Cannot mix @ and 0&quot;);
 348                     status = U_UNEXPECTED_TOKEN;
 349                     return;
 350                 }
 351                 result.widthExceptAffixes += 1;
 352                 result.groupingSizes += 1;
 353                 result.integerNumerals += 1;
 354                 result.integerTotal += 1;
 355                 if (!result.rounding.isZero() || state.peek() != u&#39;0&#39;) {
 356                     result.rounding.appendDigit(static_cast&lt;int8_t&gt;(state.peek() - u&#39;0&#39;), 0, true);
 357                 }
 358                 break;
 359 
 360             default:
 361                 goto after_outer;
 362         }
 363         state.next(); // consume the symbol
 364     }
 365 
 366     after_outer:
 367     // Disallow patterns with a trailing &#39;,&#39; or with two &#39;,&#39; next to each other
 368     auto grouping1 = static_cast&lt;int16_t&gt; (result.groupingSizes &amp; 0xffff);
 369     auto grouping2 = static_cast&lt;int16_t&gt; ((result.groupingSizes &gt;&gt; 16) &amp; 0xffff);
 370     auto grouping3 = static_cast&lt;int16_t&gt; ((result.groupingSizes &gt;&gt; 32) &amp; 0xffff);
 371     if (grouping1 == 0 &amp;&amp; grouping2 != -1) {
 372         state.toParseException(u&quot;Trailing grouping separator is invalid&quot;);
 373         status = U_UNEXPECTED_TOKEN;
 374         return;
 375     }
 376     if (grouping2 == 0 &amp;&amp; grouping3 != -1) {
 377         state.toParseException(u&quot;Grouping width of zero is invalid&quot;);
 378         status = U_PATTERN_SYNTAX_ERROR;
 379         return;
 380     }
 381 }
 382 
 383 void ParsedPatternInfo::consumeFractionFormat(UErrorCode&amp; status) {
 384     // Convenience reference:
 385     ParsedSubpatternInfo&amp; result = *currentSubpattern;
 386 
 387     int32_t zeroCounter = 0;
 388     while (true) {
 389         switch (state.peek()) {
 390             case u&#39;#&#39;:
 391                 result.widthExceptAffixes += 1;
 392                 result.fractionHashSigns += 1;
 393                 result.fractionTotal += 1;
 394                 zeroCounter++;
 395                 break;
 396 
 397             case u&#39;0&#39;:
 398             case u&#39;1&#39;:
 399             case u&#39;2&#39;:
 400             case u&#39;3&#39;:
 401             case u&#39;4&#39;:
 402             case u&#39;5&#39;:
 403             case u&#39;6&#39;:
 404             case u&#39;7&#39;:
 405             case u&#39;8&#39;:
 406             case u&#39;9&#39;:
 407                 if (result.fractionHashSigns &gt; 0) {
 408                     state.toParseException(u&quot;0 cannot follow # after decimal point&quot;);
 409                     status = U_UNEXPECTED_TOKEN;
 410                     return;
 411                 }
 412                 result.widthExceptAffixes += 1;
 413                 result.fractionNumerals += 1;
 414                 result.fractionTotal += 1;
 415                 if (state.peek() == u&#39;0&#39;) {
 416                     zeroCounter++;
 417                 } else {
 418                     result.rounding
 419                             .appendDigit(static_cast&lt;int8_t&gt;(state.peek() - u&#39;0&#39;), zeroCounter, false);
 420                     zeroCounter = 0;
 421                 }
 422                 break;
 423 
 424             default:
 425                 return;
 426         }
 427         state.next(); // consume the symbol
 428     }
 429 }
 430 
 431 void ParsedPatternInfo::consumeExponent(UErrorCode&amp; status) {
 432     // Convenience reference:
 433     ParsedSubpatternInfo&amp; result = *currentSubpattern;
 434 
 435     if (state.peek() != u&#39;E&#39;) {
 436         return;
 437     }
 438     if ((result.groupingSizes &amp; 0xffff0000L) != 0xffff0000L) {
 439         state.toParseException(u&quot;Cannot have grouping separator in scientific notation&quot;);
 440         status = U_MALFORMED_EXPONENTIAL_PATTERN;
 441         return;
 442     }
 443     state.next(); // consume the E
 444     result.widthExceptAffixes++;
 445     if (state.peek() == u&#39;+&#39;) {
 446         state.next(); // consume the +
 447         result.exponentHasPlusSign = true;
 448         result.widthExceptAffixes++;
 449     }
 450     while (state.peek() == u&#39;0&#39;) {
 451         state.next(); // consume the 0
 452         result.exponentZeros += 1;
 453         result.widthExceptAffixes++;
 454     }
 455 }
 456 
 457 ///////////////////////////////////////////////////
 458 /// END RECURSIVE DESCENT PARSER IMPLEMENTATION ///
 459 ///////////////////////////////////////////////////
 460 
 461 void PatternParser::parseToExistingPropertiesImpl(const UnicodeString&amp; pattern,
 462                                                   DecimalFormatProperties&amp; properties,
 463                                                   IgnoreRounding ignoreRounding, UErrorCode&amp; status) {
 464     if (pattern.length() == 0) {
 465         // Backwards compatibility requires that we reset to the default values.
 466         // TODO: Only overwrite the properties that &quot;saveToProperties&quot; normally touches?
 467         properties.clear();
 468         return;
 469     }
 470 
 471     ParsedPatternInfo patternInfo;
 472     parseToPatternInfo(pattern, patternInfo, status);
 473     if (U_FAILURE(status)) { return; }
 474     patternInfoToProperties(properties, patternInfo, ignoreRounding, status);
 475 }
 476 
 477 void
 478 PatternParser::patternInfoToProperties(DecimalFormatProperties&amp; properties, ParsedPatternInfo&amp; patternInfo,
 479                                        IgnoreRounding _ignoreRounding, UErrorCode&amp; status) {
 480     // Translate from PatternParseResult to Properties.
 481     // Note that most data from &quot;negative&quot; is ignored per the specification of DecimalFormat.
 482 
 483     const ParsedSubpatternInfo&amp; positive = patternInfo.positive;
 484 
 485     bool ignoreRounding;
 486     if (_ignoreRounding == IGNORE_ROUNDING_NEVER) {
 487         ignoreRounding = false;
 488     } else if (_ignoreRounding == IGNORE_ROUNDING_IF_CURRENCY) {
 489         ignoreRounding = positive.hasCurrencySign;
 490     } else {
 491         U_ASSERT(_ignoreRounding == IGNORE_ROUNDING_ALWAYS);
 492         ignoreRounding = true;
 493     }
 494 
 495     // Grouping settings
 496     auto grouping1 = static_cast&lt;int16_t&gt; (positive.groupingSizes &amp; 0xffff);
 497     auto grouping2 = static_cast&lt;int16_t&gt; ((positive.groupingSizes &gt;&gt; 16) &amp; 0xffff);
 498     auto grouping3 = static_cast&lt;int16_t&gt; ((positive.groupingSizes &gt;&gt; 32) &amp; 0xffff);
 499     if (grouping2 != -1) {
 500         properties.groupingSize = grouping1;
 501         properties.groupingUsed = true;
 502     } else {
 503         properties.groupingSize = -1;
 504         properties.groupingUsed = false;
 505     }
 506     if (grouping3 != -1) {
 507         properties.secondaryGroupingSize = grouping2;
 508     } else {
 509         properties.secondaryGroupingSize = -1;
 510     }
 511 
 512     // For backwards compatibility, require that the pattern emit at least one min digit.
 513     int minInt, minFrac;
 514     if (positive.integerTotal == 0 &amp;&amp; positive.fractionTotal &gt; 0) {
 515         // patterns like &quot;.##&quot;
 516         minInt = 0;
 517         minFrac = uprv_max(1, positive.fractionNumerals);
 518     } else if (positive.integerNumerals == 0 &amp;&amp; positive.fractionNumerals == 0) {
 519         // patterns like &quot;#.##&quot;
 520         minInt = 1;
 521         minFrac = 0;
 522     } else {
 523         minInt = positive.integerNumerals;
 524         minFrac = positive.fractionNumerals;
 525     }
 526 
 527     // Rounding settings
 528     // Don&#39;t set basic rounding when there is a currency sign; defer to CurrencyUsage
 529     if (positive.integerAtSigns &gt; 0) {
 530         properties.minimumFractionDigits = -1;
 531         properties.maximumFractionDigits = -1;
 532         properties.roundingIncrement = 0.0;
 533         properties.minimumSignificantDigits = positive.integerAtSigns;
 534         properties.maximumSignificantDigits = positive.integerAtSigns + positive.integerTrailingHashSigns;
 535     } else if (!positive.rounding.isZero()) {
 536         if (!ignoreRounding) {
 537             properties.minimumFractionDigits = minFrac;
 538             properties.maximumFractionDigits = positive.fractionTotal;
 539             properties.roundingIncrement = positive.rounding.toDouble();
 540         } else {
 541             properties.minimumFractionDigits = -1;
 542             properties.maximumFractionDigits = -1;
 543             properties.roundingIncrement = 0.0;
 544         }
 545         properties.minimumSignificantDigits = -1;
 546         properties.maximumSignificantDigits = -1;
 547     } else {
 548         if (!ignoreRounding) {
 549             properties.minimumFractionDigits = minFrac;
 550             properties.maximumFractionDigits = positive.fractionTotal;
 551             properties.roundingIncrement = 0.0;
 552         } else {
 553             properties.minimumFractionDigits = -1;
 554             properties.maximumFractionDigits = -1;
 555             properties.roundingIncrement = 0.0;
 556         }
 557         properties.minimumSignificantDigits = -1;
 558         properties.maximumSignificantDigits = -1;
 559     }
 560 
 561     // If the pattern ends with a &#39;.&#39; then force the decimal point.
 562     if (positive.hasDecimal &amp;&amp; positive.fractionTotal == 0) {
 563         properties.decimalSeparatorAlwaysShown = true;
 564     } else {
 565         properties.decimalSeparatorAlwaysShown = false;
 566     }
 567 
 568     // Scientific notation settings
 569     if (positive.exponentZeros &gt; 0) {
 570         properties.exponentSignAlwaysShown = positive.exponentHasPlusSign;
 571         properties.minimumExponentDigits = positive.exponentZeros;
 572         if (positive.integerAtSigns == 0) {
 573             // patterns without &#39;@&#39; can define max integer digits, used for engineering notation
 574             properties.minimumIntegerDigits = positive.integerNumerals;
 575             properties.maximumIntegerDigits = positive.integerTotal;
 576         } else {
 577             // patterns with &#39;@&#39; cannot define max integer digits
 578             properties.minimumIntegerDigits = 1;
 579             properties.maximumIntegerDigits = -1;
 580         }
 581     } else {
 582         properties.exponentSignAlwaysShown = false;
 583         properties.minimumExponentDigits = -1;
 584         properties.minimumIntegerDigits = minInt;
 585         properties.maximumIntegerDigits = -1;
 586     }
 587 
 588     // Compute the affix patterns (required for both padding and affixes)
 589     UnicodeString posPrefix = patternInfo.getString(AffixPatternProvider::AFFIX_PREFIX);
 590     UnicodeString posSuffix = patternInfo.getString(0);
 591 
 592     // Padding settings
 593     if (positive.hasPadding) {
 594         // The width of the positive prefix and suffix templates are included in the padding
 595         int paddingWidth = positive.widthExceptAffixes +
 596                            AffixUtils::estimateLength(posPrefix, status) +
 597                            AffixUtils::estimateLength(posSuffix, status);
 598         properties.formatWidth = paddingWidth;
 599         UnicodeString rawPaddingString = patternInfo.getString(AffixPatternProvider::AFFIX_PADDING);
 600         if (rawPaddingString.length() == 1) {
 601             properties.padString = rawPaddingString;
 602         } else if (rawPaddingString.length() == 2) {
 603             if (rawPaddingString.charAt(0) == u&#39;\&#39;&#39;) {
 604                 properties.padString.setTo(u&quot;&#39;&quot;, -1);
 605             } else {
 606                 properties.padString = rawPaddingString;
 607             }
 608         } else {
 609             properties.padString = UnicodeString(rawPaddingString, 1, rawPaddingString.length() - 2);
 610         }
 611         properties.padPosition = positive.paddingLocation;
 612     } else {
 613         properties.formatWidth = -1;
 614         properties.padString.setToBogus();
 615         properties.padPosition.nullify();
 616     }
 617 
 618     // Set the affixes
 619     // Always call the setter, even if the prefixes are empty, especially in the case of the
 620     // negative prefix pattern, to prevent default values from overriding the pattern.
 621     properties.positivePrefixPattern = posPrefix;
 622     properties.positiveSuffixPattern = posSuffix;
 623     if (patternInfo.fHasNegativeSubpattern) {
 624         properties.negativePrefixPattern = patternInfo.getString(
 625                 AffixPatternProvider::AFFIX_NEGATIVE_SUBPATTERN | AffixPatternProvider::AFFIX_PREFIX);
 626         properties.negativeSuffixPattern = patternInfo.getString(
 627                 AffixPatternProvider::AFFIX_NEGATIVE_SUBPATTERN);
 628     } else {
 629         properties.negativePrefixPattern.setToBogus();
 630         properties.negativeSuffixPattern.setToBogus();
 631     }
 632 
 633     // Set the magnitude multiplier
 634     if (positive.hasPercentSign) {
 635         properties.magnitudeMultiplier = 2;
 636     } else if (positive.hasPerMilleSign) {
 637         properties.magnitudeMultiplier = 3;
 638     } else {
 639         properties.magnitudeMultiplier = 0;
 640     }
 641 }
 642 
 643 ///////////////////////////////////////////////////////////////////
 644 /// End PatternStringParser.java; begin PatternStringUtils.java ///
 645 ///////////////////////////////////////////////////////////////////
 646 
<a name="3" id="anc3"></a><span class="line-added"> 647 // Determine whether a given roundingIncrement should be ignored for formatting</span>
<span class="line-added"> 648 // based on the current maxFrac value (maximum fraction digits). For example a</span>
<span class="line-added"> 649 // roundingIncrement of 0.01 should be ignored if maxFrac is 1, but not if maxFrac</span>
<span class="line-added"> 650 // is 2 or more. Note that roundingIncrements are rounded in significance, so</span>
<span class="line-added"> 651 // a roundingIncrement of 0.006 is treated like 0.01 for this determination, i.e.</span>
<span class="line-added"> 652 // it should not be ignored if maxFrac is 2 or more (but a roundingIncrement of</span>
<span class="line-added"> 653 // 0.005 is treated like 0.001 for significance). This is the reason for the</span>
<span class="line-added"> 654 // initial doubling below.</span>
<span class="line-added"> 655 // roundIncr must be non-zero.</span>
<span class="line-added"> 656 bool PatternStringUtils::ignoreRoundingIncrement(double roundIncr, int32_t maxFrac) {</span>
<span class="line-added"> 657     if (maxFrac &lt; 0) {</span>
<span class="line-added"> 658         return false;</span>
<span class="line-added"> 659     }</span>
<span class="line-added"> 660     int32_t frac = 0;</span>
<span class="line-added"> 661     roundIncr *= 2.0;</span>
<span class="line-added"> 662     for (frac = 0; frac &lt;= maxFrac &amp;&amp; roundIncr &lt;= 1.0; frac++, roundIncr *= 10.0);</span>
<span class="line-added"> 663     return (frac &gt; maxFrac);</span>
<span class="line-added"> 664 }</span>
<span class="line-added"> 665 </span>
 666 UnicodeString PatternStringUtils::propertiesToPatternString(const DecimalFormatProperties&amp; properties,
 667                                                             UErrorCode&amp; status) {
 668     UnicodeString sb;
 669 
 670     // Convenience references
 671     // The uprv_min() calls prevent DoS
<a name="4" id="anc4"></a><span class="line-modified"> 672     int32_t dosMax = 100;</span>
<span class="line-modified"> 673     int32_t grouping1 = uprv_max(0, uprv_min(properties.groupingSize, dosMax));</span>
<span class="line-modified"> 674     int32_t grouping2 = uprv_max(0, uprv_min(properties.secondaryGroupingSize, dosMax));</span>
<span class="line-modified"> 675     bool useGrouping = properties.groupingUsed;</span>
<span class="line-added"> 676     int32_t paddingWidth = uprv_min(properties.formatWidth, dosMax);</span>
 677     NullableValue&lt;PadPosition&gt; paddingLocation = properties.padPosition;
 678     UnicodeString paddingString = properties.padString;
<a name="5" id="anc5"></a><span class="line-modified"> 679     int32_t minInt = uprv_max(0, uprv_min(properties.minimumIntegerDigits, dosMax));</span>
<span class="line-modified"> 680     int32_t maxInt = uprv_min(properties.maximumIntegerDigits, dosMax);</span>
<span class="line-modified"> 681     int32_t minFrac = uprv_max(0, uprv_min(properties.minimumFractionDigits, dosMax));</span>
<span class="line-modified"> 682     int32_t maxFrac = uprv_min(properties.maximumFractionDigits, dosMax);</span>
<span class="line-modified"> 683     int32_t minSig = uprv_min(properties.minimumSignificantDigits, dosMax);</span>
<span class="line-modified"> 684     int32_t maxSig = uprv_min(properties.maximumSignificantDigits, dosMax);</span>
 685     bool alwaysShowDecimal = properties.decimalSeparatorAlwaysShown;
<a name="6" id="anc6"></a><span class="line-modified"> 686     int32_t exponentDigits = uprv_min(properties.minimumExponentDigits, dosMax);</span>
 687     bool exponentShowPlusSign = properties.exponentSignAlwaysShown;
<a name="7" id="anc7"></a><span class="line-modified"> 688 </span>
<span class="line-modified"> 689     PropertiesAffixPatternProvider affixes(properties, status);</span>






 690 
 691     // Prefixes
<a name="8" id="anc8"></a><span class="line-modified"> 692     sb.append(affixes.getString(AffixPatternProvider::AFFIX_POS_PREFIX));</span>
<span class="line-modified"> 693     int32_t afterPrefixPos = sb.length();</span>



 694 
 695     // Figure out the grouping sizes.
<a name="9" id="anc9"></a><span class="line-modified"> 696     if (!useGrouping) {</span>















 697         grouping1 = 0;
 698         grouping2 = 0;
<a name="10" id="anc10"></a><span class="line-added"> 699     } else if (grouping1 == grouping2) {</span>
<span class="line-added"> 700         grouping1 = 0;</span>
 701     }
<a name="11" id="anc11"></a><span class="line-modified"> 702     int32_t groupingLength = grouping1 + grouping2 + 1;</span>
 703 
 704     // Figure out the digits we need to put in the pattern.
 705     double roundingInterval = properties.roundingIncrement;
 706     UnicodeString digitsString;
<a name="12" id="anc12"></a><span class="line-modified"> 707     int32_t digitsStringScale = 0;</span>
 708     if (maxSig != uprv_min(dosMax, -1)) {
 709         // Significant Digits.
 710         while (digitsString.length() &lt; minSig) {
 711             digitsString.append(u&#39;@&#39;);
 712         }
 713         while (digitsString.length() &lt; maxSig) {
 714             digitsString.append(u&#39;#&#39;);
 715         }
<a name="13" id="anc13"></a><span class="line-modified"> 716     } else if (roundingInterval != 0.0 &amp;&amp; !ignoreRoundingIncrement(roundingInterval,maxFrac)) {</span>
 717         // Rounding Interval.
<a name="14" id="anc14"></a><span class="line-modified"> 718         digitsStringScale = -roundingutils::doubleFractionLength(roundingInterval, nullptr);</span>
 719         // TODO: Check for DoS here?
 720         DecimalQuantity incrementQuantity;
 721         incrementQuantity.setToDouble(roundingInterval);
 722         incrementQuantity.adjustMagnitude(-digitsStringScale);
 723         incrementQuantity.roundToMagnitude(0, kDefaultMode, status);
 724         UnicodeString str = incrementQuantity.toPlainString();
 725         if (str.charAt(0) == u&#39;-&#39;) {
 726             // TODO: Unsupported operation exception or fail silently?
 727             digitsString.append(str, 1, str.length() - 1);
 728         } else {
 729             digitsString.append(str);
 730         }
 731     }
 732     while (digitsString.length() + digitsStringScale &lt; minInt) {
 733         digitsString.insert(0, u&#39;0&#39;);
 734     }
 735     while (-digitsStringScale &lt; minFrac) {
 736         digitsString.append(u&#39;0&#39;);
 737         digitsStringScale--;
 738     }
 739 
 740     // Write the digits to the string builder
<a name="15" id="anc15"></a><span class="line-modified"> 741     int32_t m0 = uprv_max(groupingLength, digitsString.length() + digitsStringScale);</span>
 742     m0 = (maxInt != dosMax) ? uprv_max(maxInt, m0) - 1 : m0 - 1;
<a name="16" id="anc16"></a><span class="line-modified"> 743     int32_t mN = (maxFrac != dosMax) ? uprv_min(-maxFrac, digitsStringScale) : digitsStringScale;</span>
<span class="line-modified"> 744     for (int32_t magnitude = m0; magnitude &gt;= mN; magnitude--) {</span>
<span class="line-modified"> 745         int32_t di = digitsString.length() + digitsStringScale - magnitude - 1;</span>
 746         if (di &lt; 0 || di &gt;= digitsString.length()) {
 747             sb.append(u&#39;#&#39;);
 748         } else {
 749             sb.append(digitsString.charAt(di));
 750         }
<a name="17" id="anc17"></a><span class="line-modified"> 751         // Decimal separator</span>
<span class="line-added"> 752         if (magnitude == 0 &amp;&amp; (alwaysShowDecimal || mN &lt; 0)) {</span>
<span class="line-added"> 753             sb.append(u&#39;.&#39;);</span>
<span class="line-added"> 754         }</span>
<span class="line-added"> 755         if (!useGrouping) {</span>
<span class="line-added"> 756             continue;</span>
<span class="line-added"> 757         }</span>
<span class="line-added"> 758         // Least-significant grouping separator</span>
<span class="line-added"> 759         if (magnitude &gt; 0 &amp;&amp; magnitude == grouping1) {</span>
 760             sb.append(u&#39;,&#39;);
<a name="18" id="anc18"></a><span class="line-modified"> 761         }</span>
<span class="line-added"> 762         // All other grouping separators</span>
<span class="line-added"> 763         if (magnitude &gt; grouping1 &amp;&amp; grouping2 &gt; 0 &amp;&amp; (magnitude - grouping1) % grouping2 == 0) {</span>
 764             sb.append(u&#39;,&#39;);
<a name="19" id="anc19"></a>

 765         }
 766     }
 767 
 768     // Exponential notation
 769     if (exponentDigits != uprv_min(dosMax, -1)) {
 770         sb.append(u&#39;E&#39;);
 771         if (exponentShowPlusSign) {
 772             sb.append(u&#39;+&#39;);
 773         }
<a name="20" id="anc20"></a><span class="line-modified"> 774         for (int32_t i = 0; i &lt; exponentDigits; i++) {</span>
 775             sb.append(u&#39;0&#39;);
 776         }
 777     }
 778 
 779     // Suffixes
<a name="21" id="anc21"></a><span class="line-modified"> 780     int32_t beforeSuffixPos = sb.length();</span>
<span class="line-modified"> 781     sb.append(affixes.getString(AffixPatternProvider::AFFIX_POS_SUFFIX));</span>



 782 
 783     // Resolve Padding
<a name="22" id="anc22"></a><span class="line-modified"> 784     if (paddingWidth &gt; 0 &amp;&amp; !paddingLocation.isNull()) {</span>
 785         while (paddingWidth - sb.length() &gt; 0) {
 786             sb.insert(afterPrefixPos, u&#39;#&#39;);
 787             beforeSuffixPos++;
 788         }
<a name="23" id="anc23"></a><span class="line-modified"> 789         int32_t addedLength;</span>
 790         switch (paddingLocation.get(status)) {
 791             case PadPosition::UNUM_PAD_BEFORE_PREFIX:
 792                 addedLength = escapePaddingString(paddingString, sb, 0, status);
 793                 sb.insert(0, u&#39;*&#39;);
 794                 afterPrefixPos += addedLength + 1;
 795                 beforeSuffixPos += addedLength + 1;
 796                 break;
 797             case PadPosition::UNUM_PAD_AFTER_PREFIX:
 798                 addedLength = escapePaddingString(paddingString, sb, afterPrefixPos, status);
 799                 sb.insert(afterPrefixPos, u&#39;*&#39;);
 800                 afterPrefixPos += addedLength + 1;
 801                 beforeSuffixPos += addedLength + 1;
 802                 break;
 803             case PadPosition::UNUM_PAD_BEFORE_SUFFIX:
 804                 escapePaddingString(paddingString, sb, beforeSuffixPos, status);
 805                 sb.insert(beforeSuffixPos, u&#39;*&#39;);
 806                 break;
 807             case PadPosition::UNUM_PAD_AFTER_SUFFIX:
 808                 sb.append(u&#39;*&#39;);
 809                 escapePaddingString(paddingString, sb, sb.length(), status);
 810                 break;
 811         }
 812         if (U_FAILURE(status)) { return sb; }
 813     }
 814 
 815     // Negative affixes
 816     // Ignore if the negative prefix pattern is &quot;-&quot; and the negative suffix is empty
<a name="24" id="anc24"></a><span class="line-modified"> 817     if (affixes.hasNegativeSubpattern()) {</span>

 818         sb.append(u&#39;;&#39;);
<a name="25" id="anc25"></a><span class="line-modified"> 819         sb.append(affixes.getString(AffixPatternProvider::AFFIX_NEG_PREFIX));</span>



 820         // Copy the positive digit format into the negative.
 821         // This is optional; the pattern is the same as if &#39;#&#39; were appended here instead.
 822         // NOTE: It is not safe to append the UnicodeString to itself, so we need to copy.
 823         // See http://bugs.icu-project.org/trac/ticket/13707
 824         UnicodeString copy(sb);
 825         sb.append(copy, afterPrefixPos, beforeSuffixPos - afterPrefixPos);
<a name="26" id="anc26"></a><span class="line-modified"> 826         sb.append(affixes.getString(AffixPatternProvider::AFFIX_NEG_SUFFIX));</span>



 827     }
 828 
 829     return sb;
 830 }
 831 
 832 int PatternStringUtils::escapePaddingString(UnicodeString input, UnicodeString&amp; output, int startIndex,
 833                                             UErrorCode&amp; status) {
 834     (void) status;
 835     if (input.length() == 0) {
 836         input.setTo(kFallbackPaddingString, -1);
 837     }
 838     int startLength = output.length();
 839     if (input.length() == 1) {
 840         if (input.compare(u&quot;&#39;&quot;, -1) == 0) {
 841             output.insert(startIndex, u&quot;&#39;&#39;&quot;, -1);
 842         } else {
 843             output.insert(startIndex, input);
 844         }
 845     } else {
 846         output.insert(startIndex, u&#39;\&#39;&#39;);
 847         int offset = 1;
 848         for (int i = 0; i &lt; input.length(); i++) {
 849             // it&#39;s okay to deal in chars here because the quote mark is the only interesting thing.
 850             char16_t ch = input.charAt(i);
 851             if (ch == u&#39;\&#39;&#39;) {
 852                 output.insert(startIndex + offset, u&quot;&#39;&#39;&quot;, -1);
 853                 offset += 2;
 854             } else {
 855                 output.insert(startIndex + offset, ch);
 856                 offset += 1;
 857             }
 858         }
 859         output.insert(startIndex + offset, u&#39;\&#39;&#39;);
 860     }
 861     return output.length() - startLength;
 862 }
 863 
 864 UnicodeString
 865 PatternStringUtils::convertLocalized(const UnicodeString&amp; input, const DecimalFormatSymbols&amp; symbols,
 866                                      bool toLocalized, UErrorCode&amp; status) {
 867     // Construct a table of strings to be converted between localized and standard.
 868     static constexpr int32_t LEN = 21;
 869     UnicodeString table[LEN][2];
 870     int standIdx = toLocalized ? 0 : 1;
 871     int localIdx = toLocalized ? 1 : 0;
 872     table[0][standIdx] = u&quot;%&quot;;
 873     table[0][localIdx] = symbols.getConstSymbol(DecimalFormatSymbols::kPercentSymbol);
 874     table[1][standIdx] = u&quot;‰&quot;;
 875     table[1][localIdx] = symbols.getConstSymbol(DecimalFormatSymbols::kPerMillSymbol);
 876     table[2][standIdx] = u&quot;.&quot;;
 877     table[2][localIdx] = symbols.getConstSymbol(DecimalFormatSymbols::kDecimalSeparatorSymbol);
 878     table[3][standIdx] = u&quot;,&quot;;
 879     table[3][localIdx] = symbols.getConstSymbol(DecimalFormatSymbols::kGroupingSeparatorSymbol);
 880     table[4][standIdx] = u&quot;-&quot;;
 881     table[4][localIdx] = symbols.getConstSymbol(DecimalFormatSymbols::kMinusSignSymbol);
 882     table[5][standIdx] = u&quot;+&quot;;
 883     table[5][localIdx] = symbols.getConstSymbol(DecimalFormatSymbols::kPlusSignSymbol);
 884     table[6][standIdx] = u&quot;;&quot;;
 885     table[6][localIdx] = symbols.getConstSymbol(DecimalFormatSymbols::kPatternSeparatorSymbol);
 886     table[7][standIdx] = u&quot;@&quot;;
 887     table[7][localIdx] = symbols.getConstSymbol(DecimalFormatSymbols::kSignificantDigitSymbol);
 888     table[8][standIdx] = u&quot;E&quot;;
 889     table[8][localIdx] = symbols.getConstSymbol(DecimalFormatSymbols::kExponentialSymbol);
 890     table[9][standIdx] = u&quot;*&quot;;
 891     table[9][localIdx] = symbols.getConstSymbol(DecimalFormatSymbols::kPadEscapeSymbol);
 892     table[10][standIdx] = u&quot;#&quot;;
 893     table[10][localIdx] = symbols.getConstSymbol(DecimalFormatSymbols::kDigitSymbol);
 894     for (int i = 0; i &lt; 10; i++) {
 895         table[11 + i][standIdx] = u&#39;0&#39; + i;
 896         table[11 + i][localIdx] = symbols.getConstDigitSymbol(i);
 897     }
 898 
 899     // Special case: quotes are NOT allowed to be in any localIdx strings.
 900     // Substitute them with &#39;’&#39; instead.
 901     for (int32_t i = 0; i &lt; LEN; i++) {
 902         table[i][localIdx].findAndReplace(u&#39;\&#39;&#39;, u&#39;’&#39;);
 903     }
 904 
 905     // Iterate through the string and convert.
 906     // State table:
 907     // 0 =&gt; base state
 908     // 1 =&gt; first char inside a quoted sequence in input and output string
 909     // 2 =&gt; inside a quoted sequence in input and output string
 910     // 3 =&gt; first char after a close quote in input string;
 911     // close quote still needs to be written to output string
 912     // 4 =&gt; base state in input string; inside quoted sequence in output string
 913     // 5 =&gt; first char inside a quoted sequence in input string;
 914     // inside quoted sequence in output string
 915     UnicodeString result;
 916     int state = 0;
 917     for (int offset = 0; offset &lt; input.length(); offset++) {
 918         UChar ch = input.charAt(offset);
 919 
 920         // Handle a quote character (state shift)
 921         if (ch == u&#39;\&#39;&#39;) {
 922             if (state == 0) {
 923                 result.append(u&#39;\&#39;&#39;);
 924                 state = 1;
 925                 continue;
 926             } else if (state == 1) {
 927                 result.append(u&#39;\&#39;&#39;);
 928                 state = 0;
 929                 continue;
 930             } else if (state == 2) {
 931                 state = 3;
 932                 continue;
 933             } else if (state == 3) {
 934                 result.append(u&#39;\&#39;&#39;);
 935                 result.append(u&#39;\&#39;&#39;);
 936                 state = 1;
 937                 continue;
 938             } else if (state == 4) {
 939                 state = 5;
 940                 continue;
 941             } else {
 942                 U_ASSERT(state == 5);
 943                 result.append(u&#39;\&#39;&#39;);
 944                 result.append(u&#39;\&#39;&#39;);
 945                 state = 4;
 946                 continue;
 947             }
 948         }
 949 
 950         if (state == 0 || state == 3 || state == 4) {
 951             for (auto&amp; pair : table) {
 952                 // Perform a greedy match on this symbol string
 953                 UnicodeString temp = input.tempSubString(offset, pair[0].length());
 954                 if (temp == pair[0]) {
 955                     // Skip ahead past this region for the next iteration
 956                     offset += pair[0].length() - 1;
 957                     if (state == 3 || state == 4) {
 958                         result.append(u&#39;\&#39;&#39;);
 959                         state = 0;
 960                     }
 961                     result.append(pair[1]);
 962                     goto continue_outer;
 963                 }
 964             }
 965             // No replacement found. Check if a special quote is necessary
 966             for (auto&amp; pair : table) {
 967                 UnicodeString temp = input.tempSubString(offset, pair[1].length());
 968                 if (temp == pair[1]) {
 969                     if (state == 0) {
 970                         result.append(u&#39;\&#39;&#39;);
 971                         state = 4;
 972                     }
 973                     result.append(ch);
 974                     goto continue_outer;
 975                 }
 976             }
 977             // Still nothing. Copy the char verbatim. (Add a close quote if necessary)
 978             if (state == 3 || state == 4) {
 979                 result.append(u&#39;\&#39;&#39;);
 980                 state = 0;
 981             }
 982             result.append(ch);
 983         } else {
 984             U_ASSERT(state == 1 || state == 2 || state == 5);
 985             result.append(ch);
 986             state = 2;
 987         }
 988         continue_outer:;
 989     }
 990     // Resolve final quotes
 991     if (state == 3 || state == 4) {
 992         result.append(u&#39;\&#39;&#39;);
 993         state = 0;
 994     }
 995     if (state != 0) {
 996         // Malformed localized pattern: unterminated quote
 997         status = U_PATTERN_SYNTAX_ERROR;
 998     }
 999     return result;
1000 }
1001 
1002 void PatternStringUtils::patternInfoToStringBuilder(const AffixPatternProvider&amp; patternInfo, bool isPrefix,
1003                                                     int8_t signum, UNumberSignDisplay signDisplay,
1004                                                     StandardPlural::Form plural,
1005                                                     bool perMilleReplacesPercent, UnicodeString&amp; output) {
1006 
1007     // Should the output render &#39;+&#39; where &#39;-&#39; would normally appear in the pattern?
1008     bool plusReplacesMinusSign = signum != -1 &amp;&amp; (
1009             signDisplay == UNUM_SIGN_ALWAYS || signDisplay == UNUM_SIGN_ACCOUNTING_ALWAYS || (
1010                     signum == 1 &amp;&amp; (
1011                             signDisplay == UNUM_SIGN_EXCEPT_ZERO ||
1012                             signDisplay == UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO))) &amp;&amp;
1013                                  patternInfo.positiveHasPlusSign() == false;
1014 
1015     // Should we use the affix from the negative subpattern? (If not, we will use the positive
1016     // subpattern.)
1017     bool useNegativeAffixPattern = patternInfo.hasNegativeSubpattern() &amp;&amp; (
1018             signum == -1 || (patternInfo.negativeHasMinusSign() &amp;&amp; plusReplacesMinusSign));
1019 
1020     // Resolve the flags for the affix pattern.
1021     int flags = 0;
1022     if (useNegativeAffixPattern) {
1023         flags |= AffixPatternProvider::AFFIX_NEGATIVE_SUBPATTERN;
1024     }
1025     if (isPrefix) {
1026         flags |= AffixPatternProvider::AFFIX_PREFIX;
1027     }
1028     if (plural != StandardPlural::Form::COUNT) {
1029         U_ASSERT(plural == (AffixPatternProvider::AFFIX_PLURAL_MASK &amp; plural));
1030         flags |= plural;
1031     }
1032 
1033     // Should we prepend a sign to the pattern?
1034     bool prependSign;
1035     if (!isPrefix || useNegativeAffixPattern) {
1036         prependSign = false;
1037     } else if (signum == -1) {
1038         prependSign = signDisplay != UNUM_SIGN_NEVER;
1039     } else {
1040         prependSign = plusReplacesMinusSign;
1041     }
1042 
1043     // Compute the length of the affix pattern.
1044     int length = patternInfo.length(flags) + (prependSign ? 1 : 0);
1045 
1046     // Finally, set the result into the StringBuilder.
1047     output.remove();
1048     for (int index = 0; index &lt; length; index++) {
1049         char16_t candidate;
1050         if (prependSign &amp;&amp; index == 0) {
1051             candidate = u&#39;-&#39;;
1052         } else if (prependSign) {
1053             candidate = patternInfo.charAt(flags, index - 1);
1054         } else {
1055             candidate = patternInfo.charAt(flags, index);
1056         }
1057         if (plusReplacesMinusSign &amp;&amp; candidate == u&#39;-&#39;) {
1058             candidate = u&#39;+&#39;;
1059         }
1060         if (perMilleReplacesPercent &amp;&amp; candidate == u&#39;%&#39;) {
1061             candidate = u&#39;‰&#39;;
1062         }
1063         output.append(candidate);
1064     }
1065 }
1066 
1067 #endif /* #if !UCONFIG_NO_FORMATTING */
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>