<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/nfrule.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ******************************************************************************
   5 *   Copyright (C) 1997-2015, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 ******************************************************************************
   8 *   file name:  nfrule.cpp
   9 *   encoding:   UTF-8
  10 *   tab size:   8 (not used)
  11 *   indentation:4
  12 *
  13 * Modification history
  14 * Date        Name      Comments
  15 * 10/11/2001  Doug      Ported from ICU4J
  16 */
  17 
  18 #include &quot;nfrule.h&quot;
  19 
  20 #if U_HAVE_RBNF
  21 
  22 #include &quot;unicode/localpointer.h&quot;
  23 #include &quot;unicode/rbnf.h&quot;
  24 #include &quot;unicode/tblcoll.h&quot;
  25 #include &quot;unicode/plurfmt.h&quot;
  26 #include &quot;unicode/upluralrules.h&quot;
  27 #include &quot;unicode/coleitr.h&quot;
  28 #include &quot;unicode/uchar.h&quot;
  29 #include &quot;nfrs.h&quot;
  30 #include &quot;nfrlist.h&quot;
  31 #include &quot;nfsubs.h&quot;
  32 #include &quot;patternprops.h&quot;
  33 #include &quot;putilimp.h&quot;
  34 
  35 U_NAMESPACE_BEGIN
  36 
  37 NFRule::NFRule(const RuleBasedNumberFormat* _rbnf, const UnicodeString &amp;_ruleText, UErrorCode &amp;status)
  38   : baseValue((int32_t)0)
  39   , radix(10)
  40   , exponent(0)
  41   , decimalPoint(0)
  42   , ruleText(_ruleText)
  43   , sub1(NULL)
  44   , sub2(NULL)
  45   , formatter(_rbnf)
  46   , rulePatternFormat(NULL)
  47 {
  48     if (!ruleText.isEmpty()) {
  49         parseRuleDescriptor(ruleText, status);
  50     }
  51 }
  52 
  53 NFRule::~NFRule()
  54 {
  55     if (sub1 != sub2) {
  56         delete sub2;
  57         sub2 = NULL;
  58     }
  59     delete sub1;
  60     sub1 = NULL;
  61     delete rulePatternFormat;
  62     rulePatternFormat = NULL;
  63 }
  64 
  65 static const UChar gLeftBracket = 0x005b;
  66 static const UChar gRightBracket = 0x005d;
  67 static const UChar gColon = 0x003a;
  68 static const UChar gZero = 0x0030;
  69 static const UChar gNine = 0x0039;
  70 static const UChar gSpace = 0x0020;
  71 static const UChar gSlash = 0x002f;
  72 static const UChar gGreaterThan = 0x003e;
  73 static const UChar gLessThan = 0x003c;
  74 static const UChar gComma = 0x002c;
  75 static const UChar gDot = 0x002e;
  76 static const UChar gTick = 0x0027;
  77 //static const UChar gMinus = 0x002d;
  78 static const UChar gSemicolon = 0x003b;
  79 static const UChar gX = 0x0078;
  80 
  81 static const UChar gMinusX[] =                  {0x2D, 0x78, 0};    /* &quot;-x&quot; */
  82 static const UChar gInf[] =                     {0x49, 0x6E, 0x66, 0}; /* &quot;Inf&quot; */
  83 static const UChar gNaN[] =                     {0x4E, 0x61, 0x4E, 0}; /* &quot;NaN&quot; */
  84 
  85 static const UChar gDollarOpenParenthesis[] =   {0x24, 0x28, 0}; /* &quot;$(&quot; */
  86 static const UChar gClosedParenthesisDollar[] = {0x29, 0x24, 0}; /* &quot;)$&quot; */
  87 
  88 static const UChar gLessLess[] =                {0x3C, 0x3C, 0};    /* &quot;&lt;&lt;&quot; */
  89 static const UChar gLessPercent[] =             {0x3C, 0x25, 0};    /* &quot;&lt;%&quot; */
  90 static const UChar gLessHash[] =                {0x3C, 0x23, 0};    /* &quot;&lt;#&quot; */
  91 static const UChar gLessZero[] =                {0x3C, 0x30, 0};    /* &quot;&lt;0&quot; */
  92 static const UChar gGreaterGreater[] =          {0x3E, 0x3E, 0};    /* &quot;&gt;&gt;&quot; */
  93 static const UChar gGreaterPercent[] =          {0x3E, 0x25, 0};    /* &quot;&gt;%&quot; */
  94 static const UChar gGreaterHash[] =             {0x3E, 0x23, 0};    /* &quot;&gt;#&quot; */
  95 static const UChar gGreaterZero[] =             {0x3E, 0x30, 0};    /* &quot;&gt;0&quot; */
  96 static const UChar gEqualPercent[] =            {0x3D, 0x25, 0};    /* &quot;=%&quot; */
  97 static const UChar gEqualHash[] =               {0x3D, 0x23, 0};    /* &quot;=#&quot; */
  98 static const UChar gEqualZero[] =               {0x3D, 0x30, 0};    /* &quot;=0&quot; */
  99 static const UChar gGreaterGreaterGreater[] =   {0x3E, 0x3E, 0x3E, 0}; /* &quot;&gt;&gt;&gt;&quot; */
 100 
 101 static const UChar * const RULE_PREFIXES[] = {
 102     gLessLess, gLessPercent, gLessHash, gLessZero,
 103     gGreaterGreater, gGreaterPercent,gGreaterHash, gGreaterZero,
 104     gEqualPercent, gEqualHash, gEqualZero, NULL
 105 };
 106 
 107 void
 108 NFRule::makeRules(UnicodeString&amp; description,
 109                   NFRuleSet *owner,
 110                   const NFRule *predecessor,
 111                   const RuleBasedNumberFormat *rbnf,
 112                   NFRuleList&amp; rules,
 113                   UErrorCode&amp; status)
 114 {
 115     // we know we&#39;re making at least one rule, so go ahead and
 116     // new it up and initialize its basevalue and divisor
 117     // (this also strips the rule descriptor, if any, off the
 118     // descripton string)
 119     NFRule* rule1 = new NFRule(rbnf, description, status);
 120     /* test for NULL */
 121     if (rule1 == 0) {
 122         status = U_MEMORY_ALLOCATION_ERROR;
 123         return;
 124     }
 125     description = rule1-&gt;ruleText;
 126 
 127     // check the description to see whether there&#39;s text enclosed
 128     // in brackets
 129     int32_t brack1 = description.indexOf(gLeftBracket);
 130     int32_t brack2 = brack1 &lt; 0 ? -1 : description.indexOf(gRightBracket);
 131 
 132     // if the description doesn&#39;t contain a matched pair of brackets,
 133     // or if it&#39;s of a type that doesn&#39;t recognize bracketed text,
 134     // then leave the description alone, initialize the rule&#39;s
 135     // rule text and substitutions, and return that rule
 136     if (brack2 &lt; 0 || brack1 &gt; brack2
 137         || rule1-&gt;getType() == kProperFractionRule
 138         || rule1-&gt;getType() == kNegativeNumberRule
 139         || rule1-&gt;getType() == kInfinityRule
 140         || rule1-&gt;getType() == kNaNRule)
 141     {
 142         rule1-&gt;extractSubstitutions(owner, description, predecessor, status);
 143     }
 144     else {
 145         // if the description does contain a matched pair of brackets,
 146         // then it&#39;s really shorthand for two rules (with one exception)
 147         NFRule* rule2 = NULL;
 148         UnicodeString sbuf;
 149 
 150         // we&#39;ll actually only split the rule into two rules if its
 151         // base value is an even multiple of its divisor (or it&#39;s one
 152         // of the special rules)
 153         if ((rule1-&gt;baseValue &gt; 0
 154             &amp;&amp; (rule1-&gt;baseValue % util64_pow(rule1-&gt;radix, rule1-&gt;exponent)) == 0)
 155             || rule1-&gt;getType() == kImproperFractionRule
 156             || rule1-&gt;getType() == kMasterRule) {
 157 
 158             // if it passes that test, new up the second rule.  If the
 159             // rule set both rules will belong to is a fraction rule
 160             // set, they both have the same base value; otherwise,
 161             // increment the original rule&#39;s base value (&quot;rule1&quot; actually
 162             // goes SECOND in the rule set&#39;s rule list)
 163             rule2 = new NFRule(rbnf, UnicodeString(), status);
 164             /* test for NULL */
 165             if (rule2 == 0) {
 166                 status = U_MEMORY_ALLOCATION_ERROR;
 167                 return;
 168             }
 169             if (rule1-&gt;baseValue &gt;= 0) {
 170                 rule2-&gt;baseValue = rule1-&gt;baseValue;
 171                 if (!owner-&gt;isFractionRuleSet()) {
 172                     ++rule1-&gt;baseValue;
 173                 }
 174             }
 175 
 176             // if the description began with &quot;x.x&quot; and contains bracketed
 177             // text, it describes both the improper fraction rule and
 178             // the proper fraction rule
 179             else if (rule1-&gt;getType() == kImproperFractionRule) {
 180                 rule2-&gt;setType(kProperFractionRule);
 181             }
 182 
 183             // if the description began with &quot;x.0&quot; and contains bracketed
 184             // text, it describes both the master rule and the
 185             // improper fraction rule
 186             else if (rule1-&gt;getType() == kMasterRule) {
 187                 rule2-&gt;baseValue = rule1-&gt;baseValue;
 188                 rule1-&gt;setType(kImproperFractionRule);
 189             }
 190 
 191             // both rules have the same radix and exponent (i.e., the
 192             // same divisor)
 193             rule2-&gt;radix = rule1-&gt;radix;
 194             rule2-&gt;exponent = rule1-&gt;exponent;
 195 
 196             // rule2&#39;s rule text omits the stuff in brackets: initalize
 197             // its rule text and substitutions accordingly
 198             sbuf.append(description, 0, brack1);
 199             if (brack2 + 1 &lt; description.length()) {
 200                 sbuf.append(description, brack2 + 1, description.length() - brack2 - 1);
 201             }
 202             rule2-&gt;extractSubstitutions(owner, sbuf, predecessor, status);
 203         }
 204 
 205         // rule1&#39;s text includes the text in the brackets but omits
 206         // the brackets themselves: initialize _its_ rule text and
 207         // substitutions accordingly
 208         sbuf.setTo(description, 0, brack1);
 209         sbuf.append(description, brack1 + 1, brack2 - brack1 - 1);
 210         if (brack2 + 1 &lt; description.length()) {
 211             sbuf.append(description, brack2 + 1, description.length() - brack2 - 1);
 212         }
 213         rule1-&gt;extractSubstitutions(owner, sbuf, predecessor, status);
 214 
 215         // if we only have one rule, return it; if we have two, return
 216         // a two-element array containing them (notice that rule2 goes
 217         // BEFORE rule1 in the list: in all cases, rule2 OMITS the
 218         // material in the brackets and rule1 INCLUDES the material
 219         // in the brackets)
 220         if (rule2 != NULL) {
 221             if (rule2-&gt;baseValue &gt;= kNoBase) {
 222                 rules.add(rule2);
 223             }
 224             else {
 225                 owner-&gt;setNonNumericalRule(rule2);
 226             }
 227         }
 228     }
 229     if (rule1-&gt;baseValue &gt;= kNoBase) {
 230         rules.add(rule1);
 231     }
 232     else {
 233         owner-&gt;setNonNumericalRule(rule1);
 234     }
 235 }
 236 
 237 /**
 238  * This function parses the rule&#39;s rule descriptor (i.e., the base
 239  * value and/or other tokens that precede the rule&#39;s rule text
 240  * in the description) and sets the rule&#39;s base value, radix, and
 241  * exponent according to the descriptor.  (If the description doesn&#39;t
 242  * include a rule descriptor, then this function sets everything to
 243  * default values and the rule set sets the rule&#39;s real base value).
 244  * @param description The rule&#39;s description
 245  * @return If &quot;description&quot; included a rule descriptor, this is
 246  * &quot;description&quot; with the descriptor and any trailing whitespace
 247  * stripped off.  Otherwise; it&#39;s &quot;descriptor&quot; unchangd.
 248  */
 249 void
 250 NFRule::parseRuleDescriptor(UnicodeString&amp; description, UErrorCode&amp; status)
 251 {
 252     // the description consists of a rule descriptor and a rule body,
 253     // separated by a colon.  The rule descriptor is optional.  If
 254     // it&#39;s omitted, just set the base value to 0.
 255     int32_t p = description.indexOf(gColon);
 256     if (p != -1) {
 257         // copy the descriptor out into its own string and strip it,
 258         // along with any trailing whitespace, out of the original
 259         // description
 260         UnicodeString descriptor;
 261         descriptor.setTo(description, 0, p);
 262 
 263         ++p;
 264         while (p &lt; description.length() &amp;&amp; PatternProps::isWhiteSpace(description.charAt(p))) {
 265             ++p;
 266         }
 267         description.removeBetween(0, p);
 268 
 269         // check first to see if the rule descriptor matches the token
 270         // for one of the special rules.  If it does, set the base
 271         // value to the correct identifier value
 272         int descriptorLength = descriptor.length();
 273         UChar firstChar = descriptor.charAt(0);
 274         UChar lastChar = descriptor.charAt(descriptorLength - 1);
 275         if (firstChar &gt;= gZero &amp;&amp; firstChar &lt;= gNine &amp;&amp; lastChar != gX) {
 276             // if the rule descriptor begins with a digit, it&#39;s a descriptor
 277             // for a normal rule
 278             // since we don&#39;t have Long.parseLong, and this isn&#39;t much work anyway,
 279             // just build up the value as we encounter the digits.
 280             int64_t val = 0;
 281             p = 0;
 282             UChar c = gSpace;
 283 
 284             // begin parsing the descriptor: copy digits
 285             // into &quot;tempValue&quot;, skip periods, commas, and spaces,
 286             // stop on a slash or &gt; sign (or at the end of the string),
 287             // and throw an exception on any other character
 288             int64_t ll_10 = 10;
 289             while (p &lt; descriptorLength) {
 290                 c = descriptor.charAt(p);
 291                 if (c &gt;= gZero &amp;&amp; c &lt;= gNine) {
 292                     val = val * ll_10 + (int32_t)(c - gZero);
 293                 }
 294                 else if (c == gSlash || c == gGreaterThan) {
 295                     break;
 296                 }
 297                 else if (PatternProps::isWhiteSpace(c) || c == gComma || c == gDot) {
 298                 }
 299                 else {
 300                     // throw new IllegalArgumentException(&quot;Illegal character in rule descriptor&quot;);
 301                     status = U_PARSE_ERROR;
 302                     return;
 303                 }
 304                 ++p;
 305             }
 306 
 307             // we have the base value, so set it
 308             setBaseValue(val, status);
 309 
 310             // if we stopped the previous loop on a slash, we&#39;re
 311             // now parsing the rule&#39;s radix.  Again, accumulate digits
 312             // in tempValue, skip punctuation, stop on a &gt; mark, and
 313             // throw an exception on anything else
 314             if (c == gSlash) {
 315                 val = 0;
 316                 ++p;
 317                 int64_t ll_10 = 10;
 318                 while (p &lt; descriptorLength) {
 319                     c = descriptor.charAt(p);
 320                     if (c &gt;= gZero &amp;&amp; c &lt;= gNine) {
 321                         val = val * ll_10 + (int32_t)(c - gZero);
 322                     }
 323                     else if (c == gGreaterThan) {
 324                         break;
 325                     }
 326                     else if (PatternProps::isWhiteSpace(c) || c == gComma || c == gDot) {
 327                     }
 328                     else {
 329                         // throw new IllegalArgumentException(&quot;Illegal character is rule descriptor&quot;);
 330                         status = U_PARSE_ERROR;
 331                         return;
 332                     }
 333                     ++p;
 334                 }
 335 
 336                 // tempValue now contain&#39;s the rule&#39;s radix.  Set it
 337                 // accordingly, and recalculate the rule&#39;s exponent
 338                 radix = (int32_t)val;
 339                 if (radix == 0) {
 340                     // throw new IllegalArgumentException(&quot;Rule can&#39;t have radix of 0&quot;);
 341                     status = U_PARSE_ERROR;
 342                 }
 343 
 344                 exponent = expectedExponent();
 345             }
 346 
 347             // if we stopped the previous loop on a &gt; sign, then continue
 348             // for as long as we still see &gt; signs.  For each one,
 349             // decrement the exponent (unless the exponent is already 0).
 350             // If we see another character before reaching the end of
 351             // the descriptor, that&#39;s also a syntax error.
 352             if (c == gGreaterThan) {
 353                 while (p &lt; descriptor.length()) {
 354                     c = descriptor.charAt(p);
 355                     if (c == gGreaterThan &amp;&amp; exponent &gt; 0) {
 356                         --exponent;
 357                     } else {
 358                         // throw new IllegalArgumentException(&quot;Illegal character in rule descriptor&quot;);
 359                         status = U_PARSE_ERROR;
 360                         return;
 361                     }
 362                     ++p;
 363                 }
 364             }
 365         }
 366         else if (0 == descriptor.compare(gMinusX, 2)) {
 367             setType(kNegativeNumberRule);
 368         }
 369         else if (descriptorLength == 3) {
 370             if (firstChar == gZero &amp;&amp; lastChar == gX) {
 371                 setBaseValue(kProperFractionRule, status);
 372                 decimalPoint = descriptor.charAt(1);
 373             }
 374             else if (firstChar == gX &amp;&amp; lastChar == gX) {
 375                 setBaseValue(kImproperFractionRule, status);
 376                 decimalPoint = descriptor.charAt(1);
 377             }
 378             else if (firstChar == gX &amp;&amp; lastChar == gZero) {
 379                 setBaseValue(kMasterRule, status);
 380                 decimalPoint = descriptor.charAt(1);
 381             }
 382             else if (descriptor.compare(gNaN, 3) == 0) {
 383                 setBaseValue(kNaNRule, status);
 384             }
 385             else if (descriptor.compare(gInf, 3) == 0) {
 386                 setBaseValue(kInfinityRule, status);
 387             }
 388         }
 389     }
 390     // else use the default base value for now.
 391 
 392     // finally, if the rule body begins with an apostrophe, strip it off
 393     // (this is generally used to put whitespace at the beginning of
 394     // a rule&#39;s rule text)
 395     if (description.length() &gt; 0 &amp;&amp; description.charAt(0) == gTick) {
 396         description.removeBetween(0, 1);
 397     }
 398 
 399     // return the description with all the stuff we&#39;ve just waded through
 400     // stripped off the front.  It now contains just the rule body.
 401     // return description;
 402 }
 403 
 404 /**
 405 * Searches the rule&#39;s rule text for the substitution tokens,
 406 * creates the substitutions, and removes the substitution tokens
 407 * from the rule&#39;s rule text.
 408 * @param owner The rule set containing this rule
 409 * @param predecessor The rule preseding this one in &quot;owners&quot; rule list
 410 * @param ownersOwner The RuleBasedFormat that owns this rule
 411 */
 412 void
 413 NFRule::extractSubstitutions(const NFRuleSet* ruleSet,
 414                              const UnicodeString &amp;ruleText,
 415                              const NFRule* predecessor,
 416                              UErrorCode&amp; status)
 417 {
 418     if (U_FAILURE(status)) {
 419         return;
 420     }
 421     this-&gt;ruleText = ruleText;
 422     sub1 = extractSubstitution(ruleSet, predecessor, status);
 423     if (sub1 == NULL) {
 424         // Small optimization. There is no need to create a redundant NullSubstitution.
 425         sub2 = NULL;
 426     }
 427     else {
 428         sub2 = extractSubstitution(ruleSet, predecessor, status);
 429     }
 430     int32_t pluralRuleStart = this-&gt;ruleText.indexOf(gDollarOpenParenthesis, -1, 0);
 431     int32_t pluralRuleEnd = (pluralRuleStart &gt;= 0 ? this-&gt;ruleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart) : -1);
 432     if (pluralRuleEnd &gt;= 0) {
 433         int32_t endType = this-&gt;ruleText.indexOf(gComma, pluralRuleStart);
 434         if (endType &lt; 0) {
 435             status = U_PARSE_ERROR;
 436             return;
 437         }
 438         UnicodeString type(this-&gt;ruleText.tempSubString(pluralRuleStart + 2, endType - pluralRuleStart - 2));
 439         UPluralType pluralType;
 440         if (type.startsWith(UNICODE_STRING_SIMPLE(&quot;cardinal&quot;))) {
 441             pluralType = UPLURAL_TYPE_CARDINAL;
 442         }
 443         else if (type.startsWith(UNICODE_STRING_SIMPLE(&quot;ordinal&quot;))) {
 444             pluralType = UPLURAL_TYPE_ORDINAL;
 445         }
 446         else {
 447             status = U_ILLEGAL_ARGUMENT_ERROR;
 448             return;
 449         }
 450         rulePatternFormat = formatter-&gt;createPluralFormat(pluralType,
 451                 this-&gt;ruleText.tempSubString(endType + 1, pluralRuleEnd - endType - 1), status);
 452     }
 453 }
 454 
 455 /**
 456 * Searches the rule&#39;s rule text for the first substitution token,
 457 * creates a substitution based on it, and removes the token from
 458 * the rule&#39;s rule text.
 459 * @param owner The rule set containing this rule
 460 * @param predecessor The rule preceding this one in the rule set&#39;s
 461 * rule list
 462 * @param ownersOwner The RuleBasedNumberFormat that owns this rule
 463 * @return The newly-created substitution.  This is never null; if
 464 * the rule text doesn&#39;t contain any substitution tokens, this will
 465 * be a NullSubstitution.
 466 */
 467 NFSubstitution *
 468 NFRule::extractSubstitution(const NFRuleSet* ruleSet,
 469                             const NFRule* predecessor,
 470                             UErrorCode&amp; status)
 471 {
 472     NFSubstitution* result = NULL;
 473 
 474     // search the rule&#39;s rule text for the first two characters of
 475     // a substitution token
 476     int32_t subStart = indexOfAnyRulePrefix();
 477     int32_t subEnd = subStart;
 478 
 479     // if we didn&#39;t find one, create a null substitution positioned
 480     // at the end of the rule text
 481     if (subStart == -1) {
 482         return NULL;
 483     }
 484 
 485     // special-case the &quot;&gt;&gt;&gt;&quot; token, since searching for the &gt; at the
 486     // end will actually find the &gt; in the middle
 487     if (ruleText.indexOf(gGreaterGreaterGreater, 3, 0) == subStart) {
 488         subEnd = subStart + 2;
 489 
 490         // otherwise the substitution token ends with the same character
 491         // it began with
 492     } else {
 493         UChar c = ruleText.charAt(subStart);
 494         subEnd = ruleText.indexOf(c, subStart + 1);
 495         // special case for &#39;&lt;%foo&lt;&lt;&#39;
 496         if (c == gLessThan &amp;&amp; subEnd != -1 &amp;&amp; subEnd &lt; ruleText.length() - 1 &amp;&amp; ruleText.charAt(subEnd+1) == c) {
 497             // ordinals use &quot;=#,##0==%abbrev=&quot; as their rule.  Notice that the &#39;==&#39; in the middle
 498             // occurs because of the juxtaposition of two different rules.  The check for &#39;&lt;&#39; is a hack
 499             // to get around this.  Having the duplicate at the front would cause problems with
 500             // rules like &quot;&lt;&lt;%&quot; to format, say, percents...
 501             ++subEnd;
 502         }
 503    }
 504 
 505     // if we don&#39;t find the end of the token (i.e., if we&#39;re on a single,
 506     // unmatched token character), create a null substitution positioned
 507     // at the end of the rule
 508     if (subEnd == -1) {
 509         return NULL;
 510     }
 511 
 512     // if we get here, we have a real substitution token (or at least
 513     // some text bounded by substitution token characters).  Use
 514     // makeSubstitution() to create the right kind of substitution
 515     UnicodeString subToken;
 516     subToken.setTo(ruleText, subStart, subEnd + 1 - subStart);
 517     result = NFSubstitution::makeSubstitution(subStart, this, predecessor, ruleSet,
 518         this-&gt;formatter, subToken, status);
 519 
 520     // remove the substitution from the rule text
 521     ruleText.removeBetween(subStart, subEnd+1);
 522 
 523     return result;
 524 }
 525 
 526 /**
 527  * Sets the rule&#39;s base value, and causes the radix and exponent
 528  * to be recalculated.  This is used during construction when we
 529  * don&#39;t know the rule&#39;s base value until after it&#39;s been
 530  * constructed.  It should be used at any other time.
 531  * @param The new base value for the rule.
 532  */
 533 void
 534 NFRule::setBaseValue(int64_t newBaseValue, UErrorCode&amp; status)
 535 {
 536     // set the base value
 537     baseValue = newBaseValue;
 538     radix = 10;
 539 
 540     // if this isn&#39;t a special rule, recalculate the radix and exponent
 541     // (the radix always defaults to 10; if it&#39;s supposed to be something
 542     // else, it&#39;s cleaned up by the caller and the exponent is
 543     // recalculated again-- the only function that does this is
 544     // NFRule.parseRuleDescriptor() )
 545     if (baseValue &gt;= 1) {
 546         exponent = expectedExponent();
 547 
 548         // this function gets called on a fully-constructed rule whose
 549         // description didn&#39;t specify a base value.  This means it
 550         // has substitutions, and some substitutions hold on to copies
 551         // of the rule&#39;s divisor.  Fix their copies of the divisor.
 552         if (sub1 != NULL) {
 553             sub1-&gt;setDivisor(radix, exponent, status);
 554         }
 555         if (sub2 != NULL) {
 556             sub2-&gt;setDivisor(radix, exponent, status);
 557         }
 558 
 559         // if this is a special rule, its radix and exponent are basically
 560         // ignored.  Set them to &quot;safe&quot; default values
 561     } else {
 562         exponent = 0;
 563     }
 564 }
 565 
 566 /**
 567 * This calculates the rule&#39;s exponent based on its radix and base
 568 * value.  This will be the highest power the radix can be raised to
 569 * and still produce a result less than or equal to the base value.
 570 */
 571 int16_t
 572 NFRule::expectedExponent() const
 573 {
 574     // since the log of 0, or the log base 0 of something, causes an
 575     // error, declare the exponent in these cases to be 0 (we also
 576     // deal with the special-rule identifiers here)
 577     if (radix == 0 || baseValue &lt; 1) {
 578         return 0;
 579     }
 580 
 581     // we get rounding error in some cases-- for example, log 1000 / log 10
 582     // gives us 1.9999999996 instead of 2.  The extra logic here is to take
 583     // that into account
 584     int16_t tempResult = (int16_t)(uprv_log((double)baseValue) / uprv_log((double)radix));
 585     int64_t temp = util64_pow(radix, tempResult + 1);
 586     if (temp &lt;= baseValue) {
 587         tempResult += 1;
 588     }
 589     return tempResult;
 590 }
 591 
 592 /**
 593  * Searches the rule&#39;s rule text for any of the specified strings.
 594  * @return The index of the first match in the rule&#39;s rule text
 595  * (i.e., the first substring in the rule&#39;s rule text that matches
 596  * _any_ of the strings in &quot;strings&quot;).  If none of the strings in
 597  * &quot;strings&quot; is found in the rule&#39;s rule text, returns -1.
 598  */
 599 int32_t
 600 NFRule::indexOfAnyRulePrefix() const
 601 {
 602     int result = -1;
 603     for (int i = 0; RULE_PREFIXES[i]; i++) {
 604         int32_t pos = ruleText.indexOf(*RULE_PREFIXES[i]);
 605         if (pos != -1 &amp;&amp; (result == -1 || pos &lt; result)) {
 606             result = pos;
 607         }
 608     }
 609     return result;
 610 }
 611 
 612 //-----------------------------------------------------------------------
 613 // boilerplate
 614 //-----------------------------------------------------------------------
 615 
 616 static UBool
 617 util_equalSubstitutions(const NFSubstitution* sub1, const NFSubstitution* sub2)
 618 {
 619     if (sub1) {
 620         if (sub2) {
 621             return *sub1 == *sub2;
 622         }
 623     } else if (!sub2) {
 624         return TRUE;
 625     }
 626     return FALSE;
 627 }
 628 
 629 /**
 630 * Tests two rules for equality.
 631 * @param that The rule to compare this one against
 632 * @return True is the two rules are functionally equivalent
 633 */
 634 UBool
 635 NFRule::operator==(const NFRule&amp; rhs) const
 636 {
 637     return baseValue == rhs.baseValue
 638         &amp;&amp; radix == rhs.radix
 639         &amp;&amp; exponent == rhs.exponent
 640         &amp;&amp; ruleText == rhs.ruleText
 641         &amp;&amp; util_equalSubstitutions(sub1, rhs.sub1)
 642         &amp;&amp; util_equalSubstitutions(sub2, rhs.sub2);
 643 }
 644 
 645 /**
 646 * Returns a textual representation of the rule.  This won&#39;t
 647 * necessarily be the same as the description that this rule
 648 * was created with, but it will produce the same result.
 649 * @return A textual description of the rule
 650 */
 651 static void util_append64(UnicodeString&amp; result, int64_t n)
 652 {
 653     UChar buffer[256];
 654     int32_t len = util64_tou(n, buffer, sizeof(buffer));
 655     UnicodeString temp(buffer, len);
 656     result.append(temp);
 657 }
 658 
 659 void
 660 NFRule::_appendRuleText(UnicodeString&amp; result) const
 661 {
 662     switch (getType()) {
 663     case kNegativeNumberRule: result.append(gMinusX, 2); break;
 664     case kImproperFractionRule: result.append(gX).append(decimalPoint == 0 ? gDot : decimalPoint).append(gX); break;
 665     case kProperFractionRule: result.append(gZero).append(decimalPoint == 0 ? gDot : decimalPoint).append(gX); break;
 666     case kMasterRule: result.append(gX).append(decimalPoint == 0 ? gDot : decimalPoint).append(gZero); break;
 667     case kInfinityRule: result.append(gInf, 3); break;
 668     case kNaNRule: result.append(gNaN, 3); break;
 669     default:
 670         // for a normal rule, write out its base value, and if the radix is
 671         // something other than 10, write out the radix (with the preceding
 672         // slash, of course).  Then calculate the expected exponent and if
 673         // if isn&#39;t the same as the actual exponent, write an appropriate
 674         // number of &gt; signs.  Finally, terminate the whole thing with
 675         // a colon.
 676         util_append64(result, baseValue);
 677         if (radix != 10) {
 678             result.append(gSlash);
 679             util_append64(result, radix);
 680         }
 681         int numCarets = expectedExponent() - exponent;
 682         for (int i = 0; i &lt; numCarets; i++) {
 683             result.append(gGreaterThan);
 684         }
 685         break;
 686     }
 687     result.append(gColon);
 688     result.append(gSpace);
 689 
 690     // if the rule text begins with a space, write an apostrophe
 691     // (whitespace after the rule descriptor is ignored; the
 692     // apostrophe is used to make the whitespace significant)
 693     if (ruleText.charAt(0) == gSpace &amp;&amp; (sub1 == NULL || sub1-&gt;getPos() != 0)) {
 694         result.append(gTick);
 695     }
 696 
 697     // now, write the rule&#39;s rule text, inserting appropriate
 698     // substitution tokens in the appropriate places
 699     UnicodeString ruleTextCopy;
 700     ruleTextCopy.setTo(ruleText);
 701 
 702     UnicodeString temp;
 703     if (sub2 != NULL) {
 704         sub2-&gt;toString(temp);
 705         ruleTextCopy.insert(sub2-&gt;getPos(), temp);
 706     }
 707     if (sub1 != NULL) {
 708         sub1-&gt;toString(temp);
 709         ruleTextCopy.insert(sub1-&gt;getPos(), temp);
 710     }
 711 
 712     result.append(ruleTextCopy);
 713 
 714     // and finally, top the whole thing off with a semicolon and
 715     // return the result
 716     result.append(gSemicolon);
 717 }
 718 
 719 int64_t NFRule::getDivisor() const
 720 {
 721     return util64_pow(radix, exponent);
 722 }
 723 
 724 
 725 //-----------------------------------------------------------------------
 726 // formatting
 727 //-----------------------------------------------------------------------
 728 
 729 /**
 730 * Formats the number, and inserts the resulting text into
 731 * toInsertInto.
 732 * @param number The number being formatted
 733 * @param toInsertInto The string where the resultant text should
 734 * be inserted
 735 * @param pos The position in toInsertInto where the resultant text
 736 * should be inserted
 737 */
 738 void
 739 NFRule::doFormat(int64_t number, UnicodeString&amp; toInsertInto, int32_t pos, int32_t recursionCount, UErrorCode&amp; status) const
 740 {
 741     // first, insert the rule&#39;s rule text into toInsertInto at the
 742     // specified position, then insert the results of the substitutions
 743     // into the right places in toInsertInto (notice we do the
 744     // substitutions in reverse order so that the offsets don&#39;t get
 745     // messed up)
 746     int32_t pluralRuleStart = ruleText.length();
 747     int32_t lengthOffset = 0;
 748     if (!rulePatternFormat) {
 749         toInsertInto.insert(pos, ruleText);
 750     }
 751     else {
 752         pluralRuleStart = ruleText.indexOf(gDollarOpenParenthesis, -1, 0);
 753         int pluralRuleEnd = ruleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart);
 754         int initialLength = toInsertInto.length();
 755         if (pluralRuleEnd &lt; ruleText.length() - 1) {
 756             toInsertInto.insert(pos, ruleText.tempSubString(pluralRuleEnd + 2));
 757         }
 758         toInsertInto.insert(pos,
 759             rulePatternFormat-&gt;format((int32_t)(number/util64_pow(radix, exponent)), status));
 760         if (pluralRuleStart &gt; 0) {
 761             toInsertInto.insert(pos, ruleText.tempSubString(0, pluralRuleStart));
 762         }
 763         lengthOffset = ruleText.length() - (toInsertInto.length() - initialLength);
 764     }
 765 
 766     if (sub2 != NULL) {
 767         sub2-&gt;doSubstitution(number, toInsertInto, pos - (sub2-&gt;getPos() &gt; pluralRuleStart ? lengthOffset : 0), recursionCount, status);
 768     }
 769     if (sub1 != NULL) {
 770         sub1-&gt;doSubstitution(number, toInsertInto, pos - (sub1-&gt;getPos() &gt; pluralRuleStart ? lengthOffset : 0), recursionCount, status);
 771     }
 772 }
 773 
 774 /**
 775 * Formats the number, and inserts the resulting text into
 776 * toInsertInto.
 777 * @param number The number being formatted
 778 * @param toInsertInto The string where the resultant text should
 779 * be inserted
 780 * @param pos The position in toInsertInto where the resultant text
 781 * should be inserted
 782 */
 783 void
 784 NFRule::doFormat(double number, UnicodeString&amp; toInsertInto, int32_t pos, int32_t recursionCount, UErrorCode&amp; status) const
 785 {
 786     // first, insert the rule&#39;s rule text into toInsertInto at the
 787     // specified position, then insert the results of the substitutions
 788     // into the right places in toInsertInto
 789     // [again, we have two copies of this routine that do the same thing
 790     // so that we don&#39;t sacrifice precision in a long by casting it
 791     // to a double]
 792     int32_t pluralRuleStart = ruleText.length();
 793     int32_t lengthOffset = 0;
 794     if (!rulePatternFormat) {
 795         toInsertInto.insert(pos, ruleText);
 796     }
 797     else {
 798         pluralRuleStart = ruleText.indexOf(gDollarOpenParenthesis, -1, 0);
 799         int pluralRuleEnd = ruleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart);
 800         int initialLength = toInsertInto.length();
 801         if (pluralRuleEnd &lt; ruleText.length() - 1) {
 802             toInsertInto.insert(pos, ruleText.tempSubString(pluralRuleEnd + 2));
 803         }
 804         double pluralVal = number;
 805         if (0 &lt;= pluralVal &amp;&amp; pluralVal &lt; 1) {
 806             // We&#39;re in a fractional rule, and we have to match the NumeratorSubstitution behavior.
 807             // 2.3 can become 0.2999999999999998 for the fraction due to rounding errors.
 808             pluralVal = uprv_round(pluralVal * util64_pow(radix, exponent));
 809         }
 810         else {
 811             pluralVal = pluralVal / util64_pow(radix, exponent);
 812         }
 813         toInsertInto.insert(pos, rulePatternFormat-&gt;format((int32_t)(pluralVal), status));
 814         if (pluralRuleStart &gt; 0) {
 815             toInsertInto.insert(pos, ruleText.tempSubString(0, pluralRuleStart));
 816         }
 817         lengthOffset = ruleText.length() - (toInsertInto.length() - initialLength);
 818     }
 819 
 820     if (sub2 != NULL) {
 821         sub2-&gt;doSubstitution(number, toInsertInto, pos - (sub2-&gt;getPos() &gt; pluralRuleStart ? lengthOffset : 0), recursionCount, status);
 822     }
 823     if (sub1 != NULL) {
 824         sub1-&gt;doSubstitution(number, toInsertInto, pos - (sub1-&gt;getPos() &gt; pluralRuleStart ? lengthOffset : 0), recursionCount, status);
 825     }
 826 }
 827 
 828 /**
 829 * Used by the owning rule set to determine whether to invoke the
 830 * rollback rule (i.e., whether this rule or the one that precedes
 831 * it in the rule set&#39;s list should be used to format the number)
 832 * @param The number being formatted
 833 * @return True if the rule set should use the rule that precedes
 834 * this one in its list; false if it should use this rule
 835 */
 836 UBool
 837 NFRule::shouldRollBack(int64_t number) const
 838 {
 839     // we roll back if the rule contains a modulus substitution,
 840     // the number being formatted is an even multiple of the rule&#39;s
 841     // divisor, and the rule&#39;s base value is NOT an even multiple
 842     // of its divisor
 843     // In other words, if the original description had
 844     //    100: &lt;&lt; hundred[ &gt;&gt;];
 845     // that expands into
 846     //    100: &lt;&lt; hundred;
 847     //    101: &lt;&lt; hundred &gt;&gt;;
 848     // internally.  But when we&#39;re formatting 200, if we use the rule
 849     // at 101, which would normally apply, we get &quot;two hundred zero&quot;.
 850     // To prevent this, we roll back and use the rule at 100 instead.
 851     // This is the logic that makes this happen: the rule at 101 has
 852     // a modulus substitution, its base value isn&#39;t an even multiple
 853     // of 100, and the value we&#39;re trying to format _is_ an even
 854     // multiple of 100.  This is called the &quot;rollback rule.&quot;
 855     if ((sub1 != NULL &amp;&amp; sub1-&gt;isModulusSubstitution()) || (sub2 != NULL &amp;&amp; sub2-&gt;isModulusSubstitution())) {
 856         int64_t re = util64_pow(radix, exponent);
 857         return (number % re) == 0 &amp;&amp; (baseValue % re) != 0;
 858     }
 859     return FALSE;
 860 }
 861 
 862 //-----------------------------------------------------------------------
 863 // parsing
 864 //-----------------------------------------------------------------------
 865 
 866 /**
 867 * Attempts to parse the string with this rule.
 868 * @param text The string being parsed
 869 * @param parsePosition On entry, the value is ignored and assumed to
 870 * be 0. On exit, this has been updated with the position of the first
 871 * character not consumed by matching the text against this rule
 872 * (if this rule doesn&#39;t match the text at all, the parse position
 873 * if left unchanged (presumably at 0) and the function returns
 874 * new Long(0)).
 875 * @param isFractionRule True if this rule is contained within a
 876 * fraction rule set.  This is only used if the rule has no
 877 * substitutions.
 878 * @return If this rule matched the text, this is the rule&#39;s base value
 879 * combined appropriately with the results of parsing the substitutions.
 880 * If nothing matched, this is new Long(0) and the parse position is
 881 * left unchanged.  The result will be an instance of Long if the
 882 * result is an integer and Double otherwise.  The result is never null.
 883 */
 884 #ifdef RBNF_DEBUG
 885 #include &lt;stdio.h&gt;
 886 
 887 static void dumpUS(FILE* f, const UnicodeString&amp; us) {
 888   int len = us.length();
 889   char* buf = (char *)uprv_malloc((len+1)*sizeof(char)); //new char[len+1];
 890   if (buf != NULL) {
 891       us.extract(0, len, buf);
 892       buf[len] = 0;
 893       fprintf(f, &quot;%s&quot;, buf);
 894       uprv_free(buf); //delete[] buf;
 895   }
 896 }
 897 #endif
 898 UBool
 899 NFRule::doParse(const UnicodeString&amp; text,
 900                 ParsePosition&amp; parsePosition,
 901                 UBool isFractionRule,
 902                 double upperBound,
 903                 uint32_t nonNumericalExecutedRuleMask,
 904                 Formattable&amp; resVal) const
 905 {
 906     // internally we operate on a copy of the string being parsed
 907     // (because we&#39;re going to change it) and use our own ParsePosition
 908     ParsePosition pp;
 909     UnicodeString workText(text);
 910 
 911     int32_t sub1Pos = sub1 != NULL ? sub1-&gt;getPos() : ruleText.length();
 912     int32_t sub2Pos = sub2 != NULL ? sub2-&gt;getPos() : ruleText.length();
 913 
 914     // check to see whether the text before the first substitution
 915     // matches the text at the beginning of the string being
 916     // parsed.  If it does, strip that off the front of workText;
 917     // otherwise, dump out with a mismatch
 918     UnicodeString prefix;
 919     prefix.setTo(ruleText, 0, sub1Pos);
 920 
 921 #ifdef RBNF_DEBUG
 922     fprintf(stderr, &quot;doParse %p &quot;, this);
 923     {
 924         UnicodeString rt;
 925         _appendRuleText(rt);
 926         dumpUS(stderr, rt);
 927     }
 928 
 929     fprintf(stderr, &quot; text: &#39;&quot;);
 930     dumpUS(stderr, text);
 931     fprintf(stderr, &quot;&#39; prefix: &#39;&quot;);
 932     dumpUS(stderr, prefix);
 933 #endif
 934     stripPrefix(workText, prefix, pp);
 935     int32_t prefixLength = text.length() - workText.length();
 936 
 937 #ifdef RBNF_DEBUG
 938     fprintf(stderr, &quot;&#39; pl: %d ppi: %d s1p: %d\n&quot;, prefixLength, pp.getIndex(), sub1Pos);
 939 #endif
 940 
 941     if (pp.getIndex() == 0 &amp;&amp; sub1Pos != 0) {
 942         // commented out because ParsePosition doesn&#39;t have error index in 1.1.x
 943         // restored for ICU4C port
 944         parsePosition.setErrorIndex(pp.getErrorIndex());
 945         resVal.setLong(0);
 946         return TRUE;
 947     }
 948     if (baseValue == kInfinityRule) {
 949         // If you match this, don&#39;t try to perform any calculations on it.
 950         parsePosition.setIndex(pp.getIndex());
 951         resVal.setDouble(uprv_getInfinity());
 952         return TRUE;
 953     }
 954     if (baseValue == kNaNRule) {
 955         // If you match this, don&#39;t try to perform any calculations on it.
 956         parsePosition.setIndex(pp.getIndex());
 957         resVal.setDouble(uprv_getNaN());
 958         return TRUE;
 959     }
 960 
 961     // this is the fun part.  The basic guts of the rule-matching
 962     // logic is matchToDelimiter(), which is called twice.  The first
 963     // time it searches the input string for the rule text BETWEEN
 964     // the substitutions and tries to match the intervening text
 965     // in the input string with the first substitution.  If that
 966     // succeeds, it then calls it again, this time to look for the
 967     // rule text after the second substitution and to match the
 968     // intervening input text against the second substitution.
 969     //
 970     // For example, say we have a rule that looks like this:
 971     //    first &lt;&lt; middle &gt;&gt; last;
 972     // and input text that looks like this:
 973     //    first one middle two last
 974     // First we use stripPrefix() to match &quot;first &quot; in both places and
 975     // strip it off the front, leaving
 976     //    one middle two last
 977     // Then we use matchToDelimiter() to match &quot; middle &quot; and try to
 978     // match &quot;one&quot; against a substitution.  If it&#39;s successful, we now
 979     // have
 980     //    two last
 981     // We use matchToDelimiter() a second time to match &quot; last&quot; and
 982     // try to match &quot;two&quot; against a substitution.  If &quot;two&quot; matches
 983     // the substitution, we have a successful parse.
 984     //
 985     // Since it&#39;s possible in many cases to find multiple instances
 986     // of each of these pieces of rule text in the input string,
 987     // we need to try all the possible combinations of these
 988     // locations.  This prevents us from prematurely declaring a mismatch,
 989     // and makes sure we match as much input text as we can.
 990     int highWaterMark = 0;
 991     double result = 0;
 992     int start = 0;
 993     double tempBaseValue = (double)(baseValue &lt;= 0 ? 0 : baseValue);
 994 
 995     UnicodeString temp;
 996     do {
 997         // our partial parse result starts out as this rule&#39;s base
 998         // value.  If it finds a successful match, matchToDelimiter()
 999         // will compose this in some way with what it gets back from
1000         // the substitution, giving us a new partial parse result
1001         pp.setIndex(0);
1002 
1003         temp.setTo(ruleText, sub1Pos, sub2Pos - sub1Pos);
1004         double partialResult = matchToDelimiter(workText, start, tempBaseValue,
1005             temp, pp, sub1,
1006             nonNumericalExecutedRuleMask,
1007             upperBound);
1008 
1009         // if we got a successful match (or were trying to match a
1010         // null substitution), pp is now pointing at the first unmatched
1011         // character.  Take note of that, and try matchToDelimiter()
1012         // on the input text again
1013         if (pp.getIndex() != 0 || sub1 == NULL) {
1014             start = pp.getIndex();
1015 
1016             UnicodeString workText2;
1017             workText2.setTo(workText, pp.getIndex(), workText.length() - pp.getIndex());
1018             ParsePosition pp2;
1019 
1020             // the second matchToDelimiter() will compose our previous
1021             // partial result with whatever it gets back from its
1022             // substitution if there&#39;s a successful match, giving us
1023             // a real result
1024             temp.setTo(ruleText, sub2Pos, ruleText.length() - sub2Pos);
1025             partialResult = matchToDelimiter(workText2, 0, partialResult,
1026                 temp, pp2, sub2,
1027                 nonNumericalExecutedRuleMask,
1028                 upperBound);
1029 
1030             // if we got a successful match on this second
1031             // matchToDelimiter() call, update the high-water mark
1032             // and result (if necessary)
1033             if (pp2.getIndex() != 0 || sub2 == NULL) {
1034                 if (prefixLength + pp.getIndex() + pp2.getIndex() &gt; highWaterMark) {
1035                     highWaterMark = prefixLength + pp.getIndex() + pp2.getIndex();
1036                     result = partialResult;
1037                 }
1038             }
1039             else {
1040                 // commented out because ParsePosition doesn&#39;t have error index in 1.1.x
1041                 // restored for ICU4C port
1042                 int32_t temp = pp2.getErrorIndex() + sub1Pos + pp.getIndex();
1043                 if (temp&gt; parsePosition.getErrorIndex()) {
1044                     parsePosition.setErrorIndex(temp);
1045                 }
1046             }
1047         }
1048         else {
1049             // commented out because ParsePosition doesn&#39;t have error index in 1.1.x
1050             // restored for ICU4C port
1051             int32_t temp = sub1Pos + pp.getErrorIndex();
1052             if (temp &gt; parsePosition.getErrorIndex()) {
1053                 parsePosition.setErrorIndex(temp);
1054             }
1055         }
1056         // keep trying to match things until the outer matchToDelimiter()
1057         // call fails to make a match (each time, it picks up where it
1058         // left off the previous time)
1059     } while (sub1Pos != sub2Pos
1060         &amp;&amp; pp.getIndex() &gt; 0
1061         &amp;&amp; pp.getIndex() &lt; workText.length()
1062         &amp;&amp; pp.getIndex() != start);
1063 
1064     // update the caller&#39;s ParsePosition with our high-water mark
1065     // (i.e., it now points at the first character this function
1066     // didn&#39;t match-- the ParsePosition is therefore unchanged if
1067     // we didn&#39;t match anything)
1068     parsePosition.setIndex(highWaterMark);
1069     // commented out because ParsePosition doesn&#39;t have error index in 1.1.x
1070     // restored for ICU4C port
1071     if (highWaterMark &gt; 0) {
1072         parsePosition.setErrorIndex(0);
1073     }
1074 
1075     // this is a hack for one unusual condition: Normally, whether this
1076     // rule belong to a fraction rule set or not is handled by its
1077     // substitutions.  But if that rule HAS NO substitutions, then
1078     // we have to account for it here.  By definition, if the matching
1079     // rule in a fraction rule set has no substitutions, its numerator
1080     // is 1, and so the result is the reciprocal of its base value.
1081     if (isFractionRule &amp;&amp; highWaterMark &gt; 0 &amp;&amp; sub1 == NULL) {
1082         result = 1 / result;
1083     }
1084 
1085     resVal.setDouble(result);
1086     return TRUE; // ??? do we need to worry if it is a long or a double?
1087 }
1088 
1089 /**
1090 * This function is used by parse() to match the text being parsed
1091 * against a possible prefix string.  This function
1092 * matches characters from the beginning of the string being parsed
1093 * to characters from the prospective prefix.  If they match, pp is
1094 * updated to the first character not matched, and the result is
1095 * the unparsed part of the string.  If they don&#39;t match, the whole
1096 * string is returned, and pp is left unchanged.
1097 * @param text The string being parsed
1098 * @param prefix The text to match against
1099 * @param pp On entry, ignored and assumed to be 0.  On exit, points
1100 * to the first unmatched character (assuming the whole prefix matched),
1101 * or is unchanged (if the whole prefix didn&#39;t match).
1102 * @return If things match, this is the unparsed part of &quot;text&quot;;
1103 * if they didn&#39;t match, this is &quot;text&quot;.
1104 */
1105 void
1106 NFRule::stripPrefix(UnicodeString&amp; text, const UnicodeString&amp; prefix, ParsePosition&amp; pp) const
1107 {
1108     // if the prefix text is empty, dump out without doing anything
1109     if (prefix.length() != 0) {
1110         UErrorCode status = U_ZERO_ERROR;
1111         // use prefixLength() to match the beginning of
1112         // &quot;text&quot; against &quot;prefix&quot;.  This function returns the
1113         // number of characters from &quot;text&quot; that matched (or 0 if
1114         // we didn&#39;t match the whole prefix)
1115         int32_t pfl = prefixLength(text, prefix, status);
1116         if (U_FAILURE(status)) { // Memory allocation error.
1117             return;
1118         }
1119         if (pfl != 0) {
1120             // if we got a successful match, update the parse position
1121             // and strip the prefix off of &quot;text&quot;
1122             pp.setIndex(pp.getIndex() + pfl);
1123             text.remove(0, pfl);
1124         }
1125     }
1126 }
1127 
1128 /**
1129 * Used by parse() to match a substitution and any following text.
1130 * &quot;text&quot; is searched for instances of &quot;delimiter&quot;.  For each instance
1131 * of delimiter, the intervening text is tested to see whether it
1132 * matches the substitution.  The longest match wins.
1133 * @param text The string being parsed
1134 * @param startPos The position in &quot;text&quot; where we should start looking
1135 * for &quot;delimiter&quot;.
1136 * @param baseValue A partial parse result (often the rule&#39;s base value),
1137 * which is combined with the result from matching the substitution
1138 * @param delimiter The string to search &quot;text&quot; for.
1139 * @param pp Ignored and presumed to be 0 on entry.  If there&#39;s a match,
1140 * on exit this will point to the first unmatched character.
1141 * @param sub If we find &quot;delimiter&quot; in &quot;text&quot;, this substitution is used
1142 * to match the text between the beginning of the string and the
1143 * position of &quot;delimiter.&quot;  (If &quot;delimiter&quot; is the empty string, then
1144 * this function just matches against this substitution and updates
1145 * everything accordingly.)
1146 * @param upperBound When matching the substitution, it will only
1147 * consider rules with base values lower than this value.
1148 * @return If there&#39;s a match, this is the result of composing
1149 * baseValue with the result of matching the substitution.  Otherwise,
1150 * this is new Long(0).  It&#39;s never null.  If the result is an integer,
1151 * this will be an instance of Long; otherwise, it&#39;s an instance of
1152 * Double.
1153 *
1154 * !!! note {dlf} in point of fact, in the java code the caller always converts
1155 * the result to a double, so we might as well return one.
1156 */
1157 double
1158 NFRule::matchToDelimiter(const UnicodeString&amp; text,
1159                          int32_t startPos,
1160                          double _baseValue,
1161                          const UnicodeString&amp; delimiter,
1162                          ParsePosition&amp; pp,
1163                          const NFSubstitution* sub,
1164                          uint32_t nonNumericalExecutedRuleMask,
1165                          double upperBound) const
1166 {
1167     UErrorCode status = U_ZERO_ERROR;
1168     // if &quot;delimiter&quot; contains real (i.e., non-ignorable) text, search
1169     // it for &quot;delimiter&quot; beginning at &quot;start&quot;.  If that succeeds, then
1170     // use &quot;sub&quot;&#39;s doParse() method to match the text before the
1171     // instance of &quot;delimiter&quot; we just found.
1172     if (!allIgnorable(delimiter, status)) {
1173         if (U_FAILURE(status)) { //Memory allocation error.
1174             return 0;
1175         }
1176         ParsePosition tempPP;
1177         Formattable result;
1178 
1179         // use findText() to search for &quot;delimiter&quot;.  It returns a two-
1180         // element array: element 0 is the position of the match, and
1181         // element 1 is the number of characters that matched
1182         // &quot;delimiter&quot;.
1183         int32_t dLen;
1184         int32_t dPos = findText(text, delimiter, startPos, &amp;dLen);
1185 
1186         // if findText() succeeded, isolate the text preceding the
1187         // match, and use &quot;sub&quot; to match that text
1188         while (dPos &gt;= 0) {
1189             UnicodeString subText;
1190             subText.setTo(text, 0, dPos);
1191             if (subText.length() &gt; 0) {
1192                 UBool success = sub-&gt;doParse(subText, tempPP, _baseValue, upperBound,
1193 #if UCONFIG_NO_COLLATION
1194                     FALSE,
1195 #else
1196                     formatter-&gt;isLenient(),
1197 #endif
1198                     nonNumericalExecutedRuleMask,
1199                     result);
1200 
1201                 // if the substitution could match all the text up to
1202                 // where we found &quot;delimiter&quot;, then this function has
1203                 // a successful match.  Bump the caller&#39;s parse position
1204                 // to point to the first character after the text
1205                 // that matches &quot;delimiter&quot;, and return the result
1206                 // we got from parsing the substitution.
1207                 if (success &amp;&amp; tempPP.getIndex() == dPos) {
1208                     pp.setIndex(dPos + dLen);
1209                     return result.getDouble();
1210                 }
1211                 else {
1212                     // commented out because ParsePosition doesn&#39;t have error index in 1.1.x
1213                     // restored for ICU4C port
1214                     if (tempPP.getErrorIndex() &gt; 0) {
1215                         pp.setErrorIndex(tempPP.getErrorIndex());
1216                     } else {
1217                         pp.setErrorIndex(tempPP.getIndex());
1218                     }
1219                 }
1220             }
1221 
1222             // if we didn&#39;t match the substitution, search for another
1223             // copy of &quot;delimiter&quot; in &quot;text&quot; and repeat the loop if
1224             // we find it
1225             tempPP.setIndex(0);
1226             dPos = findText(text, delimiter, dPos + dLen, &amp;dLen);
1227         }
1228         // if we make it here, this was an unsuccessful match, and we
1229         // leave pp unchanged and return 0
1230         pp.setIndex(0);
1231         return 0;
1232 
1233         // if &quot;delimiter&quot; is empty, or consists only of ignorable characters
1234         // (i.e., is semantically empty), thwe we obviously can&#39;t search
1235         // for &quot;delimiter&quot;.  Instead, just use &quot;sub&quot; to parse as much of
1236         // &quot;text&quot; as possible.
1237     }
1238     else if (sub == NULL) {
1239         return _baseValue;
1240     }
1241     else {
1242         ParsePosition tempPP;
1243         Formattable result;
1244 
1245         // try to match the whole string against the substitution
1246         UBool success = sub-&gt;doParse(text, tempPP, _baseValue, upperBound,
1247 #if UCONFIG_NO_COLLATION
1248             FALSE,
1249 #else
1250             formatter-&gt;isLenient(),
1251 #endif
1252             nonNumericalExecutedRuleMask,
1253             result);
1254         if (success &amp;&amp; (tempPP.getIndex() != 0)) {
1255             // if there&#39;s a successful match (or it&#39;s a null
1256             // substitution), update pp to point to the first
1257             // character we didn&#39;t match, and pass the result from
1258             // sub.doParse() on through to the caller
1259             pp.setIndex(tempPP.getIndex());
1260             return result.getDouble();
1261         }
1262         else {
1263             // commented out because ParsePosition doesn&#39;t have error index in 1.1.x
1264             // restored for ICU4C port
1265             pp.setErrorIndex(tempPP.getErrorIndex());
1266         }
1267 
1268         // and if we get to here, then nothing matched, so we return
1269         // 0 and leave pp alone
1270         return 0;
1271     }
1272 }
1273 
1274 /**
1275 * Used by stripPrefix() to match characters.  If lenient parse mode
1276 * is off, this just calls startsWith().  If lenient parse mode is on,
1277 * this function uses CollationElementIterators to match characters in
1278 * the strings (only primary-order differences are significant in
1279 * determining whether there&#39;s a match).
1280 * @param str The string being tested
1281 * @param prefix The text we&#39;re hoping to see at the beginning
1282 * of &quot;str&quot;
1283 * @return If &quot;prefix&quot; is found at the beginning of &quot;str&quot;, this
1284 * is the number of characters in &quot;str&quot; that were matched (this
1285 * isn&#39;t necessarily the same as the length of &quot;prefix&quot; when matching
1286 * text with a collator).  If there&#39;s no match, this is 0.
1287 */
1288 int32_t
1289 NFRule::prefixLength(const UnicodeString&amp; str, const UnicodeString&amp; prefix, UErrorCode&amp; status) const
1290 {
1291     // if we&#39;re looking for an empty prefix, it obviously matches
1292     // zero characters.  Just go ahead and return 0.
1293     if (prefix.length() == 0) {
1294         return 0;
1295     }
1296 
1297 #if !UCONFIG_NO_COLLATION
1298     // go through all this grief if we&#39;re in lenient-parse mode
1299     if (formatter-&gt;isLenient()) {
1300         // get the formatter&#39;s collator and use it to create two
1301         // collation element iterators, one over the target string
1302         // and another over the prefix (right now, we&#39;ll throw an
1303         // exception if the collator we get back from the formatter
1304         // isn&#39;t a RuleBasedCollator, because RuleBasedCollator defines
1305         // the CollationElementIterator protocol.  Hopefully, this
1306         // will change someday.)
1307         const RuleBasedCollator* collator = formatter-&gt;getCollator();
1308         if (collator == NULL) {
1309             status = U_MEMORY_ALLOCATION_ERROR;
1310             return 0;
1311         }
1312         LocalPointer&lt;CollationElementIterator&gt; strIter(collator-&gt;createCollationElementIterator(str));
1313         LocalPointer&lt;CollationElementIterator&gt; prefixIter(collator-&gt;createCollationElementIterator(prefix));
1314         // Check for memory allocation error.
1315         if (strIter.isNull() || prefixIter.isNull()) {
1316             status = U_MEMORY_ALLOCATION_ERROR;
1317             return 0;
1318         }
1319 
1320         UErrorCode err = U_ZERO_ERROR;
1321 
1322         // The original code was problematic.  Consider this match:
1323         // prefix = &quot;fifty-&quot;
1324         // string = &quot; fifty-7&quot;
1325         // The intent is to match string up to the &#39;7&#39;, by matching &#39;fifty-&#39; at position 1
1326         // in the string.  Unfortunately, we were getting a match, and then computing where
1327         // the match terminated by rematching the string.  The rematch code was using as an
1328         // initial guess the substring of string between 0 and prefix.length.  Because of
1329         // the leading space and trailing hyphen (both ignorable) this was succeeding, leaving
1330         // the position before the hyphen in the string.  Recursing down, we then parsed the
1331         // remaining string &#39;-7&#39; as numeric.  The resulting number turned out as 43 (50 - 7).
1332         // This was not pretty, especially since the string &quot;fifty-7&quot; parsed just fine.
1333         //
1334         // We have newer APIs now, so we can use calls on the iterator to determine what we
1335         // matched up to.  If we terminate because we hit the last element in the string,
1336         // our match terminates at this length.  If we terminate because we hit the last element
1337         // in the target, our match terminates at one before the element iterator position.
1338 
1339         // match collation elements between the strings
1340         int32_t oStr = strIter-&gt;next(err);
1341         int32_t oPrefix = prefixIter-&gt;next(err);
1342 
1343         while (oPrefix != CollationElementIterator::NULLORDER) {
1344             // skip over ignorable characters in the target string
1345             while (CollationElementIterator::primaryOrder(oStr) == 0
1346                 &amp;&amp; oStr != CollationElementIterator::NULLORDER) {
1347                 oStr = strIter-&gt;next(err);
1348             }
1349 
1350             // skip over ignorable characters in the prefix
1351             while (CollationElementIterator::primaryOrder(oPrefix) == 0
1352                 &amp;&amp; oPrefix != CollationElementIterator::NULLORDER) {
1353                 oPrefix = prefixIter-&gt;next(err);
1354             }
1355 
1356             // dlf: move this above following test, if we consume the
1357             // entire target, aren&#39;t we ok even if the source was also
1358             // entirely consumed?
1359 
1360             // if skipping over ignorables brought to the end of
1361             // the prefix, we DID match: drop out of the loop
1362             if (oPrefix == CollationElementIterator::NULLORDER) {
1363                 break;
1364             }
1365 
1366             // if skipping over ignorables brought us to the end
1367             // of the target string, we didn&#39;t match and return 0
1368             if (oStr == CollationElementIterator::NULLORDER) {
1369                 return 0;
1370             }
1371 
1372             // match collation elements from the two strings
1373             // (considering only primary differences).  If we
1374             // get a mismatch, dump out and return 0
1375             if (CollationElementIterator::primaryOrder(oStr)
1376                 != CollationElementIterator::primaryOrder(oPrefix)) {
1377                 return 0;
1378 
1379                 // otherwise, advance to the next character in each string
1380                 // and loop (we drop out of the loop when we exhaust
1381                 // collation elements in the prefix)
1382             } else {
1383                 oStr = strIter-&gt;next(err);
1384                 oPrefix = prefixIter-&gt;next(err);
1385             }
1386         }
1387 
1388         int32_t result = strIter-&gt;getOffset();
1389         if (oStr != CollationElementIterator::NULLORDER) {
1390             --result; // back over character that we don&#39;t want to consume;
1391         }
1392 
1393 #ifdef RBNF_DEBUG
1394         fprintf(stderr, &quot;prefix length: %d\n&quot;, result);
1395 #endif
1396         return result;
1397 #if 0
1398         //----------------------------------------------------------------
1399         // JDK 1.2-specific API call
1400         // return strIter.getOffset();
1401         //----------------------------------------------------------------
1402         // JDK 1.1 HACK (take out for 1.2-specific code)
1403 
1404         // if we make it to here, we have a successful match.  Now we
1405         // have to find out HOW MANY characters from the target string
1406         // matched the prefix (there isn&#39;t necessarily a one-to-one
1407         // mapping between collation elements and characters).
1408         // In JDK 1.2, there&#39;s a simple getOffset() call we can use.
1409         // In JDK 1.1, on the other hand, we have to go through some
1410         // ugly contortions.  First, use the collator to compare the
1411         // same number of characters from the prefix and target string.
1412         // If they&#39;re equal, we&#39;re done.
1413         collator-&gt;setStrength(Collator::PRIMARY);
1414         if (str.length() &gt;= prefix.length()) {
1415             UnicodeString temp;
1416             temp.setTo(str, 0, prefix.length());
1417             if (collator-&gt;equals(temp, prefix)) {
1418 #ifdef RBNF_DEBUG
1419                 fprintf(stderr, &quot;returning: %d\n&quot;, prefix.length());
1420 #endif
1421                 return prefix.length();
1422             }
1423         }
1424 
1425         // if they&#39;re not equal, then we have to compare successively
1426         // larger and larger substrings of the target string until we
1427         // get to one that matches the prefix.  At that point, we know
1428         // how many characters matched the prefix, and we can return.
1429         int32_t p = 1;
1430         while (p &lt;= str.length()) {
1431             UnicodeString temp;
1432             temp.setTo(str, 0, p);
1433             if (collator-&gt;equals(temp, prefix)) {
1434                 return p;
1435             } else {
1436                 ++p;
1437             }
1438         }
1439 
1440         // SHOULD NEVER GET HERE!!!
1441         return 0;
1442         //----------------------------------------------------------------
1443 #endif
1444 
1445         // If lenient parsing is turned off, forget all that crap above.
1446         // Just use String.startsWith() and be done with it.
1447   } else
1448 #endif
1449   {
1450       if (str.startsWith(prefix)) {
1451           return prefix.length();
1452       } else {
1453           return 0;
1454       }
1455   }
1456 }
1457 
1458 /**
1459 * Searches a string for another string.  If lenient parsing is off,
1460 * this just calls indexOf().  If lenient parsing is on, this function
1461 * uses CollationElementIterator to match characters, and only
1462 * primary-order differences are significant in determining whether
1463 * there&#39;s a match.
1464 * @param str The string to search
1465 * @param key The string to search &quot;str&quot; for
1466 * @param startingAt The index into &quot;str&quot; where the search is to
1467 * begin
1468 * @return A two-element array of ints.  Element 0 is the position
1469 * of the match, or -1 if there was no match.  Element 1 is the
1470 * number of characters in &quot;str&quot; that matched (which isn&#39;t necessarily
1471 * the same as the length of &quot;key&quot;)
1472 */
1473 int32_t
1474 NFRule::findText(const UnicodeString&amp; str,
1475                  const UnicodeString&amp; key,
1476                  int32_t startingAt,
1477                  int32_t* length) const
1478 {
1479     if (rulePatternFormat) {
1480         Formattable result;
1481         FieldPosition position(UNUM_INTEGER_FIELD);
1482         position.setBeginIndex(startingAt);
1483         rulePatternFormat-&gt;parseType(str, this, result, position);
1484         int start = position.getBeginIndex();
1485         if (start &gt;= 0) {
1486             int32_t pluralRuleStart = ruleText.indexOf(gDollarOpenParenthesis, -1, 0);
1487             int32_t pluralRuleSuffix = ruleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart) + 2;
1488             int32_t matchLen = position.getEndIndex() - start;
1489             UnicodeString prefix(ruleText.tempSubString(0, pluralRuleStart));
1490             UnicodeString suffix(ruleText.tempSubString(pluralRuleSuffix));
1491             if (str.compare(start - prefix.length(), prefix.length(), prefix, 0, prefix.length()) == 0
1492                     &amp;&amp; str.compare(start + matchLen, suffix.length(), suffix, 0, suffix.length()) == 0)
1493             {
1494                 *length = matchLen + prefix.length() + suffix.length();
1495                 return start - prefix.length();
1496             }
1497         }
1498         *length = 0;
1499         return -1;
1500     }
1501     if (!formatter-&gt;isLenient()) {
1502         // if lenient parsing is turned off, this is easy: just call
1503         // String.indexOf() and we&#39;re done
1504         *length = key.length();
1505         return str.indexOf(key, startingAt);
1506     }
1507     else {
1508         // but if lenient parsing is turned ON, we&#39;ve got some work
1509         // ahead of us
1510         return findTextLenient(str, key, startingAt, length);
1511     }
1512 }
1513 
1514 int32_t
1515 NFRule::findTextLenient(const UnicodeString&amp; str,
1516                  const UnicodeString&amp; key,
1517                  int32_t startingAt,
1518                  int32_t* length) const
1519 {
1520     //----------------------------------------------------------------
1521     // JDK 1.1 HACK (take out of 1.2-specific code)
1522 
1523     // in JDK 1.2, CollationElementIterator provides us with an
1524     // API to map between character offsets and collation elements
1525     // and we can do this by marching through the string comparing
1526     // collation elements.  We can&#39;t do that in JDK 1.1.  Insted,
1527     // we have to go through this horrible slow mess:
1528     int32_t p = startingAt;
1529     int32_t keyLen = 0;
1530 
1531     // basically just isolate smaller and smaller substrings of
1532     // the target string (each running to the end of the string,
1533     // and with the first one running from startingAt to the end)
1534     // and then use prefixLength() to see if the search key is at
1535     // the beginning of each substring.  This is excruciatingly
1536     // slow, but it will locate the key and tell use how long the
1537     // matching text was.
1538     UnicodeString temp;
1539     UErrorCode status = U_ZERO_ERROR;
1540     while (p &lt; str.length() &amp;&amp; keyLen == 0) {
1541         temp.setTo(str, p, str.length() - p);
1542         keyLen = prefixLength(temp, key, status);
1543         if (U_FAILURE(status)) {
1544             break;
1545         }
1546         if (keyLen != 0) {
1547             *length = keyLen;
1548             return p;
1549         }
1550         ++p;
1551     }
1552     // if we make it to here, we didn&#39;t find it.  Return -1 for the
1553     // location.  The length should be ignored, but set it to 0,
1554     // which should be &quot;safe&quot;
1555     *length = 0;
1556     return -1;
1557 }
1558 
1559 /**
1560 * Checks to see whether a string consists entirely of ignorable
1561 * characters.
1562 * @param str The string to test.
1563 * @return true if the string is empty of consists entirely of
1564 * characters that the number formatter&#39;s collator says are
1565 * ignorable at the primary-order level.  false otherwise.
1566 */
1567 UBool
1568 NFRule::allIgnorable(const UnicodeString&amp; str, UErrorCode&amp; status) const
1569 {
1570     // if the string is empty, we can just return true
1571     if (str.length() == 0) {
1572         return TRUE;
1573     }
1574 
1575 #if !UCONFIG_NO_COLLATION
1576     // if lenient parsing is turned on, walk through the string with
1577     // a collation element iterator and make sure each collation
1578     // element is 0 (ignorable) at the primary level
1579     if (formatter-&gt;isLenient()) {
1580         const RuleBasedCollator* collator = formatter-&gt;getCollator();
1581         if (collator == NULL) {
1582             status = U_MEMORY_ALLOCATION_ERROR;
1583             return FALSE;
1584         }
1585         LocalPointer&lt;CollationElementIterator&gt; iter(collator-&gt;createCollationElementIterator(str));
1586 
1587         // Memory allocation error check.
1588         if (iter.isNull()) {
1589             status = U_MEMORY_ALLOCATION_ERROR;
1590             return FALSE;
1591         }
1592 
1593         UErrorCode err = U_ZERO_ERROR;
1594         int32_t o = iter-&gt;next(err);
1595         while (o != CollationElementIterator::NULLORDER
1596             &amp;&amp; CollationElementIterator::primaryOrder(o) == 0) {
1597             o = iter-&gt;next(err);
1598         }
1599 
1600         return o == CollationElementIterator::NULLORDER;
1601     }
1602 #endif
1603 
1604     // if lenient parsing is turned off, there is no such thing as
1605     // an ignorable character: return true only if the string is empty
1606     return FALSE;
1607 }
1608 
1609 void
1610 NFRule::setDecimalFormatSymbols(const DecimalFormatSymbols&amp; newSymbols, UErrorCode&amp; status) {
1611     if (sub1 != NULL) {
1612         sub1-&gt;setDecimalFormatSymbols(newSymbols, status);
1613     }
1614     if (sub2 != NULL) {
1615         sub2-&gt;setDecimalFormatSymbols(newSymbols, status);
1616     }
1617 }
1618 
1619 U_NAMESPACE_END
1620 
1621 /* U_HAVE_RBNF */
1622 #endif
    </pre>
  </body>
</html>