<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/uspoof_conf.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="uspoof.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uspoof_impl.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/uspoof_conf.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 99 
100 
101 int32_t SPUStringPool::size() {
102     return fVec-&gt;size();
103 }
104 
105 SPUString *SPUStringPool::getByIndex(int32_t index) {
106     SPUString *retString = (SPUString *)fVec-&gt;elementAt(index);
107     return retString;
108 }
109 
110 
111 // Comparison function for ordering strings in the string pool.
112 // Compare by length first, then, within a group of the same length,
113 // by code point order.
114 // Conforms to the type signature for a USortComparator in uvector.h
115 
116 static int8_t U_CALLCONV SPUStringCompare(UHashTok left, UHashTok right) {
117     const SPUString *sL = const_cast&lt;const SPUString *&gt;(
118         static_cast&lt;SPUString *&gt;(left.pointer));
<span class="line-modified">119     const SPUString *sR = const_cast&lt;const SPUString *&gt;(</span>
<span class="line-modified">120         static_cast&lt;SPUString *&gt;(right.pointer));</span>
121     int32_t lenL = sL-&gt;fStr-&gt;length();
122     int32_t lenR = sR-&gt;fStr-&gt;length();
123     if (lenL &lt; lenR) {
124         return -1;
125     } else if (lenL &gt; lenR) {
126         return 1;
127     } else {
128         return sL-&gt;fStr-&gt;compare(*(sR-&gt;fStr));
129     }
130 }
131 
132 void SPUStringPool::sort(UErrorCode &amp;status) {
133     fVec-&gt;sort(SPUStringCompare, status);
134 }
135 
136 
137 SPUString *SPUStringPool::addString(UnicodeString *src, UErrorCode &amp;status) {
138     SPUString *hashedString = static_cast&lt;SPUString *&gt;(uhash_get(fHash, src));
139     if (hashedString != NULL) {
140         delete src;
</pre>
<hr />
<pre>
237     if (status != U_BUFFER_OVERFLOW_ERROR) {
238         return;
239     }
240     status = U_ZERO_ERROR;
241     fInput = static_cast&lt;UChar *&gt;(uprv_malloc((inputLen+1) * sizeof(UChar)));
242     if (fInput == NULL) {
243         status = U_MEMORY_ALLOCATION_ERROR;
244         return;
245     }
246     u_strFromUTF8(fInput, inputLen+1, NULL, confusables, confusablesLen, &amp;status);
247 
248 
249     // Regular Expression to parse a line from Confusables.txt.  The expression will match
250     // any line.  What was matched is determined by examining which capture groups have a match.
251     //   Capture Group 1:  the source char
252     //   Capture Group 2:  the replacement chars
253     //   Capture Group 3-6  the table type, SL, SA, ML, or MA (deprecated)
254     //   Capture Group 7:  A blank or comment only line.
255     //   Capture Group 8:  A syntactically invalid line.  Anything that didn&#39;t match before.
256     // Example Line from the confusables.txt source file:
<span class="line-modified">257     //   &quot;1D702 ;   006E 0329 ; SL  # MATHEMATICAL ITALIC SMALL ETA ... &quot;</span>
258     UnicodeString pattern(
259         &quot;(?m)^[ \\t]*([0-9A-Fa-f]+)[ \\t]+;&quot;      // Match the source char
260         &quot;[ \\t]*([0-9A-Fa-f]+&quot;                    // Match the replacement char(s)
261            &quot;(?:[ \\t]+[0-9A-Fa-f]+)*)[ \\t]*;&quot;    //     (continued)
262         &quot;\\s*(?:(SL)|(SA)|(ML)|(MA))&quot;             // Match the table type
263         &quot;[ \\t]*(?:#.*?)?$&quot;                       // Match any trailing #comment
264         &quot;|^([ \\t]*(?:#.*?)?)$&quot;       // OR match empty lines or lines with only a #comment
265         &quot;|^(.*?)$&quot;, -1, US_INV);      // OR match any line, which catches illegal lines.
266     // TODO: Why are we using the regex C API here? C++ would just take UnicodeString...
267     fParseLine = uregex_open(pattern.getBuffer(), pattern.length(), 0, NULL, &amp;status);
268 
269     // Regular expression for parsing a hex number out of a space-separated list of them.
270     //   Capture group 1 gets the number, with spaces removed.
271     pattern = UNICODE_STRING_SIMPLE(&quot;\\s*([0-9A-F]+)&quot;);
272     fParseHexNum = uregex_open(pattern.getBuffer(), pattern.length(), 0, NULL, &amp;status);
273 
274     // Zap any Byte Order Mark at the start of input.  Changing it to a space is benign
275     //   given the syntax of the input.
276     if (*fInput == 0xfeff) {
277         *fInput = 0x20;
</pre>
</td>
<td>
<hr />
<pre>
 99 
100 
101 int32_t SPUStringPool::size() {
102     return fVec-&gt;size();
103 }
104 
105 SPUString *SPUStringPool::getByIndex(int32_t index) {
106     SPUString *retString = (SPUString *)fVec-&gt;elementAt(index);
107     return retString;
108 }
109 
110 
111 // Comparison function for ordering strings in the string pool.
112 // Compare by length first, then, within a group of the same length,
113 // by code point order.
114 // Conforms to the type signature for a USortComparator in uvector.h
115 
116 static int8_t U_CALLCONV SPUStringCompare(UHashTok left, UHashTok right) {
117     const SPUString *sL = const_cast&lt;const SPUString *&gt;(
118         static_cast&lt;SPUString *&gt;(left.pointer));
<span class="line-modified">119      const SPUString *sR = const_cast&lt;const SPUString *&gt;(</span>
<span class="line-modified">120          static_cast&lt;SPUString *&gt;(right.pointer));</span>
121     int32_t lenL = sL-&gt;fStr-&gt;length();
122     int32_t lenR = sR-&gt;fStr-&gt;length();
123     if (lenL &lt; lenR) {
124         return -1;
125     } else if (lenL &gt; lenR) {
126         return 1;
127     } else {
128         return sL-&gt;fStr-&gt;compare(*(sR-&gt;fStr));
129     }
130 }
131 
132 void SPUStringPool::sort(UErrorCode &amp;status) {
133     fVec-&gt;sort(SPUStringCompare, status);
134 }
135 
136 
137 SPUString *SPUStringPool::addString(UnicodeString *src, UErrorCode &amp;status) {
138     SPUString *hashedString = static_cast&lt;SPUString *&gt;(uhash_get(fHash, src));
139     if (hashedString != NULL) {
140         delete src;
</pre>
<hr />
<pre>
237     if (status != U_BUFFER_OVERFLOW_ERROR) {
238         return;
239     }
240     status = U_ZERO_ERROR;
241     fInput = static_cast&lt;UChar *&gt;(uprv_malloc((inputLen+1) * sizeof(UChar)));
242     if (fInput == NULL) {
243         status = U_MEMORY_ALLOCATION_ERROR;
244         return;
245     }
246     u_strFromUTF8(fInput, inputLen+1, NULL, confusables, confusablesLen, &amp;status);
247 
248 
249     // Regular Expression to parse a line from Confusables.txt.  The expression will match
250     // any line.  What was matched is determined by examining which capture groups have a match.
251     //   Capture Group 1:  the source char
252     //   Capture Group 2:  the replacement chars
253     //   Capture Group 3-6  the table type, SL, SA, ML, or MA (deprecated)
254     //   Capture Group 7:  A blank or comment only line.
255     //   Capture Group 8:  A syntactically invalid line.  Anything that didn&#39;t match before.
256     // Example Line from the confusables.txt source file:
<span class="line-modified">257     //   &quot;1D702 ;    006E 0329 ;    SL    # MATHEMATICAL ITALIC SMALL ETA ... &quot;</span>
258     UnicodeString pattern(
259         &quot;(?m)^[ \\t]*([0-9A-Fa-f]+)[ \\t]+;&quot;      // Match the source char
260         &quot;[ \\t]*([0-9A-Fa-f]+&quot;                    // Match the replacement char(s)
261            &quot;(?:[ \\t]+[0-9A-Fa-f]+)*)[ \\t]*;&quot;    //     (continued)
262         &quot;\\s*(?:(SL)|(SA)|(ML)|(MA))&quot;             // Match the table type
263         &quot;[ \\t]*(?:#.*?)?$&quot;                       // Match any trailing #comment
264         &quot;|^([ \\t]*(?:#.*?)?)$&quot;       // OR match empty lines or lines with only a #comment
265         &quot;|^(.*?)$&quot;, -1, US_INV);      // OR match any line, which catches illegal lines.
266     // TODO: Why are we using the regex C API here? C++ would just take UnicodeString...
267     fParseLine = uregex_open(pattern.getBuffer(), pattern.length(), 0, NULL, &amp;status);
268 
269     // Regular expression for parsing a hex number out of a space-separated list of them.
270     //   Capture group 1 gets the number, with spaces removed.
271     pattern = UNICODE_STRING_SIMPLE(&quot;\\s*([0-9A-F]+)&quot;);
272     fParseHexNum = uregex_open(pattern.getBuffer(), pattern.length(), 0, NULL, &amp;status);
273 
274     // Zap any Byte Order Mark at the start of input.  Changing it to a space is benign
275     //   given the syntax of the input.
276     if (*fInput == 0xfeff) {
277         *fInput = 0x20;
</pre>
</td>
</tr>
</table>
<center><a href="uspoof.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uspoof_impl.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>