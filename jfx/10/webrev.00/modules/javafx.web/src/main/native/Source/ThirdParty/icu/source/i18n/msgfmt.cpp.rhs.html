<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/msgfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /********************************************************************
   4  * COPYRIGHT:
   5  * Copyright (c) 1997-2015, International Business Machines Corporation and
   6  * others. All Rights Reserved.
   7  ********************************************************************
   8  *
   9  * File MSGFMT.CPP
  10  *
  11  * Modification History:
  12  *
  13  *   Date        Name        Description
  14  *   02/19/97    aliu        Converted from java.
  15  *   03/20/97    helena      Finished first cut of implementation.
  16  *   04/10/97    aliu        Made to work on AIX.  Added stoi to replace wtoi.
  17  *   06/11/97    helena      Fixed addPattern to take the pattern correctly.
  18  *   06/17/97    helena      Fixed the getPattern to return the correct pattern.
  19  *   07/09/97    helena      Made ParsePosition into a class.
  20  *   02/22/99    stephen     Removed character literals for EBCDIC safety
  21  *   11/01/09    kirtig      Added SelectFormat
  22  ********************************************************************/
  23 
  24 #include &quot;unicode/utypes.h&quot;
  25 
  26 #if !UCONFIG_NO_FORMATTING
  27 
  28 #include &quot;unicode/appendable.h&quot;
  29 #include &quot;unicode/choicfmt.h&quot;
  30 #include &quot;unicode/datefmt.h&quot;
  31 #include &quot;unicode/decimfmt.h&quot;
  32 #include &quot;unicode/localpointer.h&quot;
  33 #include &quot;unicode/msgfmt.h&quot;
  34 #include &quot;unicode/numberformatter.h&quot;
  35 #include &quot;unicode/plurfmt.h&quot;
  36 #include &quot;unicode/rbnf.h&quot;
  37 #include &quot;unicode/selfmt.h&quot;
  38 #include &quot;unicode/smpdtfmt.h&quot;
  39 #include &quot;unicode/umsg.h&quot;
  40 #include &quot;unicode/ustring.h&quot;
  41 #include &quot;cmemory.h&quot;
  42 #include &quot;patternprops.h&quot;
  43 #include &quot;messageimpl.h&quot;
  44 #include &quot;msgfmt_impl.h&quot;
  45 #include &quot;plurrule_impl.h&quot;
  46 #include &quot;uassert.h&quot;
  47 #include &quot;uelement.h&quot;
  48 #include &quot;uhash.h&quot;
  49 #include &quot;ustrfmt.h&quot;
  50 #include &quot;util.h&quot;
  51 #include &quot;uvector.h&quot;
  52 #include &quot;number_decimalquantity.h&quot;
  53 
  54 // *****************************************************************************
  55 // class MessageFormat
  56 // *****************************************************************************
  57 
  58 #define SINGLE_QUOTE      ((UChar)0x0027)
  59 #define COMMA             ((UChar)0x002C)
  60 #define LEFT_CURLY_BRACE  ((UChar)0x007B)
  61 #define RIGHT_CURLY_BRACE ((UChar)0x007D)
  62 
  63 //---------------------------------------
  64 // static data
  65 
  66 static const UChar ID_NUMBER[]    = {
  67     0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0  /* &quot;number&quot; */
  68 };
  69 static const UChar ID_DATE[]      = {
  70     0x64, 0x61, 0x74, 0x65, 0              /* &quot;date&quot; */
  71 };
  72 static const UChar ID_TIME[]      = {
  73     0x74, 0x69, 0x6D, 0x65, 0              /* &quot;time&quot; */
  74 };
  75 static const UChar ID_SPELLOUT[]  = {
  76     0x73, 0x70, 0x65, 0x6c, 0x6c, 0x6f, 0x75, 0x74, 0 /* &quot;spellout&quot; */
  77 };
  78 static const UChar ID_ORDINAL[]   = {
  79     0x6f, 0x72, 0x64, 0x69, 0x6e, 0x61, 0x6c, 0 /* &quot;ordinal&quot; */
  80 };
  81 static const UChar ID_DURATION[]  = {
  82     0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0 /* &quot;duration&quot; */
  83 };
  84 
  85 // MessageFormat Type List  Number, Date, Time or Choice
  86 static const UChar * const TYPE_IDS[] = {
  87     ID_NUMBER,
  88     ID_DATE,
  89     ID_TIME,
  90     ID_SPELLOUT,
  91     ID_ORDINAL,
  92     ID_DURATION,
  93     NULL,
  94 };
  95 
  96 static const UChar ID_EMPTY[]     = {
  97     0 /* empty string, used for default so that null can mark end of list */
  98 };
  99 static const UChar ID_CURRENCY[]  = {
 100     0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x63, 0x79, 0  /* &quot;currency&quot; */
 101 };
 102 static const UChar ID_PERCENT[]   = {
 103     0x70, 0x65, 0x72, 0x63, 0x65, 0x6E, 0x74, 0        /* &quot;percent&quot; */
 104 };
 105 static const UChar ID_INTEGER[]   = {
 106     0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0        /* &quot;integer&quot; */
 107 };
 108 
 109 // NumberFormat modifier list, default, currency, percent or integer
 110 static const UChar * const NUMBER_STYLE_IDS[] = {
 111     ID_EMPTY,
 112     ID_CURRENCY,
 113     ID_PERCENT,
 114     ID_INTEGER,
 115     NULL,
 116 };
 117 
 118 static const UChar ID_SHORT[]     = {
 119     0x73, 0x68, 0x6F, 0x72, 0x74, 0        /* &quot;short&quot; */
 120 };
 121 static const UChar ID_MEDIUM[]    = {
 122     0x6D, 0x65, 0x64, 0x69, 0x75, 0x6D, 0  /* &quot;medium&quot; */
 123 };
 124 static const UChar ID_LONG[]      = {
 125     0x6C, 0x6F, 0x6E, 0x67, 0              /* &quot;long&quot; */
 126 };
 127 static const UChar ID_FULL[]      = {
 128     0x66, 0x75, 0x6C, 0x6C, 0              /* &quot;full&quot; */
 129 };
 130 
 131 // DateFormat modifier list, default, short, medium, long or full
 132 static const UChar * const DATE_STYLE_IDS[] = {
 133     ID_EMPTY,
 134     ID_SHORT,
 135     ID_MEDIUM,
 136     ID_LONG,
 137     ID_FULL,
 138     NULL,
 139 };
 140 
 141 static const icu::DateFormat::EStyle DATE_STYLES[] = {
 142     icu::DateFormat::kDefault,
 143     icu::DateFormat::kShort,
 144     icu::DateFormat::kMedium,
 145     icu::DateFormat::kLong,
 146     icu::DateFormat::kFull,
 147 };
 148 
 149 static const int32_t DEFAULT_INITIAL_CAPACITY = 10;
 150 
 151 static const UChar NULL_STRING[] = {
 152     0x6E, 0x75, 0x6C, 0x6C, 0  // &quot;null&quot;
 153 };
 154 
 155 static const UChar OTHER_STRING[] = {
 156     0x6F, 0x74, 0x68, 0x65, 0x72, 0  // &quot;other&quot;
 157 };
 158 
 159 U_CDECL_BEGIN
 160 static UBool U_CALLCONV equalFormatsForHash(const UHashTok key1,
 161                                             const UHashTok key2) {
 162     return icu::MessageFormat::equalFormats(key1.pointer, key2.pointer);
 163 }
 164 
 165 U_CDECL_END
 166 
 167 U_NAMESPACE_BEGIN
 168 
 169 // -------------------------------------
 170 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(MessageFormat)
 171 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(FormatNameEnumeration)
 172 
 173 //--------------------------------------------------------------------
 174 
 175 /**
 176  * Convert an integer value to a string and append the result to
 177  * the given UnicodeString.
 178  */
 179 static UnicodeString&amp; itos(int32_t i, UnicodeString&amp; appendTo) {
 180     UChar temp[16];
 181     uprv_itou(temp,16,i,10,0); // 10 == radix
 182     appendTo.append(temp, -1);
 183     return appendTo;
 184 }
 185 
 186 
 187 // AppendableWrapper: encapsulates the result of formatting, keeping track
 188 // of the string and its length.
 189 class AppendableWrapper : public UMemory {
 190 public:
 191     AppendableWrapper(Appendable&amp; appendable) : app(appendable), len(0) {
 192     }
 193     void append(const UnicodeString&amp; s) {
 194         app.appendString(s.getBuffer(), s.length());
 195         len += s.length();
 196     }
 197     void append(const UChar* s, const int32_t sLength) {
 198         app.appendString(s, sLength);
 199         len += sLength;
 200     }
 201     void append(const UnicodeString&amp; s, int32_t start, int32_t length) {
 202         append(s.tempSubString(start, length));
 203     }
 204     void formatAndAppend(const Format* formatter, const Formattable&amp; arg, UErrorCode&amp; ec) {
 205         UnicodeString s;
 206         formatter-&gt;format(arg, s, ec);
 207         if (U_SUCCESS(ec)) {
 208             append(s);
 209         }
 210     }
 211     void formatAndAppend(const Format* formatter, const Formattable&amp; arg,
 212                          const UnicodeString &amp;argString, UErrorCode&amp; ec) {
 213         if (!argString.isEmpty()) {
 214             if (U_SUCCESS(ec)) {
 215                 append(argString);
 216             }
 217         } else {
 218             formatAndAppend(formatter, arg, ec);
 219         }
 220     }
 221     int32_t length() {
 222         return len;
 223     }
 224 private:
 225     Appendable&amp; app;
 226     int32_t len;
 227 };
 228 
 229 
 230 // -------------------------------------
 231 // Creates a MessageFormat instance based on the pattern.
 232 
 233 MessageFormat::MessageFormat(const UnicodeString&amp; pattern,
 234                              UErrorCode&amp; success)
 235 : fLocale(Locale::getDefault()),  // Uses the default locale
 236   msgPattern(success),
 237   formatAliases(NULL),
 238   formatAliasesCapacity(0),
 239   argTypes(NULL),
 240   argTypeCount(0),
 241   argTypeCapacity(0),
 242   hasArgTypeConflicts(FALSE),
 243   defaultNumberFormat(NULL),
 244   defaultDateFormat(NULL),
 245   cachedFormatters(NULL),
 246   customFormatArgStarts(NULL),
 247   pluralProvider(*this, UPLURAL_TYPE_CARDINAL),
 248   ordinalProvider(*this, UPLURAL_TYPE_ORDINAL)
 249 {
 250     setLocaleIDs(fLocale.getName(), fLocale.getName());
 251     applyPattern(pattern, success);
 252 }
 253 
 254 MessageFormat::MessageFormat(const UnicodeString&amp; pattern,
 255                              const Locale&amp; newLocale,
 256                              UErrorCode&amp; success)
 257 : fLocale(newLocale),
 258   msgPattern(success),
 259   formatAliases(NULL),
 260   formatAliasesCapacity(0),
 261   argTypes(NULL),
 262   argTypeCount(0),
 263   argTypeCapacity(0),
 264   hasArgTypeConflicts(FALSE),
 265   defaultNumberFormat(NULL),
 266   defaultDateFormat(NULL),
 267   cachedFormatters(NULL),
 268   customFormatArgStarts(NULL),
 269   pluralProvider(*this, UPLURAL_TYPE_CARDINAL),
 270   ordinalProvider(*this, UPLURAL_TYPE_ORDINAL)
 271 {
 272     setLocaleIDs(fLocale.getName(), fLocale.getName());
 273     applyPattern(pattern, success);
 274 }
 275 
 276 MessageFormat::MessageFormat(const UnicodeString&amp; pattern,
 277                              const Locale&amp; newLocale,
 278                              UParseError&amp; parseError,
 279                              UErrorCode&amp; success)
 280 : fLocale(newLocale),
 281   msgPattern(success),
 282   formatAliases(NULL),
 283   formatAliasesCapacity(0),
 284   argTypes(NULL),
 285   argTypeCount(0),
 286   argTypeCapacity(0),
 287   hasArgTypeConflicts(FALSE),
 288   defaultNumberFormat(NULL),
 289   defaultDateFormat(NULL),
 290   cachedFormatters(NULL),
 291   customFormatArgStarts(NULL),
 292   pluralProvider(*this, UPLURAL_TYPE_CARDINAL),
 293   ordinalProvider(*this, UPLURAL_TYPE_ORDINAL)
 294 {
 295     setLocaleIDs(fLocale.getName(), fLocale.getName());
 296     applyPattern(pattern, parseError, success);
 297 }
 298 
 299 MessageFormat::MessageFormat(const MessageFormat&amp; that)
 300 :
 301   Format(that),
 302   fLocale(that.fLocale),
 303   msgPattern(that.msgPattern),
 304   formatAliases(NULL),
 305   formatAliasesCapacity(0),
 306   argTypes(NULL),
 307   argTypeCount(0),
 308   argTypeCapacity(0),
 309   hasArgTypeConflicts(that.hasArgTypeConflicts),
 310   defaultNumberFormat(NULL),
 311   defaultDateFormat(NULL),
 312   cachedFormatters(NULL),
 313   customFormatArgStarts(NULL),
 314   pluralProvider(*this, UPLURAL_TYPE_CARDINAL),
 315   ordinalProvider(*this, UPLURAL_TYPE_ORDINAL)
 316 {
 317     // This will take care of creating the hash tables (since they are NULL).
 318     UErrorCode ec = U_ZERO_ERROR;
 319     copyObjects(that, ec);
 320     if (U_FAILURE(ec)) {
 321         resetPattern();
 322     }
 323 }
 324 
 325 MessageFormat::~MessageFormat()
 326 {
 327     uhash_close(cachedFormatters);
 328     uhash_close(customFormatArgStarts);
 329 
 330     uprv_free(argTypes);
 331     uprv_free(formatAliases);
 332     delete defaultNumberFormat;
 333     delete defaultDateFormat;
 334 }
 335 
 336 //--------------------------------------------------------------------
 337 // Variable-size array management
 338 
 339 /**
 340  * Allocate argTypes[] to at least the given capacity and return
 341  * TRUE if successful.  If not, leave argTypes[] unchanged.
 342  *
 343  * If argTypes is NULL, allocate it.  If it is not NULL, enlarge it
 344  * if necessary to be at least as large as specified.
 345  */
 346 UBool MessageFormat::allocateArgTypes(int32_t capacity, UErrorCode&amp; status) {
 347     if (U_FAILURE(status)) {
 348         return FALSE;
 349     }
 350     if (argTypeCapacity &gt;= capacity) {
 351         return TRUE;
 352     }
 353     if (capacity &lt; DEFAULT_INITIAL_CAPACITY) {
 354         capacity = DEFAULT_INITIAL_CAPACITY;
 355     } else if (capacity &lt; 2*argTypeCapacity) {
 356         capacity = 2*argTypeCapacity;
 357     }
 358     Formattable::Type* a = (Formattable::Type*)
 359             uprv_realloc(argTypes, sizeof(*argTypes) * capacity);
 360     if (a == NULL) {
 361         status = U_MEMORY_ALLOCATION_ERROR;
 362         return FALSE;
 363     }
 364     argTypes = a;
 365     argTypeCapacity = capacity;
 366     return TRUE;
 367 }
 368 
 369 // -------------------------------------
 370 // assignment operator
 371 
 372 const MessageFormat&amp;
 373 MessageFormat::operator=(const MessageFormat&amp; that)
 374 {
 375     if (this != &amp;that) {
 376         // Calls the super class for assignment first.
 377         Format::operator=(that);
 378 
 379         setLocale(that.fLocale);
 380         msgPattern = that.msgPattern;
 381         hasArgTypeConflicts = that.hasArgTypeConflicts;
 382 
 383         UErrorCode ec = U_ZERO_ERROR;
 384         copyObjects(that, ec);
 385         if (U_FAILURE(ec)) {
 386             resetPattern();
 387         }
 388     }
 389     return *this;
 390 }
 391 
 392 UBool
 393 MessageFormat::operator==(const Format&amp; rhs) const
 394 {
 395     if (this == &amp;rhs) return TRUE;
 396 
 397     MessageFormat&amp; that = (MessageFormat&amp;)rhs;
 398 
 399     // Check class ID before checking MessageFormat members
 400     if (!Format::operator==(rhs) ||
 401         msgPattern != that.msgPattern ||
 402         fLocale != that.fLocale) {
 403         return FALSE;
 404     }
 405 
 406     // Compare hashtables.
 407     if ((customFormatArgStarts == NULL) != (that.customFormatArgStarts == NULL)) {
 408         return FALSE;
 409     }
 410     if (customFormatArgStarts == NULL) {
 411         return TRUE;
 412     }
 413 
 414     UErrorCode ec = U_ZERO_ERROR;
 415     const int32_t count = uhash_count(customFormatArgStarts);
 416     const int32_t rhs_count = uhash_count(that.customFormatArgStarts);
 417     if (count != rhs_count) {
 418         return FALSE;
 419     }
 420     int32_t idx = 0, rhs_idx = 0, pos = UHASH_FIRST, rhs_pos = UHASH_FIRST;
 421     for (; idx &lt; count &amp;&amp; rhs_idx &lt; rhs_count &amp;&amp; U_SUCCESS(ec); ++idx, ++rhs_idx) {
 422         const UHashElement* cur = uhash_nextElement(customFormatArgStarts, &amp;pos);
 423         const UHashElement* rhs_cur = uhash_nextElement(that.customFormatArgStarts, &amp;rhs_pos);
 424         if (cur-&gt;key.integer != rhs_cur-&gt;key.integer) {
 425             return FALSE;
 426         }
 427         const Format* format = (const Format*)uhash_iget(cachedFormatters, cur-&gt;key.integer);
 428         const Format* rhs_format = (const Format*)uhash_iget(that.cachedFormatters, rhs_cur-&gt;key.integer);
 429         if (*format != *rhs_format) {
 430             return FALSE;
 431         }
 432     }
 433     return TRUE;
 434 }
 435 
 436 // -------------------------------------
 437 // Creates a copy of this MessageFormat, the caller owns the copy.
 438 
 439 Format*
 440 MessageFormat::clone() const
 441 {
 442     return new MessageFormat(*this);
 443 }
 444 
 445 // -------------------------------------
 446 // Sets the locale of this MessageFormat object to theLocale.
 447 
 448 void
 449 MessageFormat::setLocale(const Locale&amp; theLocale)
 450 {
 451     if (fLocale != theLocale) {
 452         delete defaultNumberFormat;
 453         defaultNumberFormat = NULL;
 454         delete defaultDateFormat;
 455         defaultDateFormat = NULL;
 456         fLocale = theLocale;
 457         setLocaleIDs(fLocale.getName(), fLocale.getName());
 458         pluralProvider.reset();
 459         ordinalProvider.reset();
 460     }
 461 }
 462 
 463 // -------------------------------------
 464 // Gets the locale of this MessageFormat object.
 465 
 466 const Locale&amp;
 467 MessageFormat::getLocale() const
 468 {
 469     return fLocale;
 470 }
 471 
 472 void
 473 MessageFormat::applyPattern(const UnicodeString&amp; newPattern,
 474                             UErrorCode&amp; status)
 475 {
 476     UParseError parseError;
 477     applyPattern(newPattern,parseError,status);
 478 }
 479 
 480 
 481 // -------------------------------------
 482 // Applies the new pattern and returns an error if the pattern
 483 // is not correct.
 484 void
 485 MessageFormat::applyPattern(const UnicodeString&amp; pattern,
 486                             UParseError&amp; parseError,
 487                             UErrorCode&amp; ec)
 488 {
 489     if(U_FAILURE(ec)) {
 490         return;
 491     }
 492     msgPattern.parse(pattern, &amp;parseError, ec);
 493     cacheExplicitFormats(ec);
 494 
 495     if (U_FAILURE(ec)) {
 496         resetPattern();
 497     }
 498 }
 499 
 500 void MessageFormat::resetPattern() {
 501     msgPattern.clear();
 502     uhash_close(cachedFormatters);
 503     cachedFormatters = NULL;
 504     uhash_close(customFormatArgStarts);
 505     customFormatArgStarts = NULL;
 506     argTypeCount = 0;
 507     hasArgTypeConflicts = FALSE;
 508 }
 509 
 510 void
 511 MessageFormat::applyPattern(const UnicodeString&amp; pattern,
 512                             UMessagePatternApostropheMode aposMode,
 513                             UParseError* parseError,
 514                             UErrorCode&amp; status) {
 515     if (aposMode != msgPattern.getApostropheMode()) {
 516         msgPattern.clearPatternAndSetApostropheMode(aposMode);
 517     }
 518     applyPattern(pattern, *parseError, status);
 519 }
 520 
 521 // -------------------------------------
 522 // Converts this MessageFormat instance to a pattern.
 523 
 524 UnicodeString&amp;
 525 MessageFormat::toPattern(UnicodeString&amp; appendTo) const {
 526     if ((customFormatArgStarts != NULL &amp;&amp; 0 != uhash_count(customFormatArgStarts)) ||
 527         0 == msgPattern.countParts()
 528     ) {
 529         appendTo.setToBogus();
 530         return appendTo;
 531     }
 532     return appendTo.append(msgPattern.getPatternString());
 533 }
 534 
 535 int32_t MessageFormat::nextTopLevelArgStart(int32_t partIndex) const {
 536     if (partIndex != 0) {
 537         partIndex = msgPattern.getLimitPartIndex(partIndex);
 538     }
 539     for (;;) {
 540         UMessagePatternPartType type = msgPattern.getPartType(++partIndex);
 541         if (type == UMSGPAT_PART_TYPE_ARG_START) {
 542             return partIndex;
 543         }
 544         if (type == UMSGPAT_PART_TYPE_MSG_LIMIT) {
 545             return -1;
 546         }
 547     }
 548 }
 549 
 550 void MessageFormat::setArgStartFormat(int32_t argStart,
 551                                       Format* formatter,
 552                                       UErrorCode&amp; status) {
 553     if (U_FAILURE(status)) {
 554         delete formatter;
 555         return;
 556     }
 557     if (cachedFormatters == NULL) {
 558         cachedFormatters=uhash_open(uhash_hashLong, uhash_compareLong,
 559                                     equalFormatsForHash, &amp;status);
 560         if (U_FAILURE(status)) {
 561             delete formatter;
 562             return;
 563         }
 564         uhash_setValueDeleter(cachedFormatters, uprv_deleteUObject);
 565     }
 566     if (formatter == NULL) {
 567         formatter = new DummyFormat();
 568     }
 569     uhash_iput(cachedFormatters, argStart, formatter, &amp;status);
 570 }
 571 
 572 
 573 UBool MessageFormat::argNameMatches(int32_t partIndex, const UnicodeString&amp; argName, int32_t argNumber) {
 574     const MessagePattern::Part&amp; part = msgPattern.getPart(partIndex);
 575     return part.getType() == UMSGPAT_PART_TYPE_ARG_NAME ?
 576         msgPattern.partSubstringMatches(part, argName) :
 577         part.getValue() == argNumber;  // ARG_NUMBER
 578 }
 579 
 580 // Sets a custom formatter for a MessagePattern ARG_START part index.
 581 // &quot;Custom&quot; formatters are provided by the user via setFormat() or similar APIs.
 582 void MessageFormat::setCustomArgStartFormat(int32_t argStart,
 583                                             Format* formatter,
 584                                             UErrorCode&amp; status) {
 585     setArgStartFormat(argStart, formatter, status);
 586     if (customFormatArgStarts == NULL) {
 587         customFormatArgStarts=uhash_open(uhash_hashLong, uhash_compareLong,
 588                                          NULL, &amp;status);
 589     }
 590     uhash_iputi(customFormatArgStarts, argStart, 1, &amp;status);
 591 }
 592 
 593 Format* MessageFormat::getCachedFormatter(int32_t argumentNumber) const {
 594     if (cachedFormatters == NULL) {
 595         return NULL;
 596     }
 597     void* ptr = uhash_iget(cachedFormatters, argumentNumber);
 598     if (ptr != NULL &amp;&amp; dynamic_cast&lt;DummyFormat*&gt;((Format*)ptr) == NULL) {
 599         return (Format*) ptr;
 600     } else {
 601         // Not cached, or a DummyFormat representing setFormat(NULL).
 602         return NULL;
 603     }
 604 }
 605 
 606 // -------------------------------------
 607 // Adopts the new formats array and updates the array count.
 608 // This MessageFormat instance owns the new formats.
 609 void
 610 MessageFormat::adoptFormats(Format** newFormats,
 611                             int32_t count) {
 612     if (newFormats == NULL || count &lt; 0) {
 613         return;
 614     }
 615     // Throw away any cached formatters.
 616     if (cachedFormatters != NULL) {
 617         uhash_removeAll(cachedFormatters);
 618     }
 619     if (customFormatArgStarts != NULL) {
 620         uhash_removeAll(customFormatArgStarts);
 621     }
 622 
 623     int32_t formatNumber = 0;
 624     UErrorCode status = U_ZERO_ERROR;
 625     for (int32_t partIndex = 0;
 626         formatNumber &lt; count &amp;&amp; U_SUCCESS(status) &amp;&amp;
 627             (partIndex = nextTopLevelArgStart(partIndex)) &gt;= 0;) {
 628         setCustomArgStartFormat(partIndex, newFormats[formatNumber], status);
 629         ++formatNumber;
 630     }
 631     // Delete those that didn&#39;t get used (if any).
 632     for (; formatNumber &lt; count; ++formatNumber) {
 633         delete newFormats[formatNumber];
 634     }
 635 
 636 }
 637 
 638 // -------------------------------------
 639 // Sets the new formats array and updates the array count.
 640 // This MessageFormat instance maks a copy of the new formats.
 641 
 642 void
 643 MessageFormat::setFormats(const Format** newFormats,
 644                           int32_t count) {
 645     if (newFormats == NULL || count &lt; 0) {
 646         return;
 647     }
 648     // Throw away any cached formatters.
 649     if (cachedFormatters != NULL) {
 650         uhash_removeAll(cachedFormatters);
 651     }
 652     if (customFormatArgStarts != NULL) {
 653         uhash_removeAll(customFormatArgStarts);
 654     }
 655 
 656     UErrorCode status = U_ZERO_ERROR;
 657     int32_t formatNumber = 0;
 658     for (int32_t partIndex = 0;
 659         formatNumber &lt; count &amp;&amp; U_SUCCESS(status) &amp;&amp; (partIndex = nextTopLevelArgStart(partIndex)) &gt;= 0;) {
 660       Format* newFormat = NULL;
 661       if (newFormats[formatNumber] != NULL) {
 662           newFormat = newFormats[formatNumber]-&gt;clone();
 663           if (newFormat == NULL) {
 664               status = U_MEMORY_ALLOCATION_ERROR;
 665           }
 666       }
 667       setCustomArgStartFormat(partIndex, newFormat, status);
 668       ++formatNumber;
 669     }
 670     if (U_FAILURE(status)) {
 671         resetPattern();
 672     }
 673 }
 674 
 675 // -------------------------------------
 676 // Adopt a single format by format number.
 677 // Do nothing if the format number is not less than the array count.
 678 
 679 void
 680 MessageFormat::adoptFormat(int32_t n, Format *newFormat) {
 681     LocalPointer&lt;Format&gt; p(newFormat);
 682     if (n &gt;= 0) {
 683         int32_t formatNumber = 0;
 684         for (int32_t partIndex = 0; (partIndex = nextTopLevelArgStart(partIndex)) &gt;= 0;) {
 685             if (n == formatNumber) {
 686                 UErrorCode status = U_ZERO_ERROR;
 687                 setCustomArgStartFormat(partIndex, p.orphan(), status);
 688                 return;
 689             }
 690             ++formatNumber;
 691         }
 692     }
 693 }
 694 
 695 // -------------------------------------
 696 // Adopt a single format by format name.
 697 // Do nothing if there is no match of formatName.
 698 void
 699 MessageFormat::adoptFormat(const UnicodeString&amp; formatName,
 700                            Format* formatToAdopt,
 701                            UErrorCode&amp; status) {
 702     LocalPointer&lt;Format&gt; p(formatToAdopt);
 703     if (U_FAILURE(status)) {
 704         return;
 705     }
 706     int32_t argNumber = MessagePattern::validateArgumentName(formatName);
 707     if (argNumber &lt; UMSGPAT_ARG_NAME_NOT_NUMBER) {
 708         status = U_ILLEGAL_ARGUMENT_ERROR;
 709         return;
 710     }
 711     for (int32_t partIndex = 0;
 712         (partIndex = nextTopLevelArgStart(partIndex)) &gt;= 0 &amp;&amp; U_SUCCESS(status);
 713     ) {
 714         if (argNameMatches(partIndex + 1, formatName, argNumber)) {
 715             Format* f;
 716             if (p.isValid()) {
 717                 f = p.orphan();
 718             } else if (formatToAdopt == NULL) {
 719                 f = NULL;
 720             } else {
 721                 f = formatToAdopt-&gt;clone();
 722                 if (f == NULL) {
 723                     status = U_MEMORY_ALLOCATION_ERROR;
 724                     return;
 725                 }
 726             }
 727             setCustomArgStartFormat(partIndex, f, status);
 728         }
 729     }
 730 }
 731 
 732 // -------------------------------------
 733 // Set a single format.
 734 // Do nothing if the variable is not less than the array count.
 735 void
 736 MessageFormat::setFormat(int32_t n, const Format&amp; newFormat) {
 737 
 738     if (n &gt;= 0) {
 739         int32_t formatNumber = 0;
 740         for (int32_t partIndex = 0;
 741              (partIndex = nextTopLevelArgStart(partIndex)) &gt;= 0;) {
 742             if (n == formatNumber) {
 743                 Format* new_format = newFormat.clone();
 744                 if (new_format) {
 745                     UErrorCode status = U_ZERO_ERROR;
 746                     setCustomArgStartFormat(partIndex, new_format, status);
 747                 }
 748                 return;
 749             }
 750             ++formatNumber;
 751         }
 752     }
 753 }
 754 
 755 // -------------------------------------
 756 // Get a single format by format name.
 757 // Do nothing if the variable is not less than the array count.
 758 Format *
 759 MessageFormat::getFormat(const UnicodeString&amp; formatName, UErrorCode&amp; status) {
 760     if (U_FAILURE(status) || cachedFormatters == NULL) return NULL;
 761 
 762     int32_t argNumber = MessagePattern::validateArgumentName(formatName);
 763     if (argNumber &lt; UMSGPAT_ARG_NAME_NOT_NUMBER) {
 764         status = U_ILLEGAL_ARGUMENT_ERROR;
 765         return NULL;
 766     }
 767     for (int32_t partIndex = 0; (partIndex = nextTopLevelArgStart(partIndex)) &gt;= 0;) {
 768         if (argNameMatches(partIndex + 1, formatName, argNumber)) {
 769             return getCachedFormatter(partIndex);
 770         }
 771     }
 772     return NULL;
 773 }
 774 
 775 // -------------------------------------
 776 // Set a single format by format name
 777 // Do nothing if the variable is not less than the array count.
 778 void
 779 MessageFormat::setFormat(const UnicodeString&amp; formatName,
 780                          const Format&amp; newFormat,
 781                          UErrorCode&amp; status) {
 782     if (U_FAILURE(status)) return;
 783 
 784     int32_t argNumber = MessagePattern::validateArgumentName(formatName);
 785     if (argNumber &lt; UMSGPAT_ARG_NAME_NOT_NUMBER) {
 786         status = U_ILLEGAL_ARGUMENT_ERROR;
 787         return;
 788     }
 789     for (int32_t partIndex = 0;
 790         (partIndex = nextTopLevelArgStart(partIndex)) &gt;= 0 &amp;&amp; U_SUCCESS(status);
 791     ) {
 792         if (argNameMatches(partIndex + 1, formatName, argNumber)) {
 793             Format* new_format = newFormat.clone();
 794             if (new_format == NULL) {
 795                 status = U_MEMORY_ALLOCATION_ERROR;
 796                 return;
 797             }
 798             setCustomArgStartFormat(partIndex, new_format, status);
 799         }
 800     }
 801 }
 802 
 803 // -------------------------------------
 804 // Gets the format array.
 805 const Format**
 806 MessageFormat::getFormats(int32_t&amp; cnt) const
 807 {
 808     // This old API returns an array (which we hold) of Format*
 809     // pointers.  The array is valid up to the next call to any
 810     // method on this object.  We construct and resize an array
 811     // on demand that contains aliases to the subformats[i].format
 812     // pointers.
<a name="1" id="anc1"></a><span class="line-added"> 813 </span>
<span class="line-added"> 814     // Get total required capacity first (it&#39;s refreshed on each call).</span>
<span class="line-added"> 815     int32_t totalCapacity = 0;</span>
<span class="line-added"> 816     for (int32_t partIndex = 0; (partIndex = nextTopLevelArgStart(partIndex)) &gt;= 0; ++totalCapacity) {};</span>
<span class="line-added"> 817 </span>
 818     MessageFormat* t = const_cast&lt;MessageFormat*&gt; (this);
 819     cnt = 0;
<a name="2" id="anc2"></a><span class="line-modified"> 820     if (formatAliases == nullptr) {</span>
<span class="line-modified"> 821         t-&gt;formatAliasesCapacity = totalCapacity;</span>
 822         Format** a = (Format**)
 823             uprv_malloc(sizeof(Format*) * formatAliasesCapacity);
<a name="3" id="anc3"></a><span class="line-modified"> 824         if (a == nullptr) {</span>
 825             t-&gt;formatAliasesCapacity = 0;
<a name="4" id="anc4"></a><span class="line-modified"> 826             return nullptr;</span>
 827         }
 828         t-&gt;formatAliases = a;
<a name="5" id="anc5"></a><span class="line-modified"> 829     } else if (totalCapacity &gt; formatAliasesCapacity) {</span>
 830         Format** a = (Format**)
<a name="6" id="anc6"></a><span class="line-modified"> 831             uprv_realloc(formatAliases, sizeof(Format*) * totalCapacity);</span>
<span class="line-modified"> 832         if (a == nullptr) {</span>
 833             t-&gt;formatAliasesCapacity = 0;
<a name="7" id="anc7"></a><span class="line-modified"> 834             return nullptr;</span>
 835         }
 836         t-&gt;formatAliases = a;
<a name="8" id="anc8"></a><span class="line-modified"> 837         t-&gt;formatAliasesCapacity = totalCapacity;</span>
 838     }
 839 
 840     for (int32_t partIndex = 0; (partIndex = nextTopLevelArgStart(partIndex)) &gt;= 0;) {
 841         t-&gt;formatAliases[cnt++] = getCachedFormatter(partIndex);
 842     }
 843 
 844     return (const Format**)formatAliases;
 845 }
 846 
 847 
 848 UnicodeString MessageFormat::getArgName(int32_t partIndex) {
 849     const MessagePattern::Part&amp; part = msgPattern.getPart(partIndex);
 850     return msgPattern.getSubstring(part);
 851 }
 852 
 853 StringEnumeration*
 854 MessageFormat::getFormatNames(UErrorCode&amp; status) {
 855     if (U_FAILURE(status))  return NULL;
 856 
 857     UVector *fFormatNames = new UVector(status);
 858     if (U_FAILURE(status)) {
 859         status = U_MEMORY_ALLOCATION_ERROR;
 860         return NULL;
 861     }
 862     fFormatNames-&gt;setDeleter(uprv_deleteUObject);
 863 
 864     for (int32_t partIndex = 0; (partIndex = nextTopLevelArgStart(partIndex)) &gt;= 0;) {
 865         fFormatNames-&gt;addElement(new UnicodeString(getArgName(partIndex + 1)), status);
 866     }
 867 
 868     StringEnumeration* nameEnumerator = new FormatNameEnumeration(fFormatNames, status);
 869     return nameEnumerator;
 870 }
 871 
 872 // -------------------------------------
 873 // Formats the source Formattable array and copy into the result buffer.
 874 // Ignore the FieldPosition result for error checking.
 875 
 876 UnicodeString&amp;
 877 MessageFormat::format(const Formattable* source,
 878                       int32_t cnt,
 879                       UnicodeString&amp; appendTo,
 880                       FieldPosition&amp; ignore,
 881                       UErrorCode&amp; success) const
 882 {
 883     return format(source, NULL, cnt, appendTo, &amp;ignore, success);
 884 }
 885 
 886 // -------------------------------------
 887 // Internally creates a MessageFormat instance based on the
 888 // pattern and formats the arguments Formattable array and
 889 // copy into the appendTo buffer.
 890 
 891 UnicodeString&amp;
 892 MessageFormat::format(  const UnicodeString&amp; pattern,
 893                         const Formattable* arguments,
 894                         int32_t cnt,
 895                         UnicodeString&amp; appendTo,
 896                         UErrorCode&amp; success)
 897 {
 898     MessageFormat temp(pattern, success);
 899     return temp.format(arguments, NULL, cnt, appendTo, NULL, success);
 900 }
 901 
 902 // -------------------------------------
 903 // Formats the source Formattable object and copy into the
 904 // appendTo buffer.  The Formattable object must be an array
 905 // of Formattable instances, returns error otherwise.
 906 
 907 UnicodeString&amp;
 908 MessageFormat::format(const Formattable&amp; source,
 909                       UnicodeString&amp; appendTo,
 910                       FieldPosition&amp; ignore,
 911                       UErrorCode&amp; success) const
 912 {
 913     if (U_FAILURE(success))
 914         return appendTo;
 915     if (source.getType() != Formattable::kArray) {
 916         success = U_ILLEGAL_ARGUMENT_ERROR;
 917         return appendTo;
 918     }
 919     int32_t cnt;
 920     const Formattable* tmpPtr = source.getArray(cnt);
 921     return format(tmpPtr, NULL, cnt, appendTo, &amp;ignore, success);
 922 }
 923 
 924 UnicodeString&amp;
 925 MessageFormat::format(const UnicodeString* argumentNames,
 926                       const Formattable* arguments,
 927                       int32_t count,
 928                       UnicodeString&amp; appendTo,
 929                       UErrorCode&amp; success) const {
 930     return format(arguments, argumentNames, count, appendTo, NULL, success);
 931 }
 932 
 933 // Does linear search to find the match for an ArgName.
 934 const Formattable* MessageFormat::getArgFromListByName(const Formattable* arguments,
 935                                                        const UnicodeString *argumentNames,
 936                                                        int32_t cnt, UnicodeString&amp; name) const {
 937     for (int32_t i = 0; i &lt; cnt; ++i) {
 938         if (0 == argumentNames[i].compare(name)) {
 939             return arguments + i;
 940         }
 941     }
 942     return NULL;
 943 }
 944 
 945 
 946 UnicodeString&amp;
 947 MessageFormat::format(const Formattable* arguments,
 948                       const UnicodeString *argumentNames,
 949                       int32_t cnt,
 950                       UnicodeString&amp; appendTo,
 951                       FieldPosition* pos,
 952                       UErrorCode&amp; status) const {
 953     if (U_FAILURE(status)) {
 954         return appendTo;
 955     }
 956 
 957     UnicodeStringAppendable usapp(appendTo);
 958     AppendableWrapper app(usapp);
 959     format(0, NULL, arguments, argumentNames, cnt, app, pos, status);
 960     return appendTo;
 961 }
 962 
 963 namespace {
 964 
 965 /**
 966  * Mutable input/output values for the PluralSelectorProvider.
 967  * Separate so that it is possible to make MessageFormat Freezable.
 968  */
 969 class PluralSelectorContext {
 970 public:
 971     PluralSelectorContext(int32_t start, const UnicodeString &amp;name,
 972                           const Formattable &amp;num, double off, UErrorCode &amp;errorCode)
 973             : startIndex(start), argName(name), offset(off),
 974               numberArgIndex(-1), formatter(NULL), forReplaceNumber(FALSE) {
 975         // number needs to be set even when select() is not called.
 976         // Keep it as a Number/Formattable:
 977         // For format() methods, and to preserve information (e.g., BigDecimal).
 978         if(off == 0) {
 979             number = num;
 980         } else {
 981             number = num.getDouble(errorCode) - off;
 982         }
 983     }
 984 
 985     // Input values for plural selection with decimals.
 986     int32_t startIndex;
 987     const UnicodeString &amp;argName;
 988     /** argument number - plural offset */
 989     Formattable number;
 990     double offset;
 991     // Output values for plural selection with decimals.
 992     /** -1 if REPLACE_NUMBER, 0 arg not found, &gt;0 ARG_START index */
 993     int32_t numberArgIndex;
 994     const Format *formatter;
 995     /** formatted argument number - plural offset */
 996     UnicodeString numberString;
 997     /** TRUE if number-offset was formatted with the stock number formatter */
 998     UBool forReplaceNumber;
 999 };
1000 
1001 }  // namespace
1002 
1003 // if argumentNames is NULL, this means arguments is a numeric array.
1004 // arguments can not be NULL.
1005 // We use const void *plNumber rather than const PluralSelectorContext *pluralNumber
1006 // so that we need not declare the PluralSelectorContext in the public header file.
1007 void MessageFormat::format(int32_t msgStart, const void *plNumber,
1008                            const Formattable* arguments,
1009                            const UnicodeString *argumentNames,
1010                            int32_t cnt,
1011                            AppendableWrapper&amp; appendTo,
1012                            FieldPosition* ignore,
1013                            UErrorCode&amp; success) const {
1014     if (U_FAILURE(success)) {
1015         return;
1016     }
1017 
1018     const UnicodeString&amp; msgString = msgPattern.getPatternString();
1019     int32_t prevIndex = msgPattern.getPart(msgStart).getLimit();
1020     for (int32_t i = msgStart + 1; U_SUCCESS(success) ; ++i) {
1021         const MessagePattern::Part* part = &amp;msgPattern.getPart(i);
1022         const UMessagePatternPartType type = part-&gt;getType();
1023         int32_t index = part-&gt;getIndex();
1024         appendTo.append(msgString, prevIndex, index - prevIndex);
1025         if (type == UMSGPAT_PART_TYPE_MSG_LIMIT) {
1026             return;
1027         }
1028         prevIndex = part-&gt;getLimit();
1029         if (type == UMSGPAT_PART_TYPE_REPLACE_NUMBER) {
1030             const PluralSelectorContext &amp;pluralNumber =
1031                 *static_cast&lt;const PluralSelectorContext *&gt;(plNumber);
1032             if(pluralNumber.forReplaceNumber) {
1033                 // number-offset was already formatted.
1034                 appendTo.formatAndAppend(pluralNumber.formatter,
1035                         pluralNumber.number, pluralNumber.numberString, success);
1036             } else {
1037                 const NumberFormat* nf = getDefaultNumberFormat(success);
1038                 appendTo.formatAndAppend(nf, pluralNumber.number, success);
1039             }
1040             continue;
1041         }
1042         if (type != UMSGPAT_PART_TYPE_ARG_START) {
1043             continue;
1044         }
1045         int32_t argLimit = msgPattern.getLimitPartIndex(i);
1046         UMessagePatternArgType argType = part-&gt;getArgType();
1047         part = &amp;msgPattern.getPart(++i);
1048         const Formattable* arg;
1049         UBool noArg = FALSE;
1050         UnicodeString argName = msgPattern.getSubstring(*part);
1051         if (argumentNames == NULL) {
1052             int32_t argNumber = part-&gt;getValue();  // ARG_NUMBER
1053             if (0 &lt;= argNumber &amp;&amp; argNumber &lt; cnt) {
1054                 arg = arguments + argNumber;
1055             } else {
1056                 arg = NULL;
1057                 noArg = TRUE;
1058             }
1059         } else {
1060             arg = getArgFromListByName(arguments, argumentNames, cnt, argName);
1061             if (arg == NULL) {
1062                 noArg = TRUE;
1063             }
1064         }
1065         ++i;
1066         int32_t prevDestLength = appendTo.length();
1067         const Format* formatter = NULL;
1068         if (noArg) {
1069             appendTo.append(
1070                 UnicodeString(LEFT_CURLY_BRACE).append(argName).append(RIGHT_CURLY_BRACE));
1071         } else if (arg == NULL) {
1072             appendTo.append(NULL_STRING, 4);
1073         } else if(plNumber!=NULL &amp;&amp;
1074                 static_cast&lt;const PluralSelectorContext *&gt;(plNumber)-&gt;numberArgIndex==(i-2)) {
1075             const PluralSelectorContext &amp;pluralNumber =
1076                 *static_cast&lt;const PluralSelectorContext *&gt;(plNumber);
1077             if(pluralNumber.offset == 0) {
1078                 // The number was already formatted with this formatter.
1079                 appendTo.formatAndAppend(pluralNumber.formatter, pluralNumber.number,
1080                                          pluralNumber.numberString, success);
1081             } else {
1082                 // Do not use the formatted (number-offset) string for a named argument
1083                 // that formats the number without subtracting the offset.
1084                 appendTo.formatAndAppend(pluralNumber.formatter, *arg, success);
1085             }
<a name="9" id="anc9"></a><span class="line-modified">1086         } else if ((formatter = getCachedFormatter(i -2)) != 0) {</span>
1087             // Handles all ArgType.SIMPLE, and formatters from setFormat() and its siblings.
1088             if (dynamic_cast&lt;const ChoiceFormat*&gt;(formatter) ||
1089                 dynamic_cast&lt;const PluralFormat*&gt;(formatter) ||
1090                 dynamic_cast&lt;const SelectFormat*&gt;(formatter)) {
1091                 // We only handle nested formats here if they were provided via
1092                 // setFormat() or its siblings. Otherwise they are not cached and instead
1093                 // handled below according to argType.
1094                 UnicodeString subMsgString;
1095                 formatter-&gt;format(*arg, subMsgString, success);
1096                 if (subMsgString.indexOf(LEFT_CURLY_BRACE) &gt;= 0 ||
1097                     (subMsgString.indexOf(SINGLE_QUOTE) &gt;= 0 &amp;&amp; !MessageImpl::jdkAposMode(msgPattern))
1098                 ) {
1099                     MessageFormat subMsgFormat(subMsgString, fLocale, success);
1100                     subMsgFormat.format(0, NULL, arguments, argumentNames, cnt, appendTo, ignore, success);
1101                 } else {
1102                     appendTo.append(subMsgString);
1103                 }
1104             } else {
1105                 appendTo.formatAndAppend(formatter, *arg, success);
1106             }
1107         } else if (argType == UMSGPAT_ARG_TYPE_NONE || (cachedFormatters &amp;&amp; uhash_iget(cachedFormatters, i - 2))) {
1108             // We arrive here if getCachedFormatter returned NULL, but there was actually an element in the hash table.
1109             // This can only happen if the hash table contained a DummyFormat, so the if statement above is a check
1110             // for the hash table containind DummyFormat.
1111             if (arg-&gt;isNumeric()) {
1112                 const NumberFormat* nf = getDefaultNumberFormat(success);
1113                 appendTo.formatAndAppend(nf, *arg, success);
1114             } else if (arg-&gt;getType() == Formattable::kDate) {
1115                 const DateFormat* df = getDefaultDateFormat(success);
1116                 appendTo.formatAndAppend(df, *arg, success);
1117             } else {
1118                 appendTo.append(arg-&gt;getString(success));
1119             }
1120         } else if (argType == UMSGPAT_ARG_TYPE_CHOICE) {
1121             if (!arg-&gt;isNumeric()) {
1122                 success = U_ILLEGAL_ARGUMENT_ERROR;
1123                 return;
1124             }
1125             // We must use the Formattable::getDouble() variant with the UErrorCode parameter
1126             // because only this one converts non-double numeric types to double.
1127             const double number = arg-&gt;getDouble(success);
1128             int32_t subMsgStart = ChoiceFormat::findSubMessage(msgPattern, i, number);
1129             formatComplexSubMessage(subMsgStart, NULL, arguments, argumentNames,
1130                                     cnt, appendTo, success);
1131         } else if (UMSGPAT_ARG_TYPE_HAS_PLURAL_STYLE(argType)) {
1132             if (!arg-&gt;isNumeric()) {
1133                 success = U_ILLEGAL_ARGUMENT_ERROR;
1134                 return;
1135             }
1136             const PluralSelectorProvider &amp;selector =
1137                 argType == UMSGPAT_ARG_TYPE_PLURAL ? pluralProvider : ordinalProvider;
1138             // We must use the Formattable::getDouble() variant with the UErrorCode parameter
1139             // because only this one converts non-double numeric types to double.
1140             double offset = msgPattern.getPluralOffset(i);
1141             PluralSelectorContext context(i, argName, *arg, offset, success);
1142             int32_t subMsgStart = PluralFormat::findSubMessage(
1143                     msgPattern, i, selector, &amp;context, arg-&gt;getDouble(success), success);
1144             formatComplexSubMessage(subMsgStart, &amp;context, arguments, argumentNames,
1145                                     cnt, appendTo, success);
1146         } else if (argType == UMSGPAT_ARG_TYPE_SELECT) {
1147             int32_t subMsgStart = SelectFormat::findSubMessage(msgPattern, i, arg-&gt;getString(success), success);
1148             formatComplexSubMessage(subMsgStart, NULL, arguments, argumentNames,
1149                                     cnt, appendTo, success);
1150         } else {
1151             // This should never happen.
1152             success = U_INTERNAL_PROGRAM_ERROR;
1153             return;
1154         }
1155         ignore = updateMetaData(appendTo, prevDestLength, ignore, arg);
1156         prevIndex = msgPattern.getPart(argLimit).getLimit();
1157         i = argLimit;
1158     }
1159 }
1160 
1161 
1162 void MessageFormat::formatComplexSubMessage(int32_t msgStart,
1163                                             const void *plNumber,
1164                                             const Formattable* arguments,
1165                                             const UnicodeString *argumentNames,
1166                                             int32_t cnt,
1167                                             AppendableWrapper&amp; appendTo,
1168                                             UErrorCode&amp; success) const {
1169     if (U_FAILURE(success)) {
1170         return;
1171     }
1172 
1173     if (!MessageImpl::jdkAposMode(msgPattern)) {
1174         format(msgStart, plNumber, arguments, argumentNames, cnt, appendTo, NULL, success);
1175         return;
1176     }
1177 
1178     // JDK compatibility mode: (see JDK MessageFormat.format() API docs)
1179     // - remove SKIP_SYNTAX; that is, remove half of the apostrophes
1180     // - if the result string contains an open curly brace &#39;{&#39; then
1181     //   instantiate a temporary MessageFormat object and format again;
1182     //   otherwise just append the result string
1183     const UnicodeString&amp; msgString = msgPattern.getPatternString();
1184     UnicodeString sb;
1185     int32_t prevIndex = msgPattern.getPart(msgStart).getLimit();
1186     for (int32_t i = msgStart;;) {
1187         const MessagePattern::Part&amp; part = msgPattern.getPart(++i);
1188         const UMessagePatternPartType type = part.getType();
1189         int32_t index = part.getIndex();
1190         if (type == UMSGPAT_PART_TYPE_MSG_LIMIT) {
1191             sb.append(msgString, prevIndex, index - prevIndex);
1192             break;
1193         } else if (type == UMSGPAT_PART_TYPE_REPLACE_NUMBER || type == UMSGPAT_PART_TYPE_SKIP_SYNTAX) {
1194             sb.append(msgString, prevIndex, index - prevIndex);
1195             if (type == UMSGPAT_PART_TYPE_REPLACE_NUMBER) {
1196                 const PluralSelectorContext &amp;pluralNumber =
1197                     *static_cast&lt;const PluralSelectorContext *&gt;(plNumber);
1198                 if(pluralNumber.forReplaceNumber) {
1199                     // number-offset was already formatted.
1200                     sb.append(pluralNumber.numberString);
1201                 } else {
1202                     const NumberFormat* nf = getDefaultNumberFormat(success);
1203                     sb.append(nf-&gt;format(pluralNumber.number, sb, success));
1204                 }
1205             }
1206             prevIndex = part.getLimit();
1207         } else if (type == UMSGPAT_PART_TYPE_ARG_START) {
1208             sb.append(msgString, prevIndex, index - prevIndex);
1209             prevIndex = index;
1210             i = msgPattern.getLimitPartIndex(i);
1211             index = msgPattern.getPart(i).getLimit();
1212             MessageImpl::appendReducedApostrophes(msgString, prevIndex, index, sb);
1213             prevIndex = index;
1214         }
1215     }
1216     if (sb.indexOf(LEFT_CURLY_BRACE) &gt;= 0) {
1217         UnicodeString emptyPattern;  // gcc 3.3.3 fails with &quot;UnicodeString()&quot; as the first parameter.
1218         MessageFormat subMsgFormat(emptyPattern, fLocale, success);
1219         subMsgFormat.applyPattern(sb, UMSGPAT_APOS_DOUBLE_REQUIRED, NULL, success);
1220         subMsgFormat.format(0, NULL, arguments, argumentNames, cnt, appendTo, NULL, success);
1221     } else {
1222         appendTo.append(sb);
1223     }
1224 }
1225 
1226 
1227 UnicodeString MessageFormat::getLiteralStringUntilNextArgument(int32_t from) const {
1228     const UnicodeString&amp; msgString=msgPattern.getPatternString();
1229     int32_t prevIndex=msgPattern.getPart(from).getLimit();
1230     UnicodeString b;
1231     for (int32_t i = from + 1; ; ++i) {
1232         const MessagePattern::Part&amp; part = msgPattern.getPart(i);
1233         const UMessagePatternPartType type=part.getType();
1234         int32_t index=part.getIndex();
1235         b.append(msgString, prevIndex, index - prevIndex);
1236         if(type==UMSGPAT_PART_TYPE_ARG_START || type==UMSGPAT_PART_TYPE_MSG_LIMIT) {
1237             return b;
1238         }
1239         // Unexpected Part &quot;part&quot; in parsed message.
1240         U_ASSERT(type==UMSGPAT_PART_TYPE_SKIP_SYNTAX || type==UMSGPAT_PART_TYPE_INSERT_CHAR);
1241         prevIndex=part.getLimit();
1242     }
1243 }
1244 
1245 
1246 FieldPosition* MessageFormat::updateMetaData(AppendableWrapper&amp; /*dest*/, int32_t /*prevLength*/,
1247                              FieldPosition* /*fp*/, const Formattable* /*argId*/) const {
1248     // Unlike in Java, there are no field attributes defined for MessageFormat. Do nothing.
1249     return NULL;
1250     /*
1251       if (fp != NULL &amp;&amp; Field.ARGUMENT.equals(fp.getFieldAttribute())) {
1252           fp-&gt;setBeginIndex(prevLength);
1253           fp-&gt;setEndIndex(dest.get_length());
1254           return NULL;
1255       }
1256       return fp;
1257     */
1258 }
1259 
1260 int32_t
1261 MessageFormat::findOtherSubMessage(int32_t partIndex) const {
1262     int32_t count=msgPattern.countParts();
1263     const MessagePattern::Part *part = &amp;msgPattern.getPart(partIndex);
1264     if(MessagePattern::Part::hasNumericValue(part-&gt;getType())) {
1265         ++partIndex;
1266     }
1267     // Iterate over (ARG_SELECTOR [ARG_INT|ARG_DOUBLE] message) tuples
1268     // until ARG_LIMIT or end of plural-only pattern.
1269     UnicodeString other(FALSE, OTHER_STRING, 5);
1270     do {
1271         part=&amp;msgPattern.getPart(partIndex++);
1272         UMessagePatternPartType type=part-&gt;getType();
1273         if(type==UMSGPAT_PART_TYPE_ARG_LIMIT) {
1274             break;
1275         }
1276         U_ASSERT(type==UMSGPAT_PART_TYPE_ARG_SELECTOR);
1277         // part is an ARG_SELECTOR followed by an optional explicit value, and then a message
1278         if(msgPattern.partSubstringMatches(*part, other)) {
1279             return partIndex;
1280         }
1281         if(MessagePattern::Part::hasNumericValue(msgPattern.getPartType(partIndex))) {
1282             ++partIndex;  // skip the numeric-value part of &quot;=1&quot; etc.
1283         }
1284         partIndex=msgPattern.getLimitPartIndex(partIndex);
1285     } while(++partIndex&lt;count);
1286     return 0;
1287 }
1288 
1289 int32_t
1290 MessageFormat::findFirstPluralNumberArg(int32_t msgStart, const UnicodeString &amp;argName) const {
1291     for(int32_t i=msgStart+1;; ++i) {
1292         const MessagePattern::Part &amp;part=msgPattern.getPart(i);
1293         UMessagePatternPartType type=part.getType();
1294         if(type==UMSGPAT_PART_TYPE_MSG_LIMIT) {
1295             return 0;
1296         }
1297         if(type==UMSGPAT_PART_TYPE_REPLACE_NUMBER) {
1298             return -1;
1299         }
1300         if(type==UMSGPAT_PART_TYPE_ARG_START) {
1301             UMessagePatternArgType argType=part.getArgType();
1302             if(!argName.isEmpty() &amp;&amp; (argType==UMSGPAT_ARG_TYPE_NONE || argType==UMSGPAT_ARG_TYPE_SIMPLE)) {
1303                 // ARG_NUMBER or ARG_NAME
1304                 if(msgPattern.partSubstringMatches(msgPattern.getPart(i+1), argName)) {
1305                     return i;
1306                 }
1307             }
1308             i=msgPattern.getLimitPartIndex(i);
1309         }
1310     }
1311 }
1312 
1313 void MessageFormat::copyObjects(const MessageFormat&amp; that, UErrorCode&amp; ec) {
1314     // Deep copy pointer fields.
1315     // We need not copy the formatAliases because they are re-filled
1316     // in each getFormats() call.
1317     // The defaultNumberFormat, defaultDateFormat and pluralProvider.rules
1318     // also get created on demand.
1319     argTypeCount = that.argTypeCount;
1320     if (argTypeCount &gt; 0) {
1321         if (!allocateArgTypes(argTypeCount, ec)) {
1322             return;
1323         }
1324         uprv_memcpy(argTypes, that.argTypes, argTypeCount * sizeof(argTypes[0]));
1325     }
1326     if (cachedFormatters != NULL) {
1327         uhash_removeAll(cachedFormatters);
1328     }
1329     if (customFormatArgStarts != NULL) {
1330         uhash_removeAll(customFormatArgStarts);
1331     }
1332     if (that.cachedFormatters) {
1333         if (cachedFormatters == NULL) {
1334             cachedFormatters=uhash_open(uhash_hashLong, uhash_compareLong,
1335                                         equalFormatsForHash, &amp;ec);
1336             if (U_FAILURE(ec)) {
1337                 return;
1338             }
1339             uhash_setValueDeleter(cachedFormatters, uprv_deleteUObject);
1340         }
1341 
1342         const int32_t count = uhash_count(that.cachedFormatters);
1343         int32_t pos, idx;
1344         for (idx = 0, pos = UHASH_FIRST; idx &lt; count &amp;&amp; U_SUCCESS(ec); ++idx) {
1345             const UHashElement* cur = uhash_nextElement(that.cachedFormatters, &amp;pos);
1346             Format* newFormat = ((Format*)(cur-&gt;value.pointer))-&gt;clone();
1347             if (newFormat) {
1348                 uhash_iput(cachedFormatters, cur-&gt;key.integer, newFormat, &amp;ec);
1349             } else {
1350                 ec = U_MEMORY_ALLOCATION_ERROR;
1351                 return;
1352             }
1353         }
1354     }
1355     if (that.customFormatArgStarts) {
1356         if (customFormatArgStarts == NULL) {
1357             customFormatArgStarts=uhash_open(uhash_hashLong, uhash_compareLong,
1358                                               NULL, &amp;ec);
1359         }
1360         const int32_t count = uhash_count(that.customFormatArgStarts);
1361         int32_t pos, idx;
1362         for (idx = 0, pos = UHASH_FIRST; idx &lt; count &amp;&amp; U_SUCCESS(ec); ++idx) {
1363             const UHashElement* cur = uhash_nextElement(that.customFormatArgStarts, &amp;pos);
1364             uhash_iputi(customFormatArgStarts, cur-&gt;key.integer, cur-&gt;value.integer, &amp;ec);
1365         }
1366     }
1367 }
1368 
1369 
1370 Formattable*
1371 MessageFormat::parse(int32_t msgStart,
1372                      const UnicodeString&amp; source,
1373                      ParsePosition&amp; pos,
1374                      int32_t&amp; count,
1375                      UErrorCode&amp; ec) const {
1376     count = 0;
1377     if (U_FAILURE(ec)) {
1378         pos.setErrorIndex(pos.getIndex());
1379         return NULL;
1380     }
1381     // parse() does not work with named arguments.
1382     if (msgPattern.hasNamedArguments()) {
1383         ec = U_ARGUMENT_TYPE_MISMATCH;
1384         pos.setErrorIndex(pos.getIndex());
1385         return NULL;
1386     }
1387     LocalArray&lt;Formattable&gt; resultArray(new Formattable[argTypeCount ? argTypeCount : 1]);
1388     const UnicodeString&amp; msgString=msgPattern.getPatternString();
1389     int32_t prevIndex=msgPattern.getPart(msgStart).getLimit();
1390     int32_t sourceOffset = pos.getIndex();
1391     ParsePosition tempStatus(0);
1392 
1393     for(int32_t i=msgStart+1; ; ++i) {
1394         UBool haveArgResult = FALSE;
1395         const MessagePattern::Part* part=&amp;msgPattern.getPart(i);
1396         const UMessagePatternPartType type=part-&gt;getType();
1397         int32_t index=part-&gt;getIndex();
1398         // Make sure the literal string matches.
1399         int32_t len = index - prevIndex;
1400         if (len == 0 || (0 == msgString.compare(prevIndex, len, source, sourceOffset, len))) {
1401             sourceOffset += len;
1402             prevIndex += len;
1403         } else {
1404             pos.setErrorIndex(sourceOffset);
1405             return NULL; // leave index as is to signal error
1406         }
1407         if(type==UMSGPAT_PART_TYPE_MSG_LIMIT) {
1408             // Things went well! Done.
1409             pos.setIndex(sourceOffset);
1410             return resultArray.orphan();
1411         }
1412         if(type==UMSGPAT_PART_TYPE_SKIP_SYNTAX || type==UMSGPAT_PART_TYPE_INSERT_CHAR) {
1413             prevIndex=part-&gt;getLimit();
1414             continue;
1415         }
1416         // We do not support parsing Plural formats. (No REPLACE_NUMBER here.)
1417         // Unexpected Part &quot;part&quot; in parsed message.
1418         U_ASSERT(type==UMSGPAT_PART_TYPE_ARG_START);
1419         int32_t argLimit=msgPattern.getLimitPartIndex(i);
1420 
1421         UMessagePatternArgType argType=part-&gt;getArgType();
1422         part=&amp;msgPattern.getPart(++i);
1423         int32_t argNumber = part-&gt;getValue();  // ARG_NUMBER
1424         UnicodeString key;
1425         ++i;
1426         const Format* formatter = NULL;
1427         Formattable&amp; argResult = resultArray[argNumber];
1428 
1429         if(cachedFormatters!=NULL &amp;&amp; (formatter = getCachedFormatter(i - 2))!=NULL) {
1430             // Just parse using the formatter.
1431             tempStatus.setIndex(sourceOffset);
1432             formatter-&gt;parseObject(source, argResult, tempStatus);
1433             if (tempStatus.getIndex() == sourceOffset) {
1434                 pos.setErrorIndex(sourceOffset);
1435                 return NULL; // leave index as is to signal error
1436             }
1437             sourceOffset = tempStatus.getIndex();
1438             haveArgResult = TRUE;
1439         } else if(
1440             argType==UMSGPAT_ARG_TYPE_NONE || (cachedFormatters &amp;&amp; uhash_iget(cachedFormatters, i -2))) {
1441             // We arrive here if getCachedFormatter returned NULL, but there was actually an element in the hash table.
1442             // This can only happen if the hash table contained a DummyFormat, so the if statement above is a check
1443             // for the hash table containind DummyFormat.
1444 
1445             // Match as a string.
1446             // if at end, use longest possible match
1447             // otherwise uses first match to intervening string
1448             // does NOT recursively try all possibilities
1449             UnicodeString stringAfterArgument = getLiteralStringUntilNextArgument(argLimit);
1450             int32_t next;
1451             if (!stringAfterArgument.isEmpty()) {
1452                 next = source.indexOf(stringAfterArgument, sourceOffset);
1453             } else {
1454                 next = source.length();
1455             }
1456             if (next &lt; 0) {
1457                 pos.setErrorIndex(sourceOffset);
1458                 return NULL; // leave index as is to signal error
1459             } else {
1460                 UnicodeString strValue(source.tempSubString(sourceOffset, next - sourceOffset));
1461                 UnicodeString compValue;
1462                 compValue.append(LEFT_CURLY_BRACE);
1463                 itos(argNumber, compValue);
1464                 compValue.append(RIGHT_CURLY_BRACE);
1465                 if (0 != strValue.compare(compValue)) {
1466                     argResult.setString(strValue);
1467                     haveArgResult = TRUE;
1468                 }
1469                 sourceOffset = next;
1470             }
1471         } else if(argType==UMSGPAT_ARG_TYPE_CHOICE) {
1472             tempStatus.setIndex(sourceOffset);
1473             double choiceResult = ChoiceFormat::parseArgument(msgPattern, i, source, tempStatus);
1474             if (tempStatus.getIndex() == sourceOffset) {
1475                 pos.setErrorIndex(sourceOffset);
1476                 return NULL; // leave index as is to signal error
1477             }
1478             argResult.setDouble(choiceResult);
1479             haveArgResult = TRUE;
1480             sourceOffset = tempStatus.getIndex();
1481         } else if(UMSGPAT_ARG_TYPE_HAS_PLURAL_STYLE(argType) || argType==UMSGPAT_ARG_TYPE_SELECT) {
1482             // Parsing not supported.
1483             ec = U_UNSUPPORTED_ERROR;
1484             return NULL;
1485         } else {
1486             // This should never happen.
1487             ec = U_INTERNAL_PROGRAM_ERROR;
1488             return NULL;
1489         }
1490         if (haveArgResult &amp;&amp; count &lt;= argNumber) {
1491             count = argNumber + 1;
1492         }
1493         prevIndex=msgPattern.getPart(argLimit).getLimit();
1494         i=argLimit;
1495     }
1496 }
1497 // -------------------------------------
1498 // Parses the source pattern and returns the Formattable objects array,
1499 // the array count and the ending parse position.  The caller of this method
1500 // owns the array.
1501 
1502 Formattable*
1503 MessageFormat::parse(const UnicodeString&amp; source,
1504                      ParsePosition&amp; pos,
1505                      int32_t&amp; count) const {
1506     UErrorCode ec = U_ZERO_ERROR;
1507     return parse(0, source, pos, count, ec);
1508 }
1509 
1510 // -------------------------------------
1511 // Parses the source string and returns the array of
1512 // Formattable objects and the array count.  The caller
1513 // owns the returned array.
1514 
1515 Formattable*
1516 MessageFormat::parse(const UnicodeString&amp; source,
1517                      int32_t&amp; cnt,
1518                      UErrorCode&amp; success) const
1519 {
1520     if (msgPattern.hasNamedArguments()) {
1521         success = U_ARGUMENT_TYPE_MISMATCH;
1522         return NULL;
1523     }
1524     ParsePosition status(0);
1525     // Calls the actual implementation method and starts
1526     // from zero offset of the source text.
1527     Formattable* result = parse(source, status, cnt);
1528     if (status.getIndex() == 0) {
1529         success = U_MESSAGE_PARSE_ERROR;
1530         delete[] result;
1531         return NULL;
1532     }
1533     return result;
1534 }
1535 
1536 // -------------------------------------
1537 // Parses the source text and copy into the result buffer.
1538 
1539 void
1540 MessageFormat::parseObject( const UnicodeString&amp; source,
1541                             Formattable&amp; result,
1542                             ParsePosition&amp; status) const
1543 {
1544     int32_t cnt = 0;
1545     Formattable* tmpResult = parse(source, status, cnt);
1546     if (tmpResult != NULL)
1547         result.adoptArray(tmpResult, cnt);
1548 }
1549 
1550 UnicodeString
1551 MessageFormat::autoQuoteApostrophe(const UnicodeString&amp; pattern, UErrorCode&amp; status) {
1552     UnicodeString result;
1553     if (U_SUCCESS(status)) {
1554         int32_t plen = pattern.length();
1555         const UChar* pat = pattern.getBuffer();
1556         int32_t blen = plen * 2 + 1; // space for null termination, convenience
1557         UChar* buf = result.getBuffer(blen);
1558         if (buf == NULL) {
1559             status = U_MEMORY_ALLOCATION_ERROR;
1560         } else {
1561             int32_t len = umsg_autoQuoteApostrophe(pat, plen, buf, blen, &amp;status);
1562             result.releaseBuffer(U_SUCCESS(status) ? len : 0);
1563         }
1564     }
1565     if (U_FAILURE(status)) {
1566         result.setToBogus();
1567     }
1568     return result;
1569 }
1570 
1571 // -------------------------------------
1572 
1573 static Format* makeRBNF(URBNFRuleSetTag tag, const Locale&amp; locale, const UnicodeString&amp; defaultRuleSet, UErrorCode&amp; ec) {
1574     RuleBasedNumberFormat* fmt = new RuleBasedNumberFormat(tag, locale, ec);
1575     if (fmt == NULL) {
1576         ec = U_MEMORY_ALLOCATION_ERROR;
1577     } else if (U_SUCCESS(ec) &amp;&amp; defaultRuleSet.length() &gt; 0) {
1578         UErrorCode localStatus = U_ZERO_ERROR; // ignore unrecognized default rule set
1579         fmt-&gt;setDefaultRuleSet(defaultRuleSet, localStatus);
1580     }
1581     return fmt;
1582 }
1583 
1584 void MessageFormat::cacheExplicitFormats(UErrorCode&amp; status) {
1585     if (U_FAILURE(status)) {
1586         return;
1587     }
1588 
1589     if (cachedFormatters != NULL) {
1590         uhash_removeAll(cachedFormatters);
1591     }
1592     if (customFormatArgStarts != NULL) {
1593         uhash_removeAll(customFormatArgStarts);
1594     }
1595 
1596     // The last two &quot;parts&quot; can at most be ARG_LIMIT and MSG_LIMIT
1597     // which we need not examine.
1598     int32_t limit = msgPattern.countParts() - 2;
1599     argTypeCount = 0;
1600     // We also need not look at the first two &quot;parts&quot;
1601     // (at most MSG_START and ARG_START) in this loop.
1602     // We determine the argTypeCount first so that we can allocateArgTypes
1603     // so that the next loop can set argTypes[argNumber].
1604     // (This is for the C API which needs the argTypes to read its va_arg list.)
1605     for (int32_t i = 2; i &lt; limit &amp;&amp; U_SUCCESS(status); ++i) {
1606         const MessagePattern::Part&amp; part = msgPattern.getPart(i);
1607         if (part.getType() == UMSGPAT_PART_TYPE_ARG_NUMBER) {
1608             const int argNumber = part.getValue();
1609             if (argNumber &gt;= argTypeCount) {
1610                 argTypeCount = argNumber + 1;
1611             }
1612         }
1613     }
1614     if (!allocateArgTypes(argTypeCount, status)) {
1615         return;
1616     }
1617     // Set all argTypes to kObject, as a &quot;none&quot; value, for lack of any better value.
1618     // We never use kObject for real arguments.
1619     // We use it as &quot;no argument yet&quot; for the check for hasArgTypeConflicts.
1620     for (int32_t i = 0; i &lt; argTypeCount; ++i) {
1621         argTypes[i] = Formattable::kObject;
1622     }
1623     hasArgTypeConflicts = FALSE;
1624 
1625     // This loop starts at part index 1 because we do need to examine
1626     // ARG_START parts. (But we can ignore the MSG_START.)
1627     for (int32_t i = 1; i &lt; limit &amp;&amp; U_SUCCESS(status); ++i) {
1628         const MessagePattern::Part* part = &amp;msgPattern.getPart(i);
1629         if (part-&gt;getType() != UMSGPAT_PART_TYPE_ARG_START) {
1630             continue;
1631         }
1632         UMessagePatternArgType argType = part-&gt;getArgType();
1633 
1634         int32_t argNumber = -1;
1635         part = &amp;msgPattern.getPart(i + 1);
1636         if (part-&gt;getType() == UMSGPAT_PART_TYPE_ARG_NUMBER) {
1637             argNumber = part-&gt;getValue();
1638         }
1639         Formattable::Type formattableType;
1640 
1641         switch (argType) {
1642         case UMSGPAT_ARG_TYPE_NONE:
1643             formattableType = Formattable::kString;
1644             break;
1645         case UMSGPAT_ARG_TYPE_SIMPLE: {
1646             int32_t index = i;
1647             i += 2;
1648             UnicodeString explicitType = msgPattern.getSubstring(msgPattern.getPart(i++));
1649             UnicodeString style;
1650             if ((part = &amp;msgPattern.getPart(i))-&gt;getType() == UMSGPAT_PART_TYPE_ARG_STYLE) {
1651                 style = msgPattern.getSubstring(*part);
1652                 ++i;
1653             }
1654             UParseError parseError;
1655             Format* formatter = createAppropriateFormat(explicitType, style, formattableType, parseError, status);
1656             setArgStartFormat(index, formatter, status);
1657             break;
1658         }
1659         case UMSGPAT_ARG_TYPE_CHOICE:
1660         case UMSGPAT_ARG_TYPE_PLURAL:
1661         case UMSGPAT_ARG_TYPE_SELECTORDINAL:
1662             formattableType = Formattable::kDouble;
1663             break;
1664         case UMSGPAT_ARG_TYPE_SELECT:
1665             formattableType = Formattable::kString;
1666             break;
1667         default:
1668             status = U_INTERNAL_PROGRAM_ERROR;  // Should be unreachable.
1669             formattableType = Formattable::kString;
1670             break;
1671         }
1672         if (argNumber != -1) {
1673             if (argTypes[argNumber] != Formattable::kObject &amp;&amp; argTypes[argNumber] != formattableType) {
1674                 hasArgTypeConflicts = TRUE;
1675             }
1676             argTypes[argNumber] = formattableType;
1677         }
1678     }
1679 }
1680 
<a name="10" id="anc10"></a>
1681 Format* MessageFormat::createAppropriateFormat(UnicodeString&amp; type, UnicodeString&amp; style,
1682                                                Formattable::Type&amp; formattableType, UParseError&amp; parseError,
1683                                                UErrorCode&amp; ec) {
1684     if (U_FAILURE(ec)) {
1685         return NULL;
1686     }
1687     Format* fmt = NULL;
1688     int32_t typeID, styleID;
1689     DateFormat::EStyle date_style;
<a name="11" id="anc11"></a><span class="line-added">1690     int32_t firstNonSpace;</span>
1691 
1692     switch (typeID = findKeyword(type, TYPE_IDS)) {
1693     case 0: // number
1694         formattableType = Formattable::kDouble;
1695         switch (findKeyword(style, NUMBER_STYLE_IDS)) {
1696         case 0: // default
1697             fmt = NumberFormat::createInstance(fLocale, ec);
1698             break;
1699         case 1: // currency
1700             fmt = NumberFormat::createCurrencyInstance(fLocale, ec);
1701             break;
1702         case 2: // percent
1703             fmt = NumberFormat::createPercentInstance(fLocale, ec);
1704             break;
1705         case 3: // integer
1706             formattableType = Formattable::kLong;
1707             fmt = createIntegerFormat(fLocale, ec);
1708             break;
1709         default: // pattern or skeleton
<a name="12" id="anc12"></a><span class="line-modified">1710             firstNonSpace = PatternProps::skipWhiteSpace(style, 0);</span>
<span class="line-modified">1711             if (style.compare(firstNonSpace, 2, u&quot;::&quot;, 0, 2) == 0) {</span>

1712                 // Skeleton
<a name="13" id="anc13"></a><span class="line-modified">1713                 UnicodeString skeleton = style.tempSubString(firstNonSpace + 2);</span>
1714                 fmt = number::NumberFormatter::forSkeleton(skeleton, ec).locale(fLocale).toFormat(ec);
1715             } else {
1716                 // Pattern
1717                 fmt = NumberFormat::createInstance(fLocale, ec);
1718                 if (fmt) {
1719                     auto* decfmt = dynamic_cast&lt;DecimalFormat*&gt;(fmt);
1720                     if (decfmt != nullptr) {
1721                         decfmt-&gt;applyPattern(style, parseError, ec);
1722                     }
1723                 }
1724             }
1725             break;
1726         }
1727         break;
1728 
1729     case 1: // date
1730     case 2: // time
1731         formattableType = Formattable::kDate;
<a name="14" id="anc14"></a><span class="line-modified">1732         firstNonSpace = PatternProps::skipWhiteSpace(style, 0);</span>
<span class="line-modified">1733         if (style.compare(firstNonSpace, 2, u&quot;::&quot;, 0, 2) == 0) {</span>
<span class="line-modified">1734             // Skeleton</span>
<span class="line-modified">1735             UnicodeString skeleton = style.tempSubString(firstNonSpace + 2);</span>
<span class="line-modified">1736             fmt = DateFormat::createInstanceForSkeleton(skeleton, fLocale, ec);</span>
1737         } else {
<a name="15" id="anc15"></a><span class="line-modified">1738             // Pattern</span>
<span class="line-modified">1739             styleID = findKeyword(style, DATE_STYLE_IDS);</span>
<span class="line-added">1740             date_style = (styleID &gt;= 0) ? DATE_STYLES[styleID] : DateFormat::kDefault;</span>
1741 
<a name="16" id="anc16"></a><span class="line-modified">1742             if (typeID == 1) {</span>
<span class="line-modified">1743                 fmt = DateFormat::createDateInstance(date_style, fLocale);</span>
<span class="line-modified">1744             } else {</span>
<span class="line-modified">1745                 fmt = DateFormat::createTimeInstance(date_style, fLocale);</span>
<span class="line-added">1746             }</span>
<span class="line-added">1747 </span>
<span class="line-added">1748             if (styleID &lt; 0 &amp;&amp; fmt != NULL) {</span>
<span class="line-added">1749                 SimpleDateFormat* sdtfmt = dynamic_cast&lt;SimpleDateFormat*&gt;(fmt);</span>
<span class="line-added">1750                 if (sdtfmt != NULL) {</span>
<span class="line-added">1751                     sdtfmt-&gt;applyPattern(style);</span>
<span class="line-added">1752                 }</span>
1753             }
1754         }
1755         break;
1756 
1757     case 3: // spellout
1758         formattableType = Formattable::kDouble;
1759         fmt = makeRBNF(URBNF_SPELLOUT, fLocale, style, ec);
1760         break;
1761     case 4: // ordinal
1762         formattableType = Formattable::kDouble;
1763         fmt = makeRBNF(URBNF_ORDINAL, fLocale, style, ec);
1764         break;
1765     case 5: // duration
1766         formattableType = Formattable::kDouble;
1767         fmt = makeRBNF(URBNF_DURATION, fLocale, style, ec);
1768         break;
1769     default:
1770         formattableType = Formattable::kString;
1771         ec = U_ILLEGAL_ARGUMENT_ERROR;
1772         break;
1773     }
1774 
1775     return fmt;
1776 }
1777 
1778 
1779 //-------------------------------------
1780 // Finds the string, s, in the string array, list.
1781 int32_t MessageFormat::findKeyword(const UnicodeString&amp; s,
1782                                    const UChar * const *list)
1783 {
1784     if (s.isEmpty()) {
1785         return 0; // default
1786     }
1787 
1788     int32_t length = s.length();
1789     const UChar *ps = PatternProps::trimWhiteSpace(s.getBuffer(), length);
1790     UnicodeString buffer(FALSE, ps, length);
1791     // Trims the space characters and turns all characters
1792     // in s to lower case.
1793     buffer.toLower(&quot;&quot;);
1794     for (int32_t i = 0; list[i]; ++i) {
1795         if (!buffer.compare(list[i], u_strlen(list[i]))) {
1796             return i;
1797         }
1798     }
1799     return -1;
1800 }
1801 
1802 /**
1803  * Convenience method that ought to be in NumberFormat
1804  */
1805 NumberFormat*
1806 MessageFormat::createIntegerFormat(const Locale&amp; locale, UErrorCode&amp; status) const {
1807     NumberFormat *temp = NumberFormat::createInstance(locale, status);
1808     DecimalFormat *temp2;
1809     if (temp != NULL &amp;&amp; (temp2 = dynamic_cast&lt;DecimalFormat*&gt;(temp)) != NULL) {
1810         temp2-&gt;setMaximumFractionDigits(0);
1811         temp2-&gt;setDecimalSeparatorAlwaysShown(FALSE);
1812         temp2-&gt;setParseIntegerOnly(TRUE);
1813     }
1814 
1815     return temp;
1816 }
1817 
1818 /**
1819  * Return the default number format.  Used to format a numeric
1820  * argument when subformats[i].format is NULL.  Returns NULL
1821  * on failure.
1822  *
1823  * Semantically const but may modify *this.
1824  */
1825 const NumberFormat* MessageFormat::getDefaultNumberFormat(UErrorCode&amp; ec) const {
1826     if (defaultNumberFormat == NULL) {
1827         MessageFormat* t = (MessageFormat*) this;
1828         t-&gt;defaultNumberFormat = NumberFormat::createInstance(fLocale, ec);
1829         if (U_FAILURE(ec)) {
1830             delete t-&gt;defaultNumberFormat;
1831             t-&gt;defaultNumberFormat = NULL;
1832         } else if (t-&gt;defaultNumberFormat == NULL) {
1833             ec = U_MEMORY_ALLOCATION_ERROR;
1834         }
1835     }
1836     return defaultNumberFormat;
1837 }
1838 
1839 /**
1840  * Return the default date format.  Used to format a date
1841  * argument when subformats[i].format is NULL.  Returns NULL
1842  * on failure.
1843  *
1844  * Semantically const but may modify *this.
1845  */
1846 const DateFormat* MessageFormat::getDefaultDateFormat(UErrorCode&amp; ec) const {
1847     if (defaultDateFormat == NULL) {
1848         MessageFormat* t = (MessageFormat*) this;
1849         t-&gt;defaultDateFormat = DateFormat::createDateTimeInstance(DateFormat::kShort, DateFormat::kShort, fLocale);
1850         if (t-&gt;defaultDateFormat == NULL) {
1851             ec = U_MEMORY_ALLOCATION_ERROR;
1852         }
1853     }
1854     return defaultDateFormat;
1855 }
1856 
1857 UBool
1858 MessageFormat::usesNamedArguments() const {
1859     return msgPattern.hasNamedArguments();
1860 }
1861 
1862 int32_t
1863 MessageFormat::getArgTypeCount() const {
1864     return argTypeCount;
1865 }
1866 
1867 UBool MessageFormat::equalFormats(const void* left, const void* right) {
1868     return *(const Format*)left==*(const Format*)right;
1869 }
1870 
1871 
1872 UBool MessageFormat::DummyFormat::operator==(const Format&amp;) const {
1873     return TRUE;
1874 }
1875 
1876 Format* MessageFormat::DummyFormat::clone() const {
1877     return new DummyFormat();
1878 }
1879 
1880 UnicodeString&amp; MessageFormat::DummyFormat::format(const Formattable&amp;,
1881                           UnicodeString&amp; appendTo,
1882                           UErrorCode&amp; status) const {
1883     if (U_SUCCESS(status)) {
1884         status = U_UNSUPPORTED_ERROR;
1885     }
1886     return appendTo;
1887 }
1888 
1889 UnicodeString&amp; MessageFormat::DummyFormat::format(const Formattable&amp;,
1890                           UnicodeString&amp; appendTo,
1891                           FieldPosition&amp;,
1892                           UErrorCode&amp; status) const {
1893     if (U_SUCCESS(status)) {
1894         status = U_UNSUPPORTED_ERROR;
1895     }
1896     return appendTo;
1897 }
1898 
1899 UnicodeString&amp; MessageFormat::DummyFormat::format(const Formattable&amp;,
1900                           UnicodeString&amp; appendTo,
1901                           FieldPositionIterator*,
1902                           UErrorCode&amp; status) const {
1903     if (U_SUCCESS(status)) {
1904         status = U_UNSUPPORTED_ERROR;
1905     }
1906     return appendTo;
1907 }
1908 
1909 void MessageFormat::DummyFormat::parseObject(const UnicodeString&amp;,
1910                                                      Formattable&amp;,
1911                                                      ParsePosition&amp; ) const {
1912 }
1913 
1914 
1915 FormatNameEnumeration::FormatNameEnumeration(UVector *fNameList, UErrorCode&amp; /*status*/) {
1916     pos=0;
1917     fFormatNames = fNameList;
1918 }
1919 
1920 const UnicodeString*
1921 FormatNameEnumeration::snext(UErrorCode&amp; status) {
1922     if (U_SUCCESS(status) &amp;&amp; pos &lt; fFormatNames-&gt;size()) {
1923         return (const UnicodeString*)fFormatNames-&gt;elementAt(pos++);
1924     }
1925     return NULL;
1926 }
1927 
1928 void
1929 FormatNameEnumeration::reset(UErrorCode&amp; /*status*/) {
1930     pos=0;
1931 }
1932 
1933 int32_t
1934 FormatNameEnumeration::count(UErrorCode&amp; /*status*/) const {
1935     return (fFormatNames==NULL) ? 0 : fFormatNames-&gt;size();
1936 }
1937 
1938 FormatNameEnumeration::~FormatNameEnumeration() {
1939     delete fFormatNames;
1940 }
1941 
1942 MessageFormat::PluralSelectorProvider::PluralSelectorProvider(const MessageFormat &amp;mf, UPluralType t)
1943         : msgFormat(mf), rules(NULL), type(t) {
1944 }
1945 
1946 MessageFormat::PluralSelectorProvider::~PluralSelectorProvider() {
1947     delete rules;
1948 }
1949 
1950 UnicodeString MessageFormat::PluralSelectorProvider::select(void *ctx, double number,
1951                                                             UErrorCode&amp; ec) const {
1952     if (U_FAILURE(ec)) {
1953         return UnicodeString(FALSE, OTHER_STRING, 5);
1954     }
1955     MessageFormat::PluralSelectorProvider* t = const_cast&lt;MessageFormat::PluralSelectorProvider*&gt;(this);
1956     if(rules == NULL) {
1957         t-&gt;rules = PluralRules::forLocale(msgFormat.fLocale, type, ec);
1958         if (U_FAILURE(ec)) {
1959             return UnicodeString(FALSE, OTHER_STRING, 5);
1960         }
1961     }
1962     // Select a sub-message according to how the number is formatted,
1963     // which is specified in the selected sub-message.
1964     // We avoid this circle by looking at how
1965     // the number is formatted in the &quot;other&quot; sub-message
1966     // which must always be present and usually contains the number.
1967     // Message authors should be consistent across sub-messages.
1968     PluralSelectorContext &amp;context = *static_cast&lt;PluralSelectorContext *&gt;(ctx);
1969     int32_t otherIndex = msgFormat.findOtherSubMessage(context.startIndex);
1970     context.numberArgIndex = msgFormat.findFirstPluralNumberArg(otherIndex, context.argName);
1971     if(context.numberArgIndex &gt; 0 &amp;&amp; msgFormat.cachedFormatters != NULL) {
1972         context.formatter =
1973             (const Format*)uhash_iget(msgFormat.cachedFormatters, context.numberArgIndex);
1974     }
1975     if(context.formatter == NULL) {
1976         context.formatter = msgFormat.getDefaultNumberFormat(ec);
1977         context.forReplaceNumber = TRUE;
1978     }
1979     if (context.number.getDouble(ec) != number) {
1980         ec = U_INTERNAL_PROGRAM_ERROR;
1981         return UnicodeString(FALSE, OTHER_STRING, 5);
1982     }
1983     context.formatter-&gt;format(context.number, context.numberString, ec);
1984     auto* decFmt = dynamic_cast&lt;const DecimalFormat *&gt;(context.formatter);
1985     if(decFmt != NULL) {
1986         number::impl::DecimalQuantity dq;
1987         decFmt-&gt;formatToDecimalQuantity(context.number, dq, ec);
1988         if (U_FAILURE(ec)) {
1989             return UnicodeString(FALSE, OTHER_STRING, 5);
1990         }
1991         return rules-&gt;select(dq);
1992     } else {
1993         return rules-&gt;select(number);
1994     }
1995 }
1996 
1997 void MessageFormat::PluralSelectorProvider::reset() {
1998     delete rules;
1999     rules = NULL;
2000 }
2001 
2002 
2003 U_NAMESPACE_END
2004 
2005 #endif /* #if !UCONFIG_NO_FORMATTING */
2006 
2007 //eof
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>