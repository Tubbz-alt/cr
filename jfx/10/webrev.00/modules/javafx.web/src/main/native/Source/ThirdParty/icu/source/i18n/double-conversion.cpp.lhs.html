<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/double-conversion.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2018 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 //
   4 // From the double-conversion library. Original license:
   5 //
   6 // Copyright 2010 the V8 project authors. All rights reserved.
   7 // Redistribution and use in source and binary forms, with or without
   8 // modification, are permitted provided that the following conditions are
   9 // met:
  10 //
  11 //     * Redistributions of source code must retain the above copyright
  12 //       notice, this list of conditions and the following disclaimer.
  13 //     * Redistributions in binary form must reproduce the above
  14 //       copyright notice, this list of conditions and the following
  15 //       disclaimer in the documentation and/or other materials provided
  16 //       with the distribution.
  17 //     * Neither the name of Google Inc. nor the names of its
  18 //       contributors may be used to endorse or promote products derived
  19 //       from this software without specific prior written permission.
  20 //
  21 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  22 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  23 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  24 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  25 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  26 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  27 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  28 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  29 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  30 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  31 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  32 
  33 // ICU PATCH: ifdef around UCONFIG_NO_FORMATTING
  34 #include &quot;unicode/utypes.h&quot;
  35 #if !UCONFIG_NO_FORMATTING
  36 
<a name="1" id="anc1"></a><span class="line-modified">  37 #include &lt;limits.h&gt;</span>
<span class="line-modified">  38 #include &lt;math.h&gt;</span>



  39 
  40 // ICU PATCH: Customize header file paths for ICU.
  41 // The file fixed-dtoa.h is not needed.
  42 
  43 #include &quot;double-conversion.h&quot;
  44 
  45 #include &quot;double-conversion-bignum-dtoa.h&quot;
  46 #include &quot;double-conversion-fast-dtoa.h&quot;
  47 #include &quot;double-conversion-ieee.h&quot;
  48 #include &quot;double-conversion-strtod.h&quot;
  49 #include &quot;double-conversion-utils.h&quot;
  50 
  51 // ICU PATCH: Wrap in ICU namespace
  52 U_NAMESPACE_BEGIN
  53 
  54 namespace double_conversion {
  55 
  56 #if 0  // not needed for ICU
  57 const DoubleToStringConverter&amp; DoubleToStringConverter::EcmaScriptConverter() {
  58   int flags = UNIQUE_ZERO | EMIT_POSITIVE_EXPONENT_SIGN;
  59   static DoubleToStringConverter converter(flags,
  60                                            &quot;Infinity&quot;,
  61                                            &quot;NaN&quot;,
  62                                            &#39;e&#39;,
  63                                            -6, 21,
  64                                            6, 0);
  65   return converter;
  66 }
  67 
  68 
  69 bool DoubleToStringConverter::HandleSpecialValues(
  70     double value,
  71     StringBuilder* result_builder) const {
  72   Double double_inspect(value);
  73   if (double_inspect.IsInfinite()) {
  74     if (infinity_symbol_ == NULL) return false;
  75     if (value &lt; 0) {
  76       result_builder-&gt;AddCharacter(&#39;-&#39;);
  77     }
  78     result_builder-&gt;AddString(infinity_symbol_);
  79     return true;
  80   }
  81   if (double_inspect.IsNan()) {
  82     if (nan_symbol_ == NULL) return false;
  83     result_builder-&gt;AddString(nan_symbol_);
  84     return true;
  85   }
  86   return false;
  87 }
  88 
  89 
  90 void DoubleToStringConverter::CreateExponentialRepresentation(
  91     const char* decimal_digits,
  92     int length,
  93     int exponent,
  94     StringBuilder* result_builder) const {
  95   ASSERT(length != 0);
  96   result_builder-&gt;AddCharacter(decimal_digits[0]);
  97   if (length != 1) {
  98     result_builder-&gt;AddCharacter(&#39;.&#39;);
  99     result_builder-&gt;AddSubstring(&amp;decimal_digits[1], length-1);
 100   }
 101   result_builder-&gt;AddCharacter(exponent_character_);
 102   if (exponent &lt; 0) {
 103     result_builder-&gt;AddCharacter(&#39;-&#39;);
 104     exponent = -exponent;
 105   } else {
 106     if ((flags_ &amp; EMIT_POSITIVE_EXPONENT_SIGN) != 0) {
 107       result_builder-&gt;AddCharacter(&#39;+&#39;);
 108     }
 109   }
 110   if (exponent == 0) {
 111     result_builder-&gt;AddCharacter(&#39;0&#39;);
 112     return;
 113   }
 114   ASSERT(exponent &lt; 1e4);
 115   const int kMaxExponentLength = 5;
 116   char buffer[kMaxExponentLength + 1];
 117   buffer[kMaxExponentLength] = &#39;\0&#39;;
 118   int first_char_pos = kMaxExponentLength;
 119   while (exponent &gt; 0) {
 120     buffer[--first_char_pos] = &#39;0&#39; + (exponent % 10);
 121     exponent /= 10;
 122   }
 123   result_builder-&gt;AddSubstring(&amp;buffer[first_char_pos],
 124                                kMaxExponentLength - first_char_pos);
 125 }
 126 
 127 
 128 void DoubleToStringConverter::CreateDecimalRepresentation(
 129     const char* decimal_digits,
 130     int length,
 131     int decimal_point,
 132     int digits_after_point,
 133     StringBuilder* result_builder) const {
 134   // Create a representation that is padded with zeros if needed.
 135   if (decimal_point &lt;= 0) {
 136       // &quot;0.00000decimal_rep&quot; or &quot;0.000decimal_rep00&quot;.
 137     result_builder-&gt;AddCharacter(&#39;0&#39;);
 138     if (digits_after_point &gt; 0) {
 139       result_builder-&gt;AddCharacter(&#39;.&#39;);
 140       result_builder-&gt;AddPadding(&#39;0&#39;, -decimal_point);
 141       ASSERT(length &lt;= digits_after_point - (-decimal_point));
 142       result_builder-&gt;AddSubstring(decimal_digits, length);
 143       int remaining_digits = digits_after_point - (-decimal_point) - length;
 144       result_builder-&gt;AddPadding(&#39;0&#39;, remaining_digits);
 145     }
 146   } else if (decimal_point &gt;= length) {
 147     // &quot;decimal_rep0000.00000&quot; or &quot;decimal_rep.0000&quot;.
 148     result_builder-&gt;AddSubstring(decimal_digits, length);
 149     result_builder-&gt;AddPadding(&#39;0&#39;, decimal_point - length);
 150     if (digits_after_point &gt; 0) {
 151       result_builder-&gt;AddCharacter(&#39;.&#39;);
 152       result_builder-&gt;AddPadding(&#39;0&#39;, digits_after_point);
 153     }
 154   } else {
 155     // &quot;decima.l_rep000&quot;.
 156     ASSERT(digits_after_point &gt; 0);
 157     result_builder-&gt;AddSubstring(decimal_digits, decimal_point);
 158     result_builder-&gt;AddCharacter(&#39;.&#39;);
 159     ASSERT(length - decimal_point &lt;= digits_after_point);
 160     result_builder-&gt;AddSubstring(&amp;decimal_digits[decimal_point],
 161                                  length - decimal_point);
 162     int remaining_digits = digits_after_point - (length - decimal_point);
 163     result_builder-&gt;AddPadding(&#39;0&#39;, remaining_digits);
 164   }
 165   if (digits_after_point == 0) {
 166     if ((flags_ &amp; EMIT_TRAILING_DECIMAL_POINT) != 0) {
 167       result_builder-&gt;AddCharacter(&#39;.&#39;);
 168     }
 169     if ((flags_ &amp; EMIT_TRAILING_ZERO_AFTER_POINT) != 0) {
 170       result_builder-&gt;AddCharacter(&#39;0&#39;);
 171     }
 172   }
 173 }
 174 
 175 
 176 bool DoubleToStringConverter::ToShortestIeeeNumber(
 177     double value,
 178     StringBuilder* result_builder,
 179     DoubleToStringConverter::DtoaMode mode) const {
 180   ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE);
 181   if (Double(value).IsSpecial()) {
 182     return HandleSpecialValues(value, result_builder);
 183   }
 184 
 185   int decimal_point;
 186   bool sign;
 187   const int kDecimalRepCapacity = kBase10MaximalLength + 1;
 188   char decimal_rep[kDecimalRepCapacity];
 189   int decimal_rep_length;
 190 
 191   DoubleToAscii(value, mode, 0, decimal_rep, kDecimalRepCapacity,
 192                 &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
 193 
 194   bool unique_zero = (flags_ &amp; UNIQUE_ZERO) != 0;
 195   if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {
 196     result_builder-&gt;AddCharacter(&#39;-&#39;);
 197   }
 198 
 199   int exponent = decimal_point - 1;
 200   if ((decimal_in_shortest_low_ &lt;= exponent) &amp;&amp;
 201       (exponent &lt; decimal_in_shortest_high_)) {
 202     CreateDecimalRepresentation(decimal_rep, decimal_rep_length,
 203                                 decimal_point,
 204                                 Max(0, decimal_rep_length - decimal_point),
 205                                 result_builder);
 206   } else {
 207     CreateExponentialRepresentation(decimal_rep, decimal_rep_length, exponent,
 208                                     result_builder);
 209   }
 210   return true;
 211 }
 212 
 213 
 214 bool DoubleToStringConverter::ToFixed(double value,
 215                                       int requested_digits,
 216                                       StringBuilder* result_builder) const {
 217   ASSERT(kMaxFixedDigitsBeforePoint == 60);
 218   const double kFirstNonFixed = 1e60;
 219 
 220   if (Double(value).IsSpecial()) {
 221     return HandleSpecialValues(value, result_builder);
 222   }
 223 
 224   if (requested_digits &gt; kMaxFixedDigitsAfterPoint) return false;
 225   if (value &gt;= kFirstNonFixed || value &lt;= -kFirstNonFixed) return false;
 226 
 227   // Find a sufficiently precise decimal representation of n.
 228   int decimal_point;
 229   bool sign;
 230   // Add space for the &#39;\0&#39; byte.
 231   const int kDecimalRepCapacity =
 232       kMaxFixedDigitsBeforePoint + kMaxFixedDigitsAfterPoint + 1;
 233   char decimal_rep[kDecimalRepCapacity];
 234   int decimal_rep_length;
 235   DoubleToAscii(value, FIXED, requested_digits,
 236                 decimal_rep, kDecimalRepCapacity,
 237                 &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
 238 
 239   bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);
 240   if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {
 241     result_builder-&gt;AddCharacter(&#39;-&#39;);
 242   }
 243 
 244   CreateDecimalRepresentation(decimal_rep, decimal_rep_length, decimal_point,
 245                               requested_digits, result_builder);
 246   return true;
 247 }
 248 
 249 
 250 bool DoubleToStringConverter::ToExponential(
 251     double value,
 252     int requested_digits,
 253     StringBuilder* result_builder) const {
 254   if (Double(value).IsSpecial()) {
 255     return HandleSpecialValues(value, result_builder);
 256   }
 257 
 258   if (requested_digits &lt; -1) return false;
 259   if (requested_digits &gt; kMaxExponentialDigits) return false;
 260 
 261   int decimal_point;
 262   bool sign;
 263   // Add space for digit before the decimal point and the &#39;\0&#39; character.
 264   const int kDecimalRepCapacity = kMaxExponentialDigits + 2;
 265   ASSERT(kDecimalRepCapacity &gt; kBase10MaximalLength);
 266   char decimal_rep[kDecimalRepCapacity];
 267   int decimal_rep_length;
 268 
 269   if (requested_digits == -1) {
 270     DoubleToAscii(value, SHORTEST, 0,
 271                   decimal_rep, kDecimalRepCapacity,
 272                   &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
 273   } else {
 274     DoubleToAscii(value, PRECISION, requested_digits + 1,
 275                   decimal_rep, kDecimalRepCapacity,
 276                   &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
 277     ASSERT(decimal_rep_length &lt;= requested_digits + 1);
 278 
 279     for (int i = decimal_rep_length; i &lt; requested_digits + 1; ++i) {
 280       decimal_rep[i] = &#39;0&#39;;
 281     }
 282     decimal_rep_length = requested_digits + 1;
 283   }
 284 
 285   bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);
 286   if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {
 287     result_builder-&gt;AddCharacter(&#39;-&#39;);
 288   }
 289 
 290   int exponent = decimal_point - 1;
 291   CreateExponentialRepresentation(decimal_rep,
 292                                   decimal_rep_length,
 293                                   exponent,
 294                                   result_builder);
 295   return true;
 296 }
 297 
 298 
 299 bool DoubleToStringConverter::ToPrecision(double value,
 300                                           int precision,
 301                                           StringBuilder* result_builder) const {
 302   if (Double(value).IsSpecial()) {
 303     return HandleSpecialValues(value, result_builder);
 304   }
 305 
 306   if (precision &lt; kMinPrecisionDigits || precision &gt; kMaxPrecisionDigits) {
 307     return false;
 308   }
 309 
 310   // Find a sufficiently precise decimal representation of n.
 311   int decimal_point;
 312   bool sign;
 313   // Add one for the terminating null character.
 314   const int kDecimalRepCapacity = kMaxPrecisionDigits + 1;
 315   char decimal_rep[kDecimalRepCapacity];
 316   int decimal_rep_length;
 317 
 318   DoubleToAscii(value, PRECISION, precision,
 319                 decimal_rep, kDecimalRepCapacity,
 320                 &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
 321   ASSERT(decimal_rep_length &lt;= precision);
 322 
 323   bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);
 324   if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {
 325     result_builder-&gt;AddCharacter(&#39;-&#39;);
 326   }
 327 
 328   // The exponent if we print the number as x.xxeyyy. That is with the
 329   // decimal point after the first digit.
 330   int exponent = decimal_point - 1;
 331 
 332   int extra_zero = ((flags_ &amp; EMIT_TRAILING_ZERO_AFTER_POINT) != 0) ? 1 : 0;
 333   if ((-decimal_point + 1 &gt; max_leading_padding_zeroes_in_precision_mode_) ||
 334       (decimal_point - precision + extra_zero &gt;
 335        max_trailing_padding_zeroes_in_precision_mode_)) {
 336     // Fill buffer to contain &#39;precision&#39; digits.
 337     // Usually the buffer is already at the correct length, but &#39;DoubleToAscii&#39;
 338     // is allowed to return less characters.
 339     for (int i = decimal_rep_length; i &lt; precision; ++i) {
 340       decimal_rep[i] = &#39;0&#39;;
 341     }
 342 
 343     CreateExponentialRepresentation(decimal_rep,
 344                                     precision,
 345                                     exponent,
 346                                     result_builder);
 347   } else {
 348     CreateDecimalRepresentation(decimal_rep, decimal_rep_length, decimal_point,
 349                                 Max(0, precision - decimal_point),
 350                                 result_builder);
 351   }
 352   return true;
 353 }
 354 #endif // not needed for ICU
 355 
 356 
 357 static BignumDtoaMode DtoaToBignumDtoaMode(
 358     DoubleToStringConverter::DtoaMode dtoa_mode) {
 359   switch (dtoa_mode) {
 360     case DoubleToStringConverter::SHORTEST:  return BIGNUM_DTOA_SHORTEST;
 361     case DoubleToStringConverter::SHORTEST_SINGLE:
 362         return BIGNUM_DTOA_SHORTEST_SINGLE;
 363     case DoubleToStringConverter::FIXED:     return BIGNUM_DTOA_FIXED;
 364     case DoubleToStringConverter::PRECISION: return BIGNUM_DTOA_PRECISION;
 365     default:
 366       UNREACHABLE();
 367   }
 368 }
 369 
 370 
 371 void DoubleToStringConverter::DoubleToAscii(double v,
 372                                             DtoaMode mode,
 373                                             int requested_digits,
 374                                             char* buffer,
 375                                             int buffer_length,
 376                                             bool* sign,
 377                                             int* length,
 378                                             int* point) {
 379   Vector&lt;char&gt; vector(buffer, buffer_length);
 380   ASSERT(!Double(v).IsSpecial());
 381   ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE || requested_digits &gt;= 0);
 382 
 383   if (Double(v).Sign() &lt; 0) {
 384     *sign = true;
 385     v = -v;
 386   } else {
 387     *sign = false;
 388   }
 389 
 390   if (mode == PRECISION &amp;&amp; requested_digits == 0) {
 391     vector[0] = &#39;\0&#39;;
 392     *length = 0;
 393     return;
 394   }
 395 
 396   if (v == 0) {
 397     vector[0] = &#39;0&#39;;
 398     vector[1] = &#39;\0&#39;;
 399     *length = 1;
 400     *point = 1;
 401     return;
 402   }
 403 
 404   bool fast_worked;
 405   switch (mode) {
 406     case SHORTEST:
 407       fast_worked = FastDtoa(v, FAST_DTOA_SHORTEST, 0, vector, length, point);
 408       break;
 409 #if 0 // not needed for ICU
 410     case SHORTEST_SINGLE:
 411       fast_worked = FastDtoa(v, FAST_DTOA_SHORTEST_SINGLE, 0,
 412                              vector, length, point);
 413       break;
 414     case FIXED:
 415       fast_worked = FastFixedDtoa(v, requested_digits, vector, length, point);
 416       break;
 417     case PRECISION:
 418       fast_worked = FastDtoa(v, FAST_DTOA_PRECISION, requested_digits,
 419                              vector, length, point);
 420       break;
 421 #endif // not needed for ICU
 422     default:
 423       fast_worked = false;
 424       UNREACHABLE();
 425   }
 426   if (fast_worked) return;
 427 
 428   // If the fast dtoa didn&#39;t succeed use the slower bignum version.
 429   BignumDtoaMode bignum_mode = DtoaToBignumDtoaMode(mode);
 430   BignumDtoa(v, bignum_mode, requested_digits, vector, length, point);
 431   vector[*length] = &#39;\0&#39;;
 432 }
 433 
 434 
<a name="2" id="anc2"></a>
































 435 // Consumes the given substring from the iterator.
 436 // Returns false, if the substring does not match.
 437 template &lt;class Iterator&gt;
 438 static bool ConsumeSubString(Iterator* current,
 439                              Iterator end,
<a name="3" id="anc3"></a><span class="line-modified"> 440                              const char* substring) {</span>
<span class="line-modified"> 441   ASSERT(**current == *substring);</span>
<span class="line-modified"> 442   for (substring++; *substring != &#39;\0&#39;; substring++) {</span>
<span class="line-modified"> 443     ++*current;</span>
<span class="line-modified"> 444     if (*current == end || **current != *substring) return false;</span>

 445   }
<a name="4" id="anc4"></a><span class="line-removed"> 446   ++*current;</span>
<span class="line-removed"> 447   return true;</span>
 448 }
 449 
<a name="5" id="anc5"></a>






 450 
 451 // Maximum number of significant digits in decimal representation.
 452 // The longest possible double in decimal representation is
 453 // (2^53 - 1) * 2 ^ -1074 that is (2 ^ 53 - 1) * 5 ^ 1074 / 10 ^ 1074
 454 // (768 digits). If we parse a number whose first digits are equal to a
 455 // mean of 2 adjacent doubles (that could have up to 769 digits) the result
 456 // must be rounded to the bigger one unless the tail consists of zeros, so
 457 // we don&#39;t need to preserve all the digits.
 458 const int kMaxSignificantDigits = 772;
 459 
 460 
 461 static const char kWhitespaceTable7[] = { 32, 13, 10, 9, 11, 12 };
 462 static const int kWhitespaceTable7Length = ARRAY_SIZE(kWhitespaceTable7);
 463 
 464 
 465 static const uc16 kWhitespaceTable16[] = {
 466   160, 8232, 8233, 5760, 6158, 8192, 8193, 8194, 8195,
 467   8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279
 468 };
 469 static const int kWhitespaceTable16Length = ARRAY_SIZE(kWhitespaceTable16);
 470 
 471 
 472 
 473 static bool isWhitespace(int x) {
 474   if (x &lt; 128) {
 475     for (int i = 0; i &lt; kWhitespaceTable7Length; i++) {
 476       if (kWhitespaceTable7[i] == x) return true;
 477     }
 478   } else {
 479     for (int i = 0; i &lt; kWhitespaceTable16Length; i++) {
 480       if (kWhitespaceTable16[i] == x) return true;
 481     }
 482   }
 483   return false;
 484 }
 485 
 486 
 487 // Returns true if a nonspace found and false if the end has reached.
 488 template &lt;class Iterator&gt;
 489 static inline bool AdvanceToNonspace(Iterator* current, Iterator end) {
 490   while (*current != end) {
 491     if (!isWhitespace(**current)) return true;
 492     ++*current;
 493   }
 494   return false;
 495 }
 496 
 497 
 498 static bool isDigit(int x, int radix) {
 499   return (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39; &amp;&amp; x &lt; &#39;0&#39; + radix)
 500       || (radix &gt; 10 &amp;&amp; x &gt;= &#39;a&#39; &amp;&amp; x &lt; &#39;a&#39; + radix - 10)
 501       || (radix &gt; 10 &amp;&amp; x &gt;= &#39;A&#39; &amp;&amp; x &lt; &#39;A&#39; + radix - 10);
 502 }
 503 
 504 
 505 static double SignedZero(bool sign) {
 506   return sign ? -0.0 : 0.0;
 507 }
 508 
 509 
 510 // Returns true if &#39;c&#39; is a decimal digit that is valid for the given radix.
 511 //
 512 // The function is small and could be inlined, but VS2012 emitted a warning
 513 // because it constant-propagated the radix and concluded that the last
 514 // condition was always true. By moving it into a separate function the
 515 // compiler wouldn&#39;t warn anymore.
<a name="6" id="anc6"></a><span class="line-modified"> 516 #if _MSC_VER</span>
 517 #pragma optimize(&quot;&quot;,off)
 518 static bool IsDecimalDigitForRadix(int c, int radix) {
 519   return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39; &amp;&amp; (c - &#39;0&#39;) &lt; radix;
 520 }
 521 #pragma optimize(&quot;&quot;,on)
 522 #else
 523 static bool inline IsDecimalDigitForRadix(int c, int radix) {
<a name="7" id="anc7"></a><span class="line-modified"> 524     return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39; &amp;&amp; (c - &#39;0&#39;) &lt; radix;</span>
 525 }
 526 #endif
 527 // Returns true if &#39;c&#39; is a character digit that is valid for the given radix.
 528 // The &#39;a_character&#39; should be &#39;a&#39; or &#39;A&#39;.
 529 //
 530 // The function is small and could be inlined, but VS2012 emitted a warning
 531 // because it constant-propagated the radix and concluded that the first
 532 // condition was always false. By moving it into a separate function the
 533 // compiler wouldn&#39;t warn anymore.
 534 static bool IsCharacterDigitForRadix(int c, int radix, char a_character) {
 535   return radix &gt; 10 &amp;&amp; c &gt;= a_character &amp;&amp; c &lt; a_character + radix - 10;
 536 }
 537 
<a name="8" id="anc8"></a>





























































 538 
 539 // Parsing integers with radix 2, 4, 8, 16, 32. Assumes current != end.
<a name="9" id="anc9"></a>


 540 template &lt;int radix_log_2, class Iterator&gt;
 541 static double RadixStringToIeee(Iterator* current,
 542                                 Iterator end,
 543                                 bool sign,
<a name="10" id="anc10"></a>

 544                                 bool allow_trailing_junk,
 545                                 double junk_string_value,
 546                                 bool read_as_double,
 547                                 bool* result_is_junk) {
 548   ASSERT(*current != end);
<a name="11" id="anc11"></a>

 549 
 550   const int kDoubleSize = Double::kSignificandSize;
 551   const int kSingleSize = Single::kSignificandSize;
 552   const int kSignificandSize = read_as_double? kDoubleSize: kSingleSize;
 553 
 554   *result_is_junk = true;
 555 
<a name="12" id="anc12"></a>






 556   // Skip leading 0s.
 557   while (**current == &#39;0&#39;) {
<a name="13" id="anc13"></a><span class="line-modified"> 558     ++(*current);</span>
<span class="line-removed"> 559     if (*current == end) {</span>
 560       *result_is_junk = false;
 561       return SignedZero(sign);
 562     }
 563   }
 564 
<a name="14" id="anc14"></a><span class="line-modified"> 565   int64_t number = 0;</span>
<span class="line-removed"> 566   int exponent = 0;</span>
<span class="line-removed"> 567   const int radix = (1 &lt;&lt; radix_log_2);</span>
<span class="line-removed"> 568 </span>
<span class="line-removed"> 569   do {</span>
 570     int digit;
 571     if (IsDecimalDigitForRadix(**current, radix)) {
 572       digit = static_cast&lt;char&gt;(**current) - &#39;0&#39;;
<a name="15" id="anc15"></a>
 573     } else if (IsCharacterDigitForRadix(**current, radix, &#39;a&#39;)) {
 574       digit = static_cast&lt;char&gt;(**current) - &#39;a&#39; + 10;
<a name="16" id="anc16"></a>
 575     } else if (IsCharacterDigitForRadix(**current, radix, &#39;A&#39;)) {
 576       digit = static_cast&lt;char&gt;(**current) - &#39;A&#39; + 10;
<a name="17" id="anc17"></a>







 577     } else {
 578       if (allow_trailing_junk || !AdvanceToNonspace(current, end)) {
 579         break;
 580       } else {
 581         return junk_string_value;
 582       }
 583     }
 584 
 585     number = number * radix + digit;
 586     int overflow = static_cast&lt;int&gt;(number &gt;&gt; kSignificandSize);
 587     if (overflow != 0) {
 588       // Overflow occurred. Need to determine which direction to round the
 589       // result.
 590       int overflow_bits_count = 1;
 591       while (overflow &gt; 1) {
 592         overflow_bits_count++;
 593         overflow &gt;&gt;= 1;
 594       }
 595 
 596       int dropped_bits_mask = ((1 &lt;&lt; overflow_bits_count) - 1);
 597       int dropped_bits = static_cast&lt;int&gt;(number) &amp; dropped_bits_mask;
 598       number &gt;&gt;= overflow_bits_count;
<a name="18" id="anc18"></a><span class="line-modified"> 599       exponent = overflow_bits_count;</span>
 600 
 601       bool zero_tail = true;
 602       for (;;) {
<a name="19" id="anc19"></a><span class="line-modified"> 603         ++(*current);</span>
<span class="line-modified"> 604         if (*current == end || !isDigit(**current, radix)) break;</span>







 605         zero_tail = zero_tail &amp;&amp; **current == &#39;0&#39;;
<a name="20" id="anc20"></a><span class="line-modified"> 606         exponent += radix_log_2;</span>
 607       }
 608 
<a name="21" id="anc21"></a><span class="line-modified"> 609       if (!allow_trailing_junk &amp;&amp; AdvanceToNonspace(current, end)) {</span>


 610         return junk_string_value;
 611       }
 612 
 613       int middle_value = (1 &lt;&lt; (overflow_bits_count - 1));
 614       if (dropped_bits &gt; middle_value) {
 615         number++;  // Rounding up.
 616       } else if (dropped_bits == middle_value) {
 617         // Rounding to even to consistency with decimals: half-way case rounds
 618         // up if significant part is odd and down otherwise.
 619         if ((number &amp; 1) != 0 || !zero_tail) {
 620           number++;  // Rounding up.
 621         }
 622       }
 623 
 624       // Rounding up may cause overflow.
 625       if ((number &amp; ((int64_t)1 &lt;&lt; kSignificandSize)) != 0) {
 626         exponent++;
 627         number &gt;&gt;= 1;
 628       }
 629       break;
 630     }
<a name="22" id="anc22"></a><span class="line-modified"> 631     ++(*current);</span>
<span class="line-modified"> 632   } while (*current != end);</span>
 633 
 634   ASSERT(number &lt; ((int64_t)1 &lt;&lt; kSignificandSize));
 635   ASSERT(static_cast&lt;int64_t&gt;(static_cast&lt;double&gt;(number)) == number);
 636 
 637   *result_is_junk = false;
 638 
<a name="23" id="anc23"></a><span class="line-modified"> 639   if (exponent == 0) {</span>






















 640     if (sign) {
 641       if (number == 0) return -0.0;
 642       number = -number;
 643     }
 644     return static_cast&lt;double&gt;(number);
 645   }
 646 
 647   ASSERT(number != 0);
<a name="24" id="anc24"></a><span class="line-modified"> 648   return Double(DiyFp(number, exponent)).value();</span>

 649 }
 650 
 651 template &lt;class Iterator&gt;
 652 double StringToDoubleConverter::StringToIeee(
 653     Iterator input,
 654     int length,
 655     bool read_as_double,
 656     int* processed_characters_count) const {
 657   Iterator current = input;
 658   Iterator end = input + length;
 659 
 660   *processed_characters_count = 0;
 661 
 662   const bool allow_trailing_junk = (flags_ &amp; ALLOW_TRAILING_JUNK) != 0;
 663   const bool allow_leading_spaces = (flags_ &amp; ALLOW_LEADING_SPACES) != 0;
 664   const bool allow_trailing_spaces = (flags_ &amp; ALLOW_TRAILING_SPACES) != 0;
 665   const bool allow_spaces_after_sign = (flags_ &amp; ALLOW_SPACES_AFTER_SIGN) != 0;
<a name="25" id="anc25"></a>
 666 
 667   // To make sure that iterator dereferencing is valid the following
 668   // convention is used:
 669   // 1. Each &#39;++current&#39; statement is followed by check for equality to &#39;end&#39;.
 670   // 2. If AdvanceToNonspace returned false then current == end.
 671   // 3. If &#39;current&#39; becomes equal to &#39;end&#39; the function returns or goes to
 672   // &#39;parsing_done&#39;.
 673   // 4. &#39;current&#39; is not dereferenced after the &#39;parsing_done&#39; label.
 674   // 5. Code before &#39;parsing_done&#39; may rely on &#39;current != end&#39;.
 675   if (current == end) return empty_string_value_;
 676 
 677   if (allow_leading_spaces || allow_trailing_spaces) {
 678     if (!AdvanceToNonspace(&amp;current, end)) {
 679       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 680       return empty_string_value_;
 681     }
 682     if (!allow_leading_spaces &amp;&amp; (input != current)) {
 683       // No leading spaces allowed, but AdvanceToNonspace moved forward.
 684       return junk_string_value_;
 685     }
 686   }
 687 
 688   // The longest form of simplified number is: &quot;-&lt;significant digits&gt;.1eXXX\0&quot;.
 689   const int kBufferSize = kMaxSignificantDigits + 10;
 690   char buffer[kBufferSize];  // NOLINT: size is known at compile time.
 691   int buffer_pos = 0;
 692 
 693   // Exponent will be adjusted if insignificant digits of the integer part
 694   // or insignificant leading zeros of the fractional part are dropped.
 695   int exponent = 0;
 696   int significant_digits = 0;
 697   int insignificant_digits = 0;
 698   bool nonzero_digit_dropped = false;
 699 
 700   bool sign = false;
 701 
 702   if (*current == &#39;+&#39; || *current == &#39;-&#39;) {
 703     sign = (*current == &#39;-&#39;);
 704     ++current;
 705     Iterator next_non_space = current;
 706     // Skip following spaces (if allowed).
 707     if (!AdvanceToNonspace(&amp;next_non_space, end)) return junk_string_value_;
 708     if (!allow_spaces_after_sign &amp;&amp; (current != next_non_space)) {
 709       return junk_string_value_;
 710     }
 711     current = next_non_space;
 712   }
 713 
 714   if (infinity_symbol_ != NULL) {
<a name="26" id="anc26"></a><span class="line-modified"> 715     if (*current == infinity_symbol_[0]) {</span>
<span class="line-modified"> 716       if (!ConsumeSubString(&amp;current, end, infinity_symbol_)) {</span>
 717         return junk_string_value_;
 718       }
 719 
 720       if (!(allow_trailing_spaces || allow_trailing_junk) &amp;&amp; (current != end)) {
 721         return junk_string_value_;
 722       }
 723       if (!allow_trailing_junk &amp;&amp; AdvanceToNonspace(&amp;current, end)) {
 724         return junk_string_value_;
 725       }
 726 
 727       ASSERT(buffer_pos == 0);
 728       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 729       return sign ? -Double::Infinity() : Double::Infinity();
 730     }
 731   }
 732 
 733   if (nan_symbol_ != NULL) {
<a name="27" id="anc27"></a><span class="line-modified"> 734     if (*current == nan_symbol_[0]) {</span>
<span class="line-modified"> 735       if (!ConsumeSubString(&amp;current, end, nan_symbol_)) {</span>
 736         return junk_string_value_;
 737       }
 738 
 739       if (!(allow_trailing_spaces || allow_trailing_junk) &amp;&amp; (current != end)) {
 740         return junk_string_value_;
 741       }
 742       if (!allow_trailing_junk &amp;&amp; AdvanceToNonspace(&amp;current, end)) {
 743         return junk_string_value_;
 744       }
 745 
 746       ASSERT(buffer_pos == 0);
 747       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 748       return sign ? -Double::NaN() : Double::NaN();
 749     }
 750   }
 751 
 752   bool leading_zero = false;
 753   if (*current == &#39;0&#39;) {
<a name="28" id="anc28"></a><span class="line-modified"> 754     ++current;</span>
<span class="line-removed"> 755     if (current == end) {</span>
 756       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 757       return SignedZero(sign);
 758     }
 759 
 760     leading_zero = true;
 761 
 762     // It could be hexadecimal value.
<a name="29" id="anc29"></a><span class="line-modified"> 763     if ((flags_ &amp; ALLOW_HEX) &amp;&amp; (*current == &#39;x&#39; || *current == &#39;X&#39;)) {</span>

 764       ++current;
<a name="30" id="anc30"></a><span class="line-modified"> 765       if (current == end || !isDigit(*current, 16)) {</span>
<span class="line-modified"> 766         return junk_string_value_;  // &quot;0x&quot;.</span>





 767       }
 768 
 769       bool result_is_junk;
 770       double result = RadixStringToIeee&lt;4&gt;(&amp;current,
 771                                            end,
 772                                            sign,
<a name="31" id="anc31"></a>

 773                                            allow_trailing_junk,
 774                                            junk_string_value_,
 775                                            read_as_double,
 776                                            &amp;result_is_junk);
 777       if (!result_is_junk) {
 778         if (allow_trailing_spaces) AdvanceToNonspace(&amp;current, end);
 779         *processed_characters_count = static_cast&lt;int&gt;(current - input);
 780       }
 781       return result;
 782     }
 783 
 784     // Ignore leading zeros in the integer part.
 785     while (*current == &#39;0&#39;) {
<a name="32" id="anc32"></a><span class="line-modified"> 786       ++current;</span>
<span class="line-removed"> 787       if (current == end) {</span>
 788         *processed_characters_count = static_cast&lt;int&gt;(current - input);
 789         return SignedZero(sign);
 790       }
 791     }
 792   }
 793 
 794   bool octal = leading_zero &amp;&amp; (flags_ &amp; ALLOW_OCTALS) != 0;
 795 
 796   // Copy significant digits of the integer part (if any) to the buffer.
 797   while (*current &gt;= &#39;0&#39; &amp;&amp; *current &lt;= &#39;9&#39;) {
 798     if (significant_digits &lt; kMaxSignificantDigits) {
 799       ASSERT(buffer_pos &lt; kBufferSize);
 800       buffer[buffer_pos++] = static_cast&lt;char&gt;(*current);
 801       significant_digits++;
 802       // Will later check if it&#39;s an octal in the buffer.
 803     } else {
 804       insignificant_digits++;  // Move the digit into the exponential part.
 805       nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;
 806     }
 807     octal = octal &amp;&amp; *current &lt; &#39;8&#39;;
<a name="33" id="anc33"></a><span class="line-modified"> 808     ++current;</span>
<span class="line-removed"> 809     if (current == end) goto parsing_done;</span>
 810   }
 811 
 812   if (significant_digits == 0) {
 813     octal = false;
 814   }
 815 
 816   if (*current == &#39;.&#39;) {
 817     if (octal &amp;&amp; !allow_trailing_junk) return junk_string_value_;
 818     if (octal) goto parsing_done;
 819 
<a name="34" id="anc34"></a><span class="line-modified"> 820     ++current;</span>
<span class="line-removed"> 821     if (current == end) {</span>
 822       if (significant_digits == 0 &amp;&amp; !leading_zero) {
 823         return junk_string_value_;
 824       } else {
 825         goto parsing_done;
 826       }
 827     }
 828 
 829     if (significant_digits == 0) {
 830       // octal = false;
 831       // Integer part consists of 0 or is absent. Significant digits start after
 832       // leading zeros (if any).
 833       while (*current == &#39;0&#39;) {
<a name="35" id="anc35"></a><span class="line-modified"> 834         ++current;</span>
<span class="line-removed"> 835         if (current == end) {</span>
 836           *processed_characters_count = static_cast&lt;int&gt;(current - input);
 837           return SignedZero(sign);
 838         }
 839         exponent--;  // Move this 0 into the exponent.
 840       }
 841     }
 842 
 843     // There is a fractional part.
 844     // We don&#39;t emit a &#39;.&#39;, but adjust the exponent instead.
 845     while (*current &gt;= &#39;0&#39; &amp;&amp; *current &lt;= &#39;9&#39;) {
 846       if (significant_digits &lt; kMaxSignificantDigits) {
 847         ASSERT(buffer_pos &lt; kBufferSize);
 848         buffer[buffer_pos++] = static_cast&lt;char&gt;(*current);
 849         significant_digits++;
 850         exponent--;
 851       } else {
 852         // Ignore insignificant digits in the fractional part.
 853         nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;
 854       }
<a name="36" id="anc36"></a><span class="line-modified"> 855       ++current;</span>
<span class="line-removed"> 856       if (current == end) goto parsing_done;</span>
 857     }
 858   }
 859 
 860   if (!leading_zero &amp;&amp; exponent == 0 &amp;&amp; significant_digits == 0) {
 861     // If leading_zeros is true then the string contains zeros.
 862     // If exponent &lt; 0 then string was [+-]\.0*...
 863     // If significant_digits != 0 the string is not equal to 0.
 864     // Otherwise there are no digits in the string.
 865     return junk_string_value_;
 866   }
 867 
 868   // Parse exponential part.
 869   if (*current == &#39;e&#39; || *current == &#39;E&#39;) {
 870     if (octal &amp;&amp; !allow_trailing_junk) return junk_string_value_;
 871     if (octal) goto parsing_done;
<a name="37" id="anc37"></a>
 872     ++current;
 873     if (current == end) {
 874       if (allow_trailing_junk) {
<a name="38" id="anc38"></a>
 875         goto parsing_done;
 876       } else {
 877         return junk_string_value_;
 878       }
 879     }
 880     char exponen_sign = &#39;+&#39;;
 881     if (*current == &#39;+&#39; || *current == &#39;-&#39;) {
 882       exponen_sign = static_cast&lt;char&gt;(*current);
 883       ++current;
 884       if (current == end) {
 885         if (allow_trailing_junk) {
<a name="39" id="anc39"></a>
 886           goto parsing_done;
 887         } else {
 888           return junk_string_value_;
 889         }
 890       }
 891     }
 892 
 893     if (current == end || *current &lt; &#39;0&#39; || *current &gt; &#39;9&#39;) {
 894       if (allow_trailing_junk) {
<a name="40" id="anc40"></a>
 895         goto parsing_done;
 896       } else {
 897         return junk_string_value_;
 898       }
 899     }
 900 
 901     const int max_exponent = INT_MAX / 2;
 902     ASSERT(-max_exponent / 2 &lt;= exponent &amp;&amp; exponent &lt;= max_exponent / 2);
 903     int num = 0;
 904     do {
 905       // Check overflow.
 906       int digit = *current - &#39;0&#39;;
 907       if (num &gt;= max_exponent / 10
 908           &amp;&amp; !(num == max_exponent / 10 &amp;&amp; digit &lt;= max_exponent % 10)) {
 909         num = max_exponent;
 910       } else {
 911         num = num * 10 + digit;
 912       }
 913       ++current;
 914     } while (current != end &amp;&amp; *current &gt;= &#39;0&#39; &amp;&amp; *current &lt;= &#39;9&#39;);
 915 
 916     exponent += (exponen_sign == &#39;-&#39; ? -num : num);
 917   }
 918 
 919   if (!(allow_trailing_spaces || allow_trailing_junk) &amp;&amp; (current != end)) {
 920     return junk_string_value_;
 921   }
 922   if (!allow_trailing_junk &amp;&amp; AdvanceToNonspace(&amp;current, end)) {
 923     return junk_string_value_;
 924   }
 925   if (allow_trailing_spaces) {
 926     AdvanceToNonspace(&amp;current, end);
 927   }
 928 
 929   parsing_done:
 930   exponent += insignificant_digits;
 931 
 932   if (octal) {
 933     double result;
 934     bool result_is_junk;
 935     char* start = buffer;
 936     result = RadixStringToIeee&lt;3&gt;(&amp;start,
 937                                   buffer + buffer_pos,
 938                                   sign,
<a name="41" id="anc41"></a>

 939                                   allow_trailing_junk,
 940                                   junk_string_value_,
 941                                   read_as_double,
 942                                   &amp;result_is_junk);
 943     ASSERT(!result_is_junk);
 944     *processed_characters_count = static_cast&lt;int&gt;(current - input);
 945     return result;
 946   }
 947 
 948   if (nonzero_digit_dropped) {
 949     buffer[buffer_pos++] = &#39;1&#39;;
 950     exponent--;
 951   }
 952 
 953   ASSERT(buffer_pos &lt; kBufferSize);
 954   buffer[buffer_pos] = &#39;\0&#39;;
 955 
 956   double converted;
 957   if (read_as_double) {
 958     converted = Strtod(Vector&lt;const char&gt;(buffer, buffer_pos), exponent);
 959   } else {
 960     converted = Strtof(Vector&lt;const char&gt;(buffer, buffer_pos), exponent);
 961   }
 962   *processed_characters_count = static_cast&lt;int&gt;(current - input);
 963   return sign? -converted: converted;
 964 }
 965 
 966 
 967 double StringToDoubleConverter::StringToDouble(
 968     const char* buffer,
 969     int length,
 970     int* processed_characters_count) const {
 971   return StringToIeee(buffer, length, true, processed_characters_count);
 972 }
 973 
 974 
 975 double StringToDoubleConverter::StringToDouble(
 976     const uc16* buffer,
 977     int length,
 978     int* processed_characters_count) const {
 979   return StringToIeee(buffer, length, true, processed_characters_count);
 980 }
 981 
 982 
 983 float StringToDoubleConverter::StringToFloat(
 984     const char* buffer,
 985     int length,
 986     int* processed_characters_count) const {
 987   return static_cast&lt;float&gt;(StringToIeee(buffer, length, false,
 988                                          processed_characters_count));
 989 }
 990 
 991 
 992 float StringToDoubleConverter::StringToFloat(
 993     const uc16* buffer,
 994     int length,
 995     int* processed_characters_count) const {
 996   return static_cast&lt;float&gt;(StringToIeee(buffer, length, false,
 997                                          processed_characters_count));
 998 }
 999 
1000 }  // namespace double_conversion
1001 
1002 // ICU PATCH: Close ICU namespace
1003 U_NAMESPACE_END
1004 #endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING
<a name="42" id="anc42"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="42" type="hidden" />
</body>
</html>