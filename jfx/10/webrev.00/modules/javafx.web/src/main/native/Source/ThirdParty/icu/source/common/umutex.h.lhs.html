<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/umutex.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 **********************************************************************
  5 *   Copyright (C) 1997-2015, International Business Machines
  6 *   Corporation and others.  All Rights Reserved.
  7 **********************************************************************
  8 *
  9 * File UMUTEX.H
 10 *
 11 * Modification History:
 12 *
 13 *   Date        Name        Description
 14 *   04/02/97  aliu        Creation.
 15 *   04/07/99  srl         rewrite - C interface, multiple mutices
 16 *   05/13/99  stephen     Changed to umutex (from cmutex)
 17 ******************************************************************************
 18 */
 19 
 20 #ifndef UMUTEX_H
 21 #define UMUTEX_H
 22 
<a name="1" id="anc1"></a>



 23 #include &quot;unicode/utypes.h&quot;
 24 #include &quot;unicode/uclean.h&quot;
<a name="2" id="anc2"></a>

 25 #include &quot;putilimp.h&quot;
 26 
<a name="3" id="anc3"></a>




 27 
 28 
<a name="4" id="anc4"></a><span class="line-modified"> 29 // Forward Declarations. UMutex is not in the ICU namespace (yet) because</span>
<span class="line-modified"> 30 //                       there are some remaining references from plain C.</span>
<span class="line-modified"> 31 struct UMutex;</span>
<span class="line-modified"> 32 struct UConditionVar;</span>















 33 
<a name="5" id="anc5"></a><span class="line-removed"> 34 U_NAMESPACE_BEGIN</span>
<span class="line-removed"> 35 struct UInitOnce;</span>
<span class="line-removed"> 36 U_NAMESPACE_END</span>
 37 
<a name="6" id="anc6"></a><span class="line-modified"> 38 // Stringify macros, to allow #include of user supplied atomic &amp; mutex files.</span>
<span class="line-removed"> 39 #define U_MUTEX_STR(s) #s</span>
<span class="line-removed"> 40 #define U_MUTEX_XSTR(s) U_MUTEX_STR(s)</span>
 41 
 42 /****************************************************************************
 43  *
<a name="7" id="anc7"></a><span class="line-modified"> 44  *   Low Level Atomic Operations.</span>
<span class="line-removed"> 45  *      Compiler dependent. Not operating system dependent.</span>
 46  *
 47  ****************************************************************************/
<a name="8" id="anc8"></a><span class="line-removed"> 48 #if defined (U_USER_ATOMICS_H)</span>
<span class="line-removed"> 49 #include U_MUTEX_XSTR(U_USER_ATOMICS_H)</span>
<span class="line-removed"> 50 </span>
<span class="line-removed"> 51 #elif U_HAVE_STD_ATOMICS</span>
<span class="line-removed"> 52 </span>
<span class="line-removed"> 53 //  C++11 atomics are available.</span>
<span class="line-removed"> 54 </span>
<span class="line-removed"> 55 #include &lt;atomic&gt;</span>
<span class="line-removed"> 56 </span>
<span class="line-removed"> 57 U_NAMESPACE_BEGIN</span>
 58 
 59 typedef std::atomic&lt;int32_t&gt; u_atomic_int32_t;
 60 #define ATOMIC_INT32_T_INITIALIZER(val) ATOMIC_VAR_INIT(val)
 61 
 62 inline int32_t umtx_loadAcquire(u_atomic_int32_t &amp;var) {
 63     return var.load(std::memory_order_acquire);
 64 }
 65 
 66 inline void umtx_storeRelease(u_atomic_int32_t &amp;var, int32_t val) {
 67     var.store(val, std::memory_order_release);
 68 }
 69 
 70 inline int32_t umtx_atomic_inc(u_atomic_int32_t *var) {
 71     return var-&gt;fetch_add(1) + 1;
 72 }
 73 
 74 inline int32_t umtx_atomic_dec(u_atomic_int32_t *var) {
 75     return var-&gt;fetch_sub(1) - 1;
 76 }
<a name="9" id="anc9"></a><span class="line-removed"> 77 U_NAMESPACE_END</span>
<span class="line-removed"> 78 </span>
<span class="line-removed"> 79 #elif U_PLATFORM_HAS_WIN32_API</span>
<span class="line-removed"> 80 </span>
<span class="line-removed"> 81 // MSVC compiler. Reads and writes of volatile variables have</span>
<span class="line-removed"> 82 //                acquire and release memory semantics, respectively.</span>
<span class="line-removed"> 83 //                This is a Microsoft extension, not standard C++ behavior.</span>
<span class="line-removed"> 84 //</span>
<span class="line-removed"> 85 //   Update:      can&#39;t use this because of MinGW, built with gcc.</span>
<span class="line-removed"> 86 //                Original plan was to use gcc atomics for MinGW, but they</span>
<span class="line-removed"> 87 //                aren&#39;t supported, so we fold MinGW into this path.</span>
<span class="line-removed"> 88 </span>
<span class="line-removed"> 89 #ifndef WIN32_LEAN_AND_MEAN</span>
<span class="line-removed"> 90 # define WIN32_LEAN_AND_MEAN</span>
<span class="line-removed"> 91 #endif</span>
<span class="line-removed"> 92 # define VC_EXTRALEAN</span>
<span class="line-removed"> 93 # define NOUSER</span>
<span class="line-removed"> 94 # define NOSERVICE</span>
<span class="line-removed"> 95 # define NOIME</span>
<span class="line-removed"> 96 # define NOMCX</span>
<span class="line-removed"> 97 # ifndef NOMINMAX</span>
<span class="line-removed"> 98 # define NOMINMAX</span>
<span class="line-removed"> 99 # endif</span>
<span class="line-removed">100 # include &lt;windows.h&gt;</span>
<span class="line-removed">101 </span>
<span class="line-removed">102 U_NAMESPACE_BEGIN</span>
<span class="line-removed">103 typedef volatile LONG u_atomic_int32_t;</span>
<span class="line-removed">104 #define ATOMIC_INT32_T_INITIALIZER(val) val</span>
<span class="line-removed">105 </span>
<span class="line-removed">106 inline int32_t umtx_loadAcquire(u_atomic_int32_t &amp;var) {</span>
<span class="line-removed">107     return InterlockedCompareExchange(&amp;var, 0, 0);</span>
<span class="line-removed">108 }</span>
<span class="line-removed">109 </span>
<span class="line-removed">110 inline void umtx_storeRelease(u_atomic_int32_t &amp;var, int32_t val) {</span>
<span class="line-removed">111     InterlockedExchange(&amp;var, val);</span>
<span class="line-removed">112 }</span>
<span class="line-removed">113 </span>
<span class="line-removed">114 </span>
<span class="line-removed">115 inline int32_t umtx_atomic_inc(u_atomic_int32_t *var) {</span>
<span class="line-removed">116     return InterlockedIncrement(var);</span>
<span class="line-removed">117 }</span>
<span class="line-removed">118 </span>
<span class="line-removed">119 inline int32_t umtx_atomic_dec(u_atomic_int32_t *var) {</span>
<span class="line-removed">120     return InterlockedDecrement(var);</span>
<span class="line-removed">121 }</span>
<span class="line-removed">122 U_NAMESPACE_END</span>
<span class="line-removed">123 </span>
<span class="line-removed">124 </span>
<span class="line-removed">125 #elif U_HAVE_CLANG_ATOMICS</span>
<span class="line-removed">126 /*</span>
<span class="line-removed">127  *  Clang __c11 atomic built-ins</span>
<span class="line-removed">128  */</span>
<span class="line-removed">129 </span>
<span class="line-removed">130 U_NAMESPACE_BEGIN</span>
<span class="line-removed">131 typedef _Atomic(int32_t) u_atomic_int32_t;</span>
<span class="line-removed">132 #define ATOMIC_INT32_T_INITIALIZER(val) val</span>
<span class="line-removed">133 </span>
<span class="line-removed">134 inline int32_t umtx_loadAcquire(u_atomic_int32_t &amp;var) {</span>
<span class="line-removed">135      return __c11_atomic_load(&amp;var, __ATOMIC_ACQUIRE);</span>
<span class="line-removed">136 }</span>
<span class="line-removed">137 </span>
<span class="line-removed">138 inline void umtx_storeRelease(u_atomic_int32_t &amp;var, int32_t val) {</span>
<span class="line-removed">139    return __c11_atomic_store(&amp;var, val, __ATOMIC_RELEASE);</span>
<span class="line-removed">140 }</span>
<span class="line-removed">141 </span>
<span class="line-removed">142 inline int32_t umtx_atomic_inc(u_atomic_int32_t *var) {</span>
<span class="line-removed">143     return __c11_atomic_fetch_add(var, 1, __ATOMIC_SEQ_CST) + 1;</span>
<span class="line-removed">144 }</span>
<span class="line-removed">145 </span>
<span class="line-removed">146 inline int32_t umtx_atomic_dec(u_atomic_int32_t *var) {</span>
<span class="line-removed">147     return __c11_atomic_fetch_sub(var, 1, __ATOMIC_SEQ_CST) - 1;</span>
<span class="line-removed">148 }</span>
<span class="line-removed">149 U_NAMESPACE_END</span>
<span class="line-removed">150 </span>
<span class="line-removed">151 </span>
<span class="line-removed">152 #elif U_HAVE_GCC_ATOMICS</span>
<span class="line-removed">153 /*</span>
<span class="line-removed">154  * gcc atomic ops. These are available on several other compilers as well.</span>
<span class="line-removed">155  */</span>
<span class="line-removed">156 </span>
<span class="line-removed">157 U_NAMESPACE_BEGIN</span>
<span class="line-removed">158 typedef int32_t u_atomic_int32_t;</span>
<span class="line-removed">159 #define ATOMIC_INT32_T_INITIALIZER(val) val</span>
<span class="line-removed">160 </span>
<span class="line-removed">161 inline int32_t umtx_loadAcquire(u_atomic_int32_t &amp;var) {</span>
<span class="line-removed">162     int32_t val = var;</span>
<span class="line-removed">163     __sync_synchronize();</span>
<span class="line-removed">164     return val;</span>
<span class="line-removed">165 }</span>
<span class="line-removed">166 </span>
<span class="line-removed">167 inline void umtx_storeRelease(u_atomic_int32_t &amp;var, int32_t val) {</span>
<span class="line-removed">168     __sync_synchronize();</span>
<span class="line-removed">169     var = val;</span>
<span class="line-removed">170 }</span>
<span class="line-removed">171 </span>
<span class="line-removed">172 inline int32_t umtx_atomic_inc(u_atomic_int32_t *p)  {</span>
<span class="line-removed">173    return __sync_add_and_fetch(p, 1);</span>
<span class="line-removed">174 }</span>
<span class="line-removed">175 </span>
<span class="line-removed">176 inline int32_t umtx_atomic_dec(u_atomic_int32_t *p)  {</span>
<span class="line-removed">177    return __sync_sub_and_fetch(p, 1);</span>
<span class="line-removed">178 }</span>
<span class="line-removed">179 U_NAMESPACE_END</span>
<span class="line-removed">180 </span>
<span class="line-removed">181 #else</span>
<span class="line-removed">182 </span>
<span class="line-removed">183 /*</span>
<span class="line-removed">184  * Unknown Platform. Use out-of-line functions, which in turn use mutexes.</span>
<span class="line-removed">185  *                   Slow but correct.</span>
<span class="line-removed">186  */</span>
<span class="line-removed">187 </span>
<span class="line-removed">188 #define U_NO_PLATFORM_ATOMICS</span>
<span class="line-removed">189 </span>
<span class="line-removed">190 U_NAMESPACE_BEGIN</span>
<span class="line-removed">191 typedef int32_t u_atomic_int32_t;</span>
<span class="line-removed">192 #define ATOMIC_INT32_T_INITIALIZER(val) val</span>
<span class="line-removed">193 </span>
<span class="line-removed">194 U_COMMON_API int32_t U_EXPORT2</span>
<span class="line-removed">195 umtx_loadAcquire(u_atomic_int32_t &amp;var);</span>
<span class="line-removed">196 </span>
<span class="line-removed">197 U_COMMON_API void U_EXPORT2</span>
<span class="line-removed">198 umtx_storeRelease(u_atomic_int32_t &amp;var, int32_t val);</span>
<span class="line-removed">199 </span>
<span class="line-removed">200 U_COMMON_API int32_t U_EXPORT2</span>
<span class="line-removed">201 umtx_atomic_inc(u_atomic_int32_t *p);</span>
<span class="line-removed">202 </span>
<span class="line-removed">203 U_COMMON_API int32_t U_EXPORT2</span>
<span class="line-removed">204 umtx_atomic_dec(u_atomic_int32_t *p);</span>
<span class="line-removed">205 </span>
<span class="line-removed">206 U_NAMESPACE_END</span>
<span class="line-removed">207 </span>
<span class="line-removed">208 #endif  /* Low Level Atomic Ops Platfrom Chain */</span>
<span class="line-removed">209 </span>
210 
211 
212 /*************************************************************************************************
213  *
214  *  UInitOnce Definitions.
<a name="10" id="anc10"></a><span class="line-removed">215  *     These are platform neutral.</span>
216  *
217  *************************************************************************************************/
218 
<a name="11" id="anc11"></a><span class="line-removed">219 U_NAMESPACE_BEGIN</span>
<span class="line-removed">220 </span>
221 struct UInitOnce {
222     u_atomic_int32_t   fState;
223     UErrorCode       fErrCode;
<a name="12" id="anc12"></a><span class="line-modified">224     void reset() {fState = 0;};</span>
<span class="line-modified">225     UBool isReset() {return umtx_loadAcquire(fState) == 0;};</span>
226 // Note: isReset() is used by service registration code.
227 //                 Thread safety of this usage needs review.
228 };
229 
230 #define U_INITONCE_INITIALIZER {ATOMIC_INT32_T_INITIALIZER(0), U_ZERO_ERROR}
231 
232 
233 U_COMMON_API UBool U_EXPORT2 umtx_initImplPreInit(UInitOnce &amp;);
234 U_COMMON_API void  U_EXPORT2 umtx_initImplPostInit(UInitOnce &amp;);
235 
236 template&lt;class T&gt; void umtx_initOnce(UInitOnce &amp;uio, T *obj, void (U_CALLCONV T::*fp)()) {
237     if (umtx_loadAcquire(uio.fState) == 2) {
238         return;
239     }
240     if (umtx_initImplPreInit(uio)) {
241         (obj-&gt;*fp)();
242         umtx_initImplPostInit(uio);
243     }
244 }
245 
246 
247 // umtx_initOnce variant for plain functions, or static class functions.
248 //               No context parameter.
249 inline void umtx_initOnce(UInitOnce &amp;uio, void (U_CALLCONV *fp)()) {
250     if (umtx_loadAcquire(uio.fState) == 2) {
251         return;
252     }
253     if (umtx_initImplPreInit(uio)) {
254         (*fp)();
255         umtx_initImplPostInit(uio);
256     }
257 }
258 
259 // umtx_initOnce variant for plain functions, or static class functions.
260 //               With ErrorCode, No context parameter.
261 inline void umtx_initOnce(UInitOnce &amp;uio, void (U_CALLCONV *fp)(UErrorCode &amp;), UErrorCode &amp;errCode) {
262     if (U_FAILURE(errCode)) {
263         return;
264     }
265     if (umtx_loadAcquire(uio.fState) != 2 &amp;&amp; umtx_initImplPreInit(uio)) {
266         // We run the initialization.
267         (*fp)(errCode);
268         uio.fErrCode = errCode;
269         umtx_initImplPostInit(uio);
270     } else {
271         // Someone else already ran the initialization.
272         if (U_FAILURE(uio.fErrCode)) {
273             errCode = uio.fErrCode;
274         }
275     }
276 }
277 
278 // umtx_initOnce variant for plain functions, or static class functions,
279 //               with a context parameter.
280 template&lt;class T&gt; void umtx_initOnce(UInitOnce &amp;uio, void (U_CALLCONV *fp)(T), T context) {
281     if (umtx_loadAcquire(uio.fState) == 2) {
282         return;
283     }
284     if (umtx_initImplPreInit(uio)) {
285         (*fp)(context);
286         umtx_initImplPostInit(uio);
287     }
288 }
289 
290 // umtx_initOnce variant for plain functions, or static class functions,
291 //               with a context parameter and an error code.
292 template&lt;class T&gt; void umtx_initOnce(UInitOnce &amp;uio, void (U_CALLCONV *fp)(T, UErrorCode &amp;), T context, UErrorCode &amp;errCode) {
293     if (U_FAILURE(errCode)) {
294         return;
295     }
296     if (umtx_loadAcquire(uio.fState) != 2 &amp;&amp; umtx_initImplPreInit(uio)) {
297         // We run the initialization.
298         (*fp)(context, errCode);
299         uio.fErrCode = errCode;
300         umtx_initImplPostInit(uio);
301     } else {
302         // Someone else already ran the initialization.
303         if (U_FAILURE(uio.fErrCode)) {
304             errCode = uio.fErrCode;
305         }
306     }
307 }
308 
<a name="13" id="anc13"></a><span class="line-removed">309 U_NAMESPACE_END</span>
<span class="line-removed">310 </span>
<span class="line-removed">311 </span>
312 
313 /*************************************************************************************************
314  *
<a name="14" id="anc14"></a><span class="line-modified">315  *  Mutex Definitions. Platform Dependent, #if platform chain follows.</span>
<span class="line-modified">316  *         TODO:  Add a C++11 version.</span>
<span class="line-modified">317  *                Need to convert all mutex using files to C++ first.</span>
318  *
319  *************************************************************************************************/
320 
<a name="15" id="anc15"></a><span class="line-modified">321 #if defined(U_USER_MUTEX_H)</span>
<span class="line-modified">322 // #inlcude &quot;U_USER_MUTEX_H&quot;</span>
<span class="line-modified">323 #include U_MUTEX_XSTR(U_USER_MUTEX_H)</span>


324 
<a name="16" id="anc16"></a><span class="line-modified">325 #elif U_PLATFORM_USES_ONLY_WIN32_API</span>
<span class="line-modified">326 </span>
<span class="line-removed">327 /* For CRITICAL_SECTION */</span>
<span class="line-removed">328 </span>
<span class="line-removed">329 /*</span>
<span class="line-removed">330  *   Note: there is an earlier include of windows.h in this file, but it is in</span>
<span class="line-removed">331  *         different conditionals.</span>
<span class="line-removed">332  *         This one is needed if we are using C++11 for atomic ops, but</span>
<span class="line-removed">333  *         win32 APIs for Critical Sections.</span>
<span class="line-removed">334  */</span>
<span class="line-removed">335 </span>
<span class="line-removed">336 #ifndef WIN32_LEAN_AND_MEAN</span>
<span class="line-removed">337 # define WIN32_LEAN_AND_MEAN</span>
<span class="line-removed">338 #endif</span>
<span class="line-removed">339 # define VC_EXTRALEAN</span>
<span class="line-removed">340 # define NOUSER</span>
<span class="line-removed">341 # define NOSERVICE</span>
<span class="line-removed">342 # define NOIME</span>
<span class="line-removed">343 # define NOMCX</span>
<span class="line-removed">344 # ifndef NOMINMAX</span>
<span class="line-removed">345 # define NOMINMAX</span>
<span class="line-removed">346 # endif</span>
<span class="line-removed">347 # include &lt;windows.h&gt;</span>
<span class="line-removed">348 </span>
<span class="line-removed">349 </span>
<span class="line-removed">350 typedef struct UMutex {</span>
<span class="line-removed">351     icu::UInitOnce    fInitOnce;</span>
<span class="line-removed">352     CRITICAL_SECTION  fCS;</span>
<span class="line-removed">353 } UMutex;</span>
<span class="line-removed">354 </span>
<span class="line-removed">355 /* Initializer for a static UMUTEX. Deliberately contains no value for the</span>
<span class="line-removed">356  *  CRITICAL_SECTION.</span>
<span class="line-removed">357  */</span>
<span class="line-removed">358 #define U_MUTEX_INITIALIZER {U_INITONCE_INITIALIZER}</span>
<span class="line-removed">359 </span>
<span class="line-removed">360 struct UConditionVar {</span>
<span class="line-removed">361     HANDLE           fEntryGate;</span>
<span class="line-removed">362     HANDLE           fExitGate;</span>
<span class="line-removed">363     int32_t          fWaitCount;</span>
364 };
365 
<a name="17" id="anc17"></a><span class="line-removed">366 #define U_CONDITION_INITIALIZER {NULL, NULL, 0}</span>
367 
<a name="18" id="anc18"></a>




368 
<a name="19" id="anc19"></a><span class="line-modified">369 </span>
<span class="line-removed">370 #elif U_PLATFORM_IMPLEMENTS_POSIX</span>
<span class="line-removed">371 </span>
<span class="line-removed">372 /*</span>
<span class="line-removed">373  *  POSIX platform</span>
<span class="line-removed">374  */</span>
<span class="line-removed">375 </span>
<span class="line-removed">376 #include &lt;pthread.h&gt;</span>
<span class="line-removed">377 </span>
<span class="line-removed">378 struct UMutex {</span>
<span class="line-removed">379     pthread_mutex_t  fMutex;</span>
<span class="line-removed">380 };</span>
<span class="line-removed">381 typedef struct UMutex UMutex;</span>
<span class="line-removed">382 #define U_MUTEX_INITIALIZER  {PTHREAD_MUTEX_INITIALIZER}</span>
<span class="line-removed">383 </span>
<span class="line-removed">384 struct UConditionVar {</span>
<span class="line-removed">385     pthread_cond_t   fCondition;</span>
386 };
<a name="20" id="anc20"></a><span class="line-removed">387 #define U_CONDITION_INITIALIZER {PTHREAD_COND_INITIALIZER}</span>
388 
<a name="21" id="anc21"></a><span class="line-modified">389 #else</span>

390 
<a name="22" id="anc22"></a><span class="line-modified">391 /*</span>
<span class="line-modified">392  *  Unknow platform type.</span>
<span class="line-modified">393  *      This is an error condition. ICU requires mutexes.</span>
<span class="line-modified">394  */</span>
<span class="line-modified">395 </span>
<span class="line-modified">396 #error Unknown Platform.</span>
<span class="line-modified">397 </span>
<span class="line-modified">398 #endif</span>
<span class="line-modified">399 </span>
<span class="line-modified">400 </span>
<span class="line-modified">401 </span>
<span class="line-removed">402 /**************************************************************************************</span>
<span class="line-removed">403  *</span>
<span class="line-removed">404  *  Mutex Implementation function declaratations.</span>
<span class="line-removed">405  *     Declarations are platform neutral.</span>
<span class="line-removed">406  *     Implementations, in umutex.cpp, are platform specific.</span>
<span class="line-removed">407  *</span>
<span class="line-removed">408  ************************************************************************************/</span>
409 
410 /* Lock a mutex.
411  * @param mutex The given mutex to be locked.  Pass NULL to specify
412  *              the global ICU mutex.  Recursive locks are an error
413  *              and may cause a deadlock on some platforms.
414  */
415 U_INTERNAL void U_EXPORT2 umtx_lock(UMutex* mutex);
416 
417 /* Unlock a mutex.
418  * @param mutex The given mutex to be unlocked.  Pass NULL to specify
419  *              the global ICU mutex.
420  */
421 U_INTERNAL void U_EXPORT2 umtx_unlock (UMutex* mutex);
422 
423 /*
424  * Wait on a condition variable.
425  * The calling thread will unlock the mutex and wait on the condition variable.
426  * The mutex must be locked by the calling thread when invoking this function.
427  *
428  * @param cond the condition variable to wait on.
429  * @param mutex the associated mutex.
430  */
431 
432 U_INTERNAL void U_EXPORT2 umtx_condWait(UConditionVar *cond, UMutex *mutex);
433 
434 
435 /*
436  * Broadcast wakeup of all threads waiting on a Condition.
<a name="23" id="anc23"></a><span class="line-removed">437  * The associated mutex must be locked by the calling thread when calling</span>
<span class="line-removed">438  * this function; this is a temporary ICU restriction.</span>
439  *
440  * @param cond the condition variable.
441  */
442 U_INTERNAL void U_EXPORT2 umtx_condBroadcast(UConditionVar *cond);
443 
444 /*
445  * Signal a condition variable, waking up one waiting thread.
<a name="24" id="anc24"></a><span class="line-removed">446  * CAUTION: Do not use. Place holder only. Not implemented for Windows.</span>
447  */
448 U_INTERNAL void U_EXPORT2 umtx_condSignal(UConditionVar *cond);
449 
<a name="25" id="anc25"></a>


450 #endif /* UMUTEX_H */
451 /*eof*/
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>