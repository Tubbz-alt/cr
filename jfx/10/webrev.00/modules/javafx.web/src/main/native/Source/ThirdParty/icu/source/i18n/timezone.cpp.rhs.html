<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/timezone.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 * Copyright (C) 1997-2016, International Business Machines Corporation and
   6 * others. All Rights Reserved.
   7 *******************************************************************************
   8 *
   9 * File TIMEZONE.CPP
  10 *
  11 * Modification History:
  12 *
  13 *   Date        Name        Description
  14 *   12/05/96    clhuang     Creation.
  15 *   04/21/97    aliu        General clean-up and bug fixing.
  16 *   05/08/97    aliu        Fixed Hashtable code per code review.
  17 *   07/09/97    helena      Changed createInstance to createDefault.
  18 *   07/29/97    aliu        Updated with all-new list of 96 UNIX-derived
  19 *                           TimeZones.  Changed mechanism to load from static
  20 *                           array rather than resource bundle.
  21 *   07/07/1998  srl         Bugfixes from the Java side: UTC GMT CAT NST
  22 *                           Added getDisplayName API
  23 *                           going to add custom parsing.
  24 *
  25 *                           ISSUES:
  26 *                               - should getDisplayName cache something?
  27 *                               - should custom time zones be cached? [probably]
  28 *  08/10/98     stephen     Brought getDisplayName() API in-line w/ conventions
  29 *  08/19/98     stephen     Changed createTimeZone() to never return 0
  30 *  09/02/98     stephen     Added getOffset(monthLen) and hasSameRules()
  31 *  09/15/98     stephen     Added getStaticClassID()
  32 *  02/22/99     stephen     Removed character literals for EBCDIC safety
  33 *  05/04/99     stephen     Changed initDefault() for Mutex issues
  34 *  07/12/99     helena      HPUX 11 CC Port.
  35 *  12/03/99     aliu        Moved data out of static table into icudata.dll.
  36 *                           Substantial rewrite of zone lookup, default zone, and
  37 *                           available IDs code.  Misc. cleanup.
  38 *********************************************************************************/
  39 
  40 #include &quot;utypeinfo.h&quot;  // for &#39;typeid&#39; to work
  41 
  42 #include &quot;unicode/utypes.h&quot;
  43 #include &quot;unicode/ustring.h&quot;
  44 #include &quot;uassert.h&quot;
  45 #include &quot;ustr_imp.h&quot;
  46 
  47 #ifdef U_DEBUG_TZ
  48 # include &lt;stdio.h&gt;
  49 # include &quot;uresimp.h&quot; // for debugging
  50 
  51 static void debug_tz_loc(const char *f, int32_t l)
  52 {
  53   fprintf(stderr, &quot;%s:%d: &quot;, f, l);
  54 }
  55 
  56 static void debug_tz_msg(const char *pat, ...)
  57 {
  58   va_list ap;
  59   va_start(ap, pat);
  60   vfprintf(stderr, pat, ap);
  61   fflush(stderr);
  62 }
  63 static char gStrBuf[256];
  64 #define U_DEBUG_TZ_STR(x) u_austrncpy(gStrBuf,x,sizeof(gStrBuf)-1)
  65 // must use double parens, i.e.:  U_DEBUG_TZ_MSG((&quot;four is: %d&quot;,4));
  66 #define U_DEBUG_TZ_MSG(x) {debug_tz_loc(__FILE__,__LINE__);debug_tz_msg x;}
  67 #else
  68 #define U_DEBUG_TZ_MSG(x)
  69 #endif
  70 
  71 #if !UCONFIG_NO_FORMATTING
  72 
  73 #include &quot;unicode/simpletz.h&quot;
  74 #include &quot;unicode/calendar.h&quot;
  75 #include &quot;unicode/gregocal.h&quot;
  76 #include &quot;unicode/ures.h&quot;
  77 #include &quot;unicode/tzfmt.h&quot;
  78 #include &quot;unicode/numfmt.h&quot;
  79 #include &quot;gregoimp.h&quot;
  80 #include &quot;uresimp.h&quot; // struct UResourceBundle
  81 #include &quot;olsontz.h&quot;
  82 #include &quot;mutex.h&quot;
  83 #include &quot;unicode/udata.h&quot;
  84 #include &quot;ucln_in.h&quot;
  85 #include &quot;cstring.h&quot;
  86 #include &quot;cmemory.h&quot;
  87 #include &quot;unicode/strenum.h&quot;
  88 #include &quot;uassert.h&quot;
  89 #include &quot;zonemeta.h&quot;
  90 
  91 #define kZONEINFO &quot;zoneinfo64&quot;
  92 #define kREGIONS  &quot;Regions&quot;
  93 #define kZONES    &quot;Zones&quot;
  94 #define kRULES    &quot;Rules&quot;
  95 #define kNAMES    &quot;Names&quot;
  96 #define kTZVERSION  &quot;TZVersion&quot;
  97 #define kLINKS    &quot;links&quot;
  98 #define kMAX_CUSTOM_HOUR    23
  99 #define kMAX_CUSTOM_MIN     59
 100 #define kMAX_CUSTOM_SEC     59
 101 #define MINUS 0x002D
 102 #define PLUS 0x002B
 103 #define ZERO_DIGIT 0x0030
 104 #define COLON 0x003A
 105 
 106 // Static data and constants
 107 
 108 static const UChar         WORLD[] = {0x30, 0x30, 0x31, 0x00}; /* &quot;001&quot; */
 109 
 110 static const UChar         GMT_ID[] = {0x47, 0x4D, 0x54, 0x00}; /* &quot;GMT&quot; */
 111 static const UChar         UNKNOWN_ZONE_ID[] = {0x45, 0x74, 0x63, 0x2F, 0x55, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 0x00}; /* &quot;Etc/Unknown&quot; */
 112 static const int32_t       GMT_ID_LENGTH = 3;
 113 static const int32_t       UNKNOWN_ZONE_ID_LENGTH = 11;
 114 
 115 static icu::TimeZone* DEFAULT_ZONE = NULL;
 116 static icu::UInitOnce gDefaultZoneInitOnce = U_INITONCE_INITIALIZER;
 117 
<a name="1" id="anc1"></a><span class="line-modified"> 118 alignas(icu::SimpleTimeZone)</span>
<span class="line-modified"> 119 static char gRawGMT[sizeof(icu::SimpleTimeZone)];</span>
<span class="line-added"> 120 </span>
<span class="line-added"> 121 alignas(icu::SimpleTimeZone)</span>
<span class="line-added"> 122 static char gRawUNKNOWN[sizeof(icu::SimpleTimeZone)];</span>
<span class="line-added"> 123 </span>
 124 static icu::UInitOnce gStaticZonesInitOnce = U_INITONCE_INITIALIZER;
<a name="2" id="anc2"></a><span class="line-added"> 125 static UBool gStaticZonesInitialized = FALSE; // Whether the static zones are initialized and ready to use.</span>
 126 
 127 static char TZDATA_VERSION[16];
 128 static icu::UInitOnce gTZDataVersionInitOnce = U_INITONCE_INITIALIZER;
 129 
 130 static int32_t* MAP_SYSTEM_ZONES = NULL;
 131 static int32_t* MAP_CANONICAL_SYSTEM_ZONES = NULL;
 132 static int32_t* MAP_CANONICAL_SYSTEM_LOCATION_ZONES = NULL;
 133 
 134 static int32_t LEN_SYSTEM_ZONES = 0;
 135 static int32_t LEN_CANONICAL_SYSTEM_ZONES = 0;
 136 static int32_t LEN_CANONICAL_SYSTEM_LOCATION_ZONES = 0;
 137 
 138 static icu::UInitOnce gSystemZonesInitOnce = U_INITONCE_INITIALIZER;
 139 static icu::UInitOnce gCanonicalZonesInitOnce = U_INITONCE_INITIALIZER;
 140 static icu::UInitOnce gCanonicalLocationZonesInitOnce = U_INITONCE_INITIALIZER;
 141 
 142 U_CDECL_BEGIN
 143 static UBool U_CALLCONV timeZone_cleanup(void)
 144 {
 145     U_NAMESPACE_USE
 146     delete DEFAULT_ZONE;
 147     DEFAULT_ZONE = NULL;
 148     gDefaultZoneInitOnce.reset();
 149 
<a name="3" id="anc3"></a><span class="line-modified"> 150     if (gStaticZonesInitialized) {</span>
<span class="line-modified"> 151         reinterpret_cast&lt;SimpleTimeZone*&gt;(gRawGMT)-&gt;~SimpleTimeZone();</span>
<span class="line-modified"> 152         reinterpret_cast&lt;SimpleTimeZone*&gt;(gRawUNKNOWN)-&gt;~SimpleTimeZone();</span>
<span class="line-modified"> 153         gStaticZonesInitialized = FALSE;</span>
<span class="line-modified"> 154         gStaticZonesInitOnce.reset();</span>
<span class="line-added"> 155     }</span>
 156 
 157     uprv_memset(TZDATA_VERSION, 0, sizeof(TZDATA_VERSION));
 158     gTZDataVersionInitOnce.reset();
 159 
 160     LEN_SYSTEM_ZONES = 0;
 161     uprv_free(MAP_SYSTEM_ZONES);
 162     MAP_SYSTEM_ZONES = 0;
 163     gSystemZonesInitOnce.reset();
 164 
 165     LEN_CANONICAL_SYSTEM_ZONES = 0;
 166     uprv_free(MAP_CANONICAL_SYSTEM_ZONES);
 167     MAP_CANONICAL_SYSTEM_ZONES = 0;
 168     gCanonicalZonesInitOnce.reset();
 169 
 170     LEN_CANONICAL_SYSTEM_LOCATION_ZONES = 0;
 171     uprv_free(MAP_CANONICAL_SYSTEM_LOCATION_ZONES);
 172     MAP_CANONICAL_SYSTEM_LOCATION_ZONES = 0;
 173     gCanonicalLocationZonesInitOnce.reset();
 174 
 175     return TRUE;
 176 }
 177 U_CDECL_END
 178 
 179 U_NAMESPACE_BEGIN
 180 
 181 static int32_t findInStringArray(UResourceBundle* array, const UnicodeString&amp; id, UErrorCode &amp;status)
 182 {
 183     UnicodeString copy;
 184     const UChar *u;
 185     int32_t len;
 186 
 187     int32_t start = 0;
 188     int32_t limit = ures_getSize(array);
 189     int32_t mid;
 190     int32_t lastMid = INT32_MAX;
 191     if(U_FAILURE(status) || (limit &lt; 1)) {
 192         return -1;
 193     }
 194     U_DEBUG_TZ_MSG((&quot;fisa: Looking for %s, between %d and %d\n&quot;, U_DEBUG_TZ_STR(UnicodeString(id).getTerminatedBuffer()), start, limit));
 195 
 196     for (;;) {
 197         mid = (int32_t)((start + limit) / 2);
 198         if (lastMid == mid) {   /* Have we moved? */
 199             break;  /* We haven&#39;t moved, and it wasn&#39;t found. */
 200         }
 201         lastMid = mid;
 202         u = ures_getStringByIndex(array, mid, &amp;len, &amp;status);
 203         if (U_FAILURE(status)) {
 204             break;
 205         }
 206         U_DEBUG_TZ_MSG((&quot;tz: compare to %s, %d .. [%d] .. %d\n&quot;, U_DEBUG_TZ_STR(u), start, mid, limit));
 207         copy.setTo(TRUE, u, len);
 208         int r = id.compare(copy);
 209         if(r==0) {
 210             U_DEBUG_TZ_MSG((&quot;fisa: found at %d\n&quot;, mid));
 211             return mid;
 212         } else if(r&lt;0) {
 213             limit = mid;
 214         } else {
 215             start = mid;
 216         }
 217     }
 218     U_DEBUG_TZ_MSG((&quot;fisa: not found\n&quot;));
 219     return -1;
 220 }
 221 
 222 /**
 223  * Fetch a specific zone by name.  Replaces the getByKey call.
 224  * @param top Top timezone resource
 225  * @param id Time zone ID
 226  * @param oldbundle Bundle for reuse (or NULL).   see &#39;ures_open()&#39;
 227  * @return the zone&#39;s bundle if found, or undefined if error.  Reuses oldbundle.
 228  */
 229 static UResourceBundle* getZoneByName(const UResourceBundle* top, const UnicodeString&amp; id, UResourceBundle *oldbundle, UErrorCode&amp; status) {
 230     // load the Rules object
 231     UResourceBundle *tmp = ures_getByKey(top, kNAMES, NULL, &amp;status);
 232 
 233     // search for the string
 234     int32_t idx = findInStringArray(tmp, id, status);
 235 
 236     if((idx == -1) &amp;&amp; U_SUCCESS(status)) {
 237         // not found
 238         status = U_MISSING_RESOURCE_ERROR;
 239         //ures_close(oldbundle);
 240         //oldbundle = NULL;
 241     } else {
 242         U_DEBUG_TZ_MSG((&quot;gzbn: oldbundle= size %d, type %d, %s\n&quot;, ures_getSize(tmp), ures_getType(tmp), u_errorName(status)));
 243         tmp = ures_getByKey(top, kZONES, tmp, &amp;status); // get Zones object from top
 244         U_DEBUG_TZ_MSG((&quot;gzbn: loaded ZONES, size %d, type %d, path %s %s\n&quot;, ures_getSize(tmp), ures_getType(tmp), ures_getPath(tmp), u_errorName(status)));
 245         oldbundle = ures_getByIndex(tmp, idx, oldbundle, &amp;status); // get nth Zone object
 246         U_DEBUG_TZ_MSG((&quot;gzbn: loaded z#%d, size %d, type %d, path %s, %s\n&quot;, idx, ures_getSize(oldbundle), ures_getType(oldbundle), ures_getPath(oldbundle),  u_errorName(status)));
 247     }
 248     ures_close(tmp);
 249     if(U_FAILURE(status)) {
 250         //ures_close(oldbundle);
 251         return NULL;
 252     } else {
 253         return oldbundle;
 254     }
 255 }
 256 
 257 
 258 UResourceBundle* TimeZone::loadRule(const UResourceBundle* top, const UnicodeString&amp; ruleid, UResourceBundle* oldbundle, UErrorCode&amp; status) {
 259     char key[64];
 260     ruleid.extract(0, sizeof(key)-1, key, (int32_t)sizeof(key)-1, US_INV);
 261     U_DEBUG_TZ_MSG((&quot;loadRule(%s)\n&quot;, key));
 262     UResourceBundle *r = ures_getByKey(top, kRULES, oldbundle, &amp;status);
 263     U_DEBUG_TZ_MSG((&quot;loadRule(%s) -&gt; kRULES [%s]\n&quot;, key, u_errorName(status)));
 264     r = ures_getByKey(r, key, r, &amp;status);
 265     U_DEBUG_TZ_MSG((&quot;loadRule(%s) -&gt; item [%s]\n&quot;, key, u_errorName(status)));
 266     return r;
 267 }
 268 
 269 /**
 270  * Given an ID, open the appropriate resource for the given time zone.
 271  * Dereference aliases if necessary.
 272  * @param id zone id
 273  * @param res resource, which must be ready for use (initialized but not open)
 274  * @param ec input-output error code
 275  * @return top-level resource bundle
 276  */
 277 static UResourceBundle* openOlsonResource(const UnicodeString&amp; id,
 278                                           UResourceBundle&amp; res,
 279                                           UErrorCode&amp; ec)
 280 {
<a name="4" id="anc4"></a><span class="line-modified"> 281 #ifdef U_DEBUG_TZ</span>
 282     char buf[128];
 283     id.extract(0, sizeof(buf)-1, buf, sizeof(buf), &quot;&quot;);
 284 #endif
 285     UResourceBundle *top = ures_openDirect(0, kZONEINFO, &amp;ec);
 286     U_DEBUG_TZ_MSG((&quot;pre: res sz=%d\n&quot;, ures_getSize(&amp;res)));
 287     /* &amp;res = */ getZoneByName(top, id, &amp;res, ec);
 288     // Dereference if this is an alias.  Docs say result should be 1
 289     // but it is 0 in 2.8 (?).
 290     U_DEBUG_TZ_MSG((&quot;Loading zone &#39;%s&#39; (%s, size %d) - %s\n&quot;, buf, ures_getKey((UResourceBundle*)&amp;res), ures_getSize(&amp;res), u_errorName(ec)));
 291     if (ures_getType(&amp;res) == URES_INT) {
 292         int32_t deref = ures_getInt(&amp;res, &amp;ec) + 0;
 293         U_DEBUG_TZ_MSG((&quot;getInt: %s - type is %d\n&quot;, u_errorName(ec), ures_getType(&amp;res)));
 294         UResourceBundle *ares = ures_getByKey(top, kZONES, NULL, &amp;ec); // dereference Zones section
 295         ures_getByIndex(ares, deref, &amp;res, &amp;ec);
 296         ures_close(ares);
 297         U_DEBUG_TZ_MSG((&quot;alias to #%d (%s) - %s\n&quot;, deref, &quot;??&quot;, u_errorName(ec)));
 298     } else {
 299         U_DEBUG_TZ_MSG((&quot;not an alias - size %d\n&quot;, ures_getSize(&amp;res)));
 300     }
 301     U_DEBUG_TZ_MSG((&quot;%s - final status is %s\n&quot;, buf, u_errorName(ec)));
 302     return top;
 303 }
 304 
 305 // -------------------------------------
 306 
 307 namespace {
 308 
 309 void U_CALLCONV initStaticTimeZones() {
 310     // Initialize _GMT independently of other static data; it should
 311     // be valid even if we can&#39;t load the time zone UDataMemory.
 312     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONE, timeZone_cleanup);
<a name="5" id="anc5"></a><span class="line-modified"> 313 </span>
<span class="line-modified"> 314     // new can&#39;t fail below, as we use placement new into staticly allocated space.</span>
<span class="line-added"> 315     new(gRawGMT) SimpleTimeZone(0, UnicodeString(TRUE, GMT_ID, GMT_ID_LENGTH));</span>
<span class="line-added"> 316     new(gRawUNKNOWN) SimpleTimeZone(0, UnicodeString(TRUE, UNKNOWN_ZONE_ID, UNKNOWN_ZONE_ID_LENGTH));</span>
<span class="line-added"> 317 </span>
<span class="line-added"> 318     gStaticZonesInitialized = TRUE;</span>
 319 }
 320 
 321 }  // anonymous namespace
 322 
 323 const TimeZone&amp; U_EXPORT2
 324 TimeZone::getUnknown()
 325 {
 326     umtx_initOnce(gStaticZonesInitOnce, &amp;initStaticTimeZones);
<a name="6" id="anc6"></a><span class="line-modified"> 327     return *reinterpret_cast&lt;SimpleTimeZone*&gt;(gRawUNKNOWN);</span>
 328 }
 329 
 330 const TimeZone* U_EXPORT2
 331 TimeZone::getGMT(void)
 332 {
 333     umtx_initOnce(gStaticZonesInitOnce, &amp;initStaticTimeZones);
<a name="7" id="anc7"></a><span class="line-modified"> 334     return reinterpret_cast&lt;SimpleTimeZone*&gt;(gRawGMT);</span>
 335 }
 336 
 337 // *****************************************************************************
 338 // class TimeZone
 339 // *****************************************************************************
 340 
 341 UOBJECT_DEFINE_ABSTRACT_RTTI_IMPLEMENTATION(TimeZone)
 342 
 343 TimeZone::TimeZone()
 344     :   UObject(), fID()
 345 {
 346 }
 347 
 348 // -------------------------------------
 349 
 350 TimeZone::TimeZone(const UnicodeString &amp;id)
 351     :   UObject(), fID(id)
 352 {
 353 }
 354 
 355 // -------------------------------------
 356 
 357 TimeZone::~TimeZone()
 358 {
 359 }
 360 
 361 // -------------------------------------
 362 
 363 TimeZone::TimeZone(const TimeZone &amp;source)
 364     :   UObject(source), fID(source.fID)
 365 {
 366 }
 367 
 368 // -------------------------------------
 369 
 370 TimeZone &amp;
 371 TimeZone::operator=(const TimeZone &amp;right)
 372 {
 373     if (this != &amp;right) fID = right.fID;
 374     return *this;
 375 }
 376 
 377 // -------------------------------------
 378 
 379 UBool
 380 TimeZone::operator==(const TimeZone&amp; that) const
 381 {
 382     return typeid(*this) == typeid(that) &amp;&amp;
 383         fID == that.fID;
 384 }
 385 
 386 // -------------------------------------
 387 
 388 namespace {
 389 TimeZone*
 390 createSystemTimeZone(const UnicodeString&amp; id, UErrorCode&amp; ec) {
 391     if (U_FAILURE(ec)) {
 392         return NULL;
 393     }
 394     TimeZone* z = 0;
<a name="8" id="anc8"></a><span class="line-modified"> 395     StackUResourceBundle res;</span>

 396     U_DEBUG_TZ_MSG((&quot;pre-err=%s\n&quot;, u_errorName(ec)));
<a name="9" id="anc9"></a><span class="line-modified"> 397     UResourceBundle *top = openOlsonResource(id, res.ref(), ec);</span>
 398     U_DEBUG_TZ_MSG((&quot;post-err=%s\n&quot;, u_errorName(ec)));
 399     if (U_SUCCESS(ec)) {
<a name="10" id="anc10"></a><span class="line-modified"> 400         z = new OlsonTimeZone(top, res.getAlias(), id, ec);</span>
 401         if (z == NULL) {
<a name="11" id="anc11"></a><span class="line-modified"> 402             ec = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 403             U_DEBUG_TZ_MSG((&quot;cstz: olson time zone failed to initialize - err %s\n&quot;, u_errorName(ec)));</span>
 404         }
 405     }
<a name="12" id="anc12"></a>
 406     ures_close(top);
 407     if (U_FAILURE(ec)) {
 408         U_DEBUG_TZ_MSG((&quot;cstz: failed to create, err %s\n&quot;, u_errorName(ec)));
 409         delete z;
<a name="13" id="anc13"></a><span class="line-modified"> 410         z = NULL;</span>
 411     }
 412     return z;
 413 }
 414 
 415 /**
 416  * Lookup the given name in our system zone table.  If found,
 417  * instantiate a new zone of that name and return it.  If not
 418  * found, return 0.
 419  */
 420 TimeZone*
 421 createSystemTimeZone(const UnicodeString&amp; id) {
 422     UErrorCode ec = U_ZERO_ERROR;
 423     return createSystemTimeZone(id, ec);
 424 }
 425 
 426 }
 427 
 428 TimeZone* U_EXPORT2
 429 TimeZone::createTimeZone(const UnicodeString&amp; ID)
 430 {
 431     /* We first try to lookup the zone ID in our system list.  If this
 432      * fails, we try to parse it as a custom string GMT[+-]hh:mm.  If
 433      * all else fails, we return GMT, which is probably not what the
 434      * user wants, but at least is a functioning TimeZone object.
 435      *
 436      * We cannot return NULL, because that would break compatibility
 437      * with the JDK.
 438      */
 439     TimeZone* result = createSystemTimeZone(ID);
 440 
 441     if (result == NULL) {
 442         U_DEBUG_TZ_MSG((&quot;failed to load system time zone with id - falling to custom&quot;));
 443         result = createCustomTimeZone(ID);
 444     }
 445     if (result == NULL) {
 446         U_DEBUG_TZ_MSG((&quot;failed to load time zone with id - falling to Etc/Unknown(GMT)&quot;));
 447         const TimeZone&amp; unknown = getUnknown();
<a name="14" id="anc14"></a><span class="line-modified"> 448         // Unknown zone uses staticly allocated memory, so creation of it can never fail due to OOM.</span>
<span class="line-modified"> 449         result = unknown.clone();</span>



 450     }
 451     return result;
 452 }
 453 
 454 // -------------------------------------
 455 
 456 TimeZone* U_EXPORT2
 457 TimeZone::detectHostTimeZone()
 458 {
<a name="15" id="anc15"></a><span class="line-modified"> 459     // We access system timezone data through uprv_tzset(), uprv_tzname(), and others,</span>
<span class="line-modified"> 460     // which have platform specific implementations in putil.cpp</span>
 461     int32_t rawOffset = 0;
 462     const char *hostID;
<a name="16" id="anc16"></a><span class="line-added"> 463     UBool hostDetectionSucceeded = TRUE;</span>
 464 
 465     // First, try to create a system timezone, based
 466     // on the string ID in tzname[0].
 467 
 468     uprv_tzset(); // Initialize tz... system data
 469 
 470     uprv_tzname_clear_cache();
 471 
 472     // Get the timezone ID from the host.  This function should do
 473     // any required host-specific remapping; e.g., on Windows this
<a name="17" id="anc17"></a><span class="line-modified"> 474     // function maps the Windows Time Zone name to an ICU timezone ID.</span>

 475     hostID = uprv_tzname(0);
 476 
 477     // Invert sign because UNIX semantics are backwards
 478     rawOffset = uprv_timezone() * -U_MILLIS_PER_SECOND;
 479 
 480     TimeZone* hostZone = NULL;
 481 
<a name="18" id="anc18"></a>
 482     UnicodeString hostStrID(hostID, -1, US_INV);
<a name="19" id="anc19"></a><span class="line-modified"> 483 </span>
<span class="line-modified"> 484     if (hostStrID.length() == 0) {</span>
<span class="line-added"> 485         // The host time zone detection (or remapping) above has failed and</span>
<span class="line-added"> 486         // we have no name at all. Fallback to using the Unknown zone.</span>
<span class="line-added"> 487         hostStrID = UnicodeString(TRUE, UNKNOWN_ZONE_ID, UNKNOWN_ZONE_ID_LENGTH);</span>
<span class="line-added"> 488         hostDetectionSucceeded = FALSE;</span>
<span class="line-added"> 489     }</span>
<span class="line-added"> 490 </span>
 491     hostZone = createSystemTimeZone(hostStrID);
 492 
 493 #if U_PLATFORM_USES_ONLY_WIN32_API
 494     // hostID points to a heap-allocated location on Windows.
 495     uprv_free(const_cast&lt;char *&gt;(hostID));
 496 #endif
 497 
 498     int32_t hostIDLen = hostStrID.length();
 499     if (hostZone != NULL &amp;&amp; rawOffset != hostZone-&gt;getRawOffset()
 500         &amp;&amp; (3 &lt;= hostIDLen &amp;&amp; hostIDLen &lt;= 4))
 501     {
 502         // Uh oh. This probably wasn&#39;t a good id.
 503         // It was probably an ambiguous abbreviation
 504         delete hostZone;
 505         hostZone = NULL;
 506     }
 507 
 508     // Construct a fixed standard zone with the host&#39;s ID
 509     // and raw offset.
<a name="20" id="anc20"></a><span class="line-modified"> 510     if (hostZone == NULL &amp;&amp; hostDetectionSucceeded) {</span>
 511         hostZone = new SimpleTimeZone(rawOffset, hostStrID);
 512     }
 513 
<a name="21" id="anc21"></a><span class="line-modified"> 514     // If we _still_ don&#39;t have a time zone, use the Unknown zone.</span>
 515     //
 516     // Note: This is extremely unlikely situation. If
 517     // new SimpleTimeZone(...) above fails, the following
 518     // code may also fail.
 519     if (hostZone == NULL) {
<a name="22" id="anc22"></a><span class="line-modified"> 520         // Unknown zone uses static allocated memory, so it must always exist.</span>
<span class="line-modified"> 521         // However, clone() allocates memory and can fail.</span>
<span class="line-modified"> 522         hostZone = TimeZone::getUnknown().clone();</span>



 523     }
 524 
 525     return hostZone;
 526 }
 527 
 528 // -------------------------------------
 529 
 530 /**
 531  * Initialize DEFAULT_ZONE from the system default time zone.
 532  * Upon return, DEFAULT_ZONE will not be NULL, unless operator new()
 533  * returns NULL.
 534  */
 535 static void U_CALLCONV initDefault()
 536 {
 537     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONE, timeZone_cleanup);
 538 
 539     // If setDefault() has already been called we can skip getting the
 540     // default zone information from the system.
 541     if (DEFAULT_ZONE != NULL) {
 542         return;
 543     }
 544 
 545     // NOTE:  this code is safely single threaded, being only
 546     // run via umtx_initOnce().
 547     //
 548     // Some of the locale/timezone OS functions may not be thread safe,
 549     //
 550     // The operating system might actually use ICU to implement timezones.
 551     // So we may have ICU calling ICU here, like on AIX.
 552     // There shouldn&#39;t be a problem with this; initOnce does not hold a mutex
 553     // while the init function is being run.
 554 
 555     // The code detecting the host time zone was separated from this
 556     // and implemented as TimeZone::detectHostTimeZone()
 557 
 558     TimeZone *default_zone = TimeZone::detectHostTimeZone();
 559 
 560     // The only way for DEFAULT_ZONE to be non-null at this point is if the user
 561     // made a thread-unsafe call to setDefault() or adoptDefault() in another
 562     // thread while this thread was doing something that required getting the default.
 563     U_ASSERT(DEFAULT_ZONE == NULL);
 564 
 565     DEFAULT_ZONE = default_zone;
 566 }
 567 
 568 // -------------------------------------
 569 
 570 TimeZone* U_EXPORT2
 571 TimeZone::createDefault()
 572 {
 573     umtx_initOnce(gDefaultZoneInitOnce, initDefault);
 574     return (DEFAULT_ZONE != NULL) ? DEFAULT_ZONE-&gt;clone() : NULL;
 575 }
 576 
 577 // -------------------------------------
 578 
 579 void U_EXPORT2
 580 TimeZone::adoptDefault(TimeZone* zone)
 581 {
 582     if (zone != NULL)
 583     {
 584         TimeZone *old = DEFAULT_ZONE;
 585         DEFAULT_ZONE = zone;
 586         delete old;
 587         ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONE, timeZone_cleanup);
 588     }
 589 }
 590 // -------------------------------------
 591 
 592 void U_EXPORT2
 593 TimeZone::setDefault(const TimeZone&amp; zone)
 594 {
 595     adoptDefault(zone.clone());
 596 }
 597 
 598 //----------------------------------------------------------------------
 599 
 600 
 601 static void U_CALLCONV initMap(USystemTimeZoneType type, UErrorCode&amp; ec) {
 602     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONE, timeZone_cleanup);
 603 
 604     UResourceBundle *res = ures_openDirect(0, kZONEINFO, &amp;ec);
 605     res = ures_getByKey(res, kNAMES, res, &amp;ec); // dereference Zones section
 606     if (U_SUCCESS(ec)) {
 607         int32_t size = ures_getSize(res);
 608         int32_t *m = (int32_t *)uprv_malloc(size * sizeof(int32_t));
 609         if (m == NULL) {
 610             ec = U_MEMORY_ALLOCATION_ERROR;
 611         } else {
 612             int32_t numEntries = 0;
 613             for (int32_t i = 0; i &lt; size; i++) {
 614                 UnicodeString id = ures_getUnicodeStringByIndex(res, i, &amp;ec);
 615                 if (U_FAILURE(ec)) {
 616                     break;
 617                 }
 618                 if (0 == id.compare(UNKNOWN_ZONE_ID, UNKNOWN_ZONE_ID_LENGTH)) {
 619                     // exclude Etc/Unknown
 620                     continue;
 621                 }
 622                 if (type == UCAL_ZONE_TYPE_CANONICAL || type == UCAL_ZONE_TYPE_CANONICAL_LOCATION) {
 623                     UnicodeString canonicalID;
 624                     ZoneMeta::getCanonicalCLDRID(id, canonicalID, ec);
 625                     if (U_FAILURE(ec)) {
 626                         break;
 627                     }
 628                     if (canonicalID != id) {
 629                         // exclude aliases
 630                         continue;
 631                     }
 632                 }
 633                 if (type == UCAL_ZONE_TYPE_CANONICAL_LOCATION) {
 634                     const UChar *region = TimeZone::getRegion(id, ec);
 635                     if (U_FAILURE(ec)) {
 636                         break;
 637                     }
 638                     if (u_strcmp(region, WORLD) == 0) {
 639                        // exclude non-location (&quot;001&quot;)
 640                         continue;
 641                     }
 642                 }
 643                 m[numEntries++] = i;
 644             }
 645             if (U_SUCCESS(ec)) {
 646                 int32_t *tmp = m;
 647                 m = (int32_t *)uprv_realloc(tmp, numEntries * sizeof(int32_t));
 648                 if (m == NULL) {
 649                     // realloc failed.. use the original one even it has unused
 650                     // area at the end
 651                     m = tmp;
 652                 }
 653 
 654                 switch(type) {
 655                 case UCAL_ZONE_TYPE_ANY:
 656                     U_ASSERT(MAP_SYSTEM_ZONES == NULL);
 657                     MAP_SYSTEM_ZONES = m;
 658                     LEN_SYSTEM_ZONES = numEntries;
 659                     break;
 660                 case UCAL_ZONE_TYPE_CANONICAL:
 661                     U_ASSERT(MAP_CANONICAL_SYSTEM_ZONES == NULL);
 662                     MAP_CANONICAL_SYSTEM_ZONES = m;
 663                     LEN_CANONICAL_SYSTEM_ZONES = numEntries;
 664                     break;
 665                 case UCAL_ZONE_TYPE_CANONICAL_LOCATION:
 666                     U_ASSERT(MAP_CANONICAL_SYSTEM_LOCATION_ZONES == NULL);
 667                     MAP_CANONICAL_SYSTEM_LOCATION_ZONES = m;
 668                     LEN_CANONICAL_SYSTEM_LOCATION_ZONES = numEntries;
 669                     break;
 670                 }
 671             }
 672         }
 673     }
 674     ures_close(res);
 675 }
 676 
 677 
 678 /**
 679  * This is the default implementation for subclasses that do not
 680  * override this method.  This implementation calls through to the
 681  * 8-argument getOffset() method after suitable computations, and
 682  * correctly adjusts GMT millis to local millis when necessary.
 683  */
 684 void TimeZone::getOffset(UDate date, UBool local, int32_t&amp; rawOffset,
 685                          int32_t&amp; dstOffset, UErrorCode&amp; ec) const {
 686     if (U_FAILURE(ec)) {
 687         return;
 688     }
 689 
 690     rawOffset = getRawOffset();
 691     if (!local) {
 692         date += rawOffset; // now in local standard millis
 693     }
 694 
 695     // When local == TRUE, date might not be in local standard
 696     // millis.  getOffset taking 7 parameters used here assume
 697     // the given time in day is local standard time.
 698     // At STD-&gt;DST transition, there is a range of time which
 699     // does not exist.  When &#39;date&#39; is in this time range
 700     // (and local == TRUE), this method interprets the specified
 701     // local time as DST.  At DST-&gt;STD transition, there is a
 702     // range of time which occurs twice.  In this case, this
 703     // method interprets the specified local time as STD.
 704     // To support the behavior above, we need to call getOffset
 705     // (with 7 args) twice when local == true and DST is
 706     // detected in the initial call.
 707     for (int32_t pass=0; ; ++pass) {
 708         int32_t year, month, dom, dow;
 709         double day = uprv_floor(date / U_MILLIS_PER_DAY);
 710         int32_t millis = (int32_t) (date - day * U_MILLIS_PER_DAY);
 711 
 712         Grego::dayToFields(day, year, month, dom, dow);
 713 
 714         dstOffset = getOffset(GregorianCalendar::AD, year, month, dom,
 715                               (uint8_t) dow, millis,
 716                               Grego::monthLength(year, month),
 717                               ec) - rawOffset;
 718 
 719         // Recompute if local==TRUE, dstOffset!=0.
 720         if (pass!=0 || !local || dstOffset == 0) {
 721             break;
 722         }
 723         // adjust to local standard millis
 724         date -= dstOffset;
 725     }
 726 }
 727 
 728 // -------------------------------------
 729 
 730 // New available IDs API as of ICU 2.4.  Uses StringEnumeration API.
 731 
 732 class TZEnumeration : public StringEnumeration {
 733 private:
 734 
 735     // Map into to zones.  Our results are zone[map[i]] for
 736     // i=0..len-1, where zone[i] is the i-th Olson zone.  If map==NULL
 737     // then our results are zone[i] for i=0..len-1.  Len will be zero
 738     // if the zone data could not be loaded.
 739     int32_t* map;
 740     int32_t* localMap;
 741     int32_t  len;
 742     int32_t  pos;
 743 
 744     TZEnumeration(int32_t* mapData, int32_t mapLen, UBool adoptMapData) : pos(0) {
 745         map = mapData;
 746         localMap = adoptMapData ? mapData : NULL;
 747         len = mapLen;
 748     }
 749 
 750     UBool getID(int32_t i, UErrorCode&amp; ec) {
 751         int32_t idLen = 0;
 752         const UChar* id = NULL;
 753         UResourceBundle *top = ures_openDirect(0, kZONEINFO, &amp;ec);
 754         top = ures_getByKey(top, kNAMES, top, &amp;ec); // dereference Zones section
 755         id = ures_getStringByIndex(top, i, &amp;idLen, &amp;ec);
 756         if(U_FAILURE(ec)) {
 757             unistr.truncate(0);
 758         }
 759         else {
 760             unistr.fastCopyFrom(UnicodeString(TRUE, id, idLen));
 761         }
 762         ures_close(top);
 763         return U_SUCCESS(ec);
 764     }
 765 
 766     static int32_t* getMap(USystemTimeZoneType type, int32_t&amp; len, UErrorCode&amp; ec) {
 767         len = 0;
 768         if (U_FAILURE(ec)) {
 769             return NULL;
 770         }
 771         int32_t* m = NULL;
 772         switch (type) {
 773         case UCAL_ZONE_TYPE_ANY:
 774             umtx_initOnce(gSystemZonesInitOnce, &amp;initMap, type, ec);
 775             m = MAP_SYSTEM_ZONES;
 776             len = LEN_SYSTEM_ZONES;
 777             break;
 778         case UCAL_ZONE_TYPE_CANONICAL:
 779             umtx_initOnce(gCanonicalZonesInitOnce, &amp;initMap, type, ec);
 780             m = MAP_CANONICAL_SYSTEM_ZONES;
 781             len = LEN_CANONICAL_SYSTEM_ZONES;
 782             break;
 783         case UCAL_ZONE_TYPE_CANONICAL_LOCATION:
 784             umtx_initOnce(gCanonicalLocationZonesInitOnce, &amp;initMap, type, ec);
 785             m = MAP_CANONICAL_SYSTEM_LOCATION_ZONES;
 786             len = LEN_CANONICAL_SYSTEM_LOCATION_ZONES;
 787             break;
 788         default:
 789             ec = U_ILLEGAL_ARGUMENT_ERROR;
 790             m = NULL;
 791             len = 0;
 792             break;
 793         }
 794         return m;
 795     }
 796 
 797 public:
 798 
 799 #define DEFAULT_FILTERED_MAP_SIZE 8
 800 #define MAP_INCREMENT_SIZE 8
 801 
 802     static TZEnumeration* create(USystemTimeZoneType type, const char* region, const int32_t* rawOffset, UErrorCode&amp; ec) {
 803         if (U_FAILURE(ec)) {
 804             return NULL;
 805         }
 806 
 807         int32_t baseLen;
 808         int32_t *baseMap = getMap(type, baseLen, ec);
 809 
 810         if (U_FAILURE(ec)) {
 811             return NULL;
 812         }
 813 
 814         // If any additional conditions are available,
 815         // create instance local map filtered by the conditions.
 816 
 817         int32_t *filteredMap = NULL;
 818         int32_t numEntries = 0;
 819 
 820         if (region != NULL || rawOffset != NULL) {
 821             int32_t filteredMapSize = DEFAULT_FILTERED_MAP_SIZE;
 822             filteredMap = (int32_t *)uprv_malloc(filteredMapSize * sizeof(int32_t));
 823             if (filteredMap == NULL) {
 824                 ec = U_MEMORY_ALLOCATION_ERROR;
 825                 return NULL;
 826             }
 827 
 828             // Walk through the base map
 829             UResourceBundle *res = ures_openDirect(0, kZONEINFO, &amp;ec);
 830             res = ures_getByKey(res, kNAMES, res, &amp;ec); // dereference Zones section
 831             for (int32_t i = 0; i &lt; baseLen; i++) {
 832                 int32_t zidx = baseMap[i];
 833                 UnicodeString id = ures_getUnicodeStringByIndex(res, zidx, &amp;ec);
 834                 if (U_FAILURE(ec)) {
 835                     break;
 836                 }
 837                 if (region != NULL) {
 838                     // Filter by region
 839                     char tzregion[4]; // max 3 letters + null term
 840                     TimeZone::getRegion(id, tzregion, sizeof(tzregion), ec);
 841                     if (U_FAILURE(ec)) {
 842                         break;
 843                     }
 844                     if (uprv_stricmp(tzregion, region) != 0) {
 845                         // region does not match
 846                         continue;
 847                     }
 848                 }
 849                 if (rawOffset != NULL) {
 850                     // Filter by raw offset
 851                     // Note: This is VERY inefficient
 852                     TimeZone *z = createSystemTimeZone(id, ec);
 853                     if (U_FAILURE(ec)) {
 854                         break;
 855                     }
 856                     int32_t tzoffset = z-&gt;getRawOffset();
 857                     delete z;
 858 
 859                     if (tzoffset != *rawOffset) {
 860                         continue;
 861                     }
 862                 }
 863 
 864                 if (filteredMapSize &lt;= numEntries) {
 865                     filteredMapSize += MAP_INCREMENT_SIZE;
 866                     int32_t *tmp = (int32_t *)uprv_realloc(filteredMap, filteredMapSize * sizeof(int32_t));
 867                     if (tmp == NULL) {
 868                         ec = U_MEMORY_ALLOCATION_ERROR;
 869                         break;
 870                     } else {
 871                         filteredMap = tmp;
 872                     }
 873                 }
 874 
 875                 filteredMap[numEntries++] = zidx;
 876             }
 877 
 878             if (U_FAILURE(ec)) {
 879                 uprv_free(filteredMap);
 880                 filteredMap = NULL;
 881             }
 882 
 883             ures_close(res);
 884         }
 885 
 886         TZEnumeration *result = NULL;
 887         if (U_SUCCESS(ec)) {
 888             // Finally, create a new enumeration instance
 889             if (filteredMap == NULL) {
 890                 result = new TZEnumeration(baseMap, baseLen, FALSE);
 891             } else {
 892                 result = new TZEnumeration(filteredMap, numEntries, TRUE);
 893                 filteredMap = NULL;
 894             }
 895             if (result == NULL) {
 896                 ec = U_MEMORY_ALLOCATION_ERROR;
 897             }
 898         }
 899 
 900         if (filteredMap != NULL) {
 901             uprv_free(filteredMap);
 902         }
 903 
 904         return result;
 905     }
 906 
 907     TZEnumeration(const TZEnumeration &amp;other) : StringEnumeration(), map(NULL), localMap(NULL), len(0), pos(0) {
 908         if (other.localMap != NULL) {
 909             localMap = (int32_t *)uprv_malloc(other.len * sizeof(int32_t));
 910             if (localMap != NULL) {
 911                 len = other.len;
 912                 uprv_memcpy(localMap, other.localMap, len * sizeof(int32_t));
 913                 pos = other.pos;
 914                 map = localMap;
 915             } else {
 916                 len = 0;
 917                 pos = 0;
 918                 map = NULL;
 919             }
 920         } else {
 921             map = other.map;
 922             localMap = NULL;
 923             len = other.len;
 924             pos = other.pos;
 925         }
 926     }
 927 
 928     virtual ~TZEnumeration();
 929 
 930     virtual StringEnumeration *clone() const {
 931         return new TZEnumeration(*this);
 932     }
 933 
 934     virtual int32_t count(UErrorCode&amp; status) const {
 935         return U_FAILURE(status) ? 0 : len;
 936     }
 937 
 938     virtual const UnicodeString* snext(UErrorCode&amp; status) {
 939         if (U_SUCCESS(status) &amp;&amp; map != NULL &amp;&amp; pos &lt; len) {
 940             getID(map[pos], status);
 941             ++pos;
 942             return &amp;unistr;
 943         }
 944         return 0;
 945     }
 946 
 947     virtual void reset(UErrorCode&amp; /*status*/) {
 948         pos = 0;
 949     }
 950 
 951 public:
 952     static UClassID U_EXPORT2 getStaticClassID(void);
 953     virtual UClassID getDynamicClassID(void) const;
 954 };
 955 
 956 TZEnumeration::~TZEnumeration() {
 957     if (localMap != NULL) {
 958         uprv_free(localMap);
 959     }
 960 }
 961 
 962 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(TZEnumeration)
 963 
 964 StringEnumeration* U_EXPORT2
 965 TimeZone::createTimeZoneIDEnumeration(
 966             USystemTimeZoneType zoneType,
 967             const char* region,
 968             const int32_t* rawOffset,
 969             UErrorCode&amp; ec) {
 970     return TZEnumeration::create(zoneType, region, rawOffset, ec);
 971 }
 972 
 973 StringEnumeration* U_EXPORT2
 974 TimeZone::createEnumeration() {
 975     UErrorCode ec = U_ZERO_ERROR;
 976     return TZEnumeration::create(UCAL_ZONE_TYPE_ANY, NULL, NULL, ec);
 977 }
 978 
 979 StringEnumeration* U_EXPORT2
 980 TimeZone::createEnumeration(int32_t rawOffset) {
 981     UErrorCode ec = U_ZERO_ERROR;
 982     return TZEnumeration::create(UCAL_ZONE_TYPE_ANY, NULL, &amp;rawOffset, ec);
 983 }
 984 
 985 StringEnumeration* U_EXPORT2
 986 TimeZone::createEnumeration(const char* country) {
 987     UErrorCode ec = U_ZERO_ERROR;
 988     return TZEnumeration::create(UCAL_ZONE_TYPE_ANY, country, NULL, ec);
 989 }
 990 
 991 // ---------------------------------------
 992 
 993 int32_t U_EXPORT2
 994 TimeZone::countEquivalentIDs(const UnicodeString&amp; id) {
 995     int32_t result = 0;
 996     UErrorCode ec = U_ZERO_ERROR;
<a name="23" id="anc23"></a><span class="line-modified"> 997     StackUResourceBundle res;</span>

 998     U_DEBUG_TZ_MSG((&quot;countEquivalentIDs..\n&quot;));
<a name="24" id="anc24"></a><span class="line-modified"> 999     UResourceBundle *top = openOlsonResource(id, res.ref(), ec);</span>
1000     if (U_SUCCESS(ec)) {
<a name="25" id="anc25"></a><span class="line-modified">1001         StackUResourceBundle r;</span>
<span class="line-modified">1002         ures_getByKey(res.getAlias(), kLINKS, r.getAlias(), &amp;ec);</span>
<span class="line-modified">1003         ures_getIntVector(r.getAlias(), &amp;result, &amp;ec);</span>


1004     }
<a name="26" id="anc26"></a>
1005     ures_close(top);
1006     return result;
1007 }
1008 
1009 // ---------------------------------------
1010 
1011 const UnicodeString U_EXPORT2
1012 TimeZone::getEquivalentID(const UnicodeString&amp; id, int32_t index) {
1013     U_DEBUG_TZ_MSG((&quot;gEI(%d)\n&quot;, index));
1014     UnicodeString result;
1015     UErrorCode ec = U_ZERO_ERROR;
<a name="27" id="anc27"></a><span class="line-modified">1016     StackUResourceBundle res;</span>
<span class="line-modified">1017     UResourceBundle *top = openOlsonResource(id, res.ref(), ec);</span>

1018     int32_t zone = -1;
1019     if (U_SUCCESS(ec)) {
<a name="28" id="anc28"></a><span class="line-modified">1020         StackUResourceBundle r;</span>

1021         int32_t size;
<a name="29" id="anc29"></a><span class="line-modified">1022         ures_getByKey(res.getAlias(), kLINKS, r.getAlias(), &amp;ec);</span>
<span class="line-modified">1023         const int32_t *v = ures_getIntVector(r.getAlias(), &amp;size, &amp;ec);</span>
1024         if (U_SUCCESS(ec)) {
1025             if (index &gt;= 0 &amp;&amp; index &lt; size) {
1026                 zone = v[index];
1027             }
1028         }
<a name="30" id="anc30"></a>
1029     }
<a name="31" id="anc31"></a>
1030     if (zone &gt;= 0) {
1031         UResourceBundle *ares = ures_getByKey(top, kNAMES, NULL, &amp;ec); // dereference Zones section
1032         if (U_SUCCESS(ec)) {
1033             int32_t idLen = 0;
<a name="32" id="anc32"></a><span class="line-modified">1034             const UChar* id2 = ures_getStringByIndex(ares, zone, &amp;idLen, &amp;ec);</span>
<span class="line-modified">1035             result.fastCopyFrom(UnicodeString(TRUE, id2, idLen));</span>
1036             U_DEBUG_TZ_MSG((&quot;gei(%d) -&gt; %d, len%d, %s\n&quot;, index, zone, result.length(), u_errorName(ec)));
1037         }
1038         ures_close(ares);
1039     }
1040     ures_close(top);
1041 #if defined(U_DEBUG_TZ)
1042     if(result.length() ==0) {
1043       U_DEBUG_TZ_MSG((&quot;equiv [__, #%d] -&gt; 0 (%s)\n&quot;, index, u_errorName(ec)));
1044     }
1045 #endif
1046     return result;
1047 }
1048 
1049 // ---------------------------------------
1050 
1051 // These methods are used by ZoneMeta class only.
1052 
1053 const UChar*
1054 TimeZone::findID(const UnicodeString&amp; id) {
1055     const UChar *result = NULL;
1056     UErrorCode ec = U_ZERO_ERROR;
1057     UResourceBundle *rb = ures_openDirect(NULL, kZONEINFO, &amp;ec);
1058 
1059     // resolve zone index by name
1060     UResourceBundle *names = ures_getByKey(rb, kNAMES, NULL, &amp;ec);
1061     int32_t idx = findInStringArray(names, id, ec);
1062     result = ures_getStringByIndex(names, idx, NULL, &amp;ec);
1063     if (U_FAILURE(ec)) {
1064         result = NULL;
1065     }
1066     ures_close(names);
1067     ures_close(rb);
1068     return result;
1069 }
1070 
1071 
1072 const UChar*
1073 TimeZone::dereferOlsonLink(const UnicodeString&amp; id) {
1074     const UChar *result = NULL;
1075     UErrorCode ec = U_ZERO_ERROR;
1076     UResourceBundle *rb = ures_openDirect(NULL, kZONEINFO, &amp;ec);
1077 
1078     // resolve zone index by name
1079     UResourceBundle *names = ures_getByKey(rb, kNAMES, NULL, &amp;ec);
1080     int32_t idx = findInStringArray(names, id, ec);
1081     result = ures_getStringByIndex(names, idx, NULL, &amp;ec);
1082 
1083     // open the zone bundle by index
1084     ures_getByKey(rb, kZONES, rb, &amp;ec);
1085     ures_getByIndex(rb, idx, rb, &amp;ec);
1086 
1087     if (U_SUCCESS(ec)) {
1088         if (ures_getType(rb) == URES_INT) {
1089             // this is a link - dereference the link
1090             int32_t deref = ures_getInt(rb, &amp;ec);
1091             const UChar* tmp = ures_getStringByIndex(names, deref, NULL, &amp;ec);
1092             if (U_SUCCESS(ec)) {
1093                 result = tmp;
1094             }
1095         }
1096     }
1097 
1098     ures_close(names);
1099     ures_close(rb);
1100 
1101     return result;
1102 }
1103 
1104 const UChar*
1105 TimeZone::getRegion(const UnicodeString&amp; id) {
1106     UErrorCode status = U_ZERO_ERROR;
1107     return getRegion(id, status);
1108 }
1109 
1110 const UChar*
1111 TimeZone::getRegion(const UnicodeString&amp; id, UErrorCode&amp; status) {
1112     if (U_FAILURE(status)) {
1113         return NULL;
1114     }
1115     const UChar *result = NULL;
1116     UResourceBundle *rb = ures_openDirect(NULL, kZONEINFO, &amp;status);
1117 
1118     // resolve zone index by name
1119     UResourceBundle *res = ures_getByKey(rb, kNAMES, NULL, &amp;status);
1120     int32_t idx = findInStringArray(res, id, status);
1121 
1122     // get region mapping
1123     ures_getByKey(rb, kREGIONS, res, &amp;status);
1124     const UChar *tmp = ures_getStringByIndex(res, idx, NULL, &amp;status);
1125     if (U_SUCCESS(status)) {
1126         result = tmp;
1127     }
1128 
1129     ures_close(res);
1130     ures_close(rb);
1131 
1132     return result;
1133 }
1134 
1135 
1136 // ---------------------------------------
1137 int32_t
1138 TimeZone::getRegion(const UnicodeString&amp; id, char *region, int32_t capacity, UErrorCode&amp; status)
1139 {
1140     int32_t resultLen = 0;
1141     *region = 0;
1142     if (U_FAILURE(status)) {
1143         return 0;
1144     }
1145 
1146     const UChar *uregion = NULL;
1147     // &quot;Etc/Unknown&quot; is not a system zone ID,
1148     // but in the zone data
1149     if (id.compare(UNKNOWN_ZONE_ID, UNKNOWN_ZONE_ID_LENGTH) != 0) {
1150         uregion = getRegion(id);
1151     }
1152     if (uregion == NULL) {
1153         status = U_ILLEGAL_ARGUMENT_ERROR;
1154         return 0;
1155     }
1156     resultLen = u_strlen(uregion);
1157     // A region code is represented by invariant characters
1158     u_UCharsToChars(uregion, region, uprv_min(resultLen, capacity));
1159 
1160     if (capacity &lt; resultLen) {
1161         status = U_BUFFER_OVERFLOW_ERROR;
1162         return resultLen;
1163     }
1164 
1165     return u_terminateChars(region, capacity, resultLen, &amp;status);
1166 }
1167 
1168 // ---------------------------------------
1169 
1170 
1171 UnicodeString&amp;
1172 TimeZone::getDisplayName(UnicodeString&amp; result) const
1173 {
1174     return getDisplayName(FALSE,LONG,Locale::getDefault(), result);
1175 }
1176 
1177 UnicodeString&amp;
1178 TimeZone::getDisplayName(const Locale&amp; locale, UnicodeString&amp; result) const
1179 {
1180     return getDisplayName(FALSE, LONG, locale, result);
1181 }
1182 
1183 UnicodeString&amp;
<a name="33" id="anc33"></a><span class="line-modified">1184 TimeZone::getDisplayName(UBool inDaylight, EDisplayType style, UnicodeString&amp; result)  const</span>
1185 {
<a name="34" id="anc34"></a><span class="line-modified">1186     return getDisplayName(inDaylight,style, Locale::getDefault(), result);</span>
1187 }
1188 //--------------------------------------
1189 int32_t
1190 TimeZone::getDSTSavings()const {
1191     if (useDaylightTime()) {
1192         return 3600000;
1193     }
1194     return 0;
1195 }
1196 //---------------------------------------
1197 UnicodeString&amp;
<a name="35" id="anc35"></a><span class="line-modified">1198 TimeZone::getDisplayName(UBool inDaylight, EDisplayType style, const Locale&amp; locale, UnicodeString&amp; result) const</span>
1199 {
1200     UErrorCode status = U_ZERO_ERROR;
1201     UDate date = Calendar::getNow();
<a name="36" id="anc36"></a><span class="line-modified">1202     UTimeZoneFormatTimeType timeType = UTZFMT_TIME_TYPE_UNKNOWN;</span>
1203     int32_t offset;
1204 
1205     if (style == GENERIC_LOCATION || style == LONG_GENERIC || style == SHORT_GENERIC) {
1206         LocalPointer&lt;TimeZoneFormat&gt; tzfmt(TimeZoneFormat::createInstance(locale, status));
1207         if (U_FAILURE(status)) {
1208             result.remove();
1209             return result;
1210         }
1211         // Generic format
1212         switch (style) {
1213         case GENERIC_LOCATION:
1214             tzfmt-&gt;format(UTZFMT_STYLE_GENERIC_LOCATION, *this, date, result, &amp;timeType);
1215             break;
1216         case LONG_GENERIC:
1217             tzfmt-&gt;format(UTZFMT_STYLE_GENERIC_LONG, *this, date, result, &amp;timeType);
1218             break;
1219         case SHORT_GENERIC:
1220             tzfmt-&gt;format(UTZFMT_STYLE_GENERIC_SHORT, *this, date, result, &amp;timeType);
1221             break;
1222         default:
<a name="37" id="anc37"></a><span class="line-modified">1223             UPRV_UNREACHABLE;</span>
1224         }
1225         // Generic format many use Localized GMT as the final fallback.
1226         // When Localized GMT format is used, the result might not be
1227         // appropriate for the requested daylight value.
<a name="38" id="anc38"></a><span class="line-modified">1228         if ((inDaylight &amp;&amp; timeType == UTZFMT_TIME_TYPE_STANDARD) || (!inDaylight &amp;&amp; timeType == UTZFMT_TIME_TYPE_DAYLIGHT)) {</span>
<span class="line-modified">1229             offset = inDaylight ? getRawOffset() + getDSTSavings() : getRawOffset();</span>
1230             if (style == SHORT_GENERIC) {
1231                 tzfmt-&gt;formatOffsetShortLocalizedGMT(offset, result, status);
1232             } else {
1233                 tzfmt-&gt;formatOffsetLocalizedGMT(offset, result, status);
1234             }
1235         }
1236     } else if (style == LONG_GMT || style == SHORT_GMT) {
1237         LocalPointer&lt;TimeZoneFormat&gt; tzfmt(TimeZoneFormat::createInstance(locale, status));
1238         if (U_FAILURE(status)) {
1239             result.remove();
1240             return result;
1241         }
<a name="39" id="anc39"></a><span class="line-modified">1242         offset = inDaylight &amp;&amp; useDaylightTime() ? getRawOffset() + getDSTSavings() : getRawOffset();</span>
1243         switch (style) {
1244         case LONG_GMT:
1245             tzfmt-&gt;formatOffsetLocalizedGMT(offset, result, status);
1246             break;
1247         case SHORT_GMT:
1248             tzfmt-&gt;formatOffsetISO8601Basic(offset, FALSE, FALSE, FALSE, result, status);
1249             break;
1250         default:
<a name="40" id="anc40"></a><span class="line-modified">1251             UPRV_UNREACHABLE;</span>
1252         }
1253 
1254     } else {
1255         U_ASSERT(style == LONG || style == SHORT || style == SHORT_COMMONLY_USED);
1256         UTimeZoneNameType nameType = UTZNM_UNKNOWN;
1257         switch (style) {
1258         case LONG:
<a name="41" id="anc41"></a><span class="line-modified">1259             nameType = inDaylight ? UTZNM_LONG_DAYLIGHT : UTZNM_LONG_STANDARD;</span>
1260             break;
1261         case SHORT:
1262         case SHORT_COMMONLY_USED:
<a name="42" id="anc42"></a><span class="line-modified">1263             nameType = inDaylight ? UTZNM_SHORT_DAYLIGHT : UTZNM_SHORT_STANDARD;</span>
1264             break;
1265         default:
<a name="43" id="anc43"></a><span class="line-modified">1266             UPRV_UNREACHABLE;</span>
1267         }
1268         LocalPointer&lt;TimeZoneNames&gt; tznames(TimeZoneNames::createInstance(locale, status));
1269         if (U_FAILURE(status)) {
1270             result.remove();
1271             return result;
1272         }
1273         UnicodeString canonicalID(ZoneMeta::getCanonicalCLDRID(*this));
1274         tznames-&gt;getDisplayName(canonicalID, nameType, date, result);
1275         if (result.isEmpty()) {
1276             // Fallback to localized GMT
1277             LocalPointer&lt;TimeZoneFormat&gt; tzfmt(TimeZoneFormat::createInstance(locale, status));
<a name="44" id="anc44"></a><span class="line-modified">1278             offset = inDaylight &amp;&amp; useDaylightTime() ? getRawOffset() + getDSTSavings() : getRawOffset();</span>
1279             if (style == LONG) {
1280                 tzfmt-&gt;formatOffsetLocalizedGMT(offset, result, status);
1281             } else {
1282                 tzfmt-&gt;formatOffsetShortLocalizedGMT(offset, result, status);
1283             }
1284         }
1285     }
1286     if (U_FAILURE(status)) {
1287         result.remove();
1288     }
1289     return  result;
1290 }
1291 
1292 /**
1293  * Parse a custom time zone identifier and return a corresponding zone.
1294  * @param id a string of the form GMT[+-]hh:mm, GMT[+-]hhmm, or
1295  * GMT[+-]hh.
1296  * @return a newly created SimpleTimeZone with the given offset and
1297  * no Daylight Savings Time, or null if the id cannot be parsed.
1298 */
1299 TimeZone*
1300 TimeZone::createCustomTimeZone(const UnicodeString&amp; id)
1301 {
1302     int32_t sign, hour, min, sec;
1303     if (parseCustomID(id, sign, hour, min, sec)) {
1304         UnicodeString customID;
1305         formatCustomID(hour, min, sec, (sign &lt; 0), customID);
1306         int32_t offset = sign * ((hour * 60 + min) * 60 + sec) * 1000;
1307         return new SimpleTimeZone(offset, customID);
1308     }
1309     return NULL;
1310 }
1311 
1312 UnicodeString&amp;
1313 TimeZone::getCustomID(const UnicodeString&amp; id, UnicodeString&amp; normalized, UErrorCode&amp; status) {
1314     normalized.remove();
1315     if (U_FAILURE(status)) {
1316         return normalized;
1317     }
1318     int32_t sign, hour, min, sec;
1319     if (parseCustomID(id, sign, hour, min, sec)) {
1320         formatCustomID(hour, min, sec, (sign &lt; 0), normalized);
1321     } else {
1322         status = U_ILLEGAL_ARGUMENT_ERROR;
1323     }
1324     return normalized;
1325 }
1326 
1327 UBool
1328 TimeZone::parseCustomID(const UnicodeString&amp; id, int32_t&amp; sign,
1329                         int32_t&amp; hour, int32_t&amp; min, int32_t&amp; sec) {
1330     static const int32_t         kParseFailed = -99999;
1331 
1332     NumberFormat* numberFormat = 0;
1333     UnicodeString idUppercase = id;
1334     idUppercase.toUpper(&quot;&quot;);
1335 
1336     if (id.length() &gt; GMT_ID_LENGTH &amp;&amp;
1337         idUppercase.startsWith(GMT_ID, GMT_ID_LENGTH))
1338     {
1339         ParsePosition pos(GMT_ID_LENGTH);
1340         sign = 1;
1341         hour = 0;
1342         min = 0;
1343         sec = 0;
1344 
1345         if (id[pos.getIndex()] == MINUS /*&#39;-&#39;*/) {
1346             sign = -1;
1347         } else if (id[pos.getIndex()] != PLUS /*&#39;+&#39;*/) {
1348             return FALSE;
1349         }
1350         pos.setIndex(pos.getIndex() + 1);
1351 
1352         UErrorCode success = U_ZERO_ERROR;
1353         numberFormat = NumberFormat::createInstance(success);
1354         if(U_FAILURE(success)){
1355             return FALSE;
1356         }
1357         numberFormat-&gt;setParseIntegerOnly(TRUE);
1358         //numberFormat-&gt;setLenient(TRUE); // TODO: May need to set this, depends on latest timezone parsing
1359 
1360         // Look for either hh:mm, hhmm, or hh
1361         int32_t start = pos.getIndex();
1362         Formattable n(kParseFailed);
1363         numberFormat-&gt;parse(id, n, pos);
1364         if (pos.getIndex() == start) {
1365             delete numberFormat;
1366             return FALSE;
1367         }
1368         hour = n.getLong();
1369 
1370         if (pos.getIndex() &lt; id.length()) {
1371             if (pos.getIndex() - start &gt; 2
1372                 || id[pos.getIndex()] != COLON) {
1373                 delete numberFormat;
1374                 return FALSE;
1375             }
1376             // hh:mm
1377             pos.setIndex(pos.getIndex() + 1);
1378             int32_t oldPos = pos.getIndex();
1379             n.setLong(kParseFailed);
1380             numberFormat-&gt;parse(id, n, pos);
1381             if ((pos.getIndex() - oldPos) != 2) {
1382                 // must be 2 digits
1383                 delete numberFormat;
1384                 return FALSE;
1385             }
1386             min = n.getLong();
1387             if (pos.getIndex() &lt; id.length()) {
1388                 if (id[pos.getIndex()] != COLON) {
1389                     delete numberFormat;
1390                     return FALSE;
1391                 }
1392                 // [:ss]
1393                 pos.setIndex(pos.getIndex() + 1);
1394                 oldPos = pos.getIndex();
1395                 n.setLong(kParseFailed);
1396                 numberFormat-&gt;parse(id, n, pos);
1397                 if (pos.getIndex() != id.length()
1398                         || (pos.getIndex() - oldPos) != 2) {
1399                     delete numberFormat;
1400                     return FALSE;
1401                 }
1402                 sec = n.getLong();
1403             }
1404         } else {
1405             // Supported formats are below -
1406             //
1407             // HHmmss
1408             // Hmmss
1409             // HHmm
1410             // Hmm
1411             // HH
1412             // H
1413 
1414             int32_t length = pos.getIndex() - start;
1415             if (length &lt;= 0 || 6 &lt; length) {
1416                 // invalid length
1417                 delete numberFormat;
1418                 return FALSE;
1419             }
1420             switch (length) {
1421                 case 1:
1422                 case 2:
1423                     // already set to hour
1424                     break;
1425                 case 3:
1426                 case 4:
1427                     min = hour % 100;
1428                     hour /= 100;
1429                     break;
1430                 case 5:
1431                 case 6:
1432                     sec = hour % 100;
1433                     min = (hour/100) % 100;
1434                     hour /= 10000;
1435                     break;
1436             }
1437         }
1438 
1439         delete numberFormat;
1440 
1441         if (hour &gt; kMAX_CUSTOM_HOUR || min &gt; kMAX_CUSTOM_MIN || sec &gt; kMAX_CUSTOM_SEC) {
1442             return FALSE;
1443         }
1444         return TRUE;
1445     }
1446     return FALSE;
1447 }
1448 
1449 UnicodeString&amp;
1450 TimeZone::formatCustomID(int32_t hour, int32_t min, int32_t sec,
1451                          UBool negative, UnicodeString&amp; id) {
1452     // Create time zone ID - GMT[+|-]hhmm[ss]
1453     id.setTo(GMT_ID, GMT_ID_LENGTH);
1454     if (hour | min | sec) {
1455         if (negative) {
1456             id += (UChar)MINUS;
1457         } else {
1458             id += (UChar)PLUS;
1459         }
1460 
1461         if (hour &lt; 10) {
1462             id += (UChar)ZERO_DIGIT;
1463         } else {
1464             id += (UChar)(ZERO_DIGIT + hour/10);
1465         }
1466         id += (UChar)(ZERO_DIGIT + hour%10);
1467         id += (UChar)COLON;
1468         if (min &lt; 10) {
1469             id += (UChar)ZERO_DIGIT;
1470         } else {
1471             id += (UChar)(ZERO_DIGIT + min/10);
1472         }
1473         id += (UChar)(ZERO_DIGIT + min%10);
1474 
1475         if (sec) {
1476             id += (UChar)COLON;
1477             if (sec &lt; 10) {
1478                 id += (UChar)ZERO_DIGIT;
1479             } else {
1480                 id += (UChar)(ZERO_DIGIT + sec/10);
1481             }
1482             id += (UChar)(ZERO_DIGIT + sec%10);
1483         }
1484     }
1485     return id;
1486 }
1487 
1488 
1489 UBool
1490 TimeZone::hasSameRules(const TimeZone&amp; other) const
1491 {
1492     return (getRawOffset() == other.getRawOffset() &amp;&amp;
1493             useDaylightTime() == other.useDaylightTime());
1494 }
1495 
1496 static void U_CALLCONV initTZDataVersion(UErrorCode &amp;status) {
1497     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONE, timeZone_cleanup);
1498     int32_t len = 0;
<a name="45" id="anc45"></a><span class="line-modified">1499     StackUResourceBundle bundle;</span>
<span class="line-modified">1500     ures_openDirectFillIn(bundle.getAlias(), NULL, kZONEINFO, &amp;status);</span>
<span class="line-added">1501     const UChar *tzver = ures_getStringByKey(bundle.getAlias(), kTZVERSION, &amp;len, &amp;status);</span>
1502 
1503     if (U_SUCCESS(status)) {
1504         if (len &gt;= (int32_t)sizeof(TZDATA_VERSION)) {
1505             // Ensure that there is always space for a trailing nul in TZDATA_VERSION
1506             len = sizeof(TZDATA_VERSION) - 1;
1507         }
1508         u_UCharsToChars(tzver, TZDATA_VERSION, len);
1509     }
<a name="46" id="anc46"></a>

1510 }
1511 
1512 const char*
1513 TimeZone::getTZDataVersion(UErrorCode&amp; status)
1514 {
1515     umtx_initOnce(gTZDataVersionInitOnce, &amp;initTZDataVersion, status);
1516     return (const char*)TZDATA_VERSION;
1517 }
1518 
1519 UnicodeString&amp;
1520 TimeZone::getCanonicalID(const UnicodeString&amp; id, UnicodeString&amp; canonicalID, UErrorCode&amp; status)
1521 {
1522     UBool isSystemID = FALSE;
1523     return getCanonicalID(id, canonicalID, isSystemID, status);
1524 }
1525 
1526 UnicodeString&amp;
1527 TimeZone::getCanonicalID(const UnicodeString&amp; id, UnicodeString&amp; canonicalID, UBool&amp; isSystemID,
1528                          UErrorCode&amp; status)
1529 {
1530     canonicalID.remove();
1531     isSystemID = FALSE;
1532     if (U_FAILURE(status)) {
1533         return canonicalID;
1534     }
1535     if (id.compare(UNKNOWN_ZONE_ID, UNKNOWN_ZONE_ID_LENGTH) == 0) {
1536         // special case - Etc/Unknown is a canonical ID, but not system ID
1537         canonicalID.fastCopyFrom(id);
1538         isSystemID = FALSE;
1539     } else {
1540         ZoneMeta::getCanonicalCLDRID(id, canonicalID, status);
1541         if (U_SUCCESS(status)) {
1542             isSystemID = TRUE;
1543         } else {
1544             // Not a system ID
1545             status = U_ZERO_ERROR;
1546             getCustomID(id, canonicalID, status);
1547         }
1548     }
1549     return canonicalID;
1550 }
1551 
1552 UnicodeString&amp;
1553 TimeZone::getWindowsID(const UnicodeString&amp; id, UnicodeString&amp; winid, UErrorCode&amp; status) {
1554     winid.remove();
1555     if (U_FAILURE(status)) {
1556         return winid;
1557     }
1558 
1559     // canonicalize the input ID
1560     UnicodeString canonicalID;
1561     UBool isSystemID = FALSE;
1562 
1563     getCanonicalID(id, canonicalID, isSystemID, status);
1564     if (U_FAILURE(status) || !isSystemID) {
1565         // mapping data is only applicable to tz database IDs
1566         if (status == U_ILLEGAL_ARGUMENT_ERROR) {
1567             // getWindowsID() sets an empty string where
1568             // getCanonicalID() sets a U_ILLEGAL_ARGUMENT_ERROR.
1569             status = U_ZERO_ERROR;
1570         }
1571         return winid;
1572     }
1573 
1574     UResourceBundle *mapTimezones = ures_openDirect(NULL, &quot;windowsZones&quot;, &amp;status);
1575     ures_getByKey(mapTimezones, &quot;mapTimezones&quot;, mapTimezones, &amp;status);
1576 
1577     if (U_FAILURE(status)) {
1578         return winid;
1579     }
1580 
1581     UResourceBundle *winzone = NULL;
1582     UBool found = FALSE;
1583     while (ures_hasNext(mapTimezones) &amp;&amp; !found) {
1584         winzone = ures_getNextResource(mapTimezones, winzone, &amp;status);
1585         if (U_FAILURE(status)) {
1586             break;
1587         }
1588         if (ures_getType(winzone) != URES_TABLE) {
1589             continue;
1590         }
1591         UResourceBundle *regionalData = NULL;
1592         while (ures_hasNext(winzone) &amp;&amp; !found) {
1593             regionalData = ures_getNextResource(winzone, regionalData, &amp;status);
1594             if (U_FAILURE(status)) {
1595                 break;
1596             }
1597             if (ures_getType(regionalData) != URES_STRING) {
1598                 continue;
1599             }
1600             int32_t len;
1601             const UChar *tzids = ures_getString(regionalData, &amp;len, &amp;status);
1602             if (U_FAILURE(status)) {
1603                 break;
1604             }
1605 
1606             const UChar *start = tzids;
1607             UBool hasNext = TRUE;
1608             while (hasNext) {
1609                 const UChar *end = u_strchr(start, (UChar)0x20);
1610                 if (end == NULL) {
1611                     end = tzids + len;
1612                     hasNext = FALSE;
1613                 }
<a name="47" id="anc47"></a><span class="line-modified">1614                 if (canonicalID.compare(start, static_cast&lt;int32_t&gt;(end - start)) == 0) {</span>
1615                     winid = UnicodeString(ures_getKey(winzone), -1 , US_INV);
1616                     found = TRUE;
1617                     break;
1618                 }
1619                 start = end + 1;
1620             }
1621         }
1622         ures_close(regionalData);
1623     }
1624     ures_close(winzone);
1625     ures_close(mapTimezones);
1626 
1627     return winid;
1628 }
1629 
1630 #define MAX_WINDOWS_ID_SIZE 128
1631 
1632 UnicodeString&amp;
1633 TimeZone::getIDForWindowsID(const UnicodeString&amp; winid, const char* region, UnicodeString&amp; id, UErrorCode&amp; status) {
1634     id.remove();
1635     if (U_FAILURE(status)) {
1636         return id;
1637     }
1638 
1639     UResourceBundle *zones = ures_openDirect(NULL, &quot;windowsZones&quot;, &amp;status);
1640     ures_getByKey(zones, &quot;mapTimezones&quot;, zones, &amp;status);
1641     if (U_FAILURE(status)) {
1642         ures_close(zones);
1643         return id;
1644     }
1645 
1646     UErrorCode tmperr = U_ZERO_ERROR;
1647     char winidKey[MAX_WINDOWS_ID_SIZE];
1648     int32_t winKeyLen = winid.extract(0, winid.length(), winidKey, sizeof(winidKey) - 1, US_INV);
1649 
1650     if (winKeyLen == 0 || winKeyLen &gt;= (int32_t)sizeof(winidKey)) {
1651         ures_close(zones);
1652         return id;
1653     }
1654     winidKey[winKeyLen] = 0;
1655 
1656     ures_getByKey(zones, winidKey, zones, &amp;tmperr); // use tmperr, because windows mapping might not
1657                                                     // be avaiable by design
1658     if (U_FAILURE(tmperr)) {
1659         ures_close(zones);
1660         return id;
1661     }
1662 
1663     const UChar *tzid = NULL;
1664     int32_t len = 0;
1665     UBool gotID = FALSE;
1666     if (region) {
1667         const UChar *tzids = ures_getStringByKey(zones, region, &amp;len, &amp;tmperr); // use tmperr, because
1668                                                                                 // regional mapping is optional
1669         if (U_SUCCESS(tmperr)) {
1670             // first ID delimited by space is the defasult one
1671             const UChar *end = u_strchr(tzids, (UChar)0x20);
1672             if (end == NULL) {
1673                 id.setTo(tzids, -1);
1674             } else {
<a name="48" id="anc48"></a><span class="line-modified">1675                 id.setTo(tzids, static_cast&lt;int32_t&gt;(end - tzids));</span>
1676             }
1677             gotID = TRUE;
1678         }
1679     }
1680 
1681     if (!gotID) {
1682         tzid = ures_getStringByKey(zones, &quot;001&quot;, &amp;len, &amp;status);    // using status, because &quot;001&quot; must be
1683                                                                 // available at this point
1684         if (U_SUCCESS(status)) {
1685             id.setTo(tzid, len);
1686         }
1687     }
1688 
1689     ures_close(zones);
1690     return id;
1691 }
1692 
1693 
1694 U_NAMESPACE_END
1695 
1696 #endif /* #if !UCONFIG_NO_FORMATTING */
1697 
1698 //eof
<a name="49" id="anc49"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="49" type="hidden" />
</body>
</html>