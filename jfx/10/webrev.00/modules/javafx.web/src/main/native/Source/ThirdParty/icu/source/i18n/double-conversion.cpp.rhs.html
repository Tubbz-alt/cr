<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/double-conversion.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2018 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 //
   4 // From the double-conversion library. Original license:
   5 //
   6 // Copyright 2010 the V8 project authors. All rights reserved.
   7 // Redistribution and use in source and binary forms, with or without
   8 // modification, are permitted provided that the following conditions are
   9 // met:
  10 //
  11 //     * Redistributions of source code must retain the above copyright
  12 //       notice, this list of conditions and the following disclaimer.
  13 //     * Redistributions in binary form must reproduce the above
  14 //       copyright notice, this list of conditions and the following
  15 //       disclaimer in the documentation and/or other materials provided
  16 //       with the distribution.
  17 //     * Neither the name of Google Inc. nor the names of its
  18 //       contributors may be used to endorse or promote products derived
  19 //       from this software without specific prior written permission.
  20 //
  21 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  22 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  23 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  24 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  25 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  26 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  27 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  28 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  29 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  30 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  31 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  32 
  33 // ICU PATCH: ifdef around UCONFIG_NO_FORMATTING
  34 #include &quot;unicode/utypes.h&quot;
  35 #if !UCONFIG_NO_FORMATTING
  36 
<a name="1" id="anc1"></a><span class="line-modified">  37 // ICU PATCH: Do not include std::locale.</span>
<span class="line-modified">  38 </span>
<span class="line-added">  39 #include &lt;climits&gt;</span>
<span class="line-added">  40 //#include &lt;locale&gt;</span>
<span class="line-added">  41 #include &lt;cmath&gt;</span>
  42 
  43 // ICU PATCH: Customize header file paths for ICU.
  44 // The file fixed-dtoa.h is not needed.
  45 
  46 #include &quot;double-conversion.h&quot;
  47 
  48 #include &quot;double-conversion-bignum-dtoa.h&quot;
  49 #include &quot;double-conversion-fast-dtoa.h&quot;
  50 #include &quot;double-conversion-ieee.h&quot;
  51 #include &quot;double-conversion-strtod.h&quot;
  52 #include &quot;double-conversion-utils.h&quot;
  53 
  54 // ICU PATCH: Wrap in ICU namespace
  55 U_NAMESPACE_BEGIN
  56 
  57 namespace double_conversion {
  58 
  59 #if 0  // not needed for ICU
  60 const DoubleToStringConverter&amp; DoubleToStringConverter::EcmaScriptConverter() {
  61   int flags = UNIQUE_ZERO | EMIT_POSITIVE_EXPONENT_SIGN;
  62   static DoubleToStringConverter converter(flags,
  63                                            &quot;Infinity&quot;,
  64                                            &quot;NaN&quot;,
  65                                            &#39;e&#39;,
  66                                            -6, 21,
  67                                            6, 0);
  68   return converter;
  69 }
  70 
  71 
  72 bool DoubleToStringConverter::HandleSpecialValues(
  73     double value,
  74     StringBuilder* result_builder) const {
  75   Double double_inspect(value);
  76   if (double_inspect.IsInfinite()) {
  77     if (infinity_symbol_ == NULL) return false;
  78     if (value &lt; 0) {
  79       result_builder-&gt;AddCharacter(&#39;-&#39;);
  80     }
  81     result_builder-&gt;AddString(infinity_symbol_);
  82     return true;
  83   }
  84   if (double_inspect.IsNan()) {
  85     if (nan_symbol_ == NULL) return false;
  86     result_builder-&gt;AddString(nan_symbol_);
  87     return true;
  88   }
  89   return false;
  90 }
  91 
  92 
  93 void DoubleToStringConverter::CreateExponentialRepresentation(
  94     const char* decimal_digits,
  95     int length,
  96     int exponent,
  97     StringBuilder* result_builder) const {
  98   ASSERT(length != 0);
  99   result_builder-&gt;AddCharacter(decimal_digits[0]);
 100   if (length != 1) {
 101     result_builder-&gt;AddCharacter(&#39;.&#39;);
 102     result_builder-&gt;AddSubstring(&amp;decimal_digits[1], length-1);
 103   }
 104   result_builder-&gt;AddCharacter(exponent_character_);
 105   if (exponent &lt; 0) {
 106     result_builder-&gt;AddCharacter(&#39;-&#39;);
 107     exponent = -exponent;
 108   } else {
 109     if ((flags_ &amp; EMIT_POSITIVE_EXPONENT_SIGN) != 0) {
 110       result_builder-&gt;AddCharacter(&#39;+&#39;);
 111     }
 112   }
 113   if (exponent == 0) {
 114     result_builder-&gt;AddCharacter(&#39;0&#39;);
 115     return;
 116   }
 117   ASSERT(exponent &lt; 1e4);
 118   const int kMaxExponentLength = 5;
 119   char buffer[kMaxExponentLength + 1];
 120   buffer[kMaxExponentLength] = &#39;\0&#39;;
 121   int first_char_pos = kMaxExponentLength;
 122   while (exponent &gt; 0) {
 123     buffer[--first_char_pos] = &#39;0&#39; + (exponent % 10);
 124     exponent /= 10;
 125   }
 126   result_builder-&gt;AddSubstring(&amp;buffer[first_char_pos],
 127                                kMaxExponentLength - first_char_pos);
 128 }
 129 
 130 
 131 void DoubleToStringConverter::CreateDecimalRepresentation(
 132     const char* decimal_digits,
 133     int length,
 134     int decimal_point,
 135     int digits_after_point,
 136     StringBuilder* result_builder) const {
 137   // Create a representation that is padded with zeros if needed.
 138   if (decimal_point &lt;= 0) {
 139       // &quot;0.00000decimal_rep&quot; or &quot;0.000decimal_rep00&quot;.
 140     result_builder-&gt;AddCharacter(&#39;0&#39;);
 141     if (digits_after_point &gt; 0) {
 142       result_builder-&gt;AddCharacter(&#39;.&#39;);
 143       result_builder-&gt;AddPadding(&#39;0&#39;, -decimal_point);
 144       ASSERT(length &lt;= digits_after_point - (-decimal_point));
 145       result_builder-&gt;AddSubstring(decimal_digits, length);
 146       int remaining_digits = digits_after_point - (-decimal_point) - length;
 147       result_builder-&gt;AddPadding(&#39;0&#39;, remaining_digits);
 148     }
 149   } else if (decimal_point &gt;= length) {
 150     // &quot;decimal_rep0000.00000&quot; or &quot;decimal_rep.0000&quot;.
 151     result_builder-&gt;AddSubstring(decimal_digits, length);
 152     result_builder-&gt;AddPadding(&#39;0&#39;, decimal_point - length);
 153     if (digits_after_point &gt; 0) {
 154       result_builder-&gt;AddCharacter(&#39;.&#39;);
 155       result_builder-&gt;AddPadding(&#39;0&#39;, digits_after_point);
 156     }
 157   } else {
 158     // &quot;decima.l_rep000&quot;.
 159     ASSERT(digits_after_point &gt; 0);
 160     result_builder-&gt;AddSubstring(decimal_digits, decimal_point);
 161     result_builder-&gt;AddCharacter(&#39;.&#39;);
 162     ASSERT(length - decimal_point &lt;= digits_after_point);
 163     result_builder-&gt;AddSubstring(&amp;decimal_digits[decimal_point],
 164                                  length - decimal_point);
 165     int remaining_digits = digits_after_point - (length - decimal_point);
 166     result_builder-&gt;AddPadding(&#39;0&#39;, remaining_digits);
 167   }
 168   if (digits_after_point == 0) {
 169     if ((flags_ &amp; EMIT_TRAILING_DECIMAL_POINT) != 0) {
 170       result_builder-&gt;AddCharacter(&#39;.&#39;);
 171     }
 172     if ((flags_ &amp; EMIT_TRAILING_ZERO_AFTER_POINT) != 0) {
 173       result_builder-&gt;AddCharacter(&#39;0&#39;);
 174     }
 175   }
 176 }
 177 
 178 
 179 bool DoubleToStringConverter::ToShortestIeeeNumber(
 180     double value,
 181     StringBuilder* result_builder,
 182     DoubleToStringConverter::DtoaMode mode) const {
 183   ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE);
 184   if (Double(value).IsSpecial()) {
 185     return HandleSpecialValues(value, result_builder);
 186   }
 187 
 188   int decimal_point;
 189   bool sign;
 190   const int kDecimalRepCapacity = kBase10MaximalLength + 1;
 191   char decimal_rep[kDecimalRepCapacity];
 192   int decimal_rep_length;
 193 
 194   DoubleToAscii(value, mode, 0, decimal_rep, kDecimalRepCapacity,
 195                 &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
 196 
 197   bool unique_zero = (flags_ &amp; UNIQUE_ZERO) != 0;
 198   if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {
 199     result_builder-&gt;AddCharacter(&#39;-&#39;);
 200   }
 201 
 202   int exponent = decimal_point - 1;
 203   if ((decimal_in_shortest_low_ &lt;= exponent) &amp;&amp;
 204       (exponent &lt; decimal_in_shortest_high_)) {
 205     CreateDecimalRepresentation(decimal_rep, decimal_rep_length,
 206                                 decimal_point,
 207                                 Max(0, decimal_rep_length - decimal_point),
 208                                 result_builder);
 209   } else {
 210     CreateExponentialRepresentation(decimal_rep, decimal_rep_length, exponent,
 211                                     result_builder);
 212   }
 213   return true;
 214 }
 215 
 216 
 217 bool DoubleToStringConverter::ToFixed(double value,
 218                                       int requested_digits,
 219                                       StringBuilder* result_builder) const {
 220   ASSERT(kMaxFixedDigitsBeforePoint == 60);
 221   const double kFirstNonFixed = 1e60;
 222 
 223   if (Double(value).IsSpecial()) {
 224     return HandleSpecialValues(value, result_builder);
 225   }
 226 
 227   if (requested_digits &gt; kMaxFixedDigitsAfterPoint) return false;
 228   if (value &gt;= kFirstNonFixed || value &lt;= -kFirstNonFixed) return false;
 229 
 230   // Find a sufficiently precise decimal representation of n.
 231   int decimal_point;
 232   bool sign;
 233   // Add space for the &#39;\0&#39; byte.
 234   const int kDecimalRepCapacity =
 235       kMaxFixedDigitsBeforePoint + kMaxFixedDigitsAfterPoint + 1;
 236   char decimal_rep[kDecimalRepCapacity];
 237   int decimal_rep_length;
 238   DoubleToAscii(value, FIXED, requested_digits,
 239                 decimal_rep, kDecimalRepCapacity,
 240                 &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
 241 
 242   bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);
 243   if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {
 244     result_builder-&gt;AddCharacter(&#39;-&#39;);
 245   }
 246 
 247   CreateDecimalRepresentation(decimal_rep, decimal_rep_length, decimal_point,
 248                               requested_digits, result_builder);
 249   return true;
 250 }
 251 
 252 
 253 bool DoubleToStringConverter::ToExponential(
 254     double value,
 255     int requested_digits,
 256     StringBuilder* result_builder) const {
 257   if (Double(value).IsSpecial()) {
 258     return HandleSpecialValues(value, result_builder);
 259   }
 260 
 261   if (requested_digits &lt; -1) return false;
 262   if (requested_digits &gt; kMaxExponentialDigits) return false;
 263 
 264   int decimal_point;
 265   bool sign;
 266   // Add space for digit before the decimal point and the &#39;\0&#39; character.
 267   const int kDecimalRepCapacity = kMaxExponentialDigits + 2;
 268   ASSERT(kDecimalRepCapacity &gt; kBase10MaximalLength);
 269   char decimal_rep[kDecimalRepCapacity];
 270   int decimal_rep_length;
 271 
 272   if (requested_digits == -1) {
 273     DoubleToAscii(value, SHORTEST, 0,
 274                   decimal_rep, kDecimalRepCapacity,
 275                   &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
 276   } else {
 277     DoubleToAscii(value, PRECISION, requested_digits + 1,
 278                   decimal_rep, kDecimalRepCapacity,
 279                   &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
 280     ASSERT(decimal_rep_length &lt;= requested_digits + 1);
 281 
 282     for (int i = decimal_rep_length; i &lt; requested_digits + 1; ++i) {
 283       decimal_rep[i] = &#39;0&#39;;
 284     }
 285     decimal_rep_length = requested_digits + 1;
 286   }
 287 
 288   bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);
 289   if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {
 290     result_builder-&gt;AddCharacter(&#39;-&#39;);
 291   }
 292 
 293   int exponent = decimal_point - 1;
 294   CreateExponentialRepresentation(decimal_rep,
 295                                   decimal_rep_length,
 296                                   exponent,
 297                                   result_builder);
 298   return true;
 299 }
 300 
 301 
 302 bool DoubleToStringConverter::ToPrecision(double value,
 303                                           int precision,
 304                                           StringBuilder* result_builder) const {
 305   if (Double(value).IsSpecial()) {
 306     return HandleSpecialValues(value, result_builder);
 307   }
 308 
 309   if (precision &lt; kMinPrecisionDigits || precision &gt; kMaxPrecisionDigits) {
 310     return false;
 311   }
 312 
 313   // Find a sufficiently precise decimal representation of n.
 314   int decimal_point;
 315   bool sign;
 316   // Add one for the terminating null character.
 317   const int kDecimalRepCapacity = kMaxPrecisionDigits + 1;
 318   char decimal_rep[kDecimalRepCapacity];
 319   int decimal_rep_length;
 320 
 321   DoubleToAscii(value, PRECISION, precision,
 322                 decimal_rep, kDecimalRepCapacity,
 323                 &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
 324   ASSERT(decimal_rep_length &lt;= precision);
 325 
 326   bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);
 327   if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {
 328     result_builder-&gt;AddCharacter(&#39;-&#39;);
 329   }
 330 
 331   // The exponent if we print the number as x.xxeyyy. That is with the
 332   // decimal point after the first digit.
 333   int exponent = decimal_point - 1;
 334 
 335   int extra_zero = ((flags_ &amp; EMIT_TRAILING_ZERO_AFTER_POINT) != 0) ? 1 : 0;
 336   if ((-decimal_point + 1 &gt; max_leading_padding_zeroes_in_precision_mode_) ||
 337       (decimal_point - precision + extra_zero &gt;
 338        max_trailing_padding_zeroes_in_precision_mode_)) {
 339     // Fill buffer to contain &#39;precision&#39; digits.
 340     // Usually the buffer is already at the correct length, but &#39;DoubleToAscii&#39;
 341     // is allowed to return less characters.
 342     for (int i = decimal_rep_length; i &lt; precision; ++i) {
 343       decimal_rep[i] = &#39;0&#39;;
 344     }
 345 
 346     CreateExponentialRepresentation(decimal_rep,
 347                                     precision,
 348                                     exponent,
 349                                     result_builder);
 350   } else {
 351     CreateDecimalRepresentation(decimal_rep, decimal_rep_length, decimal_point,
 352                                 Max(0, precision - decimal_point),
 353                                 result_builder);
 354   }
 355   return true;
 356 }
 357 #endif // not needed for ICU
 358 
 359 
 360 static BignumDtoaMode DtoaToBignumDtoaMode(
 361     DoubleToStringConverter::DtoaMode dtoa_mode) {
 362   switch (dtoa_mode) {
 363     case DoubleToStringConverter::SHORTEST:  return BIGNUM_DTOA_SHORTEST;
 364     case DoubleToStringConverter::SHORTEST_SINGLE:
 365         return BIGNUM_DTOA_SHORTEST_SINGLE;
 366     case DoubleToStringConverter::FIXED:     return BIGNUM_DTOA_FIXED;
 367     case DoubleToStringConverter::PRECISION: return BIGNUM_DTOA_PRECISION;
 368     default:
 369       UNREACHABLE();
 370   }
 371 }
 372 
 373 
 374 void DoubleToStringConverter::DoubleToAscii(double v,
 375                                             DtoaMode mode,
 376                                             int requested_digits,
 377                                             char* buffer,
 378                                             int buffer_length,
 379                                             bool* sign,
 380                                             int* length,
 381                                             int* point) {
 382   Vector&lt;char&gt; vector(buffer, buffer_length);
 383   ASSERT(!Double(v).IsSpecial());
 384   ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE || requested_digits &gt;= 0);
 385 
 386   if (Double(v).Sign() &lt; 0) {
 387     *sign = true;
 388     v = -v;
 389   } else {
 390     *sign = false;
 391   }
 392 
 393   if (mode == PRECISION &amp;&amp; requested_digits == 0) {
 394     vector[0] = &#39;\0&#39;;
 395     *length = 0;
 396     return;
 397   }
 398 
 399   if (v == 0) {
 400     vector[0] = &#39;0&#39;;
 401     vector[1] = &#39;\0&#39;;
 402     *length = 1;
 403     *point = 1;
 404     return;
 405   }
 406 
 407   bool fast_worked;
 408   switch (mode) {
 409     case SHORTEST:
 410       fast_worked = FastDtoa(v, FAST_DTOA_SHORTEST, 0, vector, length, point);
 411       break;
 412 #if 0 // not needed for ICU
 413     case SHORTEST_SINGLE:
 414       fast_worked = FastDtoa(v, FAST_DTOA_SHORTEST_SINGLE, 0,
 415                              vector, length, point);
 416       break;
 417     case FIXED:
 418       fast_worked = FastFixedDtoa(v, requested_digits, vector, length, point);
 419       break;
 420     case PRECISION:
 421       fast_worked = FastDtoa(v, FAST_DTOA_PRECISION, requested_digits,
 422                              vector, length, point);
 423       break;
 424 #endif // not needed for ICU
 425     default:
 426       fast_worked = false;
 427       UNREACHABLE();
 428   }
 429   if (fast_worked) return;
 430 
 431   // If the fast dtoa didn&#39;t succeed use the slower bignum version.
 432   BignumDtoaMode bignum_mode = DtoaToBignumDtoaMode(mode);
 433   BignumDtoa(v, bignum_mode, requested_digits, vector, length, point);
 434   vector[*length] = &#39;\0&#39;;
 435 }
 436 
 437 
<a name="2" id="anc2"></a><span class="line-added"> 438 namespace {</span>
<span class="line-added"> 439 </span>
<span class="line-added"> 440 inline char ToLower(char ch) {</span>
<span class="line-added"> 441 #if 0  // do not include std::locale in ICU</span>
<span class="line-added"> 442   static const std::ctype&lt;char&gt;&amp; cType =</span>
<span class="line-added"> 443       std::use_facet&lt;std::ctype&lt;char&gt; &gt;(std::locale::classic());</span>
<span class="line-added"> 444   return cType.tolower(ch);</span>
<span class="line-added"> 445 #else</span>
<span class="line-added"> 446   (void)ch;</span>
<span class="line-added"> 447   UNREACHABLE();</span>
<span class="line-added"> 448 #endif</span>
<span class="line-added"> 449 }</span>
<span class="line-added"> 450 </span>
<span class="line-added"> 451 inline char Pass(char ch) {</span>
<span class="line-added"> 452   return ch;</span>
<span class="line-added"> 453 }</span>
<span class="line-added"> 454 </span>
<span class="line-added"> 455 template &lt;class Iterator, class Converter&gt;</span>
<span class="line-added"> 456 static inline bool ConsumeSubStringImpl(Iterator* current,</span>
<span class="line-added"> 457                                         Iterator end,</span>
<span class="line-added"> 458                                         const char* substring,</span>
<span class="line-added"> 459                                         Converter converter) {</span>
<span class="line-added"> 460   ASSERT(converter(**current) == *substring);</span>
<span class="line-added"> 461   for (substring++; *substring != &#39;\0&#39;; substring++) {</span>
<span class="line-added"> 462     ++*current;</span>
<span class="line-added"> 463     if (*current == end || converter(**current) != *substring) {</span>
<span class="line-added"> 464       return false;</span>
<span class="line-added"> 465     }</span>
<span class="line-added"> 466   }</span>
<span class="line-added"> 467   ++*current;</span>
<span class="line-added"> 468   return true;</span>
<span class="line-added"> 469 }</span>
<span class="line-added"> 470 </span>
 471 // Consumes the given substring from the iterator.
 472 // Returns false, if the substring does not match.
 473 template &lt;class Iterator&gt;
 474 static bool ConsumeSubString(Iterator* current,
 475                              Iterator end,
<a name="3" id="anc3"></a><span class="line-modified"> 476                              const char* substring,</span>
<span class="line-modified"> 477                              bool allow_case_insensibility) {</span>
<span class="line-modified"> 478   if (allow_case_insensibility) {</span>
<span class="line-modified"> 479     return ConsumeSubStringImpl(current, end, substring, ToLower);</span>
<span class="line-modified"> 480   } else {</span>
<span class="line-added"> 481     return ConsumeSubStringImpl(current, end, substring, Pass);</span>
 482   }
<a name="4" id="anc4"></a>

 483 }
 484 
<a name="5" id="anc5"></a><span class="line-added"> 485 // Consumes first character of the str is equal to ch</span>
<span class="line-added"> 486 inline bool ConsumeFirstCharacter(char ch,</span>
<span class="line-added"> 487                                          const char* str,</span>
<span class="line-added"> 488                                          bool case_insensibility) {</span>
<span class="line-added"> 489   return case_insensibility ? ToLower(ch) == str[0] : ch == str[0];</span>
<span class="line-added"> 490 }</span>
<span class="line-added"> 491 }  // namespace</span>
 492 
 493 // Maximum number of significant digits in decimal representation.
 494 // The longest possible double in decimal representation is
 495 // (2^53 - 1) * 2 ^ -1074 that is (2 ^ 53 - 1) * 5 ^ 1074 / 10 ^ 1074
 496 // (768 digits). If we parse a number whose first digits are equal to a
 497 // mean of 2 adjacent doubles (that could have up to 769 digits) the result
 498 // must be rounded to the bigger one unless the tail consists of zeros, so
 499 // we don&#39;t need to preserve all the digits.
 500 const int kMaxSignificantDigits = 772;
 501 
 502 
 503 static const char kWhitespaceTable7[] = { 32, 13, 10, 9, 11, 12 };
 504 static const int kWhitespaceTable7Length = ARRAY_SIZE(kWhitespaceTable7);
 505 
 506 
 507 static const uc16 kWhitespaceTable16[] = {
 508   160, 8232, 8233, 5760, 6158, 8192, 8193, 8194, 8195,
 509   8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279
 510 };
 511 static const int kWhitespaceTable16Length = ARRAY_SIZE(kWhitespaceTable16);
 512 
 513 
 514 
 515 static bool isWhitespace(int x) {
 516   if (x &lt; 128) {
 517     for (int i = 0; i &lt; kWhitespaceTable7Length; i++) {
 518       if (kWhitespaceTable7[i] == x) return true;
 519     }
 520   } else {
 521     for (int i = 0; i &lt; kWhitespaceTable16Length; i++) {
 522       if (kWhitespaceTable16[i] == x) return true;
 523     }
 524   }
 525   return false;
 526 }
 527 
 528 
 529 // Returns true if a nonspace found and false if the end has reached.
 530 template &lt;class Iterator&gt;
 531 static inline bool AdvanceToNonspace(Iterator* current, Iterator end) {
 532   while (*current != end) {
 533     if (!isWhitespace(**current)) return true;
 534     ++*current;
 535   }
 536   return false;
 537 }
 538 
 539 
 540 static bool isDigit(int x, int radix) {
 541   return (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39; &amp;&amp; x &lt; &#39;0&#39; + radix)
 542       || (radix &gt; 10 &amp;&amp; x &gt;= &#39;a&#39; &amp;&amp; x &lt; &#39;a&#39; + radix - 10)
 543       || (radix &gt; 10 &amp;&amp; x &gt;= &#39;A&#39; &amp;&amp; x &lt; &#39;A&#39; + radix - 10);
 544 }
 545 
 546 
 547 static double SignedZero(bool sign) {
 548   return sign ? -0.0 : 0.0;
 549 }
 550 
 551 
 552 // Returns true if &#39;c&#39; is a decimal digit that is valid for the given radix.
 553 //
 554 // The function is small and could be inlined, but VS2012 emitted a warning
 555 // because it constant-propagated the radix and concluded that the last
 556 // condition was always true. By moving it into a separate function the
 557 // compiler wouldn&#39;t warn anymore.
<a name="6" id="anc6"></a><span class="line-modified"> 558 #ifdef _MSC_VER</span>
 559 #pragma optimize(&quot;&quot;,off)
 560 static bool IsDecimalDigitForRadix(int c, int radix) {
 561   return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39; &amp;&amp; (c - &#39;0&#39;) &lt; radix;
 562 }
 563 #pragma optimize(&quot;&quot;,on)
 564 #else
 565 static bool inline IsDecimalDigitForRadix(int c, int radix) {
<a name="7" id="anc7"></a><span class="line-modified"> 566   return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39; &amp;&amp; (c - &#39;0&#39;) &lt; radix;</span>
 567 }
 568 #endif
 569 // Returns true if &#39;c&#39; is a character digit that is valid for the given radix.
 570 // The &#39;a_character&#39; should be &#39;a&#39; or &#39;A&#39;.
 571 //
 572 // The function is small and could be inlined, but VS2012 emitted a warning
 573 // because it constant-propagated the radix and concluded that the first
 574 // condition was always false. By moving it into a separate function the
 575 // compiler wouldn&#39;t warn anymore.
 576 static bool IsCharacterDigitForRadix(int c, int radix, char a_character) {
 577   return radix &gt; 10 &amp;&amp; c &gt;= a_character &amp;&amp; c &lt; a_character + radix - 10;
 578 }
 579 
<a name="8" id="anc8"></a><span class="line-added"> 580 // Returns true, when the iterator is equal to end.</span>
<span class="line-added"> 581 template&lt;class Iterator&gt;</span>
<span class="line-added"> 582 static bool Advance (Iterator* it, uc16 separator, int base, Iterator&amp; end) {</span>
<span class="line-added"> 583   if (separator == StringToDoubleConverter::kNoSeparator) {</span>
<span class="line-added"> 584     ++(*it);</span>
<span class="line-added"> 585     return *it == end;</span>
<span class="line-added"> 586   }</span>
<span class="line-added"> 587   if (!isDigit(**it, base)) {</span>
<span class="line-added"> 588     ++(*it);</span>
<span class="line-added"> 589     return *it == end;</span>
<span class="line-added"> 590   }</span>
<span class="line-added"> 591   ++(*it);</span>
<span class="line-added"> 592   if (*it == end) return true;</span>
<span class="line-added"> 593   if (*it + 1 == end) return false;</span>
<span class="line-added"> 594   if (**it == separator &amp;&amp; isDigit(*(*it + 1), base)) {</span>
<span class="line-added"> 595     ++(*it);</span>
<span class="line-added"> 596   }</span>
<span class="line-added"> 597   return *it == end;</span>
<span class="line-added"> 598 }</span>
<span class="line-added"> 599 </span>
<span class="line-added"> 600 // Checks whether the string in the range start-end is a hex-float string.</span>
<span class="line-added"> 601 // This function assumes that the leading &#39;0x&#39;/&#39;0X&#39; is already consumed.</span>
<span class="line-added"> 602 //</span>
<span class="line-added"> 603 // Hex float strings are of one of the following forms:</span>
<span class="line-added"> 604 //   - hex_digits+ &#39;p&#39; (&#39;+&#39;|&#39;-&#39;)? exponent_digits+</span>
<span class="line-added"> 605 //   - hex_digits* &#39;.&#39; hex_digits+ &#39;p&#39; (&#39;+&#39;|&#39;-&#39;)? exponent_digits+</span>
<span class="line-added"> 606 //   - hex_digits+ &#39;.&#39; &#39;p&#39; (&#39;+&#39;|&#39;-&#39;)? exponent_digits+</span>
<span class="line-added"> 607 template&lt;class Iterator&gt;</span>
<span class="line-added"> 608 static bool IsHexFloatString(Iterator start,</span>
<span class="line-added"> 609                              Iterator end,</span>
<span class="line-added"> 610                              uc16 separator,</span>
<span class="line-added"> 611                              bool allow_trailing_junk) {</span>
<span class="line-added"> 612   ASSERT(start != end);</span>
<span class="line-added"> 613 </span>
<span class="line-added"> 614   Iterator current = start;</span>
<span class="line-added"> 615 </span>
<span class="line-added"> 616   bool saw_digit = false;</span>
<span class="line-added"> 617   while (isDigit(*current, 16)) {</span>
<span class="line-added"> 618     saw_digit = true;</span>
<span class="line-added"> 619     if (Advance(&amp;current, separator, 16, end)) return false;</span>
<span class="line-added"> 620   }</span>
<span class="line-added"> 621   if (*current == &#39;.&#39;) {</span>
<span class="line-added"> 622     if (Advance(&amp;current, separator, 16, end)) return false;</span>
<span class="line-added"> 623     while (isDigit(*current, 16)) {</span>
<span class="line-added"> 624       saw_digit = true;</span>
<span class="line-added"> 625       if (Advance(&amp;current, separator, 16, end)) return false;</span>
<span class="line-added"> 626     }</span>
<span class="line-added"> 627     if (!saw_digit) return false;  // Only the &#39;.&#39;, but no digits.</span>
<span class="line-added"> 628   }</span>
<span class="line-added"> 629   if (*current != &#39;p&#39; &amp;&amp; *current != &#39;P&#39;) return false;</span>
<span class="line-added"> 630   if (Advance(&amp;current, separator, 16, end)) return false;</span>
<span class="line-added"> 631   if (*current == &#39;+&#39; || *current == &#39;-&#39;) {</span>
<span class="line-added"> 632     if (Advance(&amp;current, separator, 16, end)) return false;</span>
<span class="line-added"> 633   }</span>
<span class="line-added"> 634   if (!isDigit(*current, 10)) return false;</span>
<span class="line-added"> 635   if (Advance(&amp;current, separator, 16, end)) return true;</span>
<span class="line-added"> 636   while (isDigit(*current, 10)) {</span>
<span class="line-added"> 637     if (Advance(&amp;current, separator, 16, end)) return true;</span>
<span class="line-added"> 638   }</span>
<span class="line-added"> 639   return allow_trailing_junk || !AdvanceToNonspace(&amp;current, end);</span>
<span class="line-added"> 640 }</span>
<span class="line-added"> 641 </span>
 642 
 643 // Parsing integers with radix 2, 4, 8, 16, 32. Assumes current != end.
<a name="9" id="anc9"></a><span class="line-added"> 644 //</span>
<span class="line-added"> 645 // If parse_as_hex_float is true, then the string must be a valid</span>
<span class="line-added"> 646 // hex-float.</span>
 647 template &lt;int radix_log_2, class Iterator&gt;
 648 static double RadixStringToIeee(Iterator* current,
 649                                 Iterator end,
 650                                 bool sign,
<a name="10" id="anc10"></a><span class="line-added"> 651                                 uc16 separator,</span>
<span class="line-added"> 652                                 bool parse_as_hex_float,</span>
 653                                 bool allow_trailing_junk,
 654                                 double junk_string_value,
 655                                 bool read_as_double,
 656                                 bool* result_is_junk) {
 657   ASSERT(*current != end);
<a name="11" id="anc11"></a><span class="line-added"> 658   ASSERT(!parse_as_hex_float ||</span>
<span class="line-added"> 659       IsHexFloatString(*current, end, separator, allow_trailing_junk));</span>
 660 
 661   const int kDoubleSize = Double::kSignificandSize;
 662   const int kSingleSize = Single::kSignificandSize;
 663   const int kSignificandSize = read_as_double? kDoubleSize: kSingleSize;
 664 
 665   *result_is_junk = true;
 666 
<a name="12" id="anc12"></a><span class="line-added"> 667   int64_t number = 0;</span>
<span class="line-added"> 668   int exponent = 0;</span>
<span class="line-added"> 669   const int radix = (1 &lt;&lt; radix_log_2);</span>
<span class="line-added"> 670   // Whether we have encountered a &#39;.&#39; and are parsing the decimal digits.</span>
<span class="line-added"> 671   // Only relevant if parse_as_hex_float is true.</span>
<span class="line-added"> 672   bool post_decimal = false;</span>
<span class="line-added"> 673 </span>
 674   // Skip leading 0s.
 675   while (**current == &#39;0&#39;) {
<a name="13" id="anc13"></a><span class="line-modified"> 676     if (Advance(current, separator, radix, end)) {</span>

 677       *result_is_junk = false;
 678       return SignedZero(sign);
 679     }
 680   }
 681 
<a name="14" id="anc14"></a><span class="line-modified"> 682   while (true) {</span>




 683     int digit;
 684     if (IsDecimalDigitForRadix(**current, radix)) {
 685       digit = static_cast&lt;char&gt;(**current) - &#39;0&#39;;
<a name="15" id="anc15"></a><span class="line-added"> 686       if (post_decimal) exponent -= radix_log_2;</span>
 687     } else if (IsCharacterDigitForRadix(**current, radix, &#39;a&#39;)) {
 688       digit = static_cast&lt;char&gt;(**current) - &#39;a&#39; + 10;
<a name="16" id="anc16"></a><span class="line-added"> 689       if (post_decimal) exponent -= radix_log_2;</span>
 690     } else if (IsCharacterDigitForRadix(**current, radix, &#39;A&#39;)) {
 691       digit = static_cast&lt;char&gt;(**current) - &#39;A&#39; + 10;
<a name="17" id="anc17"></a><span class="line-added"> 692       if (post_decimal) exponent -= radix_log_2;</span>
<span class="line-added"> 693     } else if (parse_as_hex_float &amp;&amp; **current == &#39;.&#39;) {</span>
<span class="line-added"> 694       post_decimal = true;</span>
<span class="line-added"> 695       Advance(current, separator, radix, end);</span>
<span class="line-added"> 696       ASSERT(*current != end);</span>
<span class="line-added"> 697       continue;</span>
<span class="line-added"> 698     } else if (parse_as_hex_float &amp;&amp; (**current == &#39;p&#39; || **current == &#39;P&#39;)) {</span>
<span class="line-added"> 699       break;</span>
 700     } else {
 701       if (allow_trailing_junk || !AdvanceToNonspace(current, end)) {
 702         break;
 703       } else {
 704         return junk_string_value;
 705       }
 706     }
 707 
 708     number = number * radix + digit;
 709     int overflow = static_cast&lt;int&gt;(number &gt;&gt; kSignificandSize);
 710     if (overflow != 0) {
 711       // Overflow occurred. Need to determine which direction to round the
 712       // result.
 713       int overflow_bits_count = 1;
 714       while (overflow &gt; 1) {
 715         overflow_bits_count++;
 716         overflow &gt;&gt;= 1;
 717       }
 718 
 719       int dropped_bits_mask = ((1 &lt;&lt; overflow_bits_count) - 1);
 720       int dropped_bits = static_cast&lt;int&gt;(number) &amp; dropped_bits_mask;
 721       number &gt;&gt;= overflow_bits_count;
<a name="18" id="anc18"></a><span class="line-modified"> 722       exponent += overflow_bits_count;</span>
 723 
 724       bool zero_tail = true;
 725       for (;;) {
<a name="19" id="anc19"></a><span class="line-modified"> 726         if (Advance(current, separator, radix, end)) break;</span>
<span class="line-modified"> 727         if (parse_as_hex_float &amp;&amp; **current == &#39;.&#39;) {</span>
<span class="line-added"> 728           // Just run over the &#39;.&#39;. We are just trying to see whether there is</span>
<span class="line-added"> 729           // a non-zero digit somewhere.</span>
<span class="line-added"> 730           Advance(current, separator, radix, end);</span>
<span class="line-added"> 731           ASSERT(*current != end);</span>
<span class="line-added"> 732           post_decimal = true;</span>
<span class="line-added"> 733         }</span>
<span class="line-added"> 734         if (!isDigit(**current, radix)) break;</span>
 735         zero_tail = zero_tail &amp;&amp; **current == &#39;0&#39;;
<a name="20" id="anc20"></a><span class="line-modified"> 736         if (!post_decimal) exponent += radix_log_2;</span>
 737       }
 738 
<a name="21" id="anc21"></a><span class="line-modified"> 739       if (!parse_as_hex_float &amp;&amp;</span>
<span class="line-added"> 740           !allow_trailing_junk &amp;&amp;</span>
<span class="line-added"> 741           AdvanceToNonspace(current, end)) {</span>
 742         return junk_string_value;
 743       }
 744 
 745       int middle_value = (1 &lt;&lt; (overflow_bits_count - 1));
 746       if (dropped_bits &gt; middle_value) {
 747         number++;  // Rounding up.
 748       } else if (dropped_bits == middle_value) {
 749         // Rounding to even to consistency with decimals: half-way case rounds
 750         // up if significant part is odd and down otherwise.
 751         if ((number &amp; 1) != 0 || !zero_tail) {
 752           number++;  // Rounding up.
 753         }
 754       }
 755 
 756       // Rounding up may cause overflow.
 757       if ((number &amp; ((int64_t)1 &lt;&lt; kSignificandSize)) != 0) {
 758         exponent++;
 759         number &gt;&gt;= 1;
 760       }
 761       break;
 762     }
<a name="22" id="anc22"></a><span class="line-modified"> 763     if (Advance(current, separator, radix, end)) break;</span>
<span class="line-modified"> 764   }</span>
 765 
 766   ASSERT(number &lt; ((int64_t)1 &lt;&lt; kSignificandSize));
 767   ASSERT(static_cast&lt;int64_t&gt;(static_cast&lt;double&gt;(number)) == number);
 768 
 769   *result_is_junk = false;
 770 
<a name="23" id="anc23"></a><span class="line-modified"> 771   if (parse_as_hex_float) {</span>
<span class="line-added"> 772     ASSERT(**current == &#39;p&#39; || **current == &#39;P&#39;);</span>
<span class="line-added"> 773     Advance(current, separator, radix, end);</span>
<span class="line-added"> 774     ASSERT(*current != end);</span>
<span class="line-added"> 775     bool is_negative = false;</span>
<span class="line-added"> 776     if (**current == &#39;+&#39;) {</span>
<span class="line-added"> 777       Advance(current, separator, radix, end);</span>
<span class="line-added"> 778       ASSERT(*current != end);</span>
<span class="line-added"> 779     } else if (**current == &#39;-&#39;) {</span>
<span class="line-added"> 780       is_negative = true;</span>
<span class="line-added"> 781       Advance(current, separator, radix, end);</span>
<span class="line-added"> 782       ASSERT(*current != end);</span>
<span class="line-added"> 783     }</span>
<span class="line-added"> 784     int written_exponent = 0;</span>
<span class="line-added"> 785     while (IsDecimalDigitForRadix(**current, 10)) {</span>
<span class="line-added"> 786       written_exponent = 10 * written_exponent + **current - &#39;0&#39;;</span>
<span class="line-added"> 787       if (Advance(current, separator, radix, end)) break;</span>
<span class="line-added"> 788     }</span>
<span class="line-added"> 789     if (is_negative) written_exponent = -written_exponent;</span>
<span class="line-added"> 790     exponent += written_exponent;</span>
<span class="line-added"> 791   }</span>
<span class="line-added"> 792 </span>
<span class="line-added"> 793   if (exponent == 0 || number == 0) {</span>
 794     if (sign) {
 795       if (number == 0) return -0.0;
 796       number = -number;
 797     }
 798     return static_cast&lt;double&gt;(number);
 799   }
 800 
 801   ASSERT(number != 0);
<a name="24" id="anc24"></a><span class="line-modified"> 802   double result = Double(DiyFp(number, exponent)).value();</span>
<span class="line-added"> 803   return sign ? -result : result;</span>
 804 }
 805 
 806 template &lt;class Iterator&gt;
 807 double StringToDoubleConverter::StringToIeee(
 808     Iterator input,
 809     int length,
 810     bool read_as_double,
 811     int* processed_characters_count) const {
 812   Iterator current = input;
 813   Iterator end = input + length;
 814 
 815   *processed_characters_count = 0;
 816 
 817   const bool allow_trailing_junk = (flags_ &amp; ALLOW_TRAILING_JUNK) != 0;
 818   const bool allow_leading_spaces = (flags_ &amp; ALLOW_LEADING_SPACES) != 0;
 819   const bool allow_trailing_spaces = (flags_ &amp; ALLOW_TRAILING_SPACES) != 0;
 820   const bool allow_spaces_after_sign = (flags_ &amp; ALLOW_SPACES_AFTER_SIGN) != 0;
<a name="25" id="anc25"></a><span class="line-added"> 821   const bool allow_case_insensibility = (flags_ &amp; ALLOW_CASE_INSENSIBILITY) != 0;</span>
 822 
 823   // To make sure that iterator dereferencing is valid the following
 824   // convention is used:
 825   // 1. Each &#39;++current&#39; statement is followed by check for equality to &#39;end&#39;.
 826   // 2. If AdvanceToNonspace returned false then current == end.
 827   // 3. If &#39;current&#39; becomes equal to &#39;end&#39; the function returns or goes to
 828   // &#39;parsing_done&#39;.
 829   // 4. &#39;current&#39; is not dereferenced after the &#39;parsing_done&#39; label.
 830   // 5. Code before &#39;parsing_done&#39; may rely on &#39;current != end&#39;.
 831   if (current == end) return empty_string_value_;
 832 
 833   if (allow_leading_spaces || allow_trailing_spaces) {
 834     if (!AdvanceToNonspace(&amp;current, end)) {
 835       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 836       return empty_string_value_;
 837     }
 838     if (!allow_leading_spaces &amp;&amp; (input != current)) {
 839       // No leading spaces allowed, but AdvanceToNonspace moved forward.
 840       return junk_string_value_;
 841     }
 842   }
 843 
 844   // The longest form of simplified number is: &quot;-&lt;significant digits&gt;.1eXXX\0&quot;.
 845   const int kBufferSize = kMaxSignificantDigits + 10;
 846   char buffer[kBufferSize];  // NOLINT: size is known at compile time.
 847   int buffer_pos = 0;
 848 
 849   // Exponent will be adjusted if insignificant digits of the integer part
 850   // or insignificant leading zeros of the fractional part are dropped.
 851   int exponent = 0;
 852   int significant_digits = 0;
 853   int insignificant_digits = 0;
 854   bool nonzero_digit_dropped = false;
 855 
 856   bool sign = false;
 857 
 858   if (*current == &#39;+&#39; || *current == &#39;-&#39;) {
 859     sign = (*current == &#39;-&#39;);
 860     ++current;
 861     Iterator next_non_space = current;
 862     // Skip following spaces (if allowed).
 863     if (!AdvanceToNonspace(&amp;next_non_space, end)) return junk_string_value_;
 864     if (!allow_spaces_after_sign &amp;&amp; (current != next_non_space)) {
 865       return junk_string_value_;
 866     }
 867     current = next_non_space;
 868   }
 869 
 870   if (infinity_symbol_ != NULL) {
<a name="26" id="anc26"></a><span class="line-modified"> 871     if (ConsumeFirstCharacter(*current, infinity_symbol_, allow_case_insensibility)) {</span>
<span class="line-modified"> 872       if (!ConsumeSubString(&amp;current, end, infinity_symbol_, allow_case_insensibility)) {</span>
 873         return junk_string_value_;
 874       }
 875 
 876       if (!(allow_trailing_spaces || allow_trailing_junk) &amp;&amp; (current != end)) {
 877         return junk_string_value_;
 878       }
 879       if (!allow_trailing_junk &amp;&amp; AdvanceToNonspace(&amp;current, end)) {
 880         return junk_string_value_;
 881       }
 882 
 883       ASSERT(buffer_pos == 0);
 884       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 885       return sign ? -Double::Infinity() : Double::Infinity();
 886     }
 887   }
 888 
 889   if (nan_symbol_ != NULL) {
<a name="27" id="anc27"></a><span class="line-modified"> 890     if (ConsumeFirstCharacter(*current, nan_symbol_, allow_case_insensibility)) {</span>
<span class="line-modified"> 891       if (!ConsumeSubString(&amp;current, end, nan_symbol_, allow_case_insensibility)) {</span>
 892         return junk_string_value_;
 893       }
 894 
 895       if (!(allow_trailing_spaces || allow_trailing_junk) &amp;&amp; (current != end)) {
 896         return junk_string_value_;
 897       }
 898       if (!allow_trailing_junk &amp;&amp; AdvanceToNonspace(&amp;current, end)) {
 899         return junk_string_value_;
 900       }
 901 
 902       ASSERT(buffer_pos == 0);
 903       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 904       return sign ? -Double::NaN() : Double::NaN();
 905     }
 906   }
 907 
 908   bool leading_zero = false;
 909   if (*current == &#39;0&#39;) {
<a name="28" id="anc28"></a><span class="line-modified"> 910     if (Advance(&amp;current, separator_, 10, end)) {</span>

 911       *processed_characters_count = static_cast&lt;int&gt;(current - input);
 912       return SignedZero(sign);
 913     }
 914 
 915     leading_zero = true;
 916 
 917     // It could be hexadecimal value.
<a name="29" id="anc29"></a><span class="line-modified"> 918     if (((flags_ &amp; ALLOW_HEX) || (flags_ &amp; ALLOW_HEX_FLOATS)) &amp;&amp;</span>
<span class="line-added"> 919         (*current == &#39;x&#39; || *current == &#39;X&#39;)) {</span>
 920       ++current;
<a name="30" id="anc30"></a><span class="line-modified"> 921 </span>
<span class="line-modified"> 922       bool parse_as_hex_float = (flags_ &amp; ALLOW_HEX_FLOATS) &amp;&amp;</span>
<span class="line-added"> 923                 IsHexFloatString(current, end, separator_, allow_trailing_junk);</span>
<span class="line-added"> 924 </span>
<span class="line-added"> 925       if (current == end) return junk_string_value_;  // &quot;0x&quot;</span>
<span class="line-added"> 926       if (!parse_as_hex_float &amp;&amp; !isDigit(*current, 16)) {</span>
<span class="line-added"> 927         return junk_string_value_;</span>
 928       }
 929 
 930       bool result_is_junk;
 931       double result = RadixStringToIeee&lt;4&gt;(&amp;current,
 932                                            end,
 933                                            sign,
<a name="31" id="anc31"></a><span class="line-added"> 934                                            separator_,</span>
<span class="line-added"> 935                                            parse_as_hex_float,</span>
 936                                            allow_trailing_junk,
 937                                            junk_string_value_,
 938                                            read_as_double,
 939                                            &amp;result_is_junk);
 940       if (!result_is_junk) {
 941         if (allow_trailing_spaces) AdvanceToNonspace(&amp;current, end);
 942         *processed_characters_count = static_cast&lt;int&gt;(current - input);
 943       }
 944       return result;
 945     }
 946 
 947     // Ignore leading zeros in the integer part.
 948     while (*current == &#39;0&#39;) {
<a name="32" id="anc32"></a><span class="line-modified"> 949       if (Advance(&amp;current, separator_, 10, end)) {</span>

 950         *processed_characters_count = static_cast&lt;int&gt;(current - input);
 951         return SignedZero(sign);
 952       }
 953     }
 954   }
 955 
 956   bool octal = leading_zero &amp;&amp; (flags_ &amp; ALLOW_OCTALS) != 0;
 957 
 958   // Copy significant digits of the integer part (if any) to the buffer.
 959   while (*current &gt;= &#39;0&#39; &amp;&amp; *current &lt;= &#39;9&#39;) {
 960     if (significant_digits &lt; kMaxSignificantDigits) {
 961       ASSERT(buffer_pos &lt; kBufferSize);
 962       buffer[buffer_pos++] = static_cast&lt;char&gt;(*current);
 963       significant_digits++;
 964       // Will later check if it&#39;s an octal in the buffer.
 965     } else {
 966       insignificant_digits++;  // Move the digit into the exponential part.
 967       nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;
 968     }
 969     octal = octal &amp;&amp; *current &lt; &#39;8&#39;;
<a name="33" id="anc33"></a><span class="line-modified"> 970     if (Advance(&amp;current, separator_, 10, end)) goto parsing_done;</span>

 971   }
 972 
 973   if (significant_digits == 0) {
 974     octal = false;
 975   }
 976 
 977   if (*current == &#39;.&#39;) {
 978     if (octal &amp;&amp; !allow_trailing_junk) return junk_string_value_;
 979     if (octal) goto parsing_done;
 980 
<a name="34" id="anc34"></a><span class="line-modified"> 981     if (Advance(&amp;current, separator_, 10, end)) {</span>

 982       if (significant_digits == 0 &amp;&amp; !leading_zero) {
 983         return junk_string_value_;
 984       } else {
 985         goto parsing_done;
 986       }
 987     }
 988 
 989     if (significant_digits == 0) {
 990       // octal = false;
 991       // Integer part consists of 0 or is absent. Significant digits start after
 992       // leading zeros (if any).
 993       while (*current == &#39;0&#39;) {
<a name="35" id="anc35"></a><span class="line-modified"> 994         if (Advance(&amp;current, separator_, 10, end)) {</span>

 995           *processed_characters_count = static_cast&lt;int&gt;(current - input);
 996           return SignedZero(sign);
 997         }
 998         exponent--;  // Move this 0 into the exponent.
 999       }
1000     }
1001 
1002     // There is a fractional part.
1003     // We don&#39;t emit a &#39;.&#39;, but adjust the exponent instead.
1004     while (*current &gt;= &#39;0&#39; &amp;&amp; *current &lt;= &#39;9&#39;) {
1005       if (significant_digits &lt; kMaxSignificantDigits) {
1006         ASSERT(buffer_pos &lt; kBufferSize);
1007         buffer[buffer_pos++] = static_cast&lt;char&gt;(*current);
1008         significant_digits++;
1009         exponent--;
1010       } else {
1011         // Ignore insignificant digits in the fractional part.
1012         nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;
1013       }
<a name="36" id="anc36"></a><span class="line-modified">1014       if (Advance(&amp;current, separator_, 10, end)) goto parsing_done;</span>

1015     }
1016   }
1017 
1018   if (!leading_zero &amp;&amp; exponent == 0 &amp;&amp; significant_digits == 0) {
1019     // If leading_zeros is true then the string contains zeros.
1020     // If exponent &lt; 0 then string was [+-]\.0*...
1021     // If significant_digits != 0 the string is not equal to 0.
1022     // Otherwise there are no digits in the string.
1023     return junk_string_value_;
1024   }
1025 
1026   // Parse exponential part.
1027   if (*current == &#39;e&#39; || *current == &#39;E&#39;) {
1028     if (octal &amp;&amp; !allow_trailing_junk) return junk_string_value_;
1029     if (octal) goto parsing_done;
<a name="37" id="anc37"></a><span class="line-added">1030     Iterator junk_begin = current;</span>
1031     ++current;
1032     if (current == end) {
1033       if (allow_trailing_junk) {
<a name="38" id="anc38"></a><span class="line-added">1034         current = junk_begin;</span>
1035         goto parsing_done;
1036       } else {
1037         return junk_string_value_;
1038       }
1039     }
1040     char exponen_sign = &#39;+&#39;;
1041     if (*current == &#39;+&#39; || *current == &#39;-&#39;) {
1042       exponen_sign = static_cast&lt;char&gt;(*current);
1043       ++current;
1044       if (current == end) {
1045         if (allow_trailing_junk) {
<a name="39" id="anc39"></a><span class="line-added">1046           current = junk_begin;</span>
1047           goto parsing_done;
1048         } else {
1049           return junk_string_value_;
1050         }
1051       }
1052     }
1053 
1054     if (current == end || *current &lt; &#39;0&#39; || *current &gt; &#39;9&#39;) {
1055       if (allow_trailing_junk) {
<a name="40" id="anc40"></a><span class="line-added">1056         current = junk_begin;</span>
1057         goto parsing_done;
1058       } else {
1059         return junk_string_value_;
1060       }
1061     }
1062 
1063     const int max_exponent = INT_MAX / 2;
1064     ASSERT(-max_exponent / 2 &lt;= exponent &amp;&amp; exponent &lt;= max_exponent / 2);
1065     int num = 0;
1066     do {
1067       // Check overflow.
1068       int digit = *current - &#39;0&#39;;
1069       if (num &gt;= max_exponent / 10
1070           &amp;&amp; !(num == max_exponent / 10 &amp;&amp; digit &lt;= max_exponent % 10)) {
1071         num = max_exponent;
1072       } else {
1073         num = num * 10 + digit;
1074       }
1075       ++current;
1076     } while (current != end &amp;&amp; *current &gt;= &#39;0&#39; &amp;&amp; *current &lt;= &#39;9&#39;);
1077 
1078     exponent += (exponen_sign == &#39;-&#39; ? -num : num);
1079   }
1080 
1081   if (!(allow_trailing_spaces || allow_trailing_junk) &amp;&amp; (current != end)) {
1082     return junk_string_value_;
1083   }
1084   if (!allow_trailing_junk &amp;&amp; AdvanceToNonspace(&amp;current, end)) {
1085     return junk_string_value_;
1086   }
1087   if (allow_trailing_spaces) {
1088     AdvanceToNonspace(&amp;current, end);
1089   }
1090 
1091   parsing_done:
1092   exponent += insignificant_digits;
1093 
1094   if (octal) {
1095     double result;
1096     bool result_is_junk;
1097     char* start = buffer;
1098     result = RadixStringToIeee&lt;3&gt;(&amp;start,
1099                                   buffer + buffer_pos,
1100                                   sign,
<a name="41" id="anc41"></a><span class="line-added">1101                                   separator_,</span>
<span class="line-added">1102                                   false, // Don&#39;t parse as hex_float.</span>
1103                                   allow_trailing_junk,
1104                                   junk_string_value_,
1105                                   read_as_double,
1106                                   &amp;result_is_junk);
1107     ASSERT(!result_is_junk);
1108     *processed_characters_count = static_cast&lt;int&gt;(current - input);
1109     return result;
1110   }
1111 
1112   if (nonzero_digit_dropped) {
1113     buffer[buffer_pos++] = &#39;1&#39;;
1114     exponent--;
1115   }
1116 
1117   ASSERT(buffer_pos &lt; kBufferSize);
1118   buffer[buffer_pos] = &#39;\0&#39;;
1119 
1120   double converted;
1121   if (read_as_double) {
1122     converted = Strtod(Vector&lt;const char&gt;(buffer, buffer_pos), exponent);
1123   } else {
1124     converted = Strtof(Vector&lt;const char&gt;(buffer, buffer_pos), exponent);
1125   }
1126   *processed_characters_count = static_cast&lt;int&gt;(current - input);
1127   return sign? -converted: converted;
1128 }
1129 
1130 
1131 double StringToDoubleConverter::StringToDouble(
1132     const char* buffer,
1133     int length,
1134     int* processed_characters_count) const {
1135   return StringToIeee(buffer, length, true, processed_characters_count);
1136 }
1137 
1138 
1139 double StringToDoubleConverter::StringToDouble(
1140     const uc16* buffer,
1141     int length,
1142     int* processed_characters_count) const {
1143   return StringToIeee(buffer, length, true, processed_characters_count);
1144 }
1145 
1146 
1147 float StringToDoubleConverter::StringToFloat(
1148     const char* buffer,
1149     int length,
1150     int* processed_characters_count) const {
1151   return static_cast&lt;float&gt;(StringToIeee(buffer, length, false,
1152                                          processed_characters_count));
1153 }
1154 
1155 
1156 float StringToDoubleConverter::StringToFloat(
1157     const uc16* buffer,
1158     int length,
1159     int* processed_characters_count) const {
1160   return static_cast&lt;float&gt;(StringToIeee(buffer, length, false,
1161                                          processed_characters_count));
1162 }
1163 
1164 }  // namespace double_conversion
1165 
1166 // ICU PATCH: Close ICU namespace
1167 U_NAMESPACE_END
1168 #endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING
<a name="42" id="anc42"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="42" type="hidden" />
</body>
</html>