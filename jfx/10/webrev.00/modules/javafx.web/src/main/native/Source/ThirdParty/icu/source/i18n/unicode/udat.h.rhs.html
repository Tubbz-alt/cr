<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/udat.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4  *******************************************************************************
   5  * Copyright (C) 1996-2016, International Business Machines
   6  * Corporation and others. All Rights Reserved.
   7  *******************************************************************************
   8 */
   9 
  10 #ifndef UDAT_H
  11 #define UDAT_H
  12 
  13 #include &quot;unicode/utypes.h&quot;
  14 
  15 #if !UCONFIG_NO_FORMATTING
  16 
  17 #include &quot;unicode/localpointer.h&quot;
  18 #include &quot;unicode/ucal.h&quot;
  19 #include &quot;unicode/unum.h&quot;
  20 #include &quot;unicode/udisplaycontext.h&quot;
  21 #include &quot;unicode/ufieldpositer.h&quot;
  22 /**
  23  * \file
  24  * \brief C API: DateFormat
  25  *
  26  * &lt;h2&gt; Date Format C API&lt;/h2&gt;
  27  *
  28  * Date Format C API  consists of functions that convert dates and
  29  * times from their internal representations to textual form and back again in a
  30  * language-independent manner. Converting from the internal representation (milliseconds
  31  * since midnight, January 1, 1970) to text is known as &quot;formatting,&quot; and converting
  32  * from text to millis is known as &quot;parsing.&quot;  We currently define only one concrete
  33  * structure UDateFormat, which can handle pretty much all normal
  34  * date formatting and parsing actions.
  35  * &lt;P&gt;
  36  * Date Format helps you to format and parse dates for any locale. Your code can
  37  * be completely independent of the locale conventions for months, days of the
  38  * week, or even the calendar format: lunar vs. solar.
  39  * &lt;P&gt;
  40  * To format a date for the current Locale with default time and date style,
  41  * use one of the static factory methods:
  42  * &lt;pre&gt;
  43  * \code
  44  *  UErrorCode status = U_ZERO_ERROR;
  45  *  UChar *myString;
  46  *  int32_t myStrlen = 0;
  47  *  UDateFormat* dfmt = udat_open(UDAT_DEFAULT, UDAT_DEFAULT, NULL, NULL, -1, NULL, -1, &amp;status);
  48  *  myStrlen = udat_format(dfmt, myDate, NULL, myStrlen, NULL, &amp;status);
  49  *  if (status==U_BUFFER_OVERFLOW_ERROR){
  50  *      status=U_ZERO_ERROR;
  51  *      myString=(UChar*)malloc(sizeof(UChar) * (myStrlen+1) );
  52  *      udat_format(dfmt, myDate, myString, myStrlen+1, NULL, &amp;status);
  53  *  }
  54  * \endcode
  55  * &lt;/pre&gt;
  56  * If you are formatting multiple numbers, it is more efficient to get the
  57  * format and use it multiple times so that the system doesn&#39;t have to fetch the
  58  * information about the local language and country conventions multiple times.
  59  * &lt;pre&gt;
  60  * \code
  61  *  UErrorCode status = U_ZERO_ERROR;
  62  *  int32_t i, myStrlen = 0;
  63  *  UChar* myString;
  64  *  char buffer[1024];
  65  *  UDate myDateArr[] = { 0.0, 100000000.0, 2000000000.0 }; // test values
  66  *  UDateFormat* df = udat_open(UDAT_DEFAULT, UDAT_DEFAULT, NULL, NULL, -1, NULL, 0, &amp;status);
  67  *  for (i = 0; i &lt; 3; i++) {
  68  *      myStrlen = udat_format(df, myDateArr[i], NULL, myStrlen, NULL, &amp;status);
  69  *      if(status == U_BUFFER_OVERFLOW_ERROR){
  70  *          status = U_ZERO_ERROR;
  71  *          myString = (UChar*)malloc(sizeof(UChar) * (myStrlen+1) );
  72  *          udat_format(df, myDateArr[i], myString, myStrlen+1, NULL, &amp;status);
  73  *          printf(&quot;%s\n&quot;, u_austrcpy(buffer, myString) );
  74  *          free(myString);
  75  *      }
  76  *  }
  77  * \endcode
  78  * &lt;/pre&gt;
  79  * To get specific fields of a date, you can use UFieldPosition to
  80  * get specific fields.
  81  * &lt;pre&gt;
  82  * \code
  83  *  UErrorCode status = U_ZERO_ERROR;
  84  *  UFieldPosition pos;
  85  *  UChar *myString;
  86  *  int32_t myStrlen = 0;
  87  *  char buffer[1024];
  88  *
  89  *  pos.field = 1;  // Same as the DateFormat::EField enum
  90  *  UDateFormat* dfmt = udat_open(UDAT_DEFAULT, UDAT_DEFAULT, NULL, -1, NULL, 0, &amp;status);
  91  *  myStrlen = udat_format(dfmt, myDate, NULL, myStrlen, &amp;pos, &amp;status);
  92  *  if (status==U_BUFFER_OVERFLOW_ERROR){
  93  *      status=U_ZERO_ERROR;
  94  *      myString=(UChar*)malloc(sizeof(UChar) * (myStrlen+1) );
  95  *      udat_format(dfmt, myDate, myString, myStrlen+1, &amp;pos, &amp;status);
  96  *  }
  97  *  printf(&quot;date format: %s\n&quot;, u_austrcpy(buffer, myString));
  98  *  buffer[pos.endIndex] = 0;   // NULL terminate the string.
  99  *  printf(&quot;UFieldPosition position equals %s\n&quot;, &amp;buffer[pos.beginIndex]);
 100  * \endcode
 101  * &lt;/pre&gt;
 102  * To format a date for a different Locale, specify it in the call to
 103  * udat_open()
 104  * &lt;pre&gt;
 105  * \code
 106  *        UDateFormat* df = udat_open(UDAT_SHORT, UDAT_SHORT, &quot;fr_FR&quot;, NULL, -1, NULL, 0, &amp;status);
 107  * \endcode
 108  * &lt;/pre&gt;
 109  * You can use a DateFormat API udat_parse() to parse.
 110  * &lt;pre&gt;
 111  * \code
 112  *  UErrorCode status = U_ZERO_ERROR;
 113  *  int32_t parsepos=0;
 114  *  UDate myDate = udat_parse(df, myString, u_strlen(myString), &amp;parsepos, &amp;status);
 115  * \endcode
 116  * &lt;/pre&gt;
 117  *  You can pass in different options for the arguments for date and time style
 118  *  to control the length of the result; from SHORT to MEDIUM to LONG to FULL.
 119  *  The exact result depends on the locale, but generally:
 120  *  see UDateFormatStyle for more details
 121  * &lt;ul type=round&gt;
 122  *   &lt;li&gt;   UDAT_SHORT is completely numeric, such as 12/13/52 or 3:30pm
 123  *   &lt;li&gt;   UDAT_MEDIUM is longer, such as Jan 12, 1952
 124  *   &lt;li&gt;   UDAT_LONG is longer, such as January 12, 1952 or 3:30:32pm
 125  *   &lt;li&gt;   UDAT_FULL is pretty completely specified, such as
 126  *          Tuesday, April 12, 1952 AD or 3:30:42pm PST.
 127  * &lt;/ul&gt;
 128  * You can also set the time zone on the format if you wish.
 129  * &lt;P&gt;
 130  * You can also use forms of the parse and format methods with Parse Position and
 131  * UFieldPosition to allow you to
 132  * &lt;ul type=round&gt;
 133  *   &lt;li&gt;   Progressively parse through pieces of a string.
 134  *   &lt;li&gt;   Align any particular field, or find out where it is for selection
 135  *          on the screen.
 136  * &lt;/ul&gt;
 137  * &lt;p&gt;&lt;strong&gt;Date and Time Patterns:&lt;/strong&gt;&lt;/p&gt;
 138  *
 139  * &lt;p&gt;Date and time formats are specified by &lt;em&gt;date and time pattern&lt;/em&gt; strings.
 140  * Within date and time pattern strings, all unquoted ASCII letters [A-Za-z] are reserved
 141  * as pattern letters representing calendar fields. &lt;code&gt;UDateFormat&lt;/code&gt; supports
 142  * the date and time formatting algorithm and pattern letters defined by
 143  * &lt;a href=&quot;http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table&quot;&gt;UTS#35
 144  * Unicode Locale Data Markup Language (LDML)&lt;/a&gt; and further documented for ICU in the
 145  * &lt;a href=&quot;https://sites.google.com/site/icuprojectuserguide/formatparse/datetime?pli=1#TOC-Date-Field-Symbol-Table&quot;&gt;ICU
 146  * User Guide&lt;/a&gt;.&lt;/p&gt;
 147  */
 148 
 149 /** A date formatter.
 150  *  For usage in C programs.
 151  *  @stable ICU 2.6
 152  */
 153 typedef void* UDateFormat;
 154 
 155 /** The possible date/time format styles
 156  *  @stable ICU 2.6
 157  */
 158 typedef enum UDateFormatStyle {
 159     /** Full style */
 160     UDAT_FULL,
 161     /** Long style */
 162     UDAT_LONG,
 163     /** Medium style */
 164     UDAT_MEDIUM,
 165     /** Short style */
 166     UDAT_SHORT,
 167     /** Default style */
 168     UDAT_DEFAULT = UDAT_MEDIUM,
 169 
 170     /** Bitfield for relative date */
 171     UDAT_RELATIVE = (1 &lt;&lt; 7),
 172 
 173     UDAT_FULL_RELATIVE = UDAT_FULL | UDAT_RELATIVE,
 174 
 175     UDAT_LONG_RELATIVE = UDAT_LONG | UDAT_RELATIVE,
 176 
 177     UDAT_MEDIUM_RELATIVE = UDAT_MEDIUM | UDAT_RELATIVE,
 178 
 179     UDAT_SHORT_RELATIVE = UDAT_SHORT | UDAT_RELATIVE,
 180 
 181 
 182     /** No style */
 183     UDAT_NONE = -1,
 184 
 185     /**
 186      * Use the pattern given in the parameter to udat_open
 187      * @see udat_open
 188      * @stable ICU 50
 189      */
 190     UDAT_PATTERN = -2,
 191 
 192 #ifndef U_HIDE_INTERNAL_API
 193     /** @internal alias to UDAT_PATTERN */
 194     UDAT_IGNORE = UDAT_PATTERN
 195 #endif /* U_HIDE_INTERNAL_API */
 196 } UDateFormatStyle;
 197 
 198 /* Skeletons for dates. */
 199 
 200 /**
 201  * Constant for date skeleton with year.
 202  * @stable ICU 4.0
 203  */
 204 #define UDAT_YEAR                       &quot;y&quot;
 205 /**
 206  * Constant for date skeleton with quarter.
 207  * @stable ICU 51
 208  */
 209 #define UDAT_QUARTER                    &quot;QQQQ&quot;
 210 /**
 211  * Constant for date skeleton with abbreviated quarter.
 212  * @stable ICU 51
 213  */
 214 #define UDAT_ABBR_QUARTER               &quot;QQQ&quot;
 215 /**
 216  * Constant for date skeleton with year and quarter.
 217  * @stable ICU 4.0
 218  */
 219 #define UDAT_YEAR_QUARTER               &quot;yQQQQ&quot;
 220 /**
 221  * Constant for date skeleton with year and abbreviated quarter.
 222  * @stable ICU 4.0
 223  */
 224 #define UDAT_YEAR_ABBR_QUARTER          &quot;yQQQ&quot;
 225 /**
 226  * Constant for date skeleton with month.
 227  * @stable ICU 4.0
 228  */
 229 #define UDAT_MONTH                      &quot;MMMM&quot;
 230 /**
 231  * Constant for date skeleton with abbreviated month.
 232  * @stable ICU 4.0
 233  */
 234 #define UDAT_ABBR_MONTH                 &quot;MMM&quot;
 235 /**
 236  * Constant for date skeleton with numeric month.
 237  * @stable ICU 4.0
 238  */
 239 #define UDAT_NUM_MONTH                  &quot;M&quot;
 240 /**
 241  * Constant for date skeleton with year and month.
 242  * @stable ICU 4.0
 243  */
 244 #define UDAT_YEAR_MONTH                 &quot;yMMMM&quot;
 245 /**
 246  * Constant for date skeleton with year and abbreviated month.
 247  * @stable ICU 4.0
 248  */
 249 #define UDAT_YEAR_ABBR_MONTH            &quot;yMMM&quot;
 250 /**
 251  * Constant for date skeleton with year and numeric month.
 252  * @stable ICU 4.0
 253  */
 254 #define UDAT_YEAR_NUM_MONTH             &quot;yM&quot;
 255 /**
 256  * Constant for date skeleton with day.
 257  * @stable ICU 4.0
 258  */
 259 #define UDAT_DAY                        &quot;d&quot;
 260 /**
 261  * Constant for date skeleton with year, month, and day.
 262  * Used in combinations date + time, date + time + zone, or time + zone.
 263  * @stable ICU 4.0
 264  */
 265 #define UDAT_YEAR_MONTH_DAY             &quot;yMMMMd&quot;
 266 /**
 267  * Constant for date skeleton with year, abbreviated month, and day.
 268  * Used in combinations date + time, date + time + zone, or time + zone.
 269  * @stable ICU 4.0
 270  */
 271 #define UDAT_YEAR_ABBR_MONTH_DAY        &quot;yMMMd&quot;
 272 /**
 273  * Constant for date skeleton with year, numeric month, and day.
 274  * Used in combinations date + time, date + time + zone, or time + zone.
 275  * @stable ICU 4.0
 276  */
 277 #define UDAT_YEAR_NUM_MONTH_DAY         &quot;yMd&quot;
 278 /**
 279  * Constant for date skeleton with weekday.
 280  * @stable ICU 51
 281  */
 282 #define UDAT_WEEKDAY                    &quot;EEEE&quot;
 283 /**
 284  * Constant for date skeleton with abbreviated weekday.
 285  * @stable ICU 51
 286  */
 287 #define UDAT_ABBR_WEEKDAY               &quot;E&quot;
 288 /**
 289  * Constant for date skeleton with year, month, weekday, and day.
 290  * Used in combinations date + time, date + time + zone, or time + zone.
 291  * @stable ICU 4.0
 292  */
 293 #define UDAT_YEAR_MONTH_WEEKDAY_DAY     &quot;yMMMMEEEEd&quot;
 294 /**
 295  * Constant for date skeleton with year, abbreviated month, weekday, and day.
 296  * Used in combinations date + time, date + time + zone, or time + zone.
 297  * @stable ICU 4.0
 298  */
 299 #define UDAT_YEAR_ABBR_MONTH_WEEKDAY_DAY &quot;yMMMEd&quot;
 300 /**
 301  * Constant for date skeleton with year, numeric month, weekday, and day.
 302  * Used in combinations date + time, date + time + zone, or time + zone.
 303  * @stable ICU 4.0
 304  */
 305 #define UDAT_YEAR_NUM_MONTH_WEEKDAY_DAY &quot;yMEd&quot;
 306 /**
 307  * Constant for date skeleton with long month and day.
 308  * Used in combinations date + time, date + time + zone, or time + zone.
 309  * @stable ICU 4.0
 310  */
 311 #define UDAT_MONTH_DAY                  &quot;MMMMd&quot;
 312 /**
 313  * Constant for date skeleton with abbreviated month and day.
 314  * Used in combinations date + time, date + time + zone, or time + zone.
 315  * @stable ICU 4.0
 316  */
 317 #define UDAT_ABBR_MONTH_DAY             &quot;MMMd&quot;
 318 /**
 319  * Constant for date skeleton with numeric month and day.
 320  * Used in combinations date + time, date + time + zone, or time + zone.
 321  * @stable ICU 4.0
 322  */
 323 #define UDAT_NUM_MONTH_DAY              &quot;Md&quot;
 324 /**
 325  * Constant for date skeleton with month, weekday, and day.
 326  * Used in combinations date + time, date + time + zone, or time + zone.
 327  * @stable ICU 4.0
 328  */
 329 #define UDAT_MONTH_WEEKDAY_DAY          &quot;MMMMEEEEd&quot;
 330 /**
 331  * Constant for date skeleton with abbreviated month, weekday, and day.
 332  * Used in combinations date + time, date + time + zone, or time + zone.
 333  * @stable ICU 4.0
 334  */
 335 #define UDAT_ABBR_MONTH_WEEKDAY_DAY     &quot;MMMEd&quot;
 336 /**
 337  * Constant for date skeleton with numeric month, weekday, and day.
 338  * Used in combinations date + time, date + time + zone, or time + zone.
 339  * @stable ICU 4.0
 340  */
 341 #define UDAT_NUM_MONTH_WEEKDAY_DAY      &quot;MEd&quot;
 342 
 343 /* Skeletons for times. */
 344 
 345 /**
 346  * Constant for date skeleton with hour, with the locale&#39;s preferred hour format (12 or 24).
 347  * @stable ICU 4.0
 348  */
 349 #define UDAT_HOUR                       &quot;j&quot;
 350 /**
 351  * Constant for date skeleton with hour in 24-hour presentation.
 352  * @stable ICU 51
 353  */
 354 #define UDAT_HOUR24                     &quot;H&quot;
 355 /**
 356  * Constant for date skeleton with minute.
 357  * @stable ICU 51
 358  */
 359 #define UDAT_MINUTE                     &quot;m&quot;
 360 /**
 361  * Constant for date skeleton with hour and minute, with the locale&#39;s preferred hour format (12 or 24).
 362  * Used in combinations date + time, date + time + zone, or time + zone.
 363  * @stable ICU 4.0
 364  */
 365 #define UDAT_HOUR_MINUTE                &quot;jm&quot;
 366 /**
 367  * Constant for date skeleton with hour and minute in 24-hour presentation.
 368  * Used in combinations date + time, date + time + zone, or time + zone.
 369  * @stable ICU 4.0
 370  */
 371 #define UDAT_HOUR24_MINUTE              &quot;Hm&quot;
 372 /**
 373  * Constant for date skeleton with second.
 374  * @stable ICU 51
 375  */
 376 #define UDAT_SECOND                     &quot;s&quot;
 377 /**
 378  * Constant for date skeleton with hour, minute, and second,
 379  * with the locale&#39;s preferred hour format (12 or 24).
 380  * Used in combinations date + time, date + time + zone, or time + zone.
 381  * @stable ICU 4.0
 382  */
 383 #define UDAT_HOUR_MINUTE_SECOND         &quot;jms&quot;
 384 /**
 385  * Constant for date skeleton with hour, minute, and second in
 386  * 24-hour presentation.
 387  * Used in combinations date + time, date + time + zone, or time + zone.
 388  * @stable ICU 4.0
 389  */
 390 #define UDAT_HOUR24_MINUTE_SECOND       &quot;Hms&quot;
 391 /**
 392  * Constant for date skeleton with minute and second.
 393  * Used in combinations date + time, date + time + zone, or time + zone.
 394  * @stable ICU 4.0
 395  */
 396 #define UDAT_MINUTE_SECOND              &quot;ms&quot;
 397 
 398 /* Skeletons for time zones. */
 399 
 400 /**
 401  * Constant for &lt;i&gt;generic location format&lt;/i&gt;, such as Los Angeles Time;
 402  * used in combinations date + time + zone, or time + zone.
 403  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Date_Format_Patterns&quot;&gt;LDML Date Format Patterns&lt;/a&gt;
 404  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Time_Zone_Fallback&quot;&gt;LDML Time Zone Fallback&lt;/a&gt;
 405  * @stable ICU 51
 406  */
 407 #define UDAT_LOCATION_TZ &quot;VVVV&quot;
 408 /**
 409  * Constant for &lt;i&gt;generic non-location format&lt;/i&gt;, such as Pacific Time;
 410  * used in combinations date + time + zone, or time + zone.
 411  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Date_Format_Patterns&quot;&gt;LDML Date Format Patterns&lt;/a&gt;
 412  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Time_Zone_Fallback&quot;&gt;LDML Time Zone Fallback&lt;/a&gt;
 413  * @stable ICU 51
 414  */
 415 #define UDAT_GENERIC_TZ &quot;vvvv&quot;
 416 /**
 417  * Constant for &lt;i&gt;generic non-location format&lt;/i&gt;, abbreviated if possible, such as PT;
 418  * used in combinations date + time + zone, or time + zone.
 419  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Date_Format_Patterns&quot;&gt;LDML Date Format Patterns&lt;/a&gt;
 420  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Time_Zone_Fallback&quot;&gt;LDML Time Zone Fallback&lt;/a&gt;
 421  * @stable ICU 51
 422  */
 423 #define UDAT_ABBR_GENERIC_TZ &quot;v&quot;
 424 /**
 425  * Constant for &lt;i&gt;specific non-location format&lt;/i&gt;, such as Pacific Daylight Time;
 426  * used in combinations date + time + zone, or time + zone.
 427  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Date_Format_Patterns&quot;&gt;LDML Date Format Patterns&lt;/a&gt;
 428  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Time_Zone_Fallback&quot;&gt;LDML Time Zone Fallback&lt;/a&gt;
 429  * @stable ICU 51
 430  */
 431 #define UDAT_SPECIFIC_TZ &quot;zzzz&quot;
 432 /**
 433  * Constant for &lt;i&gt;specific non-location format&lt;/i&gt;, abbreviated if possible, such as PDT;
 434  * used in combinations date + time + zone, or time + zone.
 435  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Date_Format_Patterns&quot;&gt;LDML Date Format Patterns&lt;/a&gt;
 436  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Time_Zone_Fallback&quot;&gt;LDML Time Zone Fallback&lt;/a&gt;
 437  * @stable ICU 51
 438  */
 439 #define UDAT_ABBR_SPECIFIC_TZ &quot;z&quot;
 440 /**
 441  * Constant for &lt;i&gt;localized GMT/UTC format&lt;/i&gt;, such as GMT+8:00 or HPG-8:00;
 442  * used in combinations date + time + zone, or time + zone.
 443  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Date_Format_Patterns&quot;&gt;LDML Date Format Patterns&lt;/a&gt;
 444  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Time_Zone_Fallback&quot;&gt;LDML Time Zone Fallback&lt;/a&gt;
 445  * @stable ICU 51
 446  */
 447 #define UDAT_ABBR_UTC_TZ &quot;ZZZZ&quot;
 448 
 449 /* deprecated skeleton constants */
 450 
 451 #ifndef U_HIDE_DEPRECATED_API
 452 /**
 453  * Constant for date skeleton with standalone month.
 454  * @deprecated ICU 50 Use UDAT_MONTH instead.
 455  */
 456 #define UDAT_STANDALONE_MONTH           &quot;LLLL&quot;
 457 /**
 458  * Constant for date skeleton with standalone abbreviated month.
 459  * @deprecated ICU 50 Use UDAT_ABBR_MONTH instead.
 460  */
 461 #define UDAT_ABBR_STANDALONE_MONTH      &quot;LLL&quot;
 462 
 463 /**
 464  * Constant for date skeleton with hour, minute, and generic timezone.
 465  * @deprecated ICU 50 Use instead UDAT_HOUR_MINUTE UDAT_ABBR_GENERIC_TZ or some other timezone presentation.
 466  */
 467 #define UDAT_HOUR_MINUTE_GENERIC_TZ     &quot;jmv&quot;
 468 /**
 469  * Constant for date skeleton with hour, minute, and timezone.
 470  * @deprecated ICU 50 Use instead UDAT_HOUR_MINUTE UDAT_ABBR_SPECIFIC_TZ or some other timezone presentation.
 471  */
 472 #define UDAT_HOUR_MINUTE_TZ             &quot;jmz&quot;
 473 /**
 474  * Constant for date skeleton with hour and generic timezone.
 475  * @deprecated ICU 50 Use instead UDAT_HOUR UDAT_ABBR_GENERIC_TZ or some other timezone presentation.
 476  */
 477 #define UDAT_HOUR_GENERIC_TZ            &quot;jv&quot;
 478 /**
 479  * Constant for date skeleton with hour and timezone.
 480  * @deprecated ICU 50 Use instead UDAT_HOUR UDAT_ABBR_SPECIFIC_TZ or some other timezone presentation.
 481  */
 482 #define UDAT_HOUR_TZ                    &quot;jz&quot;
 483 #endif  /* U_HIDE_DEPRECATED_API */
 484 
<a name="1" id="anc1"></a><span class="line-added"> 485 #ifndef U_HIDE_INTERNAL_API</span>
<span class="line-added"> 486 /**</span>
<span class="line-added"> 487  * Constant for Unicode string name of new (in 2019) Japanese calendar era,</span>
<span class="line-added"> 488  * root/English abbreviated version (ASCII-range characters).</span>
<span class="line-added"> 489  * @internal</span>
<span class="line-added"> 490  */</span>
<span class="line-added"> 491 #define JP_ERA_2019_ROOT                &quot;Reiwa&quot;</span>
<span class="line-added"> 492 /**</span>
<span class="line-added"> 493  * Constant for Unicode string name of new (in 2019) Japanese calendar era,</span>
<span class="line-added"> 494  * Japanese abbreviated version (Han, or fullwidth Latin for testing).</span>
<span class="line-added"> 495  * @internal</span>
<span class="line-added"> 496  */</span>
<span class="line-added"> 497 #define JP_ERA_2019_JA                  &quot;\\u4EE4\\u548C&quot;</span>
<span class="line-added"> 498 /**</span>
<span class="line-added"> 499  * Constant for Unicode string name of new (in 2019) Japanese calendar era,</span>
<span class="line-added"> 500  * root and Japanese narrow version (ASCII-range characters).</span>
<span class="line-added"> 501  * @internal</span>
<span class="line-added"> 502  */</span>
<span class="line-added"> 503 #define JP_ERA_2019_NARROW              &quot;R&quot;</span>
<span class="line-added"> 504 #endif  // U_HIDE_INTERNAL_API</span>
<span class="line-added"> 505 </span>
 506 /**
 507  * FieldPosition and UFieldPosition selectors for format fields
 508  * defined by DateFormat and UDateFormat.
 509  * @stable ICU 3.0
 510  */
 511 typedef enum UDateFormatField {
 512     /**
 513      * FieldPosition and UFieldPosition selector for &#39;G&#39; field alignment,
 514      * corresponding to the UCAL_ERA field.
 515      * @stable ICU 3.0
 516      */
 517     UDAT_ERA_FIELD = 0,
 518 
 519     /**
 520      * FieldPosition and UFieldPosition selector for &#39;y&#39; field alignment,
 521      * corresponding to the UCAL_YEAR field.
 522      * @stable ICU 3.0
 523      */
 524     UDAT_YEAR_FIELD = 1,
 525 
 526     /**
 527      * FieldPosition and UFieldPosition selector for &#39;M&#39; field alignment,
 528      * corresponding to the UCAL_MONTH field.
 529      * @stable ICU 3.0
 530      */
 531     UDAT_MONTH_FIELD = 2,
 532 
 533     /**
 534      * FieldPosition and UFieldPosition selector for &#39;d&#39; field alignment,
 535      * corresponding to the UCAL_DATE field.
 536      * @stable ICU 3.0
 537      */
 538     UDAT_DATE_FIELD = 3,
 539 
 540     /**
 541      * FieldPosition and UFieldPosition selector for &#39;k&#39; field alignment,
 542      * corresponding to the UCAL_HOUR_OF_DAY field.
 543      * UDAT_HOUR_OF_DAY1_FIELD is used for the one-based 24-hour clock.
 544      * For example, 23:59 + 01:00 results in 24:59.
 545      * @stable ICU 3.0
 546      */
 547     UDAT_HOUR_OF_DAY1_FIELD = 4,
 548 
 549     /**
 550      * FieldPosition and UFieldPosition selector for &#39;H&#39; field alignment,
 551      * corresponding to the UCAL_HOUR_OF_DAY field.
 552      * UDAT_HOUR_OF_DAY0_FIELD is used for the zero-based 24-hour clock.
 553      * For example, 23:59 + 01:00 results in 00:59.
 554      * @stable ICU 3.0
 555      */
 556     UDAT_HOUR_OF_DAY0_FIELD = 5,
 557 
 558     /**
 559      * FieldPosition and UFieldPosition selector for &#39;m&#39; field alignment,
 560      * corresponding to the UCAL_MINUTE field.
 561      * @stable ICU 3.0
 562      */
 563     UDAT_MINUTE_FIELD = 6,
 564 
 565     /**
 566      * FieldPosition and UFieldPosition selector for &#39;s&#39; field alignment,
 567      * corresponding to the UCAL_SECOND field.
 568      * @stable ICU 3.0
 569      */
 570     UDAT_SECOND_FIELD = 7,
 571 
 572     /**
 573      * FieldPosition and UFieldPosition selector for &#39;S&#39; field alignment,
 574      * corresponding to the UCAL_MILLISECOND field.
 575      *
 576      * Note: Time formats that use &#39;S&#39; can display a maximum of three
 577      * significant digits for fractional seconds, corresponding to millisecond
 578      * resolution and a fractional seconds sub-pattern of SSS. If the
 579      * sub-pattern is S or SS, the fractional seconds value will be truncated
 580      * (not rounded) to the number of display places specified. If the
 581      * fractional seconds sub-pattern is longer than SSS, the additional
 582      * display places will be filled with zeros.
 583      * @stable ICU 3.0
 584      */
 585     UDAT_FRACTIONAL_SECOND_FIELD = 8,
 586 
 587     /**
 588      * FieldPosition and UFieldPosition selector for &#39;E&#39; field alignment,
 589      * corresponding to the UCAL_DAY_OF_WEEK field.
 590      * @stable ICU 3.0
 591      */
 592     UDAT_DAY_OF_WEEK_FIELD = 9,
 593 
 594     /**
 595      * FieldPosition and UFieldPosition selector for &#39;D&#39; field alignment,
 596      * corresponding to the UCAL_DAY_OF_YEAR field.
 597      * @stable ICU 3.0
 598      */
 599     UDAT_DAY_OF_YEAR_FIELD = 10,
 600 
 601     /**
 602      * FieldPosition and UFieldPosition selector for &#39;F&#39; field alignment,
 603      * corresponding to the UCAL_DAY_OF_WEEK_IN_MONTH field.
 604      * @stable ICU 3.0
 605      */
 606     UDAT_DAY_OF_WEEK_IN_MONTH_FIELD = 11,
 607 
 608     /**
 609      * FieldPosition and UFieldPosition selector for &#39;w&#39; field alignment,
 610      * corresponding to the UCAL_WEEK_OF_YEAR field.
 611      * @stable ICU 3.0
 612      */
 613     UDAT_WEEK_OF_YEAR_FIELD = 12,
 614 
 615     /**
 616      * FieldPosition and UFieldPosition selector for &#39;W&#39; field alignment,
 617      * corresponding to the UCAL_WEEK_OF_MONTH field.
 618      * @stable ICU 3.0
 619      */
 620     UDAT_WEEK_OF_MONTH_FIELD = 13,
 621 
 622     /**
 623      * FieldPosition and UFieldPosition selector for &#39;a&#39; field alignment,
 624      * corresponding to the UCAL_AM_PM field.
 625      * @stable ICU 3.0
 626      */
 627     UDAT_AM_PM_FIELD = 14,
 628 
 629     /**
 630      * FieldPosition and UFieldPosition selector for &#39;h&#39; field alignment,
 631      * corresponding to the UCAL_HOUR field.
 632      * UDAT_HOUR1_FIELD is used for the one-based 12-hour clock.
 633      * For example, 11:30 PM + 1 hour results in 12:30 AM.
 634      * @stable ICU 3.0
 635      */
 636     UDAT_HOUR1_FIELD = 15,
 637 
 638     /**
 639      * FieldPosition and UFieldPosition selector for &#39;K&#39; field alignment,
 640      * corresponding to the UCAL_HOUR field.
 641      * UDAT_HOUR0_FIELD is used for the zero-based 12-hour clock.
 642      * For example, 11:30 PM + 1 hour results in 00:30 AM.
 643      * @stable ICU 3.0
 644      */
 645     UDAT_HOUR0_FIELD = 16,
 646 
 647     /**
 648      * FieldPosition and UFieldPosition selector for &#39;z&#39; field alignment,
 649      * corresponding to the UCAL_ZONE_OFFSET and
 650      * UCAL_DST_OFFSET fields.
 651      * @stable ICU 3.0
 652      */
 653     UDAT_TIMEZONE_FIELD = 17,
 654 
 655     /**
 656      * FieldPosition and UFieldPosition selector for &#39;Y&#39; field alignment,
 657      * corresponding to the UCAL_YEAR_WOY field.
 658      * @stable ICU 3.0
 659      */
 660     UDAT_YEAR_WOY_FIELD = 18,
 661 
 662     /**
 663      * FieldPosition and UFieldPosition selector for &#39;e&#39; field alignment,
 664      * corresponding to the UCAL_DOW_LOCAL field.
 665      * @stable ICU 3.0
 666      */
 667     UDAT_DOW_LOCAL_FIELD = 19,
 668 
 669     /**
 670      * FieldPosition and UFieldPosition selector for &#39;u&#39; field alignment,
 671      * corresponding to the UCAL_EXTENDED_YEAR field.
 672      * @stable ICU 3.0
 673      */
 674     UDAT_EXTENDED_YEAR_FIELD = 20,
 675 
 676     /**
 677      * FieldPosition and UFieldPosition selector for &#39;g&#39; field alignment,
 678      * corresponding to the UCAL_JULIAN_DAY field.
 679      * @stable ICU 3.0
 680      */
 681     UDAT_JULIAN_DAY_FIELD = 21,
 682 
 683     /**
 684      * FieldPosition and UFieldPosition selector for &#39;A&#39; field alignment,
 685      * corresponding to the UCAL_MILLISECONDS_IN_DAY field.
 686      * @stable ICU 3.0
 687      */
 688     UDAT_MILLISECONDS_IN_DAY_FIELD = 22,
 689 
 690     /**
 691      * FieldPosition and UFieldPosition selector for &#39;Z&#39; field alignment,
 692      * corresponding to the UCAL_ZONE_OFFSET and
 693      * UCAL_DST_OFFSET fields.
 694      * @stable ICU 3.0
 695      */
 696     UDAT_TIMEZONE_RFC_FIELD = 23,
 697 
 698     /**
 699      * FieldPosition and UFieldPosition selector for &#39;v&#39; field alignment,
 700      * corresponding to the UCAL_ZONE_OFFSET field.
 701      * @stable ICU 3.4
 702      */
 703     UDAT_TIMEZONE_GENERIC_FIELD = 24,
 704     /**
 705      * FieldPosition selector for &#39;c&#39; field alignment,
 706      * corresponding to the {@link #UCAL_DOW_LOCAL} field.
 707      * This displays the stand alone day name, if available.
 708      * @stable ICU 3.4
 709      */
 710     UDAT_STANDALONE_DAY_FIELD = 25,
 711 
 712     /**
 713      * FieldPosition selector for &#39;L&#39; field alignment,
 714      * corresponding to the {@link #UCAL_MONTH} field.
 715      * This displays the stand alone month name, if available.
 716      * @stable ICU 3.4
 717      */
 718     UDAT_STANDALONE_MONTH_FIELD = 26,
 719 
 720     /**
 721      * FieldPosition selector for &quot;Q&quot; field alignment,
 722      * corresponding to quarters. This is implemented
 723      * using the {@link #UCAL_MONTH} field. This
 724      * displays the quarter.
 725      * @stable ICU 3.6
 726      */
 727     UDAT_QUARTER_FIELD = 27,
 728 
 729     /**
 730      * FieldPosition selector for the &quot;q&quot; field alignment,
 731      * corresponding to stand-alone quarters. This is
 732      * implemented using the {@link #UCAL_MONTH} field.
 733      * This displays the stand-alone quarter.
 734      * @stable ICU 3.6
 735      */
 736     UDAT_STANDALONE_QUARTER_FIELD = 28,
 737 
 738     /**
 739      * FieldPosition and UFieldPosition selector for &#39;V&#39; field alignment,
 740      * corresponding to the UCAL_ZONE_OFFSET field.
 741      * @stable ICU 3.8
 742      */
 743     UDAT_TIMEZONE_SPECIAL_FIELD = 29,
 744 
 745     /**
 746      * FieldPosition selector for &quot;U&quot; field alignment,
 747      * corresponding to cyclic year names. This is implemented
 748      * using the {@link #UCAL_YEAR} field. This displays
 749      * the cyclic year name, if available.
 750      * @stable ICU 49
 751      */
 752     UDAT_YEAR_NAME_FIELD = 30,
 753 
 754     /**
 755      * FieldPosition selector for &#39;O&#39; field alignment,
 756      * corresponding to the UCAL_ZONE_OFFSET and UCAL_DST_OFFSETfields.
 757      * This displays the localized GMT format.
 758      * @stable ICU 51
 759      */
 760     UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD = 31,
 761 
 762     /**
 763      * FieldPosition selector for &#39;X&#39; field alignment,
 764      * corresponding to the UCAL_ZONE_OFFSET and UCAL_DST_OFFSETfields.
 765      * This displays the ISO 8601 local time offset format or UTC indicator (&quot;Z&quot;).
 766      * @stable ICU 51
 767      */
 768     UDAT_TIMEZONE_ISO_FIELD = 32,
 769 
 770     /**
 771      * FieldPosition selector for &#39;x&#39; field alignment,
 772      * corresponding to the UCAL_ZONE_OFFSET and UCAL_DST_OFFSET fields.
 773      * This displays the ISO 8601 local time offset format.
 774      * @stable ICU 51
 775      */
 776     UDAT_TIMEZONE_ISO_LOCAL_FIELD = 33,
 777 
 778 #ifndef U_HIDE_INTERNAL_API
 779     /**
 780      * FieldPosition and UFieldPosition selector for &#39;r&#39; field alignment,
 781      * no directly corresponding UCAL_ field.
 782      * @internal ICU 53
 783      */
 784     UDAT_RELATED_YEAR_FIELD = 34,
 785 #endif  /* U_HIDE_INTERNAL_API */
 786 
 787     /**
 788      * FieldPosition selector for &#39;b&#39; field alignment.
 789      * Displays midnight and noon for 12am and 12pm, respectively, if available;
 790      * otherwise fall back to AM / PM.
 791      * @stable ICU 57
 792      */
 793     UDAT_AM_PM_MIDNIGHT_NOON_FIELD = 35,
 794 
 795     /* FieldPosition selector for &#39;B&#39; field alignment.
 796      * Displays flexible day periods, such as &quot;in the morning&quot;, if available.
 797      * @stable ICU 57
 798      */
 799     UDAT_FLEXIBLE_DAY_PERIOD_FIELD = 36,
 800 
 801 #ifndef U_HIDE_INTERNAL_API
 802     /**
 803      * FieldPosition and UFieldPosition selector for time separator,
 804      * no corresponding UCAL_ field. No pattern character is currently
 805      * defined for this.
 806      * @internal
 807      */
 808     UDAT_TIME_SEPARATOR_FIELD = 37,
 809 #endif  /* U_HIDE_INTERNAL_API */
 810 
 811 #ifndef U_HIDE_DEPRECATED_API
 812     /**
 813      * Number of FieldPosition and UFieldPosition selectors for
 814      * DateFormat and UDateFormat.
 815      * Valid selectors range from 0 to UDAT_FIELD_COUNT-1.
 816      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
 817      */
 818     UDAT_FIELD_COUNT = 38
 819 #endif  /* U_HIDE_DEPRECATED_API */
 820 } UDateFormatField;
 821 
 822 
 823 #ifndef U_HIDE_INTERNAL_API
 824 /**
 825  * Is a pattern character defined for UDAT_TIME_SEPARATOR_FIELD?
 826  * In ICU 55 it was COLON, but that was withdrawn in ICU 56.
 827  * @internal ICU 56
 828  */
 829 #define UDAT_HAS_PATTERN_CHAR_FOR_TIME_SEPARATOR 0
 830 #endif /* U_HIDE_INTERNAL_API */
 831 
 832 
 833 /**
 834  * Maps from a UDateFormatField to the corresponding UCalendarDateFields.
 835  * Note: since the mapping is many-to-one, there is no inverse mapping.
 836  * @param field the UDateFormatField.
 837  * @return the UCalendarDateField.  This will be UCAL_FIELD_COUNT in case
 838  * of error (e.g., the input field is UDAT_FIELD_COUNT).
 839  * @stable ICU 4.4
 840  */
 841 U_CAPI UCalendarDateFields U_EXPORT2
 842 udat_toCalendarDateField(UDateFormatField field);
 843 
 844 
 845 /**
 846  * Open a new UDateFormat for formatting and parsing dates and times.
 847  * A UDateFormat may be used to format dates in calls to {@link #udat_format },
 848  * and to parse dates in calls to {@link #udat_parse }.
 849  * @param timeStyle The style used to format times; one of UDAT_FULL, UDAT_LONG,
 850  * UDAT_MEDIUM, UDAT_SHORT, UDAT_DEFAULT, or UDAT_NONE (relative time styles
 851  * are not currently supported).
 852  * When the pattern parameter is used, pass in UDAT_PATTERN for both timeStyle and dateStyle.
 853  * @param dateStyle The style used to format dates; one of UDAT_FULL, UDAT_LONG,
 854  * UDAT_MEDIUM, UDAT_SHORT, UDAT_DEFAULT, UDAT_FULL_RELATIVE, UDAT_LONG_RELATIVE,
 855  * UDAT_MEDIUM_RELATIVE, UDAT_SHORT_RELATIVE, or UDAT_NONE.
 856  * When the pattern parameter is used, pass in UDAT_PATTERN for both timeStyle and dateStyle.
 857  * As currently implemented,
 858  * relative date formatting only affects a limited range of calendar days before or
 859  * after the current date, based on the CLDR &amp;lt;field type=&quot;day&quot;&amp;gt;/&amp;lt;relative&amp;gt; data: For
 860  * example, in English, &quot;Yesterday&quot;, &quot;Today&quot;, and &quot;Tomorrow&quot;. Outside of this range,
 861  * dates are formatted using the corresponding non-relative style.
 862  * @param locale The locale specifying the formatting conventions
 863  * @param tzID A timezone ID specifying the timezone to use.  If 0, use
 864  * the default timezone.
 865  * @param tzIDLength The length of tzID, or -1 if null-terminated.
 866  * @param pattern A pattern specifying the format to use.
 867  * @param patternLength The number of characters in the pattern, or -1 if null-terminated.
 868  * @param status A pointer to an UErrorCode to receive any errors
 869  * @return A pointer to a UDateFormat to use for formatting dates and times, or 0 if
 870  * an error occurred.
 871  * @stable ICU 2.0
 872  */
 873 U_CAPI UDateFormat* U_EXPORT2
 874 udat_open(UDateFormatStyle  timeStyle,
 875           UDateFormatStyle  dateStyle,
 876           const char        *locale,
 877           const UChar       *tzID,
 878           int32_t           tzIDLength,
 879           const UChar       *pattern,
 880           int32_t           patternLength,
 881           UErrorCode        *status);
 882 
 883 
 884 /**
 885 * Close a UDateFormat.
 886 * Once closed, a UDateFormat may no longer be used.
 887 * @param format The formatter to close.
 888 * @stable ICU 2.0
 889 */
 890 U_CAPI void U_EXPORT2
 891 udat_close(UDateFormat* format);
 892 
 893 
 894 /**
 895  * DateFormat boolean attributes
 896  *
 897  * @stable ICU 53
 898  */
 899 typedef enum UDateFormatBooleanAttribute {
 900    /**
 901      * indicates whether whitespace is allowed. Includes trailing dot tolerance.
 902      * @stable ICU 53
 903      */
 904     UDAT_PARSE_ALLOW_WHITESPACE = 0,
 905     /**
 906      * indicates tolerance of numeric data when String data may be assumed. eg: UDAT_YEAR_NAME_FIELD,
 907      * UDAT_STANDALONE_MONTH_FIELD, UDAT_DAY_OF_WEEK_FIELD
 908      * @stable ICU 53
 909      */
 910     UDAT_PARSE_ALLOW_NUMERIC = 1,
 911     /**
 912      * indicates tolerance of a partial literal match
 913      * e.g. accepting &quot;--mon-02-march-2011&quot; for a pattern of &quot;&#39;--: &#39;EEE-WW-MMMM-yyyy&quot;
 914      * @stable ICU 56
 915      */
 916     UDAT_PARSE_PARTIAL_LITERAL_MATCH = 2,
 917     /**
 918      * indicates tolerance of pattern mismatch between input data and specified format pattern.
 919      * e.g. accepting &quot;September&quot; for a month pattern of MMM (&quot;Sep&quot;)
 920      * @stable ICU 56
 921      */
 922     UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH = 3,
 923 
 924     /* Do not conditionalize the following with #ifndef U_HIDE_DEPRECATED_API,
 925      * it is needed for layout of DateFormat object. */
 926     /**
 927      * One more than the highest normal UDateFormatBooleanAttribute value.
 928      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
 929      */
 930     UDAT_BOOLEAN_ATTRIBUTE_COUNT = 4
 931 } UDateFormatBooleanAttribute;
 932 
 933 /**
 934  * Get a boolean attribute associated with a UDateFormat.
 935  * An example would be a true value for a key of UDAT_PARSE_ALLOW_WHITESPACE indicating allowing whitespace leniency.
 936  * If the formatter does not understand the attribute, -1 is returned.
 937  * @param fmt The formatter to query.
 938  * @param attr The attribute to query; e.g. UDAT_PARSE_ALLOW_WHITESPACE.
 939  * @param status A pointer to an UErrorCode to receive any errors
 940  * @return The value of attr.
 941  * @stable ICU 53
 942  */
 943 U_CAPI UBool U_EXPORT2
 944 udat_getBooleanAttribute(const UDateFormat* fmt, UDateFormatBooleanAttribute attr, UErrorCode* status);
 945 
 946 /**
 947  * Set a boolean attribute associated with a UDateFormat.
 948  * An example of a boolean attribute is parse leniency control.  If the formatter does not understand
 949  * the attribute, the call is ignored.
 950  * @param fmt The formatter to set.
 951  * @param attr The attribute to set; one of UDAT_PARSE_ALLOW_WHITESPACE or UDAT_PARSE_ALLOW_NUMERIC
 952  * @param newValue The new value of attr.
 953  * @param status A pointer to an UErrorCode to receive any errors
 954  * @stable ICU 53
 955  */
 956 U_CAPI void U_EXPORT2
 957 udat_setBooleanAttribute(UDateFormat *fmt, UDateFormatBooleanAttribute attr, UBool newValue, UErrorCode* status);
 958 
 959 
 960 
 961 #if U_SHOW_CPLUSPLUS_API
 962 
 963 U_NAMESPACE_BEGIN
 964 
 965 /**
 966  * \class LocalUDateFormatPointer
 967  * &quot;Smart pointer&quot; class, closes a UDateFormat via udat_close().
 968  * For most methods see the LocalPointerBase base class.
 969  *
 970  * @see LocalPointerBase
 971  * @see LocalPointer
 972  * @stable ICU 4.4
 973  */
 974 U_DEFINE_LOCAL_OPEN_POINTER(LocalUDateFormatPointer, UDateFormat, udat_close);
 975 
 976 U_NAMESPACE_END
 977 
 978 #endif
 979 
 980 /**
 981  * Open a copy of a UDateFormat.
 982  * This function performs a deep copy.
 983  * @param fmt The format to copy
 984  * @param status A pointer to an UErrorCode to receive any errors.
 985  * @return A pointer to a UDateFormat identical to fmt.
 986  * @stable ICU 2.0
 987  */
 988 U_CAPI UDateFormat* U_EXPORT2
 989 udat_clone(const UDateFormat *fmt,
 990        UErrorCode *status);
 991 
 992 /**
 993 * Format a date using a UDateFormat.
 994 * The date will be formatted using the conventions specified in {@link #udat_open }
 995 * @param format The formatter to use
 996 * @param dateToFormat The date to format
 997 * @param result A pointer to a buffer to receive the formatted number.
 998 * @param resultLength The maximum size of result.
 999 * @param position A pointer to a UFieldPosition.  On input, position-&gt;field
1000 * is read.  On output, position-&gt;beginIndex and position-&gt;endIndex indicate
1001 * the beginning and ending indices of field number position-&gt;field, if such
1002 * a field exists.  This parameter may be NULL, in which case no field
1003 * position data is returned.
1004 * @param status A pointer to an UErrorCode to receive any errors
1005 * @return The total buffer size needed; if greater than resultLength, the output was truncated.
1006 * @see udat_parse
1007 * @see UFieldPosition
1008 * @stable ICU 2.0
1009 */
1010 U_CAPI int32_t U_EXPORT2
1011 udat_format(    const    UDateFormat*    format,
1012                         UDate           dateToFormat,
1013                         UChar*          result,
1014                         int32_t         resultLength,
1015                         UFieldPosition* position,
1016                         UErrorCode*     status);
1017 
1018 /**
1019 * Format a date using an UDateFormat.
1020 * The date will be formatted using the conventions specified in {@link #udat_open }
1021 * @param format The formatter to use
1022 * @param calendar The calendar to format. The calendar instance might be
1023 *                 mutated if fields are not yet fully calculated, though
1024 *                 the function won&#39;t change the logical date and time held
1025 *                 by the instance.
1026 * @param result A pointer to a buffer to receive the formatted number.
1027 * @param capacity The maximum size of result.
1028 * @param position A pointer to a UFieldPosition.  On input, position-&gt;field
1029 * is read.  On output, position-&gt;beginIndex and position-&gt;endIndex indicate
1030 * the beginning and ending indices of field number position-&gt;field, if such
1031 * a field exists.  This parameter may be NULL, in which case no field
1032 * position data is returned.
1033 * @param status A pointer to an UErrorCode to receive any errors
1034 * @return The total buffer size needed; if greater than resultLength, the output was truncated.
1035 * @see udat_format
1036 * @see udat_parseCalendar
1037 * @see UFieldPosition
1038 * @stable ICU 55
1039 */
1040 U_CAPI int32_t U_EXPORT2
1041 udat_formatCalendar(    const UDateFormat*  format,
1042                         UCalendar*      calendar,
1043                         UChar*          result,
1044                         int32_t         capacity,
1045                         UFieldPosition* position,
1046                         UErrorCode*     status);
1047 
1048 /**
1049 * Format a date using a UDateFormat.
1050 * The date will be formatted using the conventions specified in {@link #udat_open}
1051 * @param format
1052 *          The formatter to use
1053 * @param dateToFormat
1054 *          The date to format
1055 * @param result
1056 *          A pointer to a buffer to receive the formatted number.
1057 * @param resultLength
1058 *          The maximum size of result.
1059 * @param fpositer
1060 *          A pointer to a UFieldPositionIterator created by {@link #ufieldpositer_open}
1061 *          (may be NULL if field position information is not needed). Any
1062 *          iteration information already present in the UFieldPositionIterator
1063 *          will be deleted, and the iterator will be reset to apply to the
1064 *          fields in the formatted string created by this function call; the
1065 *          field values provided by {@link #ufieldpositer_next} will be from the
1066 *          UDateFormatField enum.
1067 * @param status
1068 *          A pointer to a UErrorCode to receive any errors
1069 * @return
1070 *          The total buffer size needed; if greater than resultLength, the output was truncated.
1071 * @see udat_parse
1072 * @see UFieldPositionIterator
1073 * @stable ICU 55
1074 */
1075 U_CAPI int32_t U_EXPORT2
1076 udat_formatForFields(   const UDateFormat* format,
1077                         UDate           dateToFormat,
1078                         UChar*          result,
1079                         int32_t         resultLength,
1080                         UFieldPositionIterator* fpositer,
1081                         UErrorCode*     status);
1082 
1083 /**
1084 * Format a date using a UDateFormat.
1085 * The date will be formatted using the conventions specified in {@link #udat_open }
1086 * @param format
1087 *          The formatter to use
1088 * @param calendar
1089 *          The calendar to format. The calendar instance might be mutated if fields
1090 *          are not yet fully calculated, though the function won&#39;t change the logical
1091 *          date and time held by the instance.
1092 * @param result
1093 *          A pointer to a buffer to receive the formatted number.
1094 * @param capacity
1095 *          The maximum size of result.
1096 * @param fpositer
1097 *          A pointer to a UFieldPositionIterator created by {@link #ufieldpositer_open}
1098 *          (may be NULL if field position information is not needed). Any
1099 *          iteration information already present in the UFieldPositionIterator
1100 *          will be deleted, and the iterator will be reset to apply to the
1101 *          fields in the formatted string created by this function call; the
1102 *          field values provided by {@link #ufieldpositer_next} will be from the
1103 *          UDateFormatField enum.
1104 * @param status
1105 *          A pointer to a UErrorCode to receive any errors
1106 * @return
1107 *          The total buffer size needed; if greater than resultLength, the output was truncated.
1108 * @see udat_format
1109 * @see udat_parseCalendar
1110 * @see UFieldPositionIterator
1111 * @stable ICU 55
1112 */
1113 U_CAPI int32_t U_EXPORT2
1114 udat_formatCalendarForFields( const UDateFormat* format,
1115                         UCalendar*      calendar,
1116                         UChar*          result,
1117                         int32_t         capacity,
1118                         UFieldPositionIterator* fpositer,
1119                         UErrorCode*     status);
1120 
1121 
1122 /**
1123 * Parse a string into an date/time using a UDateFormat.
1124 * The date will be parsed using the conventions specified in {@link #udat_open }.
1125 * &lt;P&gt;
1126 * Note that the normal date formats associated with some calendars - such
1127 * as the Chinese lunar calendar - do not specify enough fields to enable
1128 * dates to be parsed unambiguously. In the case of the Chinese lunar
1129 * calendar, while the year within the current 60-year cycle is specified,
1130 * the number of such cycles since the start date of the calendar (in the
1131 * UCAL_ERA field of the UCalendar object) is not normally part of the format,
1132 * and parsing may assume the wrong era. For cases such as this it is
1133 * recommended that clients parse using udat_parseCalendar with the UCalendar
1134 * passed in set to the current date, or to a date within the era/cycle that
1135 * should be assumed if absent in the format.
1136 *
1137 * @param format The formatter to use.
1138 * @param text The text to parse.
1139 * @param textLength The length of text, or -1 if null-terminated.
1140 * @param parsePos If not 0, on input a pointer to an integer specifying the offset at which
1141 * to begin parsing.  If not 0, on output the offset at which parsing ended.
1142 * @param status A pointer to an UErrorCode to receive any errors
1143 * @return The value of the parsed date/time
1144 * @see udat_format
1145 * @stable ICU 2.0
1146 */
1147 U_CAPI UDate U_EXPORT2
1148 udat_parse(const    UDateFormat*    format,
1149            const    UChar*          text,
1150                     int32_t         textLength,
1151                     int32_t         *parsePos,
1152                     UErrorCode      *status);
1153 
1154 /**
1155 * Parse a string into an date/time using a UDateFormat.
1156 * The date will be parsed using the conventions specified in {@link #udat_open }.
1157 * @param format The formatter to use.
1158 * @param calendar A calendar set on input to the date and time to be used for
1159 *                 missing values in the date/time string being parsed, and set
1160 *                 on output to the parsed date/time. When the calendar type is
1161 *                 different from the internal calendar held by the UDateFormat
1162 *                 instance, the internal calendar will be cloned to a work
1163 *                 calendar set to the same milliseconds and time zone as this
1164 *                 calendar parameter, field values will be parsed based on the
1165 *                 work calendar, then the result (milliseconds and time zone)
1166 *                 will be set in this calendar.
1167 * @param text The text to parse.
1168 * @param textLength The length of text, or -1 if null-terminated.
1169 * @param parsePos If not 0, on input a pointer to an integer specifying the offset at which
1170 * to begin parsing.  If not 0, on output the offset at which parsing ended.
1171 * @param status A pointer to an UErrorCode to receive any errors
1172 * @see udat_format
1173 * @stable ICU 2.0
1174 */
1175 U_CAPI void U_EXPORT2
1176 udat_parseCalendar(const    UDateFormat*    format,
1177                             UCalendar*      calendar,
1178                    const    UChar*          text,
1179                             int32_t         textLength,
1180                             int32_t         *parsePos,
1181                             UErrorCode      *status);
1182 
1183 /**
1184 * Determine if an UDateFormat will perform lenient parsing.
1185 * With lenient parsing, the parser may use heuristics to interpret inputs that do not
1186 * precisely match the pattern. With strict parsing, inputs must match the pattern.
1187 * @param fmt The formatter to query
1188 * @return TRUE if fmt is set to perform lenient parsing, FALSE otherwise.
1189 * @see udat_setLenient
1190 * @stable ICU 2.0
1191 */
1192 U_CAPI UBool U_EXPORT2
1193 udat_isLenient(const UDateFormat* fmt);
1194 
1195 /**
1196 * Specify whether an UDateFormat will perform lenient parsing.
1197 * With lenient parsing, the parser may use heuristics to interpret inputs that do not
1198 * precisely match the pattern. With strict parsing, inputs must match the pattern.
1199 * @param fmt The formatter to set
1200 * @param isLenient TRUE if fmt should perform lenient parsing, FALSE otherwise.
1201 * @see dat_isLenient
1202 * @stable ICU 2.0
1203 */
1204 U_CAPI void U_EXPORT2
1205 udat_setLenient(    UDateFormat*    fmt,
1206                     UBool          isLenient);
1207 
1208 /**
1209 * Get the UCalendar associated with an UDateFormat.
1210 * A UDateFormat uses a UCalendar to convert a raw value to, for example,
1211 * the day of the week.
1212 * @param fmt The formatter to query.
1213 * @return A pointer to the UCalendar used by fmt.
1214 * @see udat_setCalendar
1215 * @stable ICU 2.0
1216 */
1217 U_CAPI const UCalendar* U_EXPORT2
1218 udat_getCalendar(const UDateFormat* fmt);
1219 
1220 /**
1221 * Set the UCalendar associated with an UDateFormat.
1222 * A UDateFormat uses a UCalendar to convert a raw value to, for example,
1223 * the day of the week.
1224 * @param fmt The formatter to set.
1225 * @param calendarToSet A pointer to an UCalendar to be used by fmt.
1226 * @see udat_setCalendar
1227 * @stable ICU 2.0
1228 */
1229 U_CAPI void U_EXPORT2
1230 udat_setCalendar(            UDateFormat*    fmt,
1231                     const   UCalendar*      calendarToSet);
1232 
1233 /**
1234 * Get the UNumberFormat associated with an UDateFormat.
1235 * A UDateFormat uses a UNumberFormat to format numbers within a date,
1236 * for example the day number.
1237 * @param fmt The formatter to query.
1238 * @return A pointer to the UNumberFormat used by fmt to format numbers.
1239 * @see udat_setNumberFormat
1240 * @stable ICU 2.0
1241 */
1242 U_CAPI const UNumberFormat* U_EXPORT2
1243 udat_getNumberFormat(const UDateFormat* fmt);
1244 
1245 /**
1246 * Get the UNumberFormat for specific field associated with an UDateFormat.
1247 * For example: &#39;y&#39; for year and &#39;M&#39; for month
1248 * @param fmt The formatter to query.
1249 * @param field the field to query
1250 * @return A pointer to the UNumberFormat used by fmt to format field numbers.
1251 * @see udat_setNumberFormatForField
1252 * @stable ICU 54
1253 */
1254 U_CAPI const UNumberFormat* U_EXPORT2
1255 udat_getNumberFormatForField(const UDateFormat* fmt, UChar field);
1256 
1257 /**
1258 * Set the UNumberFormat for specific field associated with an UDateFormat.
1259 * It can be a single field like: &quot;y&quot;(year) or &quot;M&quot;(month)
1260 * It can be several field combined together: &quot;yM&quot;(year and month)
1261 * Note:
1262 * 1 symbol field is enough for multiple symbol field (so &quot;y&quot; will override &quot;yy&quot;, &quot;yyy&quot;)
1263 * If the field is not numeric, then override has no effect (like &quot;MMM&quot; will use abbreviation, not numerical field)
1264 *
1265 * @param fields the fields to set
1266 * @param fmt The formatter to set.
1267 * @param numberFormatToSet A pointer to the UNumberFormat to be used by fmt to format numbers.
1268 * @param status error code passed around (memory allocation or invalid fields)
1269 * @see udat_getNumberFormatForField
1270 * @stable ICU 54
1271 */
1272 U_CAPI void U_EXPORT2
1273 udat_adoptNumberFormatForFields(  UDateFormat* fmt,
1274                             const UChar* fields,
1275                                   UNumberFormat*  numberFormatToSet,
1276                                   UErrorCode* status);
1277 /**
1278 * Set the UNumberFormat associated with an UDateFormat.
1279 * A UDateFormat uses a UNumberFormat to format numbers within a date,
1280 * for example the day number.
1281 * This method also clears per field NumberFormat instances previously
1282 * set by {@see udat_setNumberFormatForField}
1283 * @param fmt The formatter to set.
1284 * @param numberFormatToSet A pointer to the UNumberFormat to be used by fmt to format numbers.
1285 * @see udat_getNumberFormat
1286 * @see udat_setNumberFormatForField
1287 * @stable ICU 2.0
1288 */
1289 U_CAPI void U_EXPORT2
1290 udat_setNumberFormat(            UDateFormat*    fmt,
1291                         const   UNumberFormat*  numberFormatToSet);
1292 /**
1293 * Adopt the UNumberFormat associated with an UDateFormat.
1294 * A UDateFormat uses a UNumberFormat to format numbers within a date,
1295 * for example the day number.
1296 * @param fmt The formatter to set.
1297 * @param numberFormatToAdopt A pointer to the UNumberFormat to be used by fmt to format numbers.
1298 * @see udat_getNumberFormat
1299 * @stable ICU 54
1300 */
1301 U_CAPI void U_EXPORT2
1302 udat_adoptNumberFormat(            UDateFormat*    fmt,
1303                                    UNumberFormat*  numberFormatToAdopt);
1304 /**
1305 * Get a locale for which date/time formatting patterns are available.
1306 * A UDateFormat in a locale returned by this function will perform the correct
1307 * formatting and parsing for the locale.
1308 * @param localeIndex The index of the desired locale.
1309 * @return A locale for which date/time formatting patterns are available, or 0 if none.
1310 * @see udat_countAvailable
1311 * @stable ICU 2.0
1312 */
1313 U_CAPI const char* U_EXPORT2
1314 udat_getAvailable(int32_t localeIndex);
1315 
1316 /**
1317 * Determine how many locales have date/time  formatting patterns available.
1318 * This function is most useful as determining the loop ending condition for
1319 * calls to {@link #udat_getAvailable }.
1320 * @return The number of locales for which date/time formatting patterns are available.
1321 * @see udat_getAvailable
1322 * @stable ICU 2.0
1323 */
1324 U_CAPI int32_t U_EXPORT2
1325 udat_countAvailable(void);
1326 
1327 /**
1328 * Get the year relative to which all 2-digit years are interpreted.
1329 * For example, if the 2-digit start year is 2100, the year 99 will be
1330 * interpreted as 2199.
1331 * @param fmt The formatter to query.
1332 * @param status A pointer to an UErrorCode to receive any errors
1333 * @return The year relative to which all 2-digit years are interpreted.
1334 * @see udat_Set2DigitYearStart
1335 * @stable ICU 2.0
1336 */
1337 U_CAPI UDate U_EXPORT2
1338 udat_get2DigitYearStart(    const   UDateFormat     *fmt,
1339                                     UErrorCode      *status);
1340 
1341 /**
1342 * Set the year relative to which all 2-digit years will be interpreted.
1343 * For example, if the 2-digit start year is 2100, the year 99 will be
1344 * interpreted as 2199.
1345 * @param fmt The formatter to set.
1346 * @param d The year relative to which all 2-digit years will be interpreted.
1347 * @param status A pointer to an UErrorCode to receive any errors
1348 * @see udat_Set2DigitYearStart
1349 * @stable ICU 2.0
1350 */
1351 U_CAPI void U_EXPORT2
1352 udat_set2DigitYearStart(    UDateFormat     *fmt,
1353                             UDate           d,
1354                             UErrorCode      *status);
1355 
1356 /**
1357 * Extract the pattern from a UDateFormat.
1358 * The pattern will follow the pattern syntax rules.
1359 * @param fmt The formatter to query.
1360 * @param localized TRUE if the pattern should be localized, FALSE otherwise.
1361 * @param result A pointer to a buffer to receive the pattern.
1362 * @param resultLength The maximum size of result.
1363 * @param status A pointer to an UErrorCode to receive any errors
1364 * @return The total buffer size needed; if greater than resultLength, the output was truncated.
1365 * @see udat_applyPattern
1366 * @stable ICU 2.0
1367 */
1368 U_CAPI int32_t U_EXPORT2
1369 udat_toPattern(    const   UDateFormat     *fmt,
1370                         UBool          localized,
1371                         UChar           *result,
1372                         int32_t         resultLength,
1373                         UErrorCode      *status);
1374 
1375 /**
1376 * Set the pattern used by an UDateFormat.
1377 * The pattern should follow the pattern syntax rules.
1378 * @param format The formatter to set.
1379 * @param localized TRUE if the pattern is localized, FALSE otherwise.
1380 * @param pattern The new pattern
1381 * @param patternLength The length of pattern, or -1 if null-terminated.
1382 * @see udat_toPattern
1383 * @stable ICU 2.0
1384 */
1385 U_CAPI void U_EXPORT2
1386 udat_applyPattern(            UDateFormat     *format,
1387                             UBool          localized,
1388                     const   UChar           *pattern,
1389                             int32_t         patternLength);
1390 
1391 /**
1392  * The possible types of date format symbols
1393  * @stable ICU 2.6
1394  */
1395 typedef enum UDateFormatSymbolType {
1396     /** The era names, for example AD */
1397     UDAT_ERAS,
1398     /** The month names, for example February */
1399     UDAT_MONTHS,
1400     /** The short month names, for example Feb. */
1401     UDAT_SHORT_MONTHS,
1402     /** The CLDR-style format &quot;wide&quot; weekday names, for example Monday */
1403     UDAT_WEEKDAYS,
1404     /**
1405      * The CLDR-style format &quot;abbreviated&quot; (not &quot;short&quot;) weekday names, for example &quot;Mon.&quot;
1406      * For the CLDR-style format &quot;short&quot; weekday names, use UDAT_SHORTER_WEEKDAYS.
1407      */
1408     UDAT_SHORT_WEEKDAYS,
1409     /** The AM/PM names, for example AM */
1410     UDAT_AM_PMS,
1411     /** The localized characters */
1412     UDAT_LOCALIZED_CHARS,
1413     /** The long era names, for example Anno Domini */
1414     UDAT_ERA_NAMES,
1415     /** The narrow month names, for example F */
1416     UDAT_NARROW_MONTHS,
1417     /** The CLDR-style format &quot;narrow&quot; weekday names, for example &quot;M&quot; */
1418     UDAT_NARROW_WEEKDAYS,
1419     /** Standalone context versions of months */
1420     UDAT_STANDALONE_MONTHS,
1421     UDAT_STANDALONE_SHORT_MONTHS,
1422     UDAT_STANDALONE_NARROW_MONTHS,
1423     /** The CLDR-style stand-alone &quot;wide&quot; weekday names */
1424     UDAT_STANDALONE_WEEKDAYS,
1425     /**
1426      * The CLDR-style stand-alone &quot;abbreviated&quot; (not &quot;short&quot;) weekday names.
1427      * For the CLDR-style stand-alone &quot;short&quot; weekday names, use UDAT_STANDALONE_SHORTER_WEEKDAYS.
1428      */
1429     UDAT_STANDALONE_SHORT_WEEKDAYS,
1430     /** The CLDR-style stand-alone &quot;narrow&quot; weekday names */
1431     UDAT_STANDALONE_NARROW_WEEKDAYS,
1432     /** The quarters, for example 1st Quarter */
1433     UDAT_QUARTERS,
1434     /** The short quarter names, for example Q1 */
1435     UDAT_SHORT_QUARTERS,
1436     /** Standalone context versions of quarters */
1437     UDAT_STANDALONE_QUARTERS,
1438     UDAT_STANDALONE_SHORT_QUARTERS,
1439     /**
1440      * The CLDR-style short weekday names, e.g. &quot;Su&quot;, Mo&quot;, etc.
1441      * These are named &quot;SHORTER&quot; to contrast with the constants using _SHORT_
1442      * above, which actually get the CLDR-style *abbreviated* versions of the
1443      * corresponding names.
1444      * @stable ICU 51
1445      */
1446     UDAT_SHORTER_WEEKDAYS,
1447     /**
1448      * Standalone version of UDAT_SHORTER_WEEKDAYS.
1449      * @stable ICU 51
1450      */
1451     UDAT_STANDALONE_SHORTER_WEEKDAYS,
1452     /**
1453      * Cyclic year names (only supported for some calendars, and only for FORMAT usage;
1454      * udat_setSymbols not supported for UDAT_CYCLIC_YEARS_WIDE)
1455      * @stable ICU 54
1456      */
1457     UDAT_CYCLIC_YEARS_WIDE,
1458     /**
1459      * Cyclic year names (only supported for some calendars, and only for FORMAT usage)
1460      * @stable ICU 54
1461      */
1462     UDAT_CYCLIC_YEARS_ABBREVIATED,
1463     /**
1464      * Cyclic year names (only supported for some calendars, and only for FORMAT usage;
1465      * udat_setSymbols not supported for UDAT_CYCLIC_YEARS_NARROW)
1466      * @stable ICU 54
1467      */
1468     UDAT_CYCLIC_YEARS_NARROW,
1469     /**
1470      * Calendar zodiac  names (only supported for some calendars, and only for FORMAT usage;
1471      * udat_setSymbols not supported for UDAT_ZODIAC_NAMES_WIDE)
1472      * @stable ICU 54
1473      */
1474     UDAT_ZODIAC_NAMES_WIDE,
1475     /**
1476      * Calendar zodiac  names (only supported for some calendars, and only for FORMAT usage)
1477      * @stable ICU 54
1478      */
1479     UDAT_ZODIAC_NAMES_ABBREVIATED,
1480     /**
1481      * Calendar zodiac  names (only supported for some calendars, and only for FORMAT usage;
1482      * udat_setSymbols not supported for UDAT_ZODIAC_NAMES_NARROW)
1483      * @stable ICU 54
1484      */
1485     UDAT_ZODIAC_NAMES_NARROW
1486 } UDateFormatSymbolType;
1487 
1488 struct UDateFormatSymbols;
1489 /** Date format symbols.
1490  *  For usage in C programs.
1491  *  @stable ICU 2.6
1492  */
1493 typedef struct UDateFormatSymbols UDateFormatSymbols;
1494 
1495 /**
1496 * Get the symbols associated with an UDateFormat.
1497 * The symbols are what a UDateFormat uses to represent locale-specific data,
1498 * for example month or day names.
1499 * @param fmt The formatter to query.
1500 * @param type The type of symbols to get.  One of UDAT_ERAS, UDAT_MONTHS, UDAT_SHORT_MONTHS,
1501 * UDAT_WEEKDAYS, UDAT_SHORT_WEEKDAYS, UDAT_AM_PMS, or UDAT_LOCALIZED_CHARS
1502 * @param symbolIndex The desired symbol of type type.
1503 * @param result A pointer to a buffer to receive the pattern.
1504 * @param resultLength The maximum size of result.
1505 * @param status A pointer to an UErrorCode to receive any errors
1506 * @return The total buffer size needed; if greater than resultLength, the output was truncated.
1507 * @see udat_countSymbols
1508 * @see udat_setSymbols
1509 * @stable ICU 2.0
1510 */
1511 U_CAPI int32_t U_EXPORT2
1512 udat_getSymbols(const   UDateFormat             *fmt,
1513                         UDateFormatSymbolType   type,
1514                         int32_t                 symbolIndex,
1515                         UChar                   *result,
1516                         int32_t                 resultLength,
1517                         UErrorCode              *status);
1518 
1519 /**
1520 * Count the number of particular symbols for an UDateFormat.
1521 * This function is most useful as for detemining the loop termination condition
1522 * for calls to {@link #udat_getSymbols }.
1523 * @param fmt The formatter to query.
1524 * @param type The type of symbols to count.  One of UDAT_ERAS, UDAT_MONTHS, UDAT_SHORT_MONTHS,
1525 * UDAT_WEEKDAYS, UDAT_SHORT_WEEKDAYS, UDAT_AM_PMS, or UDAT_LOCALIZED_CHARS
1526 * @return The number of symbols of type type.
1527 * @see udat_getSymbols
1528 * @see udat_setSymbols
1529 * @stable ICU 2.0
1530 */
1531 U_CAPI int32_t U_EXPORT2
1532 udat_countSymbols(    const    UDateFormat                *fmt,
1533                             UDateFormatSymbolType    type);
1534 
1535 /**
1536 * Set the symbols associated with an UDateFormat.
1537 * The symbols are what a UDateFormat uses to represent locale-specific data,
1538 * for example month or day names.
1539 * @param format The formatter to set
1540 * @param type The type of symbols to set.  One of UDAT_ERAS, UDAT_MONTHS, UDAT_SHORT_MONTHS,
1541 * UDAT_WEEKDAYS, UDAT_SHORT_WEEKDAYS, UDAT_AM_PMS, or UDAT_LOCALIZED_CHARS
1542 * @param symbolIndex The index of the symbol to set of type type.
1543 * @param value The new value
1544 * @param valueLength The length of value, or -1 if null-terminated
1545 * @param status A pointer to an UErrorCode to receive any errors
1546 * @see udat_getSymbols
1547 * @see udat_countSymbols
1548 * @stable ICU 2.0
1549 */
1550 U_CAPI void U_EXPORT2
1551 udat_setSymbols(    UDateFormat             *format,
1552                     UDateFormatSymbolType   type,
1553                     int32_t                 symbolIndex,
1554                     UChar                   *value,
1555                     int32_t                 valueLength,
1556                     UErrorCode              *status);
1557 
1558 /**
1559  * Get the locale for this date format object.
1560  * You can choose between valid and actual locale.
1561  * @param fmt The formatter to get the locale from
1562  * @param type type of the locale we&#39;re looking for (valid or actual)
1563  * @param status error code for the operation
1564  * @return the locale name
1565  * @stable ICU 2.8
1566  */
1567 U_CAPI const char* U_EXPORT2
1568 udat_getLocaleByType(const UDateFormat *fmt,
1569                      ULocDataLocaleType type,
1570                      UErrorCode* status);
1571 
1572 /**
1573  * Set a particular UDisplayContext value in the formatter, such as
1574  * UDISPCTX_CAPITALIZATION_FOR_STANDALONE.
1575  * @param fmt The formatter for which to set a UDisplayContext value.
1576  * @param value The UDisplayContext value to set.
1577  * @param status A pointer to an UErrorCode to receive any errors
1578  * @stable ICU 51
1579  */
1580 U_CAPI void U_EXPORT2
1581 udat_setContext(UDateFormat* fmt, UDisplayContext value, UErrorCode* status);
1582 
1583 /**
1584  * Get the formatter&#39;s UDisplayContext value for the specified UDisplayContextType,
1585  * such as UDISPCTX_TYPE_CAPITALIZATION.
1586  * @param fmt The formatter to query.
1587  * @param type The UDisplayContextType whose value to return
1588  * @param status A pointer to an UErrorCode to receive any errors
1589  * @return The UDisplayContextValue for the specified type.
1590  * @stable ICU 53
1591  */
1592 U_CAPI UDisplayContext U_EXPORT2
1593 udat_getContext(const UDateFormat* fmt, UDisplayContextType type, UErrorCode* status);
1594 
1595 #ifndef U_HIDE_INTERNAL_API
1596 /**
1597 * Extract the date pattern from a UDateFormat set for relative date formatting.
1598 * The pattern will follow the pattern syntax rules.
1599 * @param fmt The formatter to query.
1600 * @param result A pointer to a buffer to receive the pattern.
1601 * @param resultLength The maximum size of result.
1602 * @param status A pointer to a UErrorCode to receive any errors
1603 * @return The total buffer size needed; if greater than resultLength, the output was truncated.
1604 * @see udat_applyPatternRelative
1605 * @internal ICU 4.2 technology preview
1606 */
1607 U_INTERNAL int32_t U_EXPORT2
1608 udat_toPatternRelativeDate(const UDateFormat *fmt,
1609                            UChar             *result,
1610                            int32_t           resultLength,
1611                            UErrorCode        *status);
1612 
1613 /**
1614 * Extract the time pattern from a UDateFormat set for relative date formatting.
1615 * The pattern will follow the pattern syntax rules.
1616 * @param fmt The formatter to query.
1617 * @param result A pointer to a buffer to receive the pattern.
1618 * @param resultLength The maximum size of result.
1619 * @param status A pointer to a UErrorCode to receive any errors
1620 * @return The total buffer size needed; if greater than resultLength, the output was truncated.
1621 * @see udat_applyPatternRelative
1622 * @internal ICU 4.2 technology preview
1623 */
1624 U_INTERNAL int32_t U_EXPORT2
1625 udat_toPatternRelativeTime(const UDateFormat *fmt,
1626                            UChar             *result,
1627                            int32_t           resultLength,
1628                            UErrorCode        *status);
1629 
1630 /**
1631 * Set the date &amp; time patterns used by a UDateFormat set for relative date formatting.
1632 * The patterns should follow the pattern syntax rules.
1633 * @param format The formatter to set.
1634 * @param datePattern The new date pattern
1635 * @param datePatternLength The length of datePattern, or -1 if null-terminated.
1636 * @param timePattern The new time pattern
1637 * @param timePatternLength The length of timePattern, or -1 if null-terminated.
1638 * @param status A pointer to a UErrorCode to receive any errors
1639 * @see udat_toPatternRelativeDate, udat_toPatternRelativeTime
1640 * @internal ICU 4.2 technology preview
1641 */
1642 U_INTERNAL void U_EXPORT2
1643 udat_applyPatternRelative(UDateFormat *format,
1644                           const UChar *datePattern,
1645                           int32_t     datePatternLength,
1646                           const UChar *timePattern,
1647                           int32_t     timePatternLength,
1648                           UErrorCode  *status);
1649 
1650 /**
1651  * @internal
1652  * @see udat_open
1653  */
1654 typedef UDateFormat* (U_EXPORT2 *UDateFormatOpener) (UDateFormatStyle  timeStyle,
1655                                                     UDateFormatStyle  dateStyle,
1656                                                     const char        *locale,
1657                                                     const UChar       *tzID,
1658                                                     int32_t           tzIDLength,
1659                                                     const UChar       *pattern,
1660                                                     int32_t           patternLength,
1661                                                     UErrorCode        *status);
1662 
1663 /**
1664  * Register a provider factory
1665  * @internal ICU 49
1666  */
1667 U_INTERNAL void U_EXPORT2
1668 udat_registerOpener(UDateFormatOpener opener, UErrorCode *status);
1669 
1670 /**
1671  * Un-Register a provider factory
1672  * @internal ICU 49
1673  */
1674 U_INTERNAL UDateFormatOpener U_EXPORT2
1675 udat_unregisterOpener(UDateFormatOpener opener, UErrorCode *status);
1676 #endif  /* U_HIDE_INTERNAL_API */
1677 
1678 
1679 #endif /* #if !UCONFIG_NO_FORMATTING */
1680 
1681 #endif
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>