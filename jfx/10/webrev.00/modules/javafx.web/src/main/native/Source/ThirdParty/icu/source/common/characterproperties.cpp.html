<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/characterproperties.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2018 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 
  4 // characterproperties.cpp
  5 // created: 2018sep03 Markus W. Scherer
  6 
  7 #include &quot;unicode/utypes.h&quot;
  8 #include &quot;unicode/localpointer.h&quot;
  9 #include &quot;unicode/uchar.h&quot;
 10 #include &quot;unicode/ucpmap.h&quot;
 11 #include &quot;unicode/ucptrie.h&quot;
 12 #include &quot;unicode/umutablecptrie.h&quot;
 13 #include &quot;unicode/uniset.h&quot;
 14 #include &quot;unicode/uscript.h&quot;
 15 #include &quot;unicode/uset.h&quot;
 16 #include &quot;cmemory.h&quot;
 17 #include &quot;mutex.h&quot;
 18 #include &quot;normalizer2impl.h&quot;
 19 #include &quot;uassert.h&quot;
 20 #include &quot;ubidi_props.h&quot;
 21 #include &quot;ucase.h&quot;
 22 #include &quot;ucln_cmn.h&quot;
 23 #include &quot;umutex.h&quot;
 24 #include &quot;uprops.h&quot;
 25 
 26 using icu::LocalPointer;
 27 #if !UCONFIG_NO_NORMALIZATION
 28 using icu::Normalizer2Factory;
 29 using icu::Normalizer2Impl;
 30 #endif
 31 using icu::UInitOnce;
 32 using icu::UnicodeSet;
 33 
 34 namespace {
 35 
 36 UBool U_CALLCONV characterproperties_cleanup();
 37 
 38 constexpr int32_t NUM_INCLUSIONS = UPROPS_SRC_COUNT + UCHAR_INT_LIMIT - UCHAR_INT_START;
 39 
 40 struct Inclusion {
 41     UnicodeSet  *fSet;
 42     UInitOnce    fInitOnce;
 43 };
 44 Inclusion gInclusions[NUM_INCLUSIONS]; // cached getInclusions()
 45 
 46 UnicodeSet *sets[UCHAR_BINARY_LIMIT] = {};
 47 
 48 UCPMap *maps[UCHAR_INT_LIMIT - UCHAR_INT_START] = {};
 49 
 50 icu::UMutex *cpMutex() {
 51     static icu::UMutex m = U_MUTEX_INITIALIZER;
 52     return &amp;m;
 53 }
 54 
 55 //----------------------------------------------------------------
 56 // Inclusions list
 57 //----------------------------------------------------------------
 58 
 59 // USetAdder implementation
 60 // Does not use uset.h to reduce code dependencies
 61 void U_CALLCONV
 62 _set_add(USet *set, UChar32 c) {
 63     ((UnicodeSet *)set)-&gt;add(c);
 64 }
 65 
 66 void U_CALLCONV
 67 _set_addRange(USet *set, UChar32 start, UChar32 end) {
 68     ((UnicodeSet *)set)-&gt;add(start, end);
 69 }
 70 
 71 void U_CALLCONV
 72 _set_addString(USet *set, const UChar *str, int32_t length) {
 73     ((UnicodeSet *)set)-&gt;add(icu::UnicodeString((UBool)(length&lt;0), str, length));
 74 }
 75 
 76 UBool U_CALLCONV characterproperties_cleanup() {
 77     for (Inclusion &amp;in: gInclusions) {
 78         delete in.fSet;
 79         in.fSet = nullptr;
 80         in.fInitOnce.reset();
 81     }
 82     for (int32_t i = 0; i &lt; UPRV_LENGTHOF(sets); ++i) {
 83         delete sets[i];
 84         sets[i] = nullptr;
 85     }
 86     for (int32_t i = 0; i &lt; UPRV_LENGTHOF(maps); ++i) {
 87         ucptrie_close(reinterpret_cast&lt;UCPTrie *&gt;(maps[i]));
 88         maps[i] = nullptr;
 89     }
 90     return TRUE;
 91 }
 92 
 93 void U_CALLCONV initInclusion(UPropertySource src, UErrorCode &amp;errorCode) {
 94     // This function is invoked only via umtx_initOnce().
 95     U_ASSERT(0 &lt;= src &amp;&amp; src &lt; UPROPS_SRC_COUNT);
 96     if (src == UPROPS_SRC_NONE) {
 97         errorCode = U_INTERNAL_PROGRAM_ERROR;
 98         return;
 99     }
100     U_ASSERT(gInclusions[src].fSet == nullptr);
101 
102     LocalPointer&lt;UnicodeSet&gt; incl(new UnicodeSet());
103     if (incl.isNull()) {
104         errorCode = U_MEMORY_ALLOCATION_ERROR;
105         return;
106     }
107     USetAdder sa = {
108         (USet *)incl.getAlias(),
109         _set_add,
110         _set_addRange,
111         _set_addString,
112         nullptr, // don&#39;t need remove()
113         nullptr // don&#39;t need removeRange()
114     };
115 
116     switch(src) {
117     case UPROPS_SRC_CHAR:
118         uchar_addPropertyStarts(&amp;sa, &amp;errorCode);
119         break;
120     case UPROPS_SRC_PROPSVEC:
121         upropsvec_addPropertyStarts(&amp;sa, &amp;errorCode);
122         break;
123     case UPROPS_SRC_CHAR_AND_PROPSVEC:
124         uchar_addPropertyStarts(&amp;sa, &amp;errorCode);
125         upropsvec_addPropertyStarts(&amp;sa, &amp;errorCode);
126         break;
127 #if !UCONFIG_NO_NORMALIZATION
128     case UPROPS_SRC_CASE_AND_NORM: {
129         const Normalizer2Impl *impl=Normalizer2Factory::getNFCImpl(errorCode);
130         if(U_SUCCESS(errorCode)) {
131             impl-&gt;addPropertyStarts(&amp;sa, errorCode);
132         }
133         ucase_addPropertyStarts(&amp;sa, &amp;errorCode);
134         break;
135     }
136     case UPROPS_SRC_NFC: {
137         const Normalizer2Impl *impl=Normalizer2Factory::getNFCImpl(errorCode);
138         if(U_SUCCESS(errorCode)) {
139             impl-&gt;addPropertyStarts(&amp;sa, errorCode);
140         }
141         break;
142     }
143     case UPROPS_SRC_NFKC: {
144         const Normalizer2Impl *impl=Normalizer2Factory::getNFKCImpl(errorCode);
145         if(U_SUCCESS(errorCode)) {
146             impl-&gt;addPropertyStarts(&amp;sa, errorCode);
147         }
148         break;
149     }
150     case UPROPS_SRC_NFKC_CF: {
151         const Normalizer2Impl *impl=Normalizer2Factory::getNFKC_CFImpl(errorCode);
152         if(U_SUCCESS(errorCode)) {
153             impl-&gt;addPropertyStarts(&amp;sa, errorCode);
154         }
155         break;
156     }
157     case UPROPS_SRC_NFC_CANON_ITER: {
158         const Normalizer2Impl *impl=Normalizer2Factory::getNFCImpl(errorCode);
159         if(U_SUCCESS(errorCode)) {
160             impl-&gt;addCanonIterPropertyStarts(&amp;sa, errorCode);
161         }
162         break;
163     }
164 #endif
165     case UPROPS_SRC_CASE:
166         ucase_addPropertyStarts(&amp;sa, &amp;errorCode);
167         break;
168     case UPROPS_SRC_BIDI:
169         ubidi_addPropertyStarts(&amp;sa, &amp;errorCode);
170         break;
171     case UPROPS_SRC_INPC:
172     case UPROPS_SRC_INSC:
173     case UPROPS_SRC_VO:
174         uprops_addPropertyStarts((UPropertySource)src, &amp;sa, &amp;errorCode);
175         break;
176     default:
177         errorCode = U_INTERNAL_PROGRAM_ERROR;
178         break;
179     }
180 
181     if (U_FAILURE(errorCode)) {
182         return;
183     }
184     if (incl-&gt;isBogus()) {
185         errorCode = U_MEMORY_ALLOCATION_ERROR;
186         return;
187     }
188     // Compact for caching.
189     incl-&gt;compact();
190     gInclusions[src].fSet = incl.orphan();
191     ucln_common_registerCleanup(UCLN_COMMON_CHARACTERPROPERTIES, characterproperties_cleanup);
192 }
193 
194 const UnicodeSet *getInclusionsForSource(UPropertySource src, UErrorCode &amp;errorCode) {
195     if (U_FAILURE(errorCode)) { return nullptr; }
196     if (src &lt; 0 || UPROPS_SRC_COUNT &lt;= src) {
197         errorCode = U_ILLEGAL_ARGUMENT_ERROR;
198         return nullptr;
199     }
200     Inclusion &amp;i = gInclusions[src];
201     umtx_initOnce(i.fInitOnce, &amp;initInclusion, src, errorCode);
202     return i.fSet;
203 }
204 
205 void U_CALLCONV initIntPropInclusion(UProperty prop, UErrorCode &amp;errorCode) {
206     // This function is invoked only via umtx_initOnce().
207     U_ASSERT(UCHAR_INT_START &lt;= prop &amp;&amp; prop &lt; UCHAR_INT_LIMIT);
208     int32_t inclIndex = UPROPS_SRC_COUNT + prop - UCHAR_INT_START;
209     U_ASSERT(gInclusions[inclIndex].fSet == nullptr);
210     UPropertySource src = uprops_getSource(prop);
211     const UnicodeSet *incl = getInclusionsForSource(src, errorCode);
212     if (U_FAILURE(errorCode)) {
213         return;
214     }
215 
216     LocalPointer&lt;UnicodeSet&gt; intPropIncl(new UnicodeSet(0, 0));
217     if (intPropIncl.isNull()) {
218         errorCode = U_MEMORY_ALLOCATION_ERROR;
219         return;
220     }
221     int32_t numRanges = incl-&gt;getRangeCount();
222     int32_t prevValue = 0;
223     for (int32_t i = 0; i &lt; numRanges; ++i) {
224         UChar32 rangeEnd = incl-&gt;getRangeEnd(i);
225         for (UChar32 c = incl-&gt;getRangeStart(i); c &lt;= rangeEnd; ++c) {
226             // TODO: Get a UCharacterProperty.IntProperty to avoid the property dispatch.
227             int32_t value = u_getIntPropertyValue(c, prop);
228             if (value != prevValue) {
229                 intPropIncl-&gt;add(c);
230                 prevValue = value;
231             }
232         }
233     }
234 
235     if (intPropIncl-&gt;isBogus()) {
236         errorCode = U_MEMORY_ALLOCATION_ERROR;
237         return;
238     }
239     // Compact for caching.
240     intPropIncl-&gt;compact();
241     gInclusions[inclIndex].fSet = intPropIncl.orphan();
242     ucln_common_registerCleanup(UCLN_COMMON_CHARACTERPROPERTIES, characterproperties_cleanup);
243 }
244 
245 }  // namespace
246 
247 U_NAMESPACE_BEGIN
248 
249 const UnicodeSet *CharacterProperties::getInclusionsForProperty(
250         UProperty prop, UErrorCode &amp;errorCode) {
251     if (U_FAILURE(errorCode)) { return nullptr; }
252     if (UCHAR_INT_START &lt;= prop &amp;&amp; prop &lt; UCHAR_INT_LIMIT) {
253         int32_t inclIndex = UPROPS_SRC_COUNT + prop - UCHAR_INT_START;
254         Inclusion &amp;i = gInclusions[inclIndex];
255         umtx_initOnce(i.fInitOnce, &amp;initIntPropInclusion, prop, errorCode);
256         return i.fSet;
257     } else {
258         UPropertySource src = uprops_getSource(prop);
259         return getInclusionsForSource(src, errorCode);
260     }
261 }
262 
263 U_NAMESPACE_END
264 
265 namespace {
266 
267 UnicodeSet *makeSet(UProperty property, UErrorCode &amp;errorCode) {
268     if (U_FAILURE(errorCode)) { return nullptr; }
269     LocalPointer&lt;UnicodeSet&gt; set(new UnicodeSet());
270     if (set.isNull()) {
271         errorCode = U_MEMORY_ALLOCATION_ERROR;
272         return nullptr;
273     }
274     const UnicodeSet *inclusions =
275         icu::CharacterProperties::getInclusionsForProperty(property, errorCode);
276     if (U_FAILURE(errorCode)) { return nullptr; }
277     int32_t numRanges = inclusions-&gt;getRangeCount();
278     UChar32 startHasProperty = -1;
279 
280     for (int32_t i = 0; i &lt; numRanges; ++i) {
281         UChar32 rangeEnd = inclusions-&gt;getRangeEnd(i);
282         for (UChar32 c = inclusions-&gt;getRangeStart(i); c &lt;= rangeEnd; ++c) {
283             // TODO: Get a UCharacterProperty.BinaryProperty to avoid the property dispatch.
284             if (u_hasBinaryProperty(c, property)) {
285                 if (startHasProperty &lt; 0) {
286                     // Transition from false to true.
287                     startHasProperty = c;
288                 }
289             } else if (startHasProperty &gt;= 0) {
290                 // Transition from true to false.
291                 set-&gt;add(startHasProperty, c - 1);
292                 startHasProperty = -1;
293             }
294         }
295     }
296     if (startHasProperty &gt;= 0) {
297         set-&gt;add(startHasProperty, 0x10FFFF);
298     }
299     set-&gt;freeze();
300     return set.orphan();
301 }
302 
303 UCPMap *makeMap(UProperty property, UErrorCode &amp;errorCode) {
304     if (U_FAILURE(errorCode)) { return nullptr; }
305     uint32_t nullValue = property == UCHAR_SCRIPT ? USCRIPT_UNKNOWN : 0;
306     icu::LocalUMutableCPTriePointer mutableTrie(
307         umutablecptrie_open(nullValue, nullValue, &amp;errorCode));
308     const UnicodeSet *inclusions =
309         icu::CharacterProperties::getInclusionsForProperty(property, errorCode);
310     if (U_FAILURE(errorCode)) { return nullptr; }
311     int32_t numRanges = inclusions-&gt;getRangeCount();
312     UChar32 start = 0;
313     uint32_t value = nullValue;
314 
315     for (int32_t i = 0; i &lt; numRanges; ++i) {
316         UChar32 rangeEnd = inclusions-&gt;getRangeEnd(i);
317         for (UChar32 c = inclusions-&gt;getRangeStart(i); c &lt;= rangeEnd; ++c) {
318             // TODO: Get a UCharacterProperty.IntProperty to avoid the property dispatch.
319             uint32_t nextValue = u_getIntPropertyValue(c, property);
320             if (value != nextValue) {
321                 if (value != nullValue) {
322                     umutablecptrie_setRange(mutableTrie.getAlias(), start, c - 1, value, &amp;errorCode);
323                 }
324                 start = c;
325                 value = nextValue;
326             }
327         }
328     }
329     if (value != 0) {
330         umutablecptrie_setRange(mutableTrie.getAlias(), start, 0x10FFFF, value, &amp;errorCode);
331     }
332 
333     UCPTrieType type;
334     if (property == UCHAR_BIDI_CLASS || property == UCHAR_GENERAL_CATEGORY) {
335         type = UCPTRIE_TYPE_FAST;
336     } else {
337         type = UCPTRIE_TYPE_SMALL;
338     }
339     UCPTrieValueWidth valueWidth;
340     // TODO: UCharacterProperty.IntProperty
341     int32_t max = u_getIntPropertyMaxValue(property);
342     if (max &lt;= 0xff) {
343         valueWidth = UCPTRIE_VALUE_BITS_8;
344     } else if (max &lt;= 0xffff) {
345         valueWidth = UCPTRIE_VALUE_BITS_16;
346     } else {
347         valueWidth = UCPTRIE_VALUE_BITS_32;
348     }
349     return reinterpret_cast&lt;UCPMap *&gt;(
350         umutablecptrie_buildImmutable(mutableTrie.getAlias(), type, valueWidth, &amp;errorCode));
351 }
352 
353 }  // namespace
354 
355 U_NAMESPACE_USE
356 
357 U_CAPI const USet * U_EXPORT2
358 u_getBinaryPropertySet(UProperty property, UErrorCode *pErrorCode) {
359     if (U_FAILURE(*pErrorCode)) { return nullptr; }
360     if (property &lt; 0 || UCHAR_BINARY_LIMIT &lt;= property) {
361         *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
362         return nullptr;
363     }
364     Mutex m(cpMutex());
365     UnicodeSet *set = sets[property];
366     if (set == nullptr) {
367         sets[property] = set = makeSet(property, *pErrorCode);
368     }
369     if (U_FAILURE(*pErrorCode)) { return nullptr; }
370     return set-&gt;toUSet();
371 }
372 
373 U_CAPI const UCPMap * U_EXPORT2
374 u_getIntPropertyMap(UProperty property, UErrorCode *pErrorCode) {
375     if (U_FAILURE(*pErrorCode)) { return nullptr; }
376     if (property &lt; UCHAR_INT_START || UCHAR_INT_LIMIT &lt;= property) {
377         *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
378         return nullptr;
379     }
380     Mutex m(cpMutex());
381     UCPMap *map = maps[property - UCHAR_INT_START];
382     if (map == nullptr) {
383         maps[property - UCHAR_INT_START] = map = makeMap(property, *pErrorCode);
384     }
385     return map;
386 }
    </pre>
  </body>
</html>