diff a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_mapper.cpp b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_mapper.cpp
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_mapper.cpp
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_mapper.cpp
@@ -78,12 +78,14 @@
     ///////////
     // UNITS //
     ///////////
 
     bool useCurrency = (
-            !properties.currency.isNull() || !properties.currencyPluralInfo.fPtr.isNull() ||
-            !properties.currencyUsage.isNull() || affixProvider->hasCurrencySign());
+            !properties.currency.isNull() ||
+            !properties.currencyPluralInfo.fPtr.isNull() ||
+            !properties.currencyUsage.isNull() ||
+            affixProvider->hasCurrencySign());
     CurrencyUnit currency = resolveCurrency(properties, locale, status);
     UCurrencyUsage currencyUsage = properties.currencyUsage.getOrDefault(UCURR_USAGE_STANDARD);
     if (useCurrency) {
         // NOTE: Slicing is OK.
         macros.unit = currency; // NOLINT
@@ -139,11 +141,15 @@
     }
     Precision precision;
     if (!properties.currencyUsage.isNull()) {
         precision = Precision::constructCurrency(currencyUsage).withCurrency(currency);
     } else if (roundingIncrement != 0.0) {
-        precision = Precision::constructIncrement(roundingIncrement, minFrac);
+        if (PatternStringUtils::ignoreRoundingIncrement(roundingIncrement, maxFrac)) {
+            precision = Precision::constructFraction(minFrac, maxFrac);
+        } else {
+            precision = Precision::constructIncrement(roundingIncrement, minFrac);
+        }
     } else if (explicitMinMaxSig) {
         minSig = minSig < 1 ? 1 : minSig > kMaxIntFracSig ? kMaxIntFracSig : minSig;
         maxSig = maxSig < 0 ? kMaxIntFracSig : maxSig < minSig ? minSig : maxSig > kMaxIntFracSig
                                                                           ? kMaxIntFracSig : maxSig;
         precision = Precision::constructSignificant(minSig, maxSig);
@@ -151,11 +157,11 @@
         precision = Precision::constructFraction(minFrac, maxFrac);
     } else if (useCurrency) {
         precision = Precision::constructCurrency(currencyUsage);
     }
     if (!precision.isBogus()) {
-        precision = precision.withMode(roundingMode);
+        precision.fRoundingMode = roundingMode;
         macros.precision = precision;
     }
 
     ///////////////////
     // INTEGER WIDTH //
@@ -174,11 +180,11 @@
 
     /////////////
     // PADDING //
     /////////////
 
-    if (properties.formatWidth != -1) {
+    if (properties.formatWidth > 0) {
         macros.padder = Padder::forProperties(properties);
     }
 
     ///////////////////////////////
     // DECIMAL MARK ALWAYS SHOWN //
@@ -223,26 +229,33 @@
                 properties.exponentSignAlwaysShown ? UNUM_SIGN_ALWAYS : UNUM_SIGN_AUTO);
         // Scientific notation also involves overriding the rounding mode.
         // TODO: Overriding here is a bit of a hack. Should this logic go earlier?
         if (macros.precision.fType == Precision::PrecisionType::RND_FRACTION) {
             // For the purposes of rounding, get the original min/max int/frac, since the local
-            // variables
-            // have been manipulated for display purposes.
+            // variables have been manipulated for display purposes.
+            int maxInt_ = properties.maximumIntegerDigits;
             int minInt_ = properties.minimumIntegerDigits;
             int minFrac_ = properties.minimumFractionDigits;
             int maxFrac_ = properties.maximumFractionDigits;
             if (minInt_ == 0 && maxFrac_ == 0) {
                 // Patterns like "#E0" and "##E0", which mean no rounding!
-                macros.precision = Precision::unlimited().withMode(roundingMode);
+                macros.precision = Precision::unlimited();
             } else if (minInt_ == 0 && minFrac_ == 0) {
                 // Patterns like "#.##E0" (no zeros in the mantissa), which mean round to maxFrac+1
-                macros.precision = Precision::constructSignificant(1, maxFrac_ + 1).withMode(roundingMode);
+                macros.precision = Precision::constructSignificant(1, maxFrac_ + 1);
             } else {
-                // All other scientific patterns, which mean round to minInt+maxFrac
-                macros.precision = Precision::constructSignificant(
-                        minInt_ + minFrac_, minInt_ + maxFrac_).withMode(roundingMode);
+                int maxSig_ = minInt_ + maxFrac_;
+                // Bug #20058: if maxInt_ > minInt_ > 1, then minInt_ should be 1.
+                if (maxInt_ > minInt_ && minInt_ > 1) {
+                    minInt_ = 1;
+                }
+                int minSig_ = minInt_ + minFrac_;
+                // To avoid regression, maxSig is not reset when minInt_ set to 1.
+                // TODO: Reset maxSig_ = 1 + minFrac_ to follow the spec.
+                macros.precision = Precision::constructSignificant(minSig_, maxSig_);
             }
+            macros.precision.fRoundingMode = roundingMode;
         }
     }
 
     //////////////////////
     // COMPACT NOTATION //
@@ -287,11 +300,13 @@
         int maxSig_ = maxSig;
         double increment_ = 0.0;
         if (rounding_.fType == Precision::PrecisionType::RND_FRACTION) {
             minFrac_ = rounding_.fUnion.fracSig.fMinFrac;
             maxFrac_ = rounding_.fUnion.fracSig.fMaxFrac;
-        } else if (rounding_.fType == Precision::PrecisionType::RND_INCREMENT) {
+        } else if (rounding_.fType == Precision::PrecisionType::RND_INCREMENT
+                || rounding_.fType == Precision::PrecisionType::RND_INCREMENT_ONE
+                || rounding_.fType == Precision::PrecisionType::RND_INCREMENT_FIVE) {
             increment_ = rounding_.fUnion.increment.fIncrement;
             minFrac_ = rounding_.fUnion.increment.fMinFrac;
             maxFrac_ = rounding_.fUnion.increment.fMinFrac;
         } else if (rounding_.fType == Precision::PrecisionType::RND_SIGNIFICANT) {
             minSig_ = rounding_.fUnion.fracSig.fMinSig;
@@ -307,23 +322,21 @@
 
     return macros;
 }
 
 
-void PropertiesAffixPatternProvider::setTo(const DecimalFormatProperties& properties, UErrorCode&) {
+void PropertiesAffixPatternProvider::setTo(const DecimalFormatProperties& properties, UErrorCode& status) {
     fBogus = false;
 
     // There are two ways to set affixes in DecimalFormat: via the pattern string (applyPattern), and via the
     // explicit setters (setPositivePrefix and friends).  The way to resolve the settings is as follows:
     //
     // 1) If the explicit setting is present for the field, use it.
     // 2) Otherwise, follows UTS 35 rules based on the pattern string.
     //
     // Importantly, the explicit setters affect only the one field they override.  If you set the positive
-    // prefix, that should not affect the negative prefix.  Since it is impossible for the user of this class
-    // to know whether the origin for a string was the override or the pattern, we have to say that we always
-    // have a negative subpattern and perform all resolution logic here.
+    // prefix, that should not affect the negative prefix.
 
     // Convenience: Extract the properties into local variables.
     // Variables are named with three chars: [p/n][p/s][o/p]
     // [p/n] => p for positive, n for negative
     // [p/s] => p for prefix, s for suffix
@@ -371,10 +384,18 @@
         negSuffix = nsp;
     } else {
         // UTS 35: Default negative prefix is the positive prefix.
         negSuffix = psp.isBogus() ? u"" : psp;
     }
+
+    // For declaring if this is a currency pattern, we need to look at the
+    // original pattern, not at any user-specified overrides.
+    isCurrencyPattern = (
+        AffixUtils::hasCurrencySymbols(ppp, status) ||
+        AffixUtils::hasCurrencySymbols(psp, status) ||
+        AffixUtils::hasCurrencySymbols(npp, status) ||
+        AffixUtils::hasCurrencySymbols(nsp, status));
 }
 
 char16_t PropertiesAffixPatternProvider::charAt(int flags, int i) const {
     return getStringInternal(flags).charAt(i);
 }
@@ -407,26 +428,25 @@
     return AffixUtils::containsType(posPrefix, TYPE_PLUS_SIGN, localStatus) ||
            AffixUtils::containsType(posSuffix, TYPE_PLUS_SIGN, localStatus);
 }
 
 bool PropertiesAffixPatternProvider::hasNegativeSubpattern() const {
-    // See comments in the constructor for more information on why this is always true.
-    return true;
+    return (
+        (negSuffix != posSuffix) ||
+        negPrefix.tempSubString(1) != posPrefix ||
+        negPrefix.charAt(0) != u'-'
+    );
 }
 
 bool PropertiesAffixPatternProvider::negativeHasMinusSign() const {
     ErrorCode localStatus;
     return AffixUtils::containsType(negPrefix, TYPE_MINUS_SIGN, localStatus) ||
            AffixUtils::containsType(negSuffix, TYPE_MINUS_SIGN, localStatus);
 }
 
 bool PropertiesAffixPatternProvider::hasCurrencySign() const {
-    ErrorCode localStatus;
-    return AffixUtils::hasCurrencySymbols(posPrefix, localStatus) ||
-           AffixUtils::hasCurrencySymbols(posSuffix, localStatus) ||
-           AffixUtils::hasCurrencySymbols(negPrefix, localStatus) ||
-           AffixUtils::hasCurrencySymbols(negSuffix, localStatus);
+    return isCurrencyPattern;
 }
 
 bool PropertiesAffixPatternProvider::containsSymbolType(AffixPatternType type, UErrorCode& status) const {
     return AffixUtils::containsType(posPrefix, type, status) ||
            AffixUtils::containsType(posSuffix, type, status) ||
