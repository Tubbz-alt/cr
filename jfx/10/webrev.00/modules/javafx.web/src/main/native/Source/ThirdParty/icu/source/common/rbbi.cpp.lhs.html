<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/rbbi.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ***************************************************************************
   5 *   Copyright (C) 1999-2016 International Business Machines Corporation
   6 *   and others. All rights reserved.
   7 ***************************************************************************
   8 */
   9 //
  10 //  file:  rbbi.cpp  Contains the implementation of the rule based break iterator
  11 //                   runtime engine and the API implementation for
  12 //                   class RuleBasedBreakIterator
  13 //
  14 
  15 #include &quot;utypeinfo.h&quot;  // for &#39;typeid&#39; to work
  16 
  17 #include &quot;unicode/utypes.h&quot;
  18 
  19 #if !UCONFIG_NO_BREAK_ITERATION
  20 
<a name="1" id="anc1"></a>

  21 #include &quot;unicode/rbbi.h&quot;
  22 #include &quot;unicode/schriter.h&quot;
  23 #include &quot;unicode/uchriter.h&quot;
  24 #include &quot;unicode/uclean.h&quot;
  25 #include &quot;unicode/udata.h&quot;
  26 
  27 #include &quot;brkeng.h&quot;
  28 #include &quot;ucln_cmn.h&quot;
  29 #include &quot;cmemory.h&quot;
  30 #include &quot;cstring.h&quot;
<a name="2" id="anc2"></a>
  31 #include &quot;rbbidata.h&quot;
  32 #include &quot;rbbi_cache.h&quot;
  33 #include &quot;rbbirb.h&quot;
  34 #include &quot;uassert.h&quot;
  35 #include &quot;umutex.h&quot;
  36 #include &quot;uvectr32.h&quot;
  37 
<a name="3" id="anc3"></a><span class="line-removed">  38 // if U_LOCAL_SERVICE_HOOK is defined, then localsvc.cpp is expected to be included.</span>
<span class="line-removed">  39 #if U_LOCAL_SERVICE_HOOK</span>
<span class="line-removed">  40 #include &quot;localsvc.h&quot;</span>
<span class="line-removed">  41 #endif</span>
<span class="line-removed">  42 </span>
  43 #ifdef RBBI_DEBUG
  44 static UBool gTrace = FALSE;
  45 #endif
  46 
  47 U_NAMESPACE_BEGIN
  48 
  49 // The state number of the starting state
  50 constexpr int32_t START_STATE = 1;
  51 
  52 // The state-transition value indicating &quot;stop&quot;
  53 constexpr int32_t STOP_STATE = 0;
  54 
  55 
  56 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(RuleBasedBreakIterator)
  57 
  58 
  59 //=======================================================================
  60 // constructors
  61 //=======================================================================
  62 
  63 /**
  64  * Constructs a RuleBasedBreakIterator that uses the already-created
  65  * tables object that is passed in as a parameter.
  66  */
  67 RuleBasedBreakIterator::RuleBasedBreakIterator(RBBIDataHeader* data, UErrorCode &amp;status)
  68  : fSCharIter(UnicodeString())
  69 {
  70     init(status);
  71     fData = new RBBIDataWrapper(data, status); // status checked in constructor
  72     if (U_FAILURE(status)) {return;}
  73     if(fData == 0) {
  74         status = U_MEMORY_ALLOCATION_ERROR;
  75         return;
  76     }
  77 }
  78 
  79 //
  80 //  Construct from precompiled binary rules (tables).  This constructor is public API,
  81 //  taking the rules as a (const uint8_t *) to match the type produced by getBinaryRules().
  82 //
  83 RuleBasedBreakIterator::RuleBasedBreakIterator(const uint8_t *compiledRules,
  84                        uint32_t       ruleLength,
  85                        UErrorCode     &amp;status)
  86  : fSCharIter(UnicodeString())
  87 {
  88     init(status);
  89     if (U_FAILURE(status)) {
  90         return;
  91     }
  92     if (compiledRules == NULL || ruleLength &lt; sizeof(RBBIDataHeader)) {
  93         status = U_ILLEGAL_ARGUMENT_ERROR;
  94         return;
  95     }
  96     const RBBIDataHeader *data = (const RBBIDataHeader *)compiledRules;
  97     if (data-&gt;fLength &gt; ruleLength) {
  98         status = U_ILLEGAL_ARGUMENT_ERROR;
  99         return;
 100     }
 101     fData = new RBBIDataWrapper(data, RBBIDataWrapper::kDontAdopt, status);
 102     if (U_FAILURE(status)) {return;}
 103     if(fData == 0) {
 104         status = U_MEMORY_ALLOCATION_ERROR;
 105         return;
 106     }
 107 }
 108 
 109 
 110 //-------------------------------------------------------------------------------
 111 //
 112 //   Constructor   from a UDataMemory handle to precompiled break rules
 113 //                 stored in an ICU data file.
 114 //
 115 //-------------------------------------------------------------------------------
 116 RuleBasedBreakIterator::RuleBasedBreakIterator(UDataMemory* udm, UErrorCode &amp;status)
 117  : fSCharIter(UnicodeString())
 118 {
 119     init(status);
 120     fData = new RBBIDataWrapper(udm, status); // status checked in constructor
 121     if (U_FAILURE(status)) {return;}
 122     if(fData == 0) {
 123         status = U_MEMORY_ALLOCATION_ERROR;
 124         return;
 125     }
 126 }
 127 
 128 
 129 
 130 //-------------------------------------------------------------------------------
 131 //
 132 //   Constructor       from a set of rules supplied as a string.
 133 //
 134 //-------------------------------------------------------------------------------
 135 RuleBasedBreakIterator::RuleBasedBreakIterator( const UnicodeString  &amp;rules,
 136                                                 UParseError          &amp;parseError,
 137                                                 UErrorCode           &amp;status)
 138  : fSCharIter(UnicodeString())
 139 {
 140     init(status);
 141     if (U_FAILURE(status)) {return;}
 142     RuleBasedBreakIterator *bi = (RuleBasedBreakIterator *)
 143         RBBIRuleBuilder::createRuleBasedBreakIterator(rules, &amp;parseError, status);
 144     // Note:  This is a bit awkward.  The RBBI ruleBuilder has a factory method that
 145     //        creates and returns a complete RBBI.  From here, in a constructor, we
 146     //        can&#39;t just return the object created by the builder factory, hence
 147     //        the assignment of the factory created object to &quot;this&quot;.
 148     if (U_SUCCESS(status)) {
 149         *this = *bi;
 150         delete bi;
 151     }
 152 }
 153 
 154 
 155 //-------------------------------------------------------------------------------
 156 //
 157 // Default Constructor.      Create an empty shell that can be set up later.
 158 //                           Used when creating a RuleBasedBreakIterator from a set
 159 //                           of rules.
 160 //-------------------------------------------------------------------------------
 161 RuleBasedBreakIterator::RuleBasedBreakIterator()
 162  : fSCharIter(UnicodeString())
 163 {
 164     UErrorCode status = U_ZERO_ERROR;
 165     init(status);
 166 }
 167 
 168 
 169 //-------------------------------------------------------------------------------
 170 //
 171 //   Copy constructor.  Will produce a break iterator with the same behavior,
 172 //                      and which iterates over the same text, as the one passed in.
 173 //
 174 //-------------------------------------------------------------------------------
 175 RuleBasedBreakIterator::RuleBasedBreakIterator(const RuleBasedBreakIterator&amp; other)
 176 : BreakIterator(other),
 177   fSCharIter(UnicodeString())
 178 {
 179     UErrorCode status = U_ZERO_ERROR;
 180     this-&gt;init(status);
 181     *this = other;
 182 }
 183 
 184 
 185 /**
 186  * Destructor
 187  */
 188 RuleBasedBreakIterator::~RuleBasedBreakIterator() {
 189     if (fCharIter != &amp;fSCharIter) {
 190         // fCharIter was adopted from the outside.
 191         delete fCharIter;
 192     }
 193     fCharIter = NULL;
 194 
 195     utext_close(&amp;fText);
 196 
 197     if (fData != NULL) {
 198         fData-&gt;removeReference();
 199         fData = NULL;
 200     }
 201     delete fBreakCache;
 202     fBreakCache = NULL;
 203 
 204     delete fDictionaryCache;
 205     fDictionaryCache = NULL;
 206 
 207     delete fLanguageBreakEngines;
 208     fLanguageBreakEngines = NULL;
 209 
 210     delete fUnhandledBreakEngine;
 211     fUnhandledBreakEngine = NULL;
 212 }
 213 
 214 /**
 215  * Assignment operator.  Sets this iterator to have the same behavior,
 216  * and iterate over the same text, as the one passed in.
 217  */
 218 RuleBasedBreakIterator&amp;
 219 RuleBasedBreakIterator::operator=(const RuleBasedBreakIterator&amp; that) {
 220     if (this == &amp;that) {
 221         return *this;
 222     }
 223     BreakIterator::operator=(that);
 224 
 225     if (fLanguageBreakEngines != NULL) {
 226         delete fLanguageBreakEngines;
 227         fLanguageBreakEngines = NULL;   // Just rebuild for now
 228     }
 229     // TODO: clone fLanguageBreakEngines from &quot;that&quot;
 230     UErrorCode status = U_ZERO_ERROR;
 231     utext_clone(&amp;fText, &amp;that.fText, FALSE, TRUE, &amp;status);
 232 
 233     if (fCharIter != &amp;fSCharIter) {
 234         delete fCharIter;
 235     }
 236     fCharIter = &amp;fSCharIter;
 237 
 238     if (that.fCharIter != NULL &amp;&amp; that.fCharIter != &amp;that.fSCharIter) {
 239         // This is a little bit tricky - it will intially appear that
 240         //  this-&gt;fCharIter is adopted, even if that-&gt;fCharIter was
 241         //  not adopted.  That&#39;s ok.
 242         fCharIter = that.fCharIter-&gt;clone();
 243     }
 244     fSCharIter = that.fSCharIter;
 245     if (fCharIter == NULL) {
 246         fCharIter = &amp;fSCharIter;
 247     }
 248 
 249     if (fData != NULL) {
 250         fData-&gt;removeReference();
 251         fData = NULL;
 252     }
 253     if (that.fData != NULL) {
 254         fData = that.fData-&gt;addReference();
 255     }
 256 
 257     fPosition = that.fPosition;
 258     fRuleStatusIndex = that.fRuleStatusIndex;
 259     fDone = that.fDone;
 260 
 261     // TODO: both the dictionary and the main cache need to be copied.
 262     //       Current position could be within a dictionary range. Trying to continue
 263     //       the iteration without the caches present would go to the rules, with
 264     //       the assumption that the current position is on a rule boundary.
 265     fBreakCache-&gt;reset(fPosition, fRuleStatusIndex);
 266     fDictionaryCache-&gt;reset();
 267 
 268     return *this;
 269 }
 270 
 271 
 272 
 273 //-----------------------------------------------------------------------------
 274 //
 275 //    init()      Shared initialization routine.   Used by all the constructors.
 276 //                Initializes all fields, leaving the object in a consistent state.
 277 //
 278 //-----------------------------------------------------------------------------
 279 void RuleBasedBreakIterator::init(UErrorCode &amp;status) {
 280     fCharIter             = NULL;
 281     fData                 = NULL;
 282     fPosition             = 0;
 283     fRuleStatusIndex      = 0;
 284     fDone                 = false;
 285     fDictionaryCharCount  = 0;
 286     fLanguageBreakEngines = NULL;
 287     fUnhandledBreakEngine = NULL;
 288     fBreakCache           = NULL;
 289     fDictionaryCache      = NULL;
 290 
 291     // Note: IBM xlC is unable to assign or initialize member fText from UTEXT_INITIALIZER.
 292     // fText                 = UTEXT_INITIALIZER;
 293     static const UText initializedUText = UTEXT_INITIALIZER;
 294     uprv_memcpy(&amp;fText, &amp;initializedUText, sizeof(UText));
 295 
 296    if (U_FAILURE(status)) {
 297         return;
 298     }
 299 
 300     utext_openUChars(&amp;fText, NULL, 0, &amp;status);
 301     fDictionaryCache = new DictionaryCache(this, status);
 302     fBreakCache      = new BreakCache(this, status);
 303     if (U_SUCCESS(status) &amp;&amp; (fDictionaryCache == NULL || fBreakCache == NULL)) {
 304         status = U_MEMORY_ALLOCATION_ERROR;
 305     }
 306 
 307 #ifdef RBBI_DEBUG
 308     static UBool debugInitDone = FALSE;
 309     if (debugInitDone == FALSE) {
 310         char *debugEnv = getenv(&quot;U_RBBIDEBUG&quot;);
 311         if (debugEnv &amp;&amp; uprv_strstr(debugEnv, &quot;trace&quot;)) {
 312             gTrace = TRUE;
 313         }
 314         debugInitDone = TRUE;
 315     }
 316 #endif
 317 }
 318 
 319 
 320 
 321 //-----------------------------------------------------------------------------
 322 //
 323 //    clone - Returns a newly-constructed RuleBasedBreakIterator with the same
 324 //            behavior, and iterating over the same text, as this one.
 325 //            Virtual function: does the right thing with subclasses.
 326 //
 327 //-----------------------------------------------------------------------------
 328 BreakIterator*
 329 RuleBasedBreakIterator::clone(void) const {
 330     return new RuleBasedBreakIterator(*this);
 331 }
 332 
 333 /**
 334  * Equality operator.  Returns TRUE if both BreakIterators are of the
 335  * same class, have the same behavior, and iterate over the same text.
 336  */
 337 UBool
 338 RuleBasedBreakIterator::operator==(const BreakIterator&amp; that) const {
 339     if (typeid(*this) != typeid(that)) {
 340         return FALSE;
 341     }
 342     if (this == &amp;that) {
 343         return TRUE;
 344     }
 345 
 346     // The base class BreakIterator carries no state that participates in equality,
 347     // and does not implement an equality function that would otherwise be
 348     // checked at this point.
 349 
 350     const RuleBasedBreakIterator&amp; that2 = (const RuleBasedBreakIterator&amp;) that;
 351 
 352     if (!utext_equals(&amp;fText, &amp;that2.fText)) {
 353         // The two break iterators are operating on different text,
 354         //   or have a different iteration position.
 355         //   Note that fText&#39;s position is always the same as the break iterator&#39;s position.
 356         return FALSE;
 357     };
 358 
 359     if (!(fPosition == that2.fPosition &amp;&amp;
 360             fRuleStatusIndex == that2.fRuleStatusIndex &amp;&amp;
 361             fDone == that2.fDone)) {
 362         return FALSE;
 363     }
 364 
 365     if (that2.fData == fData ||
 366         (fData != NULL &amp;&amp; that2.fData != NULL &amp;&amp; *that2.fData == *fData)) {
 367             // The two break iterators are using the same rules.
 368             return TRUE;
 369         }
 370     return FALSE;
 371 }
 372 
 373 /**
 374  * Compute a hash code for this BreakIterator
 375  * @return A hash code
 376  */
 377 int32_t
 378 RuleBasedBreakIterator::hashCode(void) const {
 379     int32_t   hash = 0;
 380     if (fData != NULL) {
 381         hash = fData-&gt;hashCode();
 382     }
 383     return hash;
 384 }
 385 
 386 
 387 void RuleBasedBreakIterator::setText(UText *ut, UErrorCode &amp;status) {
 388     if (U_FAILURE(status)) {
 389         return;
 390     }
 391     fBreakCache-&gt;reset();
 392     fDictionaryCache-&gt;reset();
 393     utext_clone(&amp;fText, ut, FALSE, TRUE, &amp;status);
 394 
 395     // Set up a dummy CharacterIterator to be returned if anyone
 396     //   calls getText().  With input from UText, there is no reasonable
 397     //   way to return a characterIterator over the actual input text.
 398     //   Return one over an empty string instead - this is the closest
 399     //   we can come to signaling a failure.
 400     //   (GetText() is obsolete, this failure is sort of OK)
 401     fSCharIter.setText(UnicodeString());
 402 
 403     if (fCharIter != &amp;fSCharIter) {
 404         // existing fCharIter was adopted from the outside.  Delete it now.
 405         delete fCharIter;
 406     }
 407     fCharIter = &amp;fSCharIter;
 408 
 409     this-&gt;first();
 410 }
 411 
 412 
 413 UText *RuleBasedBreakIterator::getUText(UText *fillIn, UErrorCode &amp;status) const {
 414     UText *result = utext_clone(fillIn, &amp;fText, FALSE, TRUE, &amp;status);
 415     return result;
 416 }
 417 
 418 
 419 //=======================================================================
 420 // BreakIterator overrides
 421 //=======================================================================
 422 
 423 /**
 424  * Return a CharacterIterator over the text being analyzed.
 425  */
 426 CharacterIterator&amp;
 427 RuleBasedBreakIterator::getText() const {
 428     return *fCharIter;
 429 }
 430 
 431 /**
 432  * Set the iterator to analyze a new piece of text.  This function resets
 433  * the current iteration position to the beginning of the text.
 434  * @param newText An iterator over the text to analyze.
 435  */
 436 void
 437 RuleBasedBreakIterator::adoptText(CharacterIterator* newText) {
 438     // If we are holding a CharacterIterator adopted from a
 439     //   previous call to this function, delete it now.
 440     if (fCharIter != &amp;fSCharIter) {
 441         delete fCharIter;
 442     }
 443 
 444     fCharIter = newText;
 445     UErrorCode status = U_ZERO_ERROR;
 446     fBreakCache-&gt;reset();
 447     fDictionaryCache-&gt;reset();
 448     if (newText==NULL || newText-&gt;startIndex() != 0) {
 449         // startIndex !=0 wants to be an error, but there&#39;s no way to report it.
 450         // Make the iterator text be an empty string.
 451         utext_openUChars(&amp;fText, NULL, 0, &amp;status);
 452     } else {
 453         utext_openCharacterIterator(&amp;fText, newText, &amp;status);
 454     }
 455     this-&gt;first();
 456 }
 457 
 458 /**
 459  * Set the iterator to analyze a new piece of text.  This function resets
 460  * the current iteration position to the beginning of the text.
 461  * @param newText An iterator over the text to analyze.
 462  */
 463 void
 464 RuleBasedBreakIterator::setText(const UnicodeString&amp; newText) {
 465     UErrorCode status = U_ZERO_ERROR;
 466     fBreakCache-&gt;reset();
 467     fDictionaryCache-&gt;reset();
 468     utext_openConstUnicodeString(&amp;fText, &amp;newText, &amp;status);
 469 
 470     // Set up a character iterator on the string.
 471     //   Needed in case someone calls getText().
 472     //  Can not, unfortunately, do this lazily on the (probably never)
 473     //  call to getText(), because getText is const.
 474     fSCharIter.setText(newText);
 475 
 476     if (fCharIter != &amp;fSCharIter) {
 477         // old fCharIter was adopted from the outside.  Delete it.
 478         delete fCharIter;
 479     }
 480     fCharIter = &amp;fSCharIter;
 481 
 482     this-&gt;first();
 483 }
 484 
 485 
 486 /**
 487  *  Provide a new UText for the input text.  Must reference text with contents identical
 488  *  to the original.
 489  *  Intended for use with text data originating in Java (garbage collected) environments
 490  *  where the data may be moved in memory at arbitrary times.
 491  */
 492 RuleBasedBreakIterator &amp;RuleBasedBreakIterator::refreshInputText(UText *input, UErrorCode &amp;status) {
 493     if (U_FAILURE(status)) {
 494         return *this;
 495     }
 496     if (input == NULL) {
 497         status = U_ILLEGAL_ARGUMENT_ERROR;
 498         return *this;
 499     }
 500     int64_t pos = utext_getNativeIndex(&amp;fText);
 501     //  Shallow read-only clone of the new UText into the existing input UText
 502     utext_clone(&amp;fText, input, FALSE, TRUE, &amp;status);
 503     if (U_FAILURE(status)) {
 504         return *this;
 505     }
 506     utext_setNativeIndex(&amp;fText, pos);
 507     if (utext_getNativeIndex(&amp;fText) != pos) {
 508         // Sanity check.  The new input utext is supposed to have the exact same
 509         // contents as the old.  If we can&#39;t set to the same position, it doesn&#39;t.
 510         // The contents underlying the old utext might be invalid at this point,
 511         // so it&#39;s not safe to check directly.
 512         status = U_ILLEGAL_ARGUMENT_ERROR;
 513     }
 514     return *this;
 515 }
 516 
 517 
 518 /**
 519  * Sets the current iteration position to the beginning of the text, position zero.
 520  * @return The new iterator position, which is zero.
 521  */
 522 int32_t RuleBasedBreakIterator::first(void) {
 523     UErrorCode status = U_ZERO_ERROR;
 524     if (!fBreakCache-&gt;seek(0)) {
 525         fBreakCache-&gt;populateNear(0, status);
 526     }
 527     fBreakCache-&gt;current();
 528     U_ASSERT(fPosition == 0);
 529     return 0;
 530 }
 531 
 532 /**
 533  * Sets the current iteration position to the end of the text.
 534  * @return The text&#39;s past-the-end offset.
 535  */
 536 int32_t RuleBasedBreakIterator::last(void) {
 537     int32_t endPos = (int32_t)utext_nativeLength(&amp;fText);
 538     UBool endShouldBeBoundary = isBoundary(endPos);      // Has side effect of setting iterator position.
 539     (void)endShouldBeBoundary;
 540     U_ASSERT(endShouldBeBoundary);
 541     U_ASSERT(fPosition == endPos);
 542     return endPos;
 543 }
 544 
 545 /**
 546  * Advances the iterator either forward or backward the specified number of steps.
 547  * Negative values move backward, and positive values move forward.  This is
 548  * equivalent to repeatedly calling next() or previous().
 549  * @param n The number of steps to move.  The sign indicates the direction
 550  * (negative is backwards, and positive is forwards).
 551  * @return The character offset of the boundary position n boundaries away from
 552  * the current one.
 553  */
 554 int32_t RuleBasedBreakIterator::next(int32_t n) {
 555     int32_t result = 0;
 556     if (n &gt; 0) {
 557         for (; n &gt; 0 &amp;&amp; result != UBRK_DONE; --n) {
 558             result = next();
 559         }
 560     } else if (n &lt; 0) {
 561         for (; n &lt; 0 &amp;&amp; result != UBRK_DONE; ++n) {
 562             result = previous();
 563         }
 564     } else {
 565         result = current();
 566     }
 567     return result;
 568 }
 569 
 570 /**
 571  * Advances the iterator to the next boundary position.
 572  * @return The position of the first boundary after this one.
 573  */
 574 int32_t RuleBasedBreakIterator::next(void) {
 575     fBreakCache-&gt;next();
 576     return fDone ? UBRK_DONE : fPosition;
 577 }
 578 
 579 /**
 580  * Move the iterator backwards, to the boundary preceding the current one.
 581  *
 582  *         Starts from the current position within fText.
 583  *         Starting position need not be on a boundary.
 584  *
 585  * @return The position of the boundary position immediately preceding the starting position.
 586  */
 587 int32_t RuleBasedBreakIterator::previous(void) {
 588     UErrorCode status = U_ZERO_ERROR;
 589     fBreakCache-&gt;previous(status);
 590     return fDone ? UBRK_DONE : fPosition;
 591 }
 592 
 593 /**
 594  * Sets the iterator to refer to the first boundary position following
 595  * the specified position.
 596  * @param startPos The position from which to begin searching for a break position.
 597  * @return The position of the first break after the current position.
 598  */
 599 int32_t RuleBasedBreakIterator::following(int32_t startPos) {
 600     // if the supplied position is before the beginning, return the
 601     // text&#39;s starting offset
 602     if (startPos &lt; 0) {
 603         return first();
 604     }
 605 
 606     // Move requested offset to a code point start. It might be on a trail surrogate,
 607     // or on a trail byte if the input is UTF-8. Or it may be beyond the end of the text.
 608     utext_setNativeIndex(&amp;fText, startPos);
 609     startPos = (int32_t)utext_getNativeIndex(&amp;fText);
 610 
 611     UErrorCode status = U_ZERO_ERROR;
 612     fBreakCache-&gt;following(startPos, status);
 613     return fDone ? UBRK_DONE : fPosition;
 614 }
 615 
 616 /**
 617  * Sets the iterator to refer to the last boundary position before the
 618  * specified position.
 619  * @param offset The position to begin searching for a break from.
 620  * @return The position of the last boundary before the starting position.
 621  */
 622 int32_t RuleBasedBreakIterator::preceding(int32_t offset) {
 623     if (offset &gt; utext_nativeLength(&amp;fText)) {
 624         return last();
 625     }
 626 
 627     // Move requested offset to a code point start. It might be on a trail surrogate,
 628     // or on a trail byte if the input is UTF-8.
 629 
 630     utext_setNativeIndex(&amp;fText, offset);
<a name="4" id="anc4"></a><span class="line-modified"> 631     int32_t adjustedOffset = utext_getNativeIndex(&amp;fText);</span>
 632 
 633     UErrorCode status = U_ZERO_ERROR;
 634     fBreakCache-&gt;preceding(adjustedOffset, status);
 635     return fDone ? UBRK_DONE : fPosition;
 636 }
 637 
 638 /**
 639  * Returns true if the specfied position is a boundary position.  As a side
 640  * effect, leaves the iterator pointing to the first boundary position at
 641  * or after &quot;offset&quot;.
 642  *
 643  * @param offset the offset to check.
 644  * @return True if &quot;offset&quot; is a boundary position.
 645  */
 646 UBool RuleBasedBreakIterator::isBoundary(int32_t offset) {
 647     // out-of-range indexes are never boundary positions
 648     if (offset &lt; 0) {
 649         first();       // For side effects on current position, tag values.
 650         return FALSE;
 651     }
 652 
 653     // Adjust offset to be on a code point boundary and not beyond the end of the text.
 654     // Note that isBoundary() is always false for offsets that are not on code point boundaries.
 655     // But we still need the side effect of leaving iteration at the following boundary.
 656 
 657     utext_setNativeIndex(&amp;fText, offset);
<a name="5" id="anc5"></a><span class="line-modified"> 658     int32_t adjustedOffset = utext_getNativeIndex(&amp;fText);</span>
 659 
 660     bool result = false;
 661     UErrorCode status = U_ZERO_ERROR;
 662     if (fBreakCache-&gt;seek(adjustedOffset) || fBreakCache-&gt;populateNear(adjustedOffset, status)) {
 663         result = (fBreakCache-&gt;current() == offset);
 664     }
 665 
 666     if (result &amp;&amp; adjustedOffset &lt; offset &amp;&amp; utext_char32At(&amp;fText, offset) == U_SENTINEL) {
 667         // Original offset is beyond the end of the text. Return FALSE, it&#39;s not a boundary,
 668         // but the iteration position remains set to the end of the text, which is a boundary.
 669         return FALSE;
 670     }
 671     if (!result) {
 672         // Not on a boundary. isBoundary() must leave iterator on the following boundary.
 673         // Cache-&gt;seek(), above, left us on the preceding boundary, so advance one.
 674         next();
 675     }
 676     return result;
 677 }
 678 
 679 
 680 /**
 681  * Returns the current iteration position.
 682  * @return The current iteration position.
 683  */
 684 int32_t RuleBasedBreakIterator::current(void) const {
 685     return fPosition;
 686 }
 687 
 688 
 689 //=======================================================================
 690 // implementation
 691 //=======================================================================
 692 
 693 //
 694 // RBBIRunMode  -  the state machine runs an extra iteration at the beginning and end
 695 //                 of user text.  A variable with this enum type keeps track of where we
 696 //                 are.  The state machine only fetches user input while in the RUN mode.
 697 //
 698 enum RBBIRunMode {
 699     RBBI_START,     // state machine processing is before first char of input
 700     RBBI_RUN,       // state machine processing is in the user text
 701     RBBI_END        // state machine processing is after end of user text.
 702 };
 703 
 704 
 705 // Map from look-ahead break states (corresponds to rules) to boundary positions.
 706 // Allows multiple lookahead break rules to be in flight at the same time.
 707 //
 708 // This is a temporary approach for ICU 57. A better fix is to make the look-ahead numbers
 709 // in the state table be sequential, then we can just index an array. And the
 710 // table could also tell us in advance how big that array needs to be.
 711 //
 712 // Before ICU 57 there was just a single simple variable for a look-ahead match that
 713 // was in progress. Two rules at once did not work.
 714 
 715 static const int32_t kMaxLookaheads = 8;
 716 struct LookAheadResults {
 717     int32_t    fUsedSlotLimit;
 718     int32_t    fPositions[8];
 719     int16_t    fKeys[8];
 720 
<a name="6" id="anc6"></a><span class="line-modified"> 721     LookAheadResults() : fUsedSlotLimit(0), fPositions(), fKeys() {};</span>
 722 
 723     int32_t getPosition(int16_t key) {
 724         for (int32_t i=0; i&lt;fUsedSlotLimit; ++i) {
 725             if (fKeys[i] == key) {
 726                 return fPositions[i];
 727             }
 728         }
<a name="7" id="anc7"></a><span class="line-modified"> 729         U_ASSERT(FALSE);</span>
<span class="line-removed"> 730         return -1;</span>
 731     }
 732 
 733     void setPosition(int16_t key, int32_t position) {
 734         int32_t i;
 735         for (i=0; i&lt;fUsedSlotLimit; ++i) {
 736             if (fKeys[i] == key) {
 737                 fPositions[i] = position;
 738                 return;
 739             }
 740         }
 741         if (i &gt;= kMaxLookaheads) {
<a name="8" id="anc8"></a><span class="line-modified"> 742             U_ASSERT(FALSE);</span>
<span class="line-removed"> 743             i = kMaxLookaheads - 1;</span>
 744         }
 745         fKeys[i] = key;
 746         fPositions[i] = position;
 747         U_ASSERT(fUsedSlotLimit == i);
 748         fUsedSlotLimit = i + 1;
 749     }
 750 };
 751 
 752 
 753 //-----------------------------------------------------------------------------------
 754 //
 755 //  handleNext()
 756 //     Run the state machine to find a boundary
 757 //
 758 //-----------------------------------------------------------------------------------
 759 int32_t RuleBasedBreakIterator::handleNext() {
 760     int32_t             state;
 761     uint16_t            category        = 0;
 762     RBBIRunMode         mode;
 763 
 764     RBBIStateTableRow  *row;
 765     UChar32             c;
 766     LookAheadResults    lookAheadMatches;
 767     int32_t             result             = 0;
 768     int32_t             initialPosition    = 0;
 769     const RBBIStateTable *statetable       = fData-&gt;fForwardTable;
 770     const char         *tableData          = statetable-&gt;fTableData;
 771     uint32_t            tableRowLen        = statetable-&gt;fRowLen;
 772     #ifdef RBBI_DEBUG
 773         if (gTrace) {
 774             RBBIDebugPuts(&quot;Handle Next   pos   char  state category&quot;);
 775         }
 776     #endif
 777 
 778     // handleNext alway sets the break tag value.
 779     // Set the default for it.
 780     fRuleStatusIndex = 0;
 781 
 782     fDictionaryCharCount = 0;
 783 
 784     // if we&#39;re already at the end of the text, return DONE.
 785     initialPosition = fPosition;
 786     UTEXT_SETNATIVEINDEX(&amp;fText, initialPosition);
 787     result          = initialPosition;
 788     c               = UTEXT_NEXT32(&amp;fText);
 789     if (c==U_SENTINEL) {
 790         fDone = TRUE;
 791         return UBRK_DONE;
 792     }
 793 
 794     //  Set the initial state for the state machine
 795     state = START_STATE;
 796     row = (RBBIStateTableRow *)
 797             //(statetable-&gt;fTableData + (statetable-&gt;fRowLen * state));
 798             (tableData + tableRowLen * state);
 799 
 800 
 801     mode     = RBBI_RUN;
 802     if (statetable-&gt;fFlags &amp; RBBI_BOF_REQUIRED) {
 803         category = 2;
 804         mode     = RBBI_START;
 805     }
 806 
 807 
 808     // loop until we reach the end of the text or transition to state 0
 809     //
 810     for (;;) {
 811         if (c == U_SENTINEL) {
 812             // Reached end of input string.
 813             if (mode == RBBI_END) {
 814                 // We have already run the loop one last time with the
 815                 //   character set to the psueudo {eof} value.  Now it is time
 816                 //   to unconditionally bail out.
 817                 break;
 818             }
 819             // Run the loop one last time with the fake end-of-input character category.
 820             mode = RBBI_END;
 821             category = 1;
 822         }
 823 
 824         //
 825         // Get the char category.  An incoming category of 1 or 2 means that
 826         //      we are preset for doing the beginning or end of input, and
 827         //      that we shouldn&#39;t get a category from an actual text input character.
 828         //
 829         if (mode == RBBI_RUN) {
 830             // look up the current character&#39;s character category, which tells us
 831             // which column in the state table to look at.
 832             // Note:  the 16 in UTRIE_GET16 refers to the size of the data being returned,
 833             //        not the size of the character going in, which is a UChar32.
 834             //
 835             category = UTRIE2_GET16(fData-&gt;fTrie, c);
 836 
 837             // Check the dictionary bit in the character&#39;s category.
 838             //    Counter is only used by dictionary based iteration.
 839             //    Chars that need to be handled by a dictionary have a flag bit set
 840             //    in their category values.
 841             //
 842             if ((category &amp; 0x4000) != 0)  {
 843                 fDictionaryCharCount++;
 844                 //  And off the dictionary flag bit.
 845                 category &amp;= ~0x4000;
 846             }
 847         }
 848 
 849        #ifdef RBBI_DEBUG
 850             if (gTrace) {
<a name="9" id="anc9"></a><span class="line-modified"> 851                 RBBIDebugPrintf(&quot;             %4ld   &quot;, utext_getNativeIndex(&amp;fText));</span>
 852                 if (0x20&lt;=c &amp;&amp; c&lt;0x7f) {
 853                     RBBIDebugPrintf(&quot;\&quot;%c\&quot;  &quot;, c);
 854                 } else {
 855                     RBBIDebugPrintf(&quot;%5x  &quot;, c);
 856                 }
 857                 RBBIDebugPrintf(&quot;%3d  %3d\n&quot;, state, category);
 858             }
 859         #endif
 860 
 861         // State Transition - move machine to its next state
 862         //
 863 
 864         // fNextState is a variable-length array.
 865         U_ASSERT(category&lt;fData-&gt;fHeader-&gt;fCatCount);
 866         state = row-&gt;fNextState[category];  /*Not accessing beyond memory*/
 867         row = (RBBIStateTableRow *)
 868             // (statetable-&gt;fTableData + (statetable-&gt;fRowLen * state));
 869             (tableData + tableRowLen * state);
 870 
 871 
 872         if (row-&gt;fAccepting == -1) {
 873             // Match found, common case.
 874             if (mode != RBBI_START) {
 875                 result = (int32_t)UTEXT_GETNATIVEINDEX(&amp;fText);
 876             }
 877             fRuleStatusIndex = row-&gt;fTagIdx;   // Remember the break status (tag) values.
 878         }
 879 
 880         int16_t completedRule = row-&gt;fAccepting;
 881         if (completedRule &gt; 0) {
 882             // Lookahead match is completed.
 883             int32_t lookaheadResult = lookAheadMatches.getPosition(completedRule);
 884             if (lookaheadResult &gt;= 0) {
 885                 fRuleStatusIndex = row-&gt;fTagIdx;
 886                 fPosition = lookaheadResult;
 887                 return lookaheadResult;
 888             }
 889         }
 890         int16_t rule = row-&gt;fLookAhead;
 891         if (rule != 0) {
 892             // At the position of a &#39;/&#39; in a look-ahead match. Record it.
 893             int32_t  pos = (int32_t)UTEXT_GETNATIVEINDEX(&amp;fText);
 894             lookAheadMatches.setPosition(rule, pos);
 895         }
 896 
 897         if (state == STOP_STATE) {
 898             // This is the normal exit from the lookup state machine.
 899             // We have advanced through the string until it is certain that no
 900             //   longer match is possible, no matter what characters follow.
 901             break;
 902         }
 903 
 904         // Advance to the next character.
 905         // If this is a beginning-of-input loop iteration, don&#39;t advance
 906         //    the input position.  The next iteration will be processing the
 907         //    first real input character.
 908         if (mode == RBBI_RUN) {
 909             c = UTEXT_NEXT32(&amp;fText);
 910         } else {
 911             if (mode == RBBI_START) {
 912                 mode = RBBI_RUN;
 913             }
 914         }
 915     }
 916 
 917     // The state machine is done.  Check whether it found a match...
 918 
 919     // If the iterator failed to advance in the match engine, force it ahead by one.
 920     //   (This really indicates a defect in the break rules.  They should always match
 921     //    at least one character.)
 922     if (result == initialPosition) {
 923         utext_setNativeIndex(&amp;fText, initialPosition);
 924         utext_next32(&amp;fText);
 925         result = (int32_t)utext_getNativeIndex(&amp;fText);
 926         fRuleStatusIndex = 0;
 927     }
 928 
 929     // Leave the iterator at our result position.
 930     fPosition = result;
 931     #ifdef RBBI_DEBUG
 932         if (gTrace) {
 933             RBBIDebugPrintf(&quot;result = %d\n\n&quot;, result);
 934         }
 935     #endif
 936     return result;
 937 }
 938 
 939 
 940 //-----------------------------------------------------------------------------------
 941 //
 942 //  handleSafePrevious()
 943 //
 944 //      Iterate backwards using the safe reverse rules.
 945 //      The logic of this function is similar to handleNext(), but simpler
 946 //      because the safe table does not require as many options.
 947 //
 948 //-----------------------------------------------------------------------------------
 949 int32_t RuleBasedBreakIterator::handleSafePrevious(int32_t fromPosition) {
 950     int32_t             state;
 951     uint16_t            category        = 0;
 952     RBBIStateTableRow  *row;
 953     UChar32             c;
 954     int32_t             result          = 0;
 955 
 956     const RBBIStateTable *stateTable = fData-&gt;fReverseTable;
 957     UTEXT_SETNATIVEINDEX(&amp;fText, fromPosition);
 958     #ifdef RBBI_DEBUG
 959         if (gTrace) {
 960             RBBIDebugPuts(&quot;Handle Previous   pos   char  state category&quot;);
 961         }
 962     #endif
 963 
 964     // if we&#39;re already at the start of the text, return DONE.
 965     if (fData == NULL || UTEXT_GETNATIVEINDEX(&amp;fText)==0) {
 966         return BreakIterator::DONE;
 967     }
 968 
 969     //  Set the initial state for the state machine
 970     c = UTEXT_PREVIOUS32(&amp;fText);
 971     state = START_STATE;
 972     row = (RBBIStateTableRow *)
 973             (stateTable-&gt;fTableData + (stateTable-&gt;fRowLen * state));
 974 
 975     // loop until we reach the start of the text or transition to state 0
 976     //
 977     for (; c != U_SENTINEL; c = UTEXT_PREVIOUS32(&amp;fText)) {
 978 
 979         // look up the current character&#39;s character category, which tells us
 980         // which column in the state table to look at.
 981         // Note:  the 16 in UTRIE_GET16 refers to the size of the data being returned,
 982         //        not the size of the character going in, which is a UChar32.
 983         //
 984         //  And off the dictionary flag bit. For reverse iteration it is not used.
 985         category = UTRIE2_GET16(fData-&gt;fTrie, c);
 986         category &amp;= ~0x4000;
 987 
 988         #ifdef RBBI_DEBUG
 989             if (gTrace) {
 990                 RBBIDebugPrintf(&quot;             %4d   &quot;, (int32_t)utext_getNativeIndex(&amp;fText));
 991                 if (0x20&lt;=c &amp;&amp; c&lt;0x7f) {
 992                     RBBIDebugPrintf(&quot;\&quot;%c\&quot;  &quot;, c);
 993                 } else {
 994                     RBBIDebugPrintf(&quot;%5x  &quot;, c);
 995                 }
 996                 RBBIDebugPrintf(&quot;%3d  %3d\n&quot;, state, category);
 997             }
 998         #endif
 999 
1000         // State Transition - move machine to its next state
1001         //
1002         // fNextState is a variable-length array.
1003         U_ASSERT(category&lt;fData-&gt;fHeader-&gt;fCatCount);
1004         state = row-&gt;fNextState[category];  /*Not accessing beyond memory*/
1005         row = (RBBIStateTableRow *)
1006             (stateTable-&gt;fTableData + (stateTable-&gt;fRowLen * state));
1007 
1008         if (state == STOP_STATE) {
1009             // This is the normal exit from the lookup state machine.
1010             // Transistion to state zero means we have found a safe point.
1011             break;
1012         }
1013     }
1014 
1015     // The state machine is done.  Check whether it found a match...
1016     result = (int32_t)UTEXT_GETNATIVEINDEX(&amp;fText);
1017     #ifdef RBBI_DEBUG
1018         if (gTrace) {
1019             RBBIDebugPrintf(&quot;result = %d\n\n&quot;, result);
1020         }
1021     #endif
1022     return result;
1023 }
1024 
1025 //-------------------------------------------------------------------------------
1026 //
1027 //   getRuleStatus()   Return the break rule tag associated with the current
1028 //                     iterator position.  If the iterator arrived at its current
1029 //                     position by iterating forwards, the value will have been
1030 //                     cached by the handleNext() function.
1031 //
1032 //-------------------------------------------------------------------------------
1033 
1034 int32_t  RuleBasedBreakIterator::getRuleStatus() const {
1035 
1036     // fLastRuleStatusIndex indexes to the start of the appropriate status record
1037     //                                                 (the number of status values.)
1038     //   This function returns the last (largest) of the array of status values.
1039     int32_t  idx = fRuleStatusIndex + fData-&gt;fRuleStatusTable[fRuleStatusIndex];
1040     int32_t  tagVal = fData-&gt;fRuleStatusTable[idx];
1041 
1042     return tagVal;
1043 }
1044 
1045 
1046 int32_t RuleBasedBreakIterator::getRuleStatusVec(
1047              int32_t *fillInVec, int32_t capacity, UErrorCode &amp;status) {
1048     if (U_FAILURE(status)) {
1049         return 0;
1050     }
1051 
1052     int32_t  numVals = fData-&gt;fRuleStatusTable[fRuleStatusIndex];
1053     int32_t  numValsToCopy = numVals;
1054     if (numVals &gt; capacity) {
1055         status = U_BUFFER_OVERFLOW_ERROR;
1056         numValsToCopy = capacity;
1057     }
1058     int i;
1059     for (i=0; i&lt;numValsToCopy; i++) {
1060         fillInVec[i] = fData-&gt;fRuleStatusTable[fRuleStatusIndex + i + 1];
1061     }
1062     return numVals;
1063 }
1064 
1065 
1066 
1067 //-------------------------------------------------------------------------------
1068 //
1069 //   getBinaryRules        Access to the compiled form of the rules,
1070 //                         for use by build system tools that save the data
1071 //                         for standard iterator types.
1072 //
1073 //-------------------------------------------------------------------------------
1074 const uint8_t  *RuleBasedBreakIterator::getBinaryRules(uint32_t &amp;length) {
1075     const uint8_t  *retPtr = NULL;
1076     length = 0;
1077 
1078     if (fData != NULL) {
1079         retPtr = (const uint8_t *)fData-&gt;fHeader;
1080         length = fData-&gt;fHeader-&gt;fLength;
1081     }
1082     return retPtr;
1083 }
1084 
1085 
1086 BreakIterator *  RuleBasedBreakIterator::createBufferClone(void * /*stackBuffer*/,
1087                                    int32_t &amp;bufferSize,
1088                                    UErrorCode &amp;status)
1089 {
1090     if (U_FAILURE(status)){
1091         return NULL;
1092     }
1093 
1094     if (bufferSize == 0) {
1095         bufferSize = 1;  // preflighting for deprecated functionality
1096         return NULL;
1097     }
1098 
1099     BreakIterator *clonedBI = clone();
1100     if (clonedBI == NULL) {
1101         status = U_MEMORY_ALLOCATION_ERROR;
1102     } else {
1103         status = U_SAFECLONE_ALLOCATED_WARNING;
1104     }
1105     return (RuleBasedBreakIterator *)clonedBI;
1106 }
1107 
1108 U_NAMESPACE_END
1109 
1110 
1111 static icu::UStack *gLanguageBreakFactories = nullptr;
1112 static const icu::UnicodeString *gEmptyString = nullptr;
1113 static icu::UInitOnce gLanguageBreakFactoriesInitOnce = U_INITONCE_INITIALIZER;
1114 static icu::UInitOnce gRBBIInitOnce = U_INITONCE_INITIALIZER;
1115 
1116 /**
1117  * Release all static memory held by breakiterator.
1118  */
1119 U_CDECL_BEGIN
1120 static UBool U_CALLCONV rbbi_cleanup(void) {
1121     delete gLanguageBreakFactories;
1122     gLanguageBreakFactories = nullptr;
1123     delete gEmptyString;
1124     gEmptyString = nullptr;
1125     gLanguageBreakFactoriesInitOnce.reset();
1126     gRBBIInitOnce.reset();
1127     return TRUE;
1128 }
1129 U_CDECL_END
1130 
1131 U_CDECL_BEGIN
1132 static void U_CALLCONV _deleteFactory(void *obj) {
1133     delete (icu::LanguageBreakFactory *) obj;
1134 }
1135 U_CDECL_END
1136 U_NAMESPACE_BEGIN
1137 
1138 static void U_CALLCONV rbbiInit() {
1139     gEmptyString = new UnicodeString();
1140     ucln_common_registerCleanup(UCLN_COMMON_RBBI, rbbi_cleanup);
1141 }
1142 
1143 static void U_CALLCONV initLanguageFactories() {
1144     UErrorCode status = U_ZERO_ERROR;
1145     U_ASSERT(gLanguageBreakFactories == NULL);
1146     gLanguageBreakFactories = new UStack(_deleteFactory, NULL, status);
1147     if (gLanguageBreakFactories != NULL &amp;&amp; U_SUCCESS(status)) {
1148         ICULanguageBreakFactory *builtIn = new ICULanguageBreakFactory(status);
1149         gLanguageBreakFactories-&gt;push(builtIn, status);
1150 #ifdef U_LOCAL_SERVICE_HOOK
1151         LanguageBreakFactory *extra = (LanguageBreakFactory *)uprv_svc_hook(&quot;languageBreakFactory&quot;, &amp;status);
1152         if (extra != NULL) {
1153             gLanguageBreakFactories-&gt;push(extra, status);
1154         }
1155 #endif
1156     }
1157     ucln_common_registerCleanup(UCLN_COMMON_RBBI, rbbi_cleanup);
1158 }
1159 
1160 
1161 static const LanguageBreakEngine*
1162 getLanguageBreakEngineFromFactory(UChar32 c)
1163 {
1164     umtx_initOnce(gLanguageBreakFactoriesInitOnce, &amp;initLanguageFactories);
1165     if (gLanguageBreakFactories == NULL) {
1166         return NULL;
1167     }
1168 
1169     int32_t i = gLanguageBreakFactories-&gt;size();
1170     const LanguageBreakEngine *lbe = NULL;
1171     while (--i &gt;= 0) {
1172         LanguageBreakFactory *factory = (LanguageBreakFactory *)(gLanguageBreakFactories-&gt;elementAt(i));
1173         lbe = factory-&gt;getEngineFor(c);
1174         if (lbe != NULL) {
1175             break;
1176         }
1177     }
1178     return lbe;
1179 }
1180 
1181 
1182 //-------------------------------------------------------------------------------
1183 //
1184 //  getLanguageBreakEngine  Find an appropriate LanguageBreakEngine for the
1185 //                          the character c.
1186 //
1187 //-------------------------------------------------------------------------------
1188 const LanguageBreakEngine *
1189 RuleBasedBreakIterator::getLanguageBreakEngine(UChar32 c) {
1190     const LanguageBreakEngine *lbe = NULL;
1191     UErrorCode status = U_ZERO_ERROR;
1192 
1193     if (fLanguageBreakEngines == NULL) {
1194         fLanguageBreakEngines = new UStack(status);
1195         if (fLanguageBreakEngines == NULL || U_FAILURE(status)) {
1196             delete fLanguageBreakEngines;
1197             fLanguageBreakEngines = 0;
1198             return NULL;
1199         }
1200     }
1201 
1202     int32_t i = fLanguageBreakEngines-&gt;size();
1203     while (--i &gt;= 0) {
1204         lbe = (const LanguageBreakEngine *)(fLanguageBreakEngines-&gt;elementAt(i));
1205         if (lbe-&gt;handles(c)) {
1206             return lbe;
1207         }
1208     }
1209 
1210     // No existing dictionary took the character. See if a factory wants to
1211     // give us a new LanguageBreakEngine for this character.
1212     lbe = getLanguageBreakEngineFromFactory(c);
1213 
1214     // If we got one, use it and push it on our stack.
1215     if (lbe != NULL) {
1216         fLanguageBreakEngines-&gt;push((void *)lbe, status);
1217         // Even if we can&#39;t remember it, we can keep looking it up, so
1218         // return it even if the push fails.
1219         return lbe;
1220     }
1221 
1222     // No engine is forthcoming for this character. Add it to the
1223     // reject set. Create the reject break engine if needed.
1224     if (fUnhandledBreakEngine == NULL) {
1225         fUnhandledBreakEngine = new UnhandledEngine(status);
1226         if (U_SUCCESS(status) &amp;&amp; fUnhandledBreakEngine == NULL) {
1227             status = U_MEMORY_ALLOCATION_ERROR;
1228             return nullptr;
1229         }
1230         // Put it last so that scripts for which we have an engine get tried
1231         // first.
1232         fLanguageBreakEngines-&gt;insertElementAt(fUnhandledBreakEngine, 0, status);
1233         // If we can&#39;t insert it, or creation failed, get rid of it
1234         if (U_FAILURE(status)) {
1235             delete fUnhandledBreakEngine;
1236             fUnhandledBreakEngine = 0;
1237             return NULL;
1238         }
1239     }
1240 
1241     // Tell the reject engine about the character; at its discretion, it may
1242     // add more than just the one character.
1243     fUnhandledBreakEngine-&gt;handleCharacter(c);
1244 
1245     return fUnhandledBreakEngine;
1246 }
1247 
1248 void RuleBasedBreakIterator::dumpCache() {
1249     fBreakCache-&gt;dumpCache();
1250 }
1251 
1252 void RuleBasedBreakIterator::dumpTables() {
1253     fData-&gt;printData();
1254 }
1255 
1256 /**
1257  * Returns the description used to create this iterator
1258  */
1259 
1260 const UnicodeString&amp;
1261 RuleBasedBreakIterator::getRules() const {
1262     if (fData != NULL) {
1263         return fData-&gt;getRuleSourceString();
1264     } else {
1265         umtx_initOnce(gRBBIInitOnce, &amp;rbbiInit);
1266         return *gEmptyString;
1267     }
1268 }
1269 
1270 U_NAMESPACE_END
1271 
1272 #endif /* #if !UCONFIG_NO_BREAK_ITERATION */
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>