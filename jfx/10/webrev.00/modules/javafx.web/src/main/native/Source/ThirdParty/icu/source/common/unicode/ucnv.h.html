<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/ucnv.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 *   Copyright (C) 1999-2014, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8  *  ucnv.h:
   9  *  External APIs for the ICU&#39;s codeset conversion library
  10  *  Bertrand A. Damiba
  11  *
  12  * Modification History:
  13  *
  14  *   Date        Name        Description
  15  *   04/04/99    helena      Fixed internal header inclusion.
  16  *   05/11/00    helena      Added setFallback and usesFallback APIs.
  17  *   06/29/2000  helena      Major rewrite of the callback APIs.
  18  *   12/07/2000  srl         Update of documentation
  19  */
  20 
  21 /**
  22  * \file
  23  * \brief C API: Character conversion
  24  *
  25  * &lt;h2&gt;Character Conversion C API&lt;/h2&gt;
  26  *
  27  * &lt;p&gt;This API is used to convert codepage or character encoded data to and
  28  * from UTF-16. You can open a converter with {@link ucnv_open() }. With that
  29  * converter, you can get its properties, set options, convert your data and
  30  * close the converter.&lt;/p&gt;
  31  *
  32  * &lt;p&gt;Since many software programs recognize different converter names for
  33  * different types of converters, there are other functions in this API to
  34  * iterate over the converter aliases. The functions {@link ucnv_getAvailableName() },
  35  * {@link ucnv_getAlias() } and {@link ucnv_getStandardName() } are some of the
  36  * more frequently used alias functions to get this information.&lt;/p&gt;
  37  *
  38  * &lt;p&gt;When a converter encounters an illegal, irregular, invalid or unmappable character
  39  * its default behavior is to use a substitution character to replace the
  40  * bad byte sequence. This behavior can be changed by using {@link ucnv_setFromUCallBack() }
  41  * or {@link ucnv_setToUCallBack() } on the converter. The header ucnv_err.h defines
  42  * many other callback actions that can be used instead of a character substitution.&lt;/p&gt;
  43  *
  44  * &lt;p&gt;More information about this API can be found in our
  45  * &lt;a href=&quot;http://icu-project.org/userguide/conversion.html&quot;&gt;User&#39;s
  46  * Guide&lt;/a&gt;.&lt;/p&gt;
  47  */
  48 
  49 #ifndef UCNV_H
  50 #define UCNV_H
  51 
  52 #include &quot;unicode/ucnv_err.h&quot;
  53 #include &quot;unicode/uenum.h&quot;
  54 #include &quot;unicode/localpointer.h&quot;
  55 
  56 #if !defined(USET_DEFINED) &amp;&amp; !defined(U_IN_DOXYGEN)
  57 
  58 #define USET_DEFINED
  59 
  60 /**
  61  * USet is the C API type corresponding to C++ class UnicodeSet.
  62  * It is forward-declared here to avoid including unicode/uset.h file if related
  63  * conversion APIs are not used.
  64  *
  65  * @see ucnv_getUnicodeSet
  66  * @stable ICU 2.4
  67  */
  68 typedef struct USet USet;
  69 
  70 #endif
  71 
  72 #if !UCONFIG_NO_CONVERSION
  73 
  74 U_CDECL_BEGIN
  75 
  76 /** Maximum length of a converter name including the terminating NULL @stable ICU 2.0 */
  77 #define UCNV_MAX_CONVERTER_NAME_LENGTH 60
  78 /** Maximum length of a converter name including path and terminating NULL @stable ICU 2.0 */
  79 #define UCNV_MAX_FULL_FILE_NAME_LENGTH (600+UCNV_MAX_CONVERTER_NAME_LENGTH)
  80 
  81 /** Shift in for EBDCDIC_STATEFUL and iso2022 states @stable ICU 2.0 */
  82 #define  UCNV_SI 0x0F
  83 /** Shift out for EBDCDIC_STATEFUL and iso2022 states @stable ICU 2.0 */
  84 #define  UCNV_SO 0x0E
  85 
  86 /**
  87  * Enum for specifying basic types of converters
  88  * @see ucnv_getType
  89  * @stable ICU 2.0
  90  */
  91 typedef enum {
  92     /** @stable ICU 2.0 */
  93     UCNV_UNSUPPORTED_CONVERTER = -1,
  94     /** @stable ICU 2.0 */
  95     UCNV_SBCS = 0,
  96     /** @stable ICU 2.0 */
  97     UCNV_DBCS = 1,
  98     /** @stable ICU 2.0 */
  99     UCNV_MBCS = 2,
 100     /** @stable ICU 2.0 */
 101     UCNV_LATIN_1 = 3,
 102     /** @stable ICU 2.0 */
 103     UCNV_UTF8 = 4,
 104     /** @stable ICU 2.0 */
 105     UCNV_UTF16_BigEndian = 5,
 106     /** @stable ICU 2.0 */
 107     UCNV_UTF16_LittleEndian = 6,
 108     /** @stable ICU 2.0 */
 109     UCNV_UTF32_BigEndian = 7,
 110     /** @stable ICU 2.0 */
 111     UCNV_UTF32_LittleEndian = 8,
 112     /** @stable ICU 2.0 */
 113     UCNV_EBCDIC_STATEFUL = 9,
 114     /** @stable ICU 2.0 */
 115     UCNV_ISO_2022 = 10,
 116 
 117     /** @stable ICU 2.0 */
 118     UCNV_LMBCS_1 = 11,
 119     /** @stable ICU 2.0 */
 120     UCNV_LMBCS_2,
 121     /** @stable ICU 2.0 */
 122     UCNV_LMBCS_3,
 123     /** @stable ICU 2.0 */
 124     UCNV_LMBCS_4,
 125     /** @stable ICU 2.0 */
 126     UCNV_LMBCS_5,
 127     /** @stable ICU 2.0 */
 128     UCNV_LMBCS_6,
 129     /** @stable ICU 2.0 */
 130     UCNV_LMBCS_8,
 131     /** @stable ICU 2.0 */
 132     UCNV_LMBCS_11,
 133     /** @stable ICU 2.0 */
 134     UCNV_LMBCS_16,
 135     /** @stable ICU 2.0 */
 136     UCNV_LMBCS_17,
 137     /** @stable ICU 2.0 */
 138     UCNV_LMBCS_18,
 139     /** @stable ICU 2.0 */
 140     UCNV_LMBCS_19,
 141     /** @stable ICU 2.0 */
 142     UCNV_LMBCS_LAST = UCNV_LMBCS_19,
 143     /** @stable ICU 2.0 */
 144     UCNV_HZ,
 145     /** @stable ICU 2.0 */
 146     UCNV_SCSU,
 147     /** @stable ICU 2.0 */
 148     UCNV_ISCII,
 149     /** @stable ICU 2.0 */
 150     UCNV_US_ASCII,
 151     /** @stable ICU 2.0 */
 152     UCNV_UTF7,
 153     /** @stable ICU 2.2 */
 154     UCNV_BOCU1,
 155     /** @stable ICU 2.2 */
 156     UCNV_UTF16,
 157     /** @stable ICU 2.2 */
 158     UCNV_UTF32,
 159     /** @stable ICU 2.2 */
 160     UCNV_CESU8,
 161     /** @stable ICU 2.4 */
 162     UCNV_IMAP_MAILBOX,
 163     /** @stable ICU 4.8 */
 164     UCNV_COMPOUND_TEXT,
 165 
 166     /* Number of converter types for which we have conversion routines. */
 167     UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES
 168 } UConverterType;
 169 
 170 /**
 171  * Enum for specifying which platform a converter ID refers to.
 172  * The use of platform/CCSID is not recommended. See ucnv_openCCSID().
 173  *
 174  * @see ucnv_getPlatform
 175  * @see ucnv_openCCSID
 176  * @see ucnv_getCCSID
 177  * @stable ICU 2.0
 178  */
 179 typedef enum {
 180     UCNV_UNKNOWN = -1,
 181     UCNV_IBM = 0
 182 } UConverterPlatform;
 183 
 184 /**
 185  * Function pointer for error callback in the codepage to unicode direction.
 186  * Called when an error has occurred in conversion to unicode, or on open/close of the callback (see reason).
 187  * @param context Pointer to the callback&#39;s private data
 188  * @param args Information about the conversion in progress
 189  * @param codeUnits Points to &#39;length&#39; bytes of the concerned codepage sequence
 190  * @param length Size (in bytes) of the concerned codepage sequence
 191  * @param reason Defines the reason the callback was invoked
 192  * @param pErrorCode    ICU error code in/out parameter.
 193  *                      For converter callback functions, set to a conversion error
 194  *                      before the call, and the callback may reset it to U_ZERO_ERROR.
 195  * @see ucnv_setToUCallBack
 196  * @see UConverterToUnicodeArgs
 197  * @stable ICU 2.0
 198  */
 199 typedef void (U_EXPORT2 *UConverterToUCallback) (
 200                   const void* context,
 201                   UConverterToUnicodeArgs *args,
 202                   const char *codeUnits,
 203                   int32_t length,
 204                   UConverterCallbackReason reason,
 205                   UErrorCode *pErrorCode);
 206 
 207 /**
 208  * Function pointer for error callback in the unicode to codepage direction.
 209  * Called when an error has occurred in conversion from unicode, or on open/close of the callback (see reason).
 210  * @param context Pointer to the callback&#39;s private data
 211  * @param args Information about the conversion in progress
 212  * @param codeUnits Points to &#39;length&#39; UChars of the concerned Unicode sequence
 213  * @param length Size (in bytes) of the concerned codepage sequence
 214  * @param codePoint Single UChar32 (UTF-32) containing the concerend Unicode codepoint.
 215  * @param reason Defines the reason the callback was invoked
 216  * @param pErrorCode    ICU error code in/out parameter.
 217  *                      For converter callback functions, set to a conversion error
 218  *                      before the call, and the callback may reset it to U_ZERO_ERROR.
 219  * @see ucnv_setFromUCallBack
 220  * @stable ICU 2.0
 221  */
 222 typedef void (U_EXPORT2 *UConverterFromUCallback) (
 223                     const void* context,
 224                     UConverterFromUnicodeArgs *args,
 225                     const UChar* codeUnits,
 226                     int32_t length,
 227                     UChar32 codePoint,
 228                     UConverterCallbackReason reason,
 229                     UErrorCode *pErrorCode);
 230 
 231 U_CDECL_END
 232 
 233 /**
 234  * Character that separates converter names from options and options from each other.
 235  * @see ucnv_open
 236  * @stable ICU 2.0
 237  */
 238 #define UCNV_OPTION_SEP_CHAR &#39;,&#39;
 239 
 240 /**
 241  * String version of UCNV_OPTION_SEP_CHAR.
 242  * @see ucnv_open
 243  * @stable ICU 2.0
 244  */
 245 #define UCNV_OPTION_SEP_STRING &quot;,&quot;
 246 
 247 /**
 248  * Character that separates a converter option from its value.
 249  * @see ucnv_open
 250  * @stable ICU 2.0
 251  */
 252 #define UCNV_VALUE_SEP_CHAR &#39;=&#39;
 253 
 254 /**
 255  * String version of UCNV_VALUE_SEP_CHAR.
 256  * @see ucnv_open
 257  * @stable ICU 2.0
 258  */
 259 #define UCNV_VALUE_SEP_STRING &quot;=&quot;
 260 
 261 /**
 262  * Converter option for specifying a locale.
 263  * For example, ucnv_open(&quot;SCSU,locale=ja&quot;, &amp;errorCode);
 264  * See convrtrs.txt.
 265  *
 266  * @see ucnv_open
 267  * @stable ICU 2.0
 268  */
 269 #define UCNV_LOCALE_OPTION_STRING &quot;,locale=&quot;
 270 
 271 /**
 272  * Converter option for specifying a version selector (0..9) for some converters.
 273  * For example,
 274  * \code
 275  *   ucnv_open(&quot;UTF-7,version=1&quot;, &amp;errorCode);
 276  * \endcode
 277  * See convrtrs.txt.
 278  *
 279  * @see ucnv_open
 280  * @stable ICU 2.4
 281  */
 282 #define UCNV_VERSION_OPTION_STRING &quot;,version=&quot;
 283 
 284 /**
 285  * Converter option for EBCDIC SBCS or mixed-SBCS/DBCS (stateful) codepages.
 286  * Swaps Unicode mappings for EBCDIC LF and NL codes, as used on
 287  * S/390 (z/OS) Unix System Services (Open Edition).
 288  * For example, ucnv_open(&quot;ibm-1047,swaplfnl&quot;, &amp;errorCode);
 289  * See convrtrs.txt.
 290  *
 291  * @see ucnv_open
 292  * @stable ICU 2.4
 293  */
 294 #define UCNV_SWAP_LFNL_OPTION_STRING &quot;,swaplfnl&quot;
 295 
 296 /**
 297  * Do a fuzzy compare of two converter/alias names.
 298  * The comparison is case-insensitive, ignores leading zeroes if they are not
 299  * followed by further digits, and ignores all but letters and digits.
 300  * Thus the strings &quot;UTF-8&quot;, &quot;utf_8&quot;, &quot;u*T@f08&quot; and &quot;Utf 8&quot; are exactly equivalent.
 301  * See section 1.4, Charset Alias Matching in Unicode Technical Standard #22
 302  * at http://www.unicode.org/reports/tr22/
 303  *
 304  * @param name1 a converter name or alias, zero-terminated
 305  * @param name2 a converter name or alias, zero-terminated
 306  * @return 0 if the names match, or a negative value if the name1
 307  * lexically precedes name2, or a positive value if the name1
 308  * lexically follows name2.
 309  * @stable ICU 2.0
 310  */
 311 U_STABLE int U_EXPORT2
 312 ucnv_compareNames(const char *name1, const char *name2);
 313 
 314 
 315 /**
 316  * Creates a UConverter object with the name of a coded character set specified as a C string.
 317  * The actual name will be resolved with the alias file
 318  * using a case-insensitive string comparison that ignores
 319  * leading zeroes and all non-alphanumeric characters.
 320  * E.g., the names &quot;UTF8&quot;, &quot;utf-8&quot;, &quot;u*T@f08&quot; and &quot;Utf 8&quot; are all equivalent.
 321  * (See also ucnv_compareNames().)
 322  * If &lt;code&gt;NULL&lt;/code&gt; is passed for the converter name, it will create one with the
 323  * getDefaultName return value.
 324  *
 325  * &lt;p&gt;A converter name for ICU 1.5 and above may contain options
 326  * like a locale specification to control the specific behavior of
 327  * the newly instantiated converter.
 328  * The meaning of the options depends on the particular converter.
 329  * If an option is not defined for or recognized by a given converter, then it is ignored.&lt;/p&gt;
 330  *
 331  * &lt;p&gt;Options are appended to the converter name string, with a
 332  * &lt;code&gt;UCNV_OPTION_SEP_CHAR&lt;/code&gt; between the name and the first option and
 333  * also between adjacent options.&lt;/p&gt;
 334  *
 335  * &lt;p&gt;If the alias is ambiguous, then the preferred converter is used
 336  * and the status is set to U_AMBIGUOUS_ALIAS_WARNING.&lt;/p&gt;
 337  *
 338  * &lt;p&gt;The conversion behavior and names can vary between platforms. ICU may
 339  * convert some characters differently from other platforms. Details on this topic
 340  * are in the &lt;a href=&quot;http://icu-project.org/userguide/conversion.html&quot;&gt;User&#39;s
 341  * Guide&lt;/a&gt;. Aliases starting with a &quot;cp&quot; prefix have no specific meaning
 342  * other than its an alias starting with the letters &quot;cp&quot;. Please do not
 343  * associate any meaning to these aliases.&lt;/p&gt;
 344  *
 345  * \snippet samples/ucnv/convsamp.cpp ucnv_open
 346  *
 347  * @param converterName Name of the coded character set table.
 348  *          This may have options appended to the string.
 349  *          IANA alias character set names, IBM CCSIDs starting with &quot;ibm-&quot;,
 350  *          Windows codepage numbers starting with &quot;windows-&quot; are frequently
 351  *          used for this parameter. See ucnv_getAvailableName and
 352  *          ucnv_getAlias for a complete list that is available.
 353  *          If this parameter is NULL, the default converter will be used.
 354  * @param err outgoing error status &lt;TT&gt;U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR&lt;/TT&gt;
 355  * @return the created Unicode converter object, or &lt;TT&gt;NULL&lt;/TT&gt; if an error occurred
 356  * @see ucnv_openU
 357  * @see ucnv_openCCSID
 358  * @see ucnv_getAvailableName
 359  * @see ucnv_getAlias
 360  * @see ucnv_getDefaultName
 361  * @see ucnv_close
 362  * @see ucnv_compareNames
 363  * @stable ICU 2.0
 364  */
 365 U_STABLE UConverter* U_EXPORT2
 366 ucnv_open(const char *converterName, UErrorCode *err);
 367 
 368 
 369 /**
 370  * Creates a Unicode converter with the names specified as unicode string.
 371  * The name should be limited to the ASCII-7 alphanumerics range.
 372  * The actual name will be resolved with the alias file
 373  * using a case-insensitive string comparison that ignores
 374  * leading zeroes and all non-alphanumeric characters.
 375  * E.g., the names &quot;UTF8&quot;, &quot;utf-8&quot;, &quot;u*T@f08&quot; and &quot;Utf 8&quot; are all equivalent.
 376  * (See also ucnv_compareNames().)
 377  * If &lt;TT&gt;NULL&lt;/TT&gt; is passed for the converter name, it will create
 378  * one with the ucnv_getDefaultName() return value.
 379  * If the alias is ambiguous, then the preferred converter is used
 380  * and the status is set to U_AMBIGUOUS_ALIAS_WARNING.
 381  *
 382  * &lt;p&gt;See ucnv_open for the complete details&lt;/p&gt;
 383  * @param name Name of the UConverter table in a zero terminated
 384  *        Unicode string
 385  * @param err outgoing error status &lt;TT&gt;U_MEMORY_ALLOCATION_ERROR,
 386  *        U_FILE_ACCESS_ERROR&lt;/TT&gt;
 387  * @return the created Unicode converter object, or &lt;TT&gt;NULL&lt;/TT&gt; if an
 388  *        error occurred
 389  * @see ucnv_open
 390  * @see ucnv_openCCSID
 391  * @see ucnv_close
 392  * @see ucnv_compareNames
 393  * @stable ICU 2.0
 394  */
 395 U_STABLE UConverter* U_EXPORT2
 396 ucnv_openU(const UChar *name,
 397            UErrorCode *err);
 398 
 399 /**
 400  * Creates a UConverter object from a CCSID number and platform pair.
 401  * Note that the usefulness of this function is limited to platforms with numeric
 402  * encoding IDs. Only IBM and Microsoft platforms use numeric (16-bit) identifiers for
 403  * encodings.
 404  *
 405  * In addition, IBM CCSIDs and Unicode conversion tables are not 1:1 related.
 406  * For many IBM CCSIDs there are multiple (up to six) Unicode conversion tables, and
 407  * for some Unicode conversion tables there are multiple CCSIDs.
 408  * Some &quot;alternate&quot; Unicode conversion tables are provided by the
 409  * IBM CDRA conversion table registry.
 410  * The most prominent example of a systematic modification of conversion tables that is
 411  * not provided in the form of conversion table files in the repository is
 412  * that S/390 Unix System Services swaps the codes for Line Feed and New Line in all
 413  * EBCDIC codepages, which requires such a swap in the Unicode conversion tables as well.
 414  *
 415  * Only IBM default conversion tables are accessible with ucnv_openCCSID().
 416  * ucnv_getCCSID() will return the same CCSID for all conversion tables that are associated
 417  * with that CCSID.
 418  *
 419  * Currently, the only &quot;platform&quot; supported in the ICU converter API is UCNV_IBM.
 420  *
 421  * In summary, the use of CCSIDs and the associated API functions is not recommended.
 422  *
 423  * In order to open a converter with the default IBM CDRA Unicode conversion table,
 424  * you can use this function or use the prefix &quot;ibm-&quot;:
 425  * \code
 426  *     char name[20];
 427  *     sprintf(name, &quot;ibm-%hu&quot;, ccsid);
 428  *     cnv=ucnv_open(name, &amp;errorCode);
 429  * \endcode
 430  *
 431  * In order to open a converter with the IBM S/390 Unix System Services variant
 432  * of a Unicode/EBCDIC conversion table,
 433  * you can use the prefix &quot;ibm-&quot; together with the option string UCNV_SWAP_LFNL_OPTION_STRING:
 434  * \code
 435  *     char name[20];
 436  *     sprintf(name, &quot;ibm-%hu&quot; UCNV_SWAP_LFNL_OPTION_STRING, ccsid);
 437  *     cnv=ucnv_open(name, &amp;errorCode);
 438  * \endcode
 439  *
 440  * In order to open a converter from a Microsoft codepage number, use the prefix &quot;cp&quot;:
 441  * \code
 442  *     char name[20];
 443  *     sprintf(name, &quot;cp%hu&quot;, codepageID);
 444  *     cnv=ucnv_open(name, &amp;errorCode);
 445  * \endcode
 446  *
 447  * If the alias is ambiguous, then the preferred converter is used
 448  * and the status is set to U_AMBIGUOUS_ALIAS_WARNING.
 449  *
 450  * @param codepage codepage number to create
 451  * @param platform the platform in which the codepage number exists
 452  * @param err error status &lt;TT&gt;U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR&lt;/TT&gt;
 453  * @return the created Unicode converter object, or &lt;TT&gt;NULL&lt;/TT&gt; if an error
 454  *   occurred.
 455  * @see ucnv_open
 456  * @see ucnv_openU
 457  * @see ucnv_close
 458  * @see ucnv_getCCSID
 459  * @see ucnv_getPlatform
 460  * @see UConverterPlatform
 461  * @stable ICU 2.0
 462  */
 463 U_STABLE UConverter* U_EXPORT2
 464 ucnv_openCCSID(int32_t codepage,
 465                UConverterPlatform platform,
 466                UErrorCode * err);
 467 
 468 /**
 469  * &lt;p&gt;Creates a UConverter object specified from a packageName and a converterName.&lt;/p&gt;
 470  *
 471  * &lt;p&gt;The packageName and converterName must point to an ICU udata object, as defined by
 472  *   &lt;code&gt; udata_open( packageName, &quot;cnv&quot;, converterName, err) &lt;/code&gt; or equivalent.
 473  * Typically, packageName will refer to a (.dat) file, or to a package registered with
 474  * udata_setAppData(). Using a full file or directory pathname for packageName is deprecated.&lt;/p&gt;
 475  *
 476  * &lt;p&gt;The name will NOT be looked up in the alias mechanism, nor will the converter be
 477  * stored in the converter cache or the alias table. The only way to open further converters
 478  * is call this function multiple times, or use the ucnv_safeClone() function to clone a
 479  * &#39;master&#39; converter.&lt;/p&gt;
 480  *
 481  * &lt;p&gt;A future version of ICU may add alias table lookups and/or caching
 482  * to this function.&lt;/p&gt;
 483  *
 484  * &lt;p&gt;Example Use:
 485  *      &lt;code&gt;cnv = ucnv_openPackage(&quot;myapp&quot;, &quot;myconverter&quot;, &amp;err);&lt;/code&gt;
 486  * &lt;/p&gt;
 487  *
 488  * @param packageName name of the package (equivalent to &#39;path&#39; in udata_open() call)
 489  * @param converterName name of the data item to be used, without suffix.
 490  * @param err outgoing error status &lt;TT&gt;U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR&lt;/TT&gt;
 491  * @return the created Unicode converter object, or &lt;TT&gt;NULL&lt;/TT&gt; if an error occurred
 492  * @see udata_open
 493  * @see ucnv_open
 494  * @see ucnv_safeClone
 495  * @see ucnv_close
 496  * @stable ICU 2.2
 497  */
 498 U_STABLE UConverter* U_EXPORT2
 499 ucnv_openPackage(const char *packageName, const char *converterName, UErrorCode *err);
 500 
 501 /**
 502  * Thread safe converter cloning operation.
 503  * For most efficient operation, pass in a stackBuffer (and a *pBufferSize)
 504  * with at least U_CNV_SAFECLONE_BUFFERSIZE bytes of space.
 505  * If the buffer size is sufficient, then the clone will use the stack buffer;
 506  * otherwise, it will be allocated, and *pBufferSize will indicate
 507  * the actual size. (This should not occur with U_CNV_SAFECLONE_BUFFERSIZE.)
 508  *
 509  * You must ucnv_close() the clone in any case.
 510  *
 511  * If *pBufferSize==0, (regardless of whether stackBuffer==NULL or not)
 512  * then *pBufferSize will be changed to a sufficient size
 513  * for cloning this converter,
 514  * without actually cloning the converter (&quot;pure pre-flighting&quot;).
 515  *
 516  * If *pBufferSize is greater than zero but not large enough for a stack-based
 517  * clone, then the converter is cloned using newly allocated memory
 518  * and *pBufferSize is changed to the necessary size.
 519  *
 520  * If the converter clone fits into the stack buffer but the stack buffer is not
 521  * sufficiently aligned for the clone, then the clone will use an
 522  * adjusted pointer and use an accordingly smaller buffer size.
 523  *
 524  * @param cnv converter to be cloned
 525  * @param stackBuffer &lt;em&gt;Deprecated functionality as of ICU 52, use NULL.&lt;/em&gt;&lt;br&gt;
 526  *  user allocated space for the new clone. If NULL new memory will be allocated.
 527  *  If buffer is not large enough, new memory will be allocated.
 528  *  Clients can use the U_CNV_SAFECLONE_BUFFERSIZE. This will probably be enough to avoid memory allocations.
 529  * @param pBufferSize &lt;em&gt;Deprecated functionality as of ICU 52, use NULL or 1.&lt;/em&gt;&lt;br&gt;
 530  *  pointer to size of allocated space.
 531  * @param status to indicate whether the operation went on smoothly or there were errors
 532  *  An informational status value, U_SAFECLONE_ALLOCATED_WARNING,
 533  *  is used if any allocations were necessary.
 534  *  However, it is better to check if *pBufferSize grew for checking for
 535  *  allocations because warning codes can be overridden by subsequent
 536  *  function calls.
 537  * @return pointer to the new clone
 538  * @stable ICU 2.0
 539  */
 540 U_STABLE UConverter * U_EXPORT2
 541 ucnv_safeClone(const UConverter *cnv,
 542                void             *stackBuffer,
 543                int32_t          *pBufferSize,
 544                UErrorCode       *status);
 545 
 546 #ifndef U_HIDE_DEPRECATED_API
 547 
 548 /**
 549  * \def U_CNV_SAFECLONE_BUFFERSIZE
 550  * Definition of a buffer size that is designed to be large enough for
 551  * converters to be cloned with ucnv_safeClone().
 552  * @deprecated ICU 52. Do not rely on ucnv_safeClone() cloning into any provided buffer.
 553  */
 554 #define U_CNV_SAFECLONE_BUFFERSIZE  1024
 555 
 556 #endif /* U_HIDE_DEPRECATED_API */
 557 
 558 /**
 559  * Deletes the unicode converter and releases resources associated
 560  * with just this instance.
 561  * Does not free up shared converter tables.
 562  *
 563  * @param converter the converter object to be deleted
 564  * @see ucnv_open
 565  * @see ucnv_openU
 566  * @see ucnv_openCCSID
 567  * @stable ICU 2.0
 568  */
 569 U_STABLE void  U_EXPORT2
 570 ucnv_close(UConverter * converter);
 571 
 572 #if U_SHOW_CPLUSPLUS_API
 573 
 574 U_NAMESPACE_BEGIN
 575 
 576 /**
 577  * \class LocalUConverterPointer
 578  * &quot;Smart pointer&quot; class, closes a UConverter via ucnv_close().
 579  * For most methods see the LocalPointerBase base class.
 580  *
 581  * @see LocalPointerBase
 582  * @see LocalPointer
 583  * @stable ICU 4.4
 584  */
 585 U_DEFINE_LOCAL_OPEN_POINTER(LocalUConverterPointer, UConverter, ucnv_close);
 586 
 587 U_NAMESPACE_END
 588 
 589 #endif
 590 
 591 /**
 592  * Fills in the output parameter, subChars, with the substitution characters
 593  * as multiple bytes.
 594  * If ucnv_setSubstString() set a Unicode string because the converter is
 595  * stateful, then subChars will be an empty string.
 596  *
 597  * @param converter the Unicode converter
 598  * @param subChars the substitution characters
 599  * @param len on input the capacity of subChars, on output the number
 600  * of bytes copied to it
 601  * @param  err the outgoing error status code.
 602  * If the substitution character array is too small, an
 603  * &lt;TT&gt;U_INDEX_OUTOFBOUNDS_ERROR&lt;/TT&gt; will be returned.
 604  * @see ucnv_setSubstString
 605  * @see ucnv_setSubstChars
 606  * @stable ICU 2.0
 607  */
 608 U_STABLE void U_EXPORT2
 609 ucnv_getSubstChars(const UConverter *converter,
 610                    char *subChars,
 611                    int8_t *len,
 612                    UErrorCode *err);
 613 
 614 /**
 615  * Sets the substitution chars when converting from unicode to a codepage. The
 616  * substitution is specified as a string of 1-4 bytes, and may contain
 617  * &lt;TT&gt;NULL&lt;/TT&gt; bytes.
 618  * The subChars must represent a single character. The caller needs to know the
 619  * byte sequence of a valid character in the converter&#39;s charset.
 620  * For some converters, for example some ISO 2022 variants, only single-byte
 621  * substitution characters may be supported.
 622  * The newer ucnv_setSubstString() function relaxes these limitations.
 623  *
 624  * @param converter the Unicode converter
 625  * @param subChars the substitution character byte sequence we want set
 626  * @param len the number of bytes in subChars
 627  * @param err the error status code.  &lt;TT&gt;U_INDEX_OUTOFBOUNDS_ERROR &lt;/TT&gt; if
 628  * len is bigger than the maximum number of bytes allowed in subchars
 629  * @see ucnv_setSubstString
 630  * @see ucnv_getSubstChars
 631  * @stable ICU 2.0
 632  */
 633 U_STABLE void U_EXPORT2
 634 ucnv_setSubstChars(UConverter *converter,
 635                    const char *subChars,
 636                    int8_t len,
 637                    UErrorCode *err);
 638 
 639 /**
 640  * Set a substitution string for converting from Unicode to a charset.
 641  * The caller need not know the charset byte sequence for each charset.
 642  *
 643  * Unlike ucnv_setSubstChars() which is designed to set a charset byte sequence
 644  * for a single character, this function takes a Unicode string with
 645  * zero, one or more characters, and immediately verifies that the string can be
 646  * converted to the charset.
 647  * If not, or if the result is too long (more than 32 bytes as of ICU 3.6),
 648  * then the function returns with an error accordingly.
 649  *
 650  * Also unlike ucnv_setSubstChars(), this function works for stateful charsets
 651  * by converting on the fly at the point of substitution rather than setting
 652  * a fixed byte sequence.
 653  *
 654  * @param cnv The UConverter object.
 655  * @param s The Unicode string.
 656  * @param length The number of UChars in s, or -1 for a NUL-terminated string.
 657  * @param err Pointer to a standard ICU error code. Its input value must
 658  *            pass the U_SUCCESS() test, or else the function returns
 659  *            immediately. Check for U_FAILURE() on output or use with
 660  *            function chaining. (See User Guide for details.)
 661  *
 662  * @see ucnv_setSubstChars
 663  * @see ucnv_getSubstChars
 664  * @stable ICU 3.6
 665  */
 666 U_STABLE void U_EXPORT2
 667 ucnv_setSubstString(UConverter *cnv,
 668                     const UChar *s,
 669                     int32_t length,
 670                     UErrorCode *err);
 671 
 672 /**
 673  * Fills in the output parameter, errBytes, with the error characters from the
 674  * last failing conversion.
 675  *
 676  * @param converter the Unicode converter
 677  * @param errBytes the codepage bytes which were in error
 678  * @param len on input the capacity of errBytes, on output the number of
 679  *  bytes which were copied to it
 680  * @param err the error status code.
 681  * If the substitution character array is too small, an
 682  * &lt;TT&gt;U_INDEX_OUTOFBOUNDS_ERROR&lt;/TT&gt; will be returned.
 683  * @stable ICU 2.0
 684  */
 685 U_STABLE void U_EXPORT2
 686 ucnv_getInvalidChars(const UConverter *converter,
 687                      char *errBytes,
 688                      int8_t *len,
 689                      UErrorCode *err);
 690 
 691 /**
 692  * Fills in the output parameter, errChars, with the error characters from the
 693  * last failing conversion.
 694  *
 695  * @param converter the Unicode converter
 696  * @param errUChars the UChars which were in error
 697  * @param len on input the capacity of errUChars, on output the number of
 698  *  UChars which were copied to it
 699  * @param err the error status code.
 700  * If the substitution character array is too small, an
 701  * &lt;TT&gt;U_INDEX_OUTOFBOUNDS_ERROR&lt;/TT&gt; will be returned.
 702  * @stable ICU 2.0
 703  */
 704 U_STABLE void U_EXPORT2
 705 ucnv_getInvalidUChars(const UConverter *converter,
 706                       UChar *errUChars,
 707                       int8_t *len,
 708                       UErrorCode *err);
 709 
 710 /**
 711  * Resets the state of a converter to the default state. This is used
 712  * in the case of an error, to restart a conversion from a known default state.
 713  * It will also empty the internal output buffers.
 714  * @param converter the Unicode converter
 715  * @stable ICU 2.0
 716  */
 717 U_STABLE void U_EXPORT2
 718 ucnv_reset(UConverter *converter);
 719 
 720 /**
 721  * Resets the to-Unicode part of a converter state to the default state.
 722  * This is used in the case of an error to restart a conversion to
 723  * Unicode to a known default state. It will also empty the internal
 724  * output buffers used for the conversion to Unicode codepoints.
 725  * @param converter the Unicode converter
 726  * @stable ICU 2.0
 727  */
 728 U_STABLE void U_EXPORT2
 729 ucnv_resetToUnicode(UConverter *converter);
 730 
 731 /**
 732  * Resets the from-Unicode part of a converter state to the default state.
 733  * This is used in the case of an error to restart a conversion from
 734  * Unicode to a known default state. It will also empty the internal output
 735  * buffers used for the conversion from Unicode codepoints.
 736  * @param converter the Unicode converter
 737  * @stable ICU 2.0
 738  */
 739 U_STABLE void U_EXPORT2
 740 ucnv_resetFromUnicode(UConverter *converter);
 741 
 742 /**
 743  * Returns the maximum number of bytes that are output per UChar in conversion
 744  * from Unicode using this converter.
 745  * The returned number can be used with UCNV_GET_MAX_BYTES_FOR_STRING
 746  * to calculate the size of a target buffer for conversion from Unicode.
 747  *
 748  * Note: Before ICU 2.8, this function did not return reliable numbers for
 749  * some stateful converters (EBCDIC_STATEFUL, ISO-2022) and LMBCS.
 750  *
 751  * This number may not be the same as the maximum number of bytes per
 752  * &quot;conversion unit&quot;. In other words, it may not be the intuitively expected
 753  * number of bytes per character that would be published for a charset,
 754  * and may not fulfill any other purpose than the allocation of an output
 755  * buffer of guaranteed sufficient size for a given input length and converter.
 756  *
 757  * Examples for special cases that are taken into account:
 758  * - Supplementary code points may convert to more bytes than BMP code points.
 759  *   This function returns bytes per UChar (UTF-16 code unit), not per
 760  *   Unicode code point, for efficient buffer allocation.
 761  * - State-shifting output (SI/SO, escapes, etc.) from stateful converters.
 762  * - When m input UChars are converted to n output bytes, then the maximum m/n
 763  *   is taken into account.
 764  *
 765  * The number returned here does not take into account
 766  * (see UCNV_GET_MAX_BYTES_FOR_STRING):
 767  * - callbacks which output more than one charset character sequence per call,
 768  *   like escape callbacks
 769  * - initial and final non-character bytes that are output by some converters
 770  *   (automatic BOMs, initial escape sequence, final SI, etc.)
 771  *
 772  * Examples for returned values:
 773  * - SBCS charsets: 1
 774  * - Shift-JIS: 2
 775  * - UTF-16: 2 (2 per BMP, 4 per surrogate _pair_, BOM not counted)
 776  * - UTF-8: 3 (3 per BMP, 4 per surrogate _pair_)
 777  * - EBCDIC_STATEFUL (EBCDIC mixed SBCS/DBCS): 3 (SO + DBCS)
 778  * - ISO-2022: 3 (always outputs UTF-8)
 779  * - ISO-2022-JP: 6 (4-byte escape sequences + DBCS)
 780  * - ISO-2022-CN: 8 (4-byte designator sequences + 2-byte SS2/SS3 + DBCS)
 781  *
 782  * @param converter The Unicode converter.
 783  * @return The maximum number of bytes per UChar (16 bit code unit)
 784  *    that are output by ucnv_fromUnicode(),
 785  *    to be used together with UCNV_GET_MAX_BYTES_FOR_STRING
 786  *    for buffer allocation.
 787  *
 788  * @see UCNV_GET_MAX_BYTES_FOR_STRING
 789  * @see ucnv_getMinCharSize
 790  * @stable ICU 2.0
 791  */
 792 U_STABLE int8_t U_EXPORT2
 793 ucnv_getMaxCharSize(const UConverter *converter);
 794 
 795 /**
 796  * Calculates the size of a buffer for conversion from Unicode to a charset.
 797  * The calculated size is guaranteed to be sufficient for this conversion.
 798  *
 799  * It takes into account initial and final non-character bytes that are output
 800  * by some converters.
 801  * It does not take into account callbacks which output more than one charset
 802  * character sequence per call, like escape callbacks.
 803  * The default (substitution) callback only outputs one charset character sequence.
 804  *
 805  * @param length Number of UChars to be converted.
 806  * @param maxCharSize Return value from ucnv_getMaxCharSize() for the converter
 807  *                    that will be used.
 808  * @return Size of a buffer that will be large enough to hold the output bytes of
 809  *         converting length UChars with the converter that returned the maxCharSize.
 810  *
 811  * @see ucnv_getMaxCharSize
 812  * @stable ICU 2.8
 813  */
 814 #define UCNV_GET_MAX_BYTES_FOR_STRING(length, maxCharSize) \
 815      (((int32_t)(length)+10)*(int32_t)(maxCharSize))
 816 
 817 /**
 818  * Returns the minimum byte length (per codepoint) for characters in this codepage.
 819  * This is usually either 1 or 2.
 820  * @param converter the Unicode converter
 821  * @return the minimum number of bytes per codepoint allowed by this particular converter
 822  * @see ucnv_getMaxCharSize
 823  * @stable ICU 2.0
 824  */
 825 U_STABLE int8_t U_EXPORT2
 826 ucnv_getMinCharSize(const UConverter *converter);
 827 
 828 /**
 829  * Returns the display name of the converter passed in based on the Locale
 830  * passed in. If the locale contains no display name, the internal ASCII
 831  * name will be filled in.
 832  *
 833  * @param converter the Unicode converter.
 834  * @param displayLocale is the specific Locale we want to localized for
 835  * @param displayName user provided buffer to be filled in
 836  * @param displayNameCapacity size of displayName Buffer
 837  * @param err error status code
 838  * @return displayNameLength number of UChar needed in displayName
 839  * @see ucnv_getName
 840  * @stable ICU 2.0
 841  */
 842 U_STABLE int32_t U_EXPORT2
 843 ucnv_getDisplayName(const UConverter *converter,
 844                     const char *displayLocale,
 845                     UChar *displayName,
 846                     int32_t displayNameCapacity,
 847                     UErrorCode *err);
 848 
 849 /**
 850  * Gets the internal, canonical name of the converter (zero-terminated).
 851  * The lifetime of the returned string will be that of the converter
 852  * passed to this function.
 853  * @param converter the Unicode converter
 854  * @param err UErrorCode status
 855  * @return the internal name of the converter
 856  * @see ucnv_getDisplayName
 857  * @stable ICU 2.0
 858  */
 859 U_STABLE const char * U_EXPORT2
 860 ucnv_getName(const UConverter *converter, UErrorCode *err);
 861 
 862 /**
 863  * Gets a codepage number associated with the converter. This is not guaranteed
 864  * to be the one used to create the converter. Some converters do not represent
 865  * platform registered codepages and return zero for the codepage number.
 866  * The error code fill-in parameter indicates if the codepage number
 867  * is available.
 868  * Does not check if the converter is &lt;TT&gt;NULL&lt;/TT&gt; or if converter&#39;s data
 869  * table is &lt;TT&gt;NULL&lt;/TT&gt;.
 870  *
 871  * Important: The use of CCSIDs is not recommended because it is limited
 872  * to only two platforms in principle and only one (UCNV_IBM) in the current
 873  * ICU converter API.
 874  * Also, CCSIDs are insufficient to identify IBM Unicode conversion tables precisely.
 875  * For more details see ucnv_openCCSID().
 876  *
 877  * @param converter the Unicode converter
 878  * @param err the error status code.
 879  * @return If any error occurs, -1 will be returned otherwise, the codepage number
 880  * will be returned
 881  * @see ucnv_openCCSID
 882  * @see ucnv_getPlatform
 883  * @stable ICU 2.0
 884  */
 885 U_STABLE int32_t U_EXPORT2
 886 ucnv_getCCSID(const UConverter *converter,
 887               UErrorCode *err);
 888 
 889 /**
 890  * Gets a codepage platform associated with the converter. Currently,
 891  * only &lt;TT&gt;UCNV_IBM&lt;/TT&gt; will be returned.
 892  * Does not test if the converter is &lt;TT&gt;NULL&lt;/TT&gt; or if converter&#39;s data
 893  * table is &lt;TT&gt;NULL&lt;/TT&gt;.
 894  * @param converter the Unicode converter
 895  * @param err the error status code.
 896  * @return The codepage platform
 897  * @stable ICU 2.0
 898  */
 899 U_STABLE UConverterPlatform U_EXPORT2
 900 ucnv_getPlatform(const UConverter *converter,
 901                  UErrorCode *err);
 902 
 903 /**
 904  * Gets the type of the converter
 905  * e.g. SBCS, MBCS, DBCS, UTF8, UTF16_BE, UTF16_LE, ISO_2022,
 906  * EBCDIC_STATEFUL, LATIN_1
 907  * @param converter a valid, opened converter
 908  * @return the type of the converter
 909  * @stable ICU 2.0
 910  */
 911 U_STABLE UConverterType U_EXPORT2
 912 ucnv_getType(const UConverter * converter);
 913 
 914 /**
 915  * Gets the &quot;starter&quot; (lead) bytes for converters of type MBCS.
 916  * Will fill in an &lt;TT&gt;U_ILLEGAL_ARGUMENT_ERROR&lt;/TT&gt; if converter passed in
 917  * is not MBCS. Fills in an array of type UBool, with the value of the byte
 918  * as offset to the array. For example, if (starters[0x20] == TRUE) at return,
 919  * it means that the byte 0x20 is a starter byte in this converter.
 920  * Context pointers are always owned by the caller.
 921  *
 922  * @param converter a valid, opened converter of type MBCS
 923  * @param starters an array of size 256 to be filled in
 924  * @param err error status, &lt;TT&gt;U_ILLEGAL_ARGUMENT_ERROR&lt;/TT&gt; if the
 925  * converter is not a type which can return starters.
 926  * @see ucnv_getType
 927  * @stable ICU 2.0
 928  */
 929 U_STABLE void U_EXPORT2
 930 ucnv_getStarters(const UConverter* converter,
 931                  UBool starters[256],
 932                  UErrorCode* err);
 933 
 934 
 935 /**
 936  * Selectors for Unicode sets that can be returned by ucnv_getUnicodeSet().
 937  * @see ucnv_getUnicodeSet
 938  * @stable ICU 2.6
 939  */
 940 typedef enum UConverterUnicodeSet {
 941     /** Select the set of roundtrippable Unicode code points. @stable ICU 2.6 */
 942     UCNV_ROUNDTRIP_SET,
 943     /** Select the set of Unicode code points with roundtrip or fallback mappings. @stable ICU 4.0 */
 944     UCNV_ROUNDTRIP_AND_FALLBACK_SET,
 945 #ifndef U_HIDE_DEPRECATED_API
 946     /**
 947      * Number of UConverterUnicodeSet selectors.
 948      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
 949      */
 950     UCNV_SET_COUNT
 951 #endif  // U_HIDE_DEPRECATED_API
 952 } UConverterUnicodeSet;
 953 
 954 
 955 /**
 956  * Returns the set of Unicode code points that can be converted by an ICU converter.
 957  *
 958  * Returns one of several kinds of set:
 959  *
 960  * 1. UCNV_ROUNDTRIP_SET
 961  *
 962  * The set of all Unicode code points that can be roundtrip-converted
 963  * (converted without any data loss) with the converter (ucnv_fromUnicode()).
 964  * This set will not include code points that have fallback mappings
 965  * or are only the result of reverse fallback mappings.
 966  * This set will also not include PUA code points with fallbacks, although
 967  * ucnv_fromUnicode() will always uses those mappings despite ucnv_setFallback().
 968  * See UTR #22 &quot;Character Mapping Markup Language&quot;
 969  * at http://www.unicode.org/reports/tr22/
 970  *
 971  * This is useful for example for
 972  * - checking that a string or document can be roundtrip-converted with a converter,
 973  *   without/before actually performing the conversion
 974  * - testing if a converter can be used for text for typical text for a certain locale,
 975  *   by comparing its roundtrip set with the set of ExemplarCharacters from
 976  *   ICU&#39;s locale data or other sources
 977  *
 978  * 2. UCNV_ROUNDTRIP_AND_FALLBACK_SET
 979  *
 980  * The set of all Unicode code points that can be converted with the converter (ucnv_fromUnicode())
 981  * when fallbacks are turned on (see ucnv_setFallback()).
 982  * This set includes all code points with roundtrips and fallbacks (but not reverse fallbacks).
 983  *
 984  * In the future, there may be more UConverterUnicodeSet choices to select
 985  * sets with different properties.
 986  *
 987  * @param cnv The converter for which a set is requested.
 988  * @param setFillIn A valid USet *. It will be cleared by this function before
 989  *            the converter&#39;s specific set is filled into the USet.
 990  * @param whichSet A UConverterUnicodeSet selector;
 991  *              currently UCNV_ROUNDTRIP_SET is the only supported value.
 992  * @param pErrorCode ICU error code in/out parameter.
 993  *                   Must fulfill U_SUCCESS before the function call.
 994  *
 995  * @see UConverterUnicodeSet
 996  * @see uset_open
 997  * @see uset_close
 998  * @stable ICU 2.6
 999  */
1000 U_STABLE void U_EXPORT2
1001 ucnv_getUnicodeSet(const UConverter *cnv,
1002                    USet *setFillIn,
1003                    UConverterUnicodeSet whichSet,
1004                    UErrorCode *pErrorCode);
1005 
1006 /**
1007  * Gets the current calback function used by the converter when an illegal
1008  *  or invalid codepage sequence is found.
1009  * Context pointers are always owned by the caller.
1010  *
1011  * @param converter the unicode converter
1012  * @param action fillin: returns the callback function pointer
1013  * @param context fillin: returns the callback&#39;s private void* context
1014  * @see ucnv_setToUCallBack
1015  * @stable ICU 2.0
1016  */
1017 U_STABLE void U_EXPORT2
1018 ucnv_getToUCallBack (const UConverter * converter,
1019                      UConverterToUCallback *action,
1020                      const void **context);
1021 
1022 /**
1023  * Gets the current callback function used by the converter when illegal
1024  * or invalid Unicode sequence is found.
1025  * Context pointers are always owned by the caller.
1026  *
1027  * @param converter the unicode converter
1028  * @param action fillin: returns the callback function pointer
1029  * @param context fillin: returns the callback&#39;s private void* context
1030  * @see ucnv_setFromUCallBack
1031  * @stable ICU 2.0
1032  */
1033 U_STABLE void U_EXPORT2
1034 ucnv_getFromUCallBack (const UConverter * converter,
1035                        UConverterFromUCallback *action,
1036                        const void **context);
1037 
1038 /**
1039  * Changes the callback function used by the converter when
1040  * an illegal or invalid sequence is found.
1041  * Context pointers are always owned by the caller.
1042  * Predefined actions and contexts can be found in the ucnv_err.h header.
1043  *
1044  * @param converter the unicode converter
1045  * @param newAction the new callback function
1046  * @param newContext the new toUnicode callback context pointer. This can be NULL.
1047  * @param oldAction fillin: returns the old callback function pointer. This can be NULL.
1048  * @param oldContext fillin: returns the old callback&#39;s private void* context. This can be NULL.
1049  * @param err The error code status
1050  * @see ucnv_getToUCallBack
1051  * @stable ICU 2.0
1052  */
1053 U_STABLE void U_EXPORT2
1054 ucnv_setToUCallBack (UConverter * converter,
1055                      UConverterToUCallback newAction,
1056                      const void* newContext,
1057                      UConverterToUCallback *oldAction,
1058                      const void** oldContext,
1059                      UErrorCode * err);
1060 
1061 /**
1062  * Changes the current callback function used by the converter when
1063  * an illegal or invalid sequence is found.
1064  * Context pointers are always owned by the caller.
1065  * Predefined actions and contexts can be found in the ucnv_err.h header.
1066  *
1067  * @param converter the unicode converter
1068  * @param newAction the new callback function
1069  * @param newContext the new fromUnicode callback context pointer. This can be NULL.
1070  * @param oldAction fillin: returns the old callback function pointer. This can be NULL.
1071  * @param oldContext fillin: returns the old callback&#39;s private void* context. This can be NULL.
1072  * @param err The error code status
1073  * @see ucnv_getFromUCallBack
1074  * @stable ICU 2.0
1075  */
1076 U_STABLE void U_EXPORT2
1077 ucnv_setFromUCallBack (UConverter * converter,
1078                        UConverterFromUCallback newAction,
1079                        const void *newContext,
1080                        UConverterFromUCallback *oldAction,
1081                        const void **oldContext,
1082                        UErrorCode * err);
1083 
1084 /**
1085  * Converts an array of unicode characters to an array of codepage
1086  * characters. This function is optimized for converting a continuous
1087  * stream of data in buffer-sized chunks, where the entire source and
1088  * target does not fit in available buffers.
1089  *
1090  * The source pointer is an in/out parameter. It starts out pointing where the
1091  * conversion is to begin, and ends up pointing after the last UChar consumed.
1092  *
1093  * Target similarly starts out pointer at the first available byte in the output
1094  * buffer, and ends up pointing after the last byte written to the output.
1095  *
1096  * The converter always attempts to consume the entire source buffer, unless
1097  * (1.) the target buffer is full, or (2.) a failing error is returned from the
1098  * current callback function.  When a successful error status has been
1099  * returned, it means that all of the source buffer has been
1100  *  consumed. At that point, the caller should reset the source and
1101  *  sourceLimit pointers to point to the next chunk.
1102  *
1103  * At the end of the stream (flush==TRUE), the input is completely consumed
1104  * when *source==sourceLimit and no error code is set.
1105  * The converter object is then automatically reset by this function.
1106  * (This means that a converter need not be reset explicitly between data
1107  * streams if it finishes the previous stream without errors.)
1108  *
1109  * This is a &lt;I&gt;stateful&lt;/I&gt; conversion. Additionally, even when all source data has
1110  * been consumed, some data may be in the converters&#39; internal state.
1111  * Call this function repeatedly, updating the target pointers with
1112  * the next empty chunk of target in case of a
1113  * &lt;TT&gt;U_BUFFER_OVERFLOW_ERROR&lt;/TT&gt;, and updating the source  pointers
1114  *  with the next chunk of source when a successful error status is
1115  * returned, until there are no more chunks of source data.
1116  * @param converter the Unicode converter
1117  * @param target I/O parameter. Input : Points to the beginning of the buffer to copy
1118  *  codepage characters to. Output : points to after the last codepage character copied
1119  *  to &lt;TT&gt;target&lt;/TT&gt;.
1120  * @param targetLimit the pointer just after last of the &lt;TT&gt;target&lt;/TT&gt; buffer
1121  * @param source I/O parameter, pointer to pointer to the source Unicode character buffer.
1122  * @param sourceLimit the pointer just after the last of the source buffer
1123  * @param offsets if NULL is passed, nothing will happen to it, otherwise it needs to have the same number
1124  * of allocated cells as &lt;TT&gt;target&lt;/TT&gt;. Will fill in offsets from target to source pointer
1125  * e.g: &lt;TT&gt;offsets[3]&lt;/TT&gt; is equal to 6, it means that the &lt;TT&gt;target[3]&lt;/TT&gt; was a result of transcoding &lt;TT&gt;source[6]&lt;/TT&gt;
1126  * For output data carried across calls, and other data without a specific source character
1127  * (such as from escape sequences or callbacks)  -1 will be placed for offsets.
1128  * @param flush set to &lt;TT&gt;TRUE&lt;/TT&gt; if the current source buffer is the last available
1129  * chunk of the source, &lt;TT&gt;FALSE&lt;/TT&gt; otherwise. Note that if a failing status is returned,
1130  * this function may have to be called multiple times with flush set to &lt;TT&gt;TRUE&lt;/TT&gt; until
1131  * the source buffer is consumed.
1132  * @param err the error status.  &lt;TT&gt;U_ILLEGAL_ARGUMENT_ERROR&lt;/TT&gt; will be set if the
1133  * converter is &lt;TT&gt;NULL&lt;/TT&gt;.
1134  * &lt;code&gt;U_BUFFER_OVERFLOW_ERROR&lt;/code&gt; will be set if the target is full and there is
1135  * still data to be written to the target.
1136  * @see ucnv_fromUChars
1137  * @see ucnv_convert
1138  * @see ucnv_getMinCharSize
1139  * @see ucnv_setToUCallBack
1140  * @stable ICU 2.0
1141  */
1142 U_STABLE void U_EXPORT2
1143 ucnv_fromUnicode (UConverter * converter,
1144                   char **target,
1145                   const char *targetLimit,
1146                   const UChar ** source,
1147                   const UChar * sourceLimit,
1148                   int32_t* offsets,
1149                   UBool flush,
1150                   UErrorCode * err);
1151 
1152 /**
1153  * Converts a buffer of codepage bytes into an array of unicode UChars
1154  * characters. This function is optimized for converting a continuous
1155  * stream of data in buffer-sized chunks, where the entire source and
1156  * target does not fit in available buffers.
1157  *
1158  * The source pointer is an in/out parameter. It starts out pointing where the
1159  * conversion is to begin, and ends up pointing after the last byte of source consumed.
1160  *
1161  * Target similarly starts out pointer at the first available UChar in the output
1162  * buffer, and ends up pointing after the last UChar written to the output.
1163  * It does NOT necessarily keep UChar sequences together.
1164  *
1165  * The converter always attempts to consume the entire source buffer, unless
1166  * (1.) the target buffer is full, or (2.) a failing error is returned from the
1167  * current callback function.  When a successful error status has been
1168  * returned, it means that all of the source buffer has been
1169  *  consumed. At that point, the caller should reset the source and
1170  *  sourceLimit pointers to point to the next chunk.
1171  *
1172  * At the end of the stream (flush==TRUE), the input is completely consumed
1173  * when *source==sourceLimit and no error code is set
1174  * The converter object is then automatically reset by this function.
1175  * (This means that a converter need not be reset explicitly between data
1176  * streams if it finishes the previous stream without errors.)
1177  *
1178  * This is a &lt;I&gt;stateful&lt;/I&gt; conversion. Additionally, even when all source data has
1179  * been consumed, some data may be in the converters&#39; internal state.
1180  * Call this function repeatedly, updating the target pointers with
1181  * the next empty chunk of target in case of a
1182  * &lt;TT&gt;U_BUFFER_OVERFLOW_ERROR&lt;/TT&gt;, and updating the source  pointers
1183  *  with the next chunk of source when a successful error status is
1184  * returned, until there are no more chunks of source data.
1185  * @param converter the Unicode converter
1186  * @param target I/O parameter. Input : Points to the beginning of the buffer to copy
1187  *  UChars into. Output : points to after the last UChar copied.
1188  * @param targetLimit the pointer just after the end of the &lt;TT&gt;target&lt;/TT&gt; buffer
1189  * @param source I/O parameter, pointer to pointer to the source codepage buffer.
1190  * @param sourceLimit the pointer to the byte after the end of the source buffer
1191  * @param offsets if NULL is passed, nothing will happen to it, otherwise it needs to have the same number
1192  * of allocated cells as &lt;TT&gt;target&lt;/TT&gt;. Will fill in offsets from target to source pointer
1193  * e.g: &lt;TT&gt;offsets[3]&lt;/TT&gt; is equal to 6, it means that the &lt;TT&gt;target[3]&lt;/TT&gt; was a result of transcoding &lt;TT&gt;source[6]&lt;/TT&gt;
1194  * For output data carried across calls, and other data without a specific source character
1195  * (such as from escape sequences or callbacks)  -1 will be placed for offsets.
1196  * @param flush set to &lt;TT&gt;TRUE&lt;/TT&gt; if the current source buffer is the last available
1197  * chunk of the source, &lt;TT&gt;FALSE&lt;/TT&gt; otherwise. Note that if a failing status is returned,
1198  * this function may have to be called multiple times with flush set to &lt;TT&gt;TRUE&lt;/TT&gt; until
1199  * the source buffer is consumed.
1200  * @param err the error status.  &lt;TT&gt;U_ILLEGAL_ARGUMENT_ERROR&lt;/TT&gt; will be set if the
1201  * converter is &lt;TT&gt;NULL&lt;/TT&gt;.
1202  * &lt;code&gt;U_BUFFER_OVERFLOW_ERROR&lt;/code&gt; will be set if the target is full and there is
1203  * still data to be written to the target.
1204  * @see ucnv_fromUChars
1205  * @see ucnv_convert
1206  * @see ucnv_getMinCharSize
1207  * @see ucnv_setFromUCallBack
1208  * @see ucnv_getNextUChar
1209  * @stable ICU 2.0
1210  */
1211 U_STABLE void U_EXPORT2
1212 ucnv_toUnicode(UConverter *converter,
1213                UChar **target,
1214                const UChar *targetLimit,
1215                const char **source,
1216                const char *sourceLimit,
1217                int32_t *offsets,
1218                UBool flush,
1219                UErrorCode *err);
1220 
1221 /**
1222  * Convert the Unicode string into a codepage string using an existing UConverter.
1223  * The output string is NUL-terminated if possible.
1224  *
1225  * This function is a more convenient but less powerful version of ucnv_fromUnicode().
1226  * It is only useful for whole strings, not for streaming conversion.
1227  *
1228  * The maximum output buffer capacity required (barring output from callbacks) will be
1229  * UCNV_GET_MAX_BYTES_FOR_STRING(srcLength, ucnv_getMaxCharSize(cnv)).
1230  *
1231  * @param cnv the converter object to be used (ucnv_resetFromUnicode() will be called)
1232  * @param src the input Unicode string
1233  * @param srcLength the input string length, or -1 if NUL-terminated
1234  * @param dest destination string buffer, can be NULL if destCapacity==0
1235  * @param destCapacity the number of chars available at dest
1236  * @param pErrorCode normal ICU error code;
1237  *                  common error codes that may be set by this function include
1238  *                  U_BUFFER_OVERFLOW_ERROR, U_STRING_NOT_TERMINATED_WARNING,
1239  *                  U_ILLEGAL_ARGUMENT_ERROR, and conversion errors
1240  * @return the length of the output string, not counting the terminating NUL;
1241  *         if the length is greater than destCapacity, then the string will not fit
1242  *         and a buffer of the indicated length would need to be passed in
1243  * @see ucnv_fromUnicode
1244  * @see ucnv_convert
1245  * @see UCNV_GET_MAX_BYTES_FOR_STRING
1246  * @stable ICU 2.0
1247  */
1248 U_STABLE int32_t U_EXPORT2
1249 ucnv_fromUChars(UConverter *cnv,
1250                 char *dest, int32_t destCapacity,
1251                 const UChar *src, int32_t srcLength,
1252                 UErrorCode *pErrorCode);
1253 
1254 /**
1255  * Convert the codepage string into a Unicode string using an existing UConverter.
1256  * The output string is NUL-terminated if possible.
1257  *
1258  * This function is a more convenient but less powerful version of ucnv_toUnicode().
1259  * It is only useful for whole strings, not for streaming conversion.
1260  *
1261  * The maximum output buffer capacity required (barring output from callbacks) will be
1262  * 2*srcLength (each char may be converted into a surrogate pair).
1263  *
1264  * @param cnv the converter object to be used (ucnv_resetToUnicode() will be called)
1265  * @param src the input codepage string
1266  * @param srcLength the input string length, or -1 if NUL-terminated
1267  * @param dest destination string buffer, can be NULL if destCapacity==0
1268  * @param destCapacity the number of UChars available at dest
1269  * @param pErrorCode normal ICU error code;
1270  *                  common error codes that may be set by this function include
1271  *                  U_BUFFER_OVERFLOW_ERROR, U_STRING_NOT_TERMINATED_WARNING,
1272  *                  U_ILLEGAL_ARGUMENT_ERROR, and conversion errors
1273  * @return the length of the output string, not counting the terminating NUL;
1274  *         if the length is greater than destCapacity, then the string will not fit
1275  *         and a buffer of the indicated length would need to be passed in
1276  * @see ucnv_toUnicode
1277  * @see ucnv_convert
1278  * @stable ICU 2.0
1279  */
1280 U_STABLE int32_t U_EXPORT2
1281 ucnv_toUChars(UConverter *cnv,
1282               UChar *dest, int32_t destCapacity,
1283               const char *src, int32_t srcLength,
1284               UErrorCode *pErrorCode);
1285 
1286 /**
1287  * Convert a codepage buffer into Unicode one character at a time.
1288  * The input is completely consumed when the U_INDEX_OUTOFBOUNDS_ERROR is set.
1289  *
1290  * Advantage compared to ucnv_toUnicode() or ucnv_toUChars():
1291  * - Faster for small amounts of data, for most converters, e.g.,
1292  *   US-ASCII, ISO-8859-1, UTF-8/16/32, and most &quot;normal&quot; charsets.
1293  *   (For complex converters, e.g., SCSU, UTF-7 and ISO 2022 variants,
1294  *    it uses ucnv_toUnicode() internally.)
1295  * - Convenient.
1296  *
1297  * Limitations compared to ucnv_toUnicode():
1298  * - Always assumes flush=TRUE.
1299  *   This makes ucnv_getNextUChar() unsuitable for &quot;streaming&quot; conversion,
1300  *   that is, for where the input is supplied in multiple buffers,
1301  *   because ucnv_getNextUChar() will assume the end of the input at the end
1302  *   of the first buffer.
1303  * - Does not provide offset output.
1304  *
1305  * It is possible to &quot;mix&quot; ucnv_getNextUChar() and ucnv_toUnicode() because
1306  * ucnv_getNextUChar() uses the current state of the converter
1307  * (unlike ucnv_toUChars() which always resets first).
1308  * However, if ucnv_getNextUChar() is called after ucnv_toUnicode()
1309  * stopped in the middle of a character sequence (with flush=FALSE),
1310  * then ucnv_getNextUChar() will always use the slower ucnv_toUnicode()
1311  * internally until the next character boundary.
1312  * (This is new in ICU 2.6. In earlier releases, ucnv_getNextUChar() had to
1313  * start at a character boundary.)
1314  *
1315  * Instead of using ucnv_getNextUChar(), it is recommended
1316  * to convert using ucnv_toUnicode() or ucnv_toUChars()
1317  * and then iterate over the text using U16_NEXT() or a UCharIterator (uiter.h)
1318  * or a C++ CharacterIterator or similar.
1319  * This allows streaming conversion and offset output, for example.
1320  *
1321  * &lt;p&gt;Handling of surrogate pairs and supplementary-plane code points:&lt;br&gt;
1322  * There are two different kinds of codepages that provide mappings for surrogate characters:
1323  * &lt;ul&gt;
1324  *   &lt;li&gt;Codepages like UTF-8, UTF-32, and GB 18030 provide direct representations for Unicode
1325  *       code points U+10000-U+10ffff as well as for single surrogates U+d800-U+dfff.
1326  *       Each valid sequence will result in exactly one returned code point.
1327  *       If a sequence results in a single surrogate, then that will be returned
1328  *       by itself, even if a neighboring sequence encodes the matching surrogate.&lt;/li&gt;
1329  *   &lt;li&gt;Codepages like SCSU and LMBCS (and UTF-16) provide direct representations only for BMP code points
1330  *       including surrogates. Code points in supplementary planes are represented with
1331  *       two sequences, each encoding a surrogate.
1332  *       For these codepages, matching pairs of surrogates will be combined into single
1333  *       code points for returning from this function.
1334  *       (Note that SCSU is actually a mix of these codepage types.)&lt;/li&gt;
1335  * &lt;/ul&gt;&lt;/p&gt;
1336  *
1337  * @param converter an open UConverter
1338  * @param source the address of a pointer to the codepage buffer, will be
1339  *  updated to point after the bytes consumed in the conversion call.
1340  * @param sourceLimit points to the end of the input buffer
1341  * @param err fills in error status (see ucnv_toUnicode)
1342  * &lt;code&gt;U_INDEX_OUTOFBOUNDS_ERROR&lt;/code&gt; will be set if the input
1343  * is empty or does not convert to any output (e.g.: pure state-change
1344  * codes SI/SO, escape sequences for ISO 2022,
1345  * or if the callback did not output anything, ...).
1346  * This function will not set a &lt;code&gt;U_BUFFER_OVERFLOW_ERROR&lt;/code&gt; because
1347  *  the &quot;buffer&quot; is the return code. However, there might be subsequent output
1348  *  stored in the converter object
1349  * that will be returned in following calls to this function.
1350  * @return a UChar32 resulting from the partial conversion of source
1351  * @see ucnv_toUnicode
1352  * @see ucnv_toUChars
1353  * @see ucnv_convert
1354  * @stable ICU 2.0
1355  */
1356 U_STABLE UChar32 U_EXPORT2
1357 ucnv_getNextUChar(UConverter * converter,
1358                   const char **source,
1359                   const char * sourceLimit,
1360                   UErrorCode * err);
1361 
1362 /**
1363  * Convert from one external charset to another using two existing UConverters.
1364  * Internally, two conversions - ucnv_toUnicode() and ucnv_fromUnicode() -
1365  * are used, &quot;pivoting&quot; through 16-bit Unicode.
1366  *
1367  * Important: For streaming conversion (multiple function calls for successive
1368  * parts of a text stream), the caller must provide a pivot buffer explicitly,
1369  * and must preserve the pivot buffer and associated pointers from one
1370  * call to another. (The buffer may be moved if its contents and the relative
1371  * pointer positions are preserved.)
1372  *
1373  * There is a similar function, ucnv_convert(),
1374  * which has the following limitations:
1375  * - it takes charset names, not converter objects, so that
1376  *   - two converters are opened for each call
1377  *   - only single-string conversion is possible, not streaming operation
1378  * - it does not provide enough information to find out,
1379  *   in case of failure, whether the toUnicode or
1380  *   the fromUnicode conversion failed
1381  *
1382  * By contrast, ucnv_convertEx()
1383  * - takes UConverter parameters instead of charset names
1384  * - fully exposes the pivot buffer for streaming conversion and complete error handling
1385  *
1386  * ucnv_convertEx() also provides further convenience:
1387  * - an option to reset the converters at the beginning
1388  *   (if reset==TRUE, see parameters;
1389  *    also sets *pivotTarget=*pivotSource=pivotStart)
1390  * - allow NUL-terminated input
1391  *   (only a single NUL byte, will not work for charsets with multi-byte NULs)
1392  *   (if sourceLimit==NULL, see parameters)
1393  * - terminate with a NUL on output
1394  *   (only a single NUL byte, not useful for charsets with multi-byte NULs),
1395  *   or set U_STRING_NOT_TERMINATED_WARNING if the output exactly fills
1396  *   the target buffer
1397  * - the pivot buffer can be provided internally;
1398  *   possible only for whole-string conversion, not streaming conversion;
1399  *   in this case, the caller will not be able to get details about where an
1400  *   error occurred
1401  *   (if pivotStart==NULL, see below)
1402  *
1403  * The function returns when one of the following is true:
1404  * - the entire source text has been converted successfully to the target buffer
1405  * - a target buffer overflow occurred (U_BUFFER_OVERFLOW_ERROR)
1406  * - a conversion error occurred
1407  *   (other U_FAILURE(), see description of pErrorCode)
1408  *
1409  * Limitation compared to the direct use of
1410  * ucnv_fromUnicode() and ucnv_toUnicode():
1411  * ucnv_convertEx() does not provide offset information.
1412  *
1413  * Limitation compared to ucnv_fromUChars() and ucnv_toUChars():
1414  * ucnv_convertEx() does not support preflighting directly.
1415  *
1416  * Sample code for converting a single string from
1417  * one external charset to UTF-8, ignoring the location of errors:
1418  *
1419  * \code
1420  * int32_t
1421  * myToUTF8(UConverter *cnv,
1422  *          const char *s, int32_t length,
1423  *          char *u8, int32_t capacity,
1424  *          UErrorCode *pErrorCode) {
1425  *     UConverter *utf8Cnv;
1426  *     char *target;
1427  *
1428  *     if(U_FAILURE(*pErrorCode)) {
1429  *         return 0;
1430  *     }
1431  *
1432  *     utf8Cnv=myGetCachedUTF8Converter(pErrorCode);
1433  *     if(U_FAILURE(*pErrorCode)) {
1434  *         return 0;
1435  *     }
1436  *
1437  *     if(length&lt;0) {
1438  *         length=strlen(s);
1439  *     }
1440  *     target=u8;
1441  *     ucnv_convertEx(utf8Cnv, cnv,
1442  *                    &amp;target, u8+capacity,
1443  *                    &amp;s, s+length,
1444  *                    NULL, NULL, NULL, NULL,
1445  *                    TRUE, TRUE,
1446  *                    pErrorCode);
1447  *
1448  *     myReleaseCachedUTF8Converter(utf8Cnv);
1449  *
1450  *     // return the output string length, but without preflighting
1451  *     return (int32_t)(target-u8);
1452  * }
1453  * \endcode
1454  *
1455  * @param targetCnv     Output converter, used to convert from the UTF-16 pivot
1456  *                      to the target using ucnv_fromUnicode().
1457  * @param sourceCnv     Input converter, used to convert from the source to
1458  *                      the UTF-16 pivot using ucnv_toUnicode().
1459  * @param target        I/O parameter, same as for ucnv_fromUChars().
1460  *                      Input: *target points to the beginning of the target buffer.
1461  *                      Output: *target points to the first unit after the last char written.
1462  * @param targetLimit   Pointer to the first unit after the target buffer.
1463  * @param source        I/O parameter, same as for ucnv_toUChars().
1464  *                      Input: *source points to the beginning of the source buffer.
1465  *                      Output: *source points to the first unit after the last char read.
1466  * @param sourceLimit   Pointer to the first unit after the source buffer.
1467  * @param pivotStart    Pointer to the UTF-16 pivot buffer. If pivotStart==NULL,
1468  *                      then an internal buffer is used and the other pivot
1469  *                      arguments are ignored and can be NULL as well.
1470  * @param pivotSource   I/O parameter, same as source in ucnv_fromUChars() for
1471  *                      conversion from the pivot buffer to the target buffer.
1472  * @param pivotTarget   I/O parameter, same as target in ucnv_toUChars() for
1473  *                      conversion from the source buffer to the pivot buffer.
1474  *                      It must be pivotStart&lt;=*pivotSource&lt;=*pivotTarget&lt;=pivotLimit
1475  *                      and pivotStart&lt;pivotLimit (unless pivotStart==NULL).
1476  * @param pivotLimit    Pointer to the first unit after the pivot buffer.
1477  * @param reset         If TRUE, then ucnv_resetToUnicode(sourceCnv) and
1478  *                      ucnv_resetFromUnicode(targetCnv) are called, and the
1479  *                      pivot pointers are reset (*pivotTarget=*pivotSource=pivotStart).
1480  * @param flush         If true, indicates the end of the input.
1481  *                      Passed directly to ucnv_toUnicode(), and carried over to
1482  *                      ucnv_fromUnicode() when the source is empty as well.
1483  * @param pErrorCode    ICU error code in/out parameter.
1484  *                      Must fulfill U_SUCCESS before the function call.
1485  *                      U_BUFFER_OVERFLOW_ERROR always refers to the target buffer
1486  *                      because overflows into the pivot buffer are handled internally.
1487  *                      Other conversion errors are from the source-to-pivot
1488  *                      conversion if *pivotSource==pivotStart, otherwise from
1489  *                      the pivot-to-target conversion.
1490  *
1491  * @see ucnv_convert
1492  * @see ucnv_fromAlgorithmic
1493  * @see ucnv_toAlgorithmic
1494  * @see ucnv_fromUnicode
1495  * @see ucnv_toUnicode
1496  * @see ucnv_fromUChars
1497  * @see ucnv_toUChars
1498  * @stable ICU 2.6
1499  */
1500 U_STABLE void U_EXPORT2
1501 ucnv_convertEx(UConverter *targetCnv, UConverter *sourceCnv,
1502                char **target, const char *targetLimit,
1503                const char **source, const char *sourceLimit,
1504                UChar *pivotStart, UChar **pivotSource,
1505                UChar **pivotTarget, const UChar *pivotLimit,
1506                UBool reset, UBool flush,
1507                UErrorCode *pErrorCode);
1508 
1509 /**
1510  * Convert from one external charset to another.
1511  * Internally, two converters are opened according to the name arguments,
1512  * then the text is converted to and from the 16-bit Unicode &quot;pivot&quot;
1513  * using ucnv_convertEx(), then the converters are closed again.
1514  *
1515  * This is a convenience function, not an efficient way to convert a lot of text:
1516  * ucnv_convert()
1517  * - takes charset names, not converter objects, so that
1518  *   - two converters are opened for each call
1519  *   - only single-string conversion is possible, not streaming operation
1520  * - does not provide enough information to find out,
1521  *   in case of failure, whether the toUnicode or
1522  *   the fromUnicode conversion failed
1523  * - allows NUL-terminated input
1524  *   (only a single NUL byte, will not work for charsets with multi-byte NULs)
1525  *   (if sourceLength==-1, see parameters)
1526  * - terminate with a NUL on output
1527  *   (only a single NUL byte, not useful for charsets with multi-byte NULs),
1528  *   or set U_STRING_NOT_TERMINATED_WARNING if the output exactly fills
1529  *   the target buffer
1530  * - a pivot buffer is provided internally
1531  *
1532  * The function returns when one of the following is true:
1533  * - the entire source text has been converted successfully to the target buffer
1534  *   and either the target buffer is terminated with a single NUL byte
1535  *   or the error code is set to U_STRING_NOT_TERMINATED_WARNING
1536  * - a target buffer overflow occurred (U_BUFFER_OVERFLOW_ERROR)
1537  *   and the full output string length is returned (&quot;preflighting&quot;)
1538  * - a conversion error occurred
1539  *   (other U_FAILURE(), see description of pErrorCode)
1540  *
1541  * @param toConverterName   The name of the converter that is used to convert
1542  *                          from the UTF-16 pivot buffer to the target.
1543  * @param fromConverterName The name of the converter that is used to convert
1544  *                          from the source to the UTF-16 pivot buffer.
1545  * @param target            Pointer to the output buffer.
1546  * @param targetCapacity    Capacity of the target, in bytes.
1547  * @param source            Pointer to the input buffer.
1548  * @param sourceLength      Length of the input text, in bytes, or -1 for NUL-terminated input.
1549  * @param pErrorCode        ICU error code in/out parameter.
1550  *                          Must fulfill U_SUCCESS before the function call.
1551  * @return Length of the complete output text in bytes, even if it exceeds the targetCapacity
1552  *         and a U_BUFFER_OVERFLOW_ERROR is set.
1553  *
1554  * @see ucnv_convertEx
1555  * @see ucnv_fromAlgorithmic
1556  * @see ucnv_toAlgorithmic
1557  * @see ucnv_fromUnicode
1558  * @see ucnv_toUnicode
1559  * @see ucnv_fromUChars
1560  * @see ucnv_toUChars
1561  * @see ucnv_getNextUChar
1562  * @stable ICU 2.0
1563  */
1564 U_STABLE int32_t U_EXPORT2
1565 ucnv_convert(const char *toConverterName,
1566              const char *fromConverterName,
1567              char *target,
1568              int32_t targetCapacity,
1569              const char *source,
1570              int32_t sourceLength,
1571              UErrorCode *pErrorCode);
1572 
1573 /**
1574  * Convert from one external charset to another.
1575  * Internally, the text is converted to and from the 16-bit Unicode &quot;pivot&quot;
1576  * using ucnv_convertEx(). ucnv_toAlgorithmic() works exactly like ucnv_convert()
1577  * except that the two converters need not be looked up and opened completely.
1578  *
1579  * The source-to-pivot conversion uses the cnv converter parameter.
1580  * The pivot-to-target conversion uses a purely algorithmic converter
1581  * according to the specified type, e.g., UCNV_UTF8 for a UTF-8 converter.
1582  *
1583  * Internally, the algorithmic converter is opened and closed for each
1584  * function call, which is more efficient than using the public ucnv_open()
1585  * but somewhat less efficient than only resetting an existing converter
1586  * and using ucnv_convertEx().
1587  *
1588  * This function is more convenient than ucnv_convertEx() for single-string
1589  * conversions, especially when &quot;preflighting&quot; is desired (returning the length
1590  * of the complete output even if it does not fit into the target buffer;
1591  * see the User Guide Strings chapter). See ucnv_convert() for details.
1592  *
1593  * @param algorithmicType   UConverterType constant identifying the desired target
1594  *                          charset as a purely algorithmic converter.
1595  *                          Those are converters for Unicode charsets like
1596  *                          UTF-8, BOCU-1, SCSU, UTF-7, IMAP-mailbox-name, etc.,
1597  *                          as well as US-ASCII and ISO-8859-1.
1598  * @param cnv               The converter that is used to convert
1599  *                          from the source to the UTF-16 pivot buffer.
1600  * @param target            Pointer to the output buffer.
1601  * @param targetCapacity    Capacity of the target, in bytes.
1602  * @param source            Pointer to the input buffer.
1603  * @param sourceLength      Length of the input text, in bytes
1604  * @param pErrorCode        ICU error code in/out parameter.
1605  *                          Must fulfill U_SUCCESS before the function call.
1606  * @return Length of the complete output text in bytes, even if it exceeds the targetCapacity
1607  *         and a U_BUFFER_OVERFLOW_ERROR is set.
1608  *
1609  * @see ucnv_fromAlgorithmic
1610  * @see ucnv_convert
1611  * @see ucnv_convertEx
1612  * @see ucnv_fromUnicode
1613  * @see ucnv_toUnicode
1614  * @see ucnv_fromUChars
1615  * @see ucnv_toUChars
1616  * @stable ICU 2.6
1617  */
1618 U_STABLE int32_t U_EXPORT2
1619 ucnv_toAlgorithmic(UConverterType algorithmicType,
1620                    UConverter *cnv,
1621                    char *target, int32_t targetCapacity,
1622                    const char *source, int32_t sourceLength,
1623                    UErrorCode *pErrorCode);
1624 
1625 /**
1626  * Convert from one external charset to another.
1627  * Internally, the text is converted to and from the 16-bit Unicode &quot;pivot&quot;
1628  * using ucnv_convertEx(). ucnv_fromAlgorithmic() works exactly like ucnv_convert()
1629  * except that the two converters need not be looked up and opened completely.
1630  *
1631  * The source-to-pivot conversion uses a purely algorithmic converter
1632  * according to the specified type, e.g., UCNV_UTF8 for a UTF-8 converter.
1633  * The pivot-to-target conversion uses the cnv converter parameter.
1634  *
1635  * Internally, the algorithmic converter is opened and closed for each
1636  * function call, which is more efficient than using the public ucnv_open()
1637  * but somewhat less efficient than only resetting an existing converter
1638  * and using ucnv_convertEx().
1639  *
1640  * This function is more convenient than ucnv_convertEx() for single-string
1641  * conversions, especially when &quot;preflighting&quot; is desired (returning the length
1642  * of the complete output even if it does not fit into the target buffer;
1643  * see the User Guide Strings chapter). See ucnv_convert() for details.
1644  *
1645  * @param cnv               The converter that is used to convert
1646  *                          from the UTF-16 pivot buffer to the target.
1647  * @param algorithmicType   UConverterType constant identifying the desired source
1648  *                          charset as a purely algorithmic converter.
1649  *                          Those are converters for Unicode charsets like
1650  *                          UTF-8, BOCU-1, SCSU, UTF-7, IMAP-mailbox-name, etc.,
1651  *                          as well as US-ASCII and ISO-8859-1.
1652  * @param target            Pointer to the output buffer.
1653  * @param targetCapacity    Capacity of the target, in bytes.
1654  * @param source            Pointer to the input buffer.
1655  * @param sourceLength      Length of the input text, in bytes
1656  * @param pErrorCode        ICU error code in/out parameter.
1657  *                          Must fulfill U_SUCCESS before the function call.
1658  * @return Length of the complete output text in bytes, even if it exceeds the targetCapacity
1659  *         and a U_BUFFER_OVERFLOW_ERROR is set.
1660  *
1661  * @see ucnv_fromAlgorithmic
1662  * @see ucnv_convert
1663  * @see ucnv_convertEx
1664  * @see ucnv_fromUnicode
1665  * @see ucnv_toUnicode
1666  * @see ucnv_fromUChars
1667  * @see ucnv_toUChars
1668  * @stable ICU 2.6
1669  */
1670 U_STABLE int32_t U_EXPORT2
1671 ucnv_fromAlgorithmic(UConverter *cnv,
1672                      UConverterType algorithmicType,
1673                      char *target, int32_t targetCapacity,
1674                      const char *source, int32_t sourceLength,
1675                      UErrorCode *pErrorCode);
1676 
1677 /**
1678  * Frees up memory occupied by unused, cached converter shared data.
1679  *
1680  * @return the number of cached converters successfully deleted
1681  * @see ucnv_close
1682  * @stable ICU 2.0
1683  */
1684 U_STABLE int32_t U_EXPORT2
1685 ucnv_flushCache(void);
1686 
1687 /**
1688  * Returns the number of available converters, as per the alias file.
1689  *
1690  * @return the number of available converters
1691  * @see ucnv_getAvailableName
1692  * @stable ICU 2.0
1693  */
1694 U_STABLE int32_t U_EXPORT2
1695 ucnv_countAvailable(void);
1696 
1697 /**
1698  * Gets the canonical converter name of the specified converter from a list of
1699  * all available converters contaied in the alias file. All converters
1700  * in this list can be opened.
1701  *
1702  * @param n the index to a converter available on the system (in the range &lt;TT&gt;[0..ucnv_countAvaiable()]&lt;/TT&gt;)
1703  * @return a pointer a string (library owned), or &lt;TT&gt;NULL&lt;/TT&gt; if the index is out of bounds.
1704  * @see ucnv_countAvailable
1705  * @stable ICU 2.0
1706  */
1707 U_STABLE const char* U_EXPORT2
1708 ucnv_getAvailableName(int32_t n);
1709 
1710 /**
1711  * Returns a UEnumeration to enumerate all of the canonical converter
1712  * names, as per the alias file, regardless of the ability to open each
1713  * converter.
1714  *
1715  * @return A UEnumeration object for getting all the recognized canonical
1716  *   converter names.
1717  * @see ucnv_getAvailableName
1718  * @see uenum_close
1719  * @see uenum_next
1720  * @stable ICU 2.4
1721  */
1722 U_STABLE UEnumeration * U_EXPORT2
1723 ucnv_openAllNames(UErrorCode *pErrorCode);
1724 
1725 /**
1726  * Gives the number of aliases for a given converter or alias name.
1727  * If the alias is ambiguous, then the preferred converter is used
1728  * and the status is set to U_AMBIGUOUS_ALIAS_WARNING.
1729  * This method only enumerates the listed entries in the alias file.
1730  * @param alias alias name
1731  * @param pErrorCode error status
1732  * @return number of names on alias list for given alias
1733  * @stable ICU 2.0
1734  */
1735 U_STABLE uint16_t U_EXPORT2
1736 ucnv_countAliases(const char *alias, UErrorCode *pErrorCode);
1737 
1738 /**
1739  * Gives the name of the alias at given index of alias list.
1740  * This method only enumerates the listed entries in the alias file.
1741  * If the alias is ambiguous, then the preferred converter is used
1742  * and the status is set to U_AMBIGUOUS_ALIAS_WARNING.
1743  * @param alias alias name
1744  * @param n index in alias list
1745  * @param pErrorCode result of operation
1746  * @return returns the name of the alias at given index
1747  * @see ucnv_countAliases
1748  * @stable ICU 2.0
1749  */
1750 U_STABLE const char * U_EXPORT2
1751 ucnv_getAlias(const char *alias, uint16_t n, UErrorCode *pErrorCode);
1752 
1753 /**
1754  * Fill-up the list of alias names for the given alias.
1755  * This method only enumerates the listed entries in the alias file.
1756  * If the alias is ambiguous, then the preferred converter is used
1757  * and the status is set to U_AMBIGUOUS_ALIAS_WARNING.
1758  * @param alias alias name
1759  * @param aliases fill-in list, aliases is a pointer to an array of
1760  *        &lt;code&gt;ucnv_countAliases()&lt;/code&gt; string-pointers
1761  *        (&lt;code&gt;const char *&lt;/code&gt;) that will be filled in.
1762  *        The strings themselves are owned by the library.
1763  * @param pErrorCode result of operation
1764  * @stable ICU 2.0
1765  */
1766 U_STABLE void U_EXPORT2
1767 ucnv_getAliases(const char *alias, const char **aliases, UErrorCode *pErrorCode);
1768 
1769 /**
1770  * Return a new UEnumeration object for enumerating all the
1771  * alias names for a given converter that are recognized by a standard.
1772  * This method only enumerates the listed entries in the alias file.
1773  * The convrtrs.txt file can be modified to change the results of
1774  * this function.
1775  * The first result in this list is the same result given by
1776  * &lt;code&gt;ucnv_getStandardName&lt;/code&gt;, which is the default alias for
1777  * the specified standard name. The returned object must be closed with
1778  * &lt;code&gt;uenum_close&lt;/code&gt; when you are done with the object.
1779  *
1780  * @param convName original converter name
1781  * @param standard name of the standard governing the names; MIME and IANA
1782  *      are such standards
1783  * @param pErrorCode The error code
1784  * @return A UEnumeration object for getting all aliases that are recognized
1785  *      by a standard. If any of the parameters are invalid, NULL
1786  *      is returned.
1787  * @see ucnv_getStandardName
1788  * @see uenum_close
1789  * @see uenum_next
1790  * @stable ICU 2.2
1791  */
1792 U_STABLE UEnumeration * U_EXPORT2
1793 ucnv_openStandardNames(const char *convName,
1794                        const char *standard,
1795                        UErrorCode *pErrorCode);
1796 
1797 /**
1798  * Gives the number of standards associated to converter names.
1799  * @return number of standards
1800  * @stable ICU 2.0
1801  */
1802 U_STABLE uint16_t U_EXPORT2
1803 ucnv_countStandards(void);
1804 
1805 /**
1806  * Gives the name of the standard at given index of standard list.
1807  * @param n index in standard list
1808  * @param pErrorCode result of operation
1809  * @return returns the name of the standard at given index. Owned by the library.
1810  * @stable ICU 2.0
1811  */
1812 U_STABLE const char * U_EXPORT2
1813 ucnv_getStandard(uint16_t n, UErrorCode *pErrorCode);
1814 
1815 /**
1816  * Returns a standard name for a given converter name.
1817  * &lt;p&gt;
1818  * Example alias table:&lt;br&gt;
1819  * conv alias1 { STANDARD1 } alias2 { STANDARD1* }
1820  * &lt;p&gt;
1821  * Result of ucnv_getStandardName(&quot;conv&quot;, &quot;STANDARD1&quot;) from example
1822  * alias table:&lt;br&gt;
1823  * &lt;b&gt;&quot;alias2&quot;&lt;/b&gt;
1824  *
1825  * @param name original converter name
1826  * @param standard name of the standard governing the names; MIME and IANA
1827  *        are such standards
1828  * @param pErrorCode result of operation
1829  * @return returns the standard converter name;
1830  *         if a standard converter name cannot be determined,
1831  *         then &lt;code&gt;NULL&lt;/code&gt; is returned. Owned by the library.
1832  * @stable ICU 2.0
1833  */
1834 U_STABLE const char * U_EXPORT2
1835 ucnv_getStandardName(const char *name, const char *standard, UErrorCode *pErrorCode);
1836 
1837 /**
1838  * This function will return the internal canonical converter name of the
1839  * tagged alias. This is the opposite of ucnv_openStandardNames, which
1840  * returns the tagged alias given the canonical name.
1841  * &lt;p&gt;
1842  * Example alias table:&lt;br&gt;
1843  * conv alias1 { STANDARD1 } alias2 { STANDARD1* }
1844  * &lt;p&gt;
1845  * Result of ucnv_getStandardName(&quot;alias1&quot;, &quot;STANDARD1&quot;) from example
1846  * alias table:&lt;br&gt;
1847  * &lt;b&gt;&quot;conv&quot;&lt;/b&gt;
1848  *
1849  * @return returns the canonical converter name;
1850  *         if a standard or alias name cannot be determined,
1851  *         then &lt;code&gt;NULL&lt;/code&gt; is returned. The returned string is
1852  *         owned by the library.
1853  * @see ucnv_getStandardName
1854  * @stable ICU 2.4
1855  */
1856 U_STABLE const char * U_EXPORT2
1857 ucnv_getCanonicalName(const char *alias, const char *standard, UErrorCode *pErrorCode);
1858 
1859 /**
1860  * Returns the current default converter name. If you want to open
1861  * a default converter, you do not need to use this function.
1862  * It is faster if you pass a NULL argument to ucnv_open the
1863  * default converter.
1864  *
1865  * If U_CHARSET_IS_UTF8 is defined to 1 in utypes.h then this function
1866  * always returns &quot;UTF-8&quot;.
1867  *
1868  * @return returns the current default converter name.
1869  *         Storage owned by the library
1870  * @see ucnv_setDefaultName
1871  * @stable ICU 2.0
1872  */
1873 U_STABLE const char * U_EXPORT2
1874 ucnv_getDefaultName(void);
1875 
1876 #ifndef U_HIDE_SYSTEM_API
1877 /**
1878  * This function is not thread safe. DO NOT call this function when ANY ICU
1879  * function is being used from more than one thread! This function sets the
1880  * current default converter name. If this function needs to be called, it
1881  * should be called during application initialization. Most of the time, the
1882  * results from ucnv_getDefaultName() or ucnv_open with a NULL string argument
1883  * is sufficient for your application.
1884  *
1885  * If U_CHARSET_IS_UTF8 is defined to 1 in utypes.h then this function
1886  * does nothing.
1887  *
1888  * @param name the converter name to be the default (must be known by ICU).
1889  * @see ucnv_getDefaultName
1890  * @system
1891  * @stable ICU 2.0
1892  */
1893 U_STABLE void U_EXPORT2
1894 ucnv_setDefaultName(const char *name);
1895 #endif  /* U_HIDE_SYSTEM_API */
1896 
1897 /**
1898  * Fixes the backslash character mismapping.  For example, in SJIS, the backslash
1899  * character in the ASCII portion is also used to represent the yen currency sign.
1900  * When mapping from Unicode character 0x005C, it&#39;s unclear whether to map the
1901  * character back to yen or backslash in SJIS.  This function will take the input
1902  * buffer and replace all the yen sign characters with backslash.  This is necessary
1903  * when the user tries to open a file with the input buffer on Windows.
1904  * This function will test the converter to see whether such mapping is
1905  * required.  You can sometimes avoid using this function by using the correct version
1906  * of Shift-JIS.
1907  *
1908  * @param cnv The converter representing the target codepage.
1909  * @param source the input buffer to be fixed
1910  * @param sourceLen the length of the input buffer
1911  * @see ucnv_isAmbiguous
1912  * @stable ICU 2.0
1913  */
1914 U_STABLE void U_EXPORT2
1915 ucnv_fixFileSeparator(const UConverter *cnv, UChar *source, int32_t sourceLen);
1916 
1917 /**
1918  * Determines if the converter contains ambiguous mappings of the same
1919  * character or not.
1920  * @param cnv the converter to be tested
1921  * @return TRUE if the converter contains ambiguous mapping of the same
1922  * character, FALSE otherwise.
1923  * @stable ICU 2.0
1924  */
1925 U_STABLE UBool U_EXPORT2
1926 ucnv_isAmbiguous(const UConverter *cnv);
1927 
1928 /**
1929  * Sets the converter to use fallback mappings or not.
1930  * Regardless of this flag, the converter will always use
1931  * fallbacks from Unicode Private Use code points, as well as
1932  * reverse fallbacks (to Unicode).
1933  * For details see &quot;.ucm File Format&quot;
1934  * in the Conversion Data chapter of the ICU User Guide:
1935  * http://www.icu-project.org/userguide/conversion-data.html#ucmformat
1936  *
1937  * @param cnv The converter to set the fallback mapping usage on.
1938  * @param usesFallback TRUE if the user wants the converter to take advantage of the fallback
1939  * mapping, FALSE otherwise.
1940  * @stable ICU 2.0
1941  * @see ucnv_usesFallback
1942  */
1943 U_STABLE void U_EXPORT2
1944 ucnv_setFallback(UConverter *cnv, UBool usesFallback);
1945 
1946 /**
1947  * Determines if the converter uses fallback mappings or not.
1948  * This flag has restrictions, see ucnv_setFallback().
1949  *
1950  * @param cnv The converter to be tested
1951  * @return TRUE if the converter uses fallback, FALSE otherwise.
1952  * @stable ICU 2.0
1953  * @see ucnv_setFallback
1954  */
1955 U_STABLE UBool U_EXPORT2
1956 ucnv_usesFallback(const UConverter *cnv);
1957 
1958 /**
1959  * Detects Unicode signature byte sequences at the start of the byte stream
1960  * and returns the charset name of the indicated Unicode charset.
1961  * NULL is returned when no Unicode signature is recognized.
1962  * The number of bytes in the signature is output as well.
1963  *
1964  * The caller can ucnv_open() a converter using the charset name.
1965  * The first code unit (UChar) from the start of the stream will be U+FEFF
1966  * (the Unicode BOM/signature character) and can usually be ignored.
1967  *
1968  * For most Unicode charsets it is also possible to ignore the indicated
1969  * number of initial stream bytes and start converting after them.
1970  * However, there are stateful Unicode charsets (UTF-7 and BOCU-1) for which
1971  * this will not work. Therefore, it is best to ignore the first output UChar
1972  * instead of the input signature bytes.
1973  * &lt;p&gt;
1974  * Usage:
1975  * \snippet samples/ucnv/convsamp.cpp ucnv_detectUnicodeSignature
1976  *
1977  * @param source            The source string in which the signature should be detected.
1978  * @param sourceLength      Length of the input string, or -1 if terminated with a NUL byte.
1979  * @param signatureLength   A pointer to int32_t to receive the number of bytes that make up the signature
1980  *                          of the detected UTF. 0 if not detected.
1981  *                          Can be a NULL pointer.
1982  * @param pErrorCode        ICU error code in/out parameter.
1983  *                          Must fulfill U_SUCCESS before the function call.
1984  * @return The name of the encoding detected. NULL if encoding is not detected.
1985  * @stable ICU 2.4
1986  */
1987 U_STABLE const char* U_EXPORT2
1988 ucnv_detectUnicodeSignature(const char* source,
1989                             int32_t sourceLength,
1990                             int32_t *signatureLength,
1991                             UErrorCode *pErrorCode);
1992 
1993 /**
1994  * Returns the number of UChars held in the converter&#39;s internal state
1995  * because more input is needed for completing the conversion. This function is
1996  * useful for mapping semantics of ICU&#39;s converter interface to those of iconv,
1997  * and this information is not needed for normal conversion.
1998  * @param cnv       The converter in which the input is held
1999  * @param status    ICU error code in/out parameter.
2000  *                  Must fulfill U_SUCCESS before the function call.
2001  * @return The number of UChars in the state. -1 if an error is encountered.
2002  * @stable ICU 3.4
2003  */
2004 U_STABLE int32_t U_EXPORT2
2005 ucnv_fromUCountPending(const UConverter* cnv, UErrorCode* status);
2006 
2007 /**
2008  * Returns the number of chars held in the converter&#39;s internal state
2009  * because more input is needed for completing the conversion. This function is
2010  * useful for mapping semantics of ICU&#39;s converter interface to those of iconv,
2011  * and this information is not needed for normal conversion.
2012  * @param cnv       The converter in which the input is held as internal state
2013  * @param status    ICU error code in/out parameter.
2014  *                  Must fulfill U_SUCCESS before the function call.
2015  * @return The number of chars in the state. -1 if an error is encountered.
2016  * @stable ICU 3.4
2017  */
2018 U_STABLE int32_t U_EXPORT2
2019 ucnv_toUCountPending(const UConverter* cnv, UErrorCode* status);
2020 
2021 /**
2022  * Returns whether or not the charset of the converter has a fixed number of bytes
2023  * per charset character.
2024  * An example of this are converters that are of the type UCNV_SBCS or UCNV_DBCS.
2025  * Another example is UTF-32 which is always 4 bytes per character.
2026  * A Unicode code point may be represented by more than one UTF-8 or UTF-16 code unit
2027  * but a UTF-32 converter encodes each code point with 4 bytes.
2028  * Note: This method is not intended to be used to determine whether the charset has a
2029  * fixed ratio of bytes to Unicode codes &lt;i&gt;units&lt;/i&gt; for any particular Unicode encoding form.
2030  * FALSE is returned with the UErrorCode if error occurs or cnv is NULL.
2031  * @param cnv       The converter to be tested
2032  * @param status    ICU error code in/out paramter
2033  * @return TRUE if the converter is fixed-width
2034  * @stable ICU 4.8
2035  */
2036 U_STABLE UBool U_EXPORT2
2037 ucnv_isFixedWidth(UConverter *cnv, UErrorCode *status);
2038 
2039 #endif
2040 
2041 #endif
2042 /*_UCNV*/
    </pre>
  </body>
</html>