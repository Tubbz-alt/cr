<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_mapper.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="number_longnames.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_mapper.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_mapper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 63     // AFFIXES //
 64     /////////////
 65 
 66     AffixPatternProvider* affixProvider;
 67     if (properties.currencyPluralInfo.fPtr.isNull()) {
 68         warehouse.currencyPluralInfoAPP.setToBogus();
 69         warehouse.propertiesAPP.setTo(properties, status);
 70         affixProvider = &amp;warehouse.propertiesAPP;
 71     } else {
 72         warehouse.currencyPluralInfoAPP.setTo(*properties.currencyPluralInfo.fPtr, properties, status);
 73         warehouse.propertiesAPP.setToBogus();
 74         affixProvider = &amp;warehouse.currencyPluralInfoAPP;
 75     }
 76     macros.affixProvider = affixProvider;
 77 
 78     ///////////
 79     // UNITS //
 80     ///////////
 81 
 82     bool useCurrency = (
<span class="line-modified"> 83             !properties.currency.isNull() || !properties.currencyPluralInfo.fPtr.isNull() ||</span>
<span class="line-modified"> 84             !properties.currencyUsage.isNull() || affixProvider-&gt;hasCurrencySign());</span>


 85     CurrencyUnit currency = resolveCurrency(properties, locale, status);
 86     UCurrencyUsage currencyUsage = properties.currencyUsage.getOrDefault(UCURR_USAGE_STANDARD);
 87     if (useCurrency) {
 88         // NOTE: Slicing is OK.
 89         macros.unit = currency; // NOLINT
 90     }
 91     warehouse.currencySymbols = {currency, locale, symbols, status};
 92     macros.currencySymbols = &amp;warehouse.currencySymbols;
 93 
 94     ///////////////////////
 95     // ROUNDING STRATEGY //
 96     ///////////////////////
 97 
 98     int32_t maxInt = properties.maximumIntegerDigits;
 99     int32_t minInt = properties.minimumIntegerDigits;
100     int32_t maxFrac = properties.maximumFractionDigits;
101     int32_t minFrac = properties.minimumFractionDigits;
102     int32_t minSig = properties.minimumSignificantDigits;
103     int32_t maxSig = properties.maximumSignificantDigits;
104     double roundingIncrement = properties.roundingIncrement;
</pre>
<hr />
<pre>
124     // Validate min/max int/frac.
125     // For backwards compatibility, minimum overrides maximum if the two conflict.
126     // The following logic ensures that there is always a minimum of at least one digit.
127     if (minInt == 0 &amp;&amp; maxFrac != 0) {
128         // Force a digit after the decimal point.
129         minFrac = minFrac &lt;= 0 ? 1 : minFrac;
130         maxFrac = maxFrac &lt; 0 ? -1 : maxFrac &lt; minFrac ? minFrac : maxFrac;
131         minInt = 0;
132         maxInt = maxInt &lt; 0 ? -1 : maxInt &gt; kMaxIntFracSig ? -1 : maxInt;
133     } else {
134         // Force a digit before the decimal point.
135         minFrac = minFrac &lt; 0 ? 0 : minFrac;
136         maxFrac = maxFrac &lt; 0 ? -1 : maxFrac &lt; minFrac ? minFrac : maxFrac;
137         minInt = minInt &lt;= 0 ? 1 : minInt &gt; kMaxIntFracSig ? 1 : minInt;
138         maxInt = maxInt &lt; 0 ? -1 : maxInt &lt; minInt ? minInt : maxInt &gt; kMaxIntFracSig ? -1 : maxInt;
139     }
140     Precision precision;
141     if (!properties.currencyUsage.isNull()) {
142         precision = Precision::constructCurrency(currencyUsage).withCurrency(currency);
143     } else if (roundingIncrement != 0.0) {
<span class="line-modified">144         precision = Precision::constructIncrement(roundingIncrement, minFrac);</span>




145     } else if (explicitMinMaxSig) {
146         minSig = minSig &lt; 1 ? 1 : minSig &gt; kMaxIntFracSig ? kMaxIntFracSig : minSig;
147         maxSig = maxSig &lt; 0 ? kMaxIntFracSig : maxSig &lt; minSig ? minSig : maxSig &gt; kMaxIntFracSig
148                                                                           ? kMaxIntFracSig : maxSig;
149         precision = Precision::constructSignificant(minSig, maxSig);
150     } else if (explicitMinMaxFrac) {
151         precision = Precision::constructFraction(minFrac, maxFrac);
152     } else if (useCurrency) {
153         precision = Precision::constructCurrency(currencyUsage);
154     }
155     if (!precision.isBogus()) {
<span class="line-modified">156         precision = precision.withMode(roundingMode);</span>
157         macros.precision = precision;
158     }
159 
160     ///////////////////
161     // INTEGER WIDTH //
162     ///////////////////
163 
164     macros.integerWidth = IntegerWidth(
165             static_cast&lt;digits_t&gt;(minInt),
166             static_cast&lt;digits_t&gt;(maxInt),
167             properties.formatFailIfMoreThanMaxDigits);
168 
169     ///////////////////////
170     // GROUPING STRATEGY //
171     ///////////////////////
172 
173     macros.grouper = Grouper::forProperties(properties);
174 
175     /////////////
176     // PADDING //
177     /////////////
178 
<span class="line-modified">179     if (properties.formatWidth != -1) {</span>
180         macros.padder = Padder::forProperties(properties);
181     }
182 
183     ///////////////////////////////
184     // DECIMAL MARK ALWAYS SHOWN //
185     ///////////////////////////////
186 
187     macros.decimal = properties.decimalSeparatorAlwaysShown ? UNUM_DECIMAL_SEPARATOR_ALWAYS
188                                                             : UNUM_DECIMAL_SEPARATOR_AUTO;
189 
190     ///////////////////////
191     // SIGN ALWAYS SHOWN //
192     ///////////////////////
193 
194     macros.sign = properties.signAlwaysShown ? UNUM_SIGN_ALWAYS : UNUM_SIGN_AUTO;
195 
196     /////////////////////////
197     // SCIENTIFIC NOTATION //
198     /////////////////////////
199 
</pre>
<hr />
<pre>
208             macros.integerWidth = IntegerWidth::zeroFillTo(minInt).truncateAt(maxInt);
209         } else if (maxInt &gt; minInt &amp;&amp; minInt &gt; 1) {
210             // Bug #13289: if maxInt &gt; minInt &gt; 1, then minInt should be 1.
211             minInt = 1;
212             macros.integerWidth = IntegerWidth::zeroFillTo(minInt).truncateAt(maxInt);
213         }
214         int engineering = maxInt &lt; 0 ? -1 : maxInt;
215         macros.notation = ScientificNotation(
216                 // Engineering interval:
217                 static_cast&lt;int8_t&gt;(engineering),
218                 // Enforce minimum integer digits (for patterns like &quot;000.00E0&quot;):
219                 (engineering == minInt),
220                 // Minimum exponent digits:
221                 static_cast&lt;digits_t&gt;(properties.minimumExponentDigits),
222                 // Exponent sign always shown:
223                 properties.exponentSignAlwaysShown ? UNUM_SIGN_ALWAYS : UNUM_SIGN_AUTO);
224         // Scientific notation also involves overriding the rounding mode.
225         // TODO: Overriding here is a bit of a hack. Should this logic go earlier?
226         if (macros.precision.fType == Precision::PrecisionType::RND_FRACTION) {
227             // For the purposes of rounding, get the original min/max int/frac, since the local
<span class="line-modified">228             // variables</span>
<span class="line-modified">229             // have been manipulated for display purposes.</span>
230             int minInt_ = properties.minimumIntegerDigits;
231             int minFrac_ = properties.minimumFractionDigits;
232             int maxFrac_ = properties.maximumFractionDigits;
233             if (minInt_ == 0 &amp;&amp; maxFrac_ == 0) {
234                 // Patterns like &quot;#E0&quot; and &quot;##E0&quot;, which mean no rounding!
<span class="line-modified">235                 macros.precision = Precision::unlimited().withMode(roundingMode);</span>
236             } else if (minInt_ == 0 &amp;&amp; minFrac_ == 0) {
237                 // Patterns like &quot;#.##E0&quot; (no zeros in the mantissa), which mean round to maxFrac+1
<span class="line-modified">238                 macros.precision = Precision::constructSignificant(1, maxFrac_ + 1).withMode(roundingMode);</span>
239             } else {
<span class="line-modified">240                 // All other scientific patterns, which mean round to minInt+maxFrac</span>
<span class="line-modified">241                 macros.precision = Precision::constructSignificant(</span>
<span class="line-modified">242                         minInt_ + minFrac_, minInt_ + maxFrac_).withMode(roundingMode);</span>






243             }

244         }
245     }
246 
247     //////////////////////
248     // COMPACT NOTATION //
249     //////////////////////
250 
251     if (!properties.compactStyle.isNull()) {
252         if (properties.compactStyle.getNoError() == UNumberCompactStyle::UNUM_LONG) {
253             macros.notation = Notation::compactLong();
254         } else {
255             macros.notation = Notation::compactShort();
256         }
257         // Do not forward the affix provider.
258         macros.affixProvider = nullptr;
259     }
260 
261     /////////////////
262     // MULTIPLIERS //
263     /////////////////
</pre>
<hr />
<pre>
272 
273         exportedProperties-&gt;currency = currency;
274         exportedProperties-&gt;roundingMode = roundingMode;
275         exportedProperties-&gt;minimumIntegerDigits = minInt;
276         exportedProperties-&gt;maximumIntegerDigits = maxInt == -1 ? INT32_MAX : maxInt;
277 
278         Precision rounding_;
279         if (precision.fType == Precision::PrecisionType::RND_CURRENCY) {
280             rounding_ = precision.withCurrency(currency, status);
281         } else {
282             rounding_ = precision;
283         }
284         int minFrac_ = minFrac;
285         int maxFrac_ = maxFrac;
286         int minSig_ = minSig;
287         int maxSig_ = maxSig;
288         double increment_ = 0.0;
289         if (rounding_.fType == Precision::PrecisionType::RND_FRACTION) {
290             minFrac_ = rounding_.fUnion.fracSig.fMinFrac;
291             maxFrac_ = rounding_.fUnion.fracSig.fMaxFrac;
<span class="line-modified">292         } else if (rounding_.fType == Precision::PrecisionType::RND_INCREMENT) {</span>


293             increment_ = rounding_.fUnion.increment.fIncrement;
294             minFrac_ = rounding_.fUnion.increment.fMinFrac;
295             maxFrac_ = rounding_.fUnion.increment.fMinFrac;
296         } else if (rounding_.fType == Precision::PrecisionType::RND_SIGNIFICANT) {
297             minSig_ = rounding_.fUnion.fracSig.fMinSig;
298             maxSig_ = rounding_.fUnion.fracSig.fMaxSig;
299         }
300 
301         exportedProperties-&gt;minimumFractionDigits = minFrac_;
302         exportedProperties-&gt;maximumFractionDigits = maxFrac_;
303         exportedProperties-&gt;minimumSignificantDigits = minSig_;
304         exportedProperties-&gt;maximumSignificantDigits = maxSig_;
305         exportedProperties-&gt;roundingIncrement = increment_;
306     }
307 
308     return macros;
309 }
310 
311 
<span class="line-modified">312 void PropertiesAffixPatternProvider::setTo(const DecimalFormatProperties&amp; properties, UErrorCode&amp;) {</span>
313     fBogus = false;
314 
315     // There are two ways to set affixes in DecimalFormat: via the pattern string (applyPattern), and via the
316     // explicit setters (setPositivePrefix and friends).  The way to resolve the settings is as follows:
317     //
318     // 1) If the explicit setting is present for the field, use it.
319     // 2) Otherwise, follows UTS 35 rules based on the pattern string.
320     //
321     // Importantly, the explicit setters affect only the one field they override.  If you set the positive
<span class="line-modified">322     // prefix, that should not affect the negative prefix.  Since it is impossible for the user of this class</span>
<span class="line-removed">323     // to know whether the origin for a string was the override or the pattern, we have to say that we always</span>
<span class="line-removed">324     // have a negative subpattern and perform all resolution logic here.</span>
325 
326     // Convenience: Extract the properties into local variables.
327     // Variables are named with three chars: [p/n][p/s][o/p]
328     // [p/n] =&gt; p for positive, n for negative
329     // [p/s] =&gt; p for prefix, s for suffix
330     // [o/p] =&gt; o for escaped custom override string, p for pattern string
331     UnicodeString ppo = AffixUtils::escape(properties.positivePrefix);
332     UnicodeString pso = AffixUtils::escape(properties.positiveSuffix);
333     UnicodeString npo = AffixUtils::escape(properties.negativePrefix);
334     UnicodeString nso = AffixUtils::escape(properties.negativeSuffix);
335     const UnicodeString&amp; ppp = properties.positivePrefixPattern;
336     const UnicodeString&amp; psp = properties.positiveSuffixPattern;
337     const UnicodeString&amp; npp = properties.negativePrefixPattern;
338     const UnicodeString&amp; nsp = properties.negativeSuffixPattern;
339 
340     if (!properties.positivePrefix.isBogus()) {
341         posPrefix = ppo;
342     } else if (!ppp.isBogus()) {
343         posPrefix = ppp;
344     } else {
</pre>
<hr />
<pre>
356     }
357 
358     if (!properties.negativePrefix.isBogus()) {
359         negPrefix = npo;
360     } else if (!npp.isBogus()) {
361         negPrefix = npp;
362     } else {
363         // UTS 35: Default negative prefix is &quot;-&quot; with positive prefix.
364         // Important: We prepend the &quot;-&quot; to the pattern, not the override!
365         negPrefix = ppp.isBogus() ? u&quot;-&quot; : u&quot;-&quot; + ppp;
366     }
367 
368     if (!properties.negativeSuffix.isBogus()) {
369         negSuffix = nso;
370     } else if (!nsp.isBogus()) {
371         negSuffix = nsp;
372     } else {
373         // UTS 35: Default negative prefix is the positive prefix.
374         negSuffix = psp.isBogus() ? u&quot;&quot; : psp;
375     }








376 }
377 
378 char16_t PropertiesAffixPatternProvider::charAt(int flags, int i) const {
379     return getStringInternal(flags).charAt(i);
380 }
381 
382 int PropertiesAffixPatternProvider::length(int flags) const {
383     return getStringInternal(flags).length();
384 }
385 
386 UnicodeString PropertiesAffixPatternProvider::getString(int32_t flags) const {
387     return getStringInternal(flags);
388 }
389 
390 const UnicodeString&amp; PropertiesAffixPatternProvider::getStringInternal(int32_t flags) const {
391     bool prefix = (flags &amp; AFFIX_PREFIX) != 0;
392     bool negative = (flags &amp; AFFIX_NEGATIVE_SUBPATTERN) != 0;
393     if (prefix &amp;&amp; negative) {
394         return negPrefix;
395     } else if (prefix) {
396         return posPrefix;
397     } else if (negative) {
398         return negSuffix;
399     } else {
400         return posSuffix;
401     }
402 }
403 
404 bool PropertiesAffixPatternProvider::positiveHasPlusSign() const {
405     // TODO: Change the internal APIs to propagate out the error?
406     ErrorCode localStatus;
407     return AffixUtils::containsType(posPrefix, TYPE_PLUS_SIGN, localStatus) ||
408            AffixUtils::containsType(posSuffix, TYPE_PLUS_SIGN, localStatus);
409 }
410 
411 bool PropertiesAffixPatternProvider::hasNegativeSubpattern() const {
<span class="line-modified">412     // See comments in the constructor for more information on why this is always true.</span>
<span class="line-modified">413     return true;</span>



414 }
415 
416 bool PropertiesAffixPatternProvider::negativeHasMinusSign() const {
417     ErrorCode localStatus;
418     return AffixUtils::containsType(negPrefix, TYPE_MINUS_SIGN, localStatus) ||
419            AffixUtils::containsType(negSuffix, TYPE_MINUS_SIGN, localStatus);
420 }
421 
422 bool PropertiesAffixPatternProvider::hasCurrencySign() const {
<span class="line-modified">423     ErrorCode localStatus;</span>
<span class="line-removed">424     return AffixUtils::hasCurrencySymbols(posPrefix, localStatus) ||</span>
<span class="line-removed">425            AffixUtils::hasCurrencySymbols(posSuffix, localStatus) ||</span>
<span class="line-removed">426            AffixUtils::hasCurrencySymbols(negPrefix, localStatus) ||</span>
<span class="line-removed">427            AffixUtils::hasCurrencySymbols(negSuffix, localStatus);</span>
428 }
429 
430 bool PropertiesAffixPatternProvider::containsSymbolType(AffixPatternType type, UErrorCode&amp; status) const {
431     return AffixUtils::containsType(posPrefix, type, status) ||
432            AffixUtils::containsType(posSuffix, type, status) ||
433            AffixUtils::containsType(negPrefix, type, status) ||
434            AffixUtils::containsType(negSuffix, type, status);
435 }
436 
437 bool PropertiesAffixPatternProvider::hasBody() const {
438     return true;
439 }
440 
441 
442 void CurrencyPluralInfoAffixProvider::setTo(const CurrencyPluralInfo&amp; cpi,
443                                             const DecimalFormatProperties&amp; properties,
444                                             UErrorCode&amp; status) {
445     // We need to use a PropertiesAffixPatternProvider, not the simpler version ParsedPatternInfo,
446     // because user-specified affix overrides still need to work.
447     fBogus = false;
</pre>
</td>
<td>
<hr />
<pre>
 63     // AFFIXES //
 64     /////////////
 65 
 66     AffixPatternProvider* affixProvider;
 67     if (properties.currencyPluralInfo.fPtr.isNull()) {
 68         warehouse.currencyPluralInfoAPP.setToBogus();
 69         warehouse.propertiesAPP.setTo(properties, status);
 70         affixProvider = &amp;warehouse.propertiesAPP;
 71     } else {
 72         warehouse.currencyPluralInfoAPP.setTo(*properties.currencyPluralInfo.fPtr, properties, status);
 73         warehouse.propertiesAPP.setToBogus();
 74         affixProvider = &amp;warehouse.currencyPluralInfoAPP;
 75     }
 76     macros.affixProvider = affixProvider;
 77 
 78     ///////////
 79     // UNITS //
 80     ///////////
 81 
 82     bool useCurrency = (
<span class="line-modified"> 83             !properties.currency.isNull() ||</span>
<span class="line-modified"> 84             !properties.currencyPluralInfo.fPtr.isNull() ||</span>
<span class="line-added"> 85             !properties.currencyUsage.isNull() ||</span>
<span class="line-added"> 86             affixProvider-&gt;hasCurrencySign());</span>
 87     CurrencyUnit currency = resolveCurrency(properties, locale, status);
 88     UCurrencyUsage currencyUsage = properties.currencyUsage.getOrDefault(UCURR_USAGE_STANDARD);
 89     if (useCurrency) {
 90         // NOTE: Slicing is OK.
 91         macros.unit = currency; // NOLINT
 92     }
 93     warehouse.currencySymbols = {currency, locale, symbols, status};
 94     macros.currencySymbols = &amp;warehouse.currencySymbols;
 95 
 96     ///////////////////////
 97     // ROUNDING STRATEGY //
 98     ///////////////////////
 99 
100     int32_t maxInt = properties.maximumIntegerDigits;
101     int32_t minInt = properties.minimumIntegerDigits;
102     int32_t maxFrac = properties.maximumFractionDigits;
103     int32_t minFrac = properties.minimumFractionDigits;
104     int32_t minSig = properties.minimumSignificantDigits;
105     int32_t maxSig = properties.maximumSignificantDigits;
106     double roundingIncrement = properties.roundingIncrement;
</pre>
<hr />
<pre>
126     // Validate min/max int/frac.
127     // For backwards compatibility, minimum overrides maximum if the two conflict.
128     // The following logic ensures that there is always a minimum of at least one digit.
129     if (minInt == 0 &amp;&amp; maxFrac != 0) {
130         // Force a digit after the decimal point.
131         minFrac = minFrac &lt;= 0 ? 1 : minFrac;
132         maxFrac = maxFrac &lt; 0 ? -1 : maxFrac &lt; minFrac ? minFrac : maxFrac;
133         minInt = 0;
134         maxInt = maxInt &lt; 0 ? -1 : maxInt &gt; kMaxIntFracSig ? -1 : maxInt;
135     } else {
136         // Force a digit before the decimal point.
137         minFrac = minFrac &lt; 0 ? 0 : minFrac;
138         maxFrac = maxFrac &lt; 0 ? -1 : maxFrac &lt; minFrac ? minFrac : maxFrac;
139         minInt = minInt &lt;= 0 ? 1 : minInt &gt; kMaxIntFracSig ? 1 : minInt;
140         maxInt = maxInt &lt; 0 ? -1 : maxInt &lt; minInt ? minInt : maxInt &gt; kMaxIntFracSig ? -1 : maxInt;
141     }
142     Precision precision;
143     if (!properties.currencyUsage.isNull()) {
144         precision = Precision::constructCurrency(currencyUsage).withCurrency(currency);
145     } else if (roundingIncrement != 0.0) {
<span class="line-modified">146         if (PatternStringUtils::ignoreRoundingIncrement(roundingIncrement, maxFrac)) {</span>
<span class="line-added">147             precision = Precision::constructFraction(minFrac, maxFrac);</span>
<span class="line-added">148         } else {</span>
<span class="line-added">149             precision = Precision::constructIncrement(roundingIncrement, minFrac);</span>
<span class="line-added">150         }</span>
151     } else if (explicitMinMaxSig) {
152         minSig = minSig &lt; 1 ? 1 : minSig &gt; kMaxIntFracSig ? kMaxIntFracSig : minSig;
153         maxSig = maxSig &lt; 0 ? kMaxIntFracSig : maxSig &lt; minSig ? minSig : maxSig &gt; kMaxIntFracSig
154                                                                           ? kMaxIntFracSig : maxSig;
155         precision = Precision::constructSignificant(minSig, maxSig);
156     } else if (explicitMinMaxFrac) {
157         precision = Precision::constructFraction(minFrac, maxFrac);
158     } else if (useCurrency) {
159         precision = Precision::constructCurrency(currencyUsage);
160     }
161     if (!precision.isBogus()) {
<span class="line-modified">162         precision.fRoundingMode = roundingMode;</span>
163         macros.precision = precision;
164     }
165 
166     ///////////////////
167     // INTEGER WIDTH //
168     ///////////////////
169 
170     macros.integerWidth = IntegerWidth(
171             static_cast&lt;digits_t&gt;(minInt),
172             static_cast&lt;digits_t&gt;(maxInt),
173             properties.formatFailIfMoreThanMaxDigits);
174 
175     ///////////////////////
176     // GROUPING STRATEGY //
177     ///////////////////////
178 
179     macros.grouper = Grouper::forProperties(properties);
180 
181     /////////////
182     // PADDING //
183     /////////////
184 
<span class="line-modified">185     if (properties.formatWidth &gt; 0) {</span>
186         macros.padder = Padder::forProperties(properties);
187     }
188 
189     ///////////////////////////////
190     // DECIMAL MARK ALWAYS SHOWN //
191     ///////////////////////////////
192 
193     macros.decimal = properties.decimalSeparatorAlwaysShown ? UNUM_DECIMAL_SEPARATOR_ALWAYS
194                                                             : UNUM_DECIMAL_SEPARATOR_AUTO;
195 
196     ///////////////////////
197     // SIGN ALWAYS SHOWN //
198     ///////////////////////
199 
200     macros.sign = properties.signAlwaysShown ? UNUM_SIGN_ALWAYS : UNUM_SIGN_AUTO;
201 
202     /////////////////////////
203     // SCIENTIFIC NOTATION //
204     /////////////////////////
205 
</pre>
<hr />
<pre>
214             macros.integerWidth = IntegerWidth::zeroFillTo(minInt).truncateAt(maxInt);
215         } else if (maxInt &gt; minInt &amp;&amp; minInt &gt; 1) {
216             // Bug #13289: if maxInt &gt; minInt &gt; 1, then minInt should be 1.
217             minInt = 1;
218             macros.integerWidth = IntegerWidth::zeroFillTo(minInt).truncateAt(maxInt);
219         }
220         int engineering = maxInt &lt; 0 ? -1 : maxInt;
221         macros.notation = ScientificNotation(
222                 // Engineering interval:
223                 static_cast&lt;int8_t&gt;(engineering),
224                 // Enforce minimum integer digits (for patterns like &quot;000.00E0&quot;):
225                 (engineering == minInt),
226                 // Minimum exponent digits:
227                 static_cast&lt;digits_t&gt;(properties.minimumExponentDigits),
228                 // Exponent sign always shown:
229                 properties.exponentSignAlwaysShown ? UNUM_SIGN_ALWAYS : UNUM_SIGN_AUTO);
230         // Scientific notation also involves overriding the rounding mode.
231         // TODO: Overriding here is a bit of a hack. Should this logic go earlier?
232         if (macros.precision.fType == Precision::PrecisionType::RND_FRACTION) {
233             // For the purposes of rounding, get the original min/max int/frac, since the local
<span class="line-modified">234             // variables have been manipulated for display purposes.</span>
<span class="line-modified">235             int maxInt_ = properties.maximumIntegerDigits;</span>
236             int minInt_ = properties.minimumIntegerDigits;
237             int minFrac_ = properties.minimumFractionDigits;
238             int maxFrac_ = properties.maximumFractionDigits;
239             if (minInt_ == 0 &amp;&amp; maxFrac_ == 0) {
240                 // Patterns like &quot;#E0&quot; and &quot;##E0&quot;, which mean no rounding!
<span class="line-modified">241                 macros.precision = Precision::unlimited();</span>
242             } else if (minInt_ == 0 &amp;&amp; minFrac_ == 0) {
243                 // Patterns like &quot;#.##E0&quot; (no zeros in the mantissa), which mean round to maxFrac+1
<span class="line-modified">244                 macros.precision = Precision::constructSignificant(1, maxFrac_ + 1);</span>
245             } else {
<span class="line-modified">246                 int maxSig_ = minInt_ + maxFrac_;</span>
<span class="line-modified">247                 // Bug #20058: if maxInt_ &gt; minInt_ &gt; 1, then minInt_ should be 1.</span>
<span class="line-modified">248                 if (maxInt_ &gt; minInt_ &amp;&amp; minInt_ &gt; 1) {</span>
<span class="line-added">249                     minInt_ = 1;</span>
<span class="line-added">250                 }</span>
<span class="line-added">251                 int minSig_ = minInt_ + minFrac_;</span>
<span class="line-added">252                 // To avoid regression, maxSig is not reset when minInt_ set to 1.</span>
<span class="line-added">253                 // TODO: Reset maxSig_ = 1 + minFrac_ to follow the spec.</span>
<span class="line-added">254                 macros.precision = Precision::constructSignificant(minSig_, maxSig_);</span>
255             }
<span class="line-added">256             macros.precision.fRoundingMode = roundingMode;</span>
257         }
258     }
259 
260     //////////////////////
261     // COMPACT NOTATION //
262     //////////////////////
263 
264     if (!properties.compactStyle.isNull()) {
265         if (properties.compactStyle.getNoError() == UNumberCompactStyle::UNUM_LONG) {
266             macros.notation = Notation::compactLong();
267         } else {
268             macros.notation = Notation::compactShort();
269         }
270         // Do not forward the affix provider.
271         macros.affixProvider = nullptr;
272     }
273 
274     /////////////////
275     // MULTIPLIERS //
276     /////////////////
</pre>
<hr />
<pre>
285 
286         exportedProperties-&gt;currency = currency;
287         exportedProperties-&gt;roundingMode = roundingMode;
288         exportedProperties-&gt;minimumIntegerDigits = minInt;
289         exportedProperties-&gt;maximumIntegerDigits = maxInt == -1 ? INT32_MAX : maxInt;
290 
291         Precision rounding_;
292         if (precision.fType == Precision::PrecisionType::RND_CURRENCY) {
293             rounding_ = precision.withCurrency(currency, status);
294         } else {
295             rounding_ = precision;
296         }
297         int minFrac_ = minFrac;
298         int maxFrac_ = maxFrac;
299         int minSig_ = minSig;
300         int maxSig_ = maxSig;
301         double increment_ = 0.0;
302         if (rounding_.fType == Precision::PrecisionType::RND_FRACTION) {
303             minFrac_ = rounding_.fUnion.fracSig.fMinFrac;
304             maxFrac_ = rounding_.fUnion.fracSig.fMaxFrac;
<span class="line-modified">305         } else if (rounding_.fType == Precision::PrecisionType::RND_INCREMENT</span>
<span class="line-added">306                 || rounding_.fType == Precision::PrecisionType::RND_INCREMENT_ONE</span>
<span class="line-added">307                 || rounding_.fType == Precision::PrecisionType::RND_INCREMENT_FIVE) {</span>
308             increment_ = rounding_.fUnion.increment.fIncrement;
309             minFrac_ = rounding_.fUnion.increment.fMinFrac;
310             maxFrac_ = rounding_.fUnion.increment.fMinFrac;
311         } else if (rounding_.fType == Precision::PrecisionType::RND_SIGNIFICANT) {
312             minSig_ = rounding_.fUnion.fracSig.fMinSig;
313             maxSig_ = rounding_.fUnion.fracSig.fMaxSig;
314         }
315 
316         exportedProperties-&gt;minimumFractionDigits = minFrac_;
317         exportedProperties-&gt;maximumFractionDigits = maxFrac_;
318         exportedProperties-&gt;minimumSignificantDigits = minSig_;
319         exportedProperties-&gt;maximumSignificantDigits = maxSig_;
320         exportedProperties-&gt;roundingIncrement = increment_;
321     }
322 
323     return macros;
324 }
325 
326 
<span class="line-modified">327 void PropertiesAffixPatternProvider::setTo(const DecimalFormatProperties&amp; properties, UErrorCode&amp; status) {</span>
328     fBogus = false;
329 
330     // There are two ways to set affixes in DecimalFormat: via the pattern string (applyPattern), and via the
331     // explicit setters (setPositivePrefix and friends).  The way to resolve the settings is as follows:
332     //
333     // 1) If the explicit setting is present for the field, use it.
334     // 2) Otherwise, follows UTS 35 rules based on the pattern string.
335     //
336     // Importantly, the explicit setters affect only the one field they override.  If you set the positive
<span class="line-modified">337     // prefix, that should not affect the negative prefix.</span>


338 
339     // Convenience: Extract the properties into local variables.
340     // Variables are named with three chars: [p/n][p/s][o/p]
341     // [p/n] =&gt; p for positive, n for negative
342     // [p/s] =&gt; p for prefix, s for suffix
343     // [o/p] =&gt; o for escaped custom override string, p for pattern string
344     UnicodeString ppo = AffixUtils::escape(properties.positivePrefix);
345     UnicodeString pso = AffixUtils::escape(properties.positiveSuffix);
346     UnicodeString npo = AffixUtils::escape(properties.negativePrefix);
347     UnicodeString nso = AffixUtils::escape(properties.negativeSuffix);
348     const UnicodeString&amp; ppp = properties.positivePrefixPattern;
349     const UnicodeString&amp; psp = properties.positiveSuffixPattern;
350     const UnicodeString&amp; npp = properties.negativePrefixPattern;
351     const UnicodeString&amp; nsp = properties.negativeSuffixPattern;
352 
353     if (!properties.positivePrefix.isBogus()) {
354         posPrefix = ppo;
355     } else if (!ppp.isBogus()) {
356         posPrefix = ppp;
357     } else {
</pre>
<hr />
<pre>
369     }
370 
371     if (!properties.negativePrefix.isBogus()) {
372         negPrefix = npo;
373     } else if (!npp.isBogus()) {
374         negPrefix = npp;
375     } else {
376         // UTS 35: Default negative prefix is &quot;-&quot; with positive prefix.
377         // Important: We prepend the &quot;-&quot; to the pattern, not the override!
378         negPrefix = ppp.isBogus() ? u&quot;-&quot; : u&quot;-&quot; + ppp;
379     }
380 
381     if (!properties.negativeSuffix.isBogus()) {
382         negSuffix = nso;
383     } else if (!nsp.isBogus()) {
384         negSuffix = nsp;
385     } else {
386         // UTS 35: Default negative prefix is the positive prefix.
387         negSuffix = psp.isBogus() ? u&quot;&quot; : psp;
388     }
<span class="line-added">389 </span>
<span class="line-added">390     // For declaring if this is a currency pattern, we need to look at the</span>
<span class="line-added">391     // original pattern, not at any user-specified overrides.</span>
<span class="line-added">392     isCurrencyPattern = (</span>
<span class="line-added">393         AffixUtils::hasCurrencySymbols(ppp, status) ||</span>
<span class="line-added">394         AffixUtils::hasCurrencySymbols(psp, status) ||</span>
<span class="line-added">395         AffixUtils::hasCurrencySymbols(npp, status) ||</span>
<span class="line-added">396         AffixUtils::hasCurrencySymbols(nsp, status));</span>
397 }
398 
399 char16_t PropertiesAffixPatternProvider::charAt(int flags, int i) const {
400     return getStringInternal(flags).charAt(i);
401 }
402 
403 int PropertiesAffixPatternProvider::length(int flags) const {
404     return getStringInternal(flags).length();
405 }
406 
407 UnicodeString PropertiesAffixPatternProvider::getString(int32_t flags) const {
408     return getStringInternal(flags);
409 }
410 
411 const UnicodeString&amp; PropertiesAffixPatternProvider::getStringInternal(int32_t flags) const {
412     bool prefix = (flags &amp; AFFIX_PREFIX) != 0;
413     bool negative = (flags &amp; AFFIX_NEGATIVE_SUBPATTERN) != 0;
414     if (prefix &amp;&amp; negative) {
415         return negPrefix;
416     } else if (prefix) {
417         return posPrefix;
418     } else if (negative) {
419         return negSuffix;
420     } else {
421         return posSuffix;
422     }
423 }
424 
425 bool PropertiesAffixPatternProvider::positiveHasPlusSign() const {
426     // TODO: Change the internal APIs to propagate out the error?
427     ErrorCode localStatus;
428     return AffixUtils::containsType(posPrefix, TYPE_PLUS_SIGN, localStatus) ||
429            AffixUtils::containsType(posSuffix, TYPE_PLUS_SIGN, localStatus);
430 }
431 
432 bool PropertiesAffixPatternProvider::hasNegativeSubpattern() const {
<span class="line-modified">433     return (</span>
<span class="line-modified">434         (negSuffix != posSuffix) ||</span>
<span class="line-added">435         negPrefix.tempSubString(1) != posPrefix ||</span>
<span class="line-added">436         negPrefix.charAt(0) != u&#39;-&#39;</span>
<span class="line-added">437     );</span>
438 }
439 
440 bool PropertiesAffixPatternProvider::negativeHasMinusSign() const {
441     ErrorCode localStatus;
442     return AffixUtils::containsType(negPrefix, TYPE_MINUS_SIGN, localStatus) ||
443            AffixUtils::containsType(negSuffix, TYPE_MINUS_SIGN, localStatus);
444 }
445 
446 bool PropertiesAffixPatternProvider::hasCurrencySign() const {
<span class="line-modified">447     return isCurrencyPattern;</span>




448 }
449 
450 bool PropertiesAffixPatternProvider::containsSymbolType(AffixPatternType type, UErrorCode&amp; status) const {
451     return AffixUtils::containsType(posPrefix, type, status) ||
452            AffixUtils::containsType(posSuffix, type, status) ||
453            AffixUtils::containsType(negPrefix, type, status) ||
454            AffixUtils::containsType(negSuffix, type, status);
455 }
456 
457 bool PropertiesAffixPatternProvider::hasBody() const {
458     return true;
459 }
460 
461 
462 void CurrencyPluralInfoAffixProvider::setTo(const CurrencyPluralInfo&amp; cpi,
463                                             const DecimalFormatProperties&amp; properties,
464                                             UErrorCode&amp; status) {
465     // We need to use a PropertiesAffixPatternProvider, not the simpler version ParsedPatternInfo,
466     // because user-specified affix overrides still need to work.
467     fBogus = false;
</pre>
</td>
</tr>
</table>
<center><a href="number_longnames.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_mapper.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>