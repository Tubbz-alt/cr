<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/numparse_types.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Â© 2018 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 
  4 #include &quot;unicode/utypes.h&quot;
  5 
  6 #if !UCONFIG_NO_FORMATTING
  7 #ifndef __NUMPARSE_TYPES_H__
  8 #define __NUMPARSE_TYPES_H__
  9 
 10 #include &quot;unicode/uobject.h&quot;
 11 #include &quot;number_decimalquantity.h&quot;
 12 
 13 U_NAMESPACE_BEGIN namespace numparse {
 14 namespace impl {
 15 
 16 // Forward-declarations
 17 class StringSegment;
 18 class ParsedNumber;
 19 
 20 typedef int32_t result_flags_t;
 21 typedef int32_t parse_flags_t;
 22 
 23 /** Flags for the type result_flags_t */
 24 enum ResultFlags {
 25     FLAG_NEGATIVE = 0x0001,
 26     FLAG_PERCENT = 0x0002,
 27     FLAG_PERMILLE = 0x0004,
 28     FLAG_HAS_EXPONENT = 0x0008,
 29     // FLAG_HAS_DEFAULT_CURRENCY = 0x0010, // no longer used
 30     FLAG_HAS_DECIMAL_SEPARATOR = 0x0020,
 31     FLAG_NAN = 0x0040,
 32     FLAG_INFINITY = 0x0080,
 33     FLAG_FAIL = 0x0100,
 34 };
 35 
 36 /** Flags for the type parse_flags_t */
 37 enum ParseFlags {
 38     PARSE_FLAG_IGNORE_CASE = 0x0001,
 39     PARSE_FLAG_MONETARY_SEPARATORS = 0x0002,
 40     PARSE_FLAG_STRICT_SEPARATORS = 0x0004,
 41     PARSE_FLAG_STRICT_GROUPING_SIZE = 0x0008,
 42     PARSE_FLAG_INTEGER_ONLY = 0x0010,
 43     PARSE_FLAG_GROUPING_DISABLED = 0x0020,
 44     // PARSE_FLAG_FRACTION_GROUPING_ENABLED = 0x0040, // see #10794
 45     PARSE_FLAG_INCLUDE_UNPAIRED_AFFIXES = 0x0080,
 46     PARSE_FLAG_USE_FULL_AFFIXES = 0x0100,
 47     PARSE_FLAG_EXACT_AFFIX = 0x0200,
 48     PARSE_FLAG_PLUS_SIGN_ALLOWED = 0x0400,
 49     // PARSE_FLAG_OPTIMIZE = 0x0800, // no longer used
 50     // PARSE_FLAG_FORCE_BIG_DECIMAL = 0x1000, // not used in ICU4C
 51     PARSE_FLAG_NO_FOREIGN_CURRENCY = 0x2000,
<a name="1" id="anc1"></a><span class="line-added"> 52     PARSE_FLAG_ALLOW_INFINITE_RECURSION = 0x4000,</span>
 53 };
 54 
 55 
 56 // TODO: Is this class worthwhile?
 57 template&lt;int32_t stackCapacity&gt;
 58 class CompactUnicodeString {
 59   public:
 60     CompactUnicodeString() {
 61         static_assert(stackCapacity &gt; 0, &quot;cannot have zero space on stack&quot;);
 62         fBuffer[0] = 0;
 63     }
 64 
 65     CompactUnicodeString(const UnicodeString&amp; text)
 66             : fBuffer(text.length() + 1) {
<a name="2" id="anc2"></a><span class="line-modified"> 67         uprv_memcpy(fBuffer.getAlias(), text.getBuffer(), sizeof(UChar) * text.length());</span>
 68         fBuffer[text.length()] = 0;
 69     }
 70 
 71     inline UnicodeString toAliasedUnicodeString() const {
 72         return UnicodeString(TRUE, fBuffer.getAlias(), -1);
 73     }
 74 
 75     bool operator==(const CompactUnicodeString&amp; other) const {
 76         // Use the alias-only constructor and then call UnicodeString operator==
 77         return toAliasedUnicodeString() == other.toAliasedUnicodeString();
 78     }
 79 
 80   private:
 81     MaybeStackArray&lt;UChar, stackCapacity&gt; fBuffer;
 82 };
 83 
 84 
 85 /**
 86  * Struct-like class to hold the results of a parsing routine.
 87  *
 88  * @author sffc
 89  */
 90 // Exported as U_I18N_API for tests
 91 class U_I18N_API ParsedNumber {
 92   public:
 93 
 94     /**
 95      * The numerical value that was parsed.
 96      */
 97     ::icu::number::impl::DecimalQuantity quantity;
 98 
 99     /**
100      * The index of the last char consumed during parsing. If parsing started at index 0, this is equal
101      * to the number of chars consumed. This is NOT necessarily the same as the StringSegment offset;
102      * &quot;weak&quot; chars, like whitespace, change the offset, but the charsConsumed is not touched until a
103      * &quot;strong&quot; char is encountered.
104      */
105     int32_t charEnd;
106 
107     /**
108      * Boolean flags (see constants above).
109      */
110     result_flags_t flags;
111 
112     /**
113      * The pattern string corresponding to the prefix that got consumed.
114      */
115     UnicodeString prefix;
116 
117     /**
118      * The pattern string corresponding to the suffix that got consumed.
119      */
120     UnicodeString suffix;
121 
122     /**
123      * The currency that got consumed.
124      */
125     UChar currencyCode[4];
126 
127     ParsedNumber();
128 
129     ParsedNumber(const ParsedNumber&amp; other) = default;
130 
131     ParsedNumber&amp; operator=(const ParsedNumber&amp; other) = default;
132 
133     void clear();
134 
135     /**
136      * Call this method to register that a &quot;strong&quot; char was consumed. This should be done after calling
137      * {@link StringSegment#setOffset} or {@link StringSegment#adjustOffset} except when the char is
138      * &quot;weak&quot;, like whitespace.
139      *
140      * &lt;p&gt;
141      * &lt;strong&gt;What is a strong versus weak char?&lt;/strong&gt; The behavior of number parsing is to &quot;stop&quot;
142      * after reading the number, even if there is other content following the number. For example, after
143      * parsing the string &quot;123 &quot; (123 followed by a space), the cursor should be set to 3, not 4, even
144      * though there are matchers that accept whitespace. In this example, the digits are strong, whereas
145      * the whitespace is weak. Grouping separators are weak, whereas decimal separators are strong. Most
146      * other chars are strong.
147      *
148      * @param segment
149      *            The current StringSegment, usually immediately following a call to setOffset.
150      */
151     void setCharsConsumed(const StringSegment&amp; segment);
152 
153     /** Apply certain number-related flags to the DecimalQuantity. */
154     void postProcess();
155 
156     /**
157      * Returns whether this the parse was successful. To be successful, at least one char must have been
158      * consumed, and the failure flag must not be set.
159      */
160     bool success() const;
161 
162     bool seenNumber() const;
163 
<a name="3" id="anc3"></a><span class="line-modified">164     double getDouble(UErrorCode&amp; status) const;</span>
165 
166     void populateFormattable(Formattable&amp; output, parse_flags_t parseFlags) const;
167 
168     bool isBetterThan(const ParsedNumber&amp; other);
169 };
170 
171 
172 /**
173  * A mutable class allowing for a String with a variable offset and length. The charAt, length, and
174  * subSequence methods all operate relative to the fixed offset into the String.
175  *
176  * @author sffc
177  */
178 // Exported as U_I18N_API for tests
179 class U_I18N_API StringSegment : public UMemory {
180   public:
181     StringSegment(const UnicodeString&amp; str, bool ignoreCase);
182 
183     int32_t getOffset() const;
184 
185     void setOffset(int32_t start);
186 
187     /**
188      * Equivalent to &lt;code&gt;setOffset(getOffset()+delta)&lt;/code&gt;.
189      *
190      * &lt;p&gt;
191      * This method is usually called by a Matcher to register that a char was consumed. If the char is
192      * strong (it usually is, except for things like whitespace), follow this with a call to
193      * {@link ParsedNumber#setCharsConsumed}. For more information on strong chars, see that method.
194      */
195     void adjustOffset(int32_t delta);
196 
197     /**
198      * Adjusts the offset by the width of the current code point, either 1 or 2 chars.
199      */
200     void adjustOffsetByCodePoint();
201 
202     void setLength(int32_t length);
203 
204     void resetLength();
205 
206     int32_t length() const;
207 
208     char16_t charAt(int32_t index) const;
209 
210     UChar32 codePointAt(int32_t index) const;
211 
212     UnicodeString toUnicodeString() const;
213 
214     const UnicodeString toTempUnicodeString() const;
215 
216     /**
217      * Returns the first code point in the string segment, or -1 if the string starts with an invalid
218      * code point.
219      *
220      * &lt;p&gt;
221      * &lt;strong&gt;Important:&lt;/strong&gt; Most of the time, you should use {@link #matches}, which handles case
222      * folding logic, instead of this method.
223      */
224     UChar32 getCodePoint() const;
225 
226     /**
227      * Returns true if the first code point of this StringSegment equals the given code point.
228      *
229      * &lt;p&gt;
230      * This method will perform case folding if case folding is enabled for the parser.
231      */
232     bool startsWith(UChar32 otherCp) const;
233 
234     /**
235      * Returns true if the first code point of this StringSegment is in the given UnicodeSet.
236      */
237     bool startsWith(const UnicodeSet&amp; uniset) const;
238 
239     /**
240      * Returns true if there is at least one code point of overlap between this StringSegment and the
241      * given UnicodeString.
242      */
243     bool startsWith(const UnicodeString&amp; other) const;
244 
245     /**
246      * Returns the length of the prefix shared by this StringSegment and the given CharSequence. For
247      * example, if this string segment is &quot;aab&quot;, and the char sequence is &quot;aac&quot;, this method returns 2,
248      * since the first 2 characters are the same.
249      *
250      * &lt;p&gt;
251      * This method only returns offsets along code point boundaries.
252      *
253      * &lt;p&gt;
254      * This method will perform case folding if case folding was enabled in the constructor.
255      *
256      * &lt;p&gt;
257      * IMPORTANT: The given UnicodeString must not be empty! It is the caller&#39;s responsibility to check.
258      */
259     int32_t getCommonPrefixLength(const UnicodeString&amp; other);
260 
261     /**
262      * Like {@link #getCommonPrefixLength}, but never performs case folding, even if case folding is
263      * enabled for the parser.
264      */
265     int32_t getCaseSensitivePrefixLength(const UnicodeString&amp; other);
266 
267     bool operator==(const UnicodeString&amp; other) const;
268 
269   private:
<a name="4" id="anc4"></a><span class="line-modified">270     const UnicodeString&amp; fStr;</span>
271     int32_t fStart;
272     int32_t fEnd;
273     bool fFoldCase;
274 
275     int32_t getPrefixLengthInternal(const UnicodeString&amp; other, bool foldCase);
276 
277     static bool codePointsEqual(UChar32 cp1, UChar32 cp2, bool foldCase);
278 };
279 
280 
281 /**
282  * The core interface implemented by all matchers used for number parsing.
283  *
284  * Given a string, there should NOT be more than one way to consume the string with the same matcher
285  * applied multiple times. If there is, the non-greedy parsing algorithm will be unhappy and may enter an
286  * exponential-time loop. For example, consider the &quot;A Matcher&quot; that accepts &quot;any number of As&quot;. Given
287  * the string &quot;AAAA&quot;, there are 2^N = 8 ways to apply the A Matcher to this string: you could have the A
288  * Matcher apply 4 times to each character; you could have it apply just once to all the characters; you
289  * could have it apply to the first 2 characters and the second 2 characters; and so on. A better version
290  * of the &quot;A Matcher&quot; would be for it to accept exactly one A, and allow the algorithm to run it
291  * repeatedly to consume a string of multiple As. The A Matcher can implement the Flexible interface
292  * below to signal that it can be applied multiple times in a row.
293  *
294  * @author sffc
295  */
296 // Exported as U_I18N_API for tests
297 class U_I18N_API NumberParseMatcher {
298   public:
299     virtual ~NumberParseMatcher();
300 
301     /**
302      * Matchers can override this method to return true to indicate that they are optional and can be run
303      * repeatedly. Used by SeriesMatcher, primarily in the context of IgnorablesMatcher.
304      */
305     virtual bool isFlexible() const {
306         return false;
307     }
308 
309     /**
310      * Runs this matcher starting at the beginning of the given StringSegment. If this matcher finds
311      * something interesting in the StringSegment, it should update the offset of the StringSegment
312      * corresponding to how many chars were matched.
313      *
314      * This method is thread-safe.
315      *
316      * @param segment
317      *            The StringSegment to match against. Matches always start at the beginning of the
318      *            segment. The segment is guaranteed to contain at least one char.
319      * @param result
320      *            The data structure to store results if the match succeeds.
321      * @return Whether this matcher thinks there may be more interesting chars beyond the end of the
322      *         string segment.
323      */
324     virtual bool match(StringSegment&amp; segment, ParsedNumber&amp; result, UErrorCode&amp; status) const = 0;
325 
326     /**
327      * Performs a fast &quot;smoke check&quot; for whether or not this matcher could possibly match against the
328      * given string segment. The test should be as fast as possible but also as restrictive as possible.
329      * For example, matchers can maintain a UnicodeSet of all code points that count possibly start a
330      * match. Matchers should use the {@link StringSegment#startsWith} method in order to correctly
331      * handle case folding.
332      *
333      * @param segment
334      *            The segment to check against.
335      * @return true if the matcher might be able to match against this segment; false if it definitely
336      *         will not be able to match.
337      */
338     virtual bool smokeTest(const StringSegment&amp; segment) const = 0;
339 
340     /**
341      * Method called at the end of a parse, after all matchers have failed to consume any more chars.
342      * Allows a matcher to make final modifications to the result given the knowledge that no more
343      * matches are possible.
344      *
345      * @param result
346      *            The data structure to store results.
347      */
348     virtual void postProcess(ParsedNumber&amp;) const {
349         // Default implementation: no-op
<a name="5" id="anc5"></a><span class="line-modified">350     }</span>
351 
352     // String for debugging
353     virtual UnicodeString toString() const = 0;
354 
355   protected:
356     // No construction except by subclasses!
357     NumberParseMatcher() = default;
358 };
359 
360 
361 /**
362  * Interface for use in arguments.
363  */
364 // Exported as U_I18N_API for tests
365 class U_I18N_API MutableMatcherCollection {
366   public:
367     virtual ~MutableMatcherCollection() = default;
368 
369     virtual void addMatcher(NumberParseMatcher&amp; matcher) = 0;
370 };
371 
372 
373 } // namespace impl
374 } // namespace numparse
375 U_NAMESPACE_END
376 
377 #endif //__NUMPARSE_TYPES_H__
378 #endif /* #if !UCONFIG_NO_FORMATTING */
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>