<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/numparse_types.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="numparse_symbols.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="numsys.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/numparse_types.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 32     FLAG_INFINITY = 0x0080,
 33     FLAG_FAIL = 0x0100,
 34 };
 35 
 36 /** Flags for the type parse_flags_t */
 37 enum ParseFlags {
 38     PARSE_FLAG_IGNORE_CASE = 0x0001,
 39     PARSE_FLAG_MONETARY_SEPARATORS = 0x0002,
 40     PARSE_FLAG_STRICT_SEPARATORS = 0x0004,
 41     PARSE_FLAG_STRICT_GROUPING_SIZE = 0x0008,
 42     PARSE_FLAG_INTEGER_ONLY = 0x0010,
 43     PARSE_FLAG_GROUPING_DISABLED = 0x0020,
 44     // PARSE_FLAG_FRACTION_GROUPING_ENABLED = 0x0040, // see #10794
 45     PARSE_FLAG_INCLUDE_UNPAIRED_AFFIXES = 0x0080,
 46     PARSE_FLAG_USE_FULL_AFFIXES = 0x0100,
 47     PARSE_FLAG_EXACT_AFFIX = 0x0200,
 48     PARSE_FLAG_PLUS_SIGN_ALLOWED = 0x0400,
 49     // PARSE_FLAG_OPTIMIZE = 0x0800, // no longer used
 50     // PARSE_FLAG_FORCE_BIG_DECIMAL = 0x1000, // not used in ICU4C
 51     PARSE_FLAG_NO_FOREIGN_CURRENCY = 0x2000,

 52 };
 53 
 54 
 55 // TODO: Is this class worthwhile?
 56 template&lt;int32_t stackCapacity&gt;
 57 class CompactUnicodeString {
 58   public:
 59     CompactUnicodeString() {
 60         static_assert(stackCapacity &gt; 0, &quot;cannot have zero space on stack&quot;);
 61         fBuffer[0] = 0;
 62     }
 63 
 64     CompactUnicodeString(const UnicodeString&amp; text)
 65             : fBuffer(text.length() + 1) {
<span class="line-modified"> 66         memcpy(fBuffer.getAlias(), text.getBuffer(), sizeof(UChar) * text.length());</span>
 67         fBuffer[text.length()] = 0;
 68     }
 69 
 70     inline UnicodeString toAliasedUnicodeString() const {
 71         return UnicodeString(TRUE, fBuffer.getAlias(), -1);
 72     }
 73 
 74     bool operator==(const CompactUnicodeString&amp; other) const {
 75         // Use the alias-only constructor and then call UnicodeString operator==
 76         return toAliasedUnicodeString() == other.toAliasedUnicodeString();
 77     }
 78 
 79   private:
 80     MaybeStackArray&lt;UChar, stackCapacity&gt; fBuffer;
 81 };
 82 
 83 
 84 /**
 85  * Struct-like class to hold the results of a parsing routine.
 86  *
</pre>
<hr />
<pre>
143      * though there are matchers that accept whitespace. In this example, the digits are strong, whereas
144      * the whitespace is weak. Grouping separators are weak, whereas decimal separators are strong. Most
145      * other chars are strong.
146      *
147      * @param segment
148      *            The current StringSegment, usually immediately following a call to setOffset.
149      */
150     void setCharsConsumed(const StringSegment&amp; segment);
151 
152     /** Apply certain number-related flags to the DecimalQuantity. */
153     void postProcess();
154 
155     /**
156      * Returns whether this the parse was successful. To be successful, at least one char must have been
157      * consumed, and the failure flag must not be set.
158      */
159     bool success() const;
160 
161     bool seenNumber() const;
162 
<span class="line-modified">163     double getDouble() const;</span>
164 
165     void populateFormattable(Formattable&amp; output, parse_flags_t parseFlags) const;
166 
167     bool isBetterThan(const ParsedNumber&amp; other);
168 };
169 
170 
171 /**
172  * A mutable class allowing for a String with a variable offset and length. The charAt, length, and
173  * subSequence methods all operate relative to the fixed offset into the String.
174  *
175  * @author sffc
176  */
177 // Exported as U_I18N_API for tests
178 class U_I18N_API StringSegment : public UMemory {
179   public:
180     StringSegment(const UnicodeString&amp; str, bool ignoreCase);
181 
182     int32_t getOffset() const;
183 
</pre>
<hr />
<pre>
249      * &lt;p&gt;
250      * This method only returns offsets along code point boundaries.
251      *
252      * &lt;p&gt;
253      * This method will perform case folding if case folding was enabled in the constructor.
254      *
255      * &lt;p&gt;
256      * IMPORTANT: The given UnicodeString must not be empty! It is the caller&#39;s responsibility to check.
257      */
258     int32_t getCommonPrefixLength(const UnicodeString&amp; other);
259 
260     /**
261      * Like {@link #getCommonPrefixLength}, but never performs case folding, even if case folding is
262      * enabled for the parser.
263      */
264     int32_t getCaseSensitivePrefixLength(const UnicodeString&amp; other);
265 
266     bool operator==(const UnicodeString&amp; other) const;
267 
268   private:
<span class="line-modified">269     const UnicodeString fStr;</span>
270     int32_t fStart;
271     int32_t fEnd;
272     bool fFoldCase;
273 
274     int32_t getPrefixLengthInternal(const UnicodeString&amp; other, bool foldCase);
275 
276     static bool codePointsEqual(UChar32 cp1, UChar32 cp2, bool foldCase);
277 };
278 
279 
280 /**
281  * The core interface implemented by all matchers used for number parsing.
282  *
283  * Given a string, there should NOT be more than one way to consume the string with the same matcher
284  * applied multiple times. If there is, the non-greedy parsing algorithm will be unhappy and may enter an
285  * exponential-time loop. For example, consider the &quot;A Matcher&quot; that accepts &quot;any number of As&quot;. Given
286  * the string &quot;AAAA&quot;, there are 2^N = 8 ways to apply the A Matcher to this string: you could have the A
287  * Matcher apply 4 times to each character; you could have it apply just once to all the characters; you
288  * could have it apply to the first 2 characters and the second 2 characters; and so on. A better version
289  * of the &quot;A Matcher&quot; would be for it to accept exactly one A, and allow the algorithm to run it
</pre>
<hr />
<pre>
329      * match. Matchers should use the {@link StringSegment#startsWith} method in order to correctly
330      * handle case folding.
331      *
332      * @param segment
333      *            The segment to check against.
334      * @return true if the matcher might be able to match against this segment; false if it definitely
335      *         will not be able to match.
336      */
337     virtual bool smokeTest(const StringSegment&amp; segment) const = 0;
338 
339     /**
340      * Method called at the end of a parse, after all matchers have failed to consume any more chars.
341      * Allows a matcher to make final modifications to the result given the knowledge that no more
342      * matches are possible.
343      *
344      * @param result
345      *            The data structure to store results.
346      */
347     virtual void postProcess(ParsedNumber&amp;) const {
348         // Default implementation: no-op
<span class="line-modified">349     };</span>
350 
351     // String for debugging
352     virtual UnicodeString toString() const = 0;
353 
354   protected:
355     // No construction except by subclasses!
356     NumberParseMatcher() = default;
357 };
358 
359 
360 /**
361  * Interface for use in arguments.
362  */
363 // Exported as U_I18N_API for tests
364 class U_I18N_API MutableMatcherCollection {
365   public:
366     virtual ~MutableMatcherCollection() = default;
367 
368     virtual void addMatcher(NumberParseMatcher&amp; matcher) = 0;
369 };
</pre>
</td>
<td>
<hr />
<pre>
 32     FLAG_INFINITY = 0x0080,
 33     FLAG_FAIL = 0x0100,
 34 };
 35 
 36 /** Flags for the type parse_flags_t */
 37 enum ParseFlags {
 38     PARSE_FLAG_IGNORE_CASE = 0x0001,
 39     PARSE_FLAG_MONETARY_SEPARATORS = 0x0002,
 40     PARSE_FLAG_STRICT_SEPARATORS = 0x0004,
 41     PARSE_FLAG_STRICT_GROUPING_SIZE = 0x0008,
 42     PARSE_FLAG_INTEGER_ONLY = 0x0010,
 43     PARSE_FLAG_GROUPING_DISABLED = 0x0020,
 44     // PARSE_FLAG_FRACTION_GROUPING_ENABLED = 0x0040, // see #10794
 45     PARSE_FLAG_INCLUDE_UNPAIRED_AFFIXES = 0x0080,
 46     PARSE_FLAG_USE_FULL_AFFIXES = 0x0100,
 47     PARSE_FLAG_EXACT_AFFIX = 0x0200,
 48     PARSE_FLAG_PLUS_SIGN_ALLOWED = 0x0400,
 49     // PARSE_FLAG_OPTIMIZE = 0x0800, // no longer used
 50     // PARSE_FLAG_FORCE_BIG_DECIMAL = 0x1000, // not used in ICU4C
 51     PARSE_FLAG_NO_FOREIGN_CURRENCY = 0x2000,
<span class="line-added"> 52     PARSE_FLAG_ALLOW_INFINITE_RECURSION = 0x4000,</span>
 53 };
 54 
 55 
 56 // TODO: Is this class worthwhile?
 57 template&lt;int32_t stackCapacity&gt;
 58 class CompactUnicodeString {
 59   public:
 60     CompactUnicodeString() {
 61         static_assert(stackCapacity &gt; 0, &quot;cannot have zero space on stack&quot;);
 62         fBuffer[0] = 0;
 63     }
 64 
 65     CompactUnicodeString(const UnicodeString&amp; text)
 66             : fBuffer(text.length() + 1) {
<span class="line-modified"> 67         uprv_memcpy(fBuffer.getAlias(), text.getBuffer(), sizeof(UChar) * text.length());</span>
 68         fBuffer[text.length()] = 0;
 69     }
 70 
 71     inline UnicodeString toAliasedUnicodeString() const {
 72         return UnicodeString(TRUE, fBuffer.getAlias(), -1);
 73     }
 74 
 75     bool operator==(const CompactUnicodeString&amp; other) const {
 76         // Use the alias-only constructor and then call UnicodeString operator==
 77         return toAliasedUnicodeString() == other.toAliasedUnicodeString();
 78     }
 79 
 80   private:
 81     MaybeStackArray&lt;UChar, stackCapacity&gt; fBuffer;
 82 };
 83 
 84 
 85 /**
 86  * Struct-like class to hold the results of a parsing routine.
 87  *
</pre>
<hr />
<pre>
144      * though there are matchers that accept whitespace. In this example, the digits are strong, whereas
145      * the whitespace is weak. Grouping separators are weak, whereas decimal separators are strong. Most
146      * other chars are strong.
147      *
148      * @param segment
149      *            The current StringSegment, usually immediately following a call to setOffset.
150      */
151     void setCharsConsumed(const StringSegment&amp; segment);
152 
153     /** Apply certain number-related flags to the DecimalQuantity. */
154     void postProcess();
155 
156     /**
157      * Returns whether this the parse was successful. To be successful, at least one char must have been
158      * consumed, and the failure flag must not be set.
159      */
160     bool success() const;
161 
162     bool seenNumber() const;
163 
<span class="line-modified">164     double getDouble(UErrorCode&amp; status) const;</span>
165 
166     void populateFormattable(Formattable&amp; output, parse_flags_t parseFlags) const;
167 
168     bool isBetterThan(const ParsedNumber&amp; other);
169 };
170 
171 
172 /**
173  * A mutable class allowing for a String with a variable offset and length. The charAt, length, and
174  * subSequence methods all operate relative to the fixed offset into the String.
175  *
176  * @author sffc
177  */
178 // Exported as U_I18N_API for tests
179 class U_I18N_API StringSegment : public UMemory {
180   public:
181     StringSegment(const UnicodeString&amp; str, bool ignoreCase);
182 
183     int32_t getOffset() const;
184 
</pre>
<hr />
<pre>
250      * &lt;p&gt;
251      * This method only returns offsets along code point boundaries.
252      *
253      * &lt;p&gt;
254      * This method will perform case folding if case folding was enabled in the constructor.
255      *
256      * &lt;p&gt;
257      * IMPORTANT: The given UnicodeString must not be empty! It is the caller&#39;s responsibility to check.
258      */
259     int32_t getCommonPrefixLength(const UnicodeString&amp; other);
260 
261     /**
262      * Like {@link #getCommonPrefixLength}, but never performs case folding, even if case folding is
263      * enabled for the parser.
264      */
265     int32_t getCaseSensitivePrefixLength(const UnicodeString&amp; other);
266 
267     bool operator==(const UnicodeString&amp; other) const;
268 
269   private:
<span class="line-modified">270     const UnicodeString&amp; fStr;</span>
271     int32_t fStart;
272     int32_t fEnd;
273     bool fFoldCase;
274 
275     int32_t getPrefixLengthInternal(const UnicodeString&amp; other, bool foldCase);
276 
277     static bool codePointsEqual(UChar32 cp1, UChar32 cp2, bool foldCase);
278 };
279 
280 
281 /**
282  * The core interface implemented by all matchers used for number parsing.
283  *
284  * Given a string, there should NOT be more than one way to consume the string with the same matcher
285  * applied multiple times. If there is, the non-greedy parsing algorithm will be unhappy and may enter an
286  * exponential-time loop. For example, consider the &quot;A Matcher&quot; that accepts &quot;any number of As&quot;. Given
287  * the string &quot;AAAA&quot;, there are 2^N = 8 ways to apply the A Matcher to this string: you could have the A
288  * Matcher apply 4 times to each character; you could have it apply just once to all the characters; you
289  * could have it apply to the first 2 characters and the second 2 characters; and so on. A better version
290  * of the &quot;A Matcher&quot; would be for it to accept exactly one A, and allow the algorithm to run it
</pre>
<hr />
<pre>
330      * match. Matchers should use the {@link StringSegment#startsWith} method in order to correctly
331      * handle case folding.
332      *
333      * @param segment
334      *            The segment to check against.
335      * @return true if the matcher might be able to match against this segment; false if it definitely
336      *         will not be able to match.
337      */
338     virtual bool smokeTest(const StringSegment&amp; segment) const = 0;
339 
340     /**
341      * Method called at the end of a parse, after all matchers have failed to consume any more chars.
342      * Allows a matcher to make final modifications to the result given the knowledge that no more
343      * matches are possible.
344      *
345      * @param result
346      *            The data structure to store results.
347      */
348     virtual void postProcess(ParsedNumber&amp;) const {
349         // Default implementation: no-op
<span class="line-modified">350     }</span>
351 
352     // String for debugging
353     virtual UnicodeString toString() const = 0;
354 
355   protected:
356     // No construction except by subclasses!
357     NumberParseMatcher() = default;
358 };
359 
360 
361 /**
362  * Interface for use in arguments.
363  */
364 // Exported as U_I18N_API for tests
365 class U_I18N_API MutableMatcherCollection {
366   public:
367     virtual ~MutableMatcherCollection() = default;
368 
369     virtual void addMatcher(NumberParseMatcher&amp; matcher) = 0;
370 };
</pre>
</td>
</tr>
</table>
<center><a href="numparse_symbols.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="numsys.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>