<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/quantityformatter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 ******************************************************************************
  5 * Copyright (C) 2014-2016, International Business Machines
  6 * Corporation and others.  All Rights Reserved.
  7 ******************************************************************************
  8 * quantityformatter.cpp
  9 */
 10 
 11 #include &quot;unicode/utypes.h&quot;
 12 
 13 #if !UCONFIG_NO_FORMATTING
 14 
 15 #include &quot;unicode/simpleformatter.h&quot;
 16 #include &quot;quantityformatter.h&quot;
 17 #include &quot;uassert.h&quot;
 18 #include &quot;unicode/unistr.h&quot;
 19 #include &quot;unicode/decimfmt.h&quot;
 20 #include &quot;cstring.h&quot;
 21 #include &quot;unicode/plurrule.h&quot;
 22 #include &quot;charstr.h&quot;
 23 #include &quot;unicode/fmtable.h&quot;
 24 #include &quot;unicode/fieldpos.h&quot;
 25 #include &quot;standardplural.h&quot;
 26 #include &quot;uassert.h&quot;
 27 #include &quot;number_decimalquantity.h&quot;
 28 #include &quot;number_utypes.h&quot;
 29 #include &quot;number_stringbuilder.h&quot;
 30 
 31 U_NAMESPACE_BEGIN
 32 
 33 QuantityFormatter::QuantityFormatter() {
 34     for (int32_t i = 0; i &lt; UPRV_LENGTHOF(formatters); ++i) {
 35         formatters[i] = NULL;
 36     }
 37 }
 38 
 39 QuantityFormatter::QuantityFormatter(const QuantityFormatter &amp;other) {
 40     for (int32_t i = 0; i &lt; UPRV_LENGTHOF(formatters); ++i) {
 41         if (other.formatters[i] == NULL) {
 42             formatters[i] = NULL;
 43         } else {
 44             formatters[i] = new SimpleFormatter(*other.formatters[i]);
 45         }
 46     }
 47 }
 48 
 49 QuantityFormatter &amp;QuantityFormatter::operator=(
 50         const QuantityFormatter&amp; other) {
 51     if (this == &amp;other) {
 52         return *this;
 53     }
 54     for (int32_t i = 0; i &lt; UPRV_LENGTHOF(formatters); ++i) {
 55         delete formatters[i];
 56         if (other.formatters[i] == NULL) {
 57             formatters[i] = NULL;
 58         } else {
 59             formatters[i] = new SimpleFormatter(*other.formatters[i]);
 60         }
 61     }
 62     return *this;
 63 }
 64 
 65 QuantityFormatter::~QuantityFormatter() {
 66     for (int32_t i = 0; i &lt; UPRV_LENGTHOF(formatters); ++i) {
 67         delete formatters[i];
 68     }
 69 }
 70 
 71 void QuantityFormatter::reset() {
 72     for (int32_t i = 0; i &lt; UPRV_LENGTHOF(formatters); ++i) {
 73         delete formatters[i];
 74         formatters[i] = NULL;
 75     }
 76 }
 77 
 78 UBool QuantityFormatter::addIfAbsent(
 79         const char *variant,
 80         const UnicodeString &amp;rawPattern,
 81         UErrorCode &amp;status) {
 82     int32_t pluralIndex = StandardPlural::indexFromString(variant, status);
 83     if (U_FAILURE(status)) {
 84         return FALSE;
 85     }
 86     if (formatters[pluralIndex] != NULL) {
 87         return TRUE;
 88     }
 89     SimpleFormatter *newFmt = new SimpleFormatter(rawPattern, 0, 1, status);
 90     if (newFmt == NULL) {
 91         status = U_MEMORY_ALLOCATION_ERROR;
 92         return FALSE;
 93     }
 94     if (U_FAILURE(status)) {
 95         delete newFmt;
 96         return FALSE;
 97     }
 98     formatters[pluralIndex] = newFmt;
 99     return TRUE;
100 }
101 
102 UBool QuantityFormatter::isValid() const {
103     return formatters[StandardPlural::OTHER] != NULL;
104 }
105 
106 const SimpleFormatter *QuantityFormatter::getByVariant(
107         const char *variant) const {
108     U_ASSERT(isValid());
109     int32_t pluralIndex = StandardPlural::indexOrOtherIndexFromString(variant);
110     const SimpleFormatter *pattern = formatters[pluralIndex];
111     if (pattern == NULL) {
112         pattern = formatters[StandardPlural::OTHER];
113     }
114     return pattern;
115 }
116 
117 UnicodeString &amp;QuantityFormatter::format(
118             const Formattable &amp;number,
119             const NumberFormat &amp;fmt,
120             const PluralRules &amp;rules,
121             UnicodeString &amp;appendTo,
122             FieldPosition &amp;pos,
123             UErrorCode &amp;status) const {
124     UnicodeString formattedNumber;
125     StandardPlural::Form p = selectPlural(number, fmt, rules, formattedNumber, pos, status);
126     if (U_FAILURE(status)) {
127         return appendTo;
128     }
129     const SimpleFormatter *pattern = formatters[p];
130     if (pattern == NULL) {
131         pattern = formatters[StandardPlural::OTHER];
132         if (pattern == NULL) {
133             status = U_INVALID_STATE_ERROR;
134             return appendTo;
135         }
136     }
137     return format(*pattern, formattedNumber, appendTo, pos, status);
138 }
139 
140 // The following methods live here so that class PluralRules does not depend on number formatting,
141 // and the SimpleFormatter does not depend on FieldPosition.
142 
143 StandardPlural::Form QuantityFormatter::selectPlural(
144             const Formattable &amp;number,
145             const NumberFormat &amp;fmt,
146             const PluralRules &amp;rules,
147             UnicodeString &amp;formattedNumber,
148             FieldPosition &amp;pos,
149             UErrorCode &amp;status) {
150     if (U_FAILURE(status)) {
151         return StandardPlural::OTHER;
152     }
153     UnicodeString pluralKeyword;
154     const DecimalFormat *decFmt = dynamic_cast&lt;const DecimalFormat *&gt;(&amp;fmt);
155     if (decFmt != NULL) {
156         number::impl::DecimalQuantity dq;
157         decFmt-&gt;formatToDecimalQuantity(number, dq, status);
158         if (U_FAILURE(status)) {
159             return StandardPlural::OTHER;
160         }
161         pluralKeyword = rules.select(dq);
162         decFmt-&gt;format(number, formattedNumber, pos, status);
163     } else {
164         if (number.getType() == Formattable::kDouble) {
165             pluralKeyword = rules.select(number.getDouble());
166         } else if (number.getType() == Formattable::kLong) {
167             pluralKeyword = rules.select(number.getLong());
168         } else if (number.getType() == Formattable::kInt64) {
169             pluralKeyword = rules.select((double) number.getInt64());
170         } else {
171             status = U_ILLEGAL_ARGUMENT_ERROR;
172             return StandardPlural::OTHER;
173         }
174         fmt.format(number, formattedNumber, pos, status);
175     }
176     return StandardPlural::orOtherFromString(pluralKeyword);
177 }
178 
179 void QuantityFormatter::formatAndSelect(
180         double quantity,
181         const NumberFormat&amp; fmt,
182         const PluralRules&amp; rules,
183         number::impl::NumberStringBuilder&amp; output,
184         StandardPlural::Form&amp; pluralForm,
185         UErrorCode&amp; status) {
186     UnicodeString pluralKeyword;
187     const DecimalFormat* df = dynamic_cast&lt;const DecimalFormat*&gt;(&amp;fmt);
188     if (df != nullptr) {
189         number::impl::UFormattedNumberData fn;
190         fn.quantity.setToDouble(quantity);
191         df-&gt;toNumberFormatter().formatImpl(&amp;fn, status);
192         if (U_FAILURE(status)) {
193             return;
194         }
195         output = std::move(fn.getStringRef());
196         pluralKeyword = rules.select(fn.quantity);
197     } else {
198         UnicodeString result;
199         fmt.format(quantity, result, status);
200         if (U_FAILURE(status)) {
201             return;
202         }
203         output.append(result, UNUM_FIELD_COUNT, status);
204         if (U_FAILURE(status)) {
205             return;
206         }
207         pluralKeyword = rules.select(quantity);
208     }
209     pluralForm = StandardPlural::orOtherFromString(pluralKeyword);
210 }
211 
212 UnicodeString &amp;QuantityFormatter::format(
213             const SimpleFormatter &amp;pattern,
214             const UnicodeString &amp;value,
215             UnicodeString &amp;appendTo,
216             FieldPosition &amp;pos,
217             UErrorCode &amp;status) {
218     if (U_FAILURE(status)) {
219         return appendTo;
220     }
221     const UnicodeString *param = &amp;value;
222     int32_t offset;
223     pattern.formatAndAppend(&amp;param, 1, appendTo, &amp;offset, 1, status);
224     if (pos.getBeginIndex() != 0 || pos.getEndIndex() != 0) {
225         if (offset &gt;= 0) {
226             pos.setBeginIndex(pos.getBeginIndex() + offset);
227             pos.setEndIndex(pos.getEndIndex() + offset);
228         } else {
229             pos.setBeginIndex(0);
230             pos.setEndIndex(0);
231         }
232     }
233     return appendTo;
234 }
235 
236 U_NAMESPACE_END
237 
238 #endif /* #if !UCONFIG_NO_FORMATTING */
    </pre>
  </body>
</html>