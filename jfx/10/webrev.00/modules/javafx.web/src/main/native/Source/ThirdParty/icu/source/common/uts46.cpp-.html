<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uts46.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 *   Copyright (C) 2010-2015, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 *******************************************************************************
   8 *   file name:  uts46.cpp
   9 *   encoding:   UTF-8
  10 *   tab size:   8 (not used)
  11 *   indentation:4
  12 *
  13 *   created on: 2010mar09
  14 *   created by: Markus W. Scherer
  15 */
  16 
  17 #include &quot;unicode/utypes.h&quot;
  18 
  19 #if !UCONFIG_NO_IDNA
  20 
  21 #include &quot;unicode/idna.h&quot;
  22 #include &quot;unicode/normalizer2.h&quot;
  23 #include &quot;unicode/uscript.h&quot;
  24 #include &quot;unicode/ustring.h&quot;
  25 #include &quot;unicode/utf16.h&quot;
  26 #include &quot;cmemory.h&quot;
  27 #include &quot;cstring.h&quot;
  28 #include &quot;punycode.h&quot;
  29 #include &quot;ubidi_props.h&quot;
  30 #include &quot;ustr_imp.h&quot;
  31 
  32 // Note about tests for UIDNA_ERROR_DOMAIN_NAME_TOO_LONG:
  33 //
  34 // The domain name length limit is 255 octets in an internal DNS representation
  35 // where the last (&quot;root&quot;) label is the empty label
  36 // represented by length byte 0 alone.
  37 // In a conventional string, this translates to 253 characters, or 254
  38 // if there is a trailing dot for the root label.
  39 
  40 U_NAMESPACE_BEGIN
  41 
  42 // Severe errors which usually result in a U+FFFD replacement character in the result string.
  43 const uint32_t severeErrors=
  44     UIDNA_ERROR_LEADING_COMBINING_MARK|
  45     UIDNA_ERROR_DISALLOWED|
  46     UIDNA_ERROR_PUNYCODE|
  47     UIDNA_ERROR_LABEL_HAS_DOT|
  48     UIDNA_ERROR_INVALID_ACE_LABEL;
  49 
  50 static inline UBool
  51 isASCIIString(const UnicodeString &amp;dest) {
  52     const UChar *s=dest.getBuffer();
  53     const UChar *limit=s+dest.length();
  54     while(s&lt;limit) {
  55         if(*s++&gt;0x7f) {
  56             return FALSE;
  57         }
  58     }
  59     return TRUE;
  60 }
  61 
  62 static UBool
  63 isASCIIOkBiDi(const UChar *s, int32_t length);
  64 
  65 static UBool
  66 isASCIIOkBiDi(const char *s, int32_t length);
  67 
  68 // IDNA class default implementations -------------------------------------- ***
  69 
  70 IDNA::~IDNA() {}
  71 
  72 void
  73 IDNA::labelToASCII_UTF8(StringPiece label, ByteSink &amp;dest,
  74                         IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
  75     if(U_SUCCESS(errorCode)) {
  76         UnicodeString destString;
  77         labelToASCII(UnicodeString::fromUTF8(label), destString,
  78                      info, errorCode).toUTF8(dest);
  79     }
  80 }
  81 
  82 void
  83 IDNA::labelToUnicodeUTF8(StringPiece label, ByteSink &amp;dest,
  84                          IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
  85     if(U_SUCCESS(errorCode)) {
  86         UnicodeString destString;
  87         labelToUnicode(UnicodeString::fromUTF8(label), destString,
  88                        info, errorCode).toUTF8(dest);
  89     }
  90 }
  91 
  92 void
  93 IDNA::nameToASCII_UTF8(StringPiece name, ByteSink &amp;dest,
  94                        IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
  95     if(U_SUCCESS(errorCode)) {
  96         UnicodeString destString;
  97         nameToASCII(UnicodeString::fromUTF8(name), destString,
  98                     info, errorCode).toUTF8(dest);
  99     }
 100 }
 101 
 102 void
 103 IDNA::nameToUnicodeUTF8(StringPiece name, ByteSink &amp;dest,
 104                         IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
 105     if(U_SUCCESS(errorCode)) {
 106         UnicodeString destString;
 107         nameToUnicode(UnicodeString::fromUTF8(name), destString,
 108                       info, errorCode).toUTF8(dest);
 109     }
 110 }
 111 
 112 // UTS46 class declaration ------------------------------------------------- ***
 113 
 114 class UTS46 : public IDNA {
 115 public:
 116     UTS46(uint32_t options, UErrorCode &amp;errorCode);
 117     virtual ~UTS46();
 118 
 119     virtual UnicodeString &amp;
 120     labelToASCII(const UnicodeString &amp;label, UnicodeString &amp;dest,
 121                  IDNAInfo &amp;info, UErrorCode &amp;errorCode) const;
 122 
 123     virtual UnicodeString &amp;
 124     labelToUnicode(const UnicodeString &amp;label, UnicodeString &amp;dest,
 125                    IDNAInfo &amp;info, UErrorCode &amp;errorCode) const;
 126 
 127     virtual UnicodeString &amp;
 128     nameToASCII(const UnicodeString &amp;name, UnicodeString &amp;dest,
 129                 IDNAInfo &amp;info, UErrorCode &amp;errorCode) const;
 130 
 131     virtual UnicodeString &amp;
 132     nameToUnicode(const UnicodeString &amp;name, UnicodeString &amp;dest,
 133                   IDNAInfo &amp;info, UErrorCode &amp;errorCode) const;
 134 
 135     virtual void
 136     labelToASCII_UTF8(StringPiece label, ByteSink &amp;dest,
 137                       IDNAInfo &amp;info, UErrorCode &amp;errorCode) const;
 138 
 139     virtual void
 140     labelToUnicodeUTF8(StringPiece label, ByteSink &amp;dest,
 141                        IDNAInfo &amp;info, UErrorCode &amp;errorCode) const;
 142 
 143     virtual void
 144     nameToASCII_UTF8(StringPiece name, ByteSink &amp;dest,
 145                      IDNAInfo &amp;info, UErrorCode &amp;errorCode) const;
 146 
 147     virtual void
 148     nameToUnicodeUTF8(StringPiece name, ByteSink &amp;dest,
 149                       IDNAInfo &amp;info, UErrorCode &amp;errorCode) const;
 150 
 151 private:
 152     UnicodeString &amp;
 153     process(const UnicodeString &amp;src,
 154             UBool isLabel, UBool toASCII,
 155             UnicodeString &amp;dest,
 156             IDNAInfo &amp;info, UErrorCode &amp;errorCode) const;
 157 
 158     void
 159     processUTF8(StringPiece src,
 160                 UBool isLabel, UBool toASCII,
 161                 ByteSink &amp;dest,
 162                 IDNAInfo &amp;info, UErrorCode &amp;errorCode) const;
 163 
 164     UnicodeString &amp;
 165     processUnicode(const UnicodeString &amp;src,
 166                    int32_t labelStart, int32_t mappingStart,
 167                    UBool isLabel, UBool toASCII,
 168                    UnicodeString &amp;dest,
 169                    IDNAInfo &amp;info, UErrorCode &amp;errorCode) const;
 170 
 171     // returns the new dest.length()
 172     int32_t
 173     mapDevChars(UnicodeString &amp;dest, int32_t labelStart, int32_t mappingStart,
 174                 UErrorCode &amp;errorCode) const;
 175 
 176     // returns the new label length
 177     int32_t
 178     processLabel(UnicodeString &amp;dest,
 179                  int32_t labelStart, int32_t labelLength,
 180                  UBool toASCII,
 181                  IDNAInfo &amp;info, UErrorCode &amp;errorCode) const;
 182     int32_t
 183     markBadACELabel(UnicodeString &amp;dest,
 184                     int32_t labelStart, int32_t labelLength,
 185                     UBool toASCII, IDNAInfo &amp;info, UErrorCode &amp;errorCode) const;
 186 
 187     void
 188     checkLabelBiDi(const UChar *label, int32_t labelLength, IDNAInfo &amp;info) const;
 189 
 190     UBool
 191     isLabelOkContextJ(const UChar *label, int32_t labelLength) const;
 192 
 193     void
 194     checkLabelContextO(const UChar *label, int32_t labelLength, IDNAInfo &amp;info) const;
 195 
 196     const Normalizer2 &amp;uts46Norm2;  // uts46.nrm
 197     uint32_t options;
 198 };
 199 
 200 IDNA *
 201 IDNA::createUTS46Instance(uint32_t options, UErrorCode &amp;errorCode) {
 202     if(U_SUCCESS(errorCode)) {
 203         IDNA *idna=new UTS46(options, errorCode);
 204         if(idna==NULL) {
 205             errorCode=U_MEMORY_ALLOCATION_ERROR;
 206         } else if(U_FAILURE(errorCode)) {
 207             delete idna;
 208             idna=NULL;
 209         }
 210         return idna;
 211     } else {
 212         return NULL;
 213     }
 214 }
 215 
 216 // UTS46 implementation ---------------------------------------------------- ***
 217 
 218 UTS46::UTS46(uint32_t opt, UErrorCode &amp;errorCode)
 219         : uts46Norm2(*Normalizer2::getInstance(NULL, &quot;uts46&quot;, UNORM2_COMPOSE, errorCode)),
 220           options(opt) {}
 221 
 222 UTS46::~UTS46() {}
 223 
 224 UnicodeString &amp;
 225 UTS46::labelToASCII(const UnicodeString &amp;label, UnicodeString &amp;dest,
 226                     IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
 227     return process(label, TRUE, TRUE, dest, info, errorCode);
 228 }
 229 
 230 UnicodeString &amp;
 231 UTS46::labelToUnicode(const UnicodeString &amp;label, UnicodeString &amp;dest,
 232                       IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
 233     return process(label, TRUE, FALSE, dest, info, errorCode);
 234 }
 235 
 236 UnicodeString &amp;
 237 UTS46::nameToASCII(const UnicodeString &amp;name, UnicodeString &amp;dest,
 238                    IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
 239     process(name, FALSE, TRUE, dest, info, errorCode);
 240     if( dest.length()&gt;=254 &amp;&amp; (info.errors&amp;UIDNA_ERROR_DOMAIN_NAME_TOO_LONG)==0 &amp;&amp;
 241         isASCIIString(dest) &amp;&amp;
 242         (dest.length()&gt;254 || dest[253]!=0x2e)
 243     ) {
 244         info.errors|=UIDNA_ERROR_DOMAIN_NAME_TOO_LONG;
 245     }
 246     return dest;
 247 }
 248 
 249 UnicodeString &amp;
 250 UTS46::nameToUnicode(const UnicodeString &amp;name, UnicodeString &amp;dest,
 251                      IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
 252     return process(name, FALSE, FALSE, dest, info, errorCode);
 253 }
 254 
 255 void
 256 UTS46::labelToASCII_UTF8(StringPiece label, ByteSink &amp;dest,
 257                          IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
 258     processUTF8(label, TRUE, TRUE, dest, info, errorCode);
 259 }
 260 
 261 void
 262 UTS46::labelToUnicodeUTF8(StringPiece label, ByteSink &amp;dest,
 263                           IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
 264     processUTF8(label, TRUE, FALSE, dest, info, errorCode);
 265 }
 266 
 267 void
 268 UTS46::nameToASCII_UTF8(StringPiece name, ByteSink &amp;dest,
 269                         IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
 270     processUTF8(name, FALSE, TRUE, dest, info, errorCode);
 271 }
 272 
 273 void
 274 UTS46::nameToUnicodeUTF8(StringPiece name, ByteSink &amp;dest,
 275                          IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
 276     processUTF8(name, FALSE, FALSE, dest, info, errorCode);
 277 }
 278 
 279 // UTS #46 data for ASCII characters.
 280 // The normalizer (using uts46.nrm) maps uppercase ASCII letters to lowercase
 281 // and passes through all other ASCII characters.
 282 // If UIDNA_USE_STD3_RULES is set, then non-LDH characters are disallowed
 283 // using this data.
 284 // The ASCII fastpath also uses this data.
 285 // Values: -1=disallowed  0==valid  1==mapped (lowercase)
 286 static const int8_t asciiData[128]={
 287     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 288     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 289     // 002D..002E; valid  #  HYPHEN-MINUS..FULL STOP
 290     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0, -1,
 291     // 0030..0039; valid  #  DIGIT ZERO..DIGIT NINE
 292      0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1, -1,
 293     // 0041..005A; mapped  #  LATIN CAPITAL LETTER A..LATIN CAPITAL LETTER Z
 294     -1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
 295      1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1,
 296     // 0061..007A; valid  #  LATIN SMALL LETTER A..LATIN SMALL LETTER Z
 297     -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 298      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1
 299 };
 300 
 301 UnicodeString &amp;
 302 UTS46::process(const UnicodeString &amp;src,
 303                UBool isLabel, UBool toASCII,
 304                UnicodeString &amp;dest,
 305                IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
 306     // uts46Norm2.normalize() would do all of this error checking and setup,
 307     // but with the ASCII fastpath we do not always call it, and do not
 308     // call it first.
 309     if(U_FAILURE(errorCode)) {
 310         dest.setToBogus();
 311         return dest;
 312     }
 313     const UChar *srcArray=src.getBuffer();
 314     if(&amp;dest==&amp;src || srcArray==NULL) {
 315         errorCode=U_ILLEGAL_ARGUMENT_ERROR;
 316         dest.setToBogus();
 317         return dest;
 318     }
 319     // Arguments are fine, reset output values.
 320     dest.remove();
 321     info.reset();
 322     int32_t srcLength=src.length();
 323     if(srcLength==0) {
 324         info.errors|=UIDNA_ERROR_EMPTY_LABEL;
 325         return dest;
 326     }
 327     UChar *destArray=dest.getBuffer(srcLength);
 328     if(destArray==NULL) {
 329         errorCode=U_MEMORY_ALLOCATION_ERROR;
 330         return dest;
 331     }
 332     // ASCII fastpath
 333     UBool disallowNonLDHDot=(options&amp;UIDNA_USE_STD3_RULES)!=0;
 334     int32_t labelStart=0;
 335     int32_t i;
 336     for(i=0;; ++i) {
 337         if(i==srcLength) {
 338             if(toASCII) {
 339                 if((i-labelStart)&gt;63) {
 340                     info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
 341                 }
 342                 // There is a trailing dot if labelStart==i.
 343                 if(!isLabel &amp;&amp; i&gt;=254 &amp;&amp; (i&gt;254 || labelStart&lt;i)) {
 344                     info.errors|=UIDNA_ERROR_DOMAIN_NAME_TOO_LONG;
 345                 }
 346             }
 347             info.errors|=info.labelErrors;
 348             dest.releaseBuffer(i);
 349             return dest;
 350         }
 351         UChar c=srcArray[i];
 352         if(c&gt;0x7f) {
 353             break;
 354         }
 355         int cData=asciiData[c];
 356         if(cData&gt;0) {
 357             destArray[i]=c+0x20;  // Lowercase an uppercase ASCII letter.
 358         } else if(cData&lt;0 &amp;&amp; disallowNonLDHDot) {
 359             break;  // Replacing with U+FFFD can be complicated for toASCII.
 360         } else {
 361             destArray[i]=c;
 362             if(c==0x2d) {  // hyphen
 363                 if(i==(labelStart+3) &amp;&amp; srcArray[i-1]==0x2d) {
 364                     // &quot;??--...&quot; is Punycode or forbidden.
 365                     ++i;  // &#39;-&#39; was copied to dest already
 366                     break;
 367                 }
 368                 if(i==labelStart) {
 369                     // label starts with &quot;-&quot;
 370                     info.labelErrors|=UIDNA_ERROR_LEADING_HYPHEN;
 371                 }
 372                 if((i+1)==srcLength || srcArray[i+1]==0x2e) {
 373                     // label ends with &quot;-&quot;
 374                     info.labelErrors|=UIDNA_ERROR_TRAILING_HYPHEN;
 375                 }
 376             } else if(c==0x2e) {  // dot
 377                 if(isLabel) {
 378                     // Replacing with U+FFFD can be complicated for toASCII.
 379                     ++i;  // &#39;.&#39; was copied to dest already
 380                     break;
 381                 }
 382                 if(i==labelStart) {
 383                     info.labelErrors|=UIDNA_ERROR_EMPTY_LABEL;
 384                 }
 385                 if(toASCII &amp;&amp; (i-labelStart)&gt;63) {
 386                     info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
 387                 }
 388                 info.errors|=info.labelErrors;
 389                 info.labelErrors=0;
 390                 labelStart=i+1;
 391             }
 392         }
 393     }
 394     info.errors|=info.labelErrors;
 395     dest.releaseBuffer(i);
 396     processUnicode(src, labelStart, i, isLabel, toASCII, dest, info, errorCode);
 397     if( info.isBiDi &amp;&amp; U_SUCCESS(errorCode) &amp;&amp; (info.errors&amp;severeErrors)==0 &amp;&amp;
 398         (!info.isOkBiDi || (labelStart&gt;0 &amp;&amp; !isASCIIOkBiDi(dest.getBuffer(), labelStart)))
 399     ) {
 400         info.errors|=UIDNA_ERROR_BIDI;
 401     }
 402     return dest;
 403 }
 404 
 405 void
 406 UTS46::processUTF8(StringPiece src,
 407                    UBool isLabel, UBool toASCII,
 408                    ByteSink &amp;dest,
 409                    IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
 410     if(U_FAILURE(errorCode)) {
 411         return;
 412     }
 413     const char *srcArray=src.data();
 414     int32_t srcLength=src.length();
 415     if(srcArray==NULL &amp;&amp; srcLength!=0) {
 416         errorCode=U_ILLEGAL_ARGUMENT_ERROR;
 417         return;
 418     }
 419     // Arguments are fine, reset output values.
 420     info.reset();
 421     if(srcLength==0) {
 422         info.errors|=UIDNA_ERROR_EMPTY_LABEL;
 423         dest.Flush();
 424         return;
 425     }
 426     UnicodeString destString;
 427     int32_t labelStart=0;
 428     if(srcLength&lt;=256) {  // length of stackArray[]
 429         // ASCII fastpath
 430         char stackArray[256];
 431         int32_t destCapacity;
 432         char *destArray=dest.GetAppendBuffer(srcLength, srcLength+20,
 433                                              stackArray, UPRV_LENGTHOF(stackArray), &amp;destCapacity);
 434         UBool disallowNonLDHDot=(options&amp;UIDNA_USE_STD3_RULES)!=0;
 435         int32_t i;
 436         for(i=0;; ++i) {
 437             if(i==srcLength) {
 438                 if(toASCII) {
 439                     if((i-labelStart)&gt;63) {
 440                         info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
 441                     }
 442                     // There is a trailing dot if labelStart==i.
 443                     if(!isLabel &amp;&amp; i&gt;=254 &amp;&amp; (i&gt;254 || labelStart&lt;i)) {
 444                         info.errors|=UIDNA_ERROR_DOMAIN_NAME_TOO_LONG;
 445                     }
 446                 }
 447                 info.errors|=info.labelErrors;
 448                 dest.Append(destArray, i);
 449                 dest.Flush();
 450                 return;
 451             }
 452             char c=srcArray[i];
 453             if((int8_t)c&lt;0) {  // (uint8_t)c&gt;0x7f
 454                 break;
 455             }
 456             int cData=asciiData[(int)c];  // Cast: gcc warns about indexing with a char.
 457             if(cData&gt;0) {
 458                 destArray[i]=c+0x20;  // Lowercase an uppercase ASCII letter.
 459             } else if(cData&lt;0 &amp;&amp; disallowNonLDHDot) {
 460                 break;  // Replacing with U+FFFD can be complicated for toASCII.
 461             } else {
 462                 destArray[i]=c;
 463                 if(c==0x2d) {  // hyphen
 464                     if(i==(labelStart+3) &amp;&amp; srcArray[i-1]==0x2d) {
 465                         // &quot;??--...&quot; is Punycode or forbidden.
 466                         break;
 467                     }
 468                     if(i==labelStart) {
 469                         // label starts with &quot;-&quot;
 470                         info.labelErrors|=UIDNA_ERROR_LEADING_HYPHEN;
 471                     }
 472                     if((i+1)==srcLength || srcArray[i+1]==0x2e) {
 473                         // label ends with &quot;-&quot;
 474                         info.labelErrors|=UIDNA_ERROR_TRAILING_HYPHEN;
 475                     }
 476                 } else if(c==0x2e) {  // dot
 477                     if(isLabel) {
 478                         break;  // Replacing with U+FFFD can be complicated for toASCII.
 479                     }
 480                     if(i==labelStart) {
 481                         info.labelErrors|=UIDNA_ERROR_EMPTY_LABEL;
 482                     }
 483                     if(toASCII &amp;&amp; (i-labelStart)&gt;63) {
 484                         info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
 485                     }
 486                     info.errors|=info.labelErrors;
 487                     info.labelErrors=0;
 488                     labelStart=i+1;
 489                 }
 490             }
 491         }
 492         info.errors|=info.labelErrors;
 493         // Convert the processed ASCII prefix of the current label to UTF-16.
 494         int32_t mappingStart=i-labelStart;
 495         destString=UnicodeString::fromUTF8(StringPiece(destArray+labelStart, mappingStart));
 496         // Output the previous ASCII labels and process the rest of src in UTF-16.
 497         dest.Append(destArray, labelStart);
 498         processUnicode(UnicodeString::fromUTF8(StringPiece(src, labelStart)), 0, mappingStart,
 499                        isLabel, toASCII,
 500                        destString, info, errorCode);
 501     } else {
 502         // src is too long for the ASCII fastpath implementation.
 503         processUnicode(UnicodeString::fromUTF8(src), 0, 0,
 504                        isLabel, toASCII,
 505                        destString, info, errorCode);
 506     }
 507     destString.toUTF8(dest);  // calls dest.Flush()
 508     if(toASCII &amp;&amp; !isLabel) {
 509         // length==labelStart==254 means that there is a trailing dot (ok) and
 510         // destString is empty (do not index at 253-labelStart).
 511         int32_t length=labelStart+destString.length();
 512         if( length&gt;=254 &amp;&amp; isASCIIString(destString) &amp;&amp;
 513             (length&gt;254 ||
 514              (labelStart&lt;254 &amp;&amp; destString[253-labelStart]!=0x2e))
 515         ) {
 516             info.errors|=UIDNA_ERROR_DOMAIN_NAME_TOO_LONG;
 517         }
 518     }
 519     if( info.isBiDi &amp;&amp; U_SUCCESS(errorCode) &amp;&amp; (info.errors&amp;severeErrors)==0 &amp;&amp;
 520         (!info.isOkBiDi || (labelStart&gt;0 &amp;&amp; !isASCIIOkBiDi(srcArray, labelStart)))
 521     ) {
 522         info.errors|=UIDNA_ERROR_BIDI;
 523     }
 524 }
 525 
 526 UnicodeString &amp;
 527 UTS46::processUnicode(const UnicodeString &amp;src,
 528                       int32_t labelStart, int32_t mappingStart,
 529                       UBool isLabel, UBool toASCII,
 530                       UnicodeString &amp;dest,
 531                       IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
 532     if(mappingStart==0) {
 533         uts46Norm2.normalize(src, dest, errorCode);
 534     } else {
 535         uts46Norm2.normalizeSecondAndAppend(dest, src.tempSubString(mappingStart), errorCode);
 536     }
 537     if(U_FAILURE(errorCode)) {
 538         return dest;
 539     }
 540     UBool doMapDevChars=
 541         toASCII ? (options&amp;UIDNA_NONTRANSITIONAL_TO_ASCII)==0 :
 542                   (options&amp;UIDNA_NONTRANSITIONAL_TO_UNICODE)==0;
 543     const UChar *destArray=dest.getBuffer();
 544     int32_t destLength=dest.length();
 545     int32_t labelLimit=labelStart;
 546     while(labelLimit&lt;destLength) {
 547         UChar c=destArray[labelLimit];
 548         if(c==0x2e &amp;&amp; !isLabel) {
 549             int32_t labelLength=labelLimit-labelStart;
 550             int32_t newLength=processLabel(dest, labelStart, labelLength,
 551                                             toASCII, info, errorCode);
 552             info.errors|=info.labelErrors;
 553             info.labelErrors=0;
 554             if(U_FAILURE(errorCode)) {
 555                 return dest;
 556             }
 557             destArray=dest.getBuffer();
 558             destLength+=newLength-labelLength;
 559             labelLimit=labelStart+=newLength+1;
 560         } else if(0xdf&lt;=c &amp;&amp; c&lt;=0x200d &amp;&amp; (c==0xdf || c==0x3c2 || c&gt;=0x200c)) {
 561             info.isTransDiff=TRUE;
 562             if(doMapDevChars) {
 563                 destLength=mapDevChars(dest, labelStart, labelLimit, errorCode);
 564                 if(U_FAILURE(errorCode)) {
 565                     return dest;
 566                 }
 567                 destArray=dest.getBuffer();
 568                 // Do not increment labelLimit in case c was removed.
 569                 // All deviation characters have been mapped, no need to check for them again.
 570                 doMapDevChars=FALSE;
 571             } else {
 572                 ++labelLimit;
 573             }
 574         } else {
 575             ++labelLimit;
 576         }
 577     }
 578     // Permit an empty label at the end (0&lt;labelStart==labelLimit==destLength is ok)
 579     // but not an empty label elsewhere nor a completely empty domain name.
 580     // processLabel() sets UIDNA_ERROR_EMPTY_LABEL when labelLength==0.
 581     if(0==labelStart || labelStart&lt;labelLimit) {
 582         processLabel(dest, labelStart, labelLimit-labelStart,
 583                       toASCII, info, errorCode);
 584         info.errors|=info.labelErrors;
 585     }
 586     return dest;
 587 }
 588 
 589 int32_t
 590 UTS46::mapDevChars(UnicodeString &amp;dest, int32_t labelStart, int32_t mappingStart,
 591                    UErrorCode &amp;errorCode) const {
 592     if(U_FAILURE(errorCode)) {
 593         return 0;
 594     }
 595     int32_t length=dest.length();
 596     UChar *s=dest.getBuffer(dest[mappingStart]==0xdf ? length+1 : length);
 597     if(s==NULL) {
 598         errorCode=U_MEMORY_ALLOCATION_ERROR;
 599         return length;
 600     }
 601     int32_t capacity=dest.getCapacity();
 602     UBool didMapDevChars=FALSE;
 603     int32_t readIndex=mappingStart, writeIndex=mappingStart;
 604     do {
 605         UChar c=s[readIndex++];
 606         switch(c) {
 607         case 0xdf:
 608             // Map sharp s to ss.
 609             didMapDevChars=TRUE;
 610             s[writeIndex++]=0x73;  // Replace sharp s with first s.
 611             // Insert second s and account for possible buffer reallocation.
 612             if(writeIndex==readIndex) {
 613                 if(length==capacity) {
 614                     dest.releaseBuffer(length);
 615                     s=dest.getBuffer(length+1);
 616                     if(s==NULL) {
 617                         errorCode=U_MEMORY_ALLOCATION_ERROR;
 618                         return length;
 619                     }
 620                     capacity=dest.getCapacity();
 621                 }
 622                 u_memmove(s+writeIndex+1, s+writeIndex, length-writeIndex);
 623                 ++readIndex;
 624             }
 625             s[writeIndex++]=0x73;
 626             ++length;
 627             break;
 628         case 0x3c2:  // Map final sigma to nonfinal sigma.
 629             didMapDevChars=TRUE;
 630             s[writeIndex++]=0x3c3;
 631             break;
 632         case 0x200c:  // Ignore/remove ZWNJ.
 633         case 0x200d:  // Ignore/remove ZWJ.
 634             didMapDevChars=TRUE;
 635             --length;
 636             break;
 637         default:
 638             // Only really necessary if writeIndex was different from readIndex.
 639             s[writeIndex++]=c;
 640             break;
 641         }
 642     } while(writeIndex&lt;length);
 643     dest.releaseBuffer(length);
 644     if(didMapDevChars) {
 645         // Mapping deviation characters might have resulted in an un-NFC string.
 646         // We could use either the NFC or the UTS #46 normalizer.
 647         // By using the UTS #46 normalizer again, we avoid having to load a second .nrm data file.
 648         UnicodeString normalized;
 649         uts46Norm2.normalize(dest.tempSubString(labelStart), normalized, errorCode);
 650         if(U_SUCCESS(errorCode)) {
 651             dest.replace(labelStart, 0x7fffffff, normalized);
 652             if(dest.isBogus()) {
 653                 errorCode=U_MEMORY_ALLOCATION_ERROR;
 654             }
 655             return dest.length();
 656         }
 657     }
 658     return length;
 659 }
 660 
 661 // Some non-ASCII characters are equivalent to sequences with
 662 // non-LDH ASCII characters. To find them:
 663 // grep disallowed_STD3_valid IdnaMappingTable.txt (or uts46.txt)
 664 static inline UBool
 665 isNonASCIIDisallowedSTD3Valid(UChar32 c) {
 666     return c==0x2260 || c==0x226E || c==0x226F;
 667 }
 668 
 669 // Replace the label in dest with the label string, if the label was modified.
 670 // If &amp;label==&amp;dest then the label was modified in-place and labelLength
 671 // is the new label length, different from label.length().
 672 // If &amp;label!=&amp;dest then labelLength==label.length().
 673 // Returns labelLength (= the new label length).
 674 static int32_t
 675 replaceLabel(UnicodeString &amp;dest, int32_t destLabelStart, int32_t destLabelLength,
 676              const UnicodeString &amp;label, int32_t labelLength, UErrorCode &amp;errorCode) {
 677     if(U_FAILURE(errorCode)) {
 678         return 0;
 679     }
 680     if(&amp;label!=&amp;dest) {
 681         dest.replace(destLabelStart, destLabelLength, label);
 682         if(dest.isBogus()) {
 683             errorCode=U_MEMORY_ALLOCATION_ERROR;
 684             return 0;
 685         }
 686     }
 687     return labelLength;
 688 }
 689 
 690 int32_t
 691 UTS46::processLabel(UnicodeString &amp;dest,
 692                     int32_t labelStart, int32_t labelLength,
 693                     UBool toASCII,
 694                     IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
 695     if(U_FAILURE(errorCode)) {
 696         return 0;
 697     }
 698     UnicodeString fromPunycode;
 699     UnicodeString *labelString;
 700     const UChar *label=dest.getBuffer()+labelStart;
 701     int32_t destLabelStart=labelStart;
 702     int32_t destLabelLength=labelLength;
 703     UBool wasPunycode;
 704     if(labelLength&gt;=4 &amp;&amp; label[0]==0x78 &amp;&amp; label[1]==0x6e &amp;&amp; label[2]==0x2d &amp;&amp; label[3]==0x2d) {
 705         // Label starts with &quot;xn--&quot;, try to un-Punycode it.
 706         wasPunycode=TRUE;
 707         UChar *unicodeBuffer=fromPunycode.getBuffer(-1);  // capacity==-1: most labels should fit
 708         if(unicodeBuffer==NULL) {
 709             // Should never occur if we used capacity==-1 which uses the internal buffer.
 710             errorCode=U_MEMORY_ALLOCATION_ERROR;
 711             return labelLength;
 712         }
 713         UErrorCode punycodeErrorCode=U_ZERO_ERROR;
 714         int32_t unicodeLength=u_strFromPunycode(label+4, labelLength-4,
 715                                                 unicodeBuffer, fromPunycode.getCapacity(),
 716                                                 NULL, &amp;punycodeErrorCode);
 717         if(punycodeErrorCode==U_BUFFER_OVERFLOW_ERROR) {
 718             fromPunycode.releaseBuffer(0);
 719             unicodeBuffer=fromPunycode.getBuffer(unicodeLength);
 720             if(unicodeBuffer==NULL) {
 721                 errorCode=U_MEMORY_ALLOCATION_ERROR;
 722                 return labelLength;
 723             }
 724             punycodeErrorCode=U_ZERO_ERROR;
 725             unicodeLength=u_strFromPunycode(label+4, labelLength-4,
 726                                             unicodeBuffer, fromPunycode.getCapacity(),
 727                                             NULL, &amp;punycodeErrorCode);
 728         }
 729         fromPunycode.releaseBuffer(unicodeLength);
 730         if(U_FAILURE(punycodeErrorCode)) {
 731             info.labelErrors|=UIDNA_ERROR_PUNYCODE;
 732             return markBadACELabel(dest, labelStart, labelLength, toASCII, info, errorCode);
 733         }
 734         // Check for NFC, and for characters that are not
 735         // valid or deviation characters according to the normalizer.
 736         // If there is something wrong, then the string will change.
 737         // Note that the normalizer passes through non-LDH ASCII and deviation characters.
 738         // Deviation characters are ok in Punycode even in transitional processing.
 739         // In the code further below, if we find non-LDH ASCII and we have UIDNA_USE_STD3_RULES
 740         // then we will set UIDNA_ERROR_INVALID_ACE_LABEL there too.
 741         UBool isValid=uts46Norm2.isNormalized(fromPunycode, errorCode);
 742         if(U_FAILURE(errorCode)) {
 743             return labelLength;
 744         }
 745         if(!isValid) {
 746             info.labelErrors|=UIDNA_ERROR_INVALID_ACE_LABEL;
 747             return markBadACELabel(dest, labelStart, labelLength, toASCII, info, errorCode);
 748         }
 749         labelString=&amp;fromPunycode;
 750         label=fromPunycode.getBuffer();
 751         labelStart=0;
 752         labelLength=fromPunycode.length();
 753     } else {
 754         wasPunycode=FALSE;
 755         labelString=&amp;dest;
 756     }
 757     // Validity check
 758     if(labelLength==0) {
 759         info.labelErrors|=UIDNA_ERROR_EMPTY_LABEL;
 760         return replaceLabel(dest, destLabelStart, destLabelLength,
 761                             *labelString, labelLength, errorCode);
 762     }
 763     // labelLength&gt;0
 764     if(labelLength&gt;=4 &amp;&amp; label[2]==0x2d &amp;&amp; label[3]==0x2d) {
 765         // label starts with &quot;??--&quot;
 766         info.labelErrors|=UIDNA_ERROR_HYPHEN_3_4;
 767     }
 768     if(label[0]==0x2d) {
 769         // label starts with &quot;-&quot;
 770         info.labelErrors|=UIDNA_ERROR_LEADING_HYPHEN;
 771     }
 772     if(label[labelLength-1]==0x2d) {
 773         // label ends with &quot;-&quot;
 774         info.labelErrors|=UIDNA_ERROR_TRAILING_HYPHEN;
 775     }
 776     // If the label was not a Punycode label, then it was the result of
 777     // mapping, normalization and label segmentation.
 778     // If the label was in Punycode, then we mapped it again above
 779     // and checked its validity.
 780     // Now we handle the STD3 restriction to LDH characters (if set)
 781     // and we look for U+FFFD which indicates disallowed characters
 782     // in a non-Punycode label or U+FFFD itself in a Punycode label.
 783     // We also check for dots which can come from the input to a single-label function.
 784     // Ok to cast away const because we own the UnicodeString.
 785     UChar *s=(UChar *)label;
 786     const UChar *limit=label+labelLength;
 787     UChar oredChars=0;
 788     // If we enforce STD3 rules, then ASCII characters other than LDH and dot are disallowed.
 789     UBool disallowNonLDHDot=(options&amp;UIDNA_USE_STD3_RULES)!=0;
 790     do {
 791         UChar c=*s;
 792         if(c&lt;=0x7f) {
 793             if(c==0x2e) {
 794                 info.labelErrors|=UIDNA_ERROR_LABEL_HAS_DOT;
 795                 *s=0xfffd;
 796             } else if(disallowNonLDHDot &amp;&amp; asciiData[c]&lt;0) {
 797                 info.labelErrors|=UIDNA_ERROR_DISALLOWED;
 798                 *s=0xfffd;
 799             }
 800         } else {
 801             oredChars|=c;
 802             if(disallowNonLDHDot &amp;&amp; isNonASCIIDisallowedSTD3Valid(c)) {
 803                 info.labelErrors|=UIDNA_ERROR_DISALLOWED;
 804                 *s=0xfffd;
 805             } else if(c==0xfffd) {
 806                 info.labelErrors|=UIDNA_ERROR_DISALLOWED;
 807             }
 808         }
 809         ++s;
 810     } while(s&lt;limit);
 811     // Check for a leading combining mark after other validity checks
 812     // so that we don&#39;t report UIDNA_ERROR_DISALLOWED for the U+FFFD from here.
 813     UChar32 c;
 814     int32_t cpLength=0;
 815     // &quot;Unsafe&quot; is ok because unpaired surrogates were mapped to U+FFFD.
 816     U16_NEXT_UNSAFE(label, cpLength, c);
 817     if((U_GET_GC_MASK(c)&amp;U_GC_M_MASK)!=0) {
 818         info.labelErrors|=UIDNA_ERROR_LEADING_COMBINING_MARK;
 819         labelString-&gt;replace(labelStart, cpLength, (UChar)0xfffd);
 820         label=labelString-&gt;getBuffer()+labelStart;
 821         labelLength+=1-cpLength;
 822         if(labelString==&amp;dest) {
 823             destLabelLength=labelLength;
 824         }
 825     }
 826     if((info.labelErrors&amp;severeErrors)==0) {
 827         // Do contextual checks only if we do not have U+FFFD from a severe error
 828         // because U+FFFD can make these checks fail.
 829         if((options&amp;UIDNA_CHECK_BIDI)!=0 &amp;&amp; (!info.isBiDi || info.isOkBiDi)) {
 830             checkLabelBiDi(label, labelLength, info);
 831         }
 832         if( (options&amp;UIDNA_CHECK_CONTEXTJ)!=0 &amp;&amp; (oredChars&amp;0x200c)==0x200c &amp;&amp;
 833             !isLabelOkContextJ(label, labelLength)
 834         ) {
 835             info.labelErrors|=UIDNA_ERROR_CONTEXTJ;
 836         }
 837         if((options&amp;UIDNA_CHECK_CONTEXTO)!=0 &amp;&amp; oredChars&gt;=0xb7) {
 838             checkLabelContextO(label, labelLength, info);
 839         }
 840         if(toASCII) {
 841             if(wasPunycode) {
 842                 // Leave a Punycode label unchanged if it has no severe errors.
 843                 if(destLabelLength&gt;63) {
 844                     info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
 845                 }
 846                 return destLabelLength;
 847             } else if(oredChars&gt;=0x80) {
 848                 // Contains non-ASCII characters.
 849                 UnicodeString punycode;
 850                 UChar *buffer=punycode.getBuffer(63);  // 63==maximum DNS label length
 851                 if(buffer==NULL) {
 852                     errorCode=U_MEMORY_ALLOCATION_ERROR;
 853                     return destLabelLength;
 854                 }
 855                 buffer[0]=0x78;  // Write &quot;xn--&quot;.
 856                 buffer[1]=0x6e;
 857                 buffer[2]=0x2d;
 858                 buffer[3]=0x2d;
 859                 int32_t punycodeLength=u_strToPunycode(label, labelLength,
 860                                                       buffer+4, punycode.getCapacity()-4,
 861                                                       NULL, &amp;errorCode);
 862                 if(errorCode==U_BUFFER_OVERFLOW_ERROR) {
 863                     errorCode=U_ZERO_ERROR;
 864                     punycode.releaseBuffer(4);
 865                     buffer=punycode.getBuffer(4+punycodeLength);
 866                     if(buffer==NULL) {
 867                         errorCode=U_MEMORY_ALLOCATION_ERROR;
 868                         return destLabelLength;
 869                     }
 870                     punycodeLength=u_strToPunycode(label, labelLength,
 871                                                   buffer+4, punycode.getCapacity()-4,
 872                                                   NULL, &amp;errorCode);
 873                 }
 874                 punycodeLength+=4;
 875                 punycode.releaseBuffer(punycodeLength);
 876                 if(U_FAILURE(errorCode)) {
 877                     return destLabelLength;
 878                 }
 879                 if(punycodeLength&gt;63) {
 880                     info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
 881                 }
 882                 return replaceLabel(dest, destLabelStart, destLabelLength,
 883                                     punycode, punycodeLength, errorCode);
 884             } else {
 885                 // all-ASCII label
 886                 if(labelLength&gt;63) {
 887                     info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
 888                 }
 889             }
 890         }
 891     } else {
 892         // If a Punycode label has severe errors,
 893         // then leave it but make sure it does not look valid.
 894         if(wasPunycode) {
 895             info.labelErrors|=UIDNA_ERROR_INVALID_ACE_LABEL;
 896             return markBadACELabel(dest, destLabelStart, destLabelLength, toASCII, info, errorCode);
 897         }
 898     }
 899     return replaceLabel(dest, destLabelStart, destLabelLength,
 900                         *labelString, labelLength, errorCode);
 901 }
 902 
 903 // Make sure an ACE label does not look valid.
 904 // Append U+FFFD if the label has only LDH characters.
 905 // If UIDNA_USE_STD3_RULES, also replace disallowed ASCII characters with U+FFFD.
 906 int32_t
 907 UTS46::markBadACELabel(UnicodeString &amp;dest,
 908                        int32_t labelStart, int32_t labelLength,
 909                        UBool toASCII, IDNAInfo &amp;info, UErrorCode &amp;errorCode) const {
 910     if(U_FAILURE(errorCode)) {
 911         return 0;
 912     }
 913     UBool disallowNonLDHDot=(options&amp;UIDNA_USE_STD3_RULES)!=0;
 914     UBool isASCII=TRUE;
 915     UBool onlyLDH=TRUE;
 916     const UChar *label=dest.getBuffer()+labelStart;
 917     // Ok to cast away const because we own the UnicodeString.
 918     UChar *s=(UChar *)label+4;  // After the initial &quot;xn--&quot;.
 919     const UChar *limit=label+labelLength;
 920     do {
 921         UChar c=*s;
 922         if(c&lt;=0x7f) {
 923             if(c==0x2e) {
 924                 info.labelErrors|=UIDNA_ERROR_LABEL_HAS_DOT;
 925                 *s=0xfffd;
 926                 isASCII=onlyLDH=FALSE;
 927             } else if(asciiData[c]&lt;0) {
 928                 onlyLDH=FALSE;
 929                 if(disallowNonLDHDot) {
 930                     *s=0xfffd;
 931                     isASCII=FALSE;
 932                 }
 933             }
 934         } else {
 935             isASCII=onlyLDH=FALSE;
 936         }
 937     } while(++s&lt;limit);
 938     if(onlyLDH) {
 939         dest.insert(labelStart+labelLength, (UChar)0xfffd);
 940         if(dest.isBogus()) {
 941             errorCode=U_MEMORY_ALLOCATION_ERROR;
 942             return 0;
 943         }
 944         ++labelLength;
 945     } else {
 946         if(toASCII &amp;&amp; isASCII &amp;&amp; labelLength&gt;63) {
 947             info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
 948         }
 949     }
 950     return labelLength;
 951 }
 952 
 953 const uint32_t L_MASK=U_MASK(U_LEFT_TO_RIGHT);
 954 const uint32_t R_AL_MASK=U_MASK(U_RIGHT_TO_LEFT)|U_MASK(U_RIGHT_TO_LEFT_ARABIC);
 955 const uint32_t L_R_AL_MASK=L_MASK|R_AL_MASK;
 956 
 957 const uint32_t R_AL_AN_MASK=R_AL_MASK|U_MASK(U_ARABIC_NUMBER);
 958 
 959 const uint32_t EN_AN_MASK=U_MASK(U_EUROPEAN_NUMBER)|U_MASK(U_ARABIC_NUMBER);
 960 const uint32_t R_AL_EN_AN_MASK=R_AL_MASK|EN_AN_MASK;
 961 const uint32_t L_EN_MASK=L_MASK|U_MASK(U_EUROPEAN_NUMBER);
 962 
 963 const uint32_t ES_CS_ET_ON_BN_NSM_MASK=
 964     U_MASK(U_EUROPEAN_NUMBER_SEPARATOR)|
 965     U_MASK(U_COMMON_NUMBER_SEPARATOR)|
 966     U_MASK(U_EUROPEAN_NUMBER_TERMINATOR)|
 967     U_MASK(U_OTHER_NEUTRAL)|
 968     U_MASK(U_BOUNDARY_NEUTRAL)|
 969     U_MASK(U_DIR_NON_SPACING_MARK);
 970 const uint32_t L_EN_ES_CS_ET_ON_BN_NSM_MASK=L_EN_MASK|ES_CS_ET_ON_BN_NSM_MASK;
 971 const uint32_t R_AL_AN_EN_ES_CS_ET_ON_BN_NSM_MASK=R_AL_MASK|EN_AN_MASK|ES_CS_ET_ON_BN_NSM_MASK;
 972 
 973 // We scan the whole label and check both for whether it contains RTL characters
 974 // and whether it passes the BiDi Rule.
 975 // In a BiDi domain name, all labels must pass the BiDi Rule, but we might find
 976 // that a domain name is a BiDi domain name (has an RTL label) only after
 977 // processing several earlier labels.
 978 void
 979 UTS46::checkLabelBiDi(const UChar *label, int32_t labelLength, IDNAInfo &amp;info) const {
 980     // IDNA2008 BiDi rule
 981     // Get the directionality of the first character.
 982     UChar32 c;
 983     int32_t i=0;
 984     U16_NEXT_UNSAFE(label, i, c);
 985     uint32_t firstMask=U_MASK(u_charDirection(c));
 986     // 1. The first character must be a character with BIDI property L, R
 987     // or AL.  If it has the R or AL property, it is an RTL label; if it
 988     // has the L property, it is an LTR label.
 989     if((firstMask&amp;~L_R_AL_MASK)!=0) {
 990         info.isOkBiDi=FALSE;
 991     }
 992     // Get the directionality of the last non-NSM character.
 993     uint32_t lastMask;
 994     for(;;) {
 995         if(i&gt;=labelLength) {
 996             lastMask=firstMask;
 997             break;
 998         }
 999         U16_PREV_UNSAFE(label, labelLength, c);
1000         UCharDirection dir=u_charDirection(c);
1001         if(dir!=U_DIR_NON_SPACING_MARK) {
1002             lastMask=U_MASK(dir);
1003             break;
1004         }
1005     }
1006     // 3. In an RTL label, the end of the label must be a character with
1007     // BIDI property R, AL, EN or AN, followed by zero or more
1008     // characters with BIDI property NSM.
1009     // 6. In an LTR label, the end of the label must be a character with
1010     // BIDI property L or EN, followed by zero or more characters with
1011     // BIDI property NSM.
1012     if( (firstMask&amp;L_MASK)!=0 ?
1013             (lastMask&amp;~L_EN_MASK)!=0 :
1014             (lastMask&amp;~R_AL_EN_AN_MASK)!=0
1015     ) {
1016         info.isOkBiDi=FALSE;
1017     }
1018     // Add the directionalities of the intervening characters.
1019     uint32_t mask=firstMask|lastMask;
1020     while(i&lt;labelLength) {
1021         U16_NEXT_UNSAFE(label, i, c);
1022         mask|=U_MASK(u_charDirection(c));
1023     }
1024     if(firstMask&amp;L_MASK) {
1025         // 5. In an LTR label, only characters with the BIDI properties L, EN,
1026         // ES, CS, ET, ON, BN and NSM are allowed.
1027         if((mask&amp;~L_EN_ES_CS_ET_ON_BN_NSM_MASK)!=0) {
1028             info.isOkBiDi=FALSE;
1029         }
1030     } else {
1031         // 2. In an RTL label, only characters with the BIDI properties R, AL,
1032         // AN, EN, ES, CS, ET, ON, BN and NSM are allowed.
1033         if((mask&amp;~R_AL_AN_EN_ES_CS_ET_ON_BN_NSM_MASK)!=0) {
1034             info.isOkBiDi=FALSE;
1035         }
1036         // 4. In an RTL label, if an EN is present, no AN may be present, and
1037         // vice versa.
1038         if((mask&amp;EN_AN_MASK)==EN_AN_MASK) {
1039             info.isOkBiDi=FALSE;
1040         }
1041     }
1042     // An RTL label is a label that contains at least one character of type
1043     // R, AL or AN. [...]
1044     // A &quot;BIDI domain name&quot; is a domain name that contains at least one RTL
1045     // label. [...]
1046     // The following rule, consisting of six conditions, applies to labels
1047     // in BIDI domain names.
1048     if((mask&amp;R_AL_AN_MASK)!=0) {
1049         info.isBiDi=TRUE;
1050     }
1051 }
1052 
1053 // Special code for the ASCII prefix of a BiDi domain name.
1054 // The ASCII prefix is all-LTR.
1055 
1056 // IDNA2008 BiDi rule, parts relevant to ASCII labels:
1057 // 1. The first character must be a character with BIDI property L [...]
1058 // 5. In an LTR label, only characters with the BIDI properties L, EN,
1059 // ES, CS, ET, ON, BN and NSM are allowed.
1060 // 6. In an LTR label, the end of the label must be a character with
1061 // BIDI property L or EN [...]
1062 
1063 // UTF-16 version, called for mapped ASCII prefix.
1064 // Cannot contain uppercase A-Z.
1065 // s[length-1] must be the trailing dot.
1066 static UBool
1067 isASCIIOkBiDi(const UChar *s, int32_t length) {
1068     int32_t labelStart=0;
1069     for(int32_t i=0; i&lt;length; ++i) {
1070         UChar c=s[i];
1071         if(c==0x2e) {  // dot
1072             if(i&gt;labelStart) {
1073                 c=s[i-1];
1074                 if(!(0x61&lt;=c &amp;&amp; c&lt;=0x7a) &amp;&amp; !(0x30&lt;=c &amp;&amp; c&lt;=0x39)) {
1075                     // Last character in the label is not an L or EN.
1076                     return FALSE;
1077                 }
1078             }
1079             labelStart=i+1;
1080         } else if(i==labelStart) {
1081             if(!(0x61&lt;=c &amp;&amp; c&lt;=0x7a)) {
1082                 // First character in the label is not an L.
1083                 return FALSE;
1084             }
1085         } else {
1086             if(c&lt;=0x20 &amp;&amp; (c&gt;=0x1c || (9&lt;=c &amp;&amp; c&lt;=0xd))) {
1087                 // Intermediate character in the label is a B, S or WS.
1088                 return FALSE;
1089             }
1090         }
1091     }
1092     return TRUE;
1093 }
1094 
1095 // UTF-8 version, called for source ASCII prefix.
1096 // Can contain uppercase A-Z.
1097 // s[length-1] must be the trailing dot.
1098 static UBool
1099 isASCIIOkBiDi(const char *s, int32_t length) {
1100     int32_t labelStart=0;
1101     for(int32_t i=0; i&lt;length; ++i) {
1102         char c=s[i];
1103         if(c==0x2e) {  // dot
1104             if(i&gt;labelStart) {
1105                 c=s[i-1];
1106                 if(!(0x61&lt;=c &amp;&amp; c&lt;=0x7a) &amp;&amp; !(0x41&lt;=c &amp;&amp; c&lt;=0x5a) &amp;&amp; !(0x30&lt;=c &amp;&amp; c&lt;=0x39)) {
1107                     // Last character in the label is not an L or EN.
1108                     return FALSE;
1109                 }
1110             }
1111             labelStart=i+1;
1112         } else if(i==labelStart) {
1113             if(!(0x61&lt;=c &amp;&amp; c&lt;=0x7a) &amp;&amp; !(0x41&lt;=c &amp;&amp; c&lt;=0x5a)) {
1114                 // First character in the label is not an L.
1115                 return FALSE;
1116             }
1117         } else {
1118             if(c&lt;=0x20 &amp;&amp; (c&gt;=0x1c || (9&lt;=c &amp;&amp; c&lt;=0xd))) {
1119                 // Intermediate character in the label is a B, S or WS.
1120                 return FALSE;
1121             }
1122         }
1123     }
1124     return TRUE;
1125 }
1126 
1127 UBool
1128 UTS46::isLabelOkContextJ(const UChar *label, int32_t labelLength) const {
1129     // [IDNA2008-Tables]
1130     // 200C..200D  ; CONTEXTJ    # ZERO WIDTH NON-JOINER..ZERO WIDTH JOINER
1131     for(int32_t i=0; i&lt;labelLength; ++i) {
1132         if(label[i]==0x200c) {
1133             // Appendix A.1. ZERO WIDTH NON-JOINER
1134             // Rule Set:
1135             //  False;
1136             //  If Canonical_Combining_Class(Before(cp)) .eq.  Virama Then True;
1137             //  If RegExpMatch((Joining_Type:{L,D})(Joining_Type:T)*\u200C
1138             //     (Joining_Type:T)*(Joining_Type:{R,D})) Then True;
1139             if(i==0) {
1140                 return FALSE;
1141             }
1142             UChar32 c;
1143             int32_t j=i;
1144             U16_PREV_UNSAFE(label, j, c);
1145             if(uts46Norm2.getCombiningClass(c)==9) {
1146                 continue;
1147             }
1148             // check precontext (Joining_Type:{L,D})(Joining_Type:T)*
1149             for(;;) {
1150                 UJoiningType type=ubidi_getJoiningType(c);
1151                 if(type==U_JT_TRANSPARENT) {
1152                     if(j==0) {
1153                         return FALSE;
1154                     }
1155                     U16_PREV_UNSAFE(label, j, c);
1156                 } else if(type==U_JT_LEFT_JOINING || type==U_JT_DUAL_JOINING) {
1157                     break;  // precontext fulfilled
1158                 } else {
1159                     return FALSE;
1160                 }
1161             }
1162             // check postcontext (Joining_Type:T)*(Joining_Type:{R,D})
1163             for(j=i+1;;) {
1164                 if(j==labelLength) {
1165                     return FALSE;
1166                 }
1167                 U16_NEXT_UNSAFE(label, j, c);
1168                 UJoiningType type=ubidi_getJoiningType(c);
1169                 if(type==U_JT_TRANSPARENT) {
1170                     // just skip this character
1171                 } else if(type==U_JT_RIGHT_JOINING || type==U_JT_DUAL_JOINING) {
1172                     break;  // postcontext fulfilled
1173                 } else {
1174                     return FALSE;
1175                 }
1176             }
1177         } else if(label[i]==0x200d) {
1178             // Appendix A.2. ZERO WIDTH JOINER (U+200D)
1179             // Rule Set:
1180             //  False;
1181             //  If Canonical_Combining_Class(Before(cp)) .eq.  Virama Then True;
1182             if(i==0) {
1183                 return FALSE;
1184             }
1185             UChar32 c;
1186             int32_t j=i;
1187             U16_PREV_UNSAFE(label, j, c);
1188             if(uts46Norm2.getCombiningClass(c)!=9) {
1189                 return FALSE;
1190             }
1191         }
1192     }
1193     return TRUE;
1194 }
1195 
1196 void
1197 UTS46::checkLabelContextO(const UChar *label, int32_t labelLength, IDNAInfo &amp;info) const {
1198     int32_t labelEnd=labelLength-1;  // inclusive
1199     int32_t arabicDigits=0;  // -1 for 066x, +1 for 06Fx
1200     for(int32_t i=0; i&lt;=labelEnd; ++i) {
1201         UChar32 c=label[i];
1202         if(c&lt;0xb7) {
1203             // ASCII fastpath
1204         } else if(c&lt;=0x6f9) {
1205             if(c==0xb7) {
1206                 // Appendix A.3. MIDDLE DOT (U+00B7)
1207                 // Rule Set:
1208                 //  False;
1209                 //  If Before(cp) .eq.  U+006C And
1210                 //     After(cp) .eq.  U+006C Then True;
1211                 if(!(0&lt;i &amp;&amp; label[i-1]==0x6c &amp;&amp;
1212                      i&lt;labelEnd &amp;&amp; label[i+1]==0x6c)) {
1213                     info.labelErrors|=UIDNA_ERROR_CONTEXTO_PUNCTUATION;
1214                 }
1215             } else if(c==0x375) {
1216                 // Appendix A.4. GREEK LOWER NUMERAL SIGN (KERAIA) (U+0375)
1217                 // Rule Set:
1218                 //  False;
1219                 //  If Script(After(cp)) .eq.  Greek Then True;
1220                 UScriptCode script=USCRIPT_INVALID_CODE;
1221                 if(i&lt;labelEnd) {
1222                     UErrorCode errorCode=U_ZERO_ERROR;
1223                     int32_t j=i+1;
1224                     U16_NEXT(label, j, labelLength, c);
1225                     script=uscript_getScript(c, &amp;errorCode);
1226                 }
1227                 if(script!=USCRIPT_GREEK) {
1228                     info.labelErrors|=UIDNA_ERROR_CONTEXTO_PUNCTUATION;
1229                 }
1230             } else if(c==0x5f3 || c==0x5f4) {
1231                 // Appendix A.5. HEBREW PUNCTUATION GERESH (U+05F3)
1232                 // Rule Set:
1233                 //  False;
1234                 //  If Script(Before(cp)) .eq.  Hebrew Then True;
1235                 //
1236                 // Appendix A.6. HEBREW PUNCTUATION GERSHAYIM (U+05F4)
1237                 // Rule Set:
1238                 //  False;
1239                 //  If Script(Before(cp)) .eq.  Hebrew Then True;
1240                 UScriptCode script=USCRIPT_INVALID_CODE;
1241                 if(0&lt;i) {
1242                     UErrorCode errorCode=U_ZERO_ERROR;
1243                     int32_t j=i;
1244                     U16_PREV(label, 0, j, c);
1245                     script=uscript_getScript(c, &amp;errorCode);
1246                 }
1247                 if(script!=USCRIPT_HEBREW) {
1248                     info.labelErrors|=UIDNA_ERROR_CONTEXTO_PUNCTUATION;
1249                 }
1250             } else if(0x660&lt;=c /* &amp;&amp; c&lt;=0x6f9 */) {
1251                 // Appendix A.8. ARABIC-INDIC DIGITS (0660..0669)
1252                 // Rule Set:
1253                 //  True;
1254                 //  For All Characters:
1255                 //    If cp .in. 06F0..06F9 Then False;
1256                 //  End For;
1257                 //
1258                 // Appendix A.9. EXTENDED ARABIC-INDIC DIGITS (06F0..06F9)
1259                 // Rule Set:
1260                 //  True;
1261                 //  For All Characters:
1262                 //    If cp .in. 0660..0669 Then False;
1263                 //  End For;
1264                 if(c&lt;=0x669) {
1265                     if(arabicDigits&gt;0) {
1266                         info.labelErrors|=UIDNA_ERROR_CONTEXTO_DIGITS;
1267                     }
1268                     arabicDigits=-1;
1269                 } else if(0x6f0&lt;=c) {
1270                     if(arabicDigits&lt;0) {
1271                         info.labelErrors|=UIDNA_ERROR_CONTEXTO_DIGITS;
1272                     }
1273                     arabicDigits=1;
1274                 }
1275             }
1276         } else if(c==0x30fb) {
1277             // Appendix A.7. KATAKANA MIDDLE DOT (U+30FB)
1278             // Rule Set:
1279             //  False;
1280             //  For All Characters:
1281             //    If Script(cp) .in. {Hiragana, Katakana, Han} Then True;
1282             //  End For;
1283             UErrorCode errorCode=U_ZERO_ERROR;
1284             for(int j=0;;) {
1285                 if(j&gt;labelEnd) {
1286                     info.labelErrors|=UIDNA_ERROR_CONTEXTO_PUNCTUATION;
1287                     break;
1288                 }
1289                 U16_NEXT(label, j, labelLength, c);
1290                 UScriptCode script=uscript_getScript(c, &amp;errorCode);
1291                 if(script==USCRIPT_HIRAGANA || script==USCRIPT_KATAKANA || script==USCRIPT_HAN) {
1292                     break;
1293                 }
1294             }
1295         }
1296     }
1297 }
1298 
1299 U_NAMESPACE_END
1300 
1301 // C API ------------------------------------------------------------------- ***
1302 
1303 U_NAMESPACE_USE
1304 
1305 U_CAPI UIDNA * U_EXPORT2
1306 uidna_openUTS46(uint32_t options, UErrorCode *pErrorCode) {
1307     return reinterpret_cast&lt;UIDNA *&gt;(IDNA::createUTS46Instance(options, *pErrorCode));
1308 }
1309 
1310 U_CAPI void U_EXPORT2
1311 uidna_close(UIDNA *idna) {
1312     delete reinterpret_cast&lt;IDNA *&gt;(idna);
1313 }
1314 
1315 static UBool
1316 checkArgs(const void *label, int32_t length,
1317           void *dest, int32_t capacity,
1318           UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
1319     if(U_FAILURE(*pErrorCode)) {
1320         return FALSE;
1321     }
1322     // sizeof(UIDNAInfo)=16 in the first API version.
1323     if(pInfo==NULL || pInfo-&gt;size&lt;16) {
1324         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
1325         return FALSE;
1326     }
1327     if( (label==NULL ? length!=0 : length&lt;-1) ||
1328         (dest==NULL ? capacity!=0 : capacity&lt;0) ||
1329         (dest==label &amp;&amp; label!=NULL)
1330     ) {
1331         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
1332         return FALSE;
1333     }
1334     // Set all *pInfo bytes to 0 except for the size field itself.
1335     uprv_memset(&amp;pInfo-&gt;size+1, 0, pInfo-&gt;size-sizeof(pInfo-&gt;size));
1336     return TRUE;
1337 }
1338 
1339 static void
1340 idnaInfoToStruct(IDNAInfo &amp;info, UIDNAInfo *pInfo) {
1341     pInfo-&gt;isTransitionalDifferent=info.isTransitionalDifferent();
1342     pInfo-&gt;errors=info.getErrors();
1343 }
1344 
1345 U_CAPI int32_t U_EXPORT2
1346 uidna_labelToASCII(const UIDNA *idna,
1347                    const UChar *label, int32_t length,
1348                    UChar *dest, int32_t capacity,
1349                    UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
1350     if(!checkArgs(label, length, dest, capacity, pInfo, pErrorCode)) {
1351         return 0;
1352     }
1353     UnicodeString src((UBool)(length&lt;0), label, length);
1354     UnicodeString destString(dest, 0, capacity);
1355     IDNAInfo info;
1356     reinterpret_cast&lt;const IDNA *&gt;(idna)-&gt;labelToASCII(src, destString, info, *pErrorCode);
1357     idnaInfoToStruct(info, pInfo);
1358     return destString.extract(dest, capacity, *pErrorCode);
1359 }
1360 
1361 U_CAPI int32_t U_EXPORT2
1362 uidna_labelToUnicode(const UIDNA *idna,
1363                      const UChar *label, int32_t length,
1364                      UChar *dest, int32_t capacity,
1365                      UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
1366     if(!checkArgs(label, length, dest, capacity, pInfo, pErrorCode)) {
1367         return 0;
1368     }
1369     UnicodeString src((UBool)(length&lt;0), label, length);
1370     UnicodeString destString(dest, 0, capacity);
1371     IDNAInfo info;
1372     reinterpret_cast&lt;const IDNA *&gt;(idna)-&gt;labelToUnicode(src, destString, info, *pErrorCode);
1373     idnaInfoToStruct(info, pInfo);
1374     return destString.extract(dest, capacity, *pErrorCode);
1375 }
1376 
1377 U_CAPI int32_t U_EXPORT2
1378 uidna_nameToASCII(const UIDNA *idna,
1379                   const UChar *name, int32_t length,
1380                   UChar *dest, int32_t capacity,
1381                   UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
1382     if(!checkArgs(name, length, dest, capacity, pInfo, pErrorCode)) {
1383         return 0;
1384     }
1385     UnicodeString src((UBool)(length&lt;0), name, length);
1386     UnicodeString destString(dest, 0, capacity);
1387     IDNAInfo info;
1388     reinterpret_cast&lt;const IDNA *&gt;(idna)-&gt;nameToASCII(src, destString, info, *pErrorCode);
1389     idnaInfoToStruct(info, pInfo);
1390     return destString.extract(dest, capacity, *pErrorCode);
1391 }
1392 
1393 U_CAPI int32_t U_EXPORT2
1394 uidna_nameToUnicode(const UIDNA *idna,
1395                     const UChar *name, int32_t length,
1396                     UChar *dest, int32_t capacity,
1397                     UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
1398     if(!checkArgs(name, length, dest, capacity, pInfo, pErrorCode)) {
1399         return 0;
1400     }
1401     UnicodeString src((UBool)(length&lt;0), name, length);
1402     UnicodeString destString(dest, 0, capacity);
1403     IDNAInfo info;
1404     reinterpret_cast&lt;const IDNA *&gt;(idna)-&gt;nameToUnicode(src, destString, info, *pErrorCode);
1405     idnaInfoToStruct(info, pInfo);
1406     return destString.extract(dest, capacity, *pErrorCode);
1407 }
1408 
1409 U_CAPI int32_t U_EXPORT2
1410 uidna_labelToASCII_UTF8(const UIDNA *idna,
1411                         const char *label, int32_t length,
1412                         char *dest, int32_t capacity,
1413                         UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
1414     if(!checkArgs(label, length, dest, capacity, pInfo, pErrorCode)) {
1415         return 0;
1416     }
1417     StringPiece src(label, length&lt;0 ? static_cast&lt;int32_t&gt;(uprv_strlen(label)) : length);
1418     CheckedArrayByteSink sink(dest, capacity);
1419     IDNAInfo info;
1420     reinterpret_cast&lt;const IDNA *&gt;(idna)-&gt;labelToASCII_UTF8(src, sink, info, *pErrorCode);
1421     idnaInfoToStruct(info, pInfo);
1422     return u_terminateChars(dest, capacity, sink.NumberOfBytesAppended(), pErrorCode);
1423 }
1424 
1425 U_CAPI int32_t U_EXPORT2
1426 uidna_labelToUnicodeUTF8(const UIDNA *idna,
1427                          const char *label, int32_t length,
1428                          char *dest, int32_t capacity,
1429                          UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
1430     if(!checkArgs(label, length, dest, capacity, pInfo, pErrorCode)) {
1431         return 0;
1432     }
1433     StringPiece src(label, length&lt;0 ? static_cast&lt;int32_t&gt;(uprv_strlen(label)) : length);
1434     CheckedArrayByteSink sink(dest, capacity);
1435     IDNAInfo info;
1436     reinterpret_cast&lt;const IDNA *&gt;(idna)-&gt;labelToUnicodeUTF8(src, sink, info, *pErrorCode);
1437     idnaInfoToStruct(info, pInfo);
1438     return u_terminateChars(dest, capacity, sink.NumberOfBytesAppended(), pErrorCode);
1439 }
1440 
1441 U_CAPI int32_t U_EXPORT2
1442 uidna_nameToASCII_UTF8(const UIDNA *idna,
1443                        const char *name, int32_t length,
1444                        char *dest, int32_t capacity,
1445                        UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
1446     if(!checkArgs(name, length, dest, capacity, pInfo, pErrorCode)) {
1447         return 0;
1448     }
1449     StringPiece src(name, length&lt;0 ? static_cast&lt;int32_t&gt;(uprv_strlen(name)) : length);
1450     CheckedArrayByteSink sink(dest, capacity);
1451     IDNAInfo info;
1452     reinterpret_cast&lt;const IDNA *&gt;(idna)-&gt;nameToASCII_UTF8(src, sink, info, *pErrorCode);
1453     idnaInfoToStruct(info, pInfo);
1454     return u_terminateChars(dest, capacity, sink.NumberOfBytesAppended(), pErrorCode);
1455 }
1456 
1457 U_CAPI int32_t U_EXPORT2
1458 uidna_nameToUnicodeUTF8(const UIDNA *idna,
1459                         const char *name, int32_t length,
1460                         char *dest, int32_t capacity,
1461                         UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
1462     if(!checkArgs(name, length, dest, capacity, pInfo, pErrorCode)) {
1463         return 0;
1464     }
1465     StringPiece src(name, length&lt;0 ? static_cast&lt;int32_t&gt;(uprv_strlen(name)) : length);
1466     CheckedArrayByteSink sink(dest, capacity);
1467     IDNAInfo info;
1468     reinterpret_cast&lt;const IDNA *&gt;(idna)-&gt;nameToUnicodeUTF8(src, sink, info, *pErrorCode);
1469     idnaInfoToStruct(info, pInfo);
1470     return u_terminateChars(dest, capacity, sink.NumberOfBytesAppended(), pErrorCode);
1471 }
1472 
1473 #endif  // UCONFIG_NO_IDNA
    </pre>
  </body>
</html>