<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tznames.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="tzgnames.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="tznames_impl.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tznames.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12 #if !UCONFIG_NO_FORMATTING
 13 
 14 #include &quot;unicode/locid.h&quot;
 15 #include &quot;unicode/tznames.h&quot;
 16 #include &quot;unicode/uenum.h&quot;
 17 #include &quot;cmemory.h&quot;
 18 #include &quot;cstring.h&quot;
 19 #include &quot;mutex.h&quot;
 20 #include &quot;putilimp.h&quot;
 21 #include &quot;tznames_impl.h&quot;
 22 #include &quot;uassert.h&quot;
 23 #include &quot;ucln_in.h&quot;
 24 #include &quot;uhash.h&quot;
 25 #include &quot;umutex.h&quot;
 26 #include &quot;uvector.h&quot;
 27 
 28 
 29 U_NAMESPACE_BEGIN
 30 
 31 // TimeZoneNames object cache handling
<span class="line-modified"> 32 static UMutex gTimeZoneNamesLock = U_MUTEX_INITIALIZER;</span>



 33 static UHashtable *gTimeZoneNamesCache = NULL;
 34 static UBool gTimeZoneNamesCacheInitialized = FALSE;
 35 
 36 // Access count - incremented every time up to SWEEP_INTERVAL,
 37 // then reset to 0
 38 static int32_t gAccessCount = 0;
 39 
 40 // Interval for calling the cache sweep function - every 100 times
 41 #define SWEEP_INTERVAL 100
 42 
 43 // Cache expiration in millisecond. When a cached entry is no
 44 // longer referenced and exceeding this threshold since last
 45 // access time, then the cache entry will be deleted by the sweep
 46 // function. For now, 3 minutes.
 47 #define CACHE_EXPIRATION 180000.0
 48 
 49 typedef struct TimeZoneNamesCacheEntry {
 50     TimeZoneNames*  names;
 51     int32_t         refCount;
 52     double          lastAccess;
</pre>
<hr />
<pre>
 70  * Deleter for TimeZoneNamesCacheEntry
 71  */
 72 static void U_CALLCONV
 73 deleteTimeZoneNamesCacheEntry(void *obj) {
 74     icu::TimeZoneNamesCacheEntry *entry = (icu::TimeZoneNamesCacheEntry*)obj;
 75     delete (icu::TimeZoneNamesImpl*) entry-&gt;names;
 76     uprv_free(entry);
 77 }
 78 U_CDECL_END
 79 
 80 /**
 81  * Function used for removing unreferrenced cache entries exceeding
 82  * the expiration time. This function must be called with in the mutex
 83  * block.
 84  */
 85 static void sweepCache() {
 86     int32_t pos = UHASH_FIRST;
 87     const UHashElement* elem;
 88     double now = (double)uprv_getUTCtime();
 89 
<span class="line-modified"> 90     while ((elem = uhash_nextElement(gTimeZoneNamesCache, &amp;pos))) {</span>
 91         TimeZoneNamesCacheEntry *entry = (TimeZoneNamesCacheEntry *)elem-&gt;value.pointer;
 92         if (entry-&gt;refCount &lt;= 0 &amp;&amp; (now - entry-&gt;lastAccess) &gt; CACHE_EXPIRATION) {
 93             // delete this entry
 94             uhash_removeElement(gTimeZoneNamesCache, elem);
 95         }
 96     }
 97 }
 98 
 99 // ---------------------------------------------------
100 // TimeZoneNamesDelegate
101 // ---------------------------------------------------
102 class TimeZoneNamesDelegate : public TimeZoneNames {
103 public:
104     TimeZoneNamesDelegate(const Locale&amp; locale, UErrorCode&amp; status);
105     virtual ~TimeZoneNamesDelegate();
106 
107     virtual UBool operator==(const TimeZoneNames&amp; other) const;
<span class="line-modified">108     virtual UBool operator!=(const TimeZoneNames&amp; other) const {return !operator==(other);};</span>
109     virtual TimeZoneNames* clone() const;
110 
111     StringEnumeration* getAvailableMetaZoneIDs(UErrorCode&amp; status) const;
112     StringEnumeration* getAvailableMetaZoneIDs(const UnicodeString&amp; tzID, UErrorCode&amp; status) const;
113     UnicodeString&amp; getMetaZoneID(const UnicodeString&amp; tzID, UDate date, UnicodeString&amp; mzID) const;
114     UnicodeString&amp; getReferenceZoneID(const UnicodeString&amp; mzID, const char* region, UnicodeString&amp; tzID) const;
115 
116     UnicodeString&amp; getMetaZoneDisplayName(const UnicodeString&amp; mzID, UTimeZoneNameType type, UnicodeString&amp; name) const;
117     UnicodeString&amp; getTimeZoneDisplayName(const UnicodeString&amp; tzID, UTimeZoneNameType type, UnicodeString&amp; name) const;
118 
119     UnicodeString&amp; getExemplarLocationName(const UnicodeString&amp; tzID, UnicodeString&amp; name) const;
120 
121     void loadAllDisplayNames(UErrorCode&amp; status);
122     void getDisplayNames(const UnicodeString&amp; tzID, const UTimeZoneNameType types[], int32_t numTypes, UDate date, UnicodeString dest[], UErrorCode&amp; status) const;
123 
124     MatchInfoCollection* find(const UnicodeString&amp; text, int32_t start, uint32_t types, UErrorCode&amp; status) const;
125 private:
126     TimeZoneNamesDelegate();
127     TimeZoneNamesCacheEntry*    fTZnamesCacheEntry;
128 };
129 
130 TimeZoneNamesDelegate::TimeZoneNamesDelegate()
131 : fTZnamesCacheEntry(0) {
132 }
133 
134 TimeZoneNamesDelegate::TimeZoneNamesDelegate(const Locale&amp; locale, UErrorCode&amp; status) {
<span class="line-modified">135     Mutex lock(&amp;gTimeZoneNamesLock);</span>
136     if (!gTimeZoneNamesCacheInitialized) {
137         // Create empty hashtable if it is not already initialized.
138         gTimeZoneNamesCache = uhash_open(uhash_hashChars, uhash_compareChars, NULL, &amp;status);
139         if (U_SUCCESS(status)) {
140             uhash_setKeyDeleter(gTimeZoneNamesCache, uprv_free);
141             uhash_setValueDeleter(gTimeZoneNamesCache, deleteTimeZoneNamesCacheEntry);
142             gTimeZoneNamesCacheInitialized = TRUE;
143             ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONENAMES, timeZoneNames_cleanup);
144         }
145     }
146 
147     if (U_FAILURE(status)) {
148         return;
149     }
150 
151     // Check the cache, if not available, create new one and cache
152     TimeZoneNamesCacheEntry *cacheEntry = NULL;
153 
154     const char *key = locale.getName();
155     cacheEntry = (TimeZoneNamesCacheEntry *)uhash_get(gTimeZoneNamesCache, key);
</pre>
<hr />
<pre>
191             if (cacheEntry != NULL) {
192                 uprv_free(cacheEntry);
193             }
194             cacheEntry = NULL;
195         }
196     } else {
197         // Update the reference count
198         cacheEntry-&gt;refCount++;
199         cacheEntry-&gt;lastAccess = (double)uprv_getUTCtime();
200     }
201     gAccessCount++;
202     if (gAccessCount &gt;= SWEEP_INTERVAL) {
203         // sweep
204         sweepCache();
205         gAccessCount = 0;
206     }
207     fTZnamesCacheEntry = cacheEntry;
208 }
209 
210 TimeZoneNamesDelegate::~TimeZoneNamesDelegate() {
<span class="line-modified">211     umtx_lock(&amp;gTimeZoneNamesLock);</span>
212     {
213         if (fTZnamesCacheEntry) {
214             U_ASSERT(fTZnamesCacheEntry-&gt;refCount &gt; 0);
215             // Just decrement the reference count
216             fTZnamesCacheEntry-&gt;refCount--;
217         }
218     }
<span class="line-modified">219     umtx_unlock(&amp;gTimeZoneNamesLock);</span>
220 }
221 
222 UBool
223 TimeZoneNamesDelegate::operator==(const TimeZoneNames&amp; other) const {
224     if (this == &amp;other) {
225         return TRUE;
226     }
227     // Just compare if the other object also use the same
228     // cache entry
229     const TimeZoneNamesDelegate* rhs = dynamic_cast&lt;const TimeZoneNamesDelegate*&gt;(&amp;other);
230     if (rhs) {
231         return fTZnamesCacheEntry == rhs-&gt;fTZnamesCacheEntry;
232     }
233     return FALSE;
234 }
235 
236 TimeZoneNames*
237 TimeZoneNamesDelegate::clone() const {
238     TimeZoneNamesDelegate* other = new TimeZoneNamesDelegate();
239     if (other != NULL) {
<span class="line-modified">240         umtx_lock(&amp;gTimeZoneNamesLock);</span>
241         {
242             // Just increment the reference count
243             fTZnamesCacheEntry-&gt;refCount++;
244             other-&gt;fTZnamesCacheEntry = fTZnamesCacheEntry;
245         }
<span class="line-modified">246         umtx_unlock(&amp;gTimeZoneNamesLock);</span>
247     }
248     return other;
249 }
250 
251 StringEnumeration*
252 TimeZoneNamesDelegate::getAvailableMetaZoneIDs(UErrorCode&amp; status) const {
253     return fTZnamesCacheEntry-&gt;names-&gt;getAvailableMetaZoneIDs(status);
254 }
255 
256 StringEnumeration*
257 TimeZoneNamesDelegate::getAvailableMetaZoneIDs(const UnicodeString&amp; tzID, UErrorCode&amp; status) const {
258     return fTZnamesCacheEntry-&gt;names-&gt;getAvailableMetaZoneIDs(tzID, status);
259 }
260 
261 UnicodeString&amp;
262 TimeZoneNamesDelegate::getMetaZoneID(const UnicodeString&amp; tzID, UDate date, UnicodeString&amp; mzID) const {
263     return fTZnamesCacheEntry-&gt;names-&gt;getMetaZoneID(tzID, date, mzID);
264 }
265 
266 UnicodeString&amp;
</pre>
</td>
<td>
<hr />
<pre>
 12 #if !UCONFIG_NO_FORMATTING
 13 
 14 #include &quot;unicode/locid.h&quot;
 15 #include &quot;unicode/tznames.h&quot;
 16 #include &quot;unicode/uenum.h&quot;
 17 #include &quot;cmemory.h&quot;
 18 #include &quot;cstring.h&quot;
 19 #include &quot;mutex.h&quot;
 20 #include &quot;putilimp.h&quot;
 21 #include &quot;tznames_impl.h&quot;
 22 #include &quot;uassert.h&quot;
 23 #include &quot;ucln_in.h&quot;
 24 #include &quot;uhash.h&quot;
 25 #include &quot;umutex.h&quot;
 26 #include &quot;uvector.h&quot;
 27 
 28 
 29 U_NAMESPACE_BEGIN
 30 
 31 // TimeZoneNames object cache handling
<span class="line-modified"> 32 static UMutex *gTimeZoneNamesLock() {</span>
<span class="line-added"> 33     static UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added"> 34     return &amp;m;</span>
<span class="line-added"> 35 }</span>
 36 static UHashtable *gTimeZoneNamesCache = NULL;
 37 static UBool gTimeZoneNamesCacheInitialized = FALSE;
 38 
 39 // Access count - incremented every time up to SWEEP_INTERVAL,
 40 // then reset to 0
 41 static int32_t gAccessCount = 0;
 42 
 43 // Interval for calling the cache sweep function - every 100 times
 44 #define SWEEP_INTERVAL 100
 45 
 46 // Cache expiration in millisecond. When a cached entry is no
 47 // longer referenced and exceeding this threshold since last
 48 // access time, then the cache entry will be deleted by the sweep
 49 // function. For now, 3 minutes.
 50 #define CACHE_EXPIRATION 180000.0
 51 
 52 typedef struct TimeZoneNamesCacheEntry {
 53     TimeZoneNames*  names;
 54     int32_t         refCount;
 55     double          lastAccess;
</pre>
<hr />
<pre>
 73  * Deleter for TimeZoneNamesCacheEntry
 74  */
 75 static void U_CALLCONV
 76 deleteTimeZoneNamesCacheEntry(void *obj) {
 77     icu::TimeZoneNamesCacheEntry *entry = (icu::TimeZoneNamesCacheEntry*)obj;
 78     delete (icu::TimeZoneNamesImpl*) entry-&gt;names;
 79     uprv_free(entry);
 80 }
 81 U_CDECL_END
 82 
 83 /**
 84  * Function used for removing unreferrenced cache entries exceeding
 85  * the expiration time. This function must be called with in the mutex
 86  * block.
 87  */
 88 static void sweepCache() {
 89     int32_t pos = UHASH_FIRST;
 90     const UHashElement* elem;
 91     double now = (double)uprv_getUTCtime();
 92 
<span class="line-modified"> 93     while ((elem = uhash_nextElement(gTimeZoneNamesCache, &amp;pos)) != 0) {</span>
 94         TimeZoneNamesCacheEntry *entry = (TimeZoneNamesCacheEntry *)elem-&gt;value.pointer;
 95         if (entry-&gt;refCount &lt;= 0 &amp;&amp; (now - entry-&gt;lastAccess) &gt; CACHE_EXPIRATION) {
 96             // delete this entry
 97             uhash_removeElement(gTimeZoneNamesCache, elem);
 98         }
 99     }
100 }
101 
102 // ---------------------------------------------------
103 // TimeZoneNamesDelegate
104 // ---------------------------------------------------
105 class TimeZoneNamesDelegate : public TimeZoneNames {
106 public:
107     TimeZoneNamesDelegate(const Locale&amp; locale, UErrorCode&amp; status);
108     virtual ~TimeZoneNamesDelegate();
109 
110     virtual UBool operator==(const TimeZoneNames&amp; other) const;
<span class="line-modified">111     virtual UBool operator!=(const TimeZoneNames&amp; other) const {return !operator==(other);}</span>
112     virtual TimeZoneNames* clone() const;
113 
114     StringEnumeration* getAvailableMetaZoneIDs(UErrorCode&amp; status) const;
115     StringEnumeration* getAvailableMetaZoneIDs(const UnicodeString&amp; tzID, UErrorCode&amp; status) const;
116     UnicodeString&amp; getMetaZoneID(const UnicodeString&amp; tzID, UDate date, UnicodeString&amp; mzID) const;
117     UnicodeString&amp; getReferenceZoneID(const UnicodeString&amp; mzID, const char* region, UnicodeString&amp; tzID) const;
118 
119     UnicodeString&amp; getMetaZoneDisplayName(const UnicodeString&amp; mzID, UTimeZoneNameType type, UnicodeString&amp; name) const;
120     UnicodeString&amp; getTimeZoneDisplayName(const UnicodeString&amp; tzID, UTimeZoneNameType type, UnicodeString&amp; name) const;
121 
122     UnicodeString&amp; getExemplarLocationName(const UnicodeString&amp; tzID, UnicodeString&amp; name) const;
123 
124     void loadAllDisplayNames(UErrorCode&amp; status);
125     void getDisplayNames(const UnicodeString&amp; tzID, const UTimeZoneNameType types[], int32_t numTypes, UDate date, UnicodeString dest[], UErrorCode&amp; status) const;
126 
127     MatchInfoCollection* find(const UnicodeString&amp; text, int32_t start, uint32_t types, UErrorCode&amp; status) const;
128 private:
129     TimeZoneNamesDelegate();
130     TimeZoneNamesCacheEntry*    fTZnamesCacheEntry;
131 };
132 
133 TimeZoneNamesDelegate::TimeZoneNamesDelegate()
134 : fTZnamesCacheEntry(0) {
135 }
136 
137 TimeZoneNamesDelegate::TimeZoneNamesDelegate(const Locale&amp; locale, UErrorCode&amp; status) {
<span class="line-modified">138     Mutex lock(gTimeZoneNamesLock());</span>
139     if (!gTimeZoneNamesCacheInitialized) {
140         // Create empty hashtable if it is not already initialized.
141         gTimeZoneNamesCache = uhash_open(uhash_hashChars, uhash_compareChars, NULL, &amp;status);
142         if (U_SUCCESS(status)) {
143             uhash_setKeyDeleter(gTimeZoneNamesCache, uprv_free);
144             uhash_setValueDeleter(gTimeZoneNamesCache, deleteTimeZoneNamesCacheEntry);
145             gTimeZoneNamesCacheInitialized = TRUE;
146             ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONENAMES, timeZoneNames_cleanup);
147         }
148     }
149 
150     if (U_FAILURE(status)) {
151         return;
152     }
153 
154     // Check the cache, if not available, create new one and cache
155     TimeZoneNamesCacheEntry *cacheEntry = NULL;
156 
157     const char *key = locale.getName();
158     cacheEntry = (TimeZoneNamesCacheEntry *)uhash_get(gTimeZoneNamesCache, key);
</pre>
<hr />
<pre>
194             if (cacheEntry != NULL) {
195                 uprv_free(cacheEntry);
196             }
197             cacheEntry = NULL;
198         }
199     } else {
200         // Update the reference count
201         cacheEntry-&gt;refCount++;
202         cacheEntry-&gt;lastAccess = (double)uprv_getUTCtime();
203     }
204     gAccessCount++;
205     if (gAccessCount &gt;= SWEEP_INTERVAL) {
206         // sweep
207         sweepCache();
208         gAccessCount = 0;
209     }
210     fTZnamesCacheEntry = cacheEntry;
211 }
212 
213 TimeZoneNamesDelegate::~TimeZoneNamesDelegate() {
<span class="line-modified">214     umtx_lock(gTimeZoneNamesLock());</span>
215     {
216         if (fTZnamesCacheEntry) {
217             U_ASSERT(fTZnamesCacheEntry-&gt;refCount &gt; 0);
218             // Just decrement the reference count
219             fTZnamesCacheEntry-&gt;refCount--;
220         }
221     }
<span class="line-modified">222     umtx_unlock(gTimeZoneNamesLock());</span>
223 }
224 
225 UBool
226 TimeZoneNamesDelegate::operator==(const TimeZoneNames&amp; other) const {
227     if (this == &amp;other) {
228         return TRUE;
229     }
230     // Just compare if the other object also use the same
231     // cache entry
232     const TimeZoneNamesDelegate* rhs = dynamic_cast&lt;const TimeZoneNamesDelegate*&gt;(&amp;other);
233     if (rhs) {
234         return fTZnamesCacheEntry == rhs-&gt;fTZnamesCacheEntry;
235     }
236     return FALSE;
237 }
238 
239 TimeZoneNames*
240 TimeZoneNamesDelegate::clone() const {
241     TimeZoneNamesDelegate* other = new TimeZoneNamesDelegate();
242     if (other != NULL) {
<span class="line-modified">243         umtx_lock(gTimeZoneNamesLock());</span>
244         {
245             // Just increment the reference count
246             fTZnamesCacheEntry-&gt;refCount++;
247             other-&gt;fTZnamesCacheEntry = fTZnamesCacheEntry;
248         }
<span class="line-modified">249         umtx_unlock(gTimeZoneNamesLock());</span>
250     }
251     return other;
252 }
253 
254 StringEnumeration*
255 TimeZoneNamesDelegate::getAvailableMetaZoneIDs(UErrorCode&amp; status) const {
256     return fTZnamesCacheEntry-&gt;names-&gt;getAvailableMetaZoneIDs(status);
257 }
258 
259 StringEnumeration*
260 TimeZoneNamesDelegate::getAvailableMetaZoneIDs(const UnicodeString&amp; tzID, UErrorCode&amp; status) const {
261     return fTZnamesCacheEntry-&gt;names-&gt;getAvailableMetaZoneIDs(tzID, status);
262 }
263 
264 UnicodeString&amp;
265 TimeZoneNamesDelegate::getMetaZoneID(const UnicodeString&amp; tzID, UDate date, UnicodeString&amp; mzID) const {
266     return fTZnamesCacheEntry-&gt;names-&gt;getMetaZoneID(tzID, date, mzID);
267 }
268 
269 UnicodeString&amp;
</pre>
</td>
</tr>
</table>
<center><a href="tzgnames.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="tznames_impl.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>