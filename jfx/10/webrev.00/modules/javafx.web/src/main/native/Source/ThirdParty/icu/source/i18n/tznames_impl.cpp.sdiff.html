<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tznames_impl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="tznames.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ucln_in.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/tznames_impl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  32 #include &quot;ucln_in.h&quot;
  33 #include &quot;uvector.h&quot;
  34 #include &quot;olsontz.h&quot;
  35 
  36 U_NAMESPACE_BEGIN
  37 
  38 #define ZID_KEY_MAX  128
  39 #define MZ_PREFIX_LEN 5
  40 
  41 static const char gZoneStrings[]        = &quot;zoneStrings&quot;;
  42 static const char gMZPrefix[]           = &quot;meta:&quot;;
  43 
  44 static const char EMPTY[]               = &quot;&lt;empty&gt;&quot;;   // place holder for empty ZNames
  45 static const char DUMMY_LOADER[]        = &quot;&lt;dummy&gt;&quot;;   // place holder for dummy ZNamesLoader
  46 static const UChar NO_NAME[]            = { 0 };   // for empty no-fallback time zone names
  47 
  48 // stuff for TZDBTimeZoneNames
  49 static const char* TZDBNAMES_KEYS[]               = {&quot;ss&quot;, &quot;sd&quot;};
  50 static const int32_t TZDBNAMES_KEYS_SIZE = UPRV_LENGTHOF(TZDBNAMES_KEYS);
  51 
<span class="line-modified">  52 static UMutex gTZDBNamesMapLock = U_MUTEX_INITIALIZER;</span>
<span class="line-modified">  53 static UMutex gDataMutex = U_MUTEX_INITIALIZER;</span>


  54 
  55 static UHashtable* gTZDBNamesMap = NULL;
  56 static icu::UInitOnce gTZDBNamesMapInitOnce = U_INITONCE_INITIALIZER;
  57 
  58 static TextTrieMap* gTZDBNamesTrie = NULL;
  59 static icu::UInitOnce gTZDBNamesTrieInitOnce = U_INITONCE_INITIALIZER;
  60 
  61 // The order in which strings are stored may be different than the order in the public enum.
  62 enum UTimeZoneNameTypeIndex {
  63     UTZNM_INDEX_UNKNOWN = -1,
  64     UTZNM_INDEX_EXEMPLAR_LOCATION,
  65     UTZNM_INDEX_LONG_GENERIC,
  66     UTZNM_INDEX_LONG_STANDARD,
  67     UTZNM_INDEX_LONG_DAYLIGHT,
  68     UTZNM_INDEX_SHORT_GENERIC,
  69     UTZNM_INDEX_SHORT_STANDARD,
  70     UTZNM_INDEX_SHORT_DAYLIGHT,
  71     UTZNM_INDEX_COUNT
  72 };
  73 static const UChar* const EMPTY_NAMES[UTZNM_INDEX_COUNT] = {0,0,0,0,0,0,0};
</pre>
<hr />
<pre>
 340     return node;
 341 }
 342 
 343 CharacterNode*
 344 TextTrieMap::getChildNode(CharacterNode *parent, UChar c) const {
 345     // Linear search of the sorted list of children.
 346     uint16_t nodeIndex = parent-&gt;fFirstChild;
 347     while (nodeIndex &gt; 0) {
 348         CharacterNode *current = fNodes + nodeIndex;
 349         UChar childCharacter = current-&gt;fCharacter;
 350         if (childCharacter == c) {
 351             return current;
 352         } else if (childCharacter &gt; c) {
 353             break;
 354         }
 355         nodeIndex = current-&gt;fNextSibling;
 356     }
 357     return NULL;
 358 }
 359 
<span class="line-removed"> 360 // Mutex for protecting the lazy creation of the Trie node structure on the first call to search().</span>
<span class="line-removed"> 361 static UMutex TextTrieMutex = U_MUTEX_INITIALIZER;</span>
 362 
 363 // buildTrie() - The Trie node structure is needed.  Create it from the data that was
 364 //               saved at the time the ZoneStringFormatter was created.  The Trie is only
 365 //               needed for parsing operations, which are less common than formatting,
 366 //               and the Trie is big, which is why its creation is deferred until first use.
 367 void TextTrieMap::buildTrie(UErrorCode &amp;status) {
 368     if (fLazyContents != NULL) {
 369         for (int32_t i=0; i&lt;fLazyContents-&gt;size(); i+=2) {
 370             const UChar *key = (UChar *)fLazyContents-&gt;elementAt(i);
 371             void  *val = fLazyContents-&gt;elementAt(i+1);
 372             UnicodeString keyString(TRUE, key, -1);  // Aliasing UnicodeString constructor.
 373             putImpl(keyString, val, status);
 374         }
 375         delete fLazyContents;
 376         fLazyContents = NULL;
 377     }
 378 }
 379 
 380 void
 381 TextTrieMap::search(const UnicodeString &amp;text, int32_t start,




 389         Mutex lock(&amp;TextTrieMutex);
 390         if (fLazyContents != NULL) {
 391             TextTrieMap *nonConstThis = const_cast&lt;TextTrieMap *&gt;(this);
 392             nonConstThis-&gt;buildTrie(status);
 393         }
 394     }
 395     if (fNodes == NULL) {
 396         return;
 397     }
 398     search(fNodes, text, start, start, handler, status);
 399 }
 400 
 401 void
 402 TextTrieMap::search(CharacterNode *node, const UnicodeString &amp;text, int32_t start,
 403                   int32_t index, TextTrieMapSearchResultHandler *handler, UErrorCode &amp;status) const {
 404     if (U_FAILURE(status)) {
 405         return;
 406     }
 407     if (node-&gt;hasValues()) {
 408         if (!handler-&gt;handleMatch(index - start, node, status)) {
</pre>
<hr />
<pre>
1193 // static implementaion of getReferenceZoneID
1194 UnicodeString&amp;
1195 TimeZoneNamesImpl::_getReferenceZoneID(const UnicodeString&amp; mzID, const char* region, UnicodeString&amp; tzID) {
1196     ZoneMeta::getZoneIdByMetazone(mzID, UnicodeString(region, -1, US_INV), tzID);
1197     return tzID;
1198 }
1199 
1200 UnicodeString&amp;
1201 TimeZoneNamesImpl::getMetaZoneDisplayName(const UnicodeString&amp; mzID,
1202                                           UTimeZoneNameType type,
1203                                           UnicodeString&amp; name) const {
1204     name.setToBogus();  // cleanup result.
1205     if (mzID.isEmpty()) {
1206         return name;
1207     }
1208 
1209     ZNames *znames = NULL;
1210     TimeZoneNamesImpl *nonConstThis = const_cast&lt;TimeZoneNamesImpl *&gt;(this);
1211 
1212     {
<span class="line-modified">1213         Mutex lock(&amp;gDataMutex);</span>
1214         UErrorCode status = U_ZERO_ERROR;
1215         znames = nonConstThis-&gt;loadMetaZoneNames(mzID, status);
1216         if (U_FAILURE(status)) { return name; }
1217     }
1218 
1219     if (znames != NULL) {
1220         const UChar* s = znames-&gt;getName(type);
1221         if (s != NULL) {
1222             name.setTo(TRUE, s, -1);
1223         }
1224     }
1225     return name;
1226 }
1227 
1228 UnicodeString&amp;
1229 TimeZoneNamesImpl::getTimeZoneDisplayName(const UnicodeString&amp; tzID, UTimeZoneNameType type, UnicodeString&amp; name) const {
1230     name.setToBogus();  // cleanup result.
1231     if (tzID.isEmpty()) {
1232         return name;
1233     }
1234 
1235     ZNames *tznames = NULL;
1236     TimeZoneNamesImpl *nonConstThis = const_cast&lt;TimeZoneNamesImpl *&gt;(this);
1237 
1238     {
<span class="line-modified">1239         Mutex lock(&amp;gDataMutex);</span>
1240         UErrorCode status = U_ZERO_ERROR;
1241         tznames = nonConstThis-&gt;loadTimeZoneNames(tzID, status);
1242         if (U_FAILURE(status)) { return name; }
1243     }
1244 
1245     if (tznames != NULL) {
1246         const UChar *s = tznames-&gt;getName(type);
1247         if (s != NULL) {
1248             name.setTo(TRUE, s, -1);
1249         }
1250     }
1251     return name;
1252 }
1253 
1254 UnicodeString&amp;
1255 TimeZoneNamesImpl::getExemplarLocationName(const UnicodeString&amp; tzID, UnicodeString&amp; name) const {
1256     name.setToBogus();  // cleanup result.
1257     const UChar* locName = NULL;
1258     ZNames *tznames = NULL;
1259     TimeZoneNamesImpl *nonConstThis = const_cast&lt;TimeZoneNamesImpl *&gt;(this);
1260 
1261     {
<span class="line-modified">1262         Mutex lock(&amp;gDataMutex);</span>
1263         UErrorCode status = U_ZERO_ERROR;
1264         tznames = nonConstThis-&gt;loadTimeZoneNames(tzID, status);
1265         if (U_FAILURE(status)) { return name; }
1266     }
1267 
1268     if (tznames != NULL) {
1269         locName = tznames-&gt;getName(UTZNM_EXEMPLAR_LOCATION);
1270     }
1271     if (locName != NULL) {
1272         name.setTo(TRUE, locName, -1);
1273     }
1274 
1275     return name;
1276 }
1277 
1278 
1279 // Merge the MZ_PREFIX and mzId
1280 static void mergeTimeZoneKey(const UnicodeString&amp; mzID, char* result) {
1281     if (mzID.isEmpty()) {
1282         result[0] = &#39;\0&#39;;
1283         return;
1284     }
1285 
1286     char mzIdChar[ZID_KEY_MAX + 1];
1287     int32_t keyLen;
<span class="line-modified">1288     int32_t prefixLen = uprv_strlen(gMZPrefix);</span>
1289     keyLen = mzID.extract(0, mzID.length(), mzIdChar, ZID_KEY_MAX + 1, US_INV);
1290     uprv_memcpy((void *)result, (void *)gMZPrefix, prefixLen);
1291     uprv_memcpy((void *)(result + prefixLen), (void *)mzIdChar, keyLen);
1292     result[keyLen + prefixLen] = &#39;\0&#39;;
1293 }
1294 
1295 /*
1296  * This method updates the cache and must be called with a lock
1297  */
1298 ZNames*
1299 TimeZoneNamesImpl::loadMetaZoneNames(const UnicodeString&amp; mzID, UErrorCode&amp; status) {
1300     if (U_FAILURE(status)) { return NULL; }
1301     U_ASSERT(mzID.length() &lt;= ZID_KEY_MAX - MZ_PREFIX_LEN);
1302 
1303     UChar mzIDKey[ZID_KEY_MAX + 1];
1304     mzID.extract(mzIDKey, ZID_KEY_MAX + 1, status);
1305     U_ASSERT(U_SUCCESS(status));   // already checked length above
1306     mzIDKey[mzID.length()] = 0;
1307 
1308     void* mznames = uhash_get(fMZNamesMap, mzIDKey);
</pre>
<hr />
<pre>
1337     if (tznames == NULL) {
1338         ZNames::ZNamesLoader loader;
1339         loader.loadTimeZone(fZoneStrings, tzID, status);
1340         tznames = ZNames::createTimeZoneAndPutInCache(fTZNamesMap, loader.getNames(), tzID, status);
1341         if (U_FAILURE(status)) { return NULL; }
1342     }
1343 
1344     // tznames is never EMPTY
1345     return (ZNames*)tznames;
1346 }
1347 
1348 TimeZoneNames::MatchInfoCollection*
1349 TimeZoneNamesImpl::find(const UnicodeString&amp; text, int32_t start, uint32_t types, UErrorCode&amp; status) const {
1350     ZNameSearchHandler handler(types);
1351     TimeZoneNames::MatchInfoCollection* matches;
1352     TimeZoneNamesImpl* nonConstThis = const_cast&lt;TimeZoneNamesImpl*&gt;(this);
1353 
1354     // Synchronize so that data is not loaded multiple times.
1355     // TODO: Consider more fine-grained synchronization.
1356     {
<span class="line-modified">1357         Mutex lock(&amp;gDataMutex);</span>
1358 
1359         // First try of lookup.
1360         matches = doFind(handler, text, start, status);
1361         if (U_FAILURE(status)) { return NULL; }
1362         if (matches != NULL) {
1363             return matches;
1364         }
1365 
1366         // All names are not yet loaded into the trie.
1367         // We may have loaded names for formatting several time zones,
1368         // and might be parsing one of those.
1369         // Populate the parsing trie from all of the already-loaded names.
1370         nonConstThis-&gt;addAllNamesIntoTrie(status);
1371 
1372         // Second try of lookup.
1373         matches = doFind(handler, text, start, status);
1374         if (U_FAILURE(status)) { return NULL; }
1375         if (matches != NULL) {
1376             return matches;
1377         }
</pre>
<hr />
<pre>
1436     if (obj == DUMMY_LOADER) { return; }
1437     const ZNames::ZNamesLoader* loader = (const ZNames::ZNamesLoader*) obj;
1438     delete loader;
1439 }
1440 U_CDECL_END
1441 
1442 struct TimeZoneNamesImpl::ZoneStringsLoader : public ResourceSink {
1443     TimeZoneNamesImpl&amp; tzn;
1444     UHashtable* keyToLoader;
1445 
1446     ZoneStringsLoader(TimeZoneNamesImpl&amp; _tzn, UErrorCode&amp; status)
1447             : tzn(_tzn) {
1448         keyToLoader = uhash_open(uhash_hashChars, uhash_compareChars, NULL, &amp;status);
1449         if (U_FAILURE(status)) { return; }
1450         uhash_setKeyDeleter(keyToLoader, uprv_free);
1451         uhash_setValueDeleter(keyToLoader, deleteZNamesLoader);
1452     }
1453     virtual ~ZoneStringsLoader();
1454 
1455     void* createKey(const char* key, UErrorCode&amp; status) {
<span class="line-modified">1456         int32_t len = sizeof(char) * (uprv_strlen(key) + 1);</span>
1457         char* newKey = (char*) uprv_malloc(len);
1458         if (newKey == NULL) {
1459             status = U_MEMORY_ALLOCATION_ERROR;
1460             return NULL;
1461         }
1462         uprv_memcpy(newKey, key, len);
1463         newKey[len-1] = &#39;\0&#39;;
1464         return (void*) newKey;
1465     }
1466 
1467     UBool isMetaZone(const char* key) {
1468         return (uprv_strlen(key) &gt;= MZ_PREFIX_LEN &amp;&amp; uprv_memcmp(key, gMZPrefix, MZ_PREFIX_LEN) == 0);
1469     }
1470 
1471     UnicodeString mzIDFromKey(const char* key) {
<span class="line-modified">1472         return UnicodeString(key + MZ_PREFIX_LEN, uprv_strlen(key) - MZ_PREFIX_LEN, US_INV);</span>
1473     }
1474 
1475     UnicodeString tzIDFromKey(const char* key) {
1476         UnicodeString tzID(key, -1, US_INV);
1477         // Replace all colons &#39;:&#39; with slashes &#39;/&#39;
1478         for (int i=0; i&lt;tzID.length(); i++) {
1479             if (tzID.charAt(i) == 0x003A) {
1480                 tzID.setCharAt(i, 0x002F);
1481             }
1482         }
1483         return tzID;
1484     }
1485 
1486     void load(UErrorCode&amp; status) {
1487         ures_getAllItemsWithFallback(tzn.fZoneStrings, &quot;&quot;, *this, status);
1488         if (U_FAILURE(status)) { return; }
1489 
1490         int32_t pos = UHASH_FIRST;
1491         const UHashElement* element;
1492         while ((element = uhash_nextElement(keyToLoader, &amp;pos)) != NULL) {
</pre>
<hr />
<pre>
1564             if (value.getType() == URES_TABLE) {
1565                 consumeNamesTable(key, value, noFallback, status);
1566             } else {
1567                 // Ignore fields that aren&#39;t tables (e.g., fallbackFormat and regionFormatStandard).
1568                 // All time zone fields are tables.
1569             }
1570             if (U_FAILURE(status)) { return; }
1571         }
1572     }
1573 };
1574 
1575 // Virtual destructors must be defined out of line.
1576 TimeZoneNamesImpl::ZoneStringsLoader::~ZoneStringsLoader() {
1577     uhash_close(keyToLoader);
1578 }
1579 
1580 void TimeZoneNamesImpl::loadAllDisplayNames(UErrorCode&amp; status) {
1581     if (U_FAILURE(status)) return;
1582 
1583     {
<span class="line-modified">1584         Mutex lock(&amp;gDataMutex);</span>
1585         internalLoadAllDisplayNames(status);
1586     }
1587 }
1588 
1589 void TimeZoneNamesImpl::getDisplayNames(const UnicodeString&amp; tzID,
1590         const UTimeZoneNameType types[], int32_t numTypes,
1591         UDate date, UnicodeString dest[], UErrorCode&amp; status) const {
1592     if (U_FAILURE(status)) return;
1593 
1594     if (tzID.isEmpty()) { return; }
1595     void* tznames = NULL;
1596     void* mznames = NULL;
1597     TimeZoneNamesImpl *nonConstThis = const_cast&lt;TimeZoneNamesImpl*&gt;(this);
1598 
1599     // Load the time zone strings
1600     {
<span class="line-modified">1601         Mutex lock(&amp;gDataMutex);</span>
1602         tznames = (void*) nonConstThis-&gt;loadTimeZoneNames(tzID, status);
1603         if (U_FAILURE(status)) { return; }
1604     }
1605     U_ASSERT(tznames != NULL);
1606 
1607     // Load the values into the dest array
1608     for (int i = 0; i &lt; numTypes; i++) {
1609         UTimeZoneNameType type = types[i];
1610         const UChar* name = ((ZNames*)tznames)-&gt;getName(type);
1611         if (name == NULL) {
1612             if (mznames == NULL) {
1613                 // Load the meta zone name
1614                 UnicodeString mzID;
1615                 getMetaZoneID(tzID, date, mzID);
1616                 if (mzID.isEmpty()) {
1617                     mznames = (void*) EMPTY;
1618                 } else {
1619                     // Load the meta zone strings
1620                     // Mutex is scoped to the &quot;else&quot; statement
<span class="line-modified">1621                     Mutex lock(&amp;gDataMutex);</span>
1622                     mznames = (void*) nonConstThis-&gt;loadMetaZoneNames(mzID, status);
1623                     if (U_FAILURE(status)) { return; }
1624                     // Note: when the metazone doesn&#39;t exist, in Java, loadMetaZoneNames returns
1625                     // a dummy object instead of NULL.
1626                     if (mznames == NULL) {
1627                         mznames = (void*) EMPTY;
1628                     }
1629                 }
1630             }
1631             U_ASSERT(mznames != NULL);
1632             if (mznames != EMPTY) {
1633                 name = ((ZNames*)mznames)-&gt;getName(type);
1634             }
1635         }
1636         if (name != NULL) {
1637             dest[i].setTo(TRUE, name, -1);
1638         } else {
1639             dest[i].setToBogus();
1640         }
1641     }
</pre>
<hr />
<pre>
1927                 // Some tz database abbreviations are ambiguous. For example,
1928                 // CST means either Central Standard Time or China Standard Time.
1929                 // Unlike CLDR time zone display names, this implementation
1930                 // does not use unique names. And TimeZoneFormat does not expect
1931                 // multiple results returned for the same time zone type.
1932                 // For this reason, this implementation resolve one among same
1933                 // zone type with a same name at this level.
1934                 if (ninfo-&gt;parseRegions == NULL) {
1935                     // parseRegions == null means this is the default metazone
1936                     // mapping for the abbreviation.
1937                     if (defaultRegionMatch == NULL) {
1938                         match = defaultRegionMatch = ninfo;
1939                     }
1940                 } else {
1941                     UBool matchRegion = FALSE;
1942                     // non-default metazone mapping for an abbreviation
1943                     // comes with applicable regions. For example, the default
1944                     // metazone mapping for &quot;CST&quot; is America_Central,
1945                     // but if region is one of CN/MO/TW, &quot;CST&quot; is parsed
1946                     // as metazone China (China Standard Time).
<span class="line-modified">1947                     for (int32_t i = 0; i &lt; ninfo-&gt;nRegions; i++) {</span>
<span class="line-modified">1948                         const char *region = ninfo-&gt;parseRegions[i];</span>
1949                         if (uprv_strcmp(fRegion, region) == 0) {
1950                             match = ninfo;
1951                             matchRegion = TRUE;
1952                             break;
1953                         }
1954                     }
1955                     if (matchRegion) {
1956                         break;
1957                     }
1958                     if (match == NULL) {
1959                         match = ninfo;
1960                     }
1961                 }
1962             }
1963         }
1964 
1965         if (match != NULL) {
1966             UTimeZoneNameType ntype = match-&gt;type;
1967             // Note: Workaround for duplicated standard/daylight names
1968             // The tz database contains a few zones sharing a
</pre>
<hr />
<pre>
2042 static void U_CALLCONV
2043 deleteTZDBNameInfo(void *obj) {
2044     if (obj != NULL) {
2045         uprv_free(obj);
2046     }
2047 }
2048 
2049 static void U_CALLCONV prepareFind(UErrorCode &amp;status) {
2050     if (U_FAILURE(status)) {
2051         return;
2052     }
2053     gTZDBNamesTrie = new TextTrieMap(TRUE, deleteTZDBNameInfo);
2054     if (gTZDBNamesTrie == NULL) {
2055         status = U_MEMORY_ALLOCATION_ERROR;
2056         return;
2057     }
2058 
2059     const UnicodeString *mzID;
2060     StringEnumeration *mzIDs = TimeZoneNamesImpl::_getAvailableMetaZoneIDs(status);
2061     if (U_SUCCESS(status)) {
<span class="line-modified">2062         while ((mzID = mzIDs-&gt;snext(status)) &amp;&amp; U_SUCCESS(status)) {</span>
2063             const TZDBNames *names = TZDBTimeZoneNames::getMetaZoneNames(*mzID, status);
2064             if (U_FAILURE(status)) {
2065                 break;
2066             }
2067             if (names == NULL) {
2068                 continue;
2069             }
2070             const UChar *std = names-&gt;getName(UTZNM_SHORT_STANDARD);
2071             const UChar *dst = names-&gt;getName(UTZNM_SHORT_DAYLIGHT);
2072             if (std == NULL &amp;&amp; dst == NULL) {
2073                 continue;
2074             }
2075             int32_t numRegions = 0;
2076             const char **parseRegions = names-&gt;getParseRegions(numRegions);
2077 
2078             // The tz database contains a few zones sharing a
2079             // same name for both standard time and daylight saving
2080             // time. For example, Australia/Sydney observes DST,
2081             // but &quot;EST&quot; is used for both standard and daylight.
2082             // we need to store the information for later processing.
</pre>
<hr />
<pre>
2111             }
2112         }
2113     }
2114     delete mzIDs;
2115 
2116     if (U_FAILURE(status)) {
2117         delete gTZDBNamesTrie;
2118         gTZDBNamesTrie = NULL;
2119         return;
2120     }
2121 
2122     ucln_i18n_registerCleanup(UCLN_I18N_TZDBTIMEZONENAMES, tzdbTimeZoneNames_cleanup);
2123 }
2124 
2125 U_CDECL_END
2126 
2127 TZDBTimeZoneNames::TZDBTimeZoneNames(const Locale&amp; locale)
2128 : fLocale(locale) {
2129     UBool useWorld = TRUE;
2130     const char* region = fLocale.getCountry();
<span class="line-modified">2131     int32_t regionLen = uprv_strlen(region);</span>
2132     if (regionLen == 0) {
2133         UErrorCode status = U_ZERO_ERROR;
2134         char loc[ULOC_FULLNAME_CAPACITY];
2135         uloc_addLikelySubtags(fLocale.getName(), loc, sizeof(loc), &amp;status);
2136         regionLen = uloc_getCountry(loc, fRegion, sizeof(fRegion), &amp;status);
2137         if (U_SUCCESS(status) &amp;&amp; regionLen &lt; (int32_t)sizeof(fRegion)) {
2138             useWorld = FALSE;
2139         }
2140     } else if (regionLen &lt; (int32_t)sizeof(fRegion)) {
2141         uprv_strcpy(fRegion, region);
2142         useWorld = FALSE;
2143     }
2144     if (useWorld) {
2145         uprv_strcpy(fRegion, &quot;001&quot;);
2146     }
2147 }
2148 
2149 TZDBTimeZoneNames::~TZDBTimeZoneNames() {
2150 }
2151 
</pre>
<hr />
<pre>
2226         return NULL;
2227     }
2228     int32_t maxLen = 0;
2229     return handler.getMatches(maxLen);
2230 }
2231 
2232 const TZDBNames*
2233 TZDBTimeZoneNames::getMetaZoneNames(const UnicodeString&amp; mzID, UErrorCode&amp; status) {
2234     umtx_initOnce(gTZDBNamesMapInitOnce, &amp;initTZDBNamesMap, status);
2235     if (U_FAILURE(status)) {
2236         return NULL;
2237     }
2238 
2239     TZDBNames* tzdbNames = NULL;
2240 
2241     UChar mzIDKey[ZID_KEY_MAX + 1];
2242     mzID.extract(mzIDKey, ZID_KEY_MAX + 1, status);
2243     U_ASSERT(status == U_ZERO_ERROR);   // already checked length above
2244     mzIDKey[mzID.length()] = 0;
2245 

2246     umtx_lock(&amp;gTZDBNamesMapLock);
2247     {
2248         void *cacheVal = uhash_get(gTZDBNamesMap, mzIDKey);
2249         if (cacheVal == NULL) {
2250             UResourceBundle *zoneStringsRes = ures_openDirect(U_ICUDATA_ZONE, &quot;tzdbNames&quot;, &amp;status);
2251             zoneStringsRes = ures_getByKey(zoneStringsRes, gZoneStrings, zoneStringsRes, &amp;status);
2252             if (U_SUCCESS(status)) {
2253                 char key[ZID_KEY_MAX + 1];
2254                 mergeTimeZoneKey(mzID, key);
2255                 tzdbNames = TZDBNames::createInstance(zoneStringsRes, key);
2256 
2257                 if (tzdbNames == NULL) {
2258                     cacheVal = (void *)EMPTY;
2259                 } else {
2260                     cacheVal = tzdbNames;
2261                 }
2262                 // Use the persistent ID as the resource key, so we can
2263                 // avoid duplications.
2264                 // TODO: Is there a more efficient way, like intern() in Java?
2265                 void* newKey = (void*) ZoneMeta::findMetaZoneID(mzID);
</pre>
</td>
<td>
<hr />
<pre>
  32 #include &quot;ucln_in.h&quot;
  33 #include &quot;uvector.h&quot;
  34 #include &quot;olsontz.h&quot;
  35 
  36 U_NAMESPACE_BEGIN
  37 
  38 #define ZID_KEY_MAX  128
  39 #define MZ_PREFIX_LEN 5
  40 
  41 static const char gZoneStrings[]        = &quot;zoneStrings&quot;;
  42 static const char gMZPrefix[]           = &quot;meta:&quot;;
  43 
  44 static const char EMPTY[]               = &quot;&lt;empty&gt;&quot;;   // place holder for empty ZNames
  45 static const char DUMMY_LOADER[]        = &quot;&lt;dummy&gt;&quot;;   // place holder for dummy ZNamesLoader
  46 static const UChar NO_NAME[]            = { 0 };   // for empty no-fallback time zone names
  47 
  48 // stuff for TZDBTimeZoneNames
  49 static const char* TZDBNAMES_KEYS[]               = {&quot;ss&quot;, &quot;sd&quot;};
  50 static const int32_t TZDBNAMES_KEYS_SIZE = UPRV_LENGTHOF(TZDBNAMES_KEYS);
  51 
<span class="line-modified">  52 static UMutex *gDataMutex() {</span>
<span class="line-modified">  53     static UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added">  54     return &amp;m;</span>
<span class="line-added">  55 }</span>
  56 
  57 static UHashtable* gTZDBNamesMap = NULL;
  58 static icu::UInitOnce gTZDBNamesMapInitOnce = U_INITONCE_INITIALIZER;
  59 
  60 static TextTrieMap* gTZDBNamesTrie = NULL;
  61 static icu::UInitOnce gTZDBNamesTrieInitOnce = U_INITONCE_INITIALIZER;
  62 
  63 // The order in which strings are stored may be different than the order in the public enum.
  64 enum UTimeZoneNameTypeIndex {
  65     UTZNM_INDEX_UNKNOWN = -1,
  66     UTZNM_INDEX_EXEMPLAR_LOCATION,
  67     UTZNM_INDEX_LONG_GENERIC,
  68     UTZNM_INDEX_LONG_STANDARD,
  69     UTZNM_INDEX_LONG_DAYLIGHT,
  70     UTZNM_INDEX_SHORT_GENERIC,
  71     UTZNM_INDEX_SHORT_STANDARD,
  72     UTZNM_INDEX_SHORT_DAYLIGHT,
  73     UTZNM_INDEX_COUNT
  74 };
  75 static const UChar* const EMPTY_NAMES[UTZNM_INDEX_COUNT] = {0,0,0,0,0,0,0};
</pre>
<hr />
<pre>
 342     return node;
 343 }
 344 
 345 CharacterNode*
 346 TextTrieMap::getChildNode(CharacterNode *parent, UChar c) const {
 347     // Linear search of the sorted list of children.
 348     uint16_t nodeIndex = parent-&gt;fFirstChild;
 349     while (nodeIndex &gt; 0) {
 350         CharacterNode *current = fNodes + nodeIndex;
 351         UChar childCharacter = current-&gt;fCharacter;
 352         if (childCharacter == c) {
 353             return current;
 354         } else if (childCharacter &gt; c) {
 355             break;
 356         }
 357         nodeIndex = current-&gt;fNextSibling;
 358     }
 359     return NULL;
 360 }
 361 


 362 
 363 // buildTrie() - The Trie node structure is needed.  Create it from the data that was
 364 //               saved at the time the ZoneStringFormatter was created.  The Trie is only
 365 //               needed for parsing operations, which are less common than formatting,
 366 //               and the Trie is big, which is why its creation is deferred until first use.
 367 void TextTrieMap::buildTrie(UErrorCode &amp;status) {
 368     if (fLazyContents != NULL) {
 369         for (int32_t i=0; i&lt;fLazyContents-&gt;size(); i+=2) {
 370             const UChar *key = (UChar *)fLazyContents-&gt;elementAt(i);
 371             void  *val = fLazyContents-&gt;elementAt(i+1);
 372             UnicodeString keyString(TRUE, key, -1);  // Aliasing UnicodeString constructor.
 373             putImpl(keyString, val, status);
 374         }
 375         delete fLazyContents;
 376         fLazyContents = NULL;
 377     }
 378 }
 379 
 380 void
 381 TextTrieMap::search(const UnicodeString &amp;text, int32_t start,
<span class="line-added"> 389 </span>
<span class="line-added"> 390         // Mutex for protecting the lazy creation of the Trie node structure on the first call to search().</span>
<span class="line-added"> 391         static UMutex TextTrieMutex = U_MUTEX_INITIALIZER;</span>
<span class="line-added"> 392 </span>
 393         Mutex lock(&amp;TextTrieMutex);
 394         if (fLazyContents != NULL) {
 395             TextTrieMap *nonConstThis = const_cast&lt;TextTrieMap *&gt;(this);
 396             nonConstThis-&gt;buildTrie(status);
 397         }
 398     }
 399     if (fNodes == NULL) {
 400         return;
 401     }
 402     search(fNodes, text, start, start, handler, status);
 403 }
 404 
 405 void
 406 TextTrieMap::search(CharacterNode *node, const UnicodeString &amp;text, int32_t start,
 407                   int32_t index, TextTrieMapSearchResultHandler *handler, UErrorCode &amp;status) const {
 408     if (U_FAILURE(status)) {
 409         return;
 410     }
 411     if (node-&gt;hasValues()) {
 412         if (!handler-&gt;handleMatch(index - start, node, status)) {
</pre>
<hr />
<pre>
1197 // static implementaion of getReferenceZoneID
1198 UnicodeString&amp;
1199 TimeZoneNamesImpl::_getReferenceZoneID(const UnicodeString&amp; mzID, const char* region, UnicodeString&amp; tzID) {
1200     ZoneMeta::getZoneIdByMetazone(mzID, UnicodeString(region, -1, US_INV), tzID);
1201     return tzID;
1202 }
1203 
1204 UnicodeString&amp;
1205 TimeZoneNamesImpl::getMetaZoneDisplayName(const UnicodeString&amp; mzID,
1206                                           UTimeZoneNameType type,
1207                                           UnicodeString&amp; name) const {
1208     name.setToBogus();  // cleanup result.
1209     if (mzID.isEmpty()) {
1210         return name;
1211     }
1212 
1213     ZNames *znames = NULL;
1214     TimeZoneNamesImpl *nonConstThis = const_cast&lt;TimeZoneNamesImpl *&gt;(this);
1215 
1216     {
<span class="line-modified">1217         Mutex lock(gDataMutex());</span>
1218         UErrorCode status = U_ZERO_ERROR;
1219         znames = nonConstThis-&gt;loadMetaZoneNames(mzID, status);
1220         if (U_FAILURE(status)) { return name; }
1221     }
1222 
1223     if (znames != NULL) {
1224         const UChar* s = znames-&gt;getName(type);
1225         if (s != NULL) {
1226             name.setTo(TRUE, s, -1);
1227         }
1228     }
1229     return name;
1230 }
1231 
1232 UnicodeString&amp;
1233 TimeZoneNamesImpl::getTimeZoneDisplayName(const UnicodeString&amp; tzID, UTimeZoneNameType type, UnicodeString&amp; name) const {
1234     name.setToBogus();  // cleanup result.
1235     if (tzID.isEmpty()) {
1236         return name;
1237     }
1238 
1239     ZNames *tznames = NULL;
1240     TimeZoneNamesImpl *nonConstThis = const_cast&lt;TimeZoneNamesImpl *&gt;(this);
1241 
1242     {
<span class="line-modified">1243         Mutex lock(gDataMutex());</span>
1244         UErrorCode status = U_ZERO_ERROR;
1245         tznames = nonConstThis-&gt;loadTimeZoneNames(tzID, status);
1246         if (U_FAILURE(status)) { return name; }
1247     }
1248 
1249     if (tznames != NULL) {
1250         const UChar *s = tznames-&gt;getName(type);
1251         if (s != NULL) {
1252             name.setTo(TRUE, s, -1);
1253         }
1254     }
1255     return name;
1256 }
1257 
1258 UnicodeString&amp;
1259 TimeZoneNamesImpl::getExemplarLocationName(const UnicodeString&amp; tzID, UnicodeString&amp; name) const {
1260     name.setToBogus();  // cleanup result.
1261     const UChar* locName = NULL;
1262     ZNames *tznames = NULL;
1263     TimeZoneNamesImpl *nonConstThis = const_cast&lt;TimeZoneNamesImpl *&gt;(this);
1264 
1265     {
<span class="line-modified">1266         Mutex lock(gDataMutex());</span>
1267         UErrorCode status = U_ZERO_ERROR;
1268         tznames = nonConstThis-&gt;loadTimeZoneNames(tzID, status);
1269         if (U_FAILURE(status)) { return name; }
1270     }
1271 
1272     if (tznames != NULL) {
1273         locName = tznames-&gt;getName(UTZNM_EXEMPLAR_LOCATION);
1274     }
1275     if (locName != NULL) {
1276         name.setTo(TRUE, locName, -1);
1277     }
1278 
1279     return name;
1280 }
1281 
1282 
1283 // Merge the MZ_PREFIX and mzId
1284 static void mergeTimeZoneKey(const UnicodeString&amp; mzID, char* result) {
1285     if (mzID.isEmpty()) {
1286         result[0] = &#39;\0&#39;;
1287         return;
1288     }
1289 
1290     char mzIdChar[ZID_KEY_MAX + 1];
1291     int32_t keyLen;
<span class="line-modified">1292     int32_t prefixLen = static_cast&lt;int32_t&gt;(uprv_strlen(gMZPrefix));</span>
1293     keyLen = mzID.extract(0, mzID.length(), mzIdChar, ZID_KEY_MAX + 1, US_INV);
1294     uprv_memcpy((void *)result, (void *)gMZPrefix, prefixLen);
1295     uprv_memcpy((void *)(result + prefixLen), (void *)mzIdChar, keyLen);
1296     result[keyLen + prefixLen] = &#39;\0&#39;;
1297 }
1298 
1299 /*
1300  * This method updates the cache and must be called with a lock
1301  */
1302 ZNames*
1303 TimeZoneNamesImpl::loadMetaZoneNames(const UnicodeString&amp; mzID, UErrorCode&amp; status) {
1304     if (U_FAILURE(status)) { return NULL; }
1305     U_ASSERT(mzID.length() &lt;= ZID_KEY_MAX - MZ_PREFIX_LEN);
1306 
1307     UChar mzIDKey[ZID_KEY_MAX + 1];
1308     mzID.extract(mzIDKey, ZID_KEY_MAX + 1, status);
1309     U_ASSERT(U_SUCCESS(status));   // already checked length above
1310     mzIDKey[mzID.length()] = 0;
1311 
1312     void* mznames = uhash_get(fMZNamesMap, mzIDKey);
</pre>
<hr />
<pre>
1341     if (tznames == NULL) {
1342         ZNames::ZNamesLoader loader;
1343         loader.loadTimeZone(fZoneStrings, tzID, status);
1344         tznames = ZNames::createTimeZoneAndPutInCache(fTZNamesMap, loader.getNames(), tzID, status);
1345         if (U_FAILURE(status)) { return NULL; }
1346     }
1347 
1348     // tznames is never EMPTY
1349     return (ZNames*)tznames;
1350 }
1351 
1352 TimeZoneNames::MatchInfoCollection*
1353 TimeZoneNamesImpl::find(const UnicodeString&amp; text, int32_t start, uint32_t types, UErrorCode&amp; status) const {
1354     ZNameSearchHandler handler(types);
1355     TimeZoneNames::MatchInfoCollection* matches;
1356     TimeZoneNamesImpl* nonConstThis = const_cast&lt;TimeZoneNamesImpl*&gt;(this);
1357 
1358     // Synchronize so that data is not loaded multiple times.
1359     // TODO: Consider more fine-grained synchronization.
1360     {
<span class="line-modified">1361         Mutex lock(gDataMutex());</span>
1362 
1363         // First try of lookup.
1364         matches = doFind(handler, text, start, status);
1365         if (U_FAILURE(status)) { return NULL; }
1366         if (matches != NULL) {
1367             return matches;
1368         }
1369 
1370         // All names are not yet loaded into the trie.
1371         // We may have loaded names for formatting several time zones,
1372         // and might be parsing one of those.
1373         // Populate the parsing trie from all of the already-loaded names.
1374         nonConstThis-&gt;addAllNamesIntoTrie(status);
1375 
1376         // Second try of lookup.
1377         matches = doFind(handler, text, start, status);
1378         if (U_FAILURE(status)) { return NULL; }
1379         if (matches != NULL) {
1380             return matches;
1381         }
</pre>
<hr />
<pre>
1440     if (obj == DUMMY_LOADER) { return; }
1441     const ZNames::ZNamesLoader* loader = (const ZNames::ZNamesLoader*) obj;
1442     delete loader;
1443 }
1444 U_CDECL_END
1445 
1446 struct TimeZoneNamesImpl::ZoneStringsLoader : public ResourceSink {
1447     TimeZoneNamesImpl&amp; tzn;
1448     UHashtable* keyToLoader;
1449 
1450     ZoneStringsLoader(TimeZoneNamesImpl&amp; _tzn, UErrorCode&amp; status)
1451             : tzn(_tzn) {
1452         keyToLoader = uhash_open(uhash_hashChars, uhash_compareChars, NULL, &amp;status);
1453         if (U_FAILURE(status)) { return; }
1454         uhash_setKeyDeleter(keyToLoader, uprv_free);
1455         uhash_setValueDeleter(keyToLoader, deleteZNamesLoader);
1456     }
1457     virtual ~ZoneStringsLoader();
1458 
1459     void* createKey(const char* key, UErrorCode&amp; status) {
<span class="line-modified">1460         int32_t len = sizeof(char) * (static_cast&lt;int32_t&gt;(uprv_strlen(key)) + 1);</span>
1461         char* newKey = (char*) uprv_malloc(len);
1462         if (newKey == NULL) {
1463             status = U_MEMORY_ALLOCATION_ERROR;
1464             return NULL;
1465         }
1466         uprv_memcpy(newKey, key, len);
1467         newKey[len-1] = &#39;\0&#39;;
1468         return (void*) newKey;
1469     }
1470 
1471     UBool isMetaZone(const char* key) {
1472         return (uprv_strlen(key) &gt;= MZ_PREFIX_LEN &amp;&amp; uprv_memcmp(key, gMZPrefix, MZ_PREFIX_LEN) == 0);
1473     }
1474 
1475     UnicodeString mzIDFromKey(const char* key) {
<span class="line-modified">1476         return UnicodeString(key + MZ_PREFIX_LEN, static_cast&lt;int32_t&gt;(uprv_strlen(key)) - MZ_PREFIX_LEN, US_INV);</span>
1477     }
1478 
1479     UnicodeString tzIDFromKey(const char* key) {
1480         UnicodeString tzID(key, -1, US_INV);
1481         // Replace all colons &#39;:&#39; with slashes &#39;/&#39;
1482         for (int i=0; i&lt;tzID.length(); i++) {
1483             if (tzID.charAt(i) == 0x003A) {
1484                 tzID.setCharAt(i, 0x002F);
1485             }
1486         }
1487         return tzID;
1488     }
1489 
1490     void load(UErrorCode&amp; status) {
1491         ures_getAllItemsWithFallback(tzn.fZoneStrings, &quot;&quot;, *this, status);
1492         if (U_FAILURE(status)) { return; }
1493 
1494         int32_t pos = UHASH_FIRST;
1495         const UHashElement* element;
1496         while ((element = uhash_nextElement(keyToLoader, &amp;pos)) != NULL) {
</pre>
<hr />
<pre>
1568             if (value.getType() == URES_TABLE) {
1569                 consumeNamesTable(key, value, noFallback, status);
1570             } else {
1571                 // Ignore fields that aren&#39;t tables (e.g., fallbackFormat and regionFormatStandard).
1572                 // All time zone fields are tables.
1573             }
1574             if (U_FAILURE(status)) { return; }
1575         }
1576     }
1577 };
1578 
1579 // Virtual destructors must be defined out of line.
1580 TimeZoneNamesImpl::ZoneStringsLoader::~ZoneStringsLoader() {
1581     uhash_close(keyToLoader);
1582 }
1583 
1584 void TimeZoneNamesImpl::loadAllDisplayNames(UErrorCode&amp; status) {
1585     if (U_FAILURE(status)) return;
1586 
1587     {
<span class="line-modified">1588         Mutex lock(gDataMutex());</span>
1589         internalLoadAllDisplayNames(status);
1590     }
1591 }
1592 
1593 void TimeZoneNamesImpl::getDisplayNames(const UnicodeString&amp; tzID,
1594         const UTimeZoneNameType types[], int32_t numTypes,
1595         UDate date, UnicodeString dest[], UErrorCode&amp; status) const {
1596     if (U_FAILURE(status)) return;
1597 
1598     if (tzID.isEmpty()) { return; }
1599     void* tznames = NULL;
1600     void* mznames = NULL;
1601     TimeZoneNamesImpl *nonConstThis = const_cast&lt;TimeZoneNamesImpl*&gt;(this);
1602 
1603     // Load the time zone strings
1604     {
<span class="line-modified">1605         Mutex lock(gDataMutex());</span>
1606         tznames = (void*) nonConstThis-&gt;loadTimeZoneNames(tzID, status);
1607         if (U_FAILURE(status)) { return; }
1608     }
1609     U_ASSERT(tznames != NULL);
1610 
1611     // Load the values into the dest array
1612     for (int i = 0; i &lt; numTypes; i++) {
1613         UTimeZoneNameType type = types[i];
1614         const UChar* name = ((ZNames*)tznames)-&gt;getName(type);
1615         if (name == NULL) {
1616             if (mznames == NULL) {
1617                 // Load the meta zone name
1618                 UnicodeString mzID;
1619                 getMetaZoneID(tzID, date, mzID);
1620                 if (mzID.isEmpty()) {
1621                     mznames = (void*) EMPTY;
1622                 } else {
1623                     // Load the meta zone strings
1624                     // Mutex is scoped to the &quot;else&quot; statement
<span class="line-modified">1625                     Mutex lock(gDataMutex());</span>
1626                     mznames = (void*) nonConstThis-&gt;loadMetaZoneNames(mzID, status);
1627                     if (U_FAILURE(status)) { return; }
1628                     // Note: when the metazone doesn&#39;t exist, in Java, loadMetaZoneNames returns
1629                     // a dummy object instead of NULL.
1630                     if (mznames == NULL) {
1631                         mznames = (void*) EMPTY;
1632                     }
1633                 }
1634             }
1635             U_ASSERT(mznames != NULL);
1636             if (mznames != EMPTY) {
1637                 name = ((ZNames*)mznames)-&gt;getName(type);
1638             }
1639         }
1640         if (name != NULL) {
1641             dest[i].setTo(TRUE, name, -1);
1642         } else {
1643             dest[i].setToBogus();
1644         }
1645     }
</pre>
<hr />
<pre>
1931                 // Some tz database abbreviations are ambiguous. For example,
1932                 // CST means either Central Standard Time or China Standard Time.
1933                 // Unlike CLDR time zone display names, this implementation
1934                 // does not use unique names. And TimeZoneFormat does not expect
1935                 // multiple results returned for the same time zone type.
1936                 // For this reason, this implementation resolve one among same
1937                 // zone type with a same name at this level.
1938                 if (ninfo-&gt;parseRegions == NULL) {
1939                     // parseRegions == null means this is the default metazone
1940                     // mapping for the abbreviation.
1941                     if (defaultRegionMatch == NULL) {
1942                         match = defaultRegionMatch = ninfo;
1943                     }
1944                 } else {
1945                     UBool matchRegion = FALSE;
1946                     // non-default metazone mapping for an abbreviation
1947                     // comes with applicable regions. For example, the default
1948                     // metazone mapping for &quot;CST&quot; is America_Central,
1949                     // but if region is one of CN/MO/TW, &quot;CST&quot; is parsed
1950                     // as metazone China (China Standard Time).
<span class="line-modified">1951                     for (int32_t j = 0; j &lt; ninfo-&gt;nRegions; j++) {</span>
<span class="line-modified">1952                         const char *region = ninfo-&gt;parseRegions[j];</span>
1953                         if (uprv_strcmp(fRegion, region) == 0) {
1954                             match = ninfo;
1955                             matchRegion = TRUE;
1956                             break;
1957                         }
1958                     }
1959                     if (matchRegion) {
1960                         break;
1961                     }
1962                     if (match == NULL) {
1963                         match = ninfo;
1964                     }
1965                 }
1966             }
1967         }
1968 
1969         if (match != NULL) {
1970             UTimeZoneNameType ntype = match-&gt;type;
1971             // Note: Workaround for duplicated standard/daylight names
1972             // The tz database contains a few zones sharing a
</pre>
<hr />
<pre>
2046 static void U_CALLCONV
2047 deleteTZDBNameInfo(void *obj) {
2048     if (obj != NULL) {
2049         uprv_free(obj);
2050     }
2051 }
2052 
2053 static void U_CALLCONV prepareFind(UErrorCode &amp;status) {
2054     if (U_FAILURE(status)) {
2055         return;
2056     }
2057     gTZDBNamesTrie = new TextTrieMap(TRUE, deleteTZDBNameInfo);
2058     if (gTZDBNamesTrie == NULL) {
2059         status = U_MEMORY_ALLOCATION_ERROR;
2060         return;
2061     }
2062 
2063     const UnicodeString *mzID;
2064     StringEnumeration *mzIDs = TimeZoneNamesImpl::_getAvailableMetaZoneIDs(status);
2065     if (U_SUCCESS(status)) {
<span class="line-modified">2066         while ((mzID = mzIDs-&gt;snext(status)) != 0 &amp;&amp; U_SUCCESS(status)) {</span>
2067             const TZDBNames *names = TZDBTimeZoneNames::getMetaZoneNames(*mzID, status);
2068             if (U_FAILURE(status)) {
2069                 break;
2070             }
2071             if (names == NULL) {
2072                 continue;
2073             }
2074             const UChar *std = names-&gt;getName(UTZNM_SHORT_STANDARD);
2075             const UChar *dst = names-&gt;getName(UTZNM_SHORT_DAYLIGHT);
2076             if (std == NULL &amp;&amp; dst == NULL) {
2077                 continue;
2078             }
2079             int32_t numRegions = 0;
2080             const char **parseRegions = names-&gt;getParseRegions(numRegions);
2081 
2082             // The tz database contains a few zones sharing a
2083             // same name for both standard time and daylight saving
2084             // time. For example, Australia/Sydney observes DST,
2085             // but &quot;EST&quot; is used for both standard and daylight.
2086             // we need to store the information for later processing.
</pre>
<hr />
<pre>
2115             }
2116         }
2117     }
2118     delete mzIDs;
2119 
2120     if (U_FAILURE(status)) {
2121         delete gTZDBNamesTrie;
2122         gTZDBNamesTrie = NULL;
2123         return;
2124     }
2125 
2126     ucln_i18n_registerCleanup(UCLN_I18N_TZDBTIMEZONENAMES, tzdbTimeZoneNames_cleanup);
2127 }
2128 
2129 U_CDECL_END
2130 
2131 TZDBTimeZoneNames::TZDBTimeZoneNames(const Locale&amp; locale)
2132 : fLocale(locale) {
2133     UBool useWorld = TRUE;
2134     const char* region = fLocale.getCountry();
<span class="line-modified">2135     int32_t regionLen = static_cast&lt;int32_t&gt;(uprv_strlen(region));</span>
2136     if (regionLen == 0) {
2137         UErrorCode status = U_ZERO_ERROR;
2138         char loc[ULOC_FULLNAME_CAPACITY];
2139         uloc_addLikelySubtags(fLocale.getName(), loc, sizeof(loc), &amp;status);
2140         regionLen = uloc_getCountry(loc, fRegion, sizeof(fRegion), &amp;status);
2141         if (U_SUCCESS(status) &amp;&amp; regionLen &lt; (int32_t)sizeof(fRegion)) {
2142             useWorld = FALSE;
2143         }
2144     } else if (regionLen &lt; (int32_t)sizeof(fRegion)) {
2145         uprv_strcpy(fRegion, region);
2146         useWorld = FALSE;
2147     }
2148     if (useWorld) {
2149         uprv_strcpy(fRegion, &quot;001&quot;);
2150     }
2151 }
2152 
2153 TZDBTimeZoneNames::~TZDBTimeZoneNames() {
2154 }
2155 
</pre>
<hr />
<pre>
2230         return NULL;
2231     }
2232     int32_t maxLen = 0;
2233     return handler.getMatches(maxLen);
2234 }
2235 
2236 const TZDBNames*
2237 TZDBTimeZoneNames::getMetaZoneNames(const UnicodeString&amp; mzID, UErrorCode&amp; status) {
2238     umtx_initOnce(gTZDBNamesMapInitOnce, &amp;initTZDBNamesMap, status);
2239     if (U_FAILURE(status)) {
2240         return NULL;
2241     }
2242 
2243     TZDBNames* tzdbNames = NULL;
2244 
2245     UChar mzIDKey[ZID_KEY_MAX + 1];
2246     mzID.extract(mzIDKey, ZID_KEY_MAX + 1, status);
2247     U_ASSERT(status == U_ZERO_ERROR);   // already checked length above
2248     mzIDKey[mzID.length()] = 0;
2249 
<span class="line-added">2250     static UMutex gTZDBNamesMapLock = U_MUTEX_INITIALIZER;</span>
2251     umtx_lock(&amp;gTZDBNamesMapLock);
2252     {
2253         void *cacheVal = uhash_get(gTZDBNamesMap, mzIDKey);
2254         if (cacheVal == NULL) {
2255             UResourceBundle *zoneStringsRes = ures_openDirect(U_ICUDATA_ZONE, &quot;tzdbNames&quot;, &amp;status);
2256             zoneStringsRes = ures_getByKey(zoneStringsRes, gZoneStrings, zoneStringsRes, &amp;status);
2257             if (U_SUCCESS(status)) {
2258                 char key[ZID_KEY_MAX + 1];
2259                 mergeTimeZoneKey(mzID, key);
2260                 tzdbNames = TZDBNames::createInstance(zoneStringsRes, key);
2261 
2262                 if (tzdbNames == NULL) {
2263                     cacheVal = (void *)EMPTY;
2264                 } else {
2265                     cacheVal = tzdbNames;
2266                 }
2267                 // Use the persistent ID as the resource key, so we can
2268                 // avoid duplications.
2269                 // TODO: Is there a more efficient way, like intern() in Java?
2270                 void* newKey = (void*) ZoneMeta::findMetaZoneID(mzID);
</pre>
</td>
</tr>
</table>
<center><a href="tznames.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ucln_in.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>