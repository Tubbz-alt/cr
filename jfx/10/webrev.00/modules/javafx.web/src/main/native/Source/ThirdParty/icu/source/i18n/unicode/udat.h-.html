<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/udat.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4  *******************************************************************************
   5  * Copyright (C) 1996-2016, International Business Machines
   6  * Corporation and others. All Rights Reserved.
   7  *******************************************************************************
   8 */
   9 
  10 #ifndef UDAT_H
  11 #define UDAT_H
  12 
  13 #include &quot;unicode/utypes.h&quot;
  14 
  15 #if !UCONFIG_NO_FORMATTING
  16 
  17 #include &quot;unicode/localpointer.h&quot;
  18 #include &quot;unicode/ucal.h&quot;
  19 #include &quot;unicode/unum.h&quot;
  20 #include &quot;unicode/udisplaycontext.h&quot;
  21 #include &quot;unicode/ufieldpositer.h&quot;
  22 /**
  23  * \file
  24  * \brief C API: DateFormat
  25  *
  26  * &lt;h2&gt; Date Format C API&lt;/h2&gt;
  27  *
  28  * Date Format C API  consists of functions that convert dates and
  29  * times from their internal representations to textual form and back again in a
  30  * language-independent manner. Converting from the internal representation (milliseconds
  31  * since midnight, January 1, 1970) to text is known as &quot;formatting,&quot; and converting
  32  * from text to millis is known as &quot;parsing.&quot;  We currently define only one concrete
  33  * structure UDateFormat, which can handle pretty much all normal
  34  * date formatting and parsing actions.
  35  * &lt;P&gt;
  36  * Date Format helps you to format and parse dates for any locale. Your code can
  37  * be completely independent of the locale conventions for months, days of the
  38  * week, or even the calendar format: lunar vs. solar.
  39  * &lt;P&gt;
  40  * To format a date for the current Locale with default time and date style,
  41  * use one of the static factory methods:
  42  * &lt;pre&gt;
  43  * \code
  44  *  UErrorCode status = U_ZERO_ERROR;
  45  *  UChar *myString;
  46  *  int32_t myStrlen = 0;
  47  *  UDateFormat* dfmt = udat_open(UDAT_DEFAULT, UDAT_DEFAULT, NULL, NULL, -1, NULL, -1, &amp;status);
  48  *  myStrlen = udat_format(dfmt, myDate, NULL, myStrlen, NULL, &amp;status);
  49  *  if (status==U_BUFFER_OVERFLOW_ERROR){
  50  *      status=U_ZERO_ERROR;
  51  *      myString=(UChar*)malloc(sizeof(UChar) * (myStrlen+1) );
  52  *      udat_format(dfmt, myDate, myString, myStrlen+1, NULL, &amp;status);
  53  *  }
  54  * \endcode
  55  * &lt;/pre&gt;
  56  * If you are formatting multiple numbers, it is more efficient to get the
  57  * format and use it multiple times so that the system doesn&#39;t have to fetch the
  58  * information about the local language and country conventions multiple times.
  59  * &lt;pre&gt;
  60  * \code
  61  *  UErrorCode status = U_ZERO_ERROR;
  62  *  int32_t i, myStrlen = 0;
  63  *  UChar* myString;
  64  *  char buffer[1024];
  65  *  UDate myDateArr[] = { 0.0, 100000000.0, 2000000000.0 }; // test values
  66  *  UDateFormat* df = udat_open(UDAT_DEFAULT, UDAT_DEFAULT, NULL, NULL, -1, NULL, 0, &amp;status);
  67  *  for (i = 0; i &lt; 3; i++) {
  68  *      myStrlen = udat_format(df, myDateArr[i], NULL, myStrlen, NULL, &amp;status);
  69  *      if(status == U_BUFFER_OVERFLOW_ERROR){
  70  *          status = U_ZERO_ERROR;
  71  *          myString = (UChar*)malloc(sizeof(UChar) * (myStrlen+1) );
  72  *          udat_format(df, myDateArr[i], myString, myStrlen+1, NULL, &amp;status);
  73  *          printf(&quot;%s\n&quot;, u_austrcpy(buffer, myString) );
  74  *          free(myString);
  75  *      }
  76  *  }
  77  * \endcode
  78  * &lt;/pre&gt;
  79  * To get specific fields of a date, you can use UFieldPosition to
  80  * get specific fields.
  81  * &lt;pre&gt;
  82  * \code
  83  *  UErrorCode status = U_ZERO_ERROR;
  84  *  UFieldPosition pos;
  85  *  UChar *myString;
  86  *  int32_t myStrlen = 0;
  87  *  char buffer[1024];
  88  *
  89  *  pos.field = 1;  // Same as the DateFormat::EField enum
  90  *  UDateFormat* dfmt = udat_open(UDAT_DEFAULT, UDAT_DEFAULT, NULL, -1, NULL, 0, &amp;status);
  91  *  myStrlen = udat_format(dfmt, myDate, NULL, myStrlen, &amp;pos, &amp;status);
  92  *  if (status==U_BUFFER_OVERFLOW_ERROR){
  93  *      status=U_ZERO_ERROR;
  94  *      myString=(UChar*)malloc(sizeof(UChar) * (myStrlen+1) );
  95  *      udat_format(dfmt, myDate, myString, myStrlen+1, &amp;pos, &amp;status);
  96  *  }
  97  *  printf(&quot;date format: %s\n&quot;, u_austrcpy(buffer, myString));
  98  *  buffer[pos.endIndex] = 0;   // NULL terminate the string.
  99  *  printf(&quot;UFieldPosition position equals %s\n&quot;, &amp;buffer[pos.beginIndex]);
 100  * \endcode
 101  * &lt;/pre&gt;
 102  * To format a date for a different Locale, specify it in the call to
 103  * udat_open()
 104  * &lt;pre&gt;
 105  * \code
 106  *        UDateFormat* df = udat_open(UDAT_SHORT, UDAT_SHORT, &quot;fr_FR&quot;, NULL, -1, NULL, 0, &amp;status);
 107  * \endcode
 108  * &lt;/pre&gt;
 109  * You can use a DateFormat API udat_parse() to parse.
 110  * &lt;pre&gt;
 111  * \code
 112  *  UErrorCode status = U_ZERO_ERROR;
 113  *  int32_t parsepos=0;
 114  *  UDate myDate = udat_parse(df, myString, u_strlen(myString), &amp;parsepos, &amp;status);
 115  * \endcode
 116  * &lt;/pre&gt;
 117  *  You can pass in different options for the arguments for date and time style
 118  *  to control the length of the result; from SHORT to MEDIUM to LONG to FULL.
 119  *  The exact result depends on the locale, but generally:
 120  *  see UDateFormatStyle for more details
 121  * &lt;ul type=round&gt;
 122  *   &lt;li&gt;   UDAT_SHORT is completely numeric, such as 12/13/52 or 3:30pm
 123  *   &lt;li&gt;   UDAT_MEDIUM is longer, such as Jan 12, 1952
 124  *   &lt;li&gt;   UDAT_LONG is longer, such as January 12, 1952 or 3:30:32pm
 125  *   &lt;li&gt;   UDAT_FULL is pretty completely specified, such as
 126  *          Tuesday, April 12, 1952 AD or 3:30:42pm PST.
 127  * &lt;/ul&gt;
 128  * You can also set the time zone on the format if you wish.
 129  * &lt;P&gt;
 130  * You can also use forms of the parse and format methods with Parse Position and
 131  * UFieldPosition to allow you to
 132  * &lt;ul type=round&gt;
 133  *   &lt;li&gt;   Progressively parse through pieces of a string.
 134  *   &lt;li&gt;   Align any particular field, or find out where it is for selection
 135  *          on the screen.
 136  * &lt;/ul&gt;
 137  * &lt;p&gt;&lt;strong&gt;Date and Time Patterns:&lt;/strong&gt;&lt;/p&gt;
 138  *
 139  * &lt;p&gt;Date and time formats are specified by &lt;em&gt;date and time pattern&lt;/em&gt; strings.
 140  * Within date and time pattern strings, all unquoted ASCII letters [A-Za-z] are reserved
 141  * as pattern letters representing calendar fields. &lt;code&gt;UDateFormat&lt;/code&gt; supports
 142  * the date and time formatting algorithm and pattern letters defined by
 143  * &lt;a href=&quot;http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table&quot;&gt;UTS#35
 144  * Unicode Locale Data Markup Language (LDML)&lt;/a&gt; and further documented for ICU in the
 145  * &lt;a href=&quot;https://sites.google.com/site/icuprojectuserguide/formatparse/datetime?pli=1#TOC-Date-Field-Symbol-Table&quot;&gt;ICU
 146  * User Guide&lt;/a&gt;.&lt;/p&gt;
 147  */
 148 
 149 /** A date formatter.
 150  *  For usage in C programs.
 151  *  @stable ICU 2.6
 152  */
 153 typedef void* UDateFormat;
 154 
 155 /** The possible date/time format styles
 156  *  @stable ICU 2.6
 157  */
 158 typedef enum UDateFormatStyle {
 159     /** Full style */
 160     UDAT_FULL,
 161     /** Long style */
 162     UDAT_LONG,
 163     /** Medium style */
 164     UDAT_MEDIUM,
 165     /** Short style */
 166     UDAT_SHORT,
 167     /** Default style */
 168     UDAT_DEFAULT = UDAT_MEDIUM,
 169 
 170     /** Bitfield for relative date */
 171     UDAT_RELATIVE = (1 &lt;&lt; 7),
 172 
 173     UDAT_FULL_RELATIVE = UDAT_FULL | UDAT_RELATIVE,
 174 
 175     UDAT_LONG_RELATIVE = UDAT_LONG | UDAT_RELATIVE,
 176 
 177     UDAT_MEDIUM_RELATIVE = UDAT_MEDIUM | UDAT_RELATIVE,
 178 
 179     UDAT_SHORT_RELATIVE = UDAT_SHORT | UDAT_RELATIVE,
 180 
 181 
 182     /** No style */
 183     UDAT_NONE = -1,
 184 
 185     /**
 186      * Use the pattern given in the parameter to udat_open
 187      * @see udat_open
 188      * @stable ICU 50
 189      */
 190     UDAT_PATTERN = -2,
 191 
 192 #ifndef U_HIDE_INTERNAL_API
 193     /** @internal alias to UDAT_PATTERN */
 194     UDAT_IGNORE = UDAT_PATTERN
 195 #endif /* U_HIDE_INTERNAL_API */
 196 } UDateFormatStyle;
 197 
 198 /* Skeletons for dates. */
 199 
 200 /**
 201  * Constant for date skeleton with year.
 202  * @stable ICU 4.0
 203  */
 204 #define UDAT_YEAR                       &quot;y&quot;
 205 /**
 206  * Constant for date skeleton with quarter.
 207  * @stable ICU 51
 208  */
 209 #define UDAT_QUARTER                    &quot;QQQQ&quot;
 210 /**
 211  * Constant for date skeleton with abbreviated quarter.
 212  * @stable ICU 51
 213  */
 214 #define UDAT_ABBR_QUARTER               &quot;QQQ&quot;
 215 /**
 216  * Constant for date skeleton with year and quarter.
 217  * @stable ICU 4.0
 218  */
 219 #define UDAT_YEAR_QUARTER               &quot;yQQQQ&quot;
 220 /**
 221  * Constant for date skeleton with year and abbreviated quarter.
 222  * @stable ICU 4.0
 223  */
 224 #define UDAT_YEAR_ABBR_QUARTER          &quot;yQQQ&quot;
 225 /**
 226  * Constant for date skeleton with month.
 227  * @stable ICU 4.0
 228  */
 229 #define UDAT_MONTH                      &quot;MMMM&quot;
 230 /**
 231  * Constant for date skeleton with abbreviated month.
 232  * @stable ICU 4.0
 233  */
 234 #define UDAT_ABBR_MONTH                 &quot;MMM&quot;
 235 /**
 236  * Constant for date skeleton with numeric month.
 237  * @stable ICU 4.0
 238  */
 239 #define UDAT_NUM_MONTH                  &quot;M&quot;
 240 /**
 241  * Constant for date skeleton with year and month.
 242  * @stable ICU 4.0
 243  */
 244 #define UDAT_YEAR_MONTH                 &quot;yMMMM&quot;
 245 /**
 246  * Constant for date skeleton with year and abbreviated month.
 247  * @stable ICU 4.0
 248  */
 249 #define UDAT_YEAR_ABBR_MONTH            &quot;yMMM&quot;
 250 /**
 251  * Constant for date skeleton with year and numeric month.
 252  * @stable ICU 4.0
 253  */
 254 #define UDAT_YEAR_NUM_MONTH             &quot;yM&quot;
 255 /**
 256  * Constant for date skeleton with day.
 257  * @stable ICU 4.0
 258  */
 259 #define UDAT_DAY                        &quot;d&quot;
 260 /**
 261  * Constant for date skeleton with year, month, and day.
 262  * Used in combinations date + time, date + time + zone, or time + zone.
 263  * @stable ICU 4.0
 264  */
 265 #define UDAT_YEAR_MONTH_DAY             &quot;yMMMMd&quot;
 266 /**
 267  * Constant for date skeleton with year, abbreviated month, and day.
 268  * Used in combinations date + time, date + time + zone, or time + zone.
 269  * @stable ICU 4.0
 270  */
 271 #define UDAT_YEAR_ABBR_MONTH_DAY        &quot;yMMMd&quot;
 272 /**
 273  * Constant for date skeleton with year, numeric month, and day.
 274  * Used in combinations date + time, date + time + zone, or time + zone.
 275  * @stable ICU 4.0
 276  */
 277 #define UDAT_YEAR_NUM_MONTH_DAY         &quot;yMd&quot;
 278 /**
 279  * Constant for date skeleton with weekday.
 280  * @stable ICU 51
 281  */
 282 #define UDAT_WEEKDAY                    &quot;EEEE&quot;
 283 /**
 284  * Constant for date skeleton with abbreviated weekday.
 285  * @stable ICU 51
 286  */
 287 #define UDAT_ABBR_WEEKDAY               &quot;E&quot;
 288 /**
 289  * Constant for date skeleton with year, month, weekday, and day.
 290  * Used in combinations date + time, date + time + zone, or time + zone.
 291  * @stable ICU 4.0
 292  */
 293 #define UDAT_YEAR_MONTH_WEEKDAY_DAY     &quot;yMMMMEEEEd&quot;
 294 /**
 295  * Constant for date skeleton with year, abbreviated month, weekday, and day.
 296  * Used in combinations date + time, date + time + zone, or time + zone.
 297  * @stable ICU 4.0
 298  */
 299 #define UDAT_YEAR_ABBR_MONTH_WEEKDAY_DAY &quot;yMMMEd&quot;
 300 /**
 301  * Constant for date skeleton with year, numeric month, weekday, and day.
 302  * Used in combinations date + time, date + time + zone, or time + zone.
 303  * @stable ICU 4.0
 304  */
 305 #define UDAT_YEAR_NUM_MONTH_WEEKDAY_DAY &quot;yMEd&quot;
 306 /**
 307  * Constant for date skeleton with long month and day.
 308  * Used in combinations date + time, date + time + zone, or time + zone.
 309  * @stable ICU 4.0
 310  */
 311 #define UDAT_MONTH_DAY                  &quot;MMMMd&quot;
 312 /**
 313  * Constant for date skeleton with abbreviated month and day.
 314  * Used in combinations date + time, date + time + zone, or time + zone.
 315  * @stable ICU 4.0
 316  */
 317 #define UDAT_ABBR_MONTH_DAY             &quot;MMMd&quot;
 318 /**
 319  * Constant for date skeleton with numeric month and day.
 320  * Used in combinations date + time, date + time + zone, or time + zone.
 321  * @stable ICU 4.0
 322  */
 323 #define UDAT_NUM_MONTH_DAY              &quot;Md&quot;
 324 /**
 325  * Constant for date skeleton with month, weekday, and day.
 326  * Used in combinations date + time, date + time + zone, or time + zone.
 327  * @stable ICU 4.0
 328  */
 329 #define UDAT_MONTH_WEEKDAY_DAY          &quot;MMMMEEEEd&quot;
 330 /**
 331  * Constant for date skeleton with abbreviated month, weekday, and day.
 332  * Used in combinations date + time, date + time + zone, or time + zone.
 333  * @stable ICU 4.0
 334  */
 335 #define UDAT_ABBR_MONTH_WEEKDAY_DAY     &quot;MMMEd&quot;
 336 /**
 337  * Constant for date skeleton with numeric month, weekday, and day.
 338  * Used in combinations date + time, date + time + zone, or time + zone.
 339  * @stable ICU 4.0
 340  */
 341 #define UDAT_NUM_MONTH_WEEKDAY_DAY      &quot;MEd&quot;
 342 
 343 /* Skeletons for times. */
 344 
 345 /**
 346  * Constant for date skeleton with hour, with the locale&#39;s preferred hour format (12 or 24).
 347  * @stable ICU 4.0
 348  */
 349 #define UDAT_HOUR                       &quot;j&quot;
 350 /**
 351  * Constant for date skeleton with hour in 24-hour presentation.
 352  * @stable ICU 51
 353  */
 354 #define UDAT_HOUR24                     &quot;H&quot;
 355 /**
 356  * Constant for date skeleton with minute.
 357  * @stable ICU 51
 358  */
 359 #define UDAT_MINUTE                     &quot;m&quot;
 360 /**
 361  * Constant for date skeleton with hour and minute, with the locale&#39;s preferred hour format (12 or 24).
 362  * Used in combinations date + time, date + time + zone, or time + zone.
 363  * @stable ICU 4.0
 364  */
 365 #define UDAT_HOUR_MINUTE                &quot;jm&quot;
 366 /**
 367  * Constant for date skeleton with hour and minute in 24-hour presentation.
 368  * Used in combinations date + time, date + time + zone, or time + zone.
 369  * @stable ICU 4.0
 370  */
 371 #define UDAT_HOUR24_MINUTE              &quot;Hm&quot;
 372 /**
 373  * Constant for date skeleton with second.
 374  * @stable ICU 51
 375  */
 376 #define UDAT_SECOND                     &quot;s&quot;
 377 /**
 378  * Constant for date skeleton with hour, minute, and second,
 379  * with the locale&#39;s preferred hour format (12 or 24).
 380  * Used in combinations date + time, date + time + zone, or time + zone.
 381  * @stable ICU 4.0
 382  */
 383 #define UDAT_HOUR_MINUTE_SECOND         &quot;jms&quot;
 384 /**
 385  * Constant for date skeleton with hour, minute, and second in
 386  * 24-hour presentation.
 387  * Used in combinations date + time, date + time + zone, or time + zone.
 388  * @stable ICU 4.0
 389  */
 390 #define UDAT_HOUR24_MINUTE_SECOND       &quot;Hms&quot;
 391 /**
 392  * Constant for date skeleton with minute and second.
 393  * Used in combinations date + time, date + time + zone, or time + zone.
 394  * @stable ICU 4.0
 395  */
 396 #define UDAT_MINUTE_SECOND              &quot;ms&quot;
 397 
 398 /* Skeletons for time zones. */
 399 
 400 /**
 401  * Constant for &lt;i&gt;generic location format&lt;/i&gt;, such as Los Angeles Time;
 402  * used in combinations date + time + zone, or time + zone.
 403  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Date_Format_Patterns&quot;&gt;LDML Date Format Patterns&lt;/a&gt;
 404  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Time_Zone_Fallback&quot;&gt;LDML Time Zone Fallback&lt;/a&gt;
 405  * @stable ICU 51
 406  */
 407 #define UDAT_LOCATION_TZ &quot;VVVV&quot;
 408 /**
 409  * Constant for &lt;i&gt;generic non-location format&lt;/i&gt;, such as Pacific Time;
 410  * used in combinations date + time + zone, or time + zone.
 411  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Date_Format_Patterns&quot;&gt;LDML Date Format Patterns&lt;/a&gt;
 412  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Time_Zone_Fallback&quot;&gt;LDML Time Zone Fallback&lt;/a&gt;
 413  * @stable ICU 51
 414  */
 415 #define UDAT_GENERIC_TZ &quot;vvvv&quot;
 416 /**
 417  * Constant for &lt;i&gt;generic non-location format&lt;/i&gt;, abbreviated if possible, such as PT;
 418  * used in combinations date + time + zone, or time + zone.
 419  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Date_Format_Patterns&quot;&gt;LDML Date Format Patterns&lt;/a&gt;
 420  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Time_Zone_Fallback&quot;&gt;LDML Time Zone Fallback&lt;/a&gt;
 421  * @stable ICU 51
 422  */
 423 #define UDAT_ABBR_GENERIC_TZ &quot;v&quot;
 424 /**
 425  * Constant for &lt;i&gt;specific non-location format&lt;/i&gt;, such as Pacific Daylight Time;
 426  * used in combinations date + time + zone, or time + zone.
 427  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Date_Format_Patterns&quot;&gt;LDML Date Format Patterns&lt;/a&gt;
 428  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Time_Zone_Fallback&quot;&gt;LDML Time Zone Fallback&lt;/a&gt;
 429  * @stable ICU 51
 430  */
 431 #define UDAT_SPECIFIC_TZ &quot;zzzz&quot;
 432 /**
 433  * Constant for &lt;i&gt;specific non-location format&lt;/i&gt;, abbreviated if possible, such as PDT;
 434  * used in combinations date + time + zone, or time + zone.
 435  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Date_Format_Patterns&quot;&gt;LDML Date Format Patterns&lt;/a&gt;
 436  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Time_Zone_Fallback&quot;&gt;LDML Time Zone Fallback&lt;/a&gt;
 437  * @stable ICU 51
 438  */
 439 #define UDAT_ABBR_SPECIFIC_TZ &quot;z&quot;
 440 /**
 441  * Constant for &lt;i&gt;localized GMT/UTC format&lt;/i&gt;, such as GMT+8:00 or HPG-8:00;
 442  * used in combinations date + time + zone, or time + zone.
 443  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Date_Format_Patterns&quot;&gt;LDML Date Format Patterns&lt;/a&gt;
 444  * @see &lt;a href=&quot;http://unicode.org/reports/tr35/#Time_Zone_Fallback&quot;&gt;LDML Time Zone Fallback&lt;/a&gt;
 445  * @stable ICU 51
 446  */
 447 #define UDAT_ABBR_UTC_TZ &quot;ZZZZ&quot;
 448 
 449 /* deprecated skeleton constants */
 450 
 451 #ifndef U_HIDE_DEPRECATED_API
 452 /**
 453  * Constant for date skeleton with standalone month.
 454  * @deprecated ICU 50 Use UDAT_MONTH instead.
 455  */
 456 #define UDAT_STANDALONE_MONTH           &quot;LLLL&quot;
 457 /**
 458  * Constant for date skeleton with standalone abbreviated month.
 459  * @deprecated ICU 50 Use UDAT_ABBR_MONTH instead.
 460  */
 461 #define UDAT_ABBR_STANDALONE_MONTH      &quot;LLL&quot;
 462 
 463 /**
 464  * Constant for date skeleton with hour, minute, and generic timezone.
 465  * @deprecated ICU 50 Use instead UDAT_HOUR_MINUTE UDAT_ABBR_GENERIC_TZ or some other timezone presentation.
 466  */
 467 #define UDAT_HOUR_MINUTE_GENERIC_TZ     &quot;jmv&quot;
 468 /**
 469  * Constant for date skeleton with hour, minute, and timezone.
 470  * @deprecated ICU 50 Use instead UDAT_HOUR_MINUTE UDAT_ABBR_SPECIFIC_TZ or some other timezone presentation.
 471  */
 472 #define UDAT_HOUR_MINUTE_TZ             &quot;jmz&quot;
 473 /**
 474  * Constant for date skeleton with hour and generic timezone.
 475  * @deprecated ICU 50 Use instead UDAT_HOUR UDAT_ABBR_GENERIC_TZ or some other timezone presentation.
 476  */
 477 #define UDAT_HOUR_GENERIC_TZ            &quot;jv&quot;
 478 /**
 479  * Constant for date skeleton with hour and timezone.
 480  * @deprecated ICU 50 Use instead UDAT_HOUR UDAT_ABBR_SPECIFIC_TZ or some other timezone presentation.
 481  */
 482 #define UDAT_HOUR_TZ                    &quot;jz&quot;
 483 #endif  /* U_HIDE_DEPRECATED_API */
 484 
 485 /**
 486  * FieldPosition and UFieldPosition selectors for format fields
 487  * defined by DateFormat and UDateFormat.
 488  * @stable ICU 3.0
 489  */
 490 typedef enum UDateFormatField {
 491     /**
 492      * FieldPosition and UFieldPosition selector for &#39;G&#39; field alignment,
 493      * corresponding to the UCAL_ERA field.
 494      * @stable ICU 3.0
 495      */
 496     UDAT_ERA_FIELD = 0,
 497 
 498     /**
 499      * FieldPosition and UFieldPosition selector for &#39;y&#39; field alignment,
 500      * corresponding to the UCAL_YEAR field.
 501      * @stable ICU 3.0
 502      */
 503     UDAT_YEAR_FIELD = 1,
 504 
 505     /**
 506      * FieldPosition and UFieldPosition selector for &#39;M&#39; field alignment,
 507      * corresponding to the UCAL_MONTH field.
 508      * @stable ICU 3.0
 509      */
 510     UDAT_MONTH_FIELD = 2,
 511 
 512     /**
 513      * FieldPosition and UFieldPosition selector for &#39;d&#39; field alignment,
 514      * corresponding to the UCAL_DATE field.
 515      * @stable ICU 3.0
 516      */
 517     UDAT_DATE_FIELD = 3,
 518 
 519     /**
 520      * FieldPosition and UFieldPosition selector for &#39;k&#39; field alignment,
 521      * corresponding to the UCAL_HOUR_OF_DAY field.
 522      * UDAT_HOUR_OF_DAY1_FIELD is used for the one-based 24-hour clock.
 523      * For example, 23:59 + 01:00 results in 24:59.
 524      * @stable ICU 3.0
 525      */
 526     UDAT_HOUR_OF_DAY1_FIELD = 4,
 527 
 528     /**
 529      * FieldPosition and UFieldPosition selector for &#39;H&#39; field alignment,
 530      * corresponding to the UCAL_HOUR_OF_DAY field.
 531      * UDAT_HOUR_OF_DAY0_FIELD is used for the zero-based 24-hour clock.
 532      * For example, 23:59 + 01:00 results in 00:59.
 533      * @stable ICU 3.0
 534      */
 535     UDAT_HOUR_OF_DAY0_FIELD = 5,
 536 
 537     /**
 538      * FieldPosition and UFieldPosition selector for &#39;m&#39; field alignment,
 539      * corresponding to the UCAL_MINUTE field.
 540      * @stable ICU 3.0
 541      */
 542     UDAT_MINUTE_FIELD = 6,
 543 
 544     /**
 545      * FieldPosition and UFieldPosition selector for &#39;s&#39; field alignment,
 546      * corresponding to the UCAL_SECOND field.
 547      * @stable ICU 3.0
 548      */
 549     UDAT_SECOND_FIELD = 7,
 550 
 551     /**
 552      * FieldPosition and UFieldPosition selector for &#39;S&#39; field alignment,
 553      * corresponding to the UCAL_MILLISECOND field.
 554      *
 555      * Note: Time formats that use &#39;S&#39; can display a maximum of three
 556      * significant digits for fractional seconds, corresponding to millisecond
 557      * resolution and a fractional seconds sub-pattern of SSS. If the
 558      * sub-pattern is S or SS, the fractional seconds value will be truncated
 559      * (not rounded) to the number of display places specified. If the
 560      * fractional seconds sub-pattern is longer than SSS, the additional
 561      * display places will be filled with zeros.
 562      * @stable ICU 3.0
 563      */
 564     UDAT_FRACTIONAL_SECOND_FIELD = 8,
 565 
 566     /**
 567      * FieldPosition and UFieldPosition selector for &#39;E&#39; field alignment,
 568      * corresponding to the UCAL_DAY_OF_WEEK field.
 569      * @stable ICU 3.0
 570      */
 571     UDAT_DAY_OF_WEEK_FIELD = 9,
 572 
 573     /**
 574      * FieldPosition and UFieldPosition selector for &#39;D&#39; field alignment,
 575      * corresponding to the UCAL_DAY_OF_YEAR field.
 576      * @stable ICU 3.0
 577      */
 578     UDAT_DAY_OF_YEAR_FIELD = 10,
 579 
 580     /**
 581      * FieldPosition and UFieldPosition selector for &#39;F&#39; field alignment,
 582      * corresponding to the UCAL_DAY_OF_WEEK_IN_MONTH field.
 583      * @stable ICU 3.0
 584      */
 585     UDAT_DAY_OF_WEEK_IN_MONTH_FIELD = 11,
 586 
 587     /**
 588      * FieldPosition and UFieldPosition selector for &#39;w&#39; field alignment,
 589      * corresponding to the UCAL_WEEK_OF_YEAR field.
 590      * @stable ICU 3.0
 591      */
 592     UDAT_WEEK_OF_YEAR_FIELD = 12,
 593 
 594     /**
 595      * FieldPosition and UFieldPosition selector for &#39;W&#39; field alignment,
 596      * corresponding to the UCAL_WEEK_OF_MONTH field.
 597      * @stable ICU 3.0
 598      */
 599     UDAT_WEEK_OF_MONTH_FIELD = 13,
 600 
 601     /**
 602      * FieldPosition and UFieldPosition selector for &#39;a&#39; field alignment,
 603      * corresponding to the UCAL_AM_PM field.
 604      * @stable ICU 3.0
 605      */
 606     UDAT_AM_PM_FIELD = 14,
 607 
 608     /**
 609      * FieldPosition and UFieldPosition selector for &#39;h&#39; field alignment,
 610      * corresponding to the UCAL_HOUR field.
 611      * UDAT_HOUR1_FIELD is used for the one-based 12-hour clock.
 612      * For example, 11:30 PM + 1 hour results in 12:30 AM.
 613      * @stable ICU 3.0
 614      */
 615     UDAT_HOUR1_FIELD = 15,
 616 
 617     /**
 618      * FieldPosition and UFieldPosition selector for &#39;K&#39; field alignment,
 619      * corresponding to the UCAL_HOUR field.
 620      * UDAT_HOUR0_FIELD is used for the zero-based 12-hour clock.
 621      * For example, 11:30 PM + 1 hour results in 00:30 AM.
 622      * @stable ICU 3.0
 623      */
 624     UDAT_HOUR0_FIELD = 16,
 625 
 626     /**
 627      * FieldPosition and UFieldPosition selector for &#39;z&#39; field alignment,
 628      * corresponding to the UCAL_ZONE_OFFSET and
 629      * UCAL_DST_OFFSET fields.
 630      * @stable ICU 3.0
 631      */
 632     UDAT_TIMEZONE_FIELD = 17,
 633 
 634     /**
 635      * FieldPosition and UFieldPosition selector for &#39;Y&#39; field alignment,
 636      * corresponding to the UCAL_YEAR_WOY field.
 637      * @stable ICU 3.0
 638      */
 639     UDAT_YEAR_WOY_FIELD = 18,
 640 
 641     /**
 642      * FieldPosition and UFieldPosition selector for &#39;e&#39; field alignment,
 643      * corresponding to the UCAL_DOW_LOCAL field.
 644      * @stable ICU 3.0
 645      */
 646     UDAT_DOW_LOCAL_FIELD = 19,
 647 
 648     /**
 649      * FieldPosition and UFieldPosition selector for &#39;u&#39; field alignment,
 650      * corresponding to the UCAL_EXTENDED_YEAR field.
 651      * @stable ICU 3.0
 652      */
 653     UDAT_EXTENDED_YEAR_FIELD = 20,
 654 
 655     /**
 656      * FieldPosition and UFieldPosition selector for &#39;g&#39; field alignment,
 657      * corresponding to the UCAL_JULIAN_DAY field.
 658      * @stable ICU 3.0
 659      */
 660     UDAT_JULIAN_DAY_FIELD = 21,
 661 
 662     /**
 663      * FieldPosition and UFieldPosition selector for &#39;A&#39; field alignment,
 664      * corresponding to the UCAL_MILLISECONDS_IN_DAY field.
 665      * @stable ICU 3.0
 666      */
 667     UDAT_MILLISECONDS_IN_DAY_FIELD = 22,
 668 
 669     /**
 670      * FieldPosition and UFieldPosition selector for &#39;Z&#39; field alignment,
 671      * corresponding to the UCAL_ZONE_OFFSET and
 672      * UCAL_DST_OFFSET fields.
 673      * @stable ICU 3.0
 674      */
 675     UDAT_TIMEZONE_RFC_FIELD = 23,
 676 
 677     /**
 678      * FieldPosition and UFieldPosition selector for &#39;v&#39; field alignment,
 679      * corresponding to the UCAL_ZONE_OFFSET field.
 680      * @stable ICU 3.4
 681      */
 682     UDAT_TIMEZONE_GENERIC_FIELD = 24,
 683     /**
 684      * FieldPosition selector for &#39;c&#39; field alignment,
 685      * corresponding to the {@link #UCAL_DOW_LOCAL} field.
 686      * This displays the stand alone day name, if available.
 687      * @stable ICU 3.4
 688      */
 689     UDAT_STANDALONE_DAY_FIELD = 25,
 690 
 691     /**
 692      * FieldPosition selector for &#39;L&#39; field alignment,
 693      * corresponding to the {@link #UCAL_MONTH} field.
 694      * This displays the stand alone month name, if available.
 695      * @stable ICU 3.4
 696      */
 697     UDAT_STANDALONE_MONTH_FIELD = 26,
 698 
 699     /**
 700      * FieldPosition selector for &quot;Q&quot; field alignment,
 701      * corresponding to quarters. This is implemented
 702      * using the {@link #UCAL_MONTH} field. This
 703      * displays the quarter.
 704      * @stable ICU 3.6
 705      */
 706     UDAT_QUARTER_FIELD = 27,
 707 
 708     /**
 709      * FieldPosition selector for the &quot;q&quot; field alignment,
 710      * corresponding to stand-alone quarters. This is
 711      * implemented using the {@link #UCAL_MONTH} field.
 712      * This displays the stand-alone quarter.
 713      * @stable ICU 3.6
 714      */
 715     UDAT_STANDALONE_QUARTER_FIELD = 28,
 716 
 717     /**
 718      * FieldPosition and UFieldPosition selector for &#39;V&#39; field alignment,
 719      * corresponding to the UCAL_ZONE_OFFSET field.
 720      * @stable ICU 3.8
 721      */
 722     UDAT_TIMEZONE_SPECIAL_FIELD = 29,
 723 
 724     /**
 725      * FieldPosition selector for &quot;U&quot; field alignment,
 726      * corresponding to cyclic year names. This is implemented
 727      * using the {@link #UCAL_YEAR} field. This displays
 728      * the cyclic year name, if available.
 729      * @stable ICU 49
 730      */
 731     UDAT_YEAR_NAME_FIELD = 30,
 732 
 733     /**
 734      * FieldPosition selector for &#39;O&#39; field alignment,
 735      * corresponding to the UCAL_ZONE_OFFSET and UCAL_DST_OFFSETfields.
 736      * This displays the localized GMT format.
 737      * @stable ICU 51
 738      */
 739     UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD = 31,
 740 
 741     /**
 742      * FieldPosition selector for &#39;X&#39; field alignment,
 743      * corresponding to the UCAL_ZONE_OFFSET and UCAL_DST_OFFSETfields.
 744      * This displays the ISO 8601 local time offset format or UTC indicator (&quot;Z&quot;).
 745      * @stable ICU 51
 746      */
 747     UDAT_TIMEZONE_ISO_FIELD = 32,
 748 
 749     /**
 750      * FieldPosition selector for &#39;x&#39; field alignment,
 751      * corresponding to the UCAL_ZONE_OFFSET and UCAL_DST_OFFSET fields.
 752      * This displays the ISO 8601 local time offset format.
 753      * @stable ICU 51
 754      */
 755     UDAT_TIMEZONE_ISO_LOCAL_FIELD = 33,
 756 
 757 #ifndef U_HIDE_INTERNAL_API
 758     /**
 759      * FieldPosition and UFieldPosition selector for &#39;r&#39; field alignment,
 760      * no directly corresponding UCAL_ field.
 761      * @internal ICU 53
 762      */
 763     UDAT_RELATED_YEAR_FIELD = 34,
 764 #endif  /* U_HIDE_INTERNAL_API */
 765 
 766     /**
 767      * FieldPosition selector for &#39;b&#39; field alignment.
 768      * Displays midnight and noon for 12am and 12pm, respectively, if available;
 769      * otherwise fall back to AM / PM.
 770      * @stable ICU 57
 771      */
 772     UDAT_AM_PM_MIDNIGHT_NOON_FIELD = 35,
 773 
 774     /* FieldPosition selector for &#39;B&#39; field alignment.
 775      * Displays flexible day periods, such as &quot;in the morning&quot;, if available.
 776      * @stable ICU 57
 777      */
 778     UDAT_FLEXIBLE_DAY_PERIOD_FIELD = 36,
 779 
 780 #ifndef U_HIDE_INTERNAL_API
 781     /**
 782      * FieldPosition and UFieldPosition selector for time separator,
 783      * no corresponding UCAL_ field. No pattern character is currently
 784      * defined for this.
 785      * @internal
 786      */
 787     UDAT_TIME_SEPARATOR_FIELD = 37,
 788 #endif  /* U_HIDE_INTERNAL_API */
 789 
 790 #ifndef U_HIDE_DEPRECATED_API
 791     /**
 792      * Number of FieldPosition and UFieldPosition selectors for
 793      * DateFormat and UDateFormat.
 794      * Valid selectors range from 0 to UDAT_FIELD_COUNT-1.
 795      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
 796      */
 797     UDAT_FIELD_COUNT = 38
 798 #endif  /* U_HIDE_DEPRECATED_API */
 799 } UDateFormatField;
 800 
 801 
 802 #ifndef U_HIDE_INTERNAL_API
 803 /**
 804  * Is a pattern character defined for UDAT_TIME_SEPARATOR_FIELD?
 805  * In ICU 55 it was COLON, but that was withdrawn in ICU 56.
 806  * @internal ICU 56
 807  */
 808 #define UDAT_HAS_PATTERN_CHAR_FOR_TIME_SEPARATOR 0
 809 #endif /* U_HIDE_INTERNAL_API */
 810 
 811 
 812 /**
 813  * Maps from a UDateFormatField to the corresponding UCalendarDateFields.
 814  * Note: since the mapping is many-to-one, there is no inverse mapping.
 815  * @param field the UDateFormatField.
 816  * @return the UCalendarDateField.  This will be UCAL_FIELD_COUNT in case
 817  * of error (e.g., the input field is UDAT_FIELD_COUNT).
 818  * @stable ICU 4.4
 819  */
 820 U_CAPI UCalendarDateFields U_EXPORT2
 821 udat_toCalendarDateField(UDateFormatField field);
 822 
 823 
 824 /**
 825  * Open a new UDateFormat for formatting and parsing dates and times.
 826  * A UDateFormat may be used to format dates in calls to {@link #udat_format },
 827  * and to parse dates in calls to {@link #udat_parse }.
 828  * @param timeStyle The style used to format times; one of UDAT_FULL, UDAT_LONG,
 829  * UDAT_MEDIUM, UDAT_SHORT, UDAT_DEFAULT, or UDAT_NONE (relative time styles
 830  * are not currently supported).
 831  * When the pattern parameter is used, pass in UDAT_PATTERN for both timeStyle and dateStyle.
 832  * @param dateStyle The style used to format dates; one of UDAT_FULL, UDAT_LONG,
 833  * UDAT_MEDIUM, UDAT_SHORT, UDAT_DEFAULT, UDAT_FULL_RELATIVE, UDAT_LONG_RELATIVE,
 834  * UDAT_MEDIUM_RELATIVE, UDAT_SHORT_RELATIVE, or UDAT_NONE.
 835  * When the pattern parameter is used, pass in UDAT_PATTERN for both timeStyle and dateStyle.
 836  * As currently implemented,
 837  * relative date formatting only affects a limited range of calendar days before or
 838  * after the current date, based on the CLDR &amp;lt;field type=&quot;day&quot;&amp;gt;/&amp;lt;relative&amp;gt; data: For
 839  * example, in English, &quot;Yesterday&quot;, &quot;Today&quot;, and &quot;Tomorrow&quot;. Outside of this range,
 840  * dates are formatted using the corresponding non-relative style.
 841  * @param locale The locale specifying the formatting conventions
 842  * @param tzID A timezone ID specifying the timezone to use.  If 0, use
 843  * the default timezone.
 844  * @param tzIDLength The length of tzID, or -1 if null-terminated.
 845  * @param pattern A pattern specifying the format to use.
 846  * @param patternLength The number of characters in the pattern, or -1 if null-terminated.
 847  * @param status A pointer to an UErrorCode to receive any errors
 848  * @return A pointer to a UDateFormat to use for formatting dates and times, or 0 if
 849  * an error occurred.
 850  * @stable ICU 2.0
 851  */
 852 U_CAPI UDateFormat* U_EXPORT2
 853 udat_open(UDateFormatStyle  timeStyle,
 854           UDateFormatStyle  dateStyle,
 855           const char        *locale,
 856           const UChar       *tzID,
 857           int32_t           tzIDLength,
 858           const UChar       *pattern,
 859           int32_t           patternLength,
 860           UErrorCode        *status);
 861 
 862 
 863 /**
 864 * Close a UDateFormat.
 865 * Once closed, a UDateFormat may no longer be used.
 866 * @param format The formatter to close.
 867 * @stable ICU 2.0
 868 */
 869 U_CAPI void U_EXPORT2
 870 udat_close(UDateFormat* format);
 871 
 872 
 873 /**
 874  * DateFormat boolean attributes
 875  *
 876  * @stable ICU 53
 877  */
 878 typedef enum UDateFormatBooleanAttribute {
 879    /**
 880      * indicates whether whitespace is allowed. Includes trailing dot tolerance.
 881      * @stable ICU 53
 882      */
 883     UDAT_PARSE_ALLOW_WHITESPACE = 0,
 884     /**
 885      * indicates tolerance of numeric data when String data may be assumed. eg: UDAT_YEAR_NAME_FIELD,
 886      * UDAT_STANDALONE_MONTH_FIELD, UDAT_DAY_OF_WEEK_FIELD
 887      * @stable ICU 53
 888      */
 889     UDAT_PARSE_ALLOW_NUMERIC = 1,
 890     /**
 891      * indicates tolerance of a partial literal match
 892      * e.g. accepting &quot;--mon-02-march-2011&quot; for a pattern of &quot;&#39;--: &#39;EEE-WW-MMMM-yyyy&quot;
 893      * @stable ICU 56
 894      */
 895     UDAT_PARSE_PARTIAL_LITERAL_MATCH = 2,
 896     /**
 897      * indicates tolerance of pattern mismatch between input data and specified format pattern.
 898      * e.g. accepting &quot;September&quot; for a month pattern of MMM (&quot;Sep&quot;)
 899      * @stable ICU 56
 900      */
 901     UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH = 3,
 902 
 903     /* Do not conditionalize the following with #ifndef U_HIDE_DEPRECATED_API,
 904      * it is needed for layout of DateFormat object. */
 905     /**
 906      * One more than the highest normal UDateFormatBooleanAttribute value.
 907      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
 908      */
 909     UDAT_BOOLEAN_ATTRIBUTE_COUNT = 4
 910 } UDateFormatBooleanAttribute;
 911 
 912 /**
 913  * Get a boolean attribute associated with a UDateFormat.
 914  * An example would be a true value for a key of UDAT_PARSE_ALLOW_WHITESPACE indicating allowing whitespace leniency.
 915  * If the formatter does not understand the attribute, -1 is returned.
 916  * @param fmt The formatter to query.
 917  * @param attr The attribute to query; e.g. UDAT_PARSE_ALLOW_WHITESPACE.
 918  * @param status A pointer to an UErrorCode to receive any errors
 919  * @return The value of attr.
 920  * @stable ICU 53
 921  */
 922 U_CAPI UBool U_EXPORT2
 923 udat_getBooleanAttribute(const UDateFormat* fmt, UDateFormatBooleanAttribute attr, UErrorCode* status);
 924 
 925 /**
 926  * Set a boolean attribute associated with a UDateFormat.
 927  * An example of a boolean attribute is parse leniency control.  If the formatter does not understand
 928  * the attribute, the call is ignored.
 929  * @param fmt The formatter to set.
 930  * @param attr The attribute to set; one of UDAT_PARSE_ALLOW_WHITESPACE or UDAT_PARSE_ALLOW_NUMERIC
 931  * @param newValue The new value of attr.
 932  * @param status A pointer to an UErrorCode to receive any errors
 933  * @stable ICU 53
 934  */
 935 U_CAPI void U_EXPORT2
 936 udat_setBooleanAttribute(UDateFormat *fmt, UDateFormatBooleanAttribute attr, UBool newValue, UErrorCode* status);
 937 
 938 
 939 
 940 #if U_SHOW_CPLUSPLUS_API
 941 
 942 U_NAMESPACE_BEGIN
 943 
 944 /**
 945  * \class LocalUDateFormatPointer
 946  * &quot;Smart pointer&quot; class, closes a UDateFormat via udat_close().
 947  * For most methods see the LocalPointerBase base class.
 948  *
 949  * @see LocalPointerBase
 950  * @see LocalPointer
 951  * @stable ICU 4.4
 952  */
 953 U_DEFINE_LOCAL_OPEN_POINTER(LocalUDateFormatPointer, UDateFormat, udat_close);
 954 
 955 U_NAMESPACE_END
 956 
 957 #endif
 958 
 959 /**
 960  * Open a copy of a UDateFormat.
 961  * This function performs a deep copy.
 962  * @param fmt The format to copy
 963  * @param status A pointer to an UErrorCode to receive any errors.
 964  * @return A pointer to a UDateFormat identical to fmt.
 965  * @stable ICU 2.0
 966  */
 967 U_CAPI UDateFormat* U_EXPORT2
 968 udat_clone(const UDateFormat *fmt,
 969        UErrorCode *status);
 970 
 971 /**
 972 * Format a date using a UDateFormat.
 973 * The date will be formatted using the conventions specified in {@link #udat_open }
 974 * @param format The formatter to use
 975 * @param dateToFormat The date to format
 976 * @param result A pointer to a buffer to receive the formatted number.
 977 * @param resultLength The maximum size of result.
 978 * @param position A pointer to a UFieldPosition.  On input, position-&gt;field
 979 * is read.  On output, position-&gt;beginIndex and position-&gt;endIndex indicate
 980 * the beginning and ending indices of field number position-&gt;field, if such
 981 * a field exists.  This parameter may be NULL, in which case no field
 982 * position data is returned.
 983 * @param status A pointer to an UErrorCode to receive any errors
 984 * @return The total buffer size needed; if greater than resultLength, the output was truncated.
 985 * @see udat_parse
 986 * @see UFieldPosition
 987 * @stable ICU 2.0
 988 */
 989 U_CAPI int32_t U_EXPORT2
 990 udat_format(    const    UDateFormat*    format,
 991                         UDate           dateToFormat,
 992                         UChar*          result,
 993                         int32_t         resultLength,
 994                         UFieldPosition* position,
 995                         UErrorCode*     status);
 996 
 997 /**
 998 * Format a date using an UDateFormat.
 999 * The date will be formatted using the conventions specified in {@link #udat_open }
1000 * @param format The formatter to use
1001 * @param calendar The calendar to format. The calendar instance might be
1002 *                 mutated if fields are not yet fully calculated, though
1003 *                 the function won&#39;t change the logical date and time held
1004 *                 by the instance.
1005 * @param result A pointer to a buffer to receive the formatted number.
1006 * @param capacity The maximum size of result.
1007 * @param position A pointer to a UFieldPosition.  On input, position-&gt;field
1008 * is read.  On output, position-&gt;beginIndex and position-&gt;endIndex indicate
1009 * the beginning and ending indices of field number position-&gt;field, if such
1010 * a field exists.  This parameter may be NULL, in which case no field
1011 * position data is returned.
1012 * @param status A pointer to an UErrorCode to receive any errors
1013 * @return The total buffer size needed; if greater than resultLength, the output was truncated.
1014 * @see udat_format
1015 * @see udat_parseCalendar
1016 * @see UFieldPosition
1017 * @stable ICU 55
1018 */
1019 U_CAPI int32_t U_EXPORT2
1020 udat_formatCalendar(    const UDateFormat*  format,
1021                         UCalendar*      calendar,
1022                         UChar*          result,
1023                         int32_t         capacity,
1024                         UFieldPosition* position,
1025                         UErrorCode*     status);
1026 
1027 /**
1028 * Format a date using a UDateFormat.
1029 * The date will be formatted using the conventions specified in {@link #udat_open}
1030 * @param format
1031 *          The formatter to use
1032 * @param dateToFormat
1033 *          The date to format
1034 * @param result
1035 *          A pointer to a buffer to receive the formatted number.
1036 * @param resultLength
1037 *          The maximum size of result.
1038 * @param fpositer
1039 *          A pointer to a UFieldPositionIterator created by {@link #ufieldpositer_open}
1040 *          (may be NULL if field position information is not needed). Any
1041 *          iteration information already present in the UFieldPositionIterator
1042 *          will be deleted, and the iterator will be reset to apply to the
1043 *          fields in the formatted string created by this function call; the
1044 *          field values provided by {@link #ufieldpositer_next} will be from the
1045 *          UDateFormatField enum.
1046 * @param status
1047 *          A pointer to a UErrorCode to receive any errors
1048 * @return
1049 *          The total buffer size needed; if greater than resultLength, the output was truncated.
1050 * @see udat_parse
1051 * @see UFieldPositionIterator
1052 * @stable ICU 55
1053 */
1054 U_CAPI int32_t U_EXPORT2
1055 udat_formatForFields(   const UDateFormat* format,
1056                         UDate           dateToFormat,
1057                         UChar*          result,
1058                         int32_t         resultLength,
1059                         UFieldPositionIterator* fpositer,
1060                         UErrorCode*     status);
1061 
1062 /**
1063 * Format a date using a UDateFormat.
1064 * The date will be formatted using the conventions specified in {@link #udat_open }
1065 * @param format
1066 *          The formatter to use
1067 * @param calendar
1068 *          The calendar to format. The calendar instance might be mutated if fields
1069 *          are not yet fully calculated, though the function won&#39;t change the logical
1070 *          date and time held by the instance.
1071 * @param result
1072 *          A pointer to a buffer to receive the formatted number.
1073 * @param capacity
1074 *          The maximum size of result.
1075 * @param fpositer
1076 *          A pointer to a UFieldPositionIterator created by {@link #ufieldpositer_open}
1077 *          (may be NULL if field position information is not needed). Any
1078 *          iteration information already present in the UFieldPositionIterator
1079 *          will be deleted, and the iterator will be reset to apply to the
1080 *          fields in the formatted string created by this function call; the
1081 *          field values provided by {@link #ufieldpositer_next} will be from the
1082 *          UDateFormatField enum.
1083 * @param status
1084 *          A pointer to a UErrorCode to receive any errors
1085 * @return
1086 *          The total buffer size needed; if greater than resultLength, the output was truncated.
1087 * @see udat_format
1088 * @see udat_parseCalendar
1089 * @see UFieldPositionIterator
1090 * @stable ICU 55
1091 */
1092 U_CAPI int32_t U_EXPORT2
1093 udat_formatCalendarForFields( const UDateFormat* format,
1094                         UCalendar*      calendar,
1095                         UChar*          result,
1096                         int32_t         capacity,
1097                         UFieldPositionIterator* fpositer,
1098                         UErrorCode*     status);
1099 
1100 
1101 /**
1102 * Parse a string into an date/time using a UDateFormat.
1103 * The date will be parsed using the conventions specified in {@link #udat_open }.
1104 * &lt;P&gt;
1105 * Note that the normal date formats associated with some calendars - such
1106 * as the Chinese lunar calendar - do not specify enough fields to enable
1107 * dates to be parsed unambiguously. In the case of the Chinese lunar
1108 * calendar, while the year within the current 60-year cycle is specified,
1109 * the number of such cycles since the start date of the calendar (in the
1110 * UCAL_ERA field of the UCalendar object) is not normally part of the format,
1111 * and parsing may assume the wrong era. For cases such as this it is
1112 * recommended that clients parse using udat_parseCalendar with the UCalendar
1113 * passed in set to the current date, or to a date within the era/cycle that
1114 * should be assumed if absent in the format.
1115 *
1116 * @param format The formatter to use.
1117 * @param text The text to parse.
1118 * @param textLength The length of text, or -1 if null-terminated.
1119 * @param parsePos If not 0, on input a pointer to an integer specifying the offset at which
1120 * to begin parsing.  If not 0, on output the offset at which parsing ended.
1121 * @param status A pointer to an UErrorCode to receive any errors
1122 * @return The value of the parsed date/time
1123 * @see udat_format
1124 * @stable ICU 2.0
1125 */
1126 U_CAPI UDate U_EXPORT2
1127 udat_parse(const    UDateFormat*    format,
1128            const    UChar*          text,
1129                     int32_t         textLength,
1130                     int32_t         *parsePos,
1131                     UErrorCode      *status);
1132 
1133 /**
1134 * Parse a string into an date/time using a UDateFormat.
1135 * The date will be parsed using the conventions specified in {@link #udat_open }.
1136 * @param format The formatter to use.
1137 * @param calendar A calendar set on input to the date and time to be used for
1138 *                 missing values in the date/time string being parsed, and set
1139 *                 on output to the parsed date/time. When the calendar type is
1140 *                 different from the internal calendar held by the UDateFormat
1141 *                 instance, the internal calendar will be cloned to a work
1142 *                 calendar set to the same milliseconds and time zone as this
1143 *                 calendar parameter, field values will be parsed based on the
1144 *                 work calendar, then the result (milliseconds and time zone)
1145 *                 will be set in this calendar.
1146 * @param text The text to parse.
1147 * @param textLength The length of text, or -1 if null-terminated.
1148 * @param parsePos If not 0, on input a pointer to an integer specifying the offset at which
1149 * to begin parsing.  If not 0, on output the offset at which parsing ended.
1150 * @param status A pointer to an UErrorCode to receive any errors
1151 * @see udat_format
1152 * @stable ICU 2.0
1153 */
1154 U_CAPI void U_EXPORT2
1155 udat_parseCalendar(const    UDateFormat*    format,
1156                             UCalendar*      calendar,
1157                    const    UChar*          text,
1158                             int32_t         textLength,
1159                             int32_t         *parsePos,
1160                             UErrorCode      *status);
1161 
1162 /**
1163 * Determine if an UDateFormat will perform lenient parsing.
1164 * With lenient parsing, the parser may use heuristics to interpret inputs that do not
1165 * precisely match the pattern. With strict parsing, inputs must match the pattern.
1166 * @param fmt The formatter to query
1167 * @return TRUE if fmt is set to perform lenient parsing, FALSE otherwise.
1168 * @see udat_setLenient
1169 * @stable ICU 2.0
1170 */
1171 U_CAPI UBool U_EXPORT2
1172 udat_isLenient(const UDateFormat* fmt);
1173 
1174 /**
1175 * Specify whether an UDateFormat will perform lenient parsing.
1176 * With lenient parsing, the parser may use heuristics to interpret inputs that do not
1177 * precisely match the pattern. With strict parsing, inputs must match the pattern.
1178 * @param fmt The formatter to set
1179 * @param isLenient TRUE if fmt should perform lenient parsing, FALSE otherwise.
1180 * @see dat_isLenient
1181 * @stable ICU 2.0
1182 */
1183 U_CAPI void U_EXPORT2
1184 udat_setLenient(    UDateFormat*    fmt,
1185                     UBool          isLenient);
1186 
1187 /**
1188 * Get the UCalendar associated with an UDateFormat.
1189 * A UDateFormat uses a UCalendar to convert a raw value to, for example,
1190 * the day of the week.
1191 * @param fmt The formatter to query.
1192 * @return A pointer to the UCalendar used by fmt.
1193 * @see udat_setCalendar
1194 * @stable ICU 2.0
1195 */
1196 U_CAPI const UCalendar* U_EXPORT2
1197 udat_getCalendar(const UDateFormat* fmt);
1198 
1199 /**
1200 * Set the UCalendar associated with an UDateFormat.
1201 * A UDateFormat uses a UCalendar to convert a raw value to, for example,
1202 * the day of the week.
1203 * @param fmt The formatter to set.
1204 * @param calendarToSet A pointer to an UCalendar to be used by fmt.
1205 * @see udat_setCalendar
1206 * @stable ICU 2.0
1207 */
1208 U_CAPI void U_EXPORT2
1209 udat_setCalendar(            UDateFormat*    fmt,
1210                     const   UCalendar*      calendarToSet);
1211 
1212 /**
1213 * Get the UNumberFormat associated with an UDateFormat.
1214 * A UDateFormat uses a UNumberFormat to format numbers within a date,
1215 * for example the day number.
1216 * @param fmt The formatter to query.
1217 * @return A pointer to the UNumberFormat used by fmt to format numbers.
1218 * @see udat_setNumberFormat
1219 * @stable ICU 2.0
1220 */
1221 U_CAPI const UNumberFormat* U_EXPORT2
1222 udat_getNumberFormat(const UDateFormat* fmt);
1223 
1224 /**
1225 * Get the UNumberFormat for specific field associated with an UDateFormat.
1226 * For example: &#39;y&#39; for year and &#39;M&#39; for month
1227 * @param fmt The formatter to query.
1228 * @param field the field to query
1229 * @return A pointer to the UNumberFormat used by fmt to format field numbers.
1230 * @see udat_setNumberFormatForField
1231 * @stable ICU 54
1232 */
1233 U_CAPI const UNumberFormat* U_EXPORT2
1234 udat_getNumberFormatForField(const UDateFormat* fmt, UChar field);
1235 
1236 /**
1237 * Set the UNumberFormat for specific field associated with an UDateFormat.
1238 * It can be a single field like: &quot;y&quot;(year) or &quot;M&quot;(month)
1239 * It can be several field combined together: &quot;yM&quot;(year and month)
1240 * Note:
1241 * 1 symbol field is enough for multiple symbol field (so &quot;y&quot; will override &quot;yy&quot;, &quot;yyy&quot;)
1242 * If the field is not numeric, then override has no effect (like &quot;MMM&quot; will use abbreviation, not numerical field)
1243 *
1244 * @param fields the fields to set
1245 * @param fmt The formatter to set.
1246 * @param numberFormatToSet A pointer to the UNumberFormat to be used by fmt to format numbers.
1247 * @param status error code passed around (memory allocation or invalid fields)
1248 * @see udat_getNumberFormatForField
1249 * @stable ICU 54
1250 */
1251 U_CAPI void U_EXPORT2
1252 udat_adoptNumberFormatForFields(  UDateFormat* fmt,
1253                             const UChar* fields,
1254                                   UNumberFormat*  numberFormatToSet,
1255                                   UErrorCode* status);
1256 /**
1257 * Set the UNumberFormat associated with an UDateFormat.
1258 * A UDateFormat uses a UNumberFormat to format numbers within a date,
1259 * for example the day number.
1260 * This method also clears per field NumberFormat instances previously
1261 * set by {@see udat_setNumberFormatForField}
1262 * @param fmt The formatter to set.
1263 * @param numberFormatToSet A pointer to the UNumberFormat to be used by fmt to format numbers.
1264 * @see udat_getNumberFormat
1265 * @see udat_setNumberFormatForField
1266 * @stable ICU 2.0
1267 */
1268 U_CAPI void U_EXPORT2
1269 udat_setNumberFormat(            UDateFormat*    fmt,
1270                         const   UNumberFormat*  numberFormatToSet);
1271 /**
1272 * Adopt the UNumberFormat associated with an UDateFormat.
1273 * A UDateFormat uses a UNumberFormat to format numbers within a date,
1274 * for example the day number.
1275 * @param fmt The formatter to set.
1276 * @param numberFormatToAdopt A pointer to the UNumberFormat to be used by fmt to format numbers.
1277 * @see udat_getNumberFormat
1278 * @stable ICU 54
1279 */
1280 U_CAPI void U_EXPORT2
1281 udat_adoptNumberFormat(            UDateFormat*    fmt,
1282                                    UNumberFormat*  numberFormatToAdopt);
1283 /**
1284 * Get a locale for which date/time formatting patterns are available.
1285 * A UDateFormat in a locale returned by this function will perform the correct
1286 * formatting and parsing for the locale.
1287 * @param localeIndex The index of the desired locale.
1288 * @return A locale for which date/time formatting patterns are available, or 0 if none.
1289 * @see udat_countAvailable
1290 * @stable ICU 2.0
1291 */
1292 U_CAPI const char* U_EXPORT2
1293 udat_getAvailable(int32_t localeIndex);
1294 
1295 /**
1296 * Determine how many locales have date/time  formatting patterns available.
1297 * This function is most useful as determining the loop ending condition for
1298 * calls to {@link #udat_getAvailable }.
1299 * @return The number of locales for which date/time formatting patterns are available.
1300 * @see udat_getAvailable
1301 * @stable ICU 2.0
1302 */
1303 U_CAPI int32_t U_EXPORT2
1304 udat_countAvailable(void);
1305 
1306 /**
1307 * Get the year relative to which all 2-digit years are interpreted.
1308 * For example, if the 2-digit start year is 2100, the year 99 will be
1309 * interpreted as 2199.
1310 * @param fmt The formatter to query.
1311 * @param status A pointer to an UErrorCode to receive any errors
1312 * @return The year relative to which all 2-digit years are interpreted.
1313 * @see udat_Set2DigitYearStart
1314 * @stable ICU 2.0
1315 */
1316 U_CAPI UDate U_EXPORT2
1317 udat_get2DigitYearStart(    const   UDateFormat     *fmt,
1318                                     UErrorCode      *status);
1319 
1320 /**
1321 * Set the year relative to which all 2-digit years will be interpreted.
1322 * For example, if the 2-digit start year is 2100, the year 99 will be
1323 * interpreted as 2199.
1324 * @param fmt The formatter to set.
1325 * @param d The year relative to which all 2-digit years will be interpreted.
1326 * @param status A pointer to an UErrorCode to receive any errors
1327 * @see udat_Set2DigitYearStart
1328 * @stable ICU 2.0
1329 */
1330 U_CAPI void U_EXPORT2
1331 udat_set2DigitYearStart(    UDateFormat     *fmt,
1332                             UDate           d,
1333                             UErrorCode      *status);
1334 
1335 /**
1336 * Extract the pattern from a UDateFormat.
1337 * The pattern will follow the pattern syntax rules.
1338 * @param fmt The formatter to query.
1339 * @param localized TRUE if the pattern should be localized, FALSE otherwise.
1340 * @param result A pointer to a buffer to receive the pattern.
1341 * @param resultLength The maximum size of result.
1342 * @param status A pointer to an UErrorCode to receive any errors
1343 * @return The total buffer size needed; if greater than resultLength, the output was truncated.
1344 * @see udat_applyPattern
1345 * @stable ICU 2.0
1346 */
1347 U_CAPI int32_t U_EXPORT2
1348 udat_toPattern(    const   UDateFormat     *fmt,
1349                         UBool          localized,
1350                         UChar           *result,
1351                         int32_t         resultLength,
1352                         UErrorCode      *status);
1353 
1354 /**
1355 * Set the pattern used by an UDateFormat.
1356 * The pattern should follow the pattern syntax rules.
1357 * @param format The formatter to set.
1358 * @param localized TRUE if the pattern is localized, FALSE otherwise.
1359 * @param pattern The new pattern
1360 * @param patternLength The length of pattern, or -1 if null-terminated.
1361 * @see udat_toPattern
1362 * @stable ICU 2.0
1363 */
1364 U_CAPI void U_EXPORT2
1365 udat_applyPattern(            UDateFormat     *format,
1366                             UBool          localized,
1367                     const   UChar           *pattern,
1368                             int32_t         patternLength);
1369 
1370 /**
1371  * The possible types of date format symbols
1372  * @stable ICU 2.6
1373  */
1374 typedef enum UDateFormatSymbolType {
1375     /** The era names, for example AD */
1376     UDAT_ERAS,
1377     /** The month names, for example February */
1378     UDAT_MONTHS,
1379     /** The short month names, for example Feb. */
1380     UDAT_SHORT_MONTHS,
1381     /** The CLDR-style format &quot;wide&quot; weekday names, for example Monday */
1382     UDAT_WEEKDAYS,
1383     /**
1384      * The CLDR-style format &quot;abbreviated&quot; (not &quot;short&quot;) weekday names, for example &quot;Mon.&quot;
1385      * For the CLDR-style format &quot;short&quot; weekday names, use UDAT_SHORTER_WEEKDAYS.
1386      */
1387     UDAT_SHORT_WEEKDAYS,
1388     /** The AM/PM names, for example AM */
1389     UDAT_AM_PMS,
1390     /** The localized characters */
1391     UDAT_LOCALIZED_CHARS,
1392     /** The long era names, for example Anno Domini */
1393     UDAT_ERA_NAMES,
1394     /** The narrow month names, for example F */
1395     UDAT_NARROW_MONTHS,
1396     /** The CLDR-style format &quot;narrow&quot; weekday names, for example &quot;M&quot; */
1397     UDAT_NARROW_WEEKDAYS,
1398     /** Standalone context versions of months */
1399     UDAT_STANDALONE_MONTHS,
1400     UDAT_STANDALONE_SHORT_MONTHS,
1401     UDAT_STANDALONE_NARROW_MONTHS,
1402     /** The CLDR-style stand-alone &quot;wide&quot; weekday names */
1403     UDAT_STANDALONE_WEEKDAYS,
1404     /**
1405      * The CLDR-style stand-alone &quot;abbreviated&quot; (not &quot;short&quot;) weekday names.
1406      * For the CLDR-style stand-alone &quot;short&quot; weekday names, use UDAT_STANDALONE_SHORTER_WEEKDAYS.
1407      */
1408     UDAT_STANDALONE_SHORT_WEEKDAYS,
1409     /** The CLDR-style stand-alone &quot;narrow&quot; weekday names */
1410     UDAT_STANDALONE_NARROW_WEEKDAYS,
1411     /** The quarters, for example 1st Quarter */
1412     UDAT_QUARTERS,
1413     /** The short quarter names, for example Q1 */
1414     UDAT_SHORT_QUARTERS,
1415     /** Standalone context versions of quarters */
1416     UDAT_STANDALONE_QUARTERS,
1417     UDAT_STANDALONE_SHORT_QUARTERS,
1418     /**
1419      * The CLDR-style short weekday names, e.g. &quot;Su&quot;, Mo&quot;, etc.
1420      * These are named &quot;SHORTER&quot; to contrast with the constants using _SHORT_
1421      * above, which actually get the CLDR-style *abbreviated* versions of the
1422      * corresponding names.
1423      * @stable ICU 51
1424      */
1425     UDAT_SHORTER_WEEKDAYS,
1426     /**
1427      * Standalone version of UDAT_SHORTER_WEEKDAYS.
1428      * @stable ICU 51
1429      */
1430     UDAT_STANDALONE_SHORTER_WEEKDAYS,
1431     /**
1432      * Cyclic year names (only supported for some calendars, and only for FORMAT usage;
1433      * udat_setSymbols not supported for UDAT_CYCLIC_YEARS_WIDE)
1434      * @stable ICU 54
1435      */
1436     UDAT_CYCLIC_YEARS_WIDE,
1437     /**
1438      * Cyclic year names (only supported for some calendars, and only for FORMAT usage)
1439      * @stable ICU 54
1440      */
1441     UDAT_CYCLIC_YEARS_ABBREVIATED,
1442     /**
1443      * Cyclic year names (only supported for some calendars, and only for FORMAT usage;
1444      * udat_setSymbols not supported for UDAT_CYCLIC_YEARS_NARROW)
1445      * @stable ICU 54
1446      */
1447     UDAT_CYCLIC_YEARS_NARROW,
1448     /**
1449      * Calendar zodiac  names (only supported for some calendars, and only for FORMAT usage;
1450      * udat_setSymbols not supported for UDAT_ZODIAC_NAMES_WIDE)
1451      * @stable ICU 54
1452      */
1453     UDAT_ZODIAC_NAMES_WIDE,
1454     /**
1455      * Calendar zodiac  names (only supported for some calendars, and only for FORMAT usage)
1456      * @stable ICU 54
1457      */
1458     UDAT_ZODIAC_NAMES_ABBREVIATED,
1459     /**
1460      * Calendar zodiac  names (only supported for some calendars, and only for FORMAT usage;
1461      * udat_setSymbols not supported for UDAT_ZODIAC_NAMES_NARROW)
1462      * @stable ICU 54
1463      */
1464     UDAT_ZODIAC_NAMES_NARROW
1465 } UDateFormatSymbolType;
1466 
1467 struct UDateFormatSymbols;
1468 /** Date format symbols.
1469  *  For usage in C programs.
1470  *  @stable ICU 2.6
1471  */
1472 typedef struct UDateFormatSymbols UDateFormatSymbols;
1473 
1474 /**
1475 * Get the symbols associated with an UDateFormat.
1476 * The symbols are what a UDateFormat uses to represent locale-specific data,
1477 * for example month or day names.
1478 * @param fmt The formatter to query.
1479 * @param type The type of symbols to get.  One of UDAT_ERAS, UDAT_MONTHS, UDAT_SHORT_MONTHS,
1480 * UDAT_WEEKDAYS, UDAT_SHORT_WEEKDAYS, UDAT_AM_PMS, or UDAT_LOCALIZED_CHARS
1481 * @param symbolIndex The desired symbol of type type.
1482 * @param result A pointer to a buffer to receive the pattern.
1483 * @param resultLength The maximum size of result.
1484 * @param status A pointer to an UErrorCode to receive any errors
1485 * @return The total buffer size needed; if greater than resultLength, the output was truncated.
1486 * @see udat_countSymbols
1487 * @see udat_setSymbols
1488 * @stable ICU 2.0
1489 */
1490 U_CAPI int32_t U_EXPORT2
1491 udat_getSymbols(const   UDateFormat             *fmt,
1492                         UDateFormatSymbolType   type,
1493                         int32_t                 symbolIndex,
1494                         UChar                   *result,
1495                         int32_t                 resultLength,
1496                         UErrorCode              *status);
1497 
1498 /**
1499 * Count the number of particular symbols for an UDateFormat.
1500 * This function is most useful as for detemining the loop termination condition
1501 * for calls to {@link #udat_getSymbols }.
1502 * @param fmt The formatter to query.
1503 * @param type The type of symbols to count.  One of UDAT_ERAS, UDAT_MONTHS, UDAT_SHORT_MONTHS,
1504 * UDAT_WEEKDAYS, UDAT_SHORT_WEEKDAYS, UDAT_AM_PMS, or UDAT_LOCALIZED_CHARS
1505 * @return The number of symbols of type type.
1506 * @see udat_getSymbols
1507 * @see udat_setSymbols
1508 * @stable ICU 2.0
1509 */
1510 U_CAPI int32_t U_EXPORT2
1511 udat_countSymbols(    const    UDateFormat                *fmt,
1512                             UDateFormatSymbolType    type);
1513 
1514 /**
1515 * Set the symbols associated with an UDateFormat.
1516 * The symbols are what a UDateFormat uses to represent locale-specific data,
1517 * for example month or day names.
1518 * @param format The formatter to set
1519 * @param type The type of symbols to set.  One of UDAT_ERAS, UDAT_MONTHS, UDAT_SHORT_MONTHS,
1520 * UDAT_WEEKDAYS, UDAT_SHORT_WEEKDAYS, UDAT_AM_PMS, or UDAT_LOCALIZED_CHARS
1521 * @param symbolIndex The index of the symbol to set of type type.
1522 * @param value The new value
1523 * @param valueLength The length of value, or -1 if null-terminated
1524 * @param status A pointer to an UErrorCode to receive any errors
1525 * @see udat_getSymbols
1526 * @see udat_countSymbols
1527 * @stable ICU 2.0
1528 */
1529 U_CAPI void U_EXPORT2
1530 udat_setSymbols(    UDateFormat             *format,
1531                     UDateFormatSymbolType   type,
1532                     int32_t                 symbolIndex,
1533                     UChar                   *value,
1534                     int32_t                 valueLength,
1535                     UErrorCode              *status);
1536 
1537 /**
1538  * Get the locale for this date format object.
1539  * You can choose between valid and actual locale.
1540  * @param fmt The formatter to get the locale from
1541  * @param type type of the locale we&#39;re looking for (valid or actual)
1542  * @param status error code for the operation
1543  * @return the locale name
1544  * @stable ICU 2.8
1545  */
1546 U_CAPI const char* U_EXPORT2
1547 udat_getLocaleByType(const UDateFormat *fmt,
1548                      ULocDataLocaleType type,
1549                      UErrorCode* status);
1550 
1551 /**
1552  * Set a particular UDisplayContext value in the formatter, such as
1553  * UDISPCTX_CAPITALIZATION_FOR_STANDALONE.
1554  * @param fmt The formatter for which to set a UDisplayContext value.
1555  * @param value The UDisplayContext value to set.
1556  * @param status A pointer to an UErrorCode to receive any errors
1557  * @stable ICU 51
1558  */
1559 U_CAPI void U_EXPORT2
1560 udat_setContext(UDateFormat* fmt, UDisplayContext value, UErrorCode* status);
1561 
1562 /**
1563  * Get the formatter&#39;s UDisplayContext value for the specified UDisplayContextType,
1564  * such as UDISPCTX_TYPE_CAPITALIZATION.
1565  * @param fmt The formatter to query.
1566  * @param type The UDisplayContextType whose value to return
1567  * @param status A pointer to an UErrorCode to receive any errors
1568  * @return The UDisplayContextValue for the specified type.
1569  * @stable ICU 53
1570  */
1571 U_CAPI UDisplayContext U_EXPORT2
1572 udat_getContext(const UDateFormat* fmt, UDisplayContextType type, UErrorCode* status);
1573 
1574 #ifndef U_HIDE_INTERNAL_API
1575 /**
1576 * Extract the date pattern from a UDateFormat set for relative date formatting.
1577 * The pattern will follow the pattern syntax rules.
1578 * @param fmt The formatter to query.
1579 * @param result A pointer to a buffer to receive the pattern.
1580 * @param resultLength The maximum size of result.
1581 * @param status A pointer to a UErrorCode to receive any errors
1582 * @return The total buffer size needed; if greater than resultLength, the output was truncated.
1583 * @see udat_applyPatternRelative
1584 * @internal ICU 4.2 technology preview
1585 */
1586 U_INTERNAL int32_t U_EXPORT2
1587 udat_toPatternRelativeDate(const UDateFormat *fmt,
1588                            UChar             *result,
1589                            int32_t           resultLength,
1590                            UErrorCode        *status);
1591 
1592 /**
1593 * Extract the time pattern from a UDateFormat set for relative date formatting.
1594 * The pattern will follow the pattern syntax rules.
1595 * @param fmt The formatter to query.
1596 * @param result A pointer to a buffer to receive the pattern.
1597 * @param resultLength The maximum size of result.
1598 * @param status A pointer to a UErrorCode to receive any errors
1599 * @return The total buffer size needed; if greater than resultLength, the output was truncated.
1600 * @see udat_applyPatternRelative
1601 * @internal ICU 4.2 technology preview
1602 */
1603 U_INTERNAL int32_t U_EXPORT2
1604 udat_toPatternRelativeTime(const UDateFormat *fmt,
1605                            UChar             *result,
1606                            int32_t           resultLength,
1607                            UErrorCode        *status);
1608 
1609 /**
1610 * Set the date &amp; time patterns used by a UDateFormat set for relative date formatting.
1611 * The patterns should follow the pattern syntax rules.
1612 * @param format The formatter to set.
1613 * @param datePattern The new date pattern
1614 * @param datePatternLength The length of datePattern, or -1 if null-terminated.
1615 * @param timePattern The new time pattern
1616 * @param timePatternLength The length of timePattern, or -1 if null-terminated.
1617 * @param status A pointer to a UErrorCode to receive any errors
1618 * @see udat_toPatternRelativeDate, udat_toPatternRelativeTime
1619 * @internal ICU 4.2 technology preview
1620 */
1621 U_INTERNAL void U_EXPORT2
1622 udat_applyPatternRelative(UDateFormat *format,
1623                           const UChar *datePattern,
1624                           int32_t     datePatternLength,
1625                           const UChar *timePattern,
1626                           int32_t     timePatternLength,
1627                           UErrorCode  *status);
1628 
1629 /**
1630  * @internal
1631  * @see udat_open
1632  */
1633 typedef UDateFormat* (U_EXPORT2 *UDateFormatOpener) (UDateFormatStyle  timeStyle,
1634                                                     UDateFormatStyle  dateStyle,
1635                                                     const char        *locale,
1636                                                     const UChar       *tzID,
1637                                                     int32_t           tzIDLength,
1638                                                     const UChar       *pattern,
1639                                                     int32_t           patternLength,
1640                                                     UErrorCode        *status);
1641 
1642 /**
1643  * Register a provider factory
1644  * @internal ICU 49
1645  */
1646 U_INTERNAL void U_EXPORT2
1647 udat_registerOpener(UDateFormatOpener opener, UErrorCode *status);
1648 
1649 /**
1650  * Un-Register a provider factory
1651  * @internal ICU 49
1652  */
1653 U_INTERNAL UDateFormatOpener U_EXPORT2
1654 udat_unregisterOpener(UDateFormatOpener opener, UErrorCode *status);
1655 #endif  /* U_HIDE_INTERNAL_API */
1656 
1657 
1658 #endif /* #if !UCONFIG_NO_FORMATTING */
1659 
1660 #endif
    </pre>
  </body>
</html>