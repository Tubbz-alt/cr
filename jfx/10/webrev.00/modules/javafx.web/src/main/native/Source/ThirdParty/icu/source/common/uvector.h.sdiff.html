<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uvector.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="uvector.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uvectr32.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uvector.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
125     //------------------------------------------------------------
126 
127     void addElement(void* obj, UErrorCode &amp;status);
128 
129     void addElement(int32_t elem, UErrorCode &amp;status);
130 
131     void setElementAt(void* obj, int32_t index);
132 
133     void setElementAt(int32_t elem, int32_t index);
134 
135     void insertElementAt(void* obj, int32_t index, UErrorCode &amp;status);
136 
137     void insertElementAt(int32_t elem, int32_t index, UErrorCode &amp;status);
138 
139     void* elementAt(int32_t index) const;
140 
141     int32_t elementAti(int32_t index) const;
142 
143     UBool equals(const UVector &amp;other) const;
144 
<span class="line-modified">145     void* firstElement(void) const;</span>
146 
<span class="line-modified">147     void* lastElement(void) const;</span>
148 
<span class="line-modified">149     int32_t lastElementi(void) const;</span>
150 
151     int32_t indexOf(void* obj, int32_t startIndex = 0) const;
152 
153     int32_t indexOf(int32_t obj, int32_t startIndex = 0) const;
154 
<span class="line-modified">155     UBool contains(void* obj) const;</span>
156 
<span class="line-modified">157     UBool contains(int32_t obj) const;</span>
158 
159     UBool containsAll(const UVector&amp; other) const;
160 
161     UBool removeAll(const UVector&amp; other);
162 
163     UBool retainAll(const UVector&amp; other);
164 
165     void removeElementAt(int32_t index);
166 
167     UBool removeElement(void* obj);
168 
169     void removeAllElements();
170 
<span class="line-modified">171     int32_t size(void) const;</span>
172 
<span class="line-modified">173     UBool isEmpty(void) const;</span>
174 
175     UBool ensureCapacity(int32_t minimumCapacity, UErrorCode &amp;status);
176 
177     /**
178      * Change the size of this vector as follows: If newSize is
179      * smaller, then truncate the array, possibly deleting held
180      * elements for i &gt;= newSize.  If newSize is larger, grow the
181      * array, filling in new slots with NULL.
182      */
183     void setSize(int32_t newSize, UErrorCode &amp;status);
184 
185     /**
186      * Fill in the given array with all elements of this vector.
187      */
188     void** toArray(void** result) const;
189 
190     //------------------------------------------------------------
191     // New API
192     //------------------------------------------------------------
193 
194     UObjectDeleter *setDeleter(UObjectDeleter *d);
195 
196     UElementsAreEqual *setComparer(UElementsAreEqual *c);
197 
<span class="line-modified">198     void* operator[](int32_t index) const;</span>
199 
200     /**
201      * Removes the element at the given index from this vector and
202      * transfer ownership of it to the caller.  After this call, the
203      * caller owns the result and must delete it and the vector entry
204      * at &#39;index&#39; is removed, shifting all subsequent entries back by
205      * one index and shortening the size of the vector by one.  If the
206      * index is out of range or if there is no item at the given index
207      * then 0 is returned and the vector is unchanged.
208      */
209     void* orphanElementAt(int32_t index);
210 
211     /**
212      * Returns true if this vector contains none of the elements
213      * of the given vector.
214      * @param other vector to be checked for containment
215      * @return true if the test condition is met
216      */
217     UBool containsNone(const UVector&amp; other) const;
218 
</pre>
<hr />
<pre>
292  * &lt;p&gt;The poorly named &lt;tt&gt;empty()&lt;/tt&gt; method doesn&#39;t empty the
293  * stack; it determines if the stack is empty.
294  *
295  * @author Alan Liu
296  */
297 class U_COMMON_API UStack : public UVector {
298 public:
299     UStack(UErrorCode &amp;status);
300 
301     UStack(int32_t initialCapacity, UErrorCode &amp;status);
302 
303     UStack(UObjectDeleter *d, UElementsAreEqual *c, UErrorCode &amp;status);
304 
305     UStack(UObjectDeleter *d, UElementsAreEqual *c, int32_t initialCapacity, UErrorCode &amp;status);
306 
307     virtual ~UStack();
308 
309     // It&#39;s okay not to have a virtual destructor (in UVector)
310     // because UStack has no special cleanup to do.
311 
<span class="line-modified">312     UBool empty(void) const;</span>
313 
<span class="line-modified">314     void* peek(void) const;</span>
315 
<span class="line-modified">316     int32_t peeki(void) const;</span>
317 
318     void* pop(void);
319 
320     int32_t popi(void);
321 
<span class="line-modified">322     void* push(void* obj, UErrorCode &amp;status);</span>
323 
<span class="line-modified">324     int32_t push(int32_t i, UErrorCode &amp;status);</span>
325 
326     /*
327     If the object o occurs as an item in this stack,
328     this method returns the 1-based distance from the top of the stack.
329     */
330     int32_t search(void* obj) const;
331 
332     /**
333      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for this class.
334      */
335     static UClassID U_EXPORT2 getStaticClassID();
336 
337     /**
338      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for the actual class.
339      */
340     virtual UClassID getDynamicClassID() const;
341 
342 private:
343     // Disallow
344     UStack(const UStack&amp;);
</pre>
</td>
<td>
<hr />
<pre>
125     //------------------------------------------------------------
126 
127     void addElement(void* obj, UErrorCode &amp;status);
128 
129     void addElement(int32_t elem, UErrorCode &amp;status);
130 
131     void setElementAt(void* obj, int32_t index);
132 
133     void setElementAt(int32_t elem, int32_t index);
134 
135     void insertElementAt(void* obj, int32_t index, UErrorCode &amp;status);
136 
137     void insertElementAt(int32_t elem, int32_t index, UErrorCode &amp;status);
138 
139     void* elementAt(int32_t index) const;
140 
141     int32_t elementAti(int32_t index) const;
142 
143     UBool equals(const UVector &amp;other) const;
144 
<span class="line-modified">145     inline void* firstElement(void) const;</span>
146 
<span class="line-modified">147     inline void* lastElement(void) const;</span>
148 
<span class="line-modified">149     inline int32_t lastElementi(void) const;</span>
150 
151     int32_t indexOf(void* obj, int32_t startIndex = 0) const;
152 
153     int32_t indexOf(int32_t obj, int32_t startIndex = 0) const;
154 
<span class="line-modified">155     inline UBool contains(void* obj) const;</span>
156 
<span class="line-modified">157     inline UBool contains(int32_t obj) const;</span>
158 
159     UBool containsAll(const UVector&amp; other) const;
160 
161     UBool removeAll(const UVector&amp; other);
162 
163     UBool retainAll(const UVector&amp; other);
164 
165     void removeElementAt(int32_t index);
166 
167     UBool removeElement(void* obj);
168 
169     void removeAllElements();
170 
<span class="line-modified">171     inline int32_t size(void) const;</span>
172 
<span class="line-modified">173     inline UBool isEmpty(void) const;</span>
174 
175     UBool ensureCapacity(int32_t minimumCapacity, UErrorCode &amp;status);
176 
177     /**
178      * Change the size of this vector as follows: If newSize is
179      * smaller, then truncate the array, possibly deleting held
180      * elements for i &gt;= newSize.  If newSize is larger, grow the
181      * array, filling in new slots with NULL.
182      */
183     void setSize(int32_t newSize, UErrorCode &amp;status);
184 
185     /**
186      * Fill in the given array with all elements of this vector.
187      */
188     void** toArray(void** result) const;
189 
190     //------------------------------------------------------------
191     // New API
192     //------------------------------------------------------------
193 
194     UObjectDeleter *setDeleter(UObjectDeleter *d);
195 
196     UElementsAreEqual *setComparer(UElementsAreEqual *c);
197 
<span class="line-modified">198     inline void* operator[](int32_t index) const;</span>
199 
200     /**
201      * Removes the element at the given index from this vector and
202      * transfer ownership of it to the caller.  After this call, the
203      * caller owns the result and must delete it and the vector entry
204      * at &#39;index&#39; is removed, shifting all subsequent entries back by
205      * one index and shortening the size of the vector by one.  If the
206      * index is out of range or if there is no item at the given index
207      * then 0 is returned and the vector is unchanged.
208      */
209     void* orphanElementAt(int32_t index);
210 
211     /**
212      * Returns true if this vector contains none of the elements
213      * of the given vector.
214      * @param other vector to be checked for containment
215      * @return true if the test condition is met
216      */
217     UBool containsNone(const UVector&amp; other) const;
218 
</pre>
<hr />
<pre>
292  * &lt;p&gt;The poorly named &lt;tt&gt;empty()&lt;/tt&gt; method doesn&#39;t empty the
293  * stack; it determines if the stack is empty.
294  *
295  * @author Alan Liu
296  */
297 class U_COMMON_API UStack : public UVector {
298 public:
299     UStack(UErrorCode &amp;status);
300 
301     UStack(int32_t initialCapacity, UErrorCode &amp;status);
302 
303     UStack(UObjectDeleter *d, UElementsAreEqual *c, UErrorCode &amp;status);
304 
305     UStack(UObjectDeleter *d, UElementsAreEqual *c, int32_t initialCapacity, UErrorCode &amp;status);
306 
307     virtual ~UStack();
308 
309     // It&#39;s okay not to have a virtual destructor (in UVector)
310     // because UStack has no special cleanup to do.
311 
<span class="line-modified">312     inline UBool empty(void) const;</span>
313 
<span class="line-modified">314     inline void* peek(void) const;</span>
315 
<span class="line-modified">316     inline int32_t peeki(void) const;</span>
317 
318     void* pop(void);
319 
320     int32_t popi(void);
321 
<span class="line-modified">322     inline void* push(void* obj, UErrorCode &amp;status);</span>
323 
<span class="line-modified">324     inline int32_t push(int32_t i, UErrorCode &amp;status);</span>
325 
326     /*
327     If the object o occurs as an item in this stack,
328     this method returns the 1-based distance from the top of the stack.
329     */
330     int32_t search(void* obj) const;
331 
332     /**
333      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for this class.
334      */
335     static UClassID U_EXPORT2 getStaticClassID();
336 
337     /**
338      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for the actual class.
339      */
340     virtual UClassID getDynamicClassID() const;
341 
342 private:
343     // Disallow
344     UStack(const UStack&amp;);
</pre>
</td>
</tr>
</table>
<center><a href="uvector.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uvectr32.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>