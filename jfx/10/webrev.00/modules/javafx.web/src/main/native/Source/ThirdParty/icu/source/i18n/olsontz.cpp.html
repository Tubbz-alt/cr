<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/olsontz.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 * Copyright (c) 2003-2013, International Business Machines
   6 * Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8 * Author: Alan Liu
   9 * Created: July 21 2003
  10 * Since: ICU 2.8
  11 **********************************************************************
  12 */
  13 
  14 #include &quot;utypeinfo.h&quot;  // for &#39;typeid&#39; to work
  15 
  16 #include &quot;olsontz.h&quot;
  17 
  18 #if !UCONFIG_NO_FORMATTING
  19 
  20 #include &quot;unicode/ures.h&quot;
  21 #include &quot;unicode/simpletz.h&quot;
  22 #include &quot;unicode/gregocal.h&quot;
  23 #include &quot;gregoimp.h&quot;
  24 #include &quot;cmemory.h&quot;
  25 #include &quot;uassert.h&quot;
  26 #include &quot;uvector.h&quot;
  27 #include &lt;float.h&gt; // DBL_MAX
  28 #include &quot;uresimp.h&quot;
  29 #include &quot;zonemeta.h&quot;
  30 #include &quot;umutex.h&quot;
  31 
  32 #ifdef U_DEBUG_TZ
  33 # include &lt;stdio.h&gt;
  34 # include &quot;uresimp.h&quot; // for debugging
  35 
  36 static void debug_tz_loc(const char *f, int32_t l)
  37 {
  38   fprintf(stderr, &quot;%s:%d: &quot;, f, l);
  39 }
  40 
  41 static void debug_tz_msg(const char *pat, ...)
  42 {
  43   va_list ap;
  44   va_start(ap, pat);
  45   vfprintf(stderr, pat, ap);
  46   fflush(stderr);
  47 }
  48 // must use double parens, i.e.:  U_DEBUG_TZ_MSG((&quot;four is: %d&quot;,4));
  49 #define U_DEBUG_TZ_MSG(x) {debug_tz_loc(__FILE__,__LINE__);debug_tz_msg x;}
  50 #else
  51 #define U_DEBUG_TZ_MSG(x)
  52 #endif
  53 
  54 static UBool arrayEqual(const void *a1, const void *a2, int32_t size) {
  55     if (a1 == NULL &amp;&amp; a2 == NULL) {
  56         return TRUE;
  57     }
  58     if ((a1 != NULL &amp;&amp; a2 == NULL) || (a1 == NULL &amp;&amp; a2 != NULL)) {
  59         return FALSE;
  60     }
  61     if (a1 == a2) {
  62         return TRUE;
  63     }
  64 
  65     return (uprv_memcmp(a1, a2, size) == 0);
  66 }
  67 
  68 U_NAMESPACE_BEGIN
  69 
  70 #define kTRANS          &quot;trans&quot;
  71 #define kTRANSPRE32     &quot;transPre32&quot;
  72 #define kTRANSPOST32    &quot;transPost32&quot;
  73 #define kTYPEOFFSETS    &quot;typeOffsets&quot;
  74 #define kTYPEMAP        &quot;typeMap&quot;
  75 #define kLINKS          &quot;links&quot;
  76 #define kFINALRULE      &quot;finalRule&quot;
  77 #define kFINALRAW       &quot;finalRaw&quot;
  78 #define kFINALYEAR      &quot;finalYear&quot;
  79 
  80 #define SECONDS_PER_DAY (24*60*60)
  81 
  82 static const int32_t ZEROS[] = {0,0};
  83 
  84 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(OlsonTimeZone)
  85 
  86 /**
  87  * Default constructor.  Creates a time zone with an empty ID and
  88  * a fixed GMT offset of zero.
  89  */
  90 /*OlsonTimeZone::OlsonTimeZone() : finalYear(INT32_MAX), finalMillis(DBL_MAX), finalZone(0), transitionRulesInitialized(FALSE) {
  91     clearTransitionRules();
  92     constructEmpty();
  93 }*/
  94 
  95 /**
  96  * Construct a GMT+0 zone with no transitions.  This is done when a
  97  * constructor fails so the resultant object is well-behaved.
  98  */
  99 void OlsonTimeZone::constructEmpty() {
 100     canonicalID = NULL;
 101 
 102     transitionCountPre32 = transitionCount32 = transitionCountPost32 = 0;
 103     transitionTimesPre32 = transitionTimes32 = transitionTimesPost32 = NULL;
 104 
 105     typeMapData = NULL;
 106 
 107     typeCount = 1;
 108     typeOffsets = ZEROS;
 109 
 110     finalZone = NULL;
 111 }
 112 
 113 /**
 114  * Construct from a resource bundle
 115  * @param top the top-level zoneinfo resource bundle.  This is used
 116  * to lookup the rule that `res&#39; may refer to, if there is one.
 117  * @param res the resource bundle of the zone to be constructed
 118  * @param ec input-output error code
 119  */
 120 OlsonTimeZone::OlsonTimeZone(const UResourceBundle* top,
 121                              const UResourceBundle* res,
 122                              const UnicodeString&amp; tzid,
 123                              UErrorCode&amp; ec) :
 124   BasicTimeZone(tzid), finalZone(NULL)
 125 {
 126     clearTransitionRules();
 127     U_DEBUG_TZ_MSG((&quot;OlsonTimeZone(%s)\n&quot;, ures_getKey((UResourceBundle*)res)));
 128     if ((top == NULL || res == NULL) &amp;&amp; U_SUCCESS(ec)) {
 129         ec = U_ILLEGAL_ARGUMENT_ERROR;
 130     }
 131     if (U_SUCCESS(ec)) {
 132         // TODO -- clean up -- Doesn&#39;t work if res points to an alias
 133         //        // TODO remove nonconst casts below when ures_* API is fixed
 134         //        setID(ures_getKey((UResourceBundle*) res)); // cast away const
 135 
 136         int32_t len;
 137         StackUResourceBundle r;
 138 
 139         // Pre-32bit second transitions
 140         ures_getByKey(res, kTRANSPRE32, r.getAlias(), &amp;ec);
 141         transitionTimesPre32 = ures_getIntVector(r.getAlias(), &amp;len, &amp;ec);
 142         transitionCountPre32 = static_cast&lt;int16_t&gt;(len &gt;&gt; 1);
 143         if (ec == U_MISSING_RESOURCE_ERROR) {
 144             // No pre-32bit transitions
 145             transitionTimesPre32 = NULL;
 146             transitionCountPre32 = 0;
 147             ec = U_ZERO_ERROR;
 148         } else if (U_SUCCESS(ec) &amp;&amp; (len &lt; 0 || len &gt; 0x7FFF || (len &amp; 1) != 0) /* len must be even */) {
 149             ec = U_INVALID_FORMAT_ERROR;
 150         }
 151 
 152         // 32bit second transitions
 153         ures_getByKey(res, kTRANS, r.getAlias(), &amp;ec);
 154         transitionTimes32 = ures_getIntVector(r.getAlias(), &amp;len, &amp;ec);
 155         transitionCount32 = static_cast&lt;int16_t&gt;(len);
 156         if (ec == U_MISSING_RESOURCE_ERROR) {
 157             // No 32bit transitions
 158             transitionTimes32 = NULL;
 159             transitionCount32 = 0;
 160             ec = U_ZERO_ERROR;
 161         } else if (U_SUCCESS(ec) &amp;&amp; (len &lt; 0 || len &gt; 0x7FFF)) {
 162             ec = U_INVALID_FORMAT_ERROR;
 163         }
 164 
 165         // Post-32bit second transitions
 166         ures_getByKey(res, kTRANSPOST32, r.getAlias(), &amp;ec);
 167         transitionTimesPost32 = ures_getIntVector(r.getAlias(), &amp;len, &amp;ec);
 168         transitionCountPost32 = static_cast&lt;int16_t&gt;(len &gt;&gt; 1);
 169         if (ec == U_MISSING_RESOURCE_ERROR) {
 170             // No pre-32bit transitions
 171             transitionTimesPost32 = NULL;
 172             transitionCountPost32 = 0;
 173             ec = U_ZERO_ERROR;
 174         } else if (U_SUCCESS(ec) &amp;&amp; (len &lt; 0 || len &gt; 0x7FFF || (len &amp; 1) != 0) /* len must be even */) {
 175             ec = U_INVALID_FORMAT_ERROR;
 176         }
 177 
 178         // Type offsets list must be of even size, with size &gt;= 2
 179         ures_getByKey(res, kTYPEOFFSETS, r.getAlias(), &amp;ec);
 180         typeOffsets = ures_getIntVector(r.getAlias(), &amp;len, &amp;ec);
 181         if (U_SUCCESS(ec) &amp;&amp; (len &lt; 2 || len &gt; 0x7FFE || (len &amp; 1) != 0)) {
 182             ec = U_INVALID_FORMAT_ERROR;
 183         }
 184         typeCount = (int16_t) len &gt;&gt; 1;
 185 
 186         // Type map data must be of the same size as the transition count
 187         typeMapData =  NULL;
 188         if (transitionCount() &gt; 0) {
 189             ures_getByKey(res, kTYPEMAP, r.getAlias(), &amp;ec);
 190             typeMapData = ures_getBinary(r.getAlias(), &amp;len, &amp;ec);
 191             if (ec == U_MISSING_RESOURCE_ERROR) {
 192                 // no type mapping data
 193                 ec = U_INVALID_FORMAT_ERROR;
 194             } else if (U_SUCCESS(ec) &amp;&amp; len != transitionCount()) {
 195                 ec = U_INVALID_FORMAT_ERROR;
 196             }
 197         }
 198 
 199         // Process final rule and data, if any
 200         const UChar *ruleIdUStr = ures_getStringByKey(res, kFINALRULE, &amp;len, &amp;ec);
 201         ures_getByKey(res, kFINALRAW, r.getAlias(), &amp;ec);
 202         int32_t ruleRaw = ures_getInt(r.getAlias(), &amp;ec);
 203         ures_getByKey(res, kFINALYEAR, r.getAlias(), &amp;ec);
 204         int32_t ruleYear = ures_getInt(r.getAlias(), &amp;ec);
 205         if (U_SUCCESS(ec)) {
 206             UnicodeString ruleID(TRUE, ruleIdUStr, len);
 207             UResourceBundle *rule = TimeZone::loadRule(top, ruleID, NULL, ec);
 208             const int32_t *ruleData = ures_getIntVector(rule, &amp;len, &amp;ec);
 209             if (U_SUCCESS(ec) &amp;&amp; len == 11) {
 210                 UnicodeString emptyStr;
 211                 finalZone = new SimpleTimeZone(
 212                     ruleRaw * U_MILLIS_PER_SECOND,
 213                     emptyStr,
 214                     (int8_t)ruleData[0], (int8_t)ruleData[1], (int8_t)ruleData[2],
 215                     ruleData[3] * U_MILLIS_PER_SECOND,
 216                     (SimpleTimeZone::TimeMode) ruleData[4],
 217                     (int8_t)ruleData[5], (int8_t)ruleData[6], (int8_t)ruleData[7],
 218                     ruleData[8] * U_MILLIS_PER_SECOND,
 219                     (SimpleTimeZone::TimeMode) ruleData[9],
 220                     ruleData[10] * U_MILLIS_PER_SECOND, ec);
 221                 if (finalZone == NULL) {
 222                     ec = U_MEMORY_ALLOCATION_ERROR;
 223                 } else {
 224                     finalStartYear = ruleYear;
 225 
 226                     // Note: Setting finalStartYear to the finalZone is problematic.  When a date is around
 227                     // year boundary, SimpleTimeZone may return false result when DST is observed at the
 228                     // beginning of year.  We could apply safe margin (day or two), but when one of recurrent
 229                     // rules falls around year boundary, it could return false result.  Without setting the
 230                     // start year, finalZone works fine around the year boundary of the start year.
 231 
 232                     // finalZone-&gt;setStartYear(finalStartYear);
 233 
 234 
 235                     // Compute the millis for Jan 1, 0:00 GMT of the finalYear
 236 
 237                     // Note: finalStartMillis is used for detecting either if
 238                     // historic transition data or finalZone to be used.  In an
 239                     // extreme edge case - for example, two transitions fall into
 240                     // small windows of time around the year boundary, this may
 241                     // result incorrect offset computation.  But I think it will
 242                     // never happen practically.  Yoshito - Feb 20, 2010
 243                     finalStartMillis = Grego::fieldsToDay(finalStartYear, 0, 1) * U_MILLIS_PER_DAY;
 244                 }
 245             } else {
 246                 ec = U_INVALID_FORMAT_ERROR;
 247             }
 248             ures_close(rule);
 249         } else if (ec == U_MISSING_RESOURCE_ERROR) {
 250             // No final zone
 251             ec = U_ZERO_ERROR;
 252         }
 253 
 254         // initialize canonical ID
 255         canonicalID = ZoneMeta::getCanonicalCLDRID(tzid, ec);
 256     }
 257 
 258     if (U_FAILURE(ec)) {
 259         constructEmpty();
 260     }
 261 }
 262 
 263 /**
 264  * Copy constructor
 265  */
 266 OlsonTimeZone::OlsonTimeZone(const OlsonTimeZone&amp; other) :
 267     BasicTimeZone(other), finalZone(0) {
 268     *this = other;
 269 }
 270 
 271 /**
 272  * Assignment operator
 273  */
 274 OlsonTimeZone&amp; OlsonTimeZone::operator=(const OlsonTimeZone&amp; other) {
 275     canonicalID = other.canonicalID;
 276 
 277     transitionTimesPre32 = other.transitionTimesPre32;
 278     transitionTimes32 = other.transitionTimes32;
 279     transitionTimesPost32 = other.transitionTimesPost32;
 280 
 281     transitionCountPre32 = other.transitionCountPre32;
 282     transitionCount32 = other.transitionCount32;
 283     transitionCountPost32 = other.transitionCountPost32;
 284 
 285     typeCount = other.typeCount;
 286     typeOffsets = other.typeOffsets;
 287     typeMapData = other.typeMapData;
 288 
 289     delete finalZone;
 290     finalZone = (other.finalZone != 0) ?
 291         (SimpleTimeZone*) other.finalZone-&gt;clone() : 0;
 292 
 293     finalStartYear = other.finalStartYear;
 294     finalStartMillis = other.finalStartMillis;
 295 
 296     clearTransitionRules();
 297 
 298     return *this;
 299 }
 300 
 301 /**
 302  * Destructor
 303  */
 304 OlsonTimeZone::~OlsonTimeZone() {
 305     deleteTransitionRules();
 306     delete finalZone;
 307 }
 308 
 309 /**
 310  * Returns true if the two TimeZone objects are equal.
 311  */
 312 UBool OlsonTimeZone::operator==(const TimeZone&amp; other) const {
 313     return ((this == &amp;other) ||
 314             (typeid(*this) == typeid(other) &amp;&amp;
 315             TimeZone::operator==(other) &amp;&amp;
 316             hasSameRules(other)));
 317 }
 318 
 319 /**
 320  * TimeZone API.
 321  */
 322 TimeZone* OlsonTimeZone::clone() const {
 323     return new OlsonTimeZone(*this);
 324 }
 325 
 326 /**
 327  * TimeZone API.
 328  */
 329 int32_t OlsonTimeZone::getOffset(uint8_t era, int32_t year, int32_t month,
 330                                  int32_t dom, uint8_t dow,
 331                                  int32_t millis, UErrorCode&amp; ec) const {
 332     if (month &lt; UCAL_JANUARY || month &gt; UCAL_DECEMBER) {
 333         if (U_SUCCESS(ec)) {
 334             ec = U_ILLEGAL_ARGUMENT_ERROR;
 335         }
 336         return 0;
 337     } else {
 338         return getOffset(era, year, month, dom, dow, millis,
 339                          Grego::monthLength(year, month),
 340                          ec);
 341     }
 342 }
 343 
 344 /**
 345  * TimeZone API.
 346  */
 347 int32_t OlsonTimeZone::getOffset(uint8_t era, int32_t year, int32_t month,
 348                                  int32_t dom, uint8_t dow,
 349                                  int32_t millis, int32_t monthLength,
 350                                  UErrorCode&amp; ec) const {
 351     if (U_FAILURE(ec)) {
 352         return 0;
 353     }
 354 
 355     if ((era != GregorianCalendar::AD &amp;&amp; era != GregorianCalendar::BC)
 356         || month &lt; UCAL_JANUARY
 357         || month &gt; UCAL_DECEMBER
 358         || dom &lt; 1
 359         || dom &gt; monthLength
 360         || dow &lt; UCAL_SUNDAY
 361         || dow &gt; UCAL_SATURDAY
 362         || millis &lt; 0
 363         || millis &gt;= U_MILLIS_PER_DAY
 364         || monthLength &lt; 28
 365         || monthLength &gt; 31) {
 366         ec = U_ILLEGAL_ARGUMENT_ERROR;
 367         return 0;
 368     }
 369 
 370     if (era == GregorianCalendar::BC) {
 371         year = -year;
 372     }
 373 
 374     if (finalZone != NULL &amp;&amp; year &gt;= finalStartYear) {
 375         return finalZone-&gt;getOffset(era, year, month, dom, dow,
 376                                     millis, monthLength, ec);
 377     }
 378 
 379     // Compute local epoch millis from input fields
 380     UDate date = (UDate)(Grego::fieldsToDay(year, month, dom) * U_MILLIS_PER_DAY + millis);
 381     int32_t rawoff, dstoff;
 382     getHistoricalOffset(date, TRUE, kDaylight, kStandard, rawoff, dstoff);
 383     return rawoff + dstoff;
 384 }
 385 
 386 /**
 387  * TimeZone API.
 388  */
 389 void OlsonTimeZone::getOffset(UDate date, UBool local, int32_t&amp; rawoff,
 390                               int32_t&amp; dstoff, UErrorCode&amp; ec) const {
 391     if (U_FAILURE(ec)) {
 392         return;
 393     }
 394     if (finalZone != NULL &amp;&amp; date &gt;= finalStartMillis) {
 395         finalZone-&gt;getOffset(date, local, rawoff, dstoff, ec);
 396     } else {
 397         getHistoricalOffset(date, local, kFormer, kLatter, rawoff, dstoff);
 398     }
 399 }
 400 
 401 void
 402 OlsonTimeZone::getOffsetFromLocal(UDate date, int32_t nonExistingTimeOpt, int32_t duplicatedTimeOpt,
 403                                   int32_t&amp; rawoff, int32_t&amp; dstoff, UErrorCode&amp; ec) const {
 404     if (U_FAILURE(ec)) {
 405         return;
 406     }
 407     if (finalZone != NULL &amp;&amp; date &gt;= finalStartMillis) {
 408         finalZone-&gt;getOffsetFromLocal(date, nonExistingTimeOpt, duplicatedTimeOpt, rawoff, dstoff, ec);
 409     } else {
 410         getHistoricalOffset(date, TRUE, nonExistingTimeOpt, duplicatedTimeOpt, rawoff, dstoff);
 411     }
 412 }
 413 
 414 
 415 /**
 416  * TimeZone API.
 417  */
 418 void OlsonTimeZone::setRawOffset(int32_t /*offsetMillis*/) {
 419     // We don&#39;t support this operation, since OlsonTimeZones are
 420     // immutable (except for the ID, which is in the base class).
 421 
 422     // Nothing to do!
 423 }
 424 
 425 /**
 426  * TimeZone API.
 427  */
 428 int32_t OlsonTimeZone::getRawOffset() const {
 429     UErrorCode ec = U_ZERO_ERROR;
 430     int32_t raw, dst;
 431     getOffset((double) uprv_getUTCtime() * U_MILLIS_PER_SECOND,
 432               FALSE, raw, dst, ec);
 433     return raw;
 434 }
 435 
 436 #if defined U_DEBUG_TZ
 437 void printTime(double ms) {
 438             int32_t year, month, dom, dow;
 439             double millis=0;
 440             double days = ClockMath::floorDivide(((double)ms), (double)U_MILLIS_PER_DAY, millis);
 441 
 442             Grego::dayToFields(days, year, month, dom, dow);
 443             U_DEBUG_TZ_MSG((&quot;   getHistoricalOffset:  time %.1f (%04d.%02d.%02d+%.1fh)\n&quot;, ms,
 444                             year, month+1, dom, (millis/kOneHour)));
 445     }
 446 #endif
 447 
 448 int64_t
 449 OlsonTimeZone::transitionTimeInSeconds(int16_t transIdx) const {
 450     U_ASSERT(transIdx &gt;= 0 &amp;&amp; transIdx &lt; transitionCount());
 451 
 452     if (transIdx &lt; transitionCountPre32) {
 453         return (((int64_t)((uint32_t)transitionTimesPre32[transIdx &lt;&lt; 1])) &lt;&lt; 32)
 454             | ((int64_t)((uint32_t)transitionTimesPre32[(transIdx &lt;&lt; 1) + 1]));
 455     }
 456 
 457     transIdx -= transitionCountPre32;
 458     if (transIdx &lt; transitionCount32) {
 459         return (int64_t)transitionTimes32[transIdx];
 460     }
 461 
 462     transIdx -= transitionCount32;
 463     return (((int64_t)((uint32_t)transitionTimesPost32[transIdx &lt;&lt; 1])) &lt;&lt; 32)
 464         | ((int64_t)((uint32_t)transitionTimesPost32[(transIdx &lt;&lt; 1) + 1]));
 465 }
 466 
 467 // Maximum absolute offset in seconds (86400 seconds = 1 day)
 468 // getHistoricalOffset uses this constant as safety margin of
 469 // quick zone transition checking.
 470 #define MAX_OFFSET_SECONDS 86400
 471 
 472 void
 473 OlsonTimeZone::getHistoricalOffset(UDate date, UBool local,
 474                                    int32_t NonExistingTimeOpt, int32_t DuplicatedTimeOpt,
 475                                    int32_t&amp; rawoff, int32_t&amp; dstoff) const {
 476     U_DEBUG_TZ_MSG((&quot;getHistoricalOffset(%.1f, %s, %d, %d, raw, dst)\n&quot;,
 477         date, local?&quot;T&quot;:&quot;F&quot;, NonExistingTimeOpt, DuplicatedTimeOpt));
 478 #if defined U_DEBUG_TZ
 479         printTime(date*1000.0);
 480 #endif
 481     int16_t transCount = transitionCount();
 482 
 483     if (transCount &gt; 0) {
 484         double sec = uprv_floor(date / U_MILLIS_PER_SECOND);
 485         if (!local &amp;&amp; sec &lt; transitionTimeInSeconds(0)) {
 486             // Before the first transition time
 487             rawoff = initialRawOffset() * U_MILLIS_PER_SECOND;
 488             dstoff = initialDstOffset() * U_MILLIS_PER_SECOND;
 489         } else {
 490             // Linear search from the end is the fastest approach, since
 491             // most lookups will happen at/near the end.
 492             int16_t transIdx;
 493             for (transIdx = transCount - 1; transIdx &gt;= 0; transIdx--) {
 494                 int64_t transition = transitionTimeInSeconds(transIdx);
 495 
 496                 if (local &amp;&amp; (sec &gt;= (transition - MAX_OFFSET_SECONDS))) {
 497                     int32_t offsetBefore = zoneOffsetAt(transIdx - 1);
 498                     UBool dstBefore = dstOffsetAt(transIdx - 1) != 0;
 499 
 500                     int32_t offsetAfter = zoneOffsetAt(transIdx);
 501                     UBool dstAfter = dstOffsetAt(transIdx) != 0;
 502 
 503                     UBool dstToStd = dstBefore &amp;&amp; !dstAfter;
 504                     UBool stdToDst = !dstBefore &amp;&amp; dstAfter;
 505 
 506                     if (offsetAfter - offsetBefore &gt;= 0) {
 507                         // Positive transition, which makes a non-existing local time range
 508                         if (((NonExistingTimeOpt &amp; kStdDstMask) == kStandard &amp;&amp; dstToStd)
 509                                 || ((NonExistingTimeOpt &amp; kStdDstMask) == kDaylight &amp;&amp; stdToDst)) {
 510                             transition += offsetBefore;
 511                         } else if (((NonExistingTimeOpt &amp; kStdDstMask) == kStandard &amp;&amp; stdToDst)
 512                                 || ((NonExistingTimeOpt &amp; kStdDstMask) == kDaylight &amp;&amp; dstToStd)) {
 513                             transition += offsetAfter;
 514                         } else if ((NonExistingTimeOpt &amp; kFormerLatterMask) == kLatter) {
 515                             transition += offsetBefore;
 516                         } else {
 517                             // Interprets the time with rule before the transition,
 518                             // default for non-existing time range
 519                             transition += offsetAfter;
 520                         }
 521                     } else {
 522                         // Negative transition, which makes a duplicated local time range
 523                         if (((DuplicatedTimeOpt &amp; kStdDstMask) == kStandard &amp;&amp; dstToStd)
 524                                 || ((DuplicatedTimeOpt &amp; kStdDstMask) == kDaylight &amp;&amp; stdToDst)) {
 525                             transition += offsetAfter;
 526                         } else if (((DuplicatedTimeOpt &amp; kStdDstMask) == kStandard &amp;&amp; stdToDst)
 527                                 || ((DuplicatedTimeOpt &amp; kStdDstMask) == kDaylight &amp;&amp; dstToStd)) {
 528                             transition += offsetBefore;
 529                         } else if ((DuplicatedTimeOpt &amp; kFormerLatterMask) == kFormer) {
 530                             transition += offsetBefore;
 531                         } else {
 532                             // Interprets the time with rule after the transition,
 533                             // default for duplicated local time range
 534                             transition += offsetAfter;
 535                         }
 536                     }
 537                 }
 538                 if (sec &gt;= transition) {
 539                     break;
 540                 }
 541             }
 542             // transIdx could be -1 when local=true
 543             rawoff = rawOffsetAt(transIdx) * U_MILLIS_PER_SECOND;
 544             dstoff = dstOffsetAt(transIdx) * U_MILLIS_PER_SECOND;
 545         }
 546     } else {
 547         // No transitions, single pair of offsets only
 548         rawoff = initialRawOffset() * U_MILLIS_PER_SECOND;
 549         dstoff = initialDstOffset() * U_MILLIS_PER_SECOND;
 550     }
 551     U_DEBUG_TZ_MSG((&quot;getHistoricalOffset(%.1f, %s, %d, %d, raw, dst) - raw=%d, dst=%d\n&quot;,
 552         date, local?&quot;T&quot;:&quot;F&quot;, NonExistingTimeOpt, DuplicatedTimeOpt, rawoff, dstoff));
 553 }
 554 
 555 /**
 556  * TimeZone API.
 557  */
 558 UBool OlsonTimeZone::useDaylightTime() const {
 559     // If DST was observed in 1942 (for example) but has never been
 560     // observed from 1943 to the present, most clients will expect
 561     // this method to return FALSE.  This method determines whether
 562     // DST is in use in the current year (at any point in the year)
 563     // and returns TRUE if so.
 564 
 565     UDate current = uprv_getUTCtime();
 566     if (finalZone != NULL &amp;&amp; current &gt;= finalStartMillis) {
 567         return finalZone-&gt;useDaylightTime();
 568     }
 569 
 570     int32_t year, month, dom, dow, doy, mid;
 571     Grego::timeToFields(current, year, month, dom, dow, doy, mid);
 572 
 573     // Find start of this year, and start of next year
 574     double start = Grego::fieldsToDay(year, 0, 1) * SECONDS_PER_DAY;
 575     double limit = Grego::fieldsToDay(year+1, 0, 1) * SECONDS_PER_DAY;
 576 
 577     // Return TRUE if DST is observed at any time during the current
 578     // year.
 579     for (int16_t i = 0; i &lt; transitionCount(); ++i) {
 580         double transition = (double)transitionTimeInSeconds(i);
 581         if (transition &gt;= limit) {
 582             break;
 583         }
 584         if ((transition &gt;= start &amp;&amp; dstOffsetAt(i) != 0)
 585                 || (transition &gt; start &amp;&amp; dstOffsetAt(i - 1) != 0)) {
 586             return TRUE;
 587         }
 588     }
 589     return FALSE;
 590 }
 591 int32_t
 592 OlsonTimeZone::getDSTSavings() const{
 593     if (finalZone != NULL){
 594         return finalZone-&gt;getDSTSavings();
 595     }
 596     return TimeZone::getDSTSavings();
 597 }
 598 /**
 599  * TimeZone API.
 600  */
 601 UBool OlsonTimeZone::inDaylightTime(UDate date, UErrorCode&amp; ec) const {
 602     int32_t raw, dst;
 603     getOffset(date, FALSE, raw, dst, ec);
 604     return dst != 0;
 605 }
 606 
 607 UBool
 608 OlsonTimeZone::hasSameRules(const TimeZone &amp;other) const {
 609     if (this == &amp;other) {
 610         return TRUE;
 611     }
 612     const OlsonTimeZone* z = dynamic_cast&lt;const OlsonTimeZone*&gt;(&amp;other);
 613     if (z == NULL) {
 614         return FALSE;
 615     }
 616 
 617     // [sic] pointer comparison: typeMapData points into
 618     // memory-mapped or DLL space, so if two zones have the same
 619     // pointer, they are equal.
 620     if (typeMapData == z-&gt;typeMapData) {
 621         return TRUE;
 622     }
 623 
 624     // If the pointers are not equal, the zones may still
 625     // be equal if their rules and transitions are equal
 626     if ((finalZone == NULL &amp;&amp; z-&gt;finalZone != NULL)
 627         || (finalZone != NULL &amp;&amp; z-&gt;finalZone == NULL)
 628         || (finalZone != NULL &amp;&amp; z-&gt;finalZone != NULL &amp;&amp; *finalZone != *z-&gt;finalZone)) {
 629         return FALSE;
 630     }
 631 
 632     if (finalZone != NULL) {
 633         if (finalStartYear != z-&gt;finalStartYear || finalStartMillis != z-&gt;finalStartMillis) {
 634             return FALSE;
 635         }
 636     }
 637     if (typeCount != z-&gt;typeCount
 638         || transitionCountPre32 != z-&gt;transitionCountPre32
 639         || transitionCount32 != z-&gt;transitionCount32
 640         || transitionCountPost32 != z-&gt;transitionCountPost32) {
 641         return FALSE;
 642     }
 643 
 644     return
 645         arrayEqual(transitionTimesPre32, z-&gt;transitionTimesPre32, sizeof(transitionTimesPre32[0]) * transitionCountPre32 &lt;&lt; 1)
 646         &amp;&amp; arrayEqual(transitionTimes32, z-&gt;transitionTimes32, sizeof(transitionTimes32[0]) * transitionCount32)
 647         &amp;&amp; arrayEqual(transitionTimesPost32, z-&gt;transitionTimesPost32, sizeof(transitionTimesPost32[0]) * transitionCountPost32 &lt;&lt; 1)
 648         &amp;&amp; arrayEqual(typeOffsets, z-&gt;typeOffsets, sizeof(typeOffsets[0]) * typeCount &lt;&lt; 1)
 649         &amp;&amp; arrayEqual(typeMapData, z-&gt;typeMapData, sizeof(typeMapData[0]) * transitionCount());
 650 }
 651 
 652 void
 653 OlsonTimeZone::clearTransitionRules(void) {
 654     initialRule = NULL;
 655     firstTZTransition = NULL;
 656     firstFinalTZTransition = NULL;
 657     historicRules = NULL;
 658     historicRuleCount = 0;
 659     finalZoneWithStartYear = NULL;
 660     firstTZTransitionIdx = 0;
 661     transitionRulesInitOnce.reset();
 662 }
 663 
 664 void
 665 OlsonTimeZone::deleteTransitionRules(void) {
 666     if (initialRule != NULL) {
 667         delete initialRule;
 668     }
 669     if (firstTZTransition != NULL) {
 670         delete firstTZTransition;
 671     }
 672     if (firstFinalTZTransition != NULL) {
 673         delete firstFinalTZTransition;
 674     }
 675     if (finalZoneWithStartYear != NULL) {
 676         delete finalZoneWithStartYear;
 677     }
 678     if (historicRules != NULL) {
 679         for (int i = 0; i &lt; historicRuleCount; i++) {
 680             if (historicRules[i] != NULL) {
 681                 delete historicRules[i];
 682             }
 683         }
 684         uprv_free(historicRules);
 685     }
 686     clearTransitionRules();
 687 }
 688 
 689 /*
 690  * Lazy transition rules initializer
 691  */
 692 
 693 static void U_CALLCONV initRules(OlsonTimeZone *This, UErrorCode &amp;status) {
 694     This-&gt;initTransitionRules(status);
 695 }
 696 
 697 void
 698 OlsonTimeZone::checkTransitionRules(UErrorCode&amp; status) const {
 699     OlsonTimeZone *ncThis = const_cast&lt;OlsonTimeZone *&gt;(this);
 700     umtx_initOnce(ncThis-&gt;transitionRulesInitOnce, &amp;initRules, ncThis, status);
 701 }
 702 
 703 void
 704 OlsonTimeZone::initTransitionRules(UErrorCode&amp; status) {
 705     if(U_FAILURE(status)) {
 706         return;
 707     }
 708     deleteTransitionRules();
 709     UnicodeString tzid;
 710     getID(tzid);
 711 
 712     UnicodeString stdName = tzid + UNICODE_STRING_SIMPLE(&quot;(STD)&quot;);
 713     UnicodeString dstName = tzid + UNICODE_STRING_SIMPLE(&quot;(DST)&quot;);
 714 
 715     int32_t raw, dst;
 716 
 717     // Create initial rule
 718     raw = initialRawOffset() * U_MILLIS_PER_SECOND;
 719     dst = initialDstOffset() * U_MILLIS_PER_SECOND;
 720     initialRule = new InitialTimeZoneRule((dst == 0 ? stdName : dstName), raw, dst);
 721     // Check to make sure initialRule was created
 722     if (initialRule == NULL) {
 723         status = U_MEMORY_ALLOCATION_ERROR;
 724         deleteTransitionRules();
 725         return;
 726     }
 727 
 728     int32_t transCount = transitionCount();
 729     if (transCount &gt; 0) {
 730         int16_t transitionIdx, typeIdx;
 731 
 732         // We probably no longer need to check the first &quot;real&quot; transition
 733         // here, because the new tzcode remove such transitions already.
 734         // For now, keeping this code for just in case. Feb 19, 2010 Yoshito
 735         firstTZTransitionIdx = 0;
 736         for (transitionIdx = 0; transitionIdx &lt; transCount; transitionIdx++) {
 737             if (typeMapData[transitionIdx] != 0) { // type 0 is the initial type
 738                 break;
 739             }
 740             firstTZTransitionIdx++;
 741         }
 742         if (transitionIdx == transCount) {
 743             // Actually no transitions...
 744         } else {
 745             // Build historic rule array
 746             UDate* times = (UDate*)uprv_malloc(sizeof(UDate)*transCount); /* large enough to store all transition times */
 747             if (times == NULL) {
 748                 status = U_MEMORY_ALLOCATION_ERROR;
 749                 deleteTransitionRules();
 750                 return;
 751             }
 752             for (typeIdx = 0; typeIdx &lt; typeCount; typeIdx++) {
 753                 // Gather all start times for each pair of offsets
 754                 int32_t nTimes = 0;
 755                 for (transitionIdx = firstTZTransitionIdx; transitionIdx &lt; transCount; transitionIdx++) {
 756                     if (typeIdx == (int16_t)typeMapData[transitionIdx]) {
 757                         UDate tt = (UDate)transitionTime(transitionIdx);
 758                         if (finalZone == NULL || tt &lt;= finalStartMillis) {
 759                             // Exclude transitions after finalMillis
 760                             times[nTimes++] = tt;
 761                         }
 762                     }
 763                 }
 764                 if (nTimes &gt; 0) {
 765                     // Create a TimeArrayTimeZoneRule
 766                     raw = typeOffsets[typeIdx &lt;&lt; 1] * U_MILLIS_PER_SECOND;
 767                     dst = typeOffsets[(typeIdx &lt;&lt; 1) + 1] * U_MILLIS_PER_SECOND;
 768                     if (historicRules == NULL) {
 769                         historicRuleCount = typeCount;
 770                         historicRules = (TimeArrayTimeZoneRule**)uprv_malloc(sizeof(TimeArrayTimeZoneRule*)*historicRuleCount);
 771                         if (historicRules == NULL) {
 772                             status = U_MEMORY_ALLOCATION_ERROR;
 773                             deleteTransitionRules();
 774                             uprv_free(times);
 775                             return;
 776                         }
 777                         for (int i = 0; i &lt; historicRuleCount; i++) {
 778                             // Initialize TimeArrayTimeZoneRule pointers as NULL
 779                             historicRules[i] = NULL;
 780                         }
 781                     }
 782                     historicRules[typeIdx] = new TimeArrayTimeZoneRule((dst == 0 ? stdName : dstName),
 783                         raw, dst, times, nTimes, DateTimeRule::UTC_TIME);
 784                     // Check for memory allocation error
 785                     if (historicRules[typeIdx] == NULL) {
 786                         status = U_MEMORY_ALLOCATION_ERROR;
 787                         deleteTransitionRules();
 788                         return;
 789                     }
 790                 }
 791             }
 792             uprv_free(times);
 793 
 794             // Create initial transition
 795             typeIdx = (int16_t)typeMapData[firstTZTransitionIdx];
 796             firstTZTransition = new TimeZoneTransition((UDate)transitionTime(firstTZTransitionIdx),
 797                     *initialRule, *historicRules[typeIdx]);
 798             // Check to make sure firstTZTransition was created.
 799             if (firstTZTransition == NULL) {
 800                 status = U_MEMORY_ALLOCATION_ERROR;
 801                 deleteTransitionRules();
 802                 return;
 803             }
 804         }
 805     }
 806     if (finalZone != NULL) {
 807         // Get the first occurence of final rule starts
 808         UDate startTime = (UDate)finalStartMillis;
 809         TimeZoneRule *firstFinalRule = NULL;
 810 
 811         if (finalZone-&gt;useDaylightTime()) {
 812             /*
 813              * Note: When an OlsonTimeZone is constructed, we should set the final year
 814              * as the start year of finalZone.  However, the bounday condition used for
 815              * getting offset from finalZone has some problems.
 816              * For now, we do not set the valid start year when the construction time
 817              * and create a clone and set the start year when extracting rules.
 818              */
 819             finalZoneWithStartYear = (SimpleTimeZone*)finalZone-&gt;clone();
 820             // Check to make sure finalZone was actually cloned.
 821             if (finalZoneWithStartYear == NULL) {
 822                 status = U_MEMORY_ALLOCATION_ERROR;
 823                 deleteTransitionRules();
 824                 return;
 825             }
 826             finalZoneWithStartYear-&gt;setStartYear(finalStartYear);
 827 
 828             TimeZoneTransition tzt;
 829             finalZoneWithStartYear-&gt;getNextTransition(startTime, false, tzt);
 830             firstFinalRule  = tzt.getTo()-&gt;clone();
 831             // Check to make sure firstFinalRule received proper clone.
 832             if (firstFinalRule == NULL) {
 833                 status = U_MEMORY_ALLOCATION_ERROR;
 834                 deleteTransitionRules();
 835                 return;
 836             }
 837             startTime = tzt.getTime();
 838         } else {
 839             // final rule with no transitions
 840             finalZoneWithStartYear = (SimpleTimeZone*)finalZone-&gt;clone();
 841             // Check to make sure finalZone was actually cloned.
 842             if (finalZoneWithStartYear == NULL) {
 843                 status = U_MEMORY_ALLOCATION_ERROR;
 844                 deleteTransitionRules();
 845                 return;
 846             }
 847             finalZone-&gt;getID(tzid);
 848             firstFinalRule = new TimeArrayTimeZoneRule(tzid,
 849                 finalZone-&gt;getRawOffset(), 0, &amp;startTime, 1, DateTimeRule::UTC_TIME);
 850             // Check firstFinalRule was properly created.
 851             if (firstFinalRule == NULL) {
 852                 status = U_MEMORY_ALLOCATION_ERROR;
 853                 deleteTransitionRules();
 854                 return;
 855             }
 856         }
 857         TimeZoneRule *prevRule = NULL;
 858         if (transCount &gt; 0) {
 859             prevRule = historicRules[typeMapData[transCount - 1]];
 860         }
 861         if (prevRule == NULL) {
 862             // No historic transitions, but only finalZone available
 863             prevRule = initialRule;
 864         }
 865         firstFinalTZTransition = new TimeZoneTransition();
 866         // Check to make sure firstFinalTZTransition was created before dereferencing
 867         if (firstFinalTZTransition == NULL) {
 868             status = U_MEMORY_ALLOCATION_ERROR;
 869             deleteTransitionRules();
 870             return;
 871         }
 872         firstFinalTZTransition-&gt;setTime(startTime);
 873         firstFinalTZTransition-&gt;adoptFrom(prevRule-&gt;clone());
 874         firstFinalTZTransition-&gt;adoptTo(firstFinalRule);
 875     }
 876 }
 877 
 878 UBool
 879 OlsonTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransition&amp; result) const {
 880     UErrorCode status = U_ZERO_ERROR;
 881     checkTransitionRules(status);
 882     if (U_FAILURE(status)) {
 883         return FALSE;
 884     }
 885 
 886     if (finalZone != NULL) {
 887         if (inclusive &amp;&amp; base == firstFinalTZTransition-&gt;getTime()) {
 888             result = *firstFinalTZTransition;
 889             return TRUE;
 890         } else if (base &gt;= firstFinalTZTransition-&gt;getTime()) {
 891             if (finalZone-&gt;useDaylightTime()) {
 892                 //return finalZone-&gt;getNextTransition(base, inclusive, result);
 893                 return finalZoneWithStartYear-&gt;getNextTransition(base, inclusive, result);
 894             } else {
 895                 // No more transitions
 896                 return FALSE;
 897             }
 898         }
 899     }
 900     if (historicRules != NULL) {
 901         // Find a historical transition
 902         int16_t transCount = transitionCount();
 903         int16_t ttidx = transCount - 1;
 904         for (; ttidx &gt;= firstTZTransitionIdx; ttidx--) {
 905             UDate t = (UDate)transitionTime(ttidx);
 906             if (base &gt; t || (!inclusive &amp;&amp; base == t)) {
 907                 break;
 908             }
 909         }
 910         if (ttidx == transCount - 1)  {
 911             if (firstFinalTZTransition != NULL) {
 912                 result = *firstFinalTZTransition;
 913                 return TRUE;
 914             } else {
 915                 return FALSE;
 916             }
 917         } else if (ttidx &lt; firstTZTransitionIdx) {
 918             result = *firstTZTransition;
 919             return TRUE;
 920         } else {
 921             // Create a TimeZoneTransition
 922             TimeZoneRule *to = historicRules[typeMapData[ttidx + 1]];
 923             TimeZoneRule *from = historicRules[typeMapData[ttidx]];
 924             UDate startTime = (UDate)transitionTime(ttidx+1);
 925 
 926             // The transitions loaded from zoneinfo.res may contain non-transition data
 927             UnicodeString fromName, toName;
 928             from-&gt;getName(fromName);
 929             to-&gt;getName(toName);
 930             if (fromName == toName &amp;&amp; from-&gt;getRawOffset() == to-&gt;getRawOffset()
 931                     &amp;&amp; from-&gt;getDSTSavings() == to-&gt;getDSTSavings()) {
 932                 return getNextTransition(startTime, false, result);
 933             }
 934             result.setTime(startTime);
 935             result.adoptFrom(from-&gt;clone());
 936             result.adoptTo(to-&gt;clone());
 937             return TRUE;
 938         }
 939     }
 940     return FALSE;
 941 }
 942 
 943 UBool
 944 OlsonTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTransition&amp; result) const {
 945     UErrorCode status = U_ZERO_ERROR;
 946     checkTransitionRules(status);
 947     if (U_FAILURE(status)) {
 948         return FALSE;
 949     }
 950 
 951     if (finalZone != NULL) {
 952         if (inclusive &amp;&amp; base == firstFinalTZTransition-&gt;getTime()) {
 953             result = *firstFinalTZTransition;
 954             return TRUE;
 955         } else if (base &gt; firstFinalTZTransition-&gt;getTime()) {
 956             if (finalZone-&gt;useDaylightTime()) {
 957                 //return finalZone-&gt;getPreviousTransition(base, inclusive, result);
 958                 return finalZoneWithStartYear-&gt;getPreviousTransition(base, inclusive, result);
 959             } else {
 960                 result = *firstFinalTZTransition;
 961                 return TRUE;
 962             }
 963         }
 964     }
 965 
 966     if (historicRules != NULL) {
 967         // Find a historical transition
 968         int16_t ttidx = transitionCount() - 1;
 969         for (; ttidx &gt;= firstTZTransitionIdx; ttidx--) {
 970             UDate t = (UDate)transitionTime(ttidx);
 971             if (base &gt; t || (inclusive &amp;&amp; base == t)) {
 972                 break;
 973             }
 974         }
 975         if (ttidx &lt; firstTZTransitionIdx) {
 976             // No more transitions
 977             return FALSE;
 978         } else if (ttidx == firstTZTransitionIdx) {
 979             result = *firstTZTransition;
 980             return TRUE;
 981         } else {
 982             // Create a TimeZoneTransition
 983             TimeZoneRule *to = historicRules[typeMapData[ttidx]];
 984             TimeZoneRule *from = historicRules[typeMapData[ttidx-1]];
 985             UDate startTime = (UDate)transitionTime(ttidx);
 986 
 987             // The transitions loaded from zoneinfo.res may contain non-transition data
 988             UnicodeString fromName, toName;
 989             from-&gt;getName(fromName);
 990             to-&gt;getName(toName);
 991             if (fromName == toName &amp;&amp; from-&gt;getRawOffset() == to-&gt;getRawOffset()
 992                     &amp;&amp; from-&gt;getDSTSavings() == to-&gt;getDSTSavings()) {
 993                 return getPreviousTransition(startTime, false, result);
 994             }
 995             result.setTime(startTime);
 996             result.adoptFrom(from-&gt;clone());
 997             result.adoptTo(to-&gt;clone());
 998             return TRUE;
 999         }
1000     }
1001     return FALSE;
1002 }
1003 
1004 int32_t
1005 OlsonTimeZone::countTransitionRules(UErrorCode&amp; status) const {
1006     if (U_FAILURE(status)) {
1007         return 0;
1008     }
1009     checkTransitionRules(status);
1010     if (U_FAILURE(status)) {
1011         return 0;
1012     }
1013 
1014     int32_t count = 0;
1015     if (historicRules != NULL) {
1016         // historicRules may contain null entries when original zoneinfo data
1017         // includes non transition data.
1018         for (int32_t i = 0; i &lt; historicRuleCount; i++) {
1019             if (historicRules[i] != NULL) {
1020                 count++;
1021             }
1022         }
1023     }
1024     if (finalZone != NULL) {
1025         if (finalZone-&gt;useDaylightTime()) {
1026             count += 2;
1027         } else {
1028             count++;
1029         }
1030     }
1031     return count;
1032 }
1033 
1034 void
1035 OlsonTimeZone::getTimeZoneRules(const InitialTimeZoneRule*&amp; initial,
1036                                 const TimeZoneRule* trsrules[],
1037                                 int32_t&amp; trscount,
1038                                 UErrorCode&amp; status) const {
1039     if (U_FAILURE(status)) {
1040         return;
1041     }
1042     checkTransitionRules(status);
1043     if (U_FAILURE(status)) {
1044         return;
1045     }
1046 
1047     // Initial rule
1048     initial = initialRule;
1049 
1050     // Transition rules
1051     int32_t cnt = 0;
1052     if (historicRules != NULL &amp;&amp; trscount &gt; cnt) {
1053         // historicRules may contain null entries when original zoneinfo data
1054         // includes non transition data.
1055         for (int32_t i = 0; i &lt; historicRuleCount; i++) {
1056             if (historicRules[i] != NULL) {
1057                 trsrules[cnt++] = historicRules[i];
1058                 if (cnt &gt;= trscount) {
1059                     break;
1060                 }
1061             }
1062         }
1063     }
1064     if (finalZoneWithStartYear != NULL &amp;&amp; trscount &gt; cnt) {
1065         const InitialTimeZoneRule *tmpini;
1066         int32_t tmpcnt = trscount - cnt;
1067         finalZoneWithStartYear-&gt;getTimeZoneRules(tmpini, &amp;trsrules[cnt], tmpcnt, status);
1068         if (U_FAILURE(status)) {
1069             return;
1070         }
1071         cnt += tmpcnt;
1072     }
1073     // Set the result length
1074     trscount = cnt;
1075 }
1076 
1077 U_NAMESPACE_END
1078 
1079 #endif // !UCONFIG_NO_FORMATTING
1080 
1081 //eof
    </pre>
  </body>
</html>