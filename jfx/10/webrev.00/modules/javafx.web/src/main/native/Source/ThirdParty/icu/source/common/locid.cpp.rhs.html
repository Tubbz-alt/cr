<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/locid.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4  **********************************************************************
   5  *   Copyright (C) 1997-2016, International Business Machines
   6  *   Corporation and others.  All Rights Reserved.
   7  **********************************************************************
   8 *
   9 * File locid.cpp
  10 *
  11 * Created by: Richard Gillam
  12 *
  13 * Modification History:
  14 *
  15 *   Date        Name        Description
  16 *   02/11/97    aliu        Changed gLocPath to fgDataDirectory and added
  17 *                           methods to get and set it.
  18 *   04/02/97    aliu        Made operator!= inline; fixed return value
  19 *                           of getName().
  20 *   04/15/97    aliu        Cleanup for AIX/Win32.
  21 *   04/24/97    aliu        Numerous changes per code review.
  22 *   08/18/98    stephen     Changed getDisplayName()
  23 *                           Added SIMPLIFIED_CHINESE, TRADITIONAL_CHINESE
  24 *                           Added getISOCountries(), getISOLanguages(),
  25 *                           getLanguagesForCountry()
  26 *   03/16/99    bertrand    rehaul.
  27 *   07/21/99    stephen     Added U_CFUNC setDefault
  28 *   11/09/99    weiv        Added const char * getName() const;
  29 *   04/12/00    srl         removing unicodestring api&#39;s and cached hash code
  30 *   08/10/01    grhoten     Change the static Locales to accessor functions
  31 ******************************************************************************
  32 */
  33 
<a name="1" id="anc1"></a><span class="line-added">  34 #include &lt;utility&gt;</span>
  35 
<a name="2" id="anc2"></a><span class="line-added">  36 #include &quot;unicode/bytestream.h&quot;</span>
  37 #include &quot;unicode/locid.h&quot;
  38 #include &quot;unicode/strenum.h&quot;
<a name="3" id="anc3"></a><span class="line-added">  39 #include &quot;unicode/stringpiece.h&quot;</span>
  40 #include &quot;unicode/uloc.h&quot;
  41 #include &quot;putilimp.h&quot;
  42 #include &quot;mutex.h&quot;
  43 #include &quot;umutex.h&quot;
  44 #include &quot;uassert.h&quot;
  45 #include &quot;cmemory.h&quot;
  46 #include &quot;cstring.h&quot;
  47 #include &quot;uassert.h&quot;
  48 #include &quot;uhash.h&quot;
<a name="4" id="anc4"></a><span class="line-added">  49 #include &quot;ulocimp.h&quot;</span>
  50 #include &quot;ucln_cmn.h&quot;
  51 #include &quot;ustr_imp.h&quot;
  52 #include &quot;charstr.h&quot;
<a name="5" id="anc5"></a><span class="line-added">  53 #include &quot;bytesinkutil.h&quot;</span>
  54 
  55 U_CDECL_BEGIN
  56 static UBool U_CALLCONV locale_cleanup(void);
  57 U_CDECL_END
  58 
  59 U_NAMESPACE_BEGIN
  60 
  61 static Locale   *gLocaleCache = NULL;
  62 static UInitOnce gLocaleCacheInitOnce = U_INITONCE_INITIALIZER;
  63 
  64 // gDefaultLocaleMutex protects all access to gDefaultLocalesHashT and gDefaultLocale.
<a name="6" id="anc6"></a><span class="line-modified">  65 static UMutex *gDefaultLocaleMutex() {</span>
<span class="line-added">  66     static UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added">  67     return &amp;m;</span>
<span class="line-added">  68 }</span>
  69 static UHashtable *gDefaultLocalesHashT = NULL;
  70 static Locale *gDefaultLocale = NULL;
  71 
  72 /**
  73  * \def ULOC_STRING_LIMIT
  74  * strings beyond this value crash in CharString
  75  */
  76 #define ULOC_STRING_LIMIT 357913941
  77 
  78 U_NAMESPACE_END
  79 
  80 typedef enum ELocalePos {
  81     eENGLISH,
  82     eFRENCH,
  83     eGERMAN,
  84     eITALIAN,
  85     eJAPANESE,
  86     eKOREAN,
  87     eCHINESE,
  88 
  89     eFRANCE,
  90     eGERMANY,
  91     eITALY,
  92     eJAPAN,
  93     eKOREA,
  94     eCHINA,      /* Alias for PRC */
  95     eTAIWAN,
  96     eUK,
  97     eUS,
  98     eCANADA,
  99     eCANADA_FRENCH,
 100     eROOT,
 101 
 102 
 103     //eDEFAULT,
 104     eMAX_LOCALES
 105 } ELocalePos;
 106 
 107 U_CFUNC int32_t locale_getKeywords(const char *localeID,
 108             char prev,
 109             char *keywords, int32_t keywordCapacity,
 110             char *values, int32_t valuesCapacity, int32_t *valLen,
 111             UBool valuesToo,
 112             UErrorCode *status);
 113 
 114 U_CDECL_BEGIN
 115 //
 116 // Deleter function for Locales owned by the default Locale hash table/
 117 //
 118 static void U_CALLCONV
 119 deleteLocale(void *obj) {
 120     delete (icu::Locale *) obj;
 121 }
 122 
 123 static UBool U_CALLCONV locale_cleanup(void)
 124 {
 125     U_NAMESPACE_USE
 126 
 127     delete [] gLocaleCache;
 128     gLocaleCache = NULL;
 129     gLocaleCacheInitOnce.reset();
 130 
 131     if (gDefaultLocalesHashT) {
 132         uhash_close(gDefaultLocalesHashT);   // Automatically deletes all elements, using deleter func.
 133         gDefaultLocalesHashT = NULL;
 134     }
 135     gDefaultLocale = NULL;
 136     return TRUE;
 137 }
 138 
 139 
 140 static void U_CALLCONV locale_init(UErrorCode &amp;status) {
 141     U_NAMESPACE_USE
 142 
 143     U_ASSERT(gLocaleCache == NULL);
 144     gLocaleCache = new Locale[(int)eMAX_LOCALES];
 145     if (gLocaleCache == NULL) {
 146         status = U_MEMORY_ALLOCATION_ERROR;
 147         return;
 148     }
 149     ucln_common_registerCleanup(UCLN_COMMON_LOCALE, locale_cleanup);
 150     gLocaleCache[eROOT]          = Locale(&quot;&quot;);
 151     gLocaleCache[eENGLISH]       = Locale(&quot;en&quot;);
 152     gLocaleCache[eFRENCH]        = Locale(&quot;fr&quot;);
 153     gLocaleCache[eGERMAN]        = Locale(&quot;de&quot;);
 154     gLocaleCache[eITALIAN]       = Locale(&quot;it&quot;);
 155     gLocaleCache[eJAPANESE]      = Locale(&quot;ja&quot;);
 156     gLocaleCache[eKOREAN]        = Locale(&quot;ko&quot;);
 157     gLocaleCache[eCHINESE]       = Locale(&quot;zh&quot;);
 158     gLocaleCache[eFRANCE]        = Locale(&quot;fr&quot;, &quot;FR&quot;);
 159     gLocaleCache[eGERMANY]       = Locale(&quot;de&quot;, &quot;DE&quot;);
 160     gLocaleCache[eITALY]         = Locale(&quot;it&quot;, &quot;IT&quot;);
 161     gLocaleCache[eJAPAN]         = Locale(&quot;ja&quot;, &quot;JP&quot;);
 162     gLocaleCache[eKOREA]         = Locale(&quot;ko&quot;, &quot;KR&quot;);
 163     gLocaleCache[eCHINA]         = Locale(&quot;zh&quot;, &quot;CN&quot;);
 164     gLocaleCache[eTAIWAN]        = Locale(&quot;zh&quot;, &quot;TW&quot;);
 165     gLocaleCache[eUK]            = Locale(&quot;en&quot;, &quot;GB&quot;);
 166     gLocaleCache[eUS]            = Locale(&quot;en&quot;, &quot;US&quot;);
 167     gLocaleCache[eCANADA]        = Locale(&quot;en&quot;, &quot;CA&quot;);
 168     gLocaleCache[eCANADA_FRENCH] = Locale(&quot;fr&quot;, &quot;CA&quot;);
 169 }
 170 
 171 U_CDECL_END
 172 
 173 U_NAMESPACE_BEGIN
 174 
 175 Locale *locale_set_default_internal(const char *id, UErrorCode&amp; status) {
 176     // Synchronize this entire function.
<a name="7" id="anc7"></a><span class="line-modified"> 177     Mutex lock(gDefaultLocaleMutex());</span>
 178 
 179     UBool canonicalize = FALSE;
 180 
 181     // If given a NULL string for the locale id, grab the default
 182     //   name from the system.
 183     //   (Different from most other locale APIs, where a null name means use
 184     //    the current ICU default locale.)
 185     if (id == NULL) {
 186         id = uprv_getDefaultLocaleID();   // This function not thread safe? TODO: verify.
 187         canonicalize = TRUE; // always canonicalize host ID
 188     }
 189 
 190     char localeNameBuf[512];
 191 
 192     if (canonicalize) {
 193         uloc_canonicalize(id, localeNameBuf, sizeof(localeNameBuf)-1, &amp;status);
 194     } else {
 195         uloc_getName(id, localeNameBuf, sizeof(localeNameBuf)-1, &amp;status);
 196     }
 197     localeNameBuf[sizeof(localeNameBuf)-1] = 0;  // Force null termination in event of
 198                                                  //   a long name filling the buffer.
 199                                                  //   (long names are truncated.)
 200                                                  //
 201     if (U_FAILURE(status)) {
 202         return gDefaultLocale;
 203     }
 204 
 205     if (gDefaultLocalesHashT == NULL) {
 206         gDefaultLocalesHashT = uhash_open(uhash_hashChars, uhash_compareChars, NULL, &amp;status);
 207         if (U_FAILURE(status)) {
 208             return gDefaultLocale;
 209         }
 210         uhash_setValueDeleter(gDefaultLocalesHashT, deleteLocale);
 211         ucln_common_registerCleanup(UCLN_COMMON_LOCALE, locale_cleanup);
 212     }
 213 
 214     Locale *newDefault = (Locale *)uhash_get(gDefaultLocalesHashT, localeNameBuf);
 215     if (newDefault == NULL) {
 216         newDefault = new Locale(Locale::eBOGUS);
 217         if (newDefault == NULL) {
 218             status = U_MEMORY_ALLOCATION_ERROR;
 219             return gDefaultLocale;
 220         }
 221         newDefault-&gt;init(localeNameBuf, FALSE);
 222         uhash_put(gDefaultLocalesHashT, (char*) newDefault-&gt;getName(), newDefault, &amp;status);
 223         if (U_FAILURE(status)) {
 224             return gDefaultLocale;
 225         }
 226     }
 227     gDefaultLocale = newDefault;
 228     return gDefaultLocale;
 229 }
 230 
 231 U_NAMESPACE_END
 232 
 233 /* sfb 07/21/99 */
 234 U_CFUNC void
 235 locale_set_default(const char *id)
 236 {
 237     U_NAMESPACE_USE
 238     UErrorCode status = U_ZERO_ERROR;
 239     locale_set_default_internal(id, status);
 240 }
 241 /* end */
 242 
 243 U_CFUNC const char *
 244 locale_get_default(void)
 245 {
 246     U_NAMESPACE_USE
 247     return Locale::getDefault().getName();
 248 }
 249 
 250 
 251 U_NAMESPACE_BEGIN
 252 
 253 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(Locale)
 254 
 255 /*Character separating the posix id fields*/
 256 // &#39;_&#39;
 257 // In the platform codepage.
 258 #define SEP_CHAR &#39;_&#39;
 259 
 260 Locale::~Locale()
 261 {
 262     if (baseName != fullName) {
 263         uprv_free(baseName);
 264     }
 265     baseName = NULL;
 266     /*if fullName is on the heap, we free it*/
 267     if (fullName != fullNameBuffer)
 268     {
 269         uprv_free(fullName);
 270         fullName = NULL;
 271     }
 272 }
 273 
 274 Locale::Locale()
 275     : UObject(), fullName(fullNameBuffer), baseName(NULL)
 276 {
 277     init(NULL, FALSE);
 278 }
 279 
 280 /*
 281  * Internal constructor to allow construction of a locale object with
 282  *   NO side effects.   (Default constructor tries to get
 283  *   the default locale.)
 284  */
 285 Locale::Locale(Locale::ELocaleType)
 286     : UObject(), fullName(fullNameBuffer), baseName(NULL)
 287 {
 288     setToBogus();
 289 }
 290 
 291 
 292 Locale::Locale( const   char * newLanguage,
 293                 const   char * newCountry,
 294                 const   char * newVariant,
 295                 const   char * newKeywords)
 296     : UObject(), fullName(fullNameBuffer), baseName(NULL)
 297 {
 298     if( (newLanguage==NULL) &amp;&amp; (newCountry == NULL) &amp;&amp; (newVariant == NULL) )
 299     {
 300         init(NULL, FALSE); /* shortcut */
 301     }
 302     else
 303     {
 304         UErrorCode status = U_ZERO_ERROR;
 305         int32_t size = 0;
 306         int32_t lsize = 0;
 307         int32_t csize = 0;
 308         int32_t vsize = 0;
 309         int32_t ksize = 0;
 310 
 311         // Calculate the size of the resulting string.
 312 
 313         // Language
 314         if ( newLanguage != NULL )
 315         {
 316             lsize = (int32_t)uprv_strlen(newLanguage);
 317             if ( lsize &lt; 0 || lsize &gt; ULOC_STRING_LIMIT ) { // int32 wrap
 318                 setToBogus();
 319                 return;
 320             }
 321             size = lsize;
 322         }
 323 
 324         CharString togo(newLanguage, lsize, status); // start with newLanguage
 325 
 326         // _Country
 327         if ( newCountry != NULL )
 328         {
 329             csize = (int32_t)uprv_strlen(newCountry);
 330             if ( csize &lt; 0 || csize &gt; ULOC_STRING_LIMIT ) { // int32 wrap
 331                 setToBogus();
 332                 return;
 333             }
 334             size += csize;
 335         }
 336 
 337         // _Variant
 338         if ( newVariant != NULL )
 339         {
 340             // remove leading _&#39;s
 341             while(newVariant[0] == SEP_CHAR)
 342             {
 343                 newVariant++;
 344             }
 345 
 346             // remove trailing _&#39;s
 347             vsize = (int32_t)uprv_strlen(newVariant);
 348             if ( vsize &lt; 0 || vsize &gt; ULOC_STRING_LIMIT ) { // int32 wrap
 349                 setToBogus();
 350                 return;
 351             }
 352             while( (vsize&gt;1) &amp;&amp; (newVariant[vsize-1] == SEP_CHAR) )
 353             {
 354                 vsize--;
 355             }
 356         }
 357 
 358         if( vsize &gt; 0 )
 359         {
 360             size += vsize;
 361         }
 362 
 363         // Separator rules:
 364         if ( vsize &gt; 0 )
 365         {
 366             size += 2;  // at least: __v
 367         }
 368         else if ( csize &gt; 0 )
 369         {
 370             size += 1;  // at least: _v
 371         }
 372 
 373         if ( newKeywords != NULL)
 374         {
 375             ksize = (int32_t)uprv_strlen(newKeywords);
 376             if ( ksize &lt; 0 || ksize &gt; ULOC_STRING_LIMIT ) {
 377               setToBogus();
 378               return;
 379             }
 380             size += ksize + 1;
 381         }
 382 
 383         //  NOW we have the full locale string..
 384         // Now, copy it back.
 385 
 386         // newLanguage is already copied
 387 
 388         if ( ( vsize != 0 ) || (csize != 0) )  // at least:  __v
 389         {                                      //            ^
 390             togo.append(SEP_CHAR, status);
 391         }
 392 
 393         if ( csize != 0 )
 394         {
 395             togo.append(newCountry, status);
 396         }
 397 
 398         if ( vsize != 0)
 399         {
 400             togo.append(SEP_CHAR, status)
 401                 .append(newVariant, vsize, status);
 402         }
 403 
 404         if ( ksize != 0)
 405         {
 406             if (uprv_strchr(newKeywords, &#39;=&#39;)) {
 407                 togo.append(&#39;@&#39;, status); /* keyword parsing */
 408             }
 409             else {
 410                 togo.append(&#39;_&#39;, status); /* Variant parsing with a script */
 411                 if ( vsize == 0) {
 412                     togo.append(&#39;_&#39;, status); /* No country found */
 413                 }
 414             }
 415             togo.append(newKeywords, status);
 416         }
 417 
 418         if (U_FAILURE(status)) {
 419             // Something went wrong with appending, etc.
 420             setToBogus();
 421             return;
 422         }
 423         // Parse it, because for example &#39;language&#39; might really be a complete
 424         // string.
 425         init(togo.data(), FALSE);
 426     }
 427 }
 428 
 429 Locale::Locale(const Locale &amp;other)
 430     : UObject(other), fullName(fullNameBuffer), baseName(NULL)
 431 {
 432     *this = other;
 433 }
 434 
<a name="8" id="anc8"></a><span class="line-modified"> 435 Locale::Locale(Locale&amp;&amp; other) U_NOEXCEPT</span>
<span class="line-modified"> 436     : UObject(other), fullName(fullNameBuffer), baseName(fullName) {</span>
<span class="line-added"> 437   *this = std::move(other);</span>
<span class="line-added"> 438 }</span>
<span class="line-added"> 439 </span>
<span class="line-added"> 440 Locale&amp; Locale::operator=(const Locale&amp; other) {</span>
 441     if (this == &amp;other) {
 442         return *this;
 443     }
 444 
<a name="9" id="anc9"></a><span class="line-modified"> 445     setToBogus();</span>
<span class="line-modified"> 446 </span>
<span class="line-modified"> 447     if (other.fullName == other.fullNameBuffer) {</span>
<span class="line-added"> 448         uprv_strcpy(fullNameBuffer, other.fullNameBuffer);</span>
<span class="line-added"> 449     } else if (other.fullName == nullptr) {</span>
<span class="line-added"> 450         fullName = nullptr;</span>
<span class="line-added"> 451     } else {</span>
<span class="line-added"> 452         fullName = uprv_strdup(other.fullName);</span>
<span class="line-added"> 453         if (fullName == nullptr) return *this;</span>
 454     }
<a name="10" id="anc10"></a><span class="line-modified"> 455 </span>
<span class="line-modified"> 456     if (other.baseName == other.fullName) {</span>
<span class="line-modified"> 457         baseName = fullName;</span>
<span class="line-modified"> 458     } else if (other.baseName != nullptr) {</span>
<span class="line-added"> 459         baseName = uprv_strdup(other.baseName);</span>
<span class="line-added"> 460         if (baseName == nullptr) return *this;</span>
 461     }
 462 
<a name="11" id="anc11"></a><span class="line-modified"> 463     uprv_strcpy(language, other.language);</span>
<span class="line-modified"> 464     uprv_strcpy(script, other.script);</span>
<span class="line-modified"> 465     uprv_strcpy(country, other.country);</span>
<span class="line-modified"> 466 </span>
<span class="line-modified"> 467     variantBegin = other.variantBegin;</span>
<span class="line-modified"> 468     fIsBogus = other.fIsBogus;</span>
<span class="line-added"> 469 </span>
<span class="line-added"> 470     return *this;</span>
<span class="line-added"> 471 }</span>
<span class="line-added"> 472 </span>
<span class="line-added"> 473 Locale&amp; Locale::operator=(Locale&amp;&amp; other) U_NOEXCEPT {</span>
<span class="line-added"> 474     if (baseName != fullName) uprv_free(baseName);</span>
<span class="line-added"> 475     if (fullName != fullNameBuffer) uprv_free(fullName);</span>
<span class="line-added"> 476 </span>
<span class="line-added"> 477     if (other.fullName == other.fullNameBuffer) {</span>
<span class="line-added"> 478         uprv_strcpy(fullNameBuffer, other.fullNameBuffer);</span>
<span class="line-added"> 479         fullName = fullNameBuffer;</span>
<span class="line-added"> 480     } else {</span>
<span class="line-added"> 481         fullName = other.fullName;</span>
 482     }
<a name="12" id="anc12"></a>

 483 
<a name="13" id="anc13"></a>
 484     if (other.baseName == other.fullName) {
 485         baseName = fullName;
 486     } else {
<a name="14" id="anc14"></a><span class="line-modified"> 487         baseName = other.baseName;</span>


 488     }
 489 
<a name="15" id="anc15"></a>
 490     uprv_strcpy(language, other.language);
 491     uprv_strcpy(script, other.script);
 492     uprv_strcpy(country, other.country);
 493 
<a name="16" id="anc16"></a>
 494     variantBegin = other.variantBegin;
 495     fIsBogus = other.fIsBogus;
<a name="17" id="anc17"></a><span class="line-added"> 496 </span>
<span class="line-added"> 497     other.baseName = other.fullName = other.fullNameBuffer;</span>
<span class="line-added"> 498 </span>
 499     return *this;
 500 }
 501 
 502 Locale *
 503 Locale::clone() const {
 504     return new Locale(*this);
 505 }
 506 
 507 UBool
 508 Locale::operator==( const   Locale&amp; other) const
 509 {
 510     return (uprv_strcmp(other.fullName, fullName) == 0);
 511 }
 512 
 513 #define ISASCIIALPHA(c) (((c) &gt;= &#39;a&#39; &amp;&amp; (c) &lt;= &#39;z&#39;) || ((c) &gt;= &#39;A&#39; &amp;&amp; (c) &lt;= &#39;Z&#39;))
 514 
 515 /*This function initializes a Locale from a C locale ID*/
 516 Locale&amp; Locale::init(const char* localeID, UBool canonicalize)
 517 {
 518     fIsBogus = FALSE;
 519     /* Free our current storage */
 520     if (baseName != fullName) {
 521         uprv_free(baseName);
 522     }
 523     baseName = NULL;
 524     if(fullName != fullNameBuffer) {
 525         uprv_free(fullName);
 526         fullName = fullNameBuffer;
 527     }
 528 
 529     // not a loop:
 530     // just an easy way to have a common error-exit
 531     // without goto and without another function
 532     do {
 533         char *separator;
 534         char *field[5] = {0};
 535         int32_t fieldLen[5] = {0};
 536         int32_t fieldIdx;
 537         int32_t variantField;
 538         int32_t length;
 539         UErrorCode err;
 540 
 541         if(localeID == NULL) {
 542             // not an error, just set the default locale
 543             return *this = getDefault();
 544         }
 545 
 546         /* preset all fields to empty */
 547         language[0] = script[0] = country[0] = 0;
 548 
 549         // &quot;canonicalize&quot; the locale ID to ICU/Java format
 550         err = U_ZERO_ERROR;
 551         length = canonicalize ?
 552             uloc_canonicalize(localeID, fullName, sizeof(fullNameBuffer), &amp;err) :
 553             uloc_getName(localeID, fullName, sizeof(fullNameBuffer), &amp;err);
 554 
 555         if(err == U_BUFFER_OVERFLOW_ERROR || length &gt;= (int32_t)sizeof(fullNameBuffer)) {
 556             /*Go to heap for the fullName if necessary*/
 557             fullName = (char *)uprv_malloc(sizeof(char)*(length + 1));
 558             if(fullName == 0) {
 559                 fullName = fullNameBuffer;
 560                 break; // error: out of memory
 561             }
 562             err = U_ZERO_ERROR;
 563             length = canonicalize ?
 564                 uloc_canonicalize(localeID, fullName, length+1, &amp;err) :
 565                 uloc_getName(localeID, fullName, length+1, &amp;err);
 566         }
 567         if(U_FAILURE(err) || err == U_STRING_NOT_TERMINATED_WARNING) {
 568             /* should never occur */
 569             break;
 570         }
 571 
 572         variantBegin = length;
 573 
 574         /* after uloc_getName/canonicalize() we know that only &#39;_&#39; are separators */
<a name="18" id="anc18"></a><span class="line-added"> 575         /* But _ could also appeared in timezone such as &quot;en@timezone=America/Los_Angeles&quot; */</span>
 576         separator = field[0] = fullName;
 577         fieldIdx = 1;
<a name="19" id="anc19"></a><span class="line-modified"> 578         char* at = uprv_strchr(fullName, &#39;@&#39;);</span>
<span class="line-added"> 579         while ((separator = uprv_strchr(field[fieldIdx-1], SEP_CHAR)) != 0 &amp;&amp;</span>
<span class="line-added"> 580                fieldIdx &lt; UPRV_LENGTHOF(field)-1 &amp;&amp;</span>
<span class="line-added"> 581                (at == nullptr || separator &lt; at)) {</span>
 582             field[fieldIdx] = separator + 1;
 583             fieldLen[fieldIdx-1] = (int32_t)(separator - field[fieldIdx-1]);
 584             fieldIdx++;
 585         }
 586         // variant may contain @foo or .foo POSIX cruft; remove it
 587         separator = uprv_strchr(field[fieldIdx-1], &#39;@&#39;);
 588         char* sep2 = uprv_strchr(field[fieldIdx-1], &#39;.&#39;);
 589         if (separator!=NULL || sep2!=NULL) {
 590             if (separator==NULL || (sep2!=NULL &amp;&amp; separator &gt; sep2)) {
 591                 separator = sep2;
 592             }
 593             fieldLen[fieldIdx-1] = (int32_t)(separator - field[fieldIdx-1]);
 594         } else {
 595             fieldLen[fieldIdx-1] = length - (int32_t)(field[fieldIdx-1] - fullName);
 596         }
 597 
 598         if (fieldLen[0] &gt;= (int32_t)(sizeof(language)))
 599         {
 600             break; // error: the language field is too long
 601         }
 602 
 603         variantField = 1; /* Usually the 2nd one, except when a script or country is also used. */
 604         if (fieldLen[0] &gt; 0) {
 605             /* We have a language */
 606             uprv_memcpy(language, fullName, fieldLen[0]);
 607             language[fieldLen[0]] = 0;
 608         }
 609         if (fieldLen[1] == 4 &amp;&amp; ISASCIIALPHA(field[1][0]) &amp;&amp;
 610                 ISASCIIALPHA(field[1][1]) &amp;&amp; ISASCIIALPHA(field[1][2]) &amp;&amp;
 611                 ISASCIIALPHA(field[1][3])) {
 612             /* We have at least a script */
 613             uprv_memcpy(script, field[1], fieldLen[1]);
 614             script[fieldLen[1]] = 0;
 615             variantField++;
 616         }
 617 
 618         if (fieldLen[variantField] == 2 || fieldLen[variantField] == 3) {
 619             /* We have a country */
 620             uprv_memcpy(country, field[variantField], fieldLen[variantField]);
 621             country[fieldLen[variantField]] = 0;
 622             variantField++;
 623         } else if (fieldLen[variantField] == 0) {
 624             variantField++; /* script or country empty but variant in next field (i.e. en__POSIX) */
 625         }
 626 
 627         if (fieldLen[variantField] &gt; 0) {
 628             /* We have a variant */
 629             variantBegin = (int32_t)(field[variantField] - fullName);
 630         }
 631 
 632         err = U_ZERO_ERROR;
 633         initBaseName(err);
 634         if (U_FAILURE(err)) {
 635             break;
 636         }
 637 
 638         // successful end of init()
 639         return *this;
 640     } while(0); /*loop doesn&#39;t iterate*/
 641 
 642     // when an error occurs, then set this object to &quot;bogus&quot; (there is no UErrorCode here)
 643     setToBogus();
 644 
 645     return *this;
 646 }
 647 
 648 /*
 649  * Set up the base name.
 650  * If there are no key words, it&#39;s exactly the full name.
 651  * If key words exist, it&#39;s the full name truncated at the &#39;@&#39; character.
 652  * Need to set up both at init() and after setting a keyword.
 653  */
 654 void
 655 Locale::initBaseName(UErrorCode &amp;status) {
 656     if (U_FAILURE(status)) {
 657         return;
 658     }
 659     U_ASSERT(baseName==NULL || baseName==fullName);
 660     const char *atPtr = uprv_strchr(fullName, &#39;@&#39;);
 661     const char *eqPtr = uprv_strchr(fullName, &#39;=&#39;);
 662     if (atPtr &amp;&amp; eqPtr &amp;&amp; atPtr &lt; eqPtr) {
 663         // Key words exist.
 664         int32_t baseNameLength = (int32_t)(atPtr - fullName);
 665         baseName = (char *)uprv_malloc(baseNameLength + 1);
 666         if (baseName == NULL) {
 667             status = U_MEMORY_ALLOCATION_ERROR;
 668             return;
 669         }
 670         uprv_strncpy(baseName, fullName, baseNameLength);
 671         baseName[baseNameLength] = 0;
 672 
 673         // The original computation of variantBegin leaves it equal to the length
 674         // of fullName if there is no variant.  It should instead be
 675         // the length of the baseName.
 676         if (variantBegin &gt; baseNameLength) {
 677             variantBegin = baseNameLength;
 678         }
 679     } else {
 680         baseName = fullName;
 681     }
 682 }
 683 
 684 
 685 int32_t
 686 Locale::hashCode() const
 687 {
<a name="20" id="anc20"></a><span class="line-modified"> 688     return ustr_hashCharsN(fullName, static_cast&lt;int32_t&gt;(uprv_strlen(fullName)));</span>
 689 }
 690 
 691 void
 692 Locale::setToBogus() {
 693     /* Free our current storage */
 694     if(baseName != fullName) {
 695         uprv_free(baseName);
 696     }
 697     baseName = NULL;
 698     if(fullName != fullNameBuffer) {
 699         uprv_free(fullName);
 700         fullName = fullNameBuffer;
 701     }
 702     *fullNameBuffer = 0;
 703     *language = 0;
 704     *script = 0;
 705     *country = 0;
 706     fIsBogus = TRUE;
 707     variantBegin = 0;
 708 }
 709 
 710 const Locale&amp; U_EXPORT2
 711 Locale::getDefault()
 712 {
 713     {
<a name="21" id="anc21"></a><span class="line-modified"> 714         Mutex lock(gDefaultLocaleMutex());</span>
 715         if (gDefaultLocale != NULL) {
 716             return *gDefaultLocale;
 717         }
 718     }
 719     UErrorCode status = U_ZERO_ERROR;
 720     return *locale_set_default_internal(NULL, status);
 721 }
 722 
 723 
 724 
 725 void U_EXPORT2
 726 Locale::setDefault( const   Locale&amp;     newLocale,
 727                             UErrorCode&amp;  status)
 728 {
 729     if (U_FAILURE(status)) {
 730         return;
 731     }
 732 
 733     /* Set the default from the full name string of the supplied locale.
 734      * This is a convenient way to access the default locale caching mechanisms.
 735      */
 736     const char *localeID = newLocale.getName();
 737     locale_set_default_internal(localeID, status);
 738 }
 739 
<a name="22" id="anc22"></a><span class="line-added"> 740 void</span>
<span class="line-added"> 741 Locale::addLikelySubtags(UErrorCode&amp; status) {</span>
<span class="line-added"> 742     if (U_FAILURE(status)) {</span>
<span class="line-added"> 743         return;</span>
<span class="line-added"> 744     }</span>
<span class="line-added"> 745 </span>
<span class="line-added"> 746     CharString maximizedLocaleID;</span>
<span class="line-added"> 747     {</span>
<span class="line-added"> 748         CharStringByteSink sink(&amp;maximizedLocaleID);</span>
<span class="line-added"> 749         ulocimp_addLikelySubtags(fullName, sink, &amp;status);</span>
<span class="line-added"> 750     }</span>
<span class="line-added"> 751 </span>
<span class="line-added"> 752     if (U_FAILURE(status)) {</span>
<span class="line-added"> 753         return;</span>
<span class="line-added"> 754     }</span>
<span class="line-added"> 755 </span>
<span class="line-added"> 756     init(maximizedLocaleID.data(), /*canonicalize=*/FALSE);</span>
<span class="line-added"> 757     if (isBogus()) {</span>
<span class="line-added"> 758         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added"> 759     }</span>
<span class="line-added"> 760 }</span>
<span class="line-added"> 761 </span>
<span class="line-added"> 762 void</span>
<span class="line-added"> 763 Locale::minimizeSubtags(UErrorCode&amp; status) {</span>
<span class="line-added"> 764     if (U_FAILURE(status)) {</span>
<span class="line-added"> 765         return;</span>
<span class="line-added"> 766     }</span>
<span class="line-added"> 767 </span>
<span class="line-added"> 768     CharString minimizedLocaleID;</span>
<span class="line-added"> 769     {</span>
<span class="line-added"> 770         CharStringByteSink sink(&amp;minimizedLocaleID);</span>
<span class="line-added"> 771         ulocimp_minimizeSubtags(fullName, sink, &amp;status);</span>
<span class="line-added"> 772     }</span>
<span class="line-added"> 773 </span>
<span class="line-added"> 774     if (U_FAILURE(status)) {</span>
<span class="line-added"> 775         return;</span>
<span class="line-added"> 776     }</span>
<span class="line-added"> 777 </span>
<span class="line-added"> 778     init(minimizedLocaleID.data(), /*canonicalize=*/FALSE);</span>
<span class="line-added"> 779     if (isBogus()) {</span>
<span class="line-added"> 780         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added"> 781     }</span>
<span class="line-added"> 782 }</span>
<span class="line-added"> 783 </span>
<span class="line-added"> 784 Locale U_EXPORT2</span>
<span class="line-added"> 785 Locale::forLanguageTag(StringPiece tag, UErrorCode&amp; status)</span>
<span class="line-added"> 786 {</span>
<span class="line-added"> 787     Locale result(Locale::eBOGUS);</span>
<span class="line-added"> 788 </span>
<span class="line-added"> 789     if (U_FAILURE(status)) {</span>
<span class="line-added"> 790         return result;</span>
<span class="line-added"> 791     }</span>
<span class="line-added"> 792 </span>
<span class="line-added"> 793     // If a BCP-47 language tag is passed as the language parameter to the</span>
<span class="line-added"> 794     // normal Locale constructor, it will actually fall back to invoking</span>
<span class="line-added"> 795     // uloc_forLanguageTag() to parse it if it somehow is able to detect that</span>
<span class="line-added"> 796     // the string actually is BCP-47. This works well for things like strings</span>
<span class="line-added"> 797     // using BCP-47 extensions, but it does not at all work for things like</span>
<span class="line-added"> 798     // BCP-47 grandfathered tags (eg. &quot;en-GB-oed&quot;) which are possible to also</span>
<span class="line-added"> 799     // interpret as ICU locale IDs and because of that won&#39;t trigger the BCP-47</span>
<span class="line-added"> 800     // parsing. Therefore the code here explicitly calls uloc_forLanguageTag()</span>
<span class="line-added"> 801     // and then Locale::init(), instead of just calling the normal constructor.</span>
<span class="line-added"> 802 </span>
<span class="line-added"> 803     CharString localeID;</span>
<span class="line-added"> 804     int32_t parsedLength;</span>
<span class="line-added"> 805     {</span>
<span class="line-added"> 806         CharStringByteSink sink(&amp;localeID);</span>
<span class="line-added"> 807         ulocimp_forLanguageTag(</span>
<span class="line-added"> 808                 tag.data(),</span>
<span class="line-added"> 809                 tag.length(),</span>
<span class="line-added"> 810                 sink,</span>
<span class="line-added"> 811                 &amp;parsedLength,</span>
<span class="line-added"> 812                 &amp;status);</span>
<span class="line-added"> 813     }</span>
<span class="line-added"> 814 </span>
<span class="line-added"> 815     if (U_FAILURE(status)) {</span>
<span class="line-added"> 816         return result;</span>
<span class="line-added"> 817     }</span>
<span class="line-added"> 818 </span>
<span class="line-added"> 819     if (parsedLength != tag.size()) {</span>
<span class="line-added"> 820         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added"> 821         return result;</span>
<span class="line-added"> 822     }</span>
<span class="line-added"> 823 </span>
<span class="line-added"> 824     result.init(localeID.data(), /*canonicalize=*/FALSE);</span>
<span class="line-added"> 825     if (result.isBogus()) {</span>
<span class="line-added"> 826         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added"> 827     }</span>
<span class="line-added"> 828     return result;</span>
<span class="line-added"> 829 }</span>
<span class="line-added"> 830 </span>
<span class="line-added"> 831 void</span>
<span class="line-added"> 832 Locale::toLanguageTag(ByteSink&amp; sink, UErrorCode&amp; status) const</span>
<span class="line-added"> 833 {</span>
<span class="line-added"> 834     if (U_FAILURE(status)) {</span>
<span class="line-added"> 835         return;</span>
<span class="line-added"> 836     }</span>
<span class="line-added"> 837 </span>
<span class="line-added"> 838     if (fIsBogus) {</span>
<span class="line-added"> 839         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added"> 840         return;</span>
<span class="line-added"> 841     }</span>
<span class="line-added"> 842 </span>
<span class="line-added"> 843     ulocimp_toLanguageTag(fullName, sink, /*strict=*/FALSE, &amp;status);</span>
<span class="line-added"> 844 }</span>
<span class="line-added"> 845 </span>
 846 Locale U_EXPORT2
 847 Locale::createFromName (const char *name)
 848 {
 849     if (name) {
 850         Locale l(&quot;&quot;);
 851         l.init(name, FALSE);
 852         return l;
 853     }
 854     else {
 855         return getDefault();
 856     }
 857 }
 858 
 859 Locale U_EXPORT2
 860 Locale::createCanonical(const char* name) {
 861     Locale loc(&quot;&quot;);
 862     loc.init(name, TRUE);
 863     return loc;
 864 }
 865 
 866 const char *
 867 Locale::getISO3Language() const
 868 {
 869     return uloc_getISO3Language(fullName);
 870 }
 871 
 872 
 873 const char *
 874 Locale::getISO3Country() const
 875 {
 876     return uloc_getISO3Country(fullName);
 877 }
 878 
 879 /**
 880  * Return the LCID value as specified in the &quot;LocaleID&quot; resource for this
 881  * locale.  The LocaleID must be expressed as a hexadecimal number, from
 882  * one to four digits.  If the LocaleID resource is not present, or is
 883  * in an incorrect format, 0 is returned.  The LocaleID is for use in
 884  * Windows (it is an LCID), but is available on all platforms.
 885  */
 886 uint32_t
 887 Locale::getLCID() const
 888 {
 889     return uloc_getLCID(fullName);
 890 }
 891 
 892 const char* const* U_EXPORT2 Locale::getISOCountries()
 893 {
 894     return uloc_getISOCountries();
 895 }
 896 
 897 const char* const* U_EXPORT2 Locale::getISOLanguages()
 898 {
 899     return uloc_getISOLanguages();
 900 }
 901 
 902 // Set the locale&#39;s data based on a posix id.
 903 void Locale::setFromPOSIXID(const char *posixID)
 904 {
 905     init(posixID, TRUE);
 906 }
 907 
 908 const Locale &amp; U_EXPORT2
 909 Locale::getRoot(void)
 910 {
 911     return getLocale(eROOT);
 912 }
 913 
 914 const Locale &amp; U_EXPORT2
 915 Locale::getEnglish(void)
 916 {
 917     return getLocale(eENGLISH);
 918 }
 919 
 920 const Locale &amp; U_EXPORT2
 921 Locale::getFrench(void)
 922 {
 923     return getLocale(eFRENCH);
 924 }
 925 
 926 const Locale &amp; U_EXPORT2
 927 Locale::getGerman(void)
 928 {
 929     return getLocale(eGERMAN);
 930 }
 931 
 932 const Locale &amp; U_EXPORT2
 933 Locale::getItalian(void)
 934 {
 935     return getLocale(eITALIAN);
 936 }
 937 
 938 const Locale &amp; U_EXPORT2
 939 Locale::getJapanese(void)
 940 {
 941     return getLocale(eJAPANESE);
 942 }
 943 
 944 const Locale &amp; U_EXPORT2
 945 Locale::getKorean(void)
 946 {
 947     return getLocale(eKOREAN);
 948 }
 949 
 950 const Locale &amp; U_EXPORT2
 951 Locale::getChinese(void)
 952 {
 953     return getLocale(eCHINESE);
 954 }
 955 
 956 const Locale &amp; U_EXPORT2
 957 Locale::getSimplifiedChinese(void)
 958 {
 959     return getLocale(eCHINA);
 960 }
 961 
 962 const Locale &amp; U_EXPORT2
 963 Locale::getTraditionalChinese(void)
 964 {
 965     return getLocale(eTAIWAN);
 966 }
 967 
 968 
 969 const Locale &amp; U_EXPORT2
 970 Locale::getFrance(void)
 971 {
 972     return getLocale(eFRANCE);
 973 }
 974 
 975 const Locale &amp; U_EXPORT2
 976 Locale::getGermany(void)
 977 {
 978     return getLocale(eGERMANY);
 979 }
 980 
 981 const Locale &amp; U_EXPORT2
 982 Locale::getItaly(void)
 983 {
 984     return getLocale(eITALY);
 985 }
 986 
 987 const Locale &amp; U_EXPORT2
 988 Locale::getJapan(void)
 989 {
 990     return getLocale(eJAPAN);
 991 }
 992 
 993 const Locale &amp; U_EXPORT2
 994 Locale::getKorea(void)
 995 {
 996     return getLocale(eKOREA);
 997 }
 998 
 999 const Locale &amp; U_EXPORT2
1000 Locale::getChina(void)
1001 {
1002     return getLocale(eCHINA);
1003 }
1004 
1005 const Locale &amp; U_EXPORT2
1006 Locale::getPRC(void)
1007 {
1008     return getLocale(eCHINA);
1009 }
1010 
1011 const Locale &amp; U_EXPORT2
1012 Locale::getTaiwan(void)
1013 {
1014     return getLocale(eTAIWAN);
1015 }
1016 
1017 const Locale &amp; U_EXPORT2
1018 Locale::getUK(void)
1019 {
1020     return getLocale(eUK);
1021 }
1022 
1023 const Locale &amp; U_EXPORT2
1024 Locale::getUS(void)
1025 {
1026     return getLocale(eUS);
1027 }
1028 
1029 const Locale &amp; U_EXPORT2
1030 Locale::getCanada(void)
1031 {
1032     return getLocale(eCANADA);
1033 }
1034 
1035 const Locale &amp; U_EXPORT2
1036 Locale::getCanadaFrench(void)
1037 {
1038     return getLocale(eCANADA_FRENCH);
1039 }
1040 
1041 const Locale &amp;
1042 Locale::getLocale(int locid)
1043 {
1044     Locale *localeCache = getLocaleCache();
1045     U_ASSERT((locid &lt; eMAX_LOCALES)&amp;&amp;(locid&gt;=0));
1046     if (localeCache == NULL) {
1047         // Failure allocating the locale cache.
1048         //   The best we can do is return a NULL reference.
1049         locid = 0;
1050     }
1051     return localeCache[locid]; /*operating on NULL*/
1052 }
1053 
1054 /*
1055 This function is defined this way in order to get around static
1056 initialization and static destruction.
1057  */
1058 Locale *
1059 Locale::getLocaleCache(void)
1060 {
1061     UErrorCode status = U_ZERO_ERROR;
1062     umtx_initOnce(gLocaleCacheInitOnce, locale_init, status);
1063     return gLocaleCache;
1064 }
1065 
1066 class KeywordEnumeration : public StringEnumeration {
1067 private:
1068     char *keywords;
1069     char *current;
1070     int32_t length;
1071     UnicodeString currUSKey;
1072     static const char fgClassID;/* Warning this is used beyond the typical RTTI usage. */
1073 
1074 public:
1075     static UClassID U_EXPORT2 getStaticClassID(void) { return (UClassID)&amp;fgClassID; }
1076     virtual UClassID getDynamicClassID(void) const { return getStaticClassID(); }
1077 public:
1078     KeywordEnumeration(const char *keys, int32_t keywordLen, int32_t currentIndex, UErrorCode &amp;status)
1079         : keywords((char *)&amp;fgClassID), current((char *)&amp;fgClassID), length(0) {
1080         if(U_SUCCESS(status) &amp;&amp; keywordLen != 0) {
1081             if(keys == NULL || keywordLen &lt; 0) {
1082                 status = U_ILLEGAL_ARGUMENT_ERROR;
1083             } else {
1084                 keywords = (char *)uprv_malloc(keywordLen+1);
1085                 if (keywords == NULL) {
1086                     status = U_MEMORY_ALLOCATION_ERROR;
1087                 }
1088                 else {
1089                     uprv_memcpy(keywords, keys, keywordLen);
1090                     keywords[keywordLen] = 0;
1091                     current = keywords + currentIndex;
1092                     length = keywordLen;
1093                 }
1094             }
1095         }
1096     }
1097 
1098     virtual ~KeywordEnumeration();
1099 
1100     virtual StringEnumeration * clone() const
1101     {
1102         UErrorCode status = U_ZERO_ERROR;
1103         return new KeywordEnumeration(keywords, length, (int32_t)(current - keywords), status);
1104     }
1105 
1106     virtual int32_t count(UErrorCode &amp;/*status*/) const {
1107         char *kw = keywords;
1108         int32_t result = 0;
1109         while(*kw) {
1110             result++;
1111             kw += uprv_strlen(kw)+1;
1112         }
1113         return result;
1114     }
1115 
1116     virtual const char* next(int32_t* resultLength, UErrorCode&amp; status) {
1117         const char* result;
1118         int32_t len;
1119         if(U_SUCCESS(status) &amp;&amp; *current != 0) {
1120             result = current;
1121             len = (int32_t)uprv_strlen(current);
1122             current += len+1;
1123             if(resultLength != NULL) {
1124                 *resultLength = len;
1125             }
1126         } else {
1127             if(resultLength != NULL) {
1128                 *resultLength = 0;
1129             }
1130             result = NULL;
1131         }
1132         return result;
1133     }
1134 
1135     virtual const UnicodeString* snext(UErrorCode&amp; status) {
1136         int32_t resultLength = 0;
1137         const char *s = next(&amp;resultLength, status);
1138         return setChars(s, resultLength, status);
1139     }
1140 
1141     virtual void reset(UErrorCode&amp; /*status*/) {
1142         current = keywords;
1143     }
1144 };
1145 
1146 const char KeywordEnumeration::fgClassID = &#39;\0&#39;;
1147 
1148 KeywordEnumeration::~KeywordEnumeration() {
1149     uprv_free(keywords);
1150 }
1151 
<a name="23" id="anc23"></a><span class="line-added">1152 // A wrapper around KeywordEnumeration that calls uloc_toUnicodeLocaleKey() in</span>
<span class="line-added">1153 // the next() method for each keyword before returning it.</span>
<span class="line-added">1154 class UnicodeKeywordEnumeration : public KeywordEnumeration {</span>
<span class="line-added">1155 public:</span>
<span class="line-added">1156     using KeywordEnumeration::KeywordEnumeration;</span>
<span class="line-added">1157     virtual ~UnicodeKeywordEnumeration();</span>
<span class="line-added">1158 </span>
<span class="line-added">1159     virtual const char* next(int32_t* resultLength, UErrorCode&amp; status) {</span>
<span class="line-added">1160         const char* legacy_key = KeywordEnumeration::next(nullptr, status);</span>
<span class="line-added">1161         if (U_SUCCESS(status) &amp;&amp; legacy_key != nullptr) {</span>
<span class="line-added">1162             const char* key = uloc_toUnicodeLocaleKey(legacy_key);</span>
<span class="line-added">1163             if (key == nullptr) {</span>
<span class="line-added">1164                 status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1165             } else {</span>
<span class="line-added">1166                 if (resultLength != nullptr) {</span>
<span class="line-added">1167                     *resultLength = static_cast&lt;int32_t&gt;(uprv_strlen(key));</span>
<span class="line-added">1168                 }</span>
<span class="line-added">1169                 return key;</span>
<span class="line-added">1170             }</span>
<span class="line-added">1171         }</span>
<span class="line-added">1172         if (resultLength != nullptr) *resultLength = 0;</span>
<span class="line-added">1173         return nullptr;</span>
<span class="line-added">1174     }</span>
<span class="line-added">1175 };</span>
<span class="line-added">1176 </span>
<span class="line-added">1177 // Out-of-line virtual destructor to serve as the &quot;key function&quot;.</span>
<span class="line-added">1178 UnicodeKeywordEnumeration::~UnicodeKeywordEnumeration() = default;</span>
<span class="line-added">1179 </span>
1180 StringEnumeration *
1181 Locale::createKeywords(UErrorCode &amp;status) const
1182 {
1183     char keywords[256];
<a name="24" id="anc24"></a><span class="line-modified">1184     int32_t keywordCapacity = sizeof keywords;</span>
1185     StringEnumeration *result = NULL;
1186 
<a name="25" id="anc25"></a><span class="line-added">1187     if (U_FAILURE(status)) {</span>
<span class="line-added">1188         return result;</span>
<span class="line-added">1189     }</span>
<span class="line-added">1190 </span>
1191     const char* variantStart = uprv_strchr(fullName, &#39;@&#39;);
1192     const char* assignment = uprv_strchr(fullName, &#39;=&#39;);
1193     if(variantStart) {
1194         if(assignment &gt; variantStart) {
1195             int32_t keyLen = locale_getKeywords(variantStart+1, &#39;@&#39;, keywords, keywordCapacity, NULL, 0, NULL, FALSE, &amp;status);
<a name="26" id="anc26"></a><span class="line-modified">1196             if(U_SUCCESS(status) &amp;&amp; keyLen) {</span>
1197                 result = new KeywordEnumeration(keywords, keyLen, 0, status);
<a name="27" id="anc27"></a><span class="line-added">1198                 if (!result) {</span>
<span class="line-added">1199                     status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1200                 }</span>
<span class="line-added">1201             }</span>
<span class="line-added">1202         } else {</span>
<span class="line-added">1203             status = U_INVALID_FORMAT_ERROR;</span>
<span class="line-added">1204         }</span>
<span class="line-added">1205     }</span>
<span class="line-added">1206     return result;</span>
<span class="line-added">1207 }</span>
<span class="line-added">1208 </span>
<span class="line-added">1209 StringEnumeration *</span>
<span class="line-added">1210 Locale::createUnicodeKeywords(UErrorCode &amp;status) const</span>
<span class="line-added">1211 {</span>
<span class="line-added">1212     char keywords[256];</span>
<span class="line-added">1213     int32_t keywordCapacity = sizeof keywords;</span>
<span class="line-added">1214     StringEnumeration *result = NULL;</span>
<span class="line-added">1215 </span>
<span class="line-added">1216     if (U_FAILURE(status)) {</span>
<span class="line-added">1217         return result;</span>
<span class="line-added">1218     }</span>
<span class="line-added">1219 </span>
<span class="line-added">1220     const char* variantStart = uprv_strchr(fullName, &#39;@&#39;);</span>
<span class="line-added">1221     const char* assignment = uprv_strchr(fullName, &#39;=&#39;);</span>
<span class="line-added">1222     if(variantStart) {</span>
<span class="line-added">1223         if(assignment &gt; variantStart) {</span>
<span class="line-added">1224             int32_t keyLen = locale_getKeywords(variantStart+1, &#39;@&#39;, keywords, keywordCapacity, NULL, 0, NULL, FALSE, &amp;status);</span>
<span class="line-added">1225             if(U_SUCCESS(status) &amp;&amp; keyLen) {</span>
<span class="line-added">1226                 result = new UnicodeKeywordEnumeration(keywords, keyLen, 0, status);</span>
<span class="line-added">1227                 if (!result) {</span>
<span class="line-added">1228                     status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1229                 }</span>
1230             }
1231         } else {
1232             status = U_INVALID_FORMAT_ERROR;
1233         }
1234     }
1235     return result;
1236 }
1237 
1238 int32_t
1239 Locale::getKeywordValue(const char* keywordName, char *buffer, int32_t bufLen, UErrorCode &amp;status) const
1240 {
1241     return uloc_getKeywordValue(fullName, keywordName, buffer, bufLen, &amp;status);
1242 }
1243 
<a name="28" id="anc28"></a><span class="line-added">1244 void</span>
<span class="line-added">1245 Locale::getKeywordValue(StringPiece keywordName, ByteSink&amp; sink, UErrorCode&amp; status) const {</span>
<span class="line-added">1246     if (U_FAILURE(status)) {</span>
<span class="line-added">1247         return;</span>
<span class="line-added">1248     }</span>
<span class="line-added">1249 </span>
<span class="line-added">1250     if (fIsBogus) {</span>
<span class="line-added">1251         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1252         return;</span>
<span class="line-added">1253     }</span>
<span class="line-added">1254 </span>
<span class="line-added">1255     // TODO: Remove the need for a const char* to a NUL terminated buffer.</span>
<span class="line-added">1256     const CharString keywordName_nul(keywordName, status);</span>
<span class="line-added">1257     if (U_FAILURE(status)) {</span>
<span class="line-added">1258         return;</span>
<span class="line-added">1259     }</span>
<span class="line-added">1260 </span>
<span class="line-added">1261     LocalMemory&lt;char&gt; scratch;</span>
<span class="line-added">1262     int32_t scratch_capacity = 16;  // Arbitrarily chosen default size.</span>
<span class="line-added">1263 </span>
<span class="line-added">1264     char* buffer;</span>
<span class="line-added">1265     int32_t result_capacity, reslen;</span>
<span class="line-added">1266 </span>
<span class="line-added">1267     for (;;) {</span>
<span class="line-added">1268         if (scratch.allocateInsteadAndReset(scratch_capacity) == nullptr) {</span>
<span class="line-added">1269             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1270             return;</span>
<span class="line-added">1271         }</span>
<span class="line-added">1272 </span>
<span class="line-added">1273         buffer = sink.GetAppendBuffer(</span>
<span class="line-added">1274                 /*min_capacity=*/scratch_capacity,</span>
<span class="line-added">1275                 /*desired_capacity_hint=*/scratch_capacity,</span>
<span class="line-added">1276                 scratch.getAlias(),</span>
<span class="line-added">1277                 scratch_capacity,</span>
<span class="line-added">1278                 &amp;result_capacity);</span>
<span class="line-added">1279 </span>
<span class="line-added">1280         reslen = uloc_getKeywordValue(</span>
<span class="line-added">1281                 fullName,</span>
<span class="line-added">1282                 keywordName_nul.data(),</span>
<span class="line-added">1283                 buffer,</span>
<span class="line-added">1284                 result_capacity,</span>
<span class="line-added">1285                 &amp;status);</span>
<span class="line-added">1286 </span>
<span class="line-added">1287         if (status != U_BUFFER_OVERFLOW_ERROR) {</span>
<span class="line-added">1288             break;</span>
<span class="line-added">1289         }</span>
<span class="line-added">1290 </span>
<span class="line-added">1291         scratch_capacity = reslen;</span>
<span class="line-added">1292         status = U_ZERO_ERROR;</span>
<span class="line-added">1293     }</span>
<span class="line-added">1294 </span>
<span class="line-added">1295     if (U_FAILURE(status)) {</span>
<span class="line-added">1296         return;</span>
<span class="line-added">1297     }</span>
<span class="line-added">1298 </span>
<span class="line-added">1299     sink.Append(buffer, reslen);</span>
<span class="line-added">1300     if (status == U_STRING_NOT_TERMINATED_WARNING) {</span>
<span class="line-added">1301         status = U_ZERO_ERROR;  // Terminators not used.</span>
<span class="line-added">1302     }</span>
<span class="line-added">1303 }</span>
<span class="line-added">1304 </span>
<span class="line-added">1305 void</span>
<span class="line-added">1306 Locale::getUnicodeKeywordValue(StringPiece keywordName,</span>
<span class="line-added">1307                                ByteSink&amp; sink,</span>
<span class="line-added">1308                                UErrorCode&amp; status) const {</span>
<span class="line-added">1309     // TODO: Remove the need for a const char* to a NUL terminated buffer.</span>
<span class="line-added">1310     const CharString keywordName_nul(keywordName, status);</span>
<span class="line-added">1311     if (U_FAILURE(status)) {</span>
<span class="line-added">1312         return;</span>
<span class="line-added">1313     }</span>
<span class="line-added">1314 </span>
<span class="line-added">1315     const char* legacy_key = uloc_toLegacyKey(keywordName_nul.data());</span>
<span class="line-added">1316 </span>
<span class="line-added">1317     if (legacy_key == nullptr) {</span>
<span class="line-added">1318         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1319         return;</span>
<span class="line-added">1320     }</span>
<span class="line-added">1321 </span>
<span class="line-added">1322     CharString legacy_value;</span>
<span class="line-added">1323     {</span>
<span class="line-added">1324         CharStringByteSink sink(&amp;legacy_value);</span>
<span class="line-added">1325         getKeywordValue(legacy_key, sink, status);</span>
<span class="line-added">1326     }</span>
<span class="line-added">1327 </span>
<span class="line-added">1328     if (U_FAILURE(status)) {</span>
<span class="line-added">1329         return;</span>
<span class="line-added">1330     }</span>
<span class="line-added">1331 </span>
<span class="line-added">1332     const char* unicode_value = uloc_toUnicodeLocaleType(</span>
<span class="line-added">1333             keywordName_nul.data(), legacy_value.data());</span>
<span class="line-added">1334 </span>
<span class="line-added">1335     if (unicode_value == nullptr) {</span>
<span class="line-added">1336         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1337         return;</span>
<span class="line-added">1338     }</span>
<span class="line-added">1339 </span>
<span class="line-added">1340     sink.Append(unicode_value, static_cast&lt;int32_t&gt;(uprv_strlen(unicode_value)));</span>
<span class="line-added">1341 }</span>
<span class="line-added">1342 </span>
1343 void
1344 Locale::setKeywordValue(const char* keywordName, const char* keywordValue, UErrorCode &amp;status)
1345 {
1346     uloc_setKeywordValue(keywordName, keywordValue, fullName, ULOC_FULLNAME_CAPACITY, &amp;status);
1347     if (U_SUCCESS(status) &amp;&amp; baseName == fullName) {
1348         // May have added the first keyword, meaning that the fullName is no longer also the baseName.
1349         initBaseName(status);
1350     }
1351 }
1352 
<a name="29" id="anc29"></a><span class="line-added">1353 void</span>
<span class="line-added">1354 Locale::setKeywordValue(StringPiece keywordName,</span>
<span class="line-added">1355                         StringPiece keywordValue,</span>
<span class="line-added">1356                         UErrorCode&amp; status) {</span>
<span class="line-added">1357     // TODO: Remove the need for a const char* to a NUL terminated buffer.</span>
<span class="line-added">1358     const CharString keywordName_nul(keywordName, status);</span>
<span class="line-added">1359     const CharString keywordValue_nul(keywordValue, status);</span>
<span class="line-added">1360     setKeywordValue(keywordName_nul.data(), keywordValue_nul.data(), status);</span>
<span class="line-added">1361 }</span>
<span class="line-added">1362 </span>
<span class="line-added">1363 void</span>
<span class="line-added">1364 Locale::setUnicodeKeywordValue(StringPiece keywordName,</span>
<span class="line-added">1365                                StringPiece keywordValue,</span>
<span class="line-added">1366                                UErrorCode&amp; status) {</span>
<span class="line-added">1367     // TODO: Remove the need for a const char* to a NUL terminated buffer.</span>
<span class="line-added">1368     const CharString keywordName_nul(keywordName, status);</span>
<span class="line-added">1369     const CharString keywordValue_nul(keywordValue, status);</span>
<span class="line-added">1370 </span>
<span class="line-added">1371     if (U_FAILURE(status)) {</span>
<span class="line-added">1372         return;</span>
<span class="line-added">1373     }</span>
<span class="line-added">1374 </span>
<span class="line-added">1375     const char* legacy_key = uloc_toLegacyKey(keywordName_nul.data());</span>
<span class="line-added">1376 </span>
<span class="line-added">1377     if (legacy_key == nullptr) {</span>
<span class="line-added">1378         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1379         return;</span>
<span class="line-added">1380     }</span>
<span class="line-added">1381 </span>
<span class="line-added">1382     const char* legacy_value = nullptr;</span>
<span class="line-added">1383 </span>
<span class="line-added">1384     if (!keywordValue_nul.isEmpty()) {</span>
<span class="line-added">1385         legacy_value =</span>
<span class="line-added">1386             uloc_toLegacyType(keywordName_nul.data(), keywordValue_nul.data());</span>
<span class="line-added">1387 </span>
<span class="line-added">1388         if (legacy_value == nullptr) {</span>
<span class="line-added">1389             status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1390             return;</span>
<span class="line-added">1391         }</span>
<span class="line-added">1392     }</span>
<span class="line-added">1393 </span>
<span class="line-added">1394     setKeywordValue(legacy_key, legacy_value, status);</span>
<span class="line-added">1395 }</span>
<span class="line-added">1396 </span>
1397 const char *
1398 Locale::getBaseName() const {
1399     return baseName;
1400 }
1401 
1402 //eof
1403 U_NAMESPACE_END
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>