<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/numsys.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="numparse_types.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="numsys_impl.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/numsys.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,10 ***</span>
<span class="line-new-header">--- 24,12 ---</span>
  #include &quot;unicode/uloc.h&quot;
  #include &quot;unicode/schriter.h&quot;
  #include &quot;unicode/numsys.h&quot;
  #include &quot;cstring.h&quot;
  #include &quot;uassert.h&quot;
<span class="line-added">+ #include &quot;ucln_in.h&quot;</span>
<span class="line-added">+ #include &quot;umutex.h&quot;</span>
  #include &quot;uresimp.h&quot;
  #include &quot;numsys_impl.h&quot;
  
  #if !UCONFIG_NO_FORMATTING
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,47 ***</span>
  
  NumberingSystem* U_EXPORT2
  NumberingSystem::createInstance(int32_t radix_in, UBool isAlgorithmic_in, const UnicodeString &amp; desc_in, UErrorCode &amp;status) {
  
      if (U_FAILURE(status)) {
<span class="line-modified">!         return NULL;</span>
      }
  
      if ( radix_in &lt; 2 ) {
          status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">!         return NULL;</span>
      }
  
      if ( !isAlgorithmic_in ) {
         if ( desc_in.countChar32() != radix_in ) {
             status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">!            return NULL;</span>
         }
      }
  
<span class="line-modified">!     NumberingSystem *ns = new NumberingSystem();</span>
  
      ns-&gt;setRadix(radix_in);
      ns-&gt;setDesc(desc_in);
      ns-&gt;setAlgorithmic(isAlgorithmic_in);
<span class="line-modified">!     ns-&gt;setName(NULL);</span>
<span class="line-removed">-     return ns;</span>
  
  }
  
<span class="line-removed">- </span>
  NumberingSystem* U_EXPORT2
  NumberingSystem::createInstance(const Locale &amp; inLocale, UErrorCode&amp; status) {
  
      if (U_FAILURE(status)) {
<span class="line-modified">!         return NULL;</span>
      }
  
      UBool nsResolved = TRUE;
      UBool usingFallback = FALSE;
      char buffer[ULOC_KEYWORDS_CAPACITY];
<span class="line-modified">!     int32_t count = inLocale.getKeywordValue(&quot;numbers&quot;,buffer, sizeof(buffer),status);</span>
      if (U_FAILURE(status) || status == U_STRING_NOT_TERMINATED_WARNING) {
          // the &quot;numbers&quot; keyword exceeds ULOC_KEYWORDS_CAPACITY; ignore and use default.
          count = 0;
          status = U_ZERO_ERROR;
      }
<span class="line-new-header">--- 79,49 ---</span>
  
  NumberingSystem* U_EXPORT2
  NumberingSystem::createInstance(int32_t radix_in, UBool isAlgorithmic_in, const UnicodeString &amp; desc_in, UErrorCode &amp;status) {
  
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
  
      if ( radix_in &lt; 2 ) {
          status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">!         return nullptr;</span>
      }
  
      if ( !isAlgorithmic_in ) {
         if ( desc_in.countChar32() != radix_in ) {
             status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">!            return nullptr;</span>
         }
      }
  
<span class="line-modified">!     LocalPointer&lt;NumberingSystem&gt; ns(new NumberingSystem(), status);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
  
      ns-&gt;setRadix(radix_in);
      ns-&gt;setDesc(desc_in);
      ns-&gt;setAlgorithmic(isAlgorithmic_in);
<span class="line-modified">!     ns-&gt;setName(nullptr);</span>
  
<span class="line-added">+     return ns.orphan();</span>
  }
  
  NumberingSystem* U_EXPORT2
  NumberingSystem::createInstance(const Locale &amp; inLocale, UErrorCode&amp; status) {
  
      if (U_FAILURE(status)) {
<span class="line-modified">!         return nullptr;</span>
      }
  
      UBool nsResolved = TRUE;
      UBool usingFallback = FALSE;
      char buffer[ULOC_KEYWORDS_CAPACITY];
<span class="line-modified">!     int32_t count = inLocale.getKeywordValue(&quot;numbers&quot;, buffer, sizeof(buffer), status);</span>
      if (U_FAILURE(status) || status == U_STRING_NOT_TERMINATED_WARNING) {
          // the &quot;numbers&quot; keyword exceeds ULOC_KEYWORDS_CAPACITY; ignore and use default.
          count = 0;
          status = U_ZERO_ERROR;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 127,24 ***</span>
          if ( !uprv_strcmp(buffer,gDefault) || !uprv_strcmp(buffer,gNative) ||
               !uprv_strcmp(buffer,gTraditional) || !uprv_strcmp(buffer,gFinance)) {
              nsResolved = FALSE;
          }
      } else {
<span class="line-modified">!         uprv_strcpy(buffer,gDefault);</span>
          nsResolved = FALSE;
      }
  
      if (!nsResolved) { // Resolve the numbering system ( default, native, traditional or finance ) into a &quot;real&quot; numbering system
          UErrorCode localStatus = U_ZERO_ERROR;
<span class="line-modified">!         UResourceBundle *resource = ures_open(NULL, inLocale.getName(), &amp;localStatus);</span>
<span class="line-modified">!         UResourceBundle *numberElementsRes = ures_getByKey(resource,gNumberElements,NULL,&amp;localStatus);</span>
          while (!nsResolved) {
              localStatus = U_ZERO_ERROR;
              count = 0;
<span class="line-modified">!             const UChar *nsName = ures_getStringByKeyWithFallback(numberElementsRes, buffer, &amp;count, &amp;localStatus);</span>
              if ( count &gt; 0 &amp;&amp; count &lt; ULOC_KEYWORDS_CAPACITY ) { // numbering system found
<span class="line-modified">!                 u_UCharsToChars(nsName,buffer,count);</span>
                  buffer[count] = &#39;\0&#39;; // Make sure it is null terminated.
                  nsResolved = TRUE;
              }
  
              if (!nsResolved) { // Fallback behavior per TR35 - traditional falls back to native, finance and native fall back to default
<span class="line-new-header">--- 131,34 ---</span>
          if ( !uprv_strcmp(buffer,gDefault) || !uprv_strcmp(buffer,gNative) ||
               !uprv_strcmp(buffer,gTraditional) || !uprv_strcmp(buffer,gFinance)) {
              nsResolved = FALSE;
          }
      } else {
<span class="line-modified">!         uprv_strcpy(buffer, gDefault);</span>
          nsResolved = FALSE;
      }
  
      if (!nsResolved) { // Resolve the numbering system ( default, native, traditional or finance ) into a &quot;real&quot; numbering system
          UErrorCode localStatus = U_ZERO_ERROR;
<span class="line-modified">!         LocalUResourceBundlePointer resource(ures_open(nullptr, inLocale.getName(), &amp;localStatus));</span>
<span class="line-modified">!         LocalUResourceBundlePointer numberElementsRes(ures_getByKey(resource.getAlias(), gNumberElements, nullptr, &amp;localStatus));</span>
<span class="line-added">+         // Don&#39;t stomp on the catastrophic failure of OOM.</span>
<span class="line-added">+         if (localStatus == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added">+             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+             return nullptr;</span>
<span class="line-added">+         }</span>
          while (!nsResolved) {
              localStatus = U_ZERO_ERROR;
              count = 0;
<span class="line-modified">!             const UChar *nsName = ures_getStringByKeyWithFallback(numberElementsRes.getAlias(), buffer, &amp;count, &amp;localStatus);</span>
<span class="line-added">+             // Don&#39;t stomp on the catastrophic failure of OOM.</span>
<span class="line-added">+             if (localStatus == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added">+                 status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+                 return nullptr;</span>
<span class="line-added">+             }</span>
              if ( count &gt; 0 &amp;&amp; count &lt; ULOC_KEYWORDS_CAPACITY ) { // numbering system found
<span class="line-modified">!                 u_UCharsToChars(nsName, buffer, count);</span>
                  buffer[count] = &#39;\0&#39;; // Make sure it is null terminated.
                  nsResolved = TRUE;
              }
  
              if (!nsResolved) { // Fallback behavior per TR35 - traditional falls back to native, finance and native fall back to default
</pre>
<hr />
<pre>
<span class="line-old-header">*** 156,60 ***</span>
                      usingFallback = TRUE;
                      nsResolved = TRUE;
                  }
              }
          }
<span class="line-removed">-         ures_close(numberElementsRes);</span>
<span class="line-removed">-         ures_close(resource);</span>
      }
  
      if (usingFallback) {
          status = U_USING_FALLBACK_WARNING;
          NumberingSystem *ns = new NumberingSystem();
          return ns;
      } else {
<span class="line-modified">!         return NumberingSystem::createInstanceByName(buffer,status);</span>
      }
   }
  
  NumberingSystem* U_EXPORT2
  NumberingSystem::createInstance(UErrorCode&amp; status) {
      return NumberingSystem::createInstance(Locale::getDefault(), status);
  }
  
  NumberingSystem* U_EXPORT2
  NumberingSystem::createInstanceByName(const char *name, UErrorCode&amp; status) {
<span class="line-removed">-     UResourceBundle *numberingSystemsInfo = NULL;</span>
<span class="line-removed">-     UResourceBundle *nsTop, *nsCurrent;</span>
      int32_t radix = 10;
      int32_t algorithmic = 0;
  
<span class="line-modified">!     numberingSystemsInfo = ures_openDirect(NULL,gNumberingSystems, &amp;status);</span>
<span class="line-modified">!     nsCurrent = ures_getByKey(numberingSystemsInfo,gNumberingSystems,NULL,&amp;status);</span>
<span class="line-modified">!     nsTop = ures_getByKey(nsCurrent,name,NULL,&amp;status);</span>
<span class="line-removed">-     UnicodeString nsd = ures_getUnicodeStringByKey(nsTop,gDesc,&amp;status);</span>
  
<span class="line-modified">!     ures_getByKey(nsTop,gRadix,nsCurrent,&amp;status);</span>
<span class="line-removed">-     radix = ures_getInt(nsCurrent,&amp;status);</span>
  
<span class="line-modified">!     ures_getByKey(nsTop,gAlgorithmic,nsCurrent,&amp;status);</span>
<span class="line-modified">!     algorithmic = ures_getInt(nsCurrent,&amp;status);</span>
  
<span class="line-modified">!     UBool isAlgorithmic = ( algorithmic == 1 );</span>
  
<span class="line-modified">!     ures_close(nsCurrent);</span>
<span class="line-removed">-     ures_close(nsTop);</span>
<span class="line-removed">-     ures_close(numberingSystemsInfo);</span>
  
      if (U_FAILURE(status)) {
<span class="line-modified">!         status = U_UNSUPPORTED_ERROR;</span>
<span class="line-modified">!         return NULL;</span>
      }
  
<span class="line-modified">!     NumberingSystem* ns = NumberingSystem::createInstance(radix,isAlgorithmic,nsd,status);</span>
      ns-&gt;setName(name);
<span class="line-modified">!     return ns;</span>
  }
  
      /**
       * Destructor.
       * @draft ICU 4.2
<span class="line-new-header">--- 170,62 ---</span>
                      usingFallback = TRUE;
                      nsResolved = TRUE;
                  }
              }
          }
      }
  
      if (usingFallback) {
          status = U_USING_FALLBACK_WARNING;
          NumberingSystem *ns = new NumberingSystem();
<span class="line-added">+         if (ns == nullptr) {</span>
<span class="line-added">+             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         }</span>
          return ns;
      } else {
<span class="line-modified">!         return NumberingSystem::createInstanceByName(buffer, status);</span>
      }
   }
  
  NumberingSystem* U_EXPORT2
  NumberingSystem::createInstance(UErrorCode&amp; status) {
      return NumberingSystem::createInstance(Locale::getDefault(), status);
  }
  
  NumberingSystem* U_EXPORT2
  NumberingSystem::createInstanceByName(const char *name, UErrorCode&amp; status) {
      int32_t radix = 10;
      int32_t algorithmic = 0;
  
<span class="line-modified">!     LocalUResourceBundlePointer numberingSystemsInfo(ures_openDirect(nullptr, gNumberingSystems, &amp;status));</span>
<span class="line-modified">!     LocalUResourceBundlePointer nsCurrent(ures_getByKey(numberingSystemsInfo.getAlias(), gNumberingSystems, nullptr, &amp;status));</span>
<span class="line-modified">!     LocalUResourceBundlePointer nsTop(ures_getByKey(nsCurrent.getAlias(), name, nullptr, &amp;status));</span>
  
<span class="line-modified">!     UnicodeString nsd = ures_getUnicodeStringByKey(nsTop.getAlias(), gDesc, &amp;status);</span>
  
<span class="line-modified">!     ures_getByKey(nsTop.getAlias(), gRadix, nsCurrent.getAlias(), &amp;status);</span>
<span class="line-modified">!     radix = ures_getInt(nsCurrent.getAlias(), &amp;status);</span>
  
<span class="line-modified">!     ures_getByKey(nsTop.getAlias(), gAlgorithmic, nsCurrent.getAlias(), &amp;status);</span>
<span class="line-added">+     algorithmic = ures_getInt(nsCurrent.getAlias(), &amp;status);</span>
  
<span class="line-modified">!     UBool isAlgorithmic = ( algorithmic == 1 );</span>
  
      if (U_FAILURE(status)) {
<span class="line-modified">!         // Don&#39;t stomp on the catastrophic failure of OOM.</span>
<span class="line-modified">!         if (status != U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added">+             status = U_UNSUPPORTED_ERROR;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return nullptr;</span>
      }
  
<span class="line-modified">!     LocalPointer&lt;NumberingSystem&gt; ns(NumberingSystem::createInstance(radix, isAlgorithmic, nsd, status), status);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
      ns-&gt;setName(name);
<span class="line-modified">!     return ns.orphan();</span>
  }
  
      /**
       * Destructor.
       * @draft ICU 4.2
</pre>
<hr />
<pre>
<span class="line-old-header">*** 239,92 ***</span>
  
  void NumberingSystem::setDesc(const UnicodeString &amp;d) {
      desc.setTo(d);
  }
  void NumberingSystem::setName(const char *n) {
<span class="line-modified">!     if ( n == NULL ) {</span>
          name[0] = (char) 0;
      } else {
<span class="line-modified">!         uprv_strncpy(name,n,NUMSYS_NAME_CAPACITY);</span>
<span class="line-modified">!         name[NUMSYS_NAME_CAPACITY] = (char)0; // Make sure it is null terminated.</span>
      }
  }
  UBool NumberingSystem::isAlgorithmic() const {
      return ( algorithmic );
  }
  
<span class="line-modified">! StringEnumeration* NumberingSystem::getAvailableNames(UErrorCode &amp;status) {</span>
<span class="line-modified">!     // TODO(ticket #11908): Init-once static cache, with u_cleanup() callback.</span>
<span class="line-modified">!     static StringEnumeration* availableNames = NULL;</span>
  
      if (U_FAILURE(status)) {
<span class="line-modified">!         return NULL;</span>
      }
  
<span class="line-modified">!     if ( availableNames == NULL ) {</span>
<span class="line-modified">!         // TODO: Simple array of UnicodeString objects, based on length of table resource?</span>
<span class="line-modified">!         LocalPointer&lt;UVector&gt; numsysNames(new UVector(uprv_deleteUObject, NULL, status), status);</span>
<span class="line-modified">!         if (U_FAILURE(status)) {</span>
<span class="line-modified">!             return NULL;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         UErrorCode rbstatus = U_ZERO_ERROR;</span>
<span class="line-modified">!         UResourceBundle *numberingSystemsInfo = ures_openDirect(NULL, &quot;numberingSystems&quot;, &amp;rbstatus);</span>
<span class="line-removed">-         numberingSystemsInfo = ures_getByKey(numberingSystemsInfo,&quot;numberingSystems&quot;,numberingSystemsInfo,&amp;rbstatus);</span>
<span class="line-removed">-         if(U_FAILURE(rbstatus)) {</span>
              status = U_MISSING_RESOURCE_ERROR;
<span class="line-removed">-             ures_close(numberingSystemsInfo);</span>
<span class="line-removed">-             return NULL;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         while ( ures_hasNext(numberingSystemsInfo) ) {</span>
<span class="line-removed">-             UResourceBundle *nsCurrent = ures_getNextResource(numberingSystemsInfo,NULL,&amp;rbstatus);</span>
<span class="line-removed">-             const char *nsName = ures_getKey(nsCurrent);</span>
<span class="line-removed">-             numsysNames-&gt;addElement(new UnicodeString(nsName, -1, US_INV),status);</span>
<span class="line-removed">-             ures_close(nsCurrent);</span>
          }
<span class="line-removed">- </span>
          ures_close(numberingSystemsInfo);
<span class="line-modified">!         if (U_FAILURE(status)) {</span>
<span class="line-modified">!             return NULL;</span>
          }
<span class="line-modified">!         availableNames = new NumsysNameEnumeration(numsysNames.getAlias(), status);</span>
<span class="line-modified">!         if (availableNames == NULL) {</span>
<span class="line-modified">!             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">!             return NULL;</span>
          }
<span class="line-removed">-         numsysNames.orphan();  // The names got adopted.</span>
      }
  
<span class="line-modified">!     return availableNames;</span>
  }
  
<span class="line-modified">! NumsysNameEnumeration::NumsysNameEnumeration(UVector *numsysNames, UErrorCode&amp; /*status*/) {</span>
<span class="line-modified">!     pos=0;</span>
<span class="line-modified">!     fNumsysNames = numsysNames;</span>
  }
  
  const UnicodeString*
  NumsysNameEnumeration::snext(UErrorCode&amp; status) {
<span class="line-modified">!     if (U_SUCCESS(status) &amp;&amp; pos &lt; fNumsysNames-&gt;size()) {</span>
<span class="line-modified">!         return (const UnicodeString*)fNumsysNames-&gt;elementAt(pos++);</span>
      }
<span class="line-modified">!     return NULL;</span>
  }
  
  void
  NumsysNameEnumeration::reset(UErrorCode&amp; /*status*/) {
      pos=0;
  }
  
  int32_t
  NumsysNameEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">!     return (fNumsysNames==NULL) ? 0 : fNumsysNames-&gt;size();</span>
  }
  
  NumsysNameEnumeration::~NumsysNameEnumeration() {
<span class="line-removed">-     delete fNumsysNames;</span>
  }
  U_NAMESPACE_END
  
  #endif /* #if !UCONFIG_NO_FORMATTING */
  
<span class="line-new-header">--- 255,112 ---</span>
  
  void NumberingSystem::setDesc(const UnicodeString &amp;d) {
      desc.setTo(d);
  }
  void NumberingSystem::setName(const char *n) {
<span class="line-modified">!     if ( n == nullptr ) {</span>
          name[0] = (char) 0;
      } else {
<span class="line-modified">!         uprv_strncpy(name,n,kInternalNumSysNameCapacity);</span>
<span class="line-modified">!         name[kInternalNumSysNameCapacity] = &#39;\0&#39;; // Make sure it is null terminated.</span>
      }
  }
  UBool NumberingSystem::isAlgorithmic() const {
      return ( algorithmic );
  }
  
<span class="line-modified">! namespace {</span>
<span class="line-modified">! </span>
<span class="line-modified">! UVector* gNumsysNames = nullptr;</span>
<span class="line-added">+ UInitOnce gNumSysInitOnce = U_INITONCE_INITIALIZER;</span>
<span class="line-added">+ </span>
<span class="line-added">+ U_CFUNC UBool U_CALLCONV numSysCleanup() {</span>
<span class="line-added">+     delete gNumsysNames;</span>
<span class="line-added">+     gNumsysNames = nullptr;</span>
<span class="line-added">+     gNumSysInitOnce.reset();</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
  
<span class="line-added">+ U_CFUNC void initNumsysNames(UErrorCode &amp;status) {</span>
<span class="line-added">+     U_ASSERT(gNumsysNames == nullptr);</span>
<span class="line-added">+     ucln_i18n_registerCleanup(UCLN_I18N_NUMSYS, numSysCleanup);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // TODO: Simple array of UnicodeString objects, based on length of table resource?</span>
<span class="line-added">+     LocalPointer&lt;UVector&gt; numsysNames(new UVector(uprv_deleteUObject, nullptr, status), status);</span>
      if (U_FAILURE(status)) {
<span class="line-modified">!         return;</span>
      }
  
<span class="line-modified">!     UErrorCode rbstatus = U_ZERO_ERROR;</span>
<span class="line-modified">!     UResourceBundle *numberingSystemsInfo = ures_openDirect(nullptr, &quot;numberingSystems&quot;, &amp;rbstatus);</span>
<span class="line-modified">!     numberingSystemsInfo =</span>
<span class="line-modified">!             ures_getByKey(numberingSystemsInfo, &quot;numberingSystems&quot;, numberingSystemsInfo, &amp;rbstatus);</span>
<span class="line-modified">!     if (U_FAILURE(rbstatus)) {</span>
<span class="line-modified">!         // Don&#39;t stomp on the catastrophic failure of OOM.</span>
<span class="line-modified">!         if (rbstatus == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-modified">!             status = rbstatus;</span>
<span class="line-modified">!         } else {</span>
              status = U_MISSING_RESOURCE_ERROR;
          }
          ures_close(numberingSystemsInfo);
<span class="line-modified">!         return;</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     while ( ures_hasNext(numberingSystemsInfo) &amp;&amp; U_SUCCESS(status) ) {</span>
<span class="line-added">+         LocalUResourceBundlePointer nsCurrent(ures_getNextResource(numberingSystemsInfo, nullptr, &amp;rbstatus));</span>
<span class="line-added">+         if (rbstatus == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added">+             status = rbstatus; // we want to report OOM failure back to the caller.</span>
<span class="line-added">+             break;</span>
          }
<span class="line-modified">!         const char *nsName = ures_getKey(nsCurrent.getAlias());</span>
<span class="line-modified">!         LocalPointer&lt;UnicodeString&gt; newElem(new UnicodeString(nsName, -1, US_INV), status);</span>
<span class="line-modified">!         if (U_SUCCESS(status)) {</span>
<span class="line-modified">!             numsysNames-&gt;addElement(newElem.getAlias(), status);</span>
<span class="line-added">+             if (U_SUCCESS(status)) {</span>
<span class="line-added">+                 newElem.orphan(); // on success, the numsysNames vector owns newElem.</span>
<span class="line-added">+             }</span>
          }
      }
  
<span class="line-modified">!     ures_close(numberingSystemsInfo);</span>
<span class="line-added">+     if (U_SUCCESS(status)) {</span>
<span class="line-added">+         gNumsysNames = numsysNames.orphan();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return;</span>
  }
  
<span class="line-modified">! }   // end anonymous namespace</span>
<span class="line-modified">! </span>
<span class="line-modified">! StringEnumeration* NumberingSystem::getAvailableNames(UErrorCode &amp;status) {</span>
<span class="line-added">+     umtx_initOnce(gNumSysInitOnce, &amp;initNumsysNames, status);</span>
<span class="line-added">+     LocalPointer&lt;StringEnumeration&gt; result(new NumsysNameEnumeration(status), status);</span>
<span class="line-added">+     return result.orphan();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ NumsysNameEnumeration::NumsysNameEnumeration(UErrorCode&amp; status) : pos(0) {</span>
<span class="line-added">+     (void)status;</span>
  }
  
  const UnicodeString*
  NumsysNameEnumeration::snext(UErrorCode&amp; status) {
<span class="line-modified">!     if (U_SUCCESS(status) &amp;&amp; (gNumsysNames != nullptr) &amp;&amp; (pos &lt; gNumsysNames-&gt;size())) {</span>
<span class="line-modified">!         return (const UnicodeString*)gNumsysNames-&gt;elementAt(pos++);</span>
      }
<span class="line-modified">!     return nullptr;</span>
  }
  
  void
  NumsysNameEnumeration::reset(UErrorCode&amp; /*status*/) {
      pos=0;
  }
  
  int32_t
  NumsysNameEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">!     return (gNumsysNames==nullptr) ? 0 : gNumsysNames-&gt;size();</span>
  }
  
  NumsysNameEnumeration::~NumsysNameEnumeration() {
  }
  U_NAMESPACE_END
  
  #endif /* #if !UCONFIG_NO_FORMATTING */
  
</pre>
<center><a href="numparse_types.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="numsys_impl.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>