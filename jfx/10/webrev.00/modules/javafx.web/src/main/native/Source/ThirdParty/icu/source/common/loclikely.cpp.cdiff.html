<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/loclikely.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="locid.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="locmap.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/loclikely.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 17,22 ***</span>
<span class="line-new-header">--- 17,32 ---</span>
  *
  *   Code for likely and minimized locale subtags, separated out from other .cpp files
  *   that then do not depend on resource bundle code and likely-subtags data.
  */
  
<span class="line-added">+ #include &quot;unicode/bytestream.h&quot;</span>
  #include &quot;unicode/utypes.h&quot;
  #include &quot;unicode/locid.h&quot;
  #include &quot;unicode/putil.h&quot;
  #include &quot;unicode/uchar.h&quot;
  #include &quot;unicode/uloc.h&quot;
<span class="line-added">+ #include &quot;bytesinkutil.h&quot;</span>
<span class="line-added">+ #include &quot;charstr.h&quot;</span>
  #include &quot;cmemory.h&quot;
  #include &quot;cstring.h&quot;
  #include &quot;ulocimp.h&quot;
  #include &quot;ustr_imp.h&quot;
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * These are the canonical strings for unknown languages, scripts and regions.</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ static const char* const unknownLanguage = &quot;und&quot;;</span>
<span class="line-added">+ static const char* const unknownScript = &quot;Zzzz&quot;;</span>
<span class="line-added">+ static const char* const unknownRegion = &quot;ZZ&quot;;</span>
<span class="line-added">+ </span>
  /**
   * This function looks for the localeID in the likelySubtags resource.
   *
   * @param localeID The tag to find.
   * @param buffer A buffer to hold the matching entry
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,13 ***</span>
  
      if (!U_FAILURE(*err)) {
          int32_t resLen = 0;
          const UChar* s = NULL;
          UErrorCode tmpErr = U_ZERO_ERROR;
<span class="line-modified">!         UResourceBundle* subtags = ures_openDirect(NULL, &quot;likelySubtags&quot;, &amp;tmpErr);</span>
          if (U_SUCCESS(tmpErr)) {
<span class="line-modified">!             s = ures_getStringByKey(subtags, localeID, &amp;resLen, &amp;tmpErr);</span>
  
              if (U_FAILURE(tmpErr)) {
                  /*
                   * If a resource is missing, it&#39;s not really an error, it&#39;s
                   * just that we don&#39;t have any data for that particular locale ID.
<span class="line-new-header">--- 58,26 ---</span>
  
      if (!U_FAILURE(*err)) {
          int32_t resLen = 0;
          const UChar* s = NULL;
          UErrorCode tmpErr = U_ZERO_ERROR;
<span class="line-modified">!         icu::LocalUResourceBundlePointer subtags(ures_openDirect(NULL, &quot;likelySubtags&quot;, &amp;tmpErr));</span>
          if (U_SUCCESS(tmpErr)) {
<span class="line-modified">!             icu::CharString und;</span>
<span class="line-added">+             if (localeID != NULL) {</span>
<span class="line-added">+                 if (*localeID == &#39;\0&#39;) {</span>
<span class="line-added">+                     localeID = unknownLanguage;</span>
<span class="line-added">+                 } else if (*localeID == &#39;_&#39;) {</span>
<span class="line-added">+                     und.append(unknownLanguage, *err);</span>
<span class="line-added">+                     und.append(localeID, *err);</span>
<span class="line-added">+                     if (U_FAILURE(*err)) {</span>
<span class="line-added">+                         return NULL;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     localeID = und.data();</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             s = ures_getStringByKey(subtags.getAlias(), localeID, &amp;resLen, &amp;tmpErr);</span>
  
              if (U_FAILURE(tmpErr)) {
                  /*
                   * If a resource is missing, it&#39;s not really an error, it&#39;s
                   * just that we don&#39;t have any data for that particular locale ID.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 67,14 ***</span>
                  /* The buffer should never overflow. */
                  *err = U_INTERNAL_PROGRAM_ERROR;
              }
              else {
                  u_UCharsToChars(s, buffer, resLen + 1);
                  result = buffer;
              }
<span class="line-removed">- </span>
<span class="line-removed">-             ures_close(subtags);</span>
          } else {
              *err = tmpErr;
          }
      }
  
<span class="line-new-header">--- 90,17 ---</span>
                  /* The buffer should never overflow. */
                  *err = U_INTERNAL_PROGRAM_ERROR;
              }
              else {
                  u_UCharsToChars(s, buffer, resLen + 1);
<span class="line-added">+                 if (resLen &gt;= 3 &amp;&amp;</span>
<span class="line-added">+                     uprv_strnicmp(buffer, unknownLanguage, 3) == 0 &amp;&amp;</span>
<span class="line-added">+                     (resLen == 3 || buffer[3] == &#39;_&#39;)) {</span>
<span class="line-added">+                     uprv_memmove(buffer, buffer + 3, resLen - 3 + 1);</span>
<span class="line-added">+                 }</span>
                  result = buffer;
              }
          } else {
              *err = tmpErr;
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,13 ***</span>
  static void U_CALLCONV
  appendTag(
      const char* tag,
      int32_t tagLength,
      char* buffer,
<span class="line-modified">!     int32_t* bufferLength) {</span>
  
<span class="line-modified">!     if (*bufferLength &gt; 0) {</span>
          buffer[*bufferLength] = &#39;_&#39;;
          ++(*bufferLength);
      }
  
      uprv_memmove(
<span class="line-new-header">--- 120,14 ---</span>
  static void U_CALLCONV
  appendTag(
      const char* tag,
      int32_t tagLength,
      char* buffer,
<span class="line-modified">!     int32_t* bufferLength,</span>
<span class="line-added">+     UBool withSeparator) {</span>
  
<span class="line-modified">!     if (withSeparator) {</span>
          buffer[*bufferLength] = &#39;_&#39;;
          ++(*bufferLength);
      }
  
      uprv_memmove(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,17 ***</span>
          tagLength);
  
      *bufferLength += tagLength;
  }
  
<span class="line-removed">- /**</span>
<span class="line-removed">-  * These are the canonical strings for unknown languages, scripts and regions.</span>
<span class="line-removed">-  **/</span>
<span class="line-removed">- static const char* const unknownLanguage = &quot;und&quot;;</span>
<span class="line-removed">- static const char* const unknownScript = &quot;Zzzz&quot;;</span>
<span class="line-removed">- static const char* const unknownRegion = &quot;ZZ&quot;;</span>
<span class="line-removed">- </span>
  /**
   * Create a tag string from the supplied parameters.  The lang, script and region
   * parameters may be NULL pointers. If they are, their corresponding length parameters
   * must be less than or equal to 0.
   *
<span class="line-new-header">--- 136,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 145,36 ***</span>
   * @param region The region tag to use.
   * @param regionLength The length of the region tag.
   * @param trailing Any trailing data to append to the new tag.
   * @param trailingLength The length of the trailing data.
   * @param alternateTags A string containing any alternate tags.
<span class="line-modified">!  * @param tag The output buffer.</span>
<span class="line-removed">-  * @param tagCapacity The capacity of the output buffer.</span>
   * @param err A pointer to a UErrorCode for error reporting.
<span class="line-removed">-  * @return The length of the tag string, which may be greater than tagCapacity, or -1 on error.</span>
   **/
<span class="line-modified">! static int32_t U_CALLCONV</span>
  createTagStringWithAlternates(
      const char* lang,
      int32_t langLength,
      const char* script,
      int32_t scriptLength,
      const char* region,
      int32_t regionLength,
      const char* trailing,
      int32_t trailingLength,
      const char* alternateTags,
<span class="line-modified">!     char* tag,</span>
<span class="line-removed">-     int32_t tagCapacity,</span>
      UErrorCode* err) {
  
      if (U_FAILURE(*err)) {
          goto error;
      }
<span class="line-modified">!     else if (tag == NULL ||</span>
<span class="line-removed">-              tagCapacity &lt;= 0 ||</span>
<span class="line-removed">-              langLength &gt;= ULOC_LANG_CAPACITY ||</span>
               scriptLength &gt;= ULOC_SCRIPT_CAPACITY ||
               regionLength &gt;= ULOC_COUNTRY_CAPACITY) {
          goto error;
      }
      else {
<span class="line-new-header">--- 165,31 ---</span>
   * @param region The region tag to use.
   * @param regionLength The length of the region tag.
   * @param trailing Any trailing data to append to the new tag.
   * @param trailingLength The length of the trailing data.
   * @param alternateTags A string containing any alternate tags.
<span class="line-modified">!  * @param sink The output sink receiving the tag string.</span>
   * @param err A pointer to a UErrorCode for error reporting.
   **/
<span class="line-modified">! static void U_CALLCONV</span>
  createTagStringWithAlternates(
      const char* lang,
      int32_t langLength,
      const char* script,
      int32_t scriptLength,
      const char* region,
      int32_t regionLength,
      const char* trailing,
      int32_t trailingLength,
      const char* alternateTags,
<span class="line-modified">!     icu::ByteSink&amp; sink,</span>
      UErrorCode* err) {
  
      if (U_FAILURE(*err)) {
          goto error;
      }
<span class="line-modified">!     else if (langLength &gt;= ULOC_LANG_CAPACITY ||</span>
               scriptLength &gt;= ULOC_SCRIPT_CAPACITY ||
               regionLength &gt;= ULOC_COUNTRY_CAPACITY) {
          goto error;
      }
      else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,30 ***</span>
           * script and region code without worrying about overrunning
           * the user-supplied buffer.
           **/
          char tagBuffer[ULOC_FULLNAME_CAPACITY];
          int32_t tagLength = 0;
<span class="line-removed">-         int32_t capacityRemaining = tagCapacity;</span>
          UBool regionAppended = FALSE;
  
          if (langLength &gt; 0) {
              appendTag(
                  lang,
                  langLength,
                  tagBuffer,
<span class="line-modified">!                 &amp;tagLength);</span>
          }
          else if (alternateTags == NULL) {
              /*
<span class="line-modified">!              * Append the value for an unknown language, if</span>
               * we found no language.
               */
<span class="line-removed">-             appendTag(</span>
<span class="line-removed">-                 unknownLanguage,</span>
<span class="line-removed">-                 (int32_t)uprv_strlen(unknownLanguage),</span>
<span class="line-removed">-                 tagBuffer,</span>
<span class="line-removed">-                 &amp;tagLength);</span>
          }
          else {
              /*
               * Parse the alternateTags string for the language.
               */
<span class="line-new-header">--- 199,25 ---</span>
           * script and region code without worrying about overrunning
           * the user-supplied buffer.
           **/
          char tagBuffer[ULOC_FULLNAME_CAPACITY];
          int32_t tagLength = 0;
          UBool regionAppended = FALSE;
  
          if (langLength &gt; 0) {
              appendTag(
                  lang,
                  langLength,
                  tagBuffer,
<span class="line-modified">!                 &amp;tagLength,</span>
<span class="line-added">+                 /*withSeparator=*/FALSE);</span>
          }
          else if (alternateTags == NULL) {
              /*
<span class="line-modified">!              * Use the empty string for an unknown language, if</span>
               * we found no language.
               */
          }
          else {
              /*
               * Parse the alternateTags string for the language.
               */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 224,34 ***</span>
                  alternateLangLength &gt;= ULOC_LANG_CAPACITY) {
                  goto error;
              }
              else if (alternateLangLength == 0) {
                  /*
<span class="line-modified">!                  * Append the value for an unknown language, if</span>
                   * we found no language.
                   */
<span class="line-removed">-                 appendTag(</span>
<span class="line-removed">-                     unknownLanguage,</span>
<span class="line-removed">-                     (int32_t)uprv_strlen(unknownLanguage),</span>
<span class="line-removed">-                     tagBuffer,</span>
<span class="line-removed">-                     &amp;tagLength);</span>
              }
              else {
                  appendTag(
                      alternateLang,
                      alternateLangLength,
                      tagBuffer,
<span class="line-modified">!                     &amp;tagLength);</span>
              }
          }
  
          if (scriptLength &gt; 0) {
              appendTag(
                  script,
                  scriptLength,
                  tagBuffer,
<span class="line-modified">!                 &amp;tagLength);</span>
          }
          else if (alternateTags != NULL) {
              /*
               * Parse the alternateTags string for the script.
               */
<span class="line-new-header">--- 234,31 ---</span>
                  alternateLangLength &gt;= ULOC_LANG_CAPACITY) {
                  goto error;
              }
              else if (alternateLangLength == 0) {
                  /*
<span class="line-modified">!                  * Use the empty string for an unknown language, if</span>
                   * we found no language.
                   */
              }
              else {
                  appendTag(
                      alternateLang,
                      alternateLangLength,
                      tagBuffer,
<span class="line-modified">!                     &amp;tagLength,</span>
<span class="line-added">+                     /*withSeparator=*/FALSE);</span>
              }
          }
  
          if (scriptLength &gt; 0) {
              appendTag(
                  script,
                  scriptLength,
                  tagBuffer,
<span class="line-modified">!                 &amp;tagLength,</span>
<span class="line-added">+                 /*withSeparator=*/TRUE);</span>
          }
          else if (alternateTags != NULL) {
              /*
               * Parse the alternateTags string for the script.
               */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 271,20 ***</span>
              else if (alternateScriptLength &gt; 0) {
                  appendTag(
                      alternateScript,
                      alternateScriptLength,
                      tagBuffer,
<span class="line-modified">!                     &amp;tagLength);</span>
              }
          }
  
          if (regionLength &gt; 0) {
              appendTag(
                  region,
                  regionLength,
                  tagBuffer,
<span class="line-modified">!                 &amp;tagLength);</span>
  
              regionAppended = TRUE;
          }
          else if (alternateTags != NULL) {
              /*
<span class="line-new-header">--- 278,22 ---</span>
              else if (alternateScriptLength &gt; 0) {
                  appendTag(
                      alternateScript,
                      alternateScriptLength,
                      tagBuffer,
<span class="line-modified">!                     &amp;tagLength,</span>
<span class="line-added">+                     /*withSeparator=*/TRUE);</span>
              }
          }
  
          if (regionLength &gt; 0) {
              appendTag(
                  region,
                  regionLength,
                  tagBuffer,
<span class="line-modified">!                 &amp;tagLength,</span>
<span class="line-added">+                 /*withSeparator=*/TRUE);</span>
  
              regionAppended = TRUE;
          }
          else if (alternateTags != NULL) {
              /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,65 ***</span>
              else if (alternateRegionLength &gt; 0) {
                  appendTag(
                      alternateRegion,
                      alternateRegionLength,
                      tagBuffer,
<span class="line-modified">!                     &amp;tagLength);</span>
  
                  regionAppended = TRUE;
              }
          }
  
<span class="line-modified">!         {</span>
<span class="line-modified">!             const int32_t toCopy =</span>
<span class="line-modified">!                 tagLength &gt;= tagCapacity ? tagCapacity : tagLength;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             /**</span>
<span class="line-removed">-              * Copy the partial tag from our internal buffer to the supplied</span>
<span class="line-removed">-              * target.</span>
<span class="line-removed">-              **/</span>
<span class="line-removed">-             uprv_memcpy(</span>
<span class="line-removed">-                 tag,</span>
<span class="line-removed">-                 tagBuffer,</span>
<span class="line-removed">-                 toCopy);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             capacityRemaining -= toCopy;</span>
<span class="line-removed">-         }</span>
  
          if (trailingLength &gt; 0) {
<span class="line-modified">!             if (*trailing != &#39;@&#39; &amp;&amp; capacityRemaining &gt; 0) {</span>
<span class="line-modified">!                 tag[tagLength++] = &#39;_&#39;;</span>
<span class="line-modified">!                 --capacityRemaining;</span>
<span class="line-removed">-                 if (capacityRemaining &gt; 0 &amp;&amp; !regionAppended) {</span>
                      /* extra separator is required */
<span class="line-modified">!                     tag[tagLength++] = &#39;_&#39;;</span>
<span class="line-removed">-                     --capacityRemaining;</span>
                  }
              }
  
<span class="line-modified">!             if (capacityRemaining &gt; 0) {</span>
<span class="line-modified">!                 /*</span>
<span class="line-modified">!                  * Copy the trailing data into the supplied buffer.  Use uprv_memmove, since we</span>
<span class="line-modified">!                  * don&#39;t know if the user-supplied buffers overlap.</span>
<span class="line-removed">-                  */</span>
<span class="line-removed">-                 const int32_t toCopy =</span>
<span class="line-removed">-                     trailingLength &gt;= capacityRemaining ? capacityRemaining : trailingLength;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 uprv_memmove(</span>
<span class="line-removed">-                     &amp;tag[tagLength],</span>
<span class="line-removed">-                     trailing,</span>
<span class="line-removed">-                     toCopy);</span>
<span class="line-removed">-             }</span>
          }
  
<span class="line-modified">!         tagLength += trailingLength;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return u_terminateChars(</span>
<span class="line-removed">-                     tag,</span>
<span class="line-removed">-                     tagCapacity,</span>
<span class="line-removed">-                     tagLength,</span>
<span class="line-removed">-                     err);</span>
      }
  
  error:
  
      /**
<span class="line-new-header">--- 314,39 ---</span>
              else if (alternateRegionLength &gt; 0) {
                  appendTag(
                      alternateRegion,
                      alternateRegionLength,
                      tagBuffer,
<span class="line-modified">!                     &amp;tagLength,</span>
<span class="line-added">+                     /*withSeparator=*/TRUE);</span>
  
                  regionAppended = TRUE;
              }
          }
  
<span class="line-modified">!         /**</span>
<span class="line-modified">!          * Copy the partial tag from our internal buffer to the supplied</span>
<span class="line-modified">!          * target.</span>
<span class="line-modified">!          **/</span>
<span class="line-modified">!         sink.Append(tagBuffer, tagLength);</span>
  
          if (trailingLength &gt; 0) {
<span class="line-modified">!             if (*trailing != &#39;@&#39;) {</span>
<span class="line-modified">!                 sink.Append(&quot;_&quot;, 1);</span>
<span class="line-modified">!                 if (!regionAppended) {</span>
                      /* extra separator is required */
<span class="line-modified">!                     sink.Append(&quot;_&quot;, 1);</span>
                  }
              }
  
<span class="line-modified">!             /*</span>
<span class="line-modified">!              * Copy the trailing data into the supplied buffer.</span>
<span class="line-modified">!              */</span>
<span class="line-modified">!             sink.Append(trailing, trailingLength);</span>
          }
  
<span class="line-modified">!         return;</span>
      }
  
  error:
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 373,12 ***</span>
       **/
      if (*err ==  U_BUFFER_OVERFLOW_ERROR ||
          U_SUCCESS(*err)) {
          *err = U_ILLEGAL_ARGUMENT_ERROR;
      }
<span class="line-removed">- </span>
<span class="line-removed">-     return -1;</span>
  }
  
  /**
   * Create a tag string from the supplied parameters.  The lang, script and region
   * parameters may be NULL pointers. If they are, their corresponding length parameters
<span class="line-new-header">--- 356,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 398,41 ***</span>
   * @param scriptLength The length of the script tag.
   * @param region The region tag to use.
   * @param regionLength The length of the region tag.
   * @param trailing Any trailing data to append to the new tag.
   * @param trailingLength The length of the trailing data.
<span class="line-modified">!  * @param tag The output buffer.</span>
<span class="line-removed">-  * @param tagCapacity The capacity of the output buffer.</span>
   * @param err A pointer to a UErrorCode for error reporting.
<span class="line-removed">-  * @return The length of the tag string, which may be greater than tagCapacity.</span>
   **/
<span class="line-modified">! static int32_t U_CALLCONV</span>
  createTagString(
      const char* lang,
      int32_t langLength,
      const char* script,
      int32_t scriptLength,
      const char* region,
      int32_t regionLength,
      const char* trailing,
      int32_t trailingLength,
<span class="line-modified">!     char* tag,</span>
<span class="line-removed">-     int32_t tagCapacity,</span>
      UErrorCode* err)
  {
<span class="line-modified">!     return createTagStringWithAlternates(</span>
                  lang,
                  langLength,
                  script,
                  scriptLength,
                  region,
                  regionLength,
                  trailing,
                  trailingLength,
                  NULL,
<span class="line-modified">!                 tag,</span>
<span class="line-removed">-                 tagCapacity,</span>
                  err);
  }
  
  /**
   * Parse the language, script, and region subtags from a tag string, and copy the
<span class="line-new-header">--- 379,37 ---</span>
   * @param scriptLength The length of the script tag.
   * @param region The region tag to use.
   * @param regionLength The length of the region tag.
   * @param trailing Any trailing data to append to the new tag.
   * @param trailingLength The length of the trailing data.
<span class="line-modified">!  * @param sink The output sink receiving the tag string.</span>
   * @param err A pointer to a UErrorCode for error reporting.
   **/
<span class="line-modified">! static void U_CALLCONV</span>
  createTagString(
      const char* lang,
      int32_t langLength,
      const char* script,
      int32_t scriptLength,
      const char* region,
      int32_t regionLength,
      const char* trailing,
      int32_t trailingLength,
<span class="line-modified">!     icu::ByteSink&amp; sink,</span>
      UErrorCode* err)
  {
<span class="line-modified">!     createTagStringWithAlternates(</span>
                  lang,
                  langLength,
                  script,
                  scriptLength,
                  region,
                  regionLength,
                  trailing,
                  trailingLength,
                  NULL,
<span class="line-modified">!                 sink,</span>
                  err);
  }
  
  /**
   * Parse the language, script, and region subtags from a tag string, and copy the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 500,19 ***</span>
      }
  
      *langLength = subtagLength;
  
      /*
<span class="line-modified">!      * If no language was present, use the value of unknownLanguage</span>
<span class="line-modified">!      * instead.  Otherwise, move past any separator.</span>
       */
<span class="line-removed">-     if (*langLength == 0) {</span>
<span class="line-removed">-         uprv_strcpy(</span>
<span class="line-removed">-             lang,</span>
<span class="line-removed">-             unknownLanguage);</span>
<span class="line-removed">-         *langLength = (int32_t)uprv_strlen(lang);</span>
<span class="line-removed">-     }</span>
      if (_isIDSeparator(*position)) {
          ++position;
      }
  
      subtagLength = ulocimp_getScript(position, script, *scriptLength, &amp;position);
<span class="line-new-header">--- 477,13 ---</span>
      }
  
      *langLength = subtagLength;
  
      /*
<span class="line-modified">!      * If no language was present, use the empty string instead.</span>
<span class="line-modified">!      * Otherwise, move past any separator.</span>
       */
      if (_isIDSeparator(*position)) {
          ++position;
      }
  
      subtagLength = ulocimp_getScript(position, script, *scriptLength, &amp;position);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 576,31 ***</span>
      }
  
      goto exit;
  }
  
<span class="line-modified">! static int32_t U_CALLCONV</span>
  createLikelySubtagsString(
      const char* lang,
      int32_t langLength,
      const char* script,
      int32_t scriptLength,
      const char* region,
      int32_t regionLength,
      const char* variants,
      int32_t variantsLength,
<span class="line-modified">!     char* tag,</span>
<span class="line-modified">!     int32_t tagCapacity,</span>
<span class="line-removed">-     UErrorCode* err)</span>
<span class="line-removed">- {</span>
      /**
       * ULOC_FULLNAME_CAPACITY will provide enough capacity
       * that we can build a string that contains the language,
       * script and region code without worrying about overrunning
       * the user-supplied buffer.
<span class="line-removed">-     char tagBuffer[ULOC_FULLNAME_CAPACITY];</span>
      char likelySubtagsBuffer[ULOC_FULLNAME_CAPACITY];
  
      if(U_FAILURE(*err)) {
          goto error;
      }
<span class="line-new-header">--- 547,28 ---</span>
      }
  
      goto exit;
  }
  
<span class="line-modified">! static UBool U_CALLCONV</span>
  createLikelySubtagsString(
      const char* lang,
      int32_t langLength,
      const char* script,
      int32_t scriptLength,
      const char* region,
      int32_t regionLength,
      const char* variants,
      int32_t variantsLength,
<span class="line-modified">!     icu::ByteSink&amp; sink,</span>
<span class="line-modified">!     UErrorCode* err) {</span>
      /**
       * ULOC_FULLNAME_CAPACITY will provide enough capacity
       * that we can build a string that contains the language,
       * script and region code without worrying about overrunning
       * the user-supplied buffer.
      char likelySubtagsBuffer[ULOC_FULLNAME_CAPACITY];
  
      if(U_FAILURE(*err)) {
          goto error;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 610,29 ***</span>
       **/
      if (scriptLength &gt; 0 &amp;&amp; regionLength &gt; 0) {
  
          const char* likelySubtags = NULL;
  
<span class="line-modified">!         createTagString(</span>
<span class="line-modified">!             lang,</span>
<span class="line-modified">!             langLength,</span>
<span class="line-modified">!             script,</span>
<span class="line-modified">!             scriptLength,</span>
<span class="line-modified">!             region,</span>
<span class="line-modified">!             regionLength,</span>
<span class="line-modified">!             NULL,</span>
<span class="line-modified">!             0,</span>
<span class="line-modified">!             tagBuffer,</span>
<span class="line-modified">!             sizeof(tagBuffer),</span>
<span class="line-modified">!             err);</span>
          if(U_FAILURE(*err)) {
              goto error;
          }
  
          likelySubtags =
              findLikelySubtags(
<span class="line-modified">!                 tagBuffer,</span>
                  likelySubtagsBuffer,
                  sizeof(likelySubtagsBuffer),
                  err);
          if(U_FAILURE(*err)) {
              goto error;
<span class="line-new-header">--- 578,32 ---</span>
       **/
      if (scriptLength &gt; 0 &amp;&amp; regionLength &gt; 0) {
  
          const char* likelySubtags = NULL;
  
<span class="line-modified">!         icu::CharString tagBuffer;</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
<span class="line-modified">!             createTagString(</span>
<span class="line-modified">!                 lang,</span>
<span class="line-modified">!                 langLength,</span>
<span class="line-modified">!                 script,</span>
<span class="line-modified">!                 scriptLength,</span>
<span class="line-modified">!                 region,</span>
<span class="line-modified">!                 regionLength,</span>
<span class="line-modified">!                 NULL,</span>
<span class="line-modified">!                 0,</span>
<span class="line-added">+                 sink,</span>
<span class="line-added">+                 err);</span>
<span class="line-added">+         }</span>
          if(U_FAILURE(*err)) {
              goto error;
          }
  
          likelySubtags =
              findLikelySubtags(
<span class="line-modified">!                 tagBuffer.data(),</span>
                  likelySubtagsBuffer,
                  sizeof(likelySubtagsBuffer),
                  err);
          if(U_FAILURE(*err)) {
              goto error;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 640,52 ***</span>
  
          if (likelySubtags != NULL) {
              /* Always use the language tag from the
                 maximal string, since it may be more
                 specific than the one provided. */
<span class="line-modified">!             return createTagStringWithAlternates(</span>
                          NULL,
                          0,
                          NULL,
                          0,
                          NULL,
                          0,
                          variants,
                          variantsLength,
                          likelySubtags,
<span class="line-modified">!                         tag,</span>
<span class="line-removed">-                         tagCapacity,</span>
                          err);
          }
      }
  
      /**
       * Try the language with just the script.
       **/
      if (scriptLength &gt; 0) {
  
          const char* likelySubtags = NULL;
  
<span class="line-modified">!         createTagString(</span>
<span class="line-modified">!             lang,</span>
<span class="line-modified">!             langLength,</span>
<span class="line-modified">!             script,</span>
<span class="line-modified">!             scriptLength,</span>
<span class="line-modified">!             NULL,</span>
<span class="line-modified">!             0,</span>
<span class="line-modified">!             NULL,</span>
<span class="line-modified">!             0,</span>
<span class="line-modified">!             tagBuffer,</span>
<span class="line-modified">!             sizeof(tagBuffer),</span>
<span class="line-modified">!             err);</span>
          if(U_FAILURE(*err)) {
              goto error;
          }
  
          likelySubtags =
              findLikelySubtags(
<span class="line-modified">!                 tagBuffer,</span>
                  likelySubtagsBuffer,
                  sizeof(likelySubtagsBuffer),
                  err);
          if(U_FAILURE(*err)) {
              goto error;
<span class="line-new-header">--- 611,55 ---</span>
  
          if (likelySubtags != NULL) {
              /* Always use the language tag from the
                 maximal string, since it may be more
                 specific than the one provided. */
<span class="line-modified">!             createTagStringWithAlternates(</span>
                          NULL,
                          0,
                          NULL,
                          0,
                          NULL,
                          0,
                          variants,
                          variantsLength,
                          likelySubtags,
<span class="line-modified">!                         sink,</span>
                          err);
<span class="line-added">+             return TRUE;</span>
          }
      }
  
      /**
       * Try the language with just the script.
       **/
      if (scriptLength &gt; 0) {
  
          const char* likelySubtags = NULL;
  
<span class="line-modified">!         icu::CharString tagBuffer;</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
<span class="line-modified">!             createTagString(</span>
<span class="line-modified">!                 lang,</span>
<span class="line-modified">!                 langLength,</span>
<span class="line-modified">!                 script,</span>
<span class="line-modified">!                 scriptLength,</span>
<span class="line-modified">!                 NULL,</span>
<span class="line-modified">!                 0,</span>
<span class="line-modified">!                 NULL,</span>
<span class="line-modified">!                 0,</span>
<span class="line-added">+                 sink,</span>
<span class="line-added">+                 err);</span>
<span class="line-added">+         }</span>
          if(U_FAILURE(*err)) {
              goto error;
          }
  
          likelySubtags =
              findLikelySubtags(
<span class="line-modified">!                 tagBuffer.data(),</span>
                  likelySubtagsBuffer,
                  sizeof(likelySubtagsBuffer),
                  err);
          if(U_FAILURE(*err)) {
              goto error;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 693,52 ***</span>
  
          if (likelySubtags != NULL) {
              /* Always use the language tag from the
                 maximal string, since it may be more
                 specific than the one provided. */
<span class="line-modified">!             return createTagStringWithAlternates(</span>
                          NULL,
                          0,
                          NULL,
                          0,
                          region,
                          regionLength,
                          variants,
                          variantsLength,
                          likelySubtags,
<span class="line-modified">!                         tag,</span>
<span class="line-removed">-                         tagCapacity,</span>
                          err);
          }
      }
  
      /**
       * Try the language with just the region.
       **/
      if (regionLength &gt; 0) {
  
          const char* likelySubtags = NULL;
  
<span class="line-modified">!         createTagString(</span>
<span class="line-modified">!             lang,</span>
<span class="line-modified">!             langLength,</span>
<span class="line-modified">!             NULL,</span>
<span class="line-modified">!             0,</span>
<span class="line-modified">!             region,</span>
<span class="line-modified">!             regionLength,</span>
<span class="line-modified">!             NULL,</span>
<span class="line-modified">!             0,</span>
<span class="line-modified">!             tagBuffer,</span>
<span class="line-modified">!             sizeof(tagBuffer),</span>
<span class="line-modified">!             err);</span>
          if(U_FAILURE(*err)) {
              goto error;
          }
  
          likelySubtags =
              findLikelySubtags(
<span class="line-modified">!                 tagBuffer,</span>
                  likelySubtagsBuffer,
                  sizeof(likelySubtagsBuffer),
                  err);
          if(U_FAILURE(*err)) {
              goto error;
<span class="line-new-header">--- 667,55 ---</span>
  
          if (likelySubtags != NULL) {
              /* Always use the language tag from the
                 maximal string, since it may be more
                 specific than the one provided. */
<span class="line-modified">!             createTagStringWithAlternates(</span>
                          NULL,
                          0,
                          NULL,
                          0,
                          region,
                          regionLength,
                          variants,
                          variantsLength,
                          likelySubtags,
<span class="line-modified">!                         sink,</span>
                          err);
<span class="line-added">+             return TRUE;</span>
          }
      }
  
      /**
       * Try the language with just the region.
       **/
      if (regionLength &gt; 0) {
  
          const char* likelySubtags = NULL;
  
<span class="line-modified">!         icu::CharString tagBuffer;</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
<span class="line-modified">!             createTagString(</span>
<span class="line-modified">!                 lang,</span>
<span class="line-modified">!                 langLength,</span>
<span class="line-modified">!                 NULL,</span>
<span class="line-modified">!                 0,</span>
<span class="line-modified">!                 region,</span>
<span class="line-modified">!                 regionLength,</span>
<span class="line-modified">!                 NULL,</span>
<span class="line-modified">!                 0,</span>
<span class="line-added">+                 sink,</span>
<span class="line-added">+                 err);</span>
<span class="line-added">+         }</span>
          if(U_FAILURE(*err)) {
              goto error;
          }
  
          likelySubtags =
              findLikelySubtags(
<span class="line-modified">!                 tagBuffer.data(),</span>
                  likelySubtagsBuffer,
                  sizeof(likelySubtagsBuffer),
                  err);
          if(U_FAILURE(*err)) {
              goto error;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 746,51 ***</span>
  
          if (likelySubtags != NULL) {
              /* Always use the language tag from the
                 maximal string, since it may be more
                 specific than the one provided. */
<span class="line-modified">!             return createTagStringWithAlternates(</span>
                          NULL,
                          0,
                          script,
                          scriptLength,
                          NULL,
                          0,
                          variants,
                          variantsLength,
                          likelySubtags,
<span class="line-modified">!                         tag,</span>
<span class="line-removed">-                         tagCapacity,</span>
                          err);
          }
      }
  
      /**
       * Finally, try just the language.
       **/
      {
          const char* likelySubtags = NULL;
  
<span class="line-modified">!         createTagString(</span>
<span class="line-modified">!             lang,</span>
<span class="line-modified">!             langLength,</span>
<span class="line-modified">!             NULL,</span>
<span class="line-modified">!             0,</span>
<span class="line-modified">!             NULL,</span>
<span class="line-modified">!             0,</span>
<span class="line-modified">!             NULL,</span>
<span class="line-modified">!             0,</span>
<span class="line-modified">!             tagBuffer,</span>
<span class="line-modified">!             sizeof(tagBuffer),</span>
<span class="line-modified">!             err);</span>
          if(U_FAILURE(*err)) {
              goto error;
          }
  
          likelySubtags =
              findLikelySubtags(
<span class="line-modified">!                 tagBuffer,</span>
                  likelySubtagsBuffer,
                  sizeof(likelySubtagsBuffer),
                  err);
          if(U_FAILURE(*err)) {
              goto error;
<span class="line-new-header">--- 723,54 ---</span>
  
          if (likelySubtags != NULL) {
              /* Always use the language tag from the
                 maximal string, since it may be more
                 specific than the one provided. */
<span class="line-modified">!             createTagStringWithAlternates(</span>
                          NULL,
                          0,
                          script,
                          scriptLength,
                          NULL,
                          0,
                          variants,
                          variantsLength,
                          likelySubtags,
<span class="line-modified">!                         sink,</span>
                          err);
<span class="line-added">+             return TRUE;</span>
          }
      }
  
      /**
       * Finally, try just the language.
       **/
      {
          const char* likelySubtags = NULL;
  
<span class="line-modified">!         icu::CharString tagBuffer;</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
<span class="line-modified">!             createTagString(</span>
<span class="line-modified">!                 lang,</span>
<span class="line-modified">!                 langLength,</span>
<span class="line-modified">!                 NULL,</span>
<span class="line-modified">!                 0,</span>
<span class="line-modified">!                 NULL,</span>
<span class="line-modified">!                 0,</span>
<span class="line-modified">!                 NULL,</span>
<span class="line-modified">!                 0,</span>
<span class="line-added">+                 sink,</span>
<span class="line-added">+                 err);</span>
<span class="line-added">+         }</span>
          if(U_FAILURE(*err)) {
              goto error;
          }
  
          likelySubtags =
              findLikelySubtags(
<span class="line-modified">!                 tagBuffer.data(),</span>
                  likelySubtagsBuffer,
                  sizeof(likelySubtagsBuffer),
                  err);
          if(U_FAILURE(*err)) {
              goto error;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 798,39 ***</span>
  
          if (likelySubtags != NULL) {
              /* Always use the language tag from the
                 maximal string, since it may be more
                 specific than the one provided. */
<span class="line-modified">!             return createTagStringWithAlternates(</span>
                          NULL,
                          0,
                          script,
                          scriptLength,
                          region,
                          regionLength,
                          variants,
                          variantsLength,
                          likelySubtags,
<span class="line-modified">!                         tag,</span>
<span class="line-removed">-                         tagCapacity,</span>
                          err);
          }
      }
  
<span class="line-modified">!     return u_terminateChars(</span>
<span class="line-removed">-                 tag,</span>
<span class="line-removed">-                 tagCapacity,</span>
<span class="line-removed">-                 0,</span>
<span class="line-removed">-                 err);</span>
  
  error:
  
      if (!U_FAILURE(*err)) {
          *err = U_ILLEGAL_ARGUMENT_ERROR;
      }
  
<span class="line-modified">!     return -1;</span>
  }
  
  #define CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength) \
      {   int32_t count = 0; \
          int32_t i; \
<span class="line-new-header">--- 778,35 ---</span>
  
          if (likelySubtags != NULL) {
              /* Always use the language tag from the
                 maximal string, since it may be more
                 specific than the one provided. */
<span class="line-modified">!             createTagStringWithAlternates(</span>
                          NULL,
                          0,
                          script,
                          scriptLength,
                          region,
                          regionLength,
                          variants,
                          variantsLength,
                          likelySubtags,
<span class="line-modified">!                         sink,</span>
                          err);
<span class="line-added">+             return TRUE;</span>
          }
      }
  
<span class="line-modified">!     return FALSE;</span>
  
  error:
  
      if (!U_FAILURE(*err)) {
          *err = U_ILLEGAL_ARGUMENT_ERROR;
      }
  
<span class="line-modified">!     return FALSE;</span>
  }
  
  #define CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength) \
      {   int32_t count = 0; \
          int32_t i; \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 848,33 ***</span>
                  count++; \
              } \
          } \
      }
  
<span class="line-modified">! static int32_t</span>
<span class="line-modified">! _uloc_addLikelySubtags(const char*    localeID,</span>
<span class="line-modified">!          char* maximizedLocaleID,</span>
<span class="line-modified">!          int32_t maximizedLocaleIDCapacity,</span>
<span class="line-removed">-          UErrorCode* err)</span>
<span class="line-removed">- {</span>
      char lang[ULOC_LANG_CAPACITY];
      int32_t langLength = sizeof(lang);
      char script[ULOC_SCRIPT_CAPACITY];
      int32_t scriptLength = sizeof(script);
      char region[ULOC_COUNTRY_CAPACITY];
      int32_t regionLength = sizeof(region);
      const char* trailing = &quot;&quot;;
      int32_t trailingLength = 0;
      int32_t trailingIndex = 0;
<span class="line-modified">!     int32_t resultLength = 0;</span>
  
      if(U_FAILURE(*err)) {
          goto error;
      }
<span class="line-modified">!     else if (localeID == NULL ||</span>
<span class="line-removed">-              maximizedLocaleID == NULL ||</span>
<span class="line-removed">-              maximizedLocaleIDCapacity &lt;= 0) {</span>
          goto error;
      }
  
      trailingIndex = parseTagString(
          localeID,
<span class="line-new-header">--- 824,29 ---</span>
                  count++; \
              } \
          } \
      }
  
<span class="line-modified">! static void</span>
<span class="line-modified">! _uloc_addLikelySubtags(const char* localeID,</span>
<span class="line-modified">!                        icu::ByteSink&amp; sink,</span>
<span class="line-modified">!                        UErrorCode* err) {</span>
      char lang[ULOC_LANG_CAPACITY];
      int32_t langLength = sizeof(lang);
      char script[ULOC_SCRIPT_CAPACITY];
      int32_t scriptLength = sizeof(script);
      char region[ULOC_COUNTRY_CAPACITY];
      int32_t regionLength = sizeof(region);
      const char* trailing = &quot;&quot;;
      int32_t trailingLength = 0;
      int32_t trailingIndex = 0;
<span class="line-modified">!     UBool success = FALSE;</span>
  
      if(U_FAILURE(*err)) {
          goto error;
      }
<span class="line-modified">!     if (localeID == NULL) {</span>
          goto error;
      }
  
      trailingIndex = parseTagString(
          localeID,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 901,69 ***</span>
      trailing = &amp;localeID[trailingIndex];
      trailingLength = (int32_t)uprv_strlen(trailing);
  
      CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength);
  
<span class="line-modified">!     resultLength =</span>
          createLikelySubtagsString(
              lang,
              langLength,
              script,
              scriptLength,
              region,
              regionLength,
              trailing,
              trailingLength,
<span class="line-modified">!             maximizedLocaleID,</span>
<span class="line-removed">-             maximizedLocaleIDCapacity,</span>
              err);
  
<span class="line-modified">!     if (resultLength == 0) {</span>
          const int32_t localIDLength = (int32_t)uprv_strlen(localeID);
  
          /*
           * If we get here, we need to return localeID.
           */
<span class="line-modified">!         uprv_memcpy(</span>
<span class="line-removed">-             maximizedLocaleID,</span>
<span class="line-removed">-             localeID,</span>
<span class="line-removed">-             localIDLength &lt;= maximizedLocaleIDCapacity ?</span>
<span class="line-removed">-                 localIDLength : maximizedLocaleIDCapacity);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         resultLength =</span>
<span class="line-removed">-             u_terminateChars(</span>
<span class="line-removed">-                 maximizedLocaleID,</span>
<span class="line-removed">-                 maximizedLocaleIDCapacity,</span>
<span class="line-removed">-                 localIDLength,</span>
<span class="line-removed">-                 err);</span>
      }
  
<span class="line-modified">!     return resultLength;</span>
  
  error:
  
      if (!U_FAILURE(*err)) {
          *err = U_ILLEGAL_ARGUMENT_ERROR;
      }
<span class="line-removed">- </span>
<span class="line-removed">-     return -1;</span>
  }
  
<span class="line-modified">! static int32_t</span>
<span class="line-modified">! _uloc_minimizeSubtags(const char*    localeID,</span>
<span class="line-modified">!          char* minimizedLocaleID,</span>
<span class="line-modified">!          int32_t minimizedLocaleIDCapacity,</span>
<span class="line-modified">!          UErrorCode* err)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * ULOC_FULLNAME_CAPACITY will provide enough capacity</span>
<span class="line-removed">-      * that we can build a string that contains the language,</span>
<span class="line-removed">-      * script and region code without worrying about overrunning</span>
<span class="line-removed">-      * the user-supplied buffer.</span>
<span class="line-removed">-      **/</span>
<span class="line-removed">-     char maximizedTagBuffer[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-removed">-     int32_t maximizedTagBufferLength = sizeof(maximizedTagBuffer);</span>
  
      char lang[ULOC_LANG_CAPACITY];
      int32_t langLength = sizeof(lang);
      char script[ULOC_SCRIPT_CAPACITY];
      int32_t scriptLength = sizeof(script);
<span class="line-new-header">--- 873,46 ---</span>
      trailing = &amp;localeID[trailingIndex];
      trailingLength = (int32_t)uprv_strlen(trailing);
  
      CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength);
  
<span class="line-modified">!     success =</span>
          createLikelySubtagsString(
              lang,
              langLength,
              script,
              scriptLength,
              region,
              regionLength,
              trailing,
              trailingLength,
<span class="line-modified">!             sink,</span>
              err);
  
<span class="line-modified">!     if (!success) {</span>
          const int32_t localIDLength = (int32_t)uprv_strlen(localeID);
  
          /*
           * If we get here, we need to return localeID.
           */
<span class="line-modified">!         sink.Append(localeID, localIDLength);</span>
      }
  
<span class="line-modified">!     return;</span>
  
  error:
  
      if (!U_FAILURE(*err)) {
          *err = U_ILLEGAL_ARGUMENT_ERROR;
      }
  }
  
<span class="line-modified">! static void</span>
<span class="line-modified">! _uloc_minimizeSubtags(const char* localeID,</span>
<span class="line-modified">!                       icu::ByteSink&amp; sink,</span>
<span class="line-modified">!                       UErrorCode* err) {</span>
<span class="line-modified">!     icu::CharString maximizedTagBuffer;</span>
  
      char lang[ULOC_LANG_CAPACITY];
      int32_t langLength = sizeof(lang);
      char script[ULOC_SCRIPT_CAPACITY];
      int32_t scriptLength = sizeof(script);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 974,13 ***</span>
      int32_t trailingIndex = 0;
  
      if(U_FAILURE(*err)) {
          goto error;
      }
<span class="line-modified">!     else if (localeID == NULL ||</span>
<span class="line-removed">-              minimizedLocaleID == NULL ||</span>
<span class="line-removed">-              minimizedLocaleIDCapacity &lt;= 0) {</span>
          goto error;
      }
  
      trailingIndex =
          parseTagString(
<span class="line-new-header">--- 923,11 ---</span>
      int32_t trailingIndex = 0;
  
      if(U_FAILURE(*err)) {
          goto error;
      }
<span class="line-modified">!     else if (localeID == NULL) {</span>
          goto error;
      }
  
      trailingIndex =
          parseTagString(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1009,201 ***</span>
      trailing = &amp;localeID[trailingIndex];
      trailingLength = (int32_t)uprv_strlen(trailing);
  
      CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength);
  
<span class="line-modified">!     createTagString(</span>
<span class="line-modified">!         lang,</span>
<span class="line-modified">!         langLength,</span>
<span class="line-modified">!         script,</span>
<span class="line-modified">!         scriptLength,</span>
<span class="line-modified">!         region,</span>
<span class="line-modified">!         regionLength,</span>
<span class="line-modified">!         NULL,</span>
<span class="line-modified">!         0,</span>
<span class="line-modified">!         maximizedTagBuffer,</span>
<span class="line-modified">!         maximizedTagBufferLength,</span>
<span class="line-modified">!         err);</span>
<span class="line-modified">!     if(U_FAILURE(*err)) {</span>
<span class="line-modified">!         goto error;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * First, we need to first get the maximization</span>
<span class="line-modified">!      * from AddLikelySubtags.</span>
<span class="line-modified">!      **/</span>
<span class="line-modified">!     maximizedTagBufferLength =</span>
<span class="line-modified">!         uloc_addLikelySubtags(</span>
<span class="line-modified">!             maximizedTagBuffer,</span>
<span class="line-modified">!             maximizedTagBuffer,</span>
<span class="line-modified">!             maximizedTagBufferLength,</span>
<span class="line-removed">-             err);</span>
  
      if(U_FAILURE(*err)) {
          goto error;
      }
  
      /**
       * Start first with just the language.
       **/
      {
<span class="line-modified">!         char tagBuffer[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-modified">! </span>
<span class="line-modified">!         const int32_t tagBufferLength =</span>
              createLikelySubtagsString(
                  lang,
                  langLength,
                  NULL,
                  0,
                  NULL,
                  0,
                  NULL,
                  0,
<span class="line-modified">!                 tagBuffer,</span>
<span class="line-removed">-                 sizeof(tagBuffer),</span>
                  err);
  
          if(U_FAILURE(*err)) {
              goto error;
          }
<span class="line-modified">!         else if (uprv_strnicmp(</span>
<span class="line-modified">!                     maximizedTagBuffer,</span>
<span class="line-modified">!                     tagBuffer,</span>
<span class="line-modified">!                     tagBufferLength) == 0) {</span>
  
<span class="line-modified">!             return createTagString(</span>
                          lang,
                          langLength,
                          NULL,
                          0,
                          NULL,
                          0,
                          trailing,
                          trailingLength,
<span class="line-modified">!                         minimizedLocaleID,</span>
<span class="line-removed">-                         minimizedLocaleIDCapacity,</span>
                          err);
          }
      }
  
      /**
       * Next, try the language and region.
       **/
      if (regionLength &gt; 0) {
  
<span class="line-modified">!         char tagBuffer[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-modified">! </span>
<span class="line-modified">!         const int32_t tagBufferLength =</span>
              createLikelySubtagsString(
                  lang,
                  langLength,
                  NULL,
                  0,
                  region,
                  regionLength,
                  NULL,
                  0,
<span class="line-modified">!                 tagBuffer,</span>
<span class="line-removed">-                 sizeof(tagBuffer),</span>
                  err);
  
          if(U_FAILURE(*err)) {
              goto error;
          }
          else if (uprv_strnicmp(
<span class="line-modified">!                     maximizedTagBuffer,</span>
<span class="line-modified">!                     tagBuffer,</span>
<span class="line-modified">!                     tagBufferLength) == 0) {</span>
  
<span class="line-modified">!             return createTagString(</span>
                          lang,
                          langLength,
                          NULL,
                          0,
                          region,
                          regionLength,
                          trailing,
                          trailingLength,
<span class="line-modified">!                         minimizedLocaleID,</span>
<span class="line-removed">-                         minimizedLocaleIDCapacity,</span>
                          err);
          }
      }
  
      /**
       * Finally, try the language and script.  This is our last chance,
       * since trying with all three subtags would only yield the
       * maximal version that we already have.
       **/
      if (scriptLength &gt; 0 &amp;&amp; regionLength &gt; 0) {
<span class="line-modified">!         char tagBuffer[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-modified">! </span>
<span class="line-modified">!         const int32_t tagBufferLength =</span>
              createLikelySubtagsString(
                  lang,
                  langLength,
                  script,
                  scriptLength,
                  NULL,
                  0,
                  NULL,
                  0,
<span class="line-modified">!                 tagBuffer,</span>
<span class="line-removed">-                 sizeof(tagBuffer),</span>
                  err);
  
          if(U_FAILURE(*err)) {
              goto error;
          }
          else if (uprv_strnicmp(
<span class="line-modified">!                     maximizedTagBuffer,</span>
<span class="line-modified">!                     tagBuffer,</span>
<span class="line-modified">!                     tagBufferLength) == 0) {</span>
  
<span class="line-modified">!             return createTagString(</span>
                          lang,
                          langLength,
                          script,
                          scriptLength,
                          NULL,
                          0,
                          trailing,
                          trailingLength,
<span class="line-modified">!                         minimizedLocaleID,</span>
<span class="line-removed">-                         minimizedLocaleIDCapacity,</span>
                          err);
          }
      }
  
      {
          /**
           * If we got here, return the locale ID parameter.
           **/
          const int32_t localeIDLength = (int32_t)uprv_strlen(localeID);
<span class="line-modified">! </span>
<span class="line-modified">!         uprv_memcpy(</span>
<span class="line-removed">-             minimizedLocaleID,</span>
<span class="line-removed">-             localeID,</span>
<span class="line-removed">-             localeIDLength &lt;= minimizedLocaleIDCapacity ?</span>
<span class="line-removed">-                 localeIDLength : minimizedLocaleIDCapacity);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return u_terminateChars(</span>
<span class="line-removed">-                     minimizedLocaleID,</span>
<span class="line-removed">-                     minimizedLocaleIDCapacity,</span>
<span class="line-removed">-                     localeIDLength,</span>
<span class="line-removed">-                     err);</span>
      }
  
  error:
  
      if (!U_FAILURE(*err)) {
<span class="line-removed">- </span>
<span class="line-removed">-     return -1;</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  }
  
  static UBool
  do_canonicalize(const char*    localeID,
           char* buffer,
<span class="line-new-header">--- 956,187 ---</span>
      trailing = &amp;localeID[trailingIndex];
      trailingLength = (int32_t)uprv_strlen(trailing);
  
      CHECK_TRAILING_VARIANT_SIZE(trailing, trailingLength);
  
<span class="line-modified">!     {</span>
<span class="line-modified">!         icu::CharString base;</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             icu::CharStringByteSink sink(&amp;base);</span>
<span class="line-modified">!             createTagString(</span>
<span class="line-modified">!                 lang,</span>
<span class="line-modified">!                 langLength,</span>
<span class="line-modified">!                 script,</span>
<span class="line-modified">!                 scriptLength,</span>
<span class="line-modified">!                 region,</span>
<span class="line-modified">!                 regionLength,</span>
<span class="line-modified">!                 NULL,</span>
<span class="line-modified">!                 0,</span>
<span class="line-modified">!                 sink,</span>
<span class="line-modified">!                 err);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         /**</span>
<span class="line-modified">!          * First, we need to first get the maximization</span>
<span class="line-modified">!          * from AddLikelySubtags.</span>
<span class="line-modified">!          **/</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             icu::CharStringByteSink sink(&amp;maximizedTagBuffer);</span>
<span class="line-modified">!             ulocimp_addLikelySubtags(base.data(), sink, err);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
  
      if(U_FAILURE(*err)) {
          goto error;
      }
  
      /**
       * Start first with just the language.
       **/
      {
<span class="line-modified">!         icu::CharString tagBuffer;</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
              createLikelySubtagsString(
                  lang,
                  langLength,
                  NULL,
                  0,
                  NULL,
                  0,
                  NULL,
                  0,
<span class="line-modified">!                 sink,</span>
                  err);
<span class="line-added">+         }</span>
  
          if(U_FAILURE(*err)) {
              goto error;
          }
<span class="line-modified">!         else if (!tagBuffer.isEmpty() &amp;&amp; uprv_strnicmp(</span>
<span class="line-modified">!                     maximizedTagBuffer.data(),</span>
<span class="line-modified">!                     tagBuffer.data(),</span>
<span class="line-modified">!                     tagBuffer.length()) == 0) {</span>
  
<span class="line-modified">!             createTagString(</span>
                          lang,
                          langLength,
                          NULL,
                          0,
                          NULL,
                          0,
                          trailing,
                          trailingLength,
<span class="line-modified">!                         sink,</span>
                          err);
<span class="line-added">+             return;</span>
          }
      }
  
      /**
       * Next, try the language and region.
       **/
      if (regionLength &gt; 0) {
  
<span class="line-modified">!         icu::CharString tagBuffer;</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
              createLikelySubtagsString(
                  lang,
                  langLength,
                  NULL,
                  0,
                  region,
                  regionLength,
                  NULL,
                  0,
<span class="line-modified">!                 sink,</span>
                  err);
<span class="line-added">+         }</span>
  
          if(U_FAILURE(*err)) {
              goto error;
          }
          else if (uprv_strnicmp(
<span class="line-modified">!                     maximizedTagBuffer.data(),</span>
<span class="line-modified">!                     tagBuffer.data(),</span>
<span class="line-modified">!                     tagBuffer.length()) == 0) {</span>
  
<span class="line-modified">!             createTagString(</span>
                          lang,
                          langLength,
                          NULL,
                          0,
                          region,
                          regionLength,
                          trailing,
                          trailingLength,
<span class="line-modified">!                         sink,</span>
                          err);
<span class="line-added">+             return;</span>
          }
      }
  
      /**
       * Finally, try the language and script.  This is our last chance,
       * since trying with all three subtags would only yield the
       * maximal version that we already have.
       **/
      if (scriptLength &gt; 0 &amp;&amp; regionLength &gt; 0) {
<span class="line-modified">!         icu::CharString tagBuffer;</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             icu::CharStringByteSink sink(&amp;tagBuffer);</span>
              createLikelySubtagsString(
                  lang,
                  langLength,
                  script,
                  scriptLength,
                  NULL,
                  0,
                  NULL,
                  0,
<span class="line-modified">!                 sink,</span>
                  err);
<span class="line-added">+         }</span>
  
          if(U_FAILURE(*err)) {
              goto error;
          }
          else if (uprv_strnicmp(
<span class="line-modified">!                     maximizedTagBuffer.data(),</span>
<span class="line-modified">!                     tagBuffer.data(),</span>
<span class="line-modified">!                     tagBuffer.length()) == 0) {</span>
  
<span class="line-modified">!             createTagString(</span>
                          lang,
                          langLength,
                          script,
                          scriptLength,
                          NULL,
                          0,
                          trailing,
                          trailingLength,
<span class="line-modified">!                         sink,</span>
                          err);
<span class="line-added">+             return;</span>
          }
      }
  
      {
          /**
           * If we got here, return the locale ID parameter.
           **/
          const int32_t localeIDLength = (int32_t)uprv_strlen(localeID);
<span class="line-modified">!         sink.Append(localeID, localeIDLength);</span>
<span class="line-modified">!         return;</span>
      }
  
  error:
  
      if (!U_FAILURE(*err)) {
  }
  
  static UBool
  do_canonicalize(const char*    localeID,
           char* buffer,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1230,63 ***</span>
          return TRUE;
      }
  }
  
  U_CAPI int32_t U_EXPORT2
<span class="line-modified">! uloc_addLikelySubtags(const char*    localeID,</span>
<span class="line-modified">!          char* maximizedLocaleID,</span>
<span class="line-modified">!          int32_t maximizedLocaleIDCapacity,</span>
<span class="line-modified">!          UErrorCode* err)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     char localeBuffer[ULOC_FULLNAME_CAPACITY];</span>
  
<span class="line-modified">!     if (!do_canonicalize(</span>
<span class="line-modified">!         localeID,</span>
<span class="line-modified">!         localeBuffer,</span>
<span class="line-modified">!         sizeof(localeBuffer),</span>
<span class="line-modified">!         err)) {</span>
<span class="line-modified">!         return -1;</span>
      }
<span class="line-modified">!     else {</span>
<span class="line-modified">!         return _uloc_addLikelySubtags(</span>
<span class="line-modified">!                     localeBuffer,</span>
<span class="line-modified">!                     maximizedLocaleID,</span>
<span class="line-modified">!                     maximizedLocaleIDCapacity,</span>
<span class="line-modified">!                     err);</span>
      }
  }
  
<span class="line-modified">! U_CAPI int32_t U_EXPORT2</span>
<span class="line-modified">! uloc_minimizeSubtags(const char*    localeID,</span>
<span class="line-modified">!          char* minimizedLocaleID,</span>
<span class="line-modified">!          int32_t minimizedLocaleIDCapacity,</span>
<span class="line-removed">-          UErrorCode* err)</span>
<span class="line-removed">- {</span>
      char localeBuffer[ULOC_FULLNAME_CAPACITY];
  
<span class="line-modified">!     if (!do_canonicalize(</span>
<span class="line-modified">!         localeID,</span>
<span class="line-removed">-         localeBuffer,</span>
<span class="line-removed">-         sizeof(localeBuffer),</span>
<span class="line-removed">-         err)) {</span>
<span class="line-removed">-         return -1;</span>
      }
<span class="line-modified">!     else {</span>
<span class="line-modified">!         return _uloc_minimizeSubtags(</span>
<span class="line-modified">!                     localeBuffer,</span>
<span class="line-modified">!                     minimizedLocaleID,</span>
<span class="line-modified">!                     minimizedLocaleIDCapacity,</span>
<span class="line-modified">!                     err);</span>
      }
  }
  
  // Pairs of (language subtag, + or -) for finding out fast if common languages
  // are LTR (minus) or RTL (plus).
  static const char LANG_DIR_STRING[] =
          &quot;root-en-es-pt-zh-ja-ko-de-fr-it-ar+he+fa+ru-nl-pl-th-tr-&quot;;
  
<span class="line-modified">! // Implemented here because this calls uloc_addLikelySubtags().</span>
  U_CAPI UBool U_EXPORT2
  uloc_isRightToLeft(const char *locale) {
      UErrorCode errorCode = U_ZERO_ERROR;
      char script[8];
      int32_t scriptLength = uloc_getScript(locale, script, UPRV_LENGTHOF(script), &amp;errorCode);
<span class="line-new-header">--- 1163,95 ---</span>
          return TRUE;
      }
  }
  
  U_CAPI int32_t U_EXPORT2
<span class="line-modified">! uloc_addLikelySubtags(const char* localeID,</span>
<span class="line-modified">!                       char* maximizedLocaleID,</span>
<span class="line-modified">!                       int32_t maximizedLocaleIDCapacity,</span>
<span class="line-modified">!                       UErrorCode* status) {</span>
<span class="line-modified">!     if (U_FAILURE(*status)) {</span>
<span class="line-modified">!         return 0;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     icu::CheckedArrayByteSink sink(</span>
<span class="line-modified">!             maximizedLocaleID, maximizedLocaleIDCapacity);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     ulocimp_addLikelySubtags(localeID, sink, status);</span>
<span class="line-modified">!     int32_t reslen = sink.NumberOfBytesAppended();</span>
<span class="line-modified">! </span>
<span class="line-added">+     if (U_FAILURE(*status)) {</span>
<span class="line-added">+         return sink.Overflowed() ? reslen : -1;</span>
      }
<span class="line-modified">! </span>
<span class="line-modified">!     if (sink.Overflowed()) {</span>
<span class="line-modified">!         *status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         u_terminateChars(</span>
<span class="line-modified">!                 maximizedLocaleID, maximizedLocaleIDCapacity, reslen, status);</span>
      }
<span class="line-added">+ </span>
<span class="line-added">+     return reslen;</span>
  }
  
<span class="line-modified">! U_CAPI void U_EXPORT2</span>
<span class="line-modified">! ulocimp_addLikelySubtags(const char* localeID,</span>
<span class="line-modified">!                          icu::ByteSink&amp; sink,</span>
<span class="line-modified">!                          UErrorCode* status) {</span>
      char localeBuffer[ULOC_FULLNAME_CAPACITY];
  
<span class="line-modified">!     if (do_canonicalize(localeID, localeBuffer, sizeof localeBuffer, status)) {</span>
<span class="line-modified">!         _uloc_addLikelySubtags(localeBuffer, sink, status);</span>
      }
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! U_CAPI int32_t U_EXPORT2</span>
<span class="line-modified">! uloc_minimizeSubtags(const char* localeID,</span>
<span class="line-modified">!                      char* minimizedLocaleID,</span>
<span class="line-modified">!                      int32_t minimizedLocaleIDCapacity,</span>
<span class="line-added">+                      UErrorCode* status) {</span>
<span class="line-added">+     if (U_FAILURE(*status)) {</span>
<span class="line-added">+         return 0;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     icu::CheckedArrayByteSink sink(</span>
<span class="line-added">+             minimizedLocaleID, minimizedLocaleIDCapacity);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ulocimp_minimizeSubtags(localeID, sink, status);</span>
<span class="line-added">+     int32_t reslen = sink.NumberOfBytesAppended();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (U_FAILURE(*status)) {</span>
<span class="line-added">+         return sink.Overflowed() ? reslen : -1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (sink.Overflowed()) {</span>
<span class="line-added">+         *status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         u_terminateChars(</span>
<span class="line-added">+                 minimizedLocaleID, minimizedLocaleIDCapacity, reslen, status);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return reslen;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ U_CAPI void U_EXPORT2</span>
<span class="line-added">+ ulocimp_minimizeSubtags(const char* localeID,</span>
<span class="line-added">+                         icu::ByteSink&amp; sink,</span>
<span class="line-added">+                         UErrorCode* status) {</span>
<span class="line-added">+     char localeBuffer[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (do_canonicalize(localeID, localeBuffer, sizeof localeBuffer, status)) {</span>
<span class="line-added">+         _uloc_minimizeSubtags(localeBuffer, sink, status);</span>
      }
  }
  
  // Pairs of (language subtag, + or -) for finding out fast if common languages
  // are LTR (minus) or RTL (plus).
  static const char LANG_DIR_STRING[] =
          &quot;root-en-es-pt-zh-ja-ko-de-fr-it-ar+he+fa+ru-nl-pl-th-tr-&quot;;
  
<span class="line-modified">! // Implemented here because this calls ulocimp_addLikelySubtags().</span>
  U_CAPI UBool U_EXPORT2
  uloc_isRightToLeft(const char *locale) {
      UErrorCode errorCode = U_ZERO_ERROR;
      char script[8];
      int32_t scriptLength = uloc_getScript(locale, script, UPRV_LENGTHOF(script), &amp;errorCode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1295,30 ***</span>
          // Fastpath: We know the likely scripts and their writing direction
          // for some common languages.
          errorCode = U_ZERO_ERROR;
          char lang[8];
          int32_t langLength = uloc_getLanguage(locale, lang, UPRV_LENGTHOF(lang), &amp;errorCode);
<span class="line-modified">!         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING ||</span>
<span class="line-removed">-                 langLength == 0) {</span>
              return FALSE;
          }
<span class="line-modified">!         const char* langPtr = uprv_strstr(LANG_DIR_STRING, lang);</span>
<span class="line-modified">!         if (langPtr != NULL) {</span>
<span class="line-modified">!             switch (langPtr[langLength]) {</span>
<span class="line-modified">!             case &#39;-&#39;: return FALSE;</span>
<span class="line-modified">!             case &#39;+&#39;: return TRUE;</span>
<span class="line-modified">!             default: break;  // partial match of a longer code</span>
              }
          }
          // Otherwise, find the likely script.
          errorCode = U_ZERO_ERROR;
<span class="line-modified">!         char likely[ULOC_FULLNAME_CAPACITY];</span>
<span class="line-modified">!         (void)uloc_addLikelySubtags(locale, likely, UPRV_LENGTHOF(likely), &amp;errorCode);</span>
          if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING) {
              return FALSE;
          }
<span class="line-modified">!         scriptLength = uloc_getScript(likely, script, UPRV_LENGTHOF(script), &amp;errorCode);</span>
          if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING ||
                  scriptLength == 0) {
              return FALSE;
          }
      }
<span class="line-new-header">--- 1260,34 ---</span>
          // Fastpath: We know the likely scripts and their writing direction
          // for some common languages.
          errorCode = U_ZERO_ERROR;
          char lang[8];
          int32_t langLength = uloc_getLanguage(locale, lang, UPRV_LENGTHOF(lang), &amp;errorCode);
<span class="line-modified">!         if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING) {</span>
              return FALSE;
          }
<span class="line-modified">!         if (langLength &gt; 0) {</span>
<span class="line-modified">!             const char* langPtr = uprv_strstr(LANG_DIR_STRING, lang);</span>
<span class="line-modified">!             if (langPtr != NULL) {</span>
<span class="line-modified">!                 switch (langPtr[langLength]) {</span>
<span class="line-modified">!                 case &#39;-&#39;: return FALSE;</span>
<span class="line-modified">!                 case &#39;+&#39;: return TRUE;</span>
<span class="line-added">+                 default: break;  // partial match of a longer code</span>
<span class="line-added">+                 }</span>
              }
          }
          // Otherwise, find the likely script.
          errorCode = U_ZERO_ERROR;
<span class="line-modified">!         icu::CharString likely;</span>
<span class="line-modified">!         {</span>
<span class="line-added">+             icu::CharStringByteSink sink(&amp;likely);</span>
<span class="line-added">+             ulocimp_addLikelySubtags(locale, sink, &amp;errorCode);</span>
<span class="line-added">+         }</span>
          if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING) {
              return FALSE;
          }
<span class="line-modified">!         scriptLength = uloc_getScript(likely.data(), script, UPRV_LENGTHOF(script), &amp;errorCode);</span>
          if (U_FAILURE(errorCode) || errorCode == U_STRING_NOT_TERMINATED_WARNING ||
                  scriptLength == 0) {
              return FALSE;
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1365,15 ***</span>
          rgLen = uloc_getCountry(localeID, rgBuf, ULOC_RG_BUFLEN, status);
          if (U_FAILURE(*status)) {
              rgLen = 0;
          } else if (rgLen == 0 &amp;&amp; inferRegion) {
              // no unicode_region_subtag but inferRegion TRUE, try likely subtags
<span class="line-removed">-             char locBuf[ULOC_FULLNAME_CAPACITY];</span>
              rgStatus = U_ZERO_ERROR;
<span class="line-modified">!             (void)uloc_addLikelySubtags(localeID, locBuf, ULOC_FULLNAME_CAPACITY, &amp;rgStatus);</span>
              if (U_SUCCESS(rgStatus)) {
<span class="line-modified">!                 rgLen = uloc_getCountry(locBuf, rgBuf, ULOC_RG_BUFLEN, status);</span>
                  if (U_FAILURE(*status)) {
                      rgLen = 0;
                  }
              }
          }
<span class="line-new-header">--- 1334,18 ---</span>
          rgLen = uloc_getCountry(localeID, rgBuf, ULOC_RG_BUFLEN, status);
          if (U_FAILURE(*status)) {
              rgLen = 0;
          } else if (rgLen == 0 &amp;&amp; inferRegion) {
              // no unicode_region_subtag but inferRegion TRUE, try likely subtags
              rgStatus = U_ZERO_ERROR;
<span class="line-modified">!             icu::CharString locBuf;</span>
<span class="line-added">+             {</span>
<span class="line-added">+                 icu::CharStringByteSink sink(&amp;locBuf);</span>
<span class="line-added">+                 ulocimp_addLikelySubtags(localeID, sink, &amp;rgStatus);</span>
<span class="line-added">+             }</span>
              if (U_SUCCESS(rgStatus)) {
<span class="line-modified">!                 rgLen = uloc_getCountry(locBuf.data(), rgBuf, ULOC_RG_BUFLEN, status);</span>
                  if (U_FAILURE(*status)) {
                      rgLen = 0;
                  }
              }
          }
</pre>
<center><a href="locid.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="locmap.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>