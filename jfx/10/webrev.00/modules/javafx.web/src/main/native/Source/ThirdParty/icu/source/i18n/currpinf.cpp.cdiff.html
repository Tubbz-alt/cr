<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/currpinf.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="currfmt.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="currunit.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/currpinf.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 15,11 ***</span>
  
  #ifdef CURRENCY_PLURAL_INFO_DEBUG
  #include &lt;iostream&gt;
  #endif
  
<span class="line-removed">- </span>
  #include &quot;unicode/locid.h&quot;
  #include &quot;unicode/plurrule.h&quot;
  #include &quot;unicode/strenum.h&quot;
  #include &quot;unicode/ures.h&quot;
  #include &quot;unicode/numsys.h&quot;
<span class="line-new-header">--- 15,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,11 ***</span>
  #include &quot;uresimp.h&quot;
  #include &quot;ureslocs.h&quot;
  
  U_NAMESPACE_BEGIN
  
<span class="line-removed">- </span>
  static const UChar gNumberPatternSeparator = 0x3B; // ;
  
  U_CDECL_BEGIN
  
  /**
<span class="line-new-header">--- 27,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,70 ***</span>
  static const char gPatternsTag[]=&quot;patterns&quot;;
  static const char gDecimalFormatTag[]=&quot;decimalFormat&quot;;
  static const char gCurrUnitPtnTag[]=&quot;CurrencyUnitPatterns&quot;;
  
  CurrencyPluralInfo::CurrencyPluralInfo(UErrorCode&amp; status)
<span class="line-modified">! :   fPluralCountToCurrencyUnitPattern(NULL),</span>
<span class="line-modified">!     fPluralRules(NULL),</span>
<span class="line-modified">!     fLocale(NULL) {</span>
      initialize(Locale::getDefault(), status);
  }
  
  CurrencyPluralInfo::CurrencyPluralInfo(const Locale&amp; locale, UErrorCode&amp; status)
<span class="line-modified">! :   fPluralCountToCurrencyUnitPattern(NULL),</span>
<span class="line-modified">!     fPluralRules(NULL),</span>
<span class="line-modified">!     fLocale(NULL) {</span>
      initialize(locale, status);
  }
  
  CurrencyPluralInfo::CurrencyPluralInfo(const CurrencyPluralInfo&amp; info)
  :   UObject(info),
<span class="line-modified">!     fPluralCountToCurrencyUnitPattern(NULL),</span>
<span class="line-modified">!     fPluralRules(NULL),</span>
<span class="line-modified">!     fLocale(NULL) {</span>
      *this = info;
  }
  
<span class="line-removed">- </span>
  CurrencyPluralInfo&amp;
  CurrencyPluralInfo::operator=(const CurrencyPluralInfo&amp; info) {
      if (this == &amp;info) {
          return *this;
      }
  
      deleteHash(fPluralCountToCurrencyUnitPattern);
<span class="line-modified">!     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-removed">-     fPluralCountToCurrencyUnitPattern = initHash(status);</span>
      copyHash(info.fPluralCountToCurrencyUnitPattern,
<span class="line-modified">!              fPluralCountToCurrencyUnitPattern, status);</span>
<span class="line-modified">!     if ( U_FAILURE(status) ) {</span>
          return *this;
      }
  
      delete fPluralRules;
      delete fLocale;
<span class="line-modified">!     if (info.fPluralRules) {</span>
          fPluralRules = info.fPluralRules-&gt;clone();
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         fPluralRules = NULL;</span>
      }
<span class="line-modified">!     if (info.fLocale) {</span>
          fLocale = info.fLocale-&gt;clone();
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         fLocale = NULL;</span>
      }
      return *this;
  }
  
<span class="line-removed">- </span>
  CurrencyPluralInfo::~CurrencyPluralInfo() {
      deleteHash(fPluralCountToCurrencyUnitPattern);
<span class="line-modified">!     fPluralCountToCurrencyUnitPattern = NULL;</span>
      delete fPluralRules;
      delete fLocale;
<span class="line-modified">!     fPluralRules = NULL;</span>
<span class="line-modified">!     fLocale = NULL;</span>
  }
  
  UBool
  CurrencyPluralInfo::operator==(const CurrencyPluralInfo&amp; info) const {
  #ifdef CURRENCY_PLURAL_INFO_DEBUG
<span class="line-new-header">--- 61,90 ---</span>
  static const char gPatternsTag[]=&quot;patterns&quot;;
  static const char gDecimalFormatTag[]=&quot;decimalFormat&quot;;
  static const char gCurrUnitPtnTag[]=&quot;CurrencyUnitPatterns&quot;;
  
  CurrencyPluralInfo::CurrencyPluralInfo(UErrorCode&amp; status)
<span class="line-modified">! :   fPluralCountToCurrencyUnitPattern(nullptr),</span>
<span class="line-modified">!     fPluralRules(nullptr),</span>
<span class="line-modified">!     fLocale(nullptr),</span>
<span class="line-added">+     fInternalStatus(U_ZERO_ERROR) {</span>
      initialize(Locale::getDefault(), status);
  }
  
  CurrencyPluralInfo::CurrencyPluralInfo(const Locale&amp; locale, UErrorCode&amp; status)
<span class="line-modified">! :   fPluralCountToCurrencyUnitPattern(nullptr),</span>
<span class="line-modified">!     fPluralRules(nullptr),</span>
<span class="line-modified">!     fLocale(nullptr),</span>
<span class="line-added">+     fInternalStatus(U_ZERO_ERROR) {</span>
      initialize(locale, status);
  }
  
  CurrencyPluralInfo::CurrencyPluralInfo(const CurrencyPluralInfo&amp; info)
  :   UObject(info),
<span class="line-modified">!     fPluralCountToCurrencyUnitPattern(nullptr),</span>
<span class="line-modified">!     fPluralRules(nullptr),</span>
<span class="line-modified">!     fLocale(nullptr),</span>
<span class="line-added">+     fInternalStatus(U_ZERO_ERROR) {</span>
      *this = info;
  }
  
  CurrencyPluralInfo&amp;
  CurrencyPluralInfo::operator=(const CurrencyPluralInfo&amp; info) {
      if (this == &amp;info) {
          return *this;
      }
  
<span class="line-added">+     fInternalStatus = info.fInternalStatus;</span>
<span class="line-added">+     if (U_FAILURE(fInternalStatus)) {</span>
<span class="line-added">+         // bail out early if the object we were copying from was already &#39;invalid&#39;.</span>
<span class="line-added">+         return *this;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      deleteHash(fPluralCountToCurrencyUnitPattern);
<span class="line-modified">!     fPluralCountToCurrencyUnitPattern = initHash(fInternalStatus);</span>
      copyHash(info.fPluralCountToCurrencyUnitPattern,
<span class="line-modified">!              fPluralCountToCurrencyUnitPattern, fInternalStatus);</span>
<span class="line-modified">!     if ( U_FAILURE(fInternalStatus) ) {</span>
          return *this;
      }
  
      delete fPluralRules;
<span class="line-added">+     fPluralRules = nullptr;</span>
      delete fLocale;
<span class="line-modified">!     fLocale = nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (info.fPluralRules != nullptr) {</span>
          fPluralRules = info.fPluralRules-&gt;clone();
<span class="line-modified">!         if (fPluralRules == nullptr) {</span>
<span class="line-modified">!             fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+             return *this;</span>
<span class="line-added">+         }</span>
      }
<span class="line-modified">!     if (info.fLocale != nullptr) {</span>
          fLocale = info.fLocale-&gt;clone();
<span class="line-modified">!         if (fLocale == nullptr) {</span>
<span class="line-modified">!             // Note: If clone had an error parameter, then we could check/set that instead.</span>
<span class="line-added">+             fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+             return *this;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // If the other locale wasn&#39;t bogus, but our clone&#39;d locale is bogus, then OOM happened</span>
<span class="line-added">+         // during the call to clone().</span>
<span class="line-added">+         if (!info.fLocale-&gt;isBogus() &amp;&amp; fLocale-&gt;isBogus()) {</span>
<span class="line-added">+             fInternalStatus = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+             return *this;</span>
<span class="line-added">+         }</span>
      }
      return *this;
  }
  
  CurrencyPluralInfo::~CurrencyPluralInfo() {
      deleteHash(fPluralCountToCurrencyUnitPattern);
<span class="line-modified">!     fPluralCountToCurrencyUnitPattern = nullptr;</span>
      delete fPluralRules;
      delete fLocale;
<span class="line-modified">!     fPluralRules = nullptr;</span>
<span class="line-modified">!     fLocale = nullptr;</span>
  }
  
  UBool
  CurrencyPluralInfo::operator==(const CurrencyPluralInfo&amp; info) const {
  #ifdef CURRENCY_PLURAL_INFO_DEBUG
</pre>
<hr />
<pre>
<span class="line-old-header">*** 146,11 ***</span>
  }
  
  
  CurrencyPluralInfo*
  CurrencyPluralInfo::clone() const {
<span class="line-modified">!     return new CurrencyPluralInfo(*this);</span>
  }
  
  const PluralRules*
  CurrencyPluralInfo::getPluralRules() const {
      return fPluralRules;
<span class="line-new-header">--- 164,18 ---</span>
  }
  
  
  CurrencyPluralInfo*
  CurrencyPluralInfo::clone() const {
<span class="line-modified">!     CurrencyPluralInfo* newObj = new CurrencyPluralInfo(*this);</span>
<span class="line-added">+     // Since clone doesn&#39;t have a &#39;status&#39; parameter, the best we can do is return nullptr</span>
<span class="line-added">+     // if the new object was not full constructed properly (an error occurred).</span>
<span class="line-added">+     if (newObj != nullptr &amp;&amp; U_FAILURE(newObj-&gt;fInternalStatus)) {</span>
<span class="line-added">+         delete newObj;</span>
<span class="line-added">+         newObj = nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return newObj;</span>
  }
  
  const PluralRules*
  CurrencyPluralInfo::getPluralRules() const {
      return fPluralRules;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 159,19 ***</span>
  UnicodeString&amp;
  CurrencyPluralInfo::getCurrencyPluralPattern(const UnicodeString&amp;  pluralCount,
                                               UnicodeString&amp; result) const {
      const UnicodeString* currencyPluralPattern =
          (UnicodeString*)fPluralCountToCurrencyUnitPattern-&gt;get(pluralCount);
<span class="line-modified">!     if (currencyPluralPattern == NULL) {</span>
          // fall back to &quot;other&quot;
          if (pluralCount.compare(gPluralCountOther, 5)) {
              currencyPluralPattern =
                  (UnicodeString*)fPluralCountToCurrencyUnitPattern-&gt;get(UnicodeString(TRUE, gPluralCountOther, 5));
          }
<span class="line-modified">!         if (currencyPluralPattern == NULL) {</span>
              // no currencyUnitPatterns defined,
<span class="line-modified">!             // fallback to predefined defult.</span>
              // This should never happen when ICU resource files are
              // available, since currencyUnitPattern of &quot;other&quot; is always
              // defined in root.
              result = UnicodeString(gDefaultCurrencyPluralPattern);
              return result;
<span class="line-new-header">--- 184,19 ---</span>
  UnicodeString&amp;
  CurrencyPluralInfo::getCurrencyPluralPattern(const UnicodeString&amp;  pluralCount,
                                               UnicodeString&amp; result) const {
      const UnicodeString* currencyPluralPattern =
          (UnicodeString*)fPluralCountToCurrencyUnitPattern-&gt;get(pluralCount);
<span class="line-modified">!     if (currencyPluralPattern == nullptr) {</span>
          // fall back to &quot;other&quot;
          if (pluralCount.compare(gPluralCountOther, 5)) {
              currencyPluralPattern =
                  (UnicodeString*)fPluralCountToCurrencyUnitPattern-&gt;get(UnicodeString(TRUE, gPluralCountOther, 5));
          }
<span class="line-modified">!         if (currencyPluralPattern == nullptr) {</span>
              // no currencyUnitPatterns defined,
<span class="line-modified">!             // fallback to predefined default.</span>
              // This should never happen when ICU resource files are
              // available, since currencyUnitPattern of &quot;other&quot; is always
              // defined in root.
              result = UnicodeString(gDefaultCurrencyPluralPattern);
              return result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 188,83 ***</span>
  
  void
  CurrencyPluralInfo::setPluralRules(const UnicodeString&amp; ruleDescription,
                                     UErrorCode&amp; status) {
      if (U_SUCCESS(status)) {
<span class="line-modified">!         if (fPluralRules) {</span>
<span class="line-removed">-             delete fPluralRules;</span>
<span class="line-removed">-         }</span>
          fPluralRules = PluralRules::createRules(ruleDescription, status);
      }
  }
  
<span class="line-removed">- </span>
  void
  CurrencyPluralInfo::setCurrencyPluralPattern(const UnicodeString&amp; pluralCount,
                                               const UnicodeString&amp; pattern,
                                               UErrorCode&amp; status) {
      if (U_SUCCESS(status)) {
          UnicodeString* oldValue = static_cast&lt;UnicodeString*&gt;(
              fPluralCountToCurrencyUnitPattern-&gt;get(pluralCount));
          delete oldValue;
<span class="line-modified">!         fPluralCountToCurrencyUnitPattern-&gt;put(pluralCount, new UnicodeString(pattern), status);</span>
      }
  }
  
<span class="line-removed">- </span>
  void
  CurrencyPluralInfo::setLocale(const Locale&amp; loc, UErrorCode&amp; status) {
      initialize(loc, status);
  }
  
<span class="line-removed">- </span>
  void
  CurrencyPluralInfo::initialize(const Locale&amp; loc, UErrorCode&amp; status) {
      if (U_FAILURE(status)) {
          return;
      }
      delete fLocale;
      fLocale = loc.clone();
<span class="line-modified">!     if (fPluralRules) {</span>
<span class="line-modified">!         delete fPluralRules;</span>
      }
      fPluralRules = PluralRules::forLocale(loc, status);
      setupCurrencyPluralPattern(loc, status);
  }
  
<span class="line-removed">- </span>
  void
  CurrencyPluralInfo::setupCurrencyPluralPattern(const Locale&amp; loc, UErrorCode&amp; status) {
      if (U_FAILURE(status)) {
          return;
      }
  
<span class="line-modified">!     if (fPluralCountToCurrencyUnitPattern) {</span>
<span class="line-removed">-         deleteHash(fPluralCountToCurrencyUnitPattern);</span>
<span class="line-removed">-     }</span>
      fPluralCountToCurrencyUnitPattern = initHash(status);
      if (U_FAILURE(status)) {
          return;
      }
  
<span class="line-modified">!     NumberingSystem *ns = NumberingSystem::createInstance(loc,status);</span>
      UErrorCode ec = U_ZERO_ERROR;
<span class="line-modified">!     UResourceBundle *rb = ures_open(NULL, loc.getName(), &amp;ec);</span>
<span class="line-modified">!     UResourceBundle *numElements = ures_getByKeyWithFallback(rb, gNumberElementsTag, NULL, &amp;ec);</span>
<span class="line-modified">!     rb = ures_getByKeyWithFallback(numElements, ns-&gt;getName(), rb, &amp;ec);</span>
<span class="line-modified">!     rb = ures_getByKeyWithFallback(rb, gPatternsTag, rb, &amp;ec);</span>
      int32_t ptnLen;
<span class="line-modified">!     const UChar* numberStylePattern = ures_getStringByKeyWithFallback(rb, gDecimalFormatTag, &amp;ptnLen, &amp;ec);</span>
      // Fall back to &quot;latn&quot; if num sys specific pattern isn&#39;t there.
<span class="line-modified">!     if ( ec == U_MISSING_RESOURCE_ERROR &amp;&amp; uprv_strcmp(ns-&gt;getName(),gLatnTag)) {</span>
          ec = U_ZERO_ERROR;
<span class="line-modified">!         rb = ures_getByKeyWithFallback(numElements, gLatnTag, rb, &amp;ec);</span>
<span class="line-modified">!         rb = ures_getByKeyWithFallback(rb, gPatternsTag, rb, &amp;ec);</span>
<span class="line-modified">!         numberStylePattern = ures_getStringByKeyWithFallback(rb, gDecimalFormatTag, &amp;ptnLen, &amp;ec);</span>
      }
      int32_t numberStylePatternLen = ptnLen;
<span class="line-modified">!     const UChar* negNumberStylePattern = NULL;</span>
      int32_t negNumberStylePatternLen = 0;
      // TODO: Java
      // parse to check whether there is &quot;;&quot; separator in the numberStylePattern
      UBool hasSeparator = false;
      if (U_SUCCESS(ec)) {
<span class="line-new-header">--- 213,94 ---</span>
  
  void
  CurrencyPluralInfo::setPluralRules(const UnicodeString&amp; ruleDescription,
                                     UErrorCode&amp; status) {
      if (U_SUCCESS(status)) {
<span class="line-modified">!         delete fPluralRules;</span>
          fPluralRules = PluralRules::createRules(ruleDescription, status);
      }
  }
  
  void
  CurrencyPluralInfo::setCurrencyPluralPattern(const UnicodeString&amp; pluralCount,
                                               const UnicodeString&amp; pattern,
                                               UErrorCode&amp; status) {
      if (U_SUCCESS(status)) {
          UnicodeString* oldValue = static_cast&lt;UnicodeString*&gt;(
              fPluralCountToCurrencyUnitPattern-&gt;get(pluralCount));
          delete oldValue;
<span class="line-modified">!         LocalPointer&lt;UnicodeString&gt; p(new UnicodeString(pattern), status);</span>
<span class="line-added">+         if (U_SUCCESS(status)) {</span>
<span class="line-added">+             // the p object allocated above will be owned by fPluralCountToCurrencyUnitPattern</span>
<span class="line-added">+             // after the call to put(), even if the method returns failure.</span>
<span class="line-added">+             fPluralCountToCurrencyUnitPattern-&gt;put(pluralCount, p.orphan(), status);</span>
<span class="line-added">+         }</span>
      }
  }
  
  void
  CurrencyPluralInfo::setLocale(const Locale&amp; loc, UErrorCode&amp; status) {
      initialize(loc, status);
  }
  
  void
  CurrencyPluralInfo::initialize(const Locale&amp; loc, UErrorCode&amp; status) {
      if (U_FAILURE(status)) {
          return;
      }
      delete fLocale;
<span class="line-added">+     fLocale = nullptr;</span>
<span class="line-added">+     delete fPluralRules;</span>
<span class="line-added">+     fPluralRules = nullptr;</span>
<span class="line-added">+ </span>
      fLocale = loc.clone();
<span class="line-modified">!     if (fLocale == nullptr) {</span>
<span class="line-modified">!         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // If the locale passed in wasn&#39;t bogus, but our clone&#39;d locale is bogus, then OOM happened</span>
<span class="line-added">+     // during the call to loc.clone().</span>
<span class="line-added">+     if (!loc.isBogus() &amp;&amp; fLocale-&gt;isBogus()) {</span>
<span class="line-added">+         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+         return;</span>
      }
      fPluralRules = PluralRules::forLocale(loc, status);
      setupCurrencyPluralPattern(loc, status);
  }
  
  void
  CurrencyPluralInfo::setupCurrencyPluralPattern(const Locale&amp; loc, UErrorCode&amp; status) {
      if (U_FAILURE(status)) {
          return;
      }
  
<span class="line-modified">!     deleteHash(fPluralCountToCurrencyUnitPattern);</span>
      fPluralCountToCurrencyUnitPattern = initHash(status);
      if (U_FAILURE(status)) {
          return;
      }
  
<span class="line-modified">!     LocalPointer&lt;NumberingSystem&gt; ns(NumberingSystem::createInstance(loc, status), status);</span>
<span class="line-added">+     if (U_FAILURE(status)) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      UErrorCode ec = U_ZERO_ERROR;
<span class="line-modified">!     LocalUResourceBundlePointer rb(ures_open(nullptr, loc.getName(), &amp;ec));</span>
<span class="line-modified">!     LocalUResourceBundlePointer numElements(ures_getByKeyWithFallback(rb.getAlias(), gNumberElementsTag, nullptr, &amp;ec));</span>
<span class="line-modified">!     ures_getByKeyWithFallback(numElements.getAlias(), ns-&gt;getName(), rb.getAlias(), &amp;ec);</span>
<span class="line-modified">!     ures_getByKeyWithFallback(rb.getAlias(), gPatternsTag, rb.getAlias(), &amp;ec);</span>
      int32_t ptnLen;
<span class="line-modified">!     const UChar* numberStylePattern = ures_getStringByKeyWithFallback(rb.getAlias(), gDecimalFormatTag, &amp;ptnLen, &amp;ec);</span>
      // Fall back to &quot;latn&quot; if num sys specific pattern isn&#39;t there.
<span class="line-modified">!     if ( ec == U_MISSING_RESOURCE_ERROR &amp;&amp; (uprv_strcmp(ns-&gt;getName(), gLatnTag) != 0)) {</span>
          ec = U_ZERO_ERROR;
<span class="line-modified">!         ures_getByKeyWithFallback(numElements.getAlias(), gLatnTag, rb.getAlias(), &amp;ec);</span>
<span class="line-modified">!         ures_getByKeyWithFallback(rb.getAlias(), gPatternsTag, rb.getAlias(), &amp;ec);</span>
<span class="line-modified">!         numberStylePattern = ures_getStringByKeyWithFallback(rb.getAlias(), gDecimalFormatTag, &amp;ptnLen, &amp;ec);</span>
      }
      int32_t numberStylePatternLen = ptnLen;
<span class="line-modified">!     const UChar* negNumberStylePattern = nullptr;</span>
      int32_t negNumberStylePatternLen = 0;
      // TODO: Java
      // parse to check whether there is &quot;;&quot; separator in the numberStylePattern
      UBool hasSeparator = false;
      if (U_SUCCESS(ec)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 277,129 ***</span>
                  numberStylePatternLen = styleCharIndex;
              }
          }
      }
  
<span class="line-removed">-     ures_close(numElements);</span>
<span class="line-removed">-     ures_close(rb);</span>
<span class="line-removed">-     delete ns;</span>
<span class="line-removed">- </span>
      if (U_FAILURE(ec)) {
          return;
      }
  
<span class="line-modified">!     UResourceBundle *currRb = ures_open(U_ICUDATA_CURR, loc.getName(), &amp;ec);</span>
<span class="line-modified">!     UResourceBundle *currencyRes = ures_getByKeyWithFallback(currRb, gCurrUnitPtnTag, NULL, &amp;ec);</span>
  
  #ifdef CURRENCY_PLURAL_INFO_DEBUG
      std::cout &lt;&lt; &quot;in set up\n&quot;;
  #endif
<span class="line-modified">!     StringEnumeration* keywords = fPluralRules-&gt;getKeywords(ec);</span>
      if (U_SUCCESS(ec)) {
          const char* pluralCount;
<span class="line-modified">!         while ((pluralCount = keywords-&gt;next(NULL, ec)) != NULL) {</span>
<span class="line-modified">!             if ( U_SUCCESS(ec) ) {</span>
<span class="line-modified">!                 int32_t ptnLen;</span>
<span class="line-modified">!                 UErrorCode err = U_ZERO_ERROR;</span>
<span class="line-modified">!                 const UChar* patternChars = ures_getStringByKeyWithFallback(</span>
<span class="line-modified">!                     currencyRes, pluralCount, &amp;ptnLen, &amp;err);</span>
<span class="line-modified">!                 if (U_SUCCESS(err) &amp;&amp; ptnLen &gt; 0) {</span>
<span class="line-modified">!                     UnicodeString* pattern = new UnicodeString(patternChars, ptnLen);</span>
  #ifdef CURRENCY_PLURAL_INFO_DEBUG
<span class="line-modified">!                     char result_1[1000];</span>
<span class="line-modified">!                     pattern-&gt;extract(0, pattern-&gt;length(), result_1, &quot;UTF-8&quot;);</span>
<span class="line-modified">!                     std::cout &lt;&lt; &quot;pluralCount: &quot; &lt;&lt; pluralCount &lt;&lt; &quot;; pattern: &quot; &lt;&lt; result_1 &lt;&lt; &quot;\n&quot;;</span>
  #endif
<span class="line-modified">!                     pattern-&gt;findAndReplace(UnicodeString(TRUE, gPart0, 3),</span>
<span class="line-modified">!                       UnicodeString(numberStylePattern, numberStylePatternLen));</span>
<span class="line-modified">!                     pattern-&gt;findAndReplace(UnicodeString(TRUE, gPart1, 3), UnicodeString(TRUE, gTripleCurrencySign, 3));</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     if (hasSeparator) {</span>
<span class="line-modified">!                         UnicodeString negPattern(patternChars, ptnLen);</span>
<span class="line-modified">!                         negPattern.findAndReplace(UnicodeString(TRUE, gPart0, 3),</span>
<span class="line-modified">!                           UnicodeString(negNumberStylePattern, negNumberStylePatternLen));</span>
<span class="line-modified">!                         negPattern.findAndReplace(UnicodeString(TRUE, gPart1, 3), UnicodeString(TRUE, gTripleCurrencySign, 3));</span>
<span class="line-modified">!                         pattern-&gt;append(gNumberPatternSeparator);</span>
<span class="line-modified">!                         pattern-&gt;append(negPattern);</span>
<span class="line-modified">!                     }</span>
  #ifdef CURRENCY_PLURAL_INFO_DEBUG
<span class="line-modified">!                     pattern-&gt;extract(0, pattern-&gt;length(), result_1, &quot;UTF-8&quot;);</span>
<span class="line-modified">!                     std::cout &lt;&lt; &quot;pluralCount: &quot; &lt;&lt; pluralCount &lt;&lt; &quot;; pattern: &quot; &lt;&lt; result_1 &lt;&lt; &quot;\n&quot;;</span>
  #endif
<span class="line-modified">! </span>
<span class="line-modified">!                     fPluralCountToCurrencyUnitPattern-&gt;put(UnicodeString(pluralCount, -1, US_INV), pattern, status);</span>
<span class="line-modified">!                 }</span>
              }
          }
      }
<span class="line-modified">!     delete keywords;</span>
<span class="line-modified">!     ures_close(currencyRes);</span>
<span class="line-modified">!     ures_close(currRb);</span>
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  void
<span class="line-modified">! CurrencyPluralInfo::deleteHash(Hashtable* hTable)</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     if ( hTable == NULL ) {</span>
          return;
      }
      int32_t pos = UHASH_FIRST;
<span class="line-modified">!     const UHashElement* element = NULL;</span>
<span class="line-modified">!     while ( (element = hTable-&gt;nextElement(pos)) != NULL ) {</span>
          const UHashTok valueTok = element-&gt;value;
          const UnicodeString* value = (UnicodeString*)valueTok.pointer;
          delete value;
      }
      delete hTable;
<span class="line-modified">!     hTable = NULL;</span>
  }
  
<span class="line-removed">- </span>
  Hashtable*
  CurrencyPluralInfo::initHash(UErrorCode&amp; status) {
<span class="line-modified">!     if ( U_FAILURE(status) ) {</span>
<span class="line-modified">!         return NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     Hashtable* hTable;</span>
<span class="line-removed">-     if ( (hTable = new Hashtable(TRUE, status)) == NULL ) {</span>
<span class="line-removed">-         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">-         return NULL;</span>
      }
<span class="line-modified">!     if ( U_FAILURE(status) ) {</span>
<span class="line-modified">!         delete hTable;</span>
<span class="line-modified">!         return NULL;</span>
      }
      hTable-&gt;setValueComparator(ValueComparator);
<span class="line-modified">!     return hTable;</span>
  }
  
<span class="line-removed">- </span>
  void
  CurrencyPluralInfo::copyHash(const Hashtable* source,
                             Hashtable* target,
                             UErrorCode&amp; status) {
<span class="line-modified">!     if ( U_FAILURE(status) ) {</span>
          return;
      }
      int32_t pos = UHASH_FIRST;
<span class="line-modified">!     const UHashElement* element = NULL;</span>
<span class="line-modified">!     if ( source ) {</span>
<span class="line-modified">!         while ( (element = source-&gt;nextElement(pos)) != NULL ) {</span>
              const UHashTok keyTok = element-&gt;key;
              const UnicodeString* key = (UnicodeString*)keyTok.pointer;
              const UHashTok valueTok = element-&gt;value;
              const UnicodeString* value = (UnicodeString*)valueTok.pointer;
<span class="line-modified">!             UnicodeString* copy = new UnicodeString(*value);</span>
<span class="line-modified">!             target-&gt;put(UnicodeString(*key), copy, status);</span>
<span class="line-modified">!             if ( U_FAILURE(status) ) {</span>
                  return;
              }
          }
      }
  }
<span class="line-removed">- </span>
  U_NAMESPACE_END
  
  #endif
<span class="line-new-header">--- 313,129 ---</span>
                  numberStylePatternLen = styleCharIndex;
              }
          }
      }
  
      if (U_FAILURE(ec)) {
<span class="line-added">+         // If OOM occurred during the above code, then we want to report that back to the caller.</span>
<span class="line-added">+         if (ec == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added">+             status = ec;</span>
<span class="line-added">+         }</span>
          return;
      }
  
<span class="line-modified">!     LocalUResourceBundlePointer currRb(ures_open(U_ICUDATA_CURR, loc.getName(), &amp;ec));</span>
<span class="line-modified">!     LocalUResourceBundlePointer currencyRes(ures_getByKeyWithFallback(currRb.getAlias(), gCurrUnitPtnTag, nullptr, &amp;ec));</span>
  
  #ifdef CURRENCY_PLURAL_INFO_DEBUG
      std::cout &lt;&lt; &quot;in set up\n&quot;;
  #endif
<span class="line-modified">!     LocalPointer&lt;StringEnumeration&gt; keywords(fPluralRules-&gt;getKeywords(ec), ec);</span>
      if (U_SUCCESS(ec)) {
          const char* pluralCount;
<span class="line-modified">!         while (((pluralCount = keywords-&gt;next(nullptr, ec)) != nullptr) &amp;&amp; U_SUCCESS(ec)) {</span>
<span class="line-modified">!             int32_t ptnLength;</span>
<span class="line-modified">!             UErrorCode err = U_ZERO_ERROR;</span>
<span class="line-modified">!             const UChar* patternChars = ures_getStringByKeyWithFallback(currencyRes.getAlias(), pluralCount, &amp;ptnLength, &amp;err);</span>
<span class="line-modified">!             if (err == U_MEMORY_ALLOCATION_ERROR || patternChars == nullptr) {</span>
<span class="line-modified">!                 ec = err;</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             }</span>
<span class="line-added">+             if (U_SUCCESS(err) &amp;&amp; ptnLength &gt; 0) {</span>
<span class="line-added">+                 UnicodeString* pattern = new UnicodeString(patternChars, ptnLength);</span>
<span class="line-added">+                 if (pattern == nullptr) {</span>
<span class="line-added">+                     ec = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
  #ifdef CURRENCY_PLURAL_INFO_DEBUG
<span class="line-modified">!                 char result_1[1000];</span>
<span class="line-modified">!                 pattern-&gt;extract(0, pattern-&gt;length(), result_1, &quot;UTF-8&quot;);</span>
<span class="line-modified">!                 std::cout &lt;&lt; &quot;pluralCount: &quot; &lt;&lt; pluralCount &lt;&lt; &quot;; pattern: &quot; &lt;&lt; result_1 &lt;&lt; &quot;\n&quot;;</span>
  #endif
<span class="line-modified">!                 pattern-&gt;findAndReplace(UnicodeString(TRUE, gPart0, 3),</span>
<span class="line-modified">!                     UnicodeString(numberStylePattern, numberStylePatternLen));</span>
<span class="line-modified">!                 pattern-&gt;findAndReplace(UnicodeString(TRUE, gPart1, 3), UnicodeString(TRUE, gTripleCurrencySign, 3));</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 if (hasSeparator) {</span>
<span class="line-modified">!                     UnicodeString negPattern(patternChars, ptnLength);</span>
<span class="line-modified">!                     negPattern.findAndReplace(UnicodeString(TRUE, gPart0, 3),</span>
<span class="line-modified">!                         UnicodeString(negNumberStylePattern, negNumberStylePatternLen));</span>
<span class="line-modified">!                     negPattern.findAndReplace(UnicodeString(TRUE, gPart1, 3), UnicodeString(TRUE, gTripleCurrencySign, 3));</span>
<span class="line-modified">!                     pattern-&gt;append(gNumberPatternSeparator);</span>
<span class="line-modified">!                     pattern-&gt;append(negPattern);</span>
<span class="line-modified">!                 }</span>
  #ifdef CURRENCY_PLURAL_INFO_DEBUG
<span class="line-modified">!                 pattern-&gt;extract(0, pattern-&gt;length(), result_1, &quot;UTF-8&quot;);</span>
<span class="line-modified">!                 std::cout &lt;&lt; &quot;pluralCount: &quot; &lt;&lt; pluralCount &lt;&lt; &quot;; pattern: &quot; &lt;&lt; result_1 &lt;&lt; &quot;\n&quot;;</span>
  #endif
<span class="line-modified">!                 // the &#39;pattern&#39; object allocated above will be owned by the fPluralCountToCurrencyUnitPattern after the call to</span>
<span class="line-modified">!                 // put(), even if the method returns failure.</span>
<span class="line-modified">!                 fPluralCountToCurrencyUnitPattern-&gt;put(UnicodeString(pluralCount, -1, US_INV), pattern, status);</span>
              }
          }
      }
<span class="line-modified">!     // If OOM occurred during the above code, then we want to report that back to the caller.</span>
<span class="line-modified">!     if (ec == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-modified">!         status = ec;</span>
<span class="line-added">+     }</span>
  }
  
  void
<span class="line-modified">! CurrencyPluralInfo::deleteHash(Hashtable* hTable) {</span>
<span class="line-modified">!     if ( hTable == nullptr ) {</span>
          return;
      }
      int32_t pos = UHASH_FIRST;
<span class="line-modified">!     const UHashElement* element = nullptr;</span>
<span class="line-modified">!     while ( (element = hTable-&gt;nextElement(pos)) != nullptr ) {</span>
          const UHashTok valueTok = element-&gt;value;
          const UnicodeString* value = (UnicodeString*)valueTok.pointer;
          delete value;
      }
      delete hTable;
<span class="line-modified">!     hTable = nullptr;</span>
  }
  
  Hashtable*
  CurrencyPluralInfo::initHash(UErrorCode&amp; status) {
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
<span class="line-modified">!         return nullptr;</span>
      }
<span class="line-modified">!     LocalPointer&lt;Hashtable&gt; hTable(new Hashtable(TRUE, status), status);</span>
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
<span class="line-modified">!         return nullptr;</span>
      }
      hTable-&gt;setValueComparator(ValueComparator);
<span class="line-modified">!     return hTable.orphan();</span>
  }
  
  void
  CurrencyPluralInfo::copyHash(const Hashtable* source,
                             Hashtable* target,
                             UErrorCode&amp; status) {
<span class="line-modified">!     if (U_FAILURE(status)) {</span>
          return;
      }
      int32_t pos = UHASH_FIRST;
<span class="line-modified">!     const UHashElement* element = nullptr;</span>
<span class="line-modified">!     if (source) {</span>
<span class="line-modified">!         while ( (element = source-&gt;nextElement(pos)) != nullptr ) {</span>
              const UHashTok keyTok = element-&gt;key;
              const UnicodeString* key = (UnicodeString*)keyTok.pointer;
              const UHashTok valueTok = element-&gt;value;
              const UnicodeString* value = (UnicodeString*)valueTok.pointer;
<span class="line-modified">!             LocalPointer&lt;UnicodeString&gt; copy(new UnicodeString(*value), status);</span>
<span class="line-modified">!             if (U_FAILURE(status)) {</span>
<span class="line-modified">!                 return;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // The HashTable owns the &#39;copy&#39; object after the call to put().</span>
<span class="line-added">+             target-&gt;put(UnicodeString(*key), copy.orphan(), status);</span>
<span class="line-added">+             if (U_FAILURE(status)) {</span>
                  return;
              }
          }
      }
  }
  U_NAMESPACE_END
  
  #endif
</pre>
<center><a href="currfmt.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="currunit.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>