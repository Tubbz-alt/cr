diff a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uhash.cpp b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uhash.cpp
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uhash.cpp
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uhash.cpp
@@ -216,11 +216,11 @@
 
     if (U_FAILURE(*status)) return;
 
     U_ASSERT(primeIndex >= 0 && primeIndex < PRIMES_LENGTH);
 
-    hash->primeIndex = primeIndex;
+    hash->primeIndex = static_cast<int8_t>(primeIndex);
     hash->length = PRIMES[primeIndex];
 
     p = hash->elements = (UHashElement*)
         uprv_malloc(sizeof(UHashElement) * hash->length);
 
@@ -374,12 +374,11 @@
         /* We get to this point if the hashtable is full (no empty or
          * deleted slots), and we've failed to find a match.  THIS
          * WILL NEVER HAPPEN as long as uhash_put() makes sure that
          * count is always < length.
          */
-        U_ASSERT(FALSE);
-        return NULL; /* Never happens if uhash_put() behaves */
+        UPRV_UNREACHABLE;
     }
     return &(elements[theIndex]);
 }
 
 /**
@@ -858,17 +857,17 @@
 }
 
 U_CAPI int32_t U_EXPORT2
 uhash_hashChars(const UHashTok key) {
     const char *s = (const char *)key.pointer;
-    return s == NULL ? 0 : static_cast<int32_t>(ustr_hashCharsN(s, uprv_strlen(s)));
+    return s == NULL ? 0 : static_cast<int32_t>(ustr_hashCharsN(s, static_cast<int32_t>(uprv_strlen(s))));
 }
 
 U_CAPI int32_t U_EXPORT2
 uhash_hashIChars(const UHashTok key) {
     const char *s = (const char *)key.pointer;
-    return s == NULL ? 0 : ustr_hashICharsN(s, uprv_strlen(s));
+    return s == NULL ? 0 : ustr_hashICharsN(s, static_cast<int32_t>(uprv_strlen(s)));
 }
 
 U_CAPI UBool U_EXPORT2
 uhash_equals(const UHashtable* hash1, const UHashtable* hash2){
     int32_t count1, count2, pos, i;
