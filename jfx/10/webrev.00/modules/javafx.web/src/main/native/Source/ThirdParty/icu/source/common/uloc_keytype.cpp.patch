diff a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc_keytype.cpp b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc_keytype.cpp
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc_keytype.cpp
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc_keytype.cpp
@@ -4,12 +4,18 @@
 **********************************************************************
 *   Copyright (C) 2014-2016, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 **********************************************************************
 */
+#include <algorithm>
+
 #include "unicode/utypes.h"
+#include "unicode/unistr.h"
+#include "unicode/uobject.h"
 
+#include "charstr.h"
+#include "cmemory.h"
 #include "cstring.h"
 #include "uassert.h"
 #include "ucln_cmn.h"
 #include "uhash.h"
 #include "umutex.h"
@@ -17,33 +23,34 @@
 #include "uvector.h"
 #include "udataswp.h" /* for InvChar functions */
 
 static UHashtable* gLocExtKeyMap = NULL;
 static icu::UInitOnce gLocExtKeyMapInitOnce = U_INITONCE_INITIALIZER;
-static icu::UVector* gKeyTypeStringPool = NULL;
-static icu::UVector* gLocExtKeyDataEntries = NULL;
-static icu::UVector* gLocExtTypeEntries = NULL;
 
 // bit flags for special types
 typedef enum {
     SPECIALTYPE_NONE = 0,
     SPECIALTYPE_CODEPOINTS = 1,
     SPECIALTYPE_REORDER_CODE = 2,
     SPECIALTYPE_RG_KEY_VALUE = 4
 } SpecialType;
 
-typedef struct LocExtKeyData {
+struct LocExtKeyData : public icu::UMemory {
     const char*     legacyId;
     const char*     bcpId;
-    UHashtable*     typeMap;
+    icu::LocalUHashtablePointer typeMap;
     uint32_t        specialTypes;
-} LocExtKeyData;
+};
 
-typedef struct LocExtType {
+struct LocExtType : public icu::UMemory {
     const char*     legacyId;
     const char*     bcpId;
-} LocExtType;
+};
+
+static icu::MemoryPool<icu::CharString>* gKeyTypeStringPool = NULL;
+static icu::MemoryPool<LocExtKeyData>* gLocExtKeyDataEntries = NULL;
+static icu::MemoryPool<LocExtType>* gLocExtTypeEntries = NULL;
 
 U_CDECL_BEGIN
 
 static UBool U_CALLCONV
 uloc_key_type_cleanup(void) {
@@ -63,29 +70,10 @@
 
     gLocExtKeyMapInitOnce.reset();
     return TRUE;
 }
 
-static void U_CALLCONV
-uloc_deleteKeyTypeStringPoolEntry(void* obj) {
-    uprv_free(obj);
-}
-
-static void U_CALLCONV
-uloc_deleteKeyDataEntry(void* obj) {
-    LocExtKeyData* keyData = (LocExtKeyData*)obj;
-    if (keyData->typeMap != NULL) {
-        uhash_close(keyData->typeMap);
-    }
-    uprv_free(keyData);
-}
-
-static void U_CALLCONV
-uloc_deleteTypeEntry(void* obj) {
-    uprv_free(obj);
-}
-
 U_CDECL_END
 
 
 static void U_CALLCONV
 initFromResourceBundle(UErrorCode& sts) {
@@ -105,36 +93,24 @@
     UErrorCode tmpSts = U_ZERO_ERROR;
     LocalUResourceBundlePointer typeAliasRes(ures_getByKey(keyTypeDataRes.getAlias(), "typeAlias", NULL, &tmpSts));
     tmpSts = U_ZERO_ERROR;
     LocalUResourceBundlePointer bcpTypeAliasRes(ures_getByKey(keyTypeDataRes.getAlias(), "bcpTypeAlias", NULL, &tmpSts));
 
-    // initialize vectors storing dynamically allocated objects
-    gKeyTypeStringPool = new UVector(uloc_deleteKeyTypeStringPoolEntry, NULL, sts);
+    // initialize pools storing dynamically allocated objects
+    gKeyTypeStringPool = new icu::MemoryPool<icu::CharString>;
     if (gKeyTypeStringPool == NULL) {
-        if (U_SUCCESS(sts)) {
-            sts = U_MEMORY_ALLOCATION_ERROR;
-        }
-    }
-    if (U_FAILURE(sts)) {
+        sts = U_MEMORY_ALLOCATION_ERROR;
         return;
     }
-    gLocExtKeyDataEntries = new UVector(uloc_deleteKeyDataEntry, NULL, sts);
+    gLocExtKeyDataEntries = new icu::MemoryPool<LocExtKeyData>;
     if (gLocExtKeyDataEntries == NULL) {
-        if (U_SUCCESS(sts)) {
-            sts = U_MEMORY_ALLOCATION_ERROR;
-        }
-    }
-    if (U_FAILURE(sts)) {
+        sts = U_MEMORY_ALLOCATION_ERROR;
         return;
     }
-    gLocExtTypeEntries = new UVector(uloc_deleteTypeEntry, NULL, sts);
+    gLocExtTypeEntries = new icu::MemoryPool<LocExtType>;
     if (gLocExtTypeEntries == NULL) {
-        if (U_SUCCESS(sts)) {
-            sts = U_MEMORY_ALLOCATION_ERROR;
-        }
-    }
-    if (U_FAILURE(sts)) {
+        sts = U_MEMORY_ALLOCATION_ERROR;
         return;
     }
 
     // iterate through keyMap resource
     LocalUResourceBundlePointer keyMapEntry;
@@ -143,31 +119,28 @@
         keyMapEntry.adoptInstead(ures_getNextResource(keyMapRes.getAlias(), keyMapEntry.orphan(), &sts));
         if (U_FAILURE(sts)) {
             break;
         }
         const char* legacyKeyId = ures_getKey(keyMapEntry.getAlias());
-        int32_t bcpKeyIdLen = 0;
-        const UChar* uBcpKeyId = ures_getString(keyMapEntry.getAlias(), &bcpKeyIdLen, &sts);
+        UnicodeString uBcpKeyId = ures_getUnicodeString(keyMapEntry.getAlias(), &sts);
         if (U_FAILURE(sts)) {
             break;
         }
 
         // empty value indicates that BCP key is same with the legacy key.
         const char* bcpKeyId = legacyKeyId;
-        if (bcpKeyIdLen > 0) {
-            char* bcpKeyIdBuf = (char*)uprv_malloc(bcpKeyIdLen + 1);
+        if (!uBcpKeyId.isEmpty()) {
+            icu::CharString* bcpKeyIdBuf = gKeyTypeStringPool->create();
             if (bcpKeyIdBuf == NULL) {
                 sts = U_MEMORY_ALLOCATION_ERROR;
                 break;
             }
-            u_UCharsToChars(uBcpKeyId, bcpKeyIdBuf, bcpKeyIdLen);
-            bcpKeyIdBuf[bcpKeyIdLen] = 0;
-            gKeyTypeStringPool->addElement(bcpKeyIdBuf, sts);
+            bcpKeyIdBuf->appendInvariantChars(uBcpKeyId, sts);
             if (U_FAILURE(sts)) {
                 break;
             }
-            bcpKeyId = bcpKeyIdBuf;
+            bcpKeyId = bcpKeyIdBuf->data();
         }
 
         UBool isTZ = uprv_strcmp(legacyKeyId, "timezone") == 0;
 
         UHashtable* typeDataMap = uhash_open(uhash_hashIChars, uhash_compareIChars, NULL, &sts);
@@ -197,11 +170,11 @@
         // look up type map for the key, and walk through the mapping data
         tmpSts = U_ZERO_ERROR;
         LocalUResourceBundlePointer typeMapResByKey(ures_getByKey(typeMapRes.getAlias(), legacyKeyId, NULL, &tmpSts));
         if (U_FAILURE(tmpSts)) {
             // type map for each key must exist
-            U_ASSERT(FALSE);
+            UPRV_UNREACHABLE;
         } else {
             LocalUResourceBundlePointer typeMapEntry;
 
             while (ures_hasNext(typeMapResByKey.getAlias())) {
                 typeMapEntry.adoptInstead(ures_getNextResource(typeMapResByKey.getAlias(), typeMapEntry.orphan(), &sts));
@@ -226,74 +199,58 @@
 
                 if (isTZ) {
                     // a timezone key uses a colon instead of a slash in the resource.
                     // e.g. America:Los_Angeles
                     if (uprv_strchr(legacyTypeId, ':') != NULL) {
-                        int32_t legacyTypeIdLen = uprv_strlen(legacyTypeId);
-                        char* legacyTypeIdBuf = (char*)uprv_malloc(legacyTypeIdLen + 1);
+                        icu::CharString* legacyTypeIdBuf =
+                                gKeyTypeStringPool->create(legacyTypeId, sts);
                         if (legacyTypeIdBuf == NULL) {
                             sts = U_MEMORY_ALLOCATION_ERROR;
                             break;
                         }
-                        const char* p = legacyTypeId;
-                        char* q = legacyTypeIdBuf;
-                        while (*p) {
-                            if (*p == ':') {
-                                *q++ = '/';
-                            } else {
-                                *q++ = *p;
-                            }
-                            p++;
-                        }
-                        *q = 0;
-
-                        gKeyTypeStringPool->addElement(legacyTypeIdBuf, sts);
                         if (U_FAILURE(sts)) {
                             break;
                         }
-                        legacyTypeId = legacyTypeIdBuf;
+                        std::replace(
+                                legacyTypeIdBuf->data(),
+                                legacyTypeIdBuf->data() + legacyTypeIdBuf->length(),
+                                ':', '/');
+                        legacyTypeId = legacyTypeIdBuf->data();
                     }
                 }
 
-                int32_t bcpTypeIdLen = 0;
-                const UChar* uBcpTypeId = ures_getString(typeMapEntry.getAlias(), &bcpTypeIdLen, &sts);
+                UnicodeString uBcpTypeId = ures_getUnicodeString(typeMapEntry.getAlias(), &sts);
                 if (U_FAILURE(sts)) {
                     break;
                 }
 
                 // empty value indicates that BCP type is same with the legacy type.
                 const char* bcpTypeId = legacyTypeId;
-                if (bcpTypeIdLen > 0) {
-                    char* bcpTypeIdBuf = (char*)uprv_malloc(bcpTypeIdLen + 1);
+                if (!uBcpTypeId.isEmpty()) {
+                    icu::CharString* bcpTypeIdBuf = gKeyTypeStringPool->create();
                     if (bcpTypeIdBuf == NULL) {
                         sts = U_MEMORY_ALLOCATION_ERROR;
                         break;
                     }
-                    u_UCharsToChars(uBcpTypeId, bcpTypeIdBuf, bcpTypeIdLen);
-                    bcpTypeIdBuf[bcpTypeIdLen] = 0;
-                    gKeyTypeStringPool->addElement(bcpTypeIdBuf, sts);
+                    bcpTypeIdBuf->appendInvariantChars(uBcpTypeId, sts);
                     if (U_FAILURE(sts)) {
                         break;
                     }
-                    bcpTypeId = bcpTypeIdBuf;
+                    bcpTypeId = bcpTypeIdBuf->data();
                 }
 
                 // Note: legacy type value should never be
                 // equivalent to bcp type value of a different
                 // type under the same key. So we use a single
                 // map for lookup.
-                LocExtType* t = (LocExtType*)uprv_malloc(sizeof(LocExtType));
+                LocExtType* t = gLocExtTypeEntries->create();
                 if (t == NULL) {
                     sts = U_MEMORY_ALLOCATION_ERROR;
                     break;
                 }
                 t->bcpId = bcpTypeId;
-                gLocExtTypeEntries->addElement((void*)t, sts);
-                if (U_FAILURE(sts)) {
-                    break;
-                }
 
                 uhash_put(typeDataMap, (void*)legacyTypeId, t, &sts);
                 if (bcpTypeId != legacyTypeId) {
                     // different type value
                     uhash_put(typeDataMap, (void*)bcpTypeId, t, &sts);
@@ -318,33 +275,24 @@
                         if (uprv_compareInvWithUChar(NULL, legacyTypeId, -1, to, toLen) == 0) {
                             const char* from = ures_getKey(typeAliasDataEntry.getAlias());
                             if (isTZ) {
                                 // replace colon with slash if necessary
                                 if (uprv_strchr(from, ':') != NULL) {
-                                    int32_t fromLen = uprv_strlen(from);
-                                    char* fromBuf = (char*)uprv_malloc(fromLen + 1);
+                                    icu::CharString* fromBuf =
+                                            gKeyTypeStringPool->create(from, sts);
                                     if (fromBuf == NULL) {
                                         sts = U_MEMORY_ALLOCATION_ERROR;
                                         break;
                                     }
-                                    const char* p = from;
-                                    char* q = fromBuf;
-                                    while (*p) {
-                                        if (*p == ':') {
-                                            *q++ = '/';
-                                        } else {
-                                            *q++ = *p;
-                                        }
-                                        p++;
-                                    }
-                                    *q = 0;
-
-                                    gKeyTypeStringPool->addElement(fromBuf, sts);
                                     if (U_FAILURE(sts)) {
                                         break;
                                     }
-                                    from = fromBuf;
+                                    std::replace(
+                                            fromBuf->data(),
+                                            fromBuf->data() + fromBuf->length(),
+                                            ':', '/');
+                                    from = fromBuf->data();
                                 }
                             }
                             uhash_put(typeDataMap, (void*)from, t, &sts);
                         }
                     }
@@ -378,24 +326,19 @@
         }
         if (U_FAILURE(sts)) {
             break;
         }
 
-        LocExtKeyData* keyData = (LocExtKeyData*)uprv_malloc(sizeof(LocExtKeyData));
+        LocExtKeyData* keyData = gLocExtKeyDataEntries->create();
         if (keyData == NULL) {
             sts = U_MEMORY_ALLOCATION_ERROR;
             break;
         }
         keyData->bcpId = bcpKeyId;
         keyData->legacyId = legacyKeyId;
         keyData->specialTypes = specialTypes;
-        keyData->typeMap = typeDataMap;
-
-        gLocExtKeyDataEntries->addElement((void*)keyData, sts);
-        if (U_FAILURE(sts)) {
-            break;
-        }
+        keyData->typeMap.adoptInstead(typeDataMap);
 
         uhash_put(gLocExtKeyMap, (void*)legacyKeyId, keyData, &sts);
         if (legacyKeyId != bcpKeyId) {
             // different key value
             uhash_put(gLocExtKeyMap, (void*)bcpKeyId, keyData, &sts);
@@ -470,11 +413,10 @@
             return FALSE;
         }
         p++;
     }
     return (subtagLen == 6);
-    return TRUE;
 }
 
 U_CFUNC const char*
 ulocimp_toBcpKey(const char* key) {
     if (!init()) {
@@ -517,11 +459,11 @@
     LocExtKeyData* keyData = (LocExtKeyData*)uhash_get(gLocExtKeyMap, key);
     if (keyData != NULL) {
         if (isKnownKey != NULL) {
             *isKnownKey = TRUE;
         }
-        LocExtType* t = (LocExtType*)uhash_get(keyData->typeMap, type);
+        LocExtType* t = (LocExtType*)uhash_get(keyData->typeMap.getAlias(), type);
         if (t != NULL) {
             return t->bcpId;
         }
         if (keyData->specialTypes != SPECIALTYPE_NONE) {
             UBool matched = FALSE;
@@ -562,11 +504,11 @@
     LocExtKeyData* keyData = (LocExtKeyData*)uhash_get(gLocExtKeyMap, key);
     if (keyData != NULL) {
         if (isKnownKey != NULL) {
             *isKnownKey = TRUE;
         }
-        LocExtType* t = (LocExtType*)uhash_get(keyData->typeMap, type);
+        LocExtType* t = (LocExtType*)uhash_get(keyData->typeMap.getAlias(), type);
         if (t != NULL) {
             return t->legacyId;
         }
         if (keyData->specialTypes != SPECIALTYPE_NONE) {
             UBool matched = FALSE;
