<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtitvfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="dtfmtsym.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="dtitvinf.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtitvfmt.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11 */
  12 
  13 #include &quot;utypeinfo.h&quot;  // for &#39;typeid&#39; to work
  14 
  15 #include &quot;unicode/dtitvfmt.h&quot;
  16 
  17 #if !UCONFIG_NO_FORMATTING
  18 
  19 //TODO: put in compilation
  20 //#define DTITVFMT_DEBUG 1
  21 
  22 #include &quot;unicode/calendar.h&quot;
  23 #include &quot;unicode/dtptngen.h&quot;
  24 #include &quot;unicode/dtitvinf.h&quot;
  25 #include &quot;unicode/simpleformatter.h&quot;
  26 #include &quot;cmemory.h&quot;
  27 #include &quot;cstring.h&quot;
  28 #include &quot;dtitv_impl.h&quot;
  29 #include &quot;mutex.h&quot;
  30 #include &quot;uresimp.h&quot;

  31 
  32 #ifdef DTITVFMT_DEBUG
  33 #include &lt;iostream&gt;
  34 #endif
  35 
  36 U_NAMESPACE_BEGIN
  37 
  38 
  39 
  40 #ifdef DTITVFMT_DEBUG
  41 #define PRINTMESG(msg) { std::cout &lt;&lt; &quot;(&quot; &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;) &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;; }
  42 #endif
  43 
  44 
  45 static const UChar gDateFormatSkeleton[][11] = {
  46 //yMMMMEEEEd
  47 {LOW_Y, CAP_M, CAP_M, CAP_M, CAP_M, CAP_E, CAP_E, CAP_E, CAP_E, LOW_D, 0},
  48 //yMMMMd
  49 {LOW_Y, CAP_M, CAP_M, CAP_M, CAP_M, LOW_D, 0},
  50 //yMMMd
  51 {LOW_Y, CAP_M, CAP_M, CAP_M, LOW_D, 0},
  52 //yMd
  53 {LOW_Y, CAP_M, LOW_D, 0} };
  54 
  55 
  56 static const char gCalendarTag[] = &quot;calendar&quot;;
  57 static const char gGregorianTag[] = &quot;gregorian&quot;;
  58 static const char gDateTimePatternsTag[] = &quot;DateTimePatterns&quot;;
  59 
  60 
  61 // latestFirst:
  62 static const UChar gLaterFirstPrefix[] = {LOW_L, LOW_A, LOW_T, LOW_E, LOW_S,LOW_T, CAP_F, LOW_I, LOW_R, LOW_S, LOW_T, COLON};
  63 
  64 // earliestFirst:
  65 static const UChar gEarlierFirstPrefix[] = {LOW_E, LOW_A, LOW_R, LOW_L, LOW_I, LOW_E, LOW_S, LOW_T, CAP_F, LOW_I, LOW_R, LOW_S, LOW_T, COLON};
  66 
  67 











  68 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DateIntervalFormat)
  69 
  70 // Mutex, protects access to fDateFormat, fFromCalendar and fToCalendar.
  71 //        Needed because these data members are modified by const methods of DateIntervalFormat.
  72 
<span class="line-modified">  73 static UMutex gFormatterMutex = U_MUTEX_INITIALIZER;</span>



  74 
  75 DateIntervalFormat* U_EXPORT2
  76 DateIntervalFormat::createInstance(const UnicodeString&amp; skeleton,
  77                                    UErrorCode&amp; status) {
  78     return createInstance(skeleton, Locale::getDefault(), status);
  79 }
  80 
  81 
  82 DateIntervalFormat* U_EXPORT2
  83 DateIntervalFormat::createInstance(const UnicodeString&amp; skeleton,
  84                                    const Locale&amp; locale,
  85                                    UErrorCode&amp; status) {
  86 #ifdef DTITVFMT_DEBUG
  87     char result[1000];
  88     char result_1[1000];
  89     char mesg[2000];
  90     skeleton.extract(0,  skeleton.length(), result, &quot;UTF-8&quot;);
  91     UnicodeString pat;
  92     ((SimpleDateFormat*)dtfmt)-&gt;toPattern(pat);
  93     pat.extract(0,  pat.length(), result_1, &quot;UTF-8&quot;);
</pre>
<hr />
<pre>
 139     fToCalendar(NULL),
 140     fLocale(itvfmt.fLocale),
 141     fDatePattern(NULL),
 142     fTimePattern(NULL),
 143     fDateTimeFormat(NULL) {
 144     *this = itvfmt;
 145 }
 146 
 147 
 148 DateIntervalFormat&amp;
 149 DateIntervalFormat::operator=(const DateIntervalFormat&amp; itvfmt) {
 150     if ( this != &amp;itvfmt ) {
 151         delete fDateFormat;
 152         delete fInfo;
 153         delete fFromCalendar;
 154         delete fToCalendar;
 155         delete fDatePattern;
 156         delete fTimePattern;
 157         delete fDateTimeFormat;
 158         {
<span class="line-modified"> 159             Mutex lock(&amp;gFormatterMutex);</span>
 160             if ( itvfmt.fDateFormat ) {
 161                 fDateFormat = (SimpleDateFormat*)itvfmt.fDateFormat-&gt;clone();
 162             } else {
 163                 fDateFormat = NULL;
 164             }
 165             if ( itvfmt.fFromCalendar ) {
 166                 fFromCalendar = itvfmt.fFromCalendar-&gt;clone();
 167             } else {
 168                 fFromCalendar = NULL;
 169             }
 170             if ( itvfmt.fToCalendar ) {
 171                 fToCalendar = itvfmt.fToCalendar-&gt;clone();
 172             } else {
 173                 fToCalendar = NULL;
 174             }
 175         }
 176         if ( itvfmt.fInfo ) {
 177             fInfo = itvfmt.fInfo-&gt;clone();
 178         } else {
 179             fInfo = NULL;
</pre>
<hr />
<pre>
 201     delete fTimePattern;
 202     delete fDateTimeFormat;
 203 }
 204 
 205 
 206 Format*
 207 DateIntervalFormat::clone(void) const {
 208     return new DateIntervalFormat(*this);
 209 }
 210 
 211 
 212 UBool
 213 DateIntervalFormat::operator==(const Format&amp; other) const {
 214     if (typeid(*this) != typeid(other)) {return FALSE;}
 215     const DateIntervalFormat* fmt = (DateIntervalFormat*)&amp;other;
 216     if (this == fmt) {return TRUE;}
 217     if (!Format::operator==(other)) {return FALSE;}
 218     if ((fInfo != fmt-&gt;fInfo) &amp;&amp; (fInfo == NULL || fmt-&gt;fInfo == NULL)) {return FALSE;}
 219     if (fInfo &amp;&amp; fmt-&gt;fInfo &amp;&amp; (*fInfo != *fmt-&gt;fInfo )) {return FALSE;}
 220     {
<span class="line-modified"> 221         Mutex lock(&amp;gFormatterMutex);</span>
 222         if (fDateFormat != fmt-&gt;fDateFormat &amp;&amp; (fDateFormat == NULL || fmt-&gt;fDateFormat == NULL)) {return FALSE;}
 223         if (fDateFormat &amp;&amp; fmt-&gt;fDateFormat &amp;&amp; (*fDateFormat != *fmt-&gt;fDateFormat)) {return FALSE;}
 224     }
 225     // note: fFromCalendar and fToCalendar hold no persistent state, and therefore do not participate in operator ==.
 226     //       fDateFormat has the master calendar for the DateIntervalFormat.
 227     if (fSkeleton != fmt-&gt;fSkeleton) {return FALSE;}
 228     if (fDatePattern != fmt-&gt;fDatePattern &amp;&amp; (fDatePattern == NULL || fmt-&gt;fDatePattern == NULL)) {return FALSE;}
 229     if (fDatePattern &amp;&amp; fmt-&gt;fDatePattern &amp;&amp; (*fDatePattern != *fmt-&gt;fDatePattern)) {return FALSE;}
 230     if (fTimePattern != fmt-&gt;fTimePattern &amp;&amp; (fTimePattern == NULL || fmt-&gt;fTimePattern == NULL)) {return FALSE;}
 231     if (fTimePattern &amp;&amp; fmt-&gt;fTimePattern &amp;&amp; (*fTimePattern != *fmt-&gt;fTimePattern)) {return FALSE;}
 232     if (fDateTimeFormat != fmt-&gt;fDateTimeFormat &amp;&amp; (fDateTimeFormat == NULL || fmt-&gt;fDateTimeFormat == NULL)) {return FALSE;}
 233     if (fDateTimeFormat &amp;&amp; fmt-&gt;fDateTimeFormat &amp;&amp; (*fDateTimeFormat != *fmt-&gt;fDateTimeFormat)) {return FALSE;}
 234     if (fLocale != fmt-&gt;fLocale) {return FALSE;}
 235 
 236     for (int32_t i = 0; i&lt; DateIntervalInfo::kIPI_MAX_INDEX; ++i ) {
 237         if (fIntervalPatterns[i].firstPart != fmt-&gt;fIntervalPatterns[i].firstPart) {return FALSE;}
 238         if (fIntervalPatterns[i].secondPart != fmt-&gt;fIntervalPatterns[i].secondPart ) {return FALSE;}
 239         if (fIntervalPatterns[i].laterDateFirst != fmt-&gt;fIntervalPatterns[i].laterDateFirst) {return FALSE;}
 240     }
 241     return TRUE;
</pre>
<hr />
<pre>
 254     if ( obj.getType() == Formattable::kObject ) {
 255         const UObject* formatObj = obj.getObject();
 256         const DateInterval* interval = dynamic_cast&lt;const DateInterval*&gt;(formatObj);
 257         if (interval != NULL) {
 258             return format(interval, appendTo, fieldPosition, status);
 259         }
 260     }
 261     status = U_ILLEGAL_ARGUMENT_ERROR;
 262     return appendTo;
 263 }
 264 
 265 
 266 UnicodeString&amp;
 267 DateIntervalFormat::format(const DateInterval* dtInterval,
 268                            UnicodeString&amp; appendTo,
 269                            FieldPosition&amp; fieldPosition,
 270                            UErrorCode&amp; status) const {
 271     if ( U_FAILURE(status) ) {
 272         return appendTo;
 273     }
<span class="line-modified"> 274     if (fFromCalendar == NULL || fToCalendar == NULL || fDateFormat == NULL || fInfo == NULL) {</span>
 275         status = U_INVALID_STATE_ERROR;
 276         return appendTo;
 277     }
 278 
<span class="line-modified"> 279     Mutex lock(&amp;gFormatterMutex);</span>
<span class="line-modified"> 280     fFromCalendar-&gt;setTime(dtInterval-&gt;getFromDate(), status);</span>
<span class="line-modified"> 281     fToCalendar-&gt;setTime(dtInterval-&gt;getToDate(), status);</span>
<span class="line-modified"> 282     return formatImpl(*fFromCalendar, *fToCalendar, appendTo,fieldPosition, status);</span>




































 283 }
 284 
 285 
 286 UnicodeString&amp;
 287 DateIntervalFormat::format(Calendar&amp; fromCalendar,
 288                            Calendar&amp; toCalendar,
 289                            UnicodeString&amp; appendTo,
 290                            FieldPosition&amp; pos,
 291                            UErrorCode&amp; status) const {
<span class="line-modified"> 292     Mutex lock(&amp;gFormatterMutex);</span>
<span class="line-modified"> 293     return formatImpl(fromCalendar, toCalendar, appendTo, pos, status);</span>























































 294 }
 295 
 296 
 297 UnicodeString&amp;
 298 DateIntervalFormat::formatImpl(Calendar&amp; fromCalendar,
 299                            Calendar&amp; toCalendar,
 300                            UnicodeString&amp; appendTo,
<span class="line-modified"> 301                            FieldPosition&amp; pos,</span>

 302                            UErrorCode&amp; status) const {
 303     if ( U_FAILURE(status) ) {
 304         return appendTo;
 305     }
 306 



 307     // not support different calendar types and time zones
 308     //if ( fromCalendar.getType() != toCalendar.getType() ) {
 309     if ( !fromCalendar.isEquivalentTo(toCalendar) ) {
 310         status = U_ILLEGAL_ARGUMENT_ERROR;
 311         return appendTo;
 312     }
 313 
 314     // First, find the largest different calendar field.
 315     UCalendarDateFields field = UCAL_FIELD_COUNT;
 316 
 317     if ( fromCalendar.get(UCAL_ERA,status) != toCalendar.get(UCAL_ERA,status)) {
 318         field = UCAL_ERA;
 319     } else if ( fromCalendar.get(UCAL_YEAR, status) !=
 320                 toCalendar.get(UCAL_YEAR, status) ) {
 321         field = UCAL_YEAR;
 322     } else if ( fromCalendar.get(UCAL_MONTH, status) !=
 323                 toCalendar.get(UCAL_MONTH, status) ) {
 324         field = UCAL_MONTH;
 325     } else if ( fromCalendar.get(UCAL_DATE, status) !=
 326                 toCalendar.get(UCAL_DATE, status) ) {
</pre>
<hr />
<pre>
 329                 toCalendar.get(UCAL_AM_PM, status) ) {
 330         field = UCAL_AM_PM;
 331     } else if ( fromCalendar.get(UCAL_HOUR, status) !=
 332                 toCalendar.get(UCAL_HOUR, status) ) {
 333         field = UCAL_HOUR;
 334     } else if ( fromCalendar.get(UCAL_MINUTE, status) !=
 335                 toCalendar.get(UCAL_MINUTE, status) ) {
 336         field = UCAL_MINUTE;
 337     } else if ( fromCalendar.get(UCAL_SECOND, status) !=
 338                 toCalendar.get(UCAL_SECOND, status) ) {
 339         field = UCAL_SECOND;
 340     }
 341 
 342     if ( U_FAILURE(status) ) {
 343         return appendTo;
 344     }
 345     if ( field == UCAL_FIELD_COUNT ) {
 346         /* ignore the millisecond etc. small fields&#39; difference.
 347          * use single date when all the above are the same.
 348          */
<span class="line-modified"> 349         return fDateFormat-&gt;format(fromCalendar, appendTo, pos);</span>
 350     }
 351     UBool fromToOnSameDay = (field==UCAL_AM_PM || field==UCAL_HOUR || field==UCAL_MINUTE || field==UCAL_SECOND);
 352 
 353     // following call should not set wrong status,
 354     // all the pass-in fields are valid till here
 355     int32_t itvPtnIndex = DateIntervalInfo::calendarFieldToIntervalIndex(field,
 356                                                                         status);
 357     const PatternInfo&amp; intervalPattern = fIntervalPatterns[itvPtnIndex];
 358 
 359     if ( intervalPattern.firstPart.isEmpty() &amp;&amp;
 360          intervalPattern.secondPart.isEmpty() ) {
 361         if ( fDateFormat-&gt;isFieldUnitIgnored(field) ) {
 362             /* the largest different calendar field is small than
 363              * the smallest calendar field in pattern,
 364              * return single date format.
 365              */
<span class="line-modified"> 366             return fDateFormat-&gt;format(fromCalendar, appendTo, pos);</span>
 367         }
<span class="line-modified"> 368         return fallbackFormat(fromCalendar, toCalendar, fromToOnSameDay, appendTo, pos, status);</span>
 369     }
 370     // If the first part in interval pattern is empty,
 371     // the 2nd part of it saves the full-pattern used in fall-back.
 372     // For a &#39;real&#39; interval pattern, the first part will never be empty.
 373     if ( intervalPattern.firstPart.isEmpty() ) {
 374         // fall back
 375         UnicodeString originalPattern;
 376         fDateFormat-&gt;toPattern(originalPattern);
 377         fDateFormat-&gt;applyPattern(intervalPattern.secondPart);
<span class="line-modified"> 378         appendTo = fallbackFormat(fromCalendar, toCalendar, fromToOnSameDay, appendTo, pos, status);</span>
 379         fDateFormat-&gt;applyPattern(originalPattern);
 380         return appendTo;
 381     }
 382     Calendar* firstCal;
 383     Calendar* secondCal;
 384     if ( intervalPattern.laterDateFirst ) {
 385         firstCal = &amp;toCalendar;
 386         secondCal = &amp;fromCalendar;

 387     } else {
 388         firstCal = &amp;fromCalendar;
 389         secondCal = &amp;toCalendar;

 390     }
 391     // break the interval pattern into 2 parts,
 392     // first part should not be empty,
 393     UnicodeString originalPattern;
 394     fDateFormat-&gt;toPattern(originalPattern);
 395     fDateFormat-&gt;applyPattern(intervalPattern.firstPart);
<span class="line-modified"> 396     fDateFormat-&gt;format(*firstCal, appendTo, pos);</span>

 397     if ( !intervalPattern.secondPart.isEmpty() ) {
 398         fDateFormat-&gt;applyPattern(intervalPattern.secondPart);
<span class="line-modified"> 399         FieldPosition otherPos;</span>
<span class="line-removed"> 400         otherPos.setField(pos.getField());</span>
<span class="line-removed"> 401         fDateFormat-&gt;format(*secondCal, appendTo, otherPos);</span>
<span class="line-removed"> 402         if (pos.getEndIndex() == 0 &amp;&amp; otherPos.getEndIndex() &gt; 0) {</span>
<span class="line-removed"> 403             pos = otherPos;</span>
<span class="line-removed"> 404         }</span>
 405     }
 406     fDateFormat-&gt;applyPattern(originalPattern);
 407     return appendTo;
 408 }
 409 
 410 
 411 
 412 void
 413 DateIntervalFormat::parseObject(const UnicodeString&amp; /* source */,
 414                                 Formattable&amp; /* result */,
 415                                 ParsePosition&amp; /* parse_pos */) const {
 416     // parseObject(const UnicodeString&amp;, Formattable&amp;, UErrorCode&amp;) const
 417     // will set status as U_INVALID_FORMAT_ERROR if
 418     // parse_pos is still 0
 419 }
 420 
 421 
 422 
 423 
 424 const DateIntervalInfo*
</pre>
<hr />
<pre>
 475 void
 476 DateIntervalFormat::setTimeZone(const TimeZone&amp; zone)
 477 {
 478     if (fDateFormat != NULL) {
 479         fDateFormat-&gt;setTimeZone(zone);
 480     }
 481     // The fDateFormat has the master calendar for the DateIntervalFormat;
 482     // fFromCalendar and fToCalendar are internal work clones of that calendar.
 483     if (fFromCalendar) {
 484         fFromCalendar-&gt;setTimeZone(zone);
 485     }
 486     if (fToCalendar) {
 487         fToCalendar-&gt;setTimeZone(zone);
 488     }
 489 }
 490 
 491 const TimeZone&amp;
 492 DateIntervalFormat::getTimeZone() const
 493 {
 494     if (fDateFormat != NULL) {
<span class="line-modified"> 495         Mutex lock(&amp;gFormatterMutex);</span>
 496         return fDateFormat-&gt;getTimeZone();
 497     }
 498     // If fDateFormat is NULL (unexpected), create default timezone.
 499     return *(TimeZone::createDefault());
 500 }
 501 
 502 DateIntervalFormat::DateIntervalFormat(const Locale&amp; locale,
 503                                        DateIntervalInfo* dtItvInfo,
 504                                        const UnicodeString* skeleton,
 505                                        UErrorCode&amp; status)
 506 :   fInfo(NULL),
 507     fDateFormat(NULL),
 508     fFromCalendar(NULL),
 509     fToCalendar(NULL),
 510     fLocale(locale),
 511     fDatePattern(NULL),
 512     fTimePattern(NULL),
 513     fDateTimeFormat(NULL)
 514 {
 515     LocalPointer&lt;DateIntervalInfo&gt; info(dtItvInfo, status);
</pre>
<hr />
<pre>
 860           case LOW_J:
 861           case LOW_S:
 862           case CAP_S:
 863           case CAP_A:
 864             timeSkeleton.append(ch);
 865             normalizedTimeSkeleton.append(ch);
 866             break;
 867         }
 868     }
 869 
 870     /* generate normalized form for date*/
 871     if ( yCount != 0 ) {
 872         for (i = 0; i &lt; yCount; ++i) {
 873             normalizedDateSkeleton.append(LOW_Y);
 874         }
 875     }
 876     if ( MCount != 0 ) {
 877         if ( MCount &lt; 3 ) {
 878             normalizedDateSkeleton.append(CAP_M);
 879         } else {
<span class="line-modified"> 880             int32_t i;</span>
<span class="line-removed"> 881             for ( i = 0; i &lt; MCount &amp;&amp; i &lt; MAX_M_COUNT; ++i ) {</span>
 882                  normalizedDateSkeleton.append(CAP_M);
 883             }
 884         }
 885     }
 886     if ( ECount != 0 ) {
 887         if ( ECount &lt;= 3 ) {
 888             normalizedDateSkeleton.append(CAP_E);
 889         } else {
<span class="line-modified"> 890             int32_t i;</span>
<span class="line-removed"> 891             for ( i = 0; i &lt; ECount &amp;&amp; i &lt; MAX_E_COUNT; ++i ) {</span>
 892                  normalizedDateSkeleton.append(CAP_E);
 893             }
 894         }
 895     }
 896     if ( dCount != 0 ) {
 897         normalizedDateSkeleton.append(LOW_D);
 898     }
 899 
 900     /* generate normalized form for time */
 901     if ( HCount != 0 ) {
 902         normalizedTimeSkeleton.append(CAP_H);
 903     }
 904     else if ( hCount != 0 ) {
 905         normalizedTimeSkeleton.append(LOW_H);
 906     }
 907     if ( mCount != 0 ) {
 908         normalizedTimeSkeleton.append(LOW_M);
 909     }
 910     if ( zCount != 0 ) {
 911         normalizedTimeSkeleton.append(LOW_Z);
</pre>
<hr />
<pre>
1007         return false;
1008     }
1009 
1010     if ( timeSkeleton.length() == 0 ) {
1011         UnicodeString extendedSkeleton;
1012         UnicodeString extendedBestSkeleton;
1013         // only has date skeleton
1014         setIntervalPattern(UCAL_DATE, skeleton, bestSkeleton, differenceInfo,
1015                            &amp;extendedSkeleton, &amp;extendedBestSkeleton);
1016 
1017         UBool extended = setIntervalPattern(UCAL_MONTH, skeleton, bestSkeleton,
1018                                      differenceInfo,
1019                                      &amp;extendedSkeleton, &amp;extendedBestSkeleton);
1020 
1021         if ( extended ) {
1022             bestSkeleton = &amp;extendedBestSkeleton;
1023             skeleton = &amp;extendedSkeleton;
1024         }
1025         setIntervalPattern(UCAL_YEAR, skeleton, bestSkeleton, differenceInfo,
1026                            &amp;extendedSkeleton, &amp;extendedBestSkeleton);
<span class="line-modified">1027     } else {</span>


1028         setIntervalPattern(UCAL_MINUTE, skeleton, bestSkeleton, differenceInfo);
1029         setIntervalPattern(UCAL_HOUR, skeleton, bestSkeleton, differenceInfo);
1030         setIntervalPattern(UCAL_AM_PM, skeleton, bestSkeleton, differenceInfo);
1031     }
1032     return true;
1033 }
1034 
1035 
1036 
1037 void
1038 DateIntervalFormat::setFallbackPattern(UCalendarDateFields field,
1039                                        const UnicodeString&amp; skeleton,
1040                                        UErrorCode&amp; status) {
1041     if ( U_FAILURE(status) ) {
1042         return;
1043     }
1044     UnicodeString pattern = DateFormat::getBestPattern(
1045             fLocale, skeleton, status);
1046     if ( U_FAILURE(status) ) {
1047         return;
</pre>
<hr />
<pre>
1279         }
1280         else if (!inQuote &amp;&amp; ((ch &gt;= 0x0061 /*&#39;a&#39;*/ &amp;&amp; ch &lt;= 0x007A /*&#39;z&#39;*/)
1281                     || (ch &gt;= 0x0041 /*&#39;A&#39;*/ &amp;&amp; ch &lt;= 0x005A /*&#39;Z&#39;*/))) {
1282             // ch is a date-time pattern character
1283             prevCh = ch;
1284             ++count;
1285         }
1286     }
1287     // check last pattern char, distinguish
1288     // &quot;dd MM&quot; ( no repetition ),
1289     // &quot;d-d&quot;(last char repeated ), and
1290     // &quot;d-d MM&quot; ( repetition found )
1291     if ( count &gt; 0 &amp;&amp; foundRepetition == FALSE ) {
1292         if ( patternRepeated[(int)(prevCh - PATTERN_CHAR_BASE)] == FALSE ) {
1293             count = 0;
1294         }
1295     }
1296     return (i - count);
1297 }
1298 
<span class="line-modified">1299 static const UChar bracketedZero[] = {0x7B,0x30,0x7D};</span>
<span class="line-modified">1300 static const UChar bracketedOne[]  = {0x7B,0x31,0x7D};</span>
<span class="line-modified">1301 </span>
<span class="line-modified">1302 void</span>
<span class="line-modified">1303 DateIntervalFormat::adjustPosition(UnicodeString&amp; combiningPattern, // has {0} and {1} in it</span>
<span class="line-modified">1304                                    UnicodeString&amp; pat0, FieldPosition&amp; pos0, // pattern and pos corresponding to {0}</span>
<span class="line-modified">1305                                    UnicodeString&amp; pat1, FieldPosition&amp; pos1, // pattern and pos corresponding to {1}</span>
<span class="line-modified">1306                                    FieldPosition&amp; posResult)  {</span>
<span class="line-modified">1307     int32_t index0 = combiningPattern.indexOf(bracketedZero, 3, 0);</span>
<span class="line-modified">1308     int32_t index1 = combiningPattern.indexOf(bracketedOne,  3, 0);</span>
<span class="line-modified">1309     if (index0 &lt; 0 || index1 &lt; 0) {</span>
1310         return;
1311     }
<span class="line-modified">1312     int32_t placeholderLen = 3; // length of &quot;{0}&quot; or &quot;{1}&quot;</span>
<span class="line-modified">1313     if (index0 &lt; index1) {</span>
<span class="line-modified">1314         if (pos0.getEndIndex() &gt; 0) {</span>
<span class="line-modified">1315             posResult.setBeginIndex(pos0.getBeginIndex() + index0);</span>
<span class="line-modified">1316             posResult.setEndIndex(pos0.getEndIndex() + index0);</span>
<span class="line-modified">1317         } else if (pos1.getEndIndex() &gt; 0) {</span>
<span class="line-modified">1318             // here index1 &gt;= 3</span>
<span class="line-modified">1319             index1 += pat0.length() - placeholderLen; // adjust for pat0 replacing {0}</span>
<span class="line-modified">1320             posResult.setBeginIndex(pos1.getBeginIndex() + index1);</span>
<span class="line-modified">1321             posResult.setEndIndex(pos1.getEndIndex() + index1);</span>
<span class="line-modified">1322         }</span>
1323     } else {
<span class="line-modified">1324         if (pos1.getEndIndex() &gt; 0) {</span>
<span class="line-modified">1325             posResult.setBeginIndex(pos1.getBeginIndex() + index1);</span>
<span class="line-modified">1326             posResult.setEndIndex(pos1.getEndIndex() + index1);</span>
<span class="line-modified">1327         } else if (pos0.getEndIndex() &gt; 0) {</span>
<span class="line-modified">1328             // here index0 &gt;= 3</span>
<span class="line-modified">1329             index0 += pat1.length() - placeholderLen; // adjust for pat1 replacing {1}</span>
<span class="line-removed">1330             posResult.setBeginIndex(pos0.getBeginIndex() + index0);</span>
<span class="line-removed">1331             posResult.setEndIndex(pos0.getEndIndex() + index0);</span>
<span class="line-removed">1332         }</span>
1333     }
1334 }
1335 
1336 UnicodeString&amp;
1337 DateIntervalFormat::fallbackFormat(Calendar&amp; fromCalendar,
1338                                    Calendar&amp; toCalendar,
1339                                    UBool fromToOnSameDay, // new
1340                                    UnicodeString&amp; appendTo,
<span class="line-modified">1341                                    FieldPosition&amp; pos,</span>

1342                                    UErrorCode&amp; status) const {
1343     if ( U_FAILURE(status) ) {
1344         return appendTo;
1345     }
<span class="line-modified">1346     UnicodeString fullPattern; // for saving the pattern in fDateFormat</span>
1347     UBool formatDatePlusTimeRange = (fromToOnSameDay &amp;&amp; fDatePattern &amp;&amp; fTimePattern);
<span class="line-removed">1348     // the fall back</span>
1349     if (formatDatePlusTimeRange) {








1350         fDateFormat-&gt;toPattern(fullPattern); // save current pattern, restore later
<span class="line-modified">1351         fDateFormat-&gt;applyPattern(*fTimePattern);</span>
<span class="line-modified">1352     }</span>
<span class="line-modified">1353     FieldPosition otherPos;</span>
<span class="line-modified">1354     otherPos.setField(pos.getField());</span>
<span class="line-modified">1355     UnicodeString earlierDate;</span>
<span class="line-modified">1356     fDateFormat-&gt;format(fromCalendar, earlierDate, pos);</span>
<span class="line-modified">1357     UnicodeString laterDate;</span>
<span class="line-modified">1358     fDateFormat-&gt;format(toCalendar, laterDate, otherPos);</span>
<span class="line-modified">1359     UnicodeString fallbackPattern;</span>
<span class="line-modified">1360     fInfo-&gt;getFallbackIntervalPattern(fallbackPattern);</span>
<span class="line-modified">1361     adjustPosition(fallbackPattern, earlierDate, pos, laterDate, otherPos, pos);</span>
<span class="line-modified">1362     UnicodeString fallbackRange;</span>
<span class="line-modified">1363     SimpleFormatter(fallbackPattern, 2, 2, status).</span>
<span class="line-modified">1364             format(earlierDate, laterDate, fallbackRange, status);</span>
<span class="line-modified">1365     if ( U_SUCCESS(status) &amp;&amp; formatDatePlusTimeRange ) {</span>
<span class="line-modified">1366         // fallbackRange has just the time range, need to format the date part and combine that</span>
<span class="line-modified">1367         fDateFormat-&gt;applyPattern(*fDatePattern);</span>
<span class="line-modified">1368         UnicodeString datePortion;</span>
<span class="line-modified">1369         otherPos.setBeginIndex(0);</span>
<span class="line-modified">1370         otherPos.setEndIndex(0);</span>
<span class="line-modified">1371         fDateFormat-&gt;format(fromCalendar, datePortion, otherPos);</span>
<span class="line-modified">1372         adjustPosition(*fDateTimeFormat, fallbackRange, pos, datePortion, otherPos, pos);</span>
<span class="line-removed">1373         const UnicodeString *values[2] = {</span>
<span class="line-removed">1374             &amp;fallbackRange,  // {0} is time range</span>
<span class="line-removed">1375             &amp;datePortion,  // {1} is single date portion</span>
<span class="line-removed">1376         };</span>
<span class="line-removed">1377         SimpleFormatter(*fDateTimeFormat, 2, 2, status).</span>
<span class="line-removed">1378                 formatAndReplace(values, 2, fallbackRange, NULL, 0, status);</span>
<span class="line-removed">1379     }</span>
<span class="line-removed">1380     if ( U_SUCCESS(status) ) {</span>
<span class="line-removed">1381         appendTo.append(fallbackRange);</span>
<span class="line-removed">1382     }</span>
<span class="line-removed">1383     if (formatDatePlusTimeRange) {</span>
1384         // restore full pattern
1385         fDateFormat-&gt;applyPattern(fullPattern);


1386     }
1387     return appendTo;
1388 }
1389 
1390 
1391 
1392 
1393 UBool  U_EXPORT2
1394 DateIntervalFormat::fieldExistsInSkeleton(UCalendarDateFields field,
1395                                           const UnicodeString&amp; skeleton)
1396 {
1397     const UChar fieldChar = fgCalendarFieldToPatternLetter[field];
1398     return ( (skeleton.indexOf(fieldChar) == -1)?FALSE:TRUE ) ;
1399 }
1400 
1401 
1402 
1403 void  U_EXPORT2
1404 DateIntervalFormat::adjustFieldWidth(const UnicodeString&amp; inputSkeleton,
1405                  const UnicodeString&amp; bestMatchSkeleton,
</pre>
<hr />
<pre>
1537     // else: fall back
1538     // it should not happen if the interval format defined is valid
1539 }
1540 
1541 
1542 
1543 const UChar
1544 DateIntervalFormat::fgCalendarFieldToPatternLetter[] =
1545 {
1546     /*GyM*/ CAP_G, LOW_Y, CAP_M,
1547     /*wWd*/ LOW_W, CAP_W, LOW_D,
1548     /*DEF*/ CAP_D, CAP_E, CAP_F,
1549     /*ahH*/ LOW_A, LOW_H, CAP_H,
1550     /*msS*/ LOW_M, LOW_S, CAP_S, // MINUTE, SECOND, MILLISECOND
1551     /*z.Y*/ LOW_Z, SPACE, CAP_Y, // ZONE_OFFSET, DST_OFFSET, YEAR_WOY,
1552     /*eug*/ LOW_E, LOW_U, LOW_G, // DOW_LOCAL, EXTENDED_YEAR, JULIAN_DAY,
1553     /*A..*/ CAP_A, SPACE, SPACE, // MILLISECONDS_IN_DAY, IS_LEAP_MONTH, FIELD_COUNT
1554 };
1555 
1556 

1557 U_NAMESPACE_END
1558 
1559 #endif
</pre>
</td>
<td>
<hr />
<pre>
  11 */
  12 
  13 #include &quot;utypeinfo.h&quot;  // for &#39;typeid&#39; to work
  14 
  15 #include &quot;unicode/dtitvfmt.h&quot;
  16 
  17 #if !UCONFIG_NO_FORMATTING
  18 
  19 //TODO: put in compilation
  20 //#define DTITVFMT_DEBUG 1
  21 
  22 #include &quot;unicode/calendar.h&quot;
  23 #include &quot;unicode/dtptngen.h&quot;
  24 #include &quot;unicode/dtitvinf.h&quot;
  25 #include &quot;unicode/simpleformatter.h&quot;
  26 #include &quot;cmemory.h&quot;
  27 #include &quot;cstring.h&quot;
  28 #include &quot;dtitv_impl.h&quot;
  29 #include &quot;mutex.h&quot;
  30 #include &quot;uresimp.h&quot;
<span class="line-added">  31 #include &quot;formattedval_impl.h&quot;</span>
  32 
  33 #ifdef DTITVFMT_DEBUG
  34 #include &lt;iostream&gt;
  35 #endif
  36 
  37 U_NAMESPACE_BEGIN
  38 
  39 
  40 
  41 #ifdef DTITVFMT_DEBUG
  42 #define PRINTMESG(msg) { std::cout &lt;&lt; &quot;(&quot; &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;) &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;; }
  43 #endif
  44 
  45 
  46 static const UChar gDateFormatSkeleton[][11] = {
  47 //yMMMMEEEEd
  48 {LOW_Y, CAP_M, CAP_M, CAP_M, CAP_M, CAP_E, CAP_E, CAP_E, CAP_E, LOW_D, 0},
  49 //yMMMMd
  50 {LOW_Y, CAP_M, CAP_M, CAP_M, CAP_M, LOW_D, 0},
  51 //yMMMd
  52 {LOW_Y, CAP_M, CAP_M, CAP_M, LOW_D, 0},
  53 //yMd
  54 {LOW_Y, CAP_M, LOW_D, 0} };
  55 
  56 
  57 static const char gCalendarTag[] = &quot;calendar&quot;;
  58 static const char gGregorianTag[] = &quot;gregorian&quot;;
  59 static const char gDateTimePatternsTag[] = &quot;DateTimePatterns&quot;;
  60 
  61 
  62 // latestFirst:
  63 static const UChar gLaterFirstPrefix[] = {LOW_L, LOW_A, LOW_T, LOW_E, LOW_S,LOW_T, CAP_F, LOW_I, LOW_R, LOW_S, LOW_T, COLON};
  64 
  65 // earliestFirst:
  66 static const UChar gEarlierFirstPrefix[] = {LOW_E, LOW_A, LOW_R, LOW_L, LOW_I, LOW_E, LOW_S, LOW_T, CAP_F, LOW_I, LOW_R, LOW_S, LOW_T, COLON};
  67 
  68 
<span class="line-added">  69 class FormattedDateIntervalData : public FormattedValueFieldPositionIteratorImpl {</span>
<span class="line-added">  70 public:</span>
<span class="line-added">  71     FormattedDateIntervalData(UErrorCode&amp; status) : FormattedValueFieldPositionIteratorImpl(5, status) {}</span>
<span class="line-added">  72     virtual ~FormattedDateIntervalData();</span>
<span class="line-added">  73 };</span>
<span class="line-added">  74 </span>
<span class="line-added">  75 FormattedDateIntervalData::~FormattedDateIntervalData() = default;</span>
<span class="line-added">  76 </span>
<span class="line-added">  77 UPRV_FORMATTED_VALUE_SUBCLASS_AUTO_IMPL(FormattedDateInterval)</span>
<span class="line-added">  78 </span>
<span class="line-added">  79 </span>
  80 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DateIntervalFormat)
  81 
  82 // Mutex, protects access to fDateFormat, fFromCalendar and fToCalendar.
  83 //        Needed because these data members are modified by const methods of DateIntervalFormat.
  84 
<span class="line-modified">  85 static UMutex *gFormatterMutex() {</span>
<span class="line-added">  86     static UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added">  87     return &amp;m;</span>
<span class="line-added">  88 }</span>
  89 
  90 DateIntervalFormat* U_EXPORT2
  91 DateIntervalFormat::createInstance(const UnicodeString&amp; skeleton,
  92                                    UErrorCode&amp; status) {
  93     return createInstance(skeleton, Locale::getDefault(), status);
  94 }
  95 
  96 
  97 DateIntervalFormat* U_EXPORT2
  98 DateIntervalFormat::createInstance(const UnicodeString&amp; skeleton,
  99                                    const Locale&amp; locale,
 100                                    UErrorCode&amp; status) {
 101 #ifdef DTITVFMT_DEBUG
 102     char result[1000];
 103     char result_1[1000];
 104     char mesg[2000];
 105     skeleton.extract(0,  skeleton.length(), result, &quot;UTF-8&quot;);
 106     UnicodeString pat;
 107     ((SimpleDateFormat*)dtfmt)-&gt;toPattern(pat);
 108     pat.extract(0,  pat.length(), result_1, &quot;UTF-8&quot;);
</pre>
<hr />
<pre>
 154     fToCalendar(NULL),
 155     fLocale(itvfmt.fLocale),
 156     fDatePattern(NULL),
 157     fTimePattern(NULL),
 158     fDateTimeFormat(NULL) {
 159     *this = itvfmt;
 160 }
 161 
 162 
 163 DateIntervalFormat&amp;
 164 DateIntervalFormat::operator=(const DateIntervalFormat&amp; itvfmt) {
 165     if ( this != &amp;itvfmt ) {
 166         delete fDateFormat;
 167         delete fInfo;
 168         delete fFromCalendar;
 169         delete fToCalendar;
 170         delete fDatePattern;
 171         delete fTimePattern;
 172         delete fDateTimeFormat;
 173         {
<span class="line-modified"> 174             Mutex lock(gFormatterMutex());</span>
 175             if ( itvfmt.fDateFormat ) {
 176                 fDateFormat = (SimpleDateFormat*)itvfmt.fDateFormat-&gt;clone();
 177             } else {
 178                 fDateFormat = NULL;
 179             }
 180             if ( itvfmt.fFromCalendar ) {
 181                 fFromCalendar = itvfmt.fFromCalendar-&gt;clone();
 182             } else {
 183                 fFromCalendar = NULL;
 184             }
 185             if ( itvfmt.fToCalendar ) {
 186                 fToCalendar = itvfmt.fToCalendar-&gt;clone();
 187             } else {
 188                 fToCalendar = NULL;
 189             }
 190         }
 191         if ( itvfmt.fInfo ) {
 192             fInfo = itvfmt.fInfo-&gt;clone();
 193         } else {
 194             fInfo = NULL;
</pre>
<hr />
<pre>
 216     delete fTimePattern;
 217     delete fDateTimeFormat;
 218 }
 219 
 220 
 221 Format*
 222 DateIntervalFormat::clone(void) const {
 223     return new DateIntervalFormat(*this);
 224 }
 225 
 226 
 227 UBool
 228 DateIntervalFormat::operator==(const Format&amp; other) const {
 229     if (typeid(*this) != typeid(other)) {return FALSE;}
 230     const DateIntervalFormat* fmt = (DateIntervalFormat*)&amp;other;
 231     if (this == fmt) {return TRUE;}
 232     if (!Format::operator==(other)) {return FALSE;}
 233     if ((fInfo != fmt-&gt;fInfo) &amp;&amp; (fInfo == NULL || fmt-&gt;fInfo == NULL)) {return FALSE;}
 234     if (fInfo &amp;&amp; fmt-&gt;fInfo &amp;&amp; (*fInfo != *fmt-&gt;fInfo )) {return FALSE;}
 235     {
<span class="line-modified"> 236         Mutex lock(gFormatterMutex());</span>
 237         if (fDateFormat != fmt-&gt;fDateFormat &amp;&amp; (fDateFormat == NULL || fmt-&gt;fDateFormat == NULL)) {return FALSE;}
 238         if (fDateFormat &amp;&amp; fmt-&gt;fDateFormat &amp;&amp; (*fDateFormat != *fmt-&gt;fDateFormat)) {return FALSE;}
 239     }
 240     // note: fFromCalendar and fToCalendar hold no persistent state, and therefore do not participate in operator ==.
 241     //       fDateFormat has the master calendar for the DateIntervalFormat.
 242     if (fSkeleton != fmt-&gt;fSkeleton) {return FALSE;}
 243     if (fDatePattern != fmt-&gt;fDatePattern &amp;&amp; (fDatePattern == NULL || fmt-&gt;fDatePattern == NULL)) {return FALSE;}
 244     if (fDatePattern &amp;&amp; fmt-&gt;fDatePattern &amp;&amp; (*fDatePattern != *fmt-&gt;fDatePattern)) {return FALSE;}
 245     if (fTimePattern != fmt-&gt;fTimePattern &amp;&amp; (fTimePattern == NULL || fmt-&gt;fTimePattern == NULL)) {return FALSE;}
 246     if (fTimePattern &amp;&amp; fmt-&gt;fTimePattern &amp;&amp; (*fTimePattern != *fmt-&gt;fTimePattern)) {return FALSE;}
 247     if (fDateTimeFormat != fmt-&gt;fDateTimeFormat &amp;&amp; (fDateTimeFormat == NULL || fmt-&gt;fDateTimeFormat == NULL)) {return FALSE;}
 248     if (fDateTimeFormat &amp;&amp; fmt-&gt;fDateTimeFormat &amp;&amp; (*fDateTimeFormat != *fmt-&gt;fDateTimeFormat)) {return FALSE;}
 249     if (fLocale != fmt-&gt;fLocale) {return FALSE;}
 250 
 251     for (int32_t i = 0; i&lt; DateIntervalInfo::kIPI_MAX_INDEX; ++i ) {
 252         if (fIntervalPatterns[i].firstPart != fmt-&gt;fIntervalPatterns[i].firstPart) {return FALSE;}
 253         if (fIntervalPatterns[i].secondPart != fmt-&gt;fIntervalPatterns[i].secondPart ) {return FALSE;}
 254         if (fIntervalPatterns[i].laterDateFirst != fmt-&gt;fIntervalPatterns[i].laterDateFirst) {return FALSE;}
 255     }
 256     return TRUE;
</pre>
<hr />
<pre>
 269     if ( obj.getType() == Formattable::kObject ) {
 270         const UObject* formatObj = obj.getObject();
 271         const DateInterval* interval = dynamic_cast&lt;const DateInterval*&gt;(formatObj);
 272         if (interval != NULL) {
 273             return format(interval, appendTo, fieldPosition, status);
 274         }
 275     }
 276     status = U_ILLEGAL_ARGUMENT_ERROR;
 277     return appendTo;
 278 }
 279 
 280 
 281 UnicodeString&amp;
 282 DateIntervalFormat::format(const DateInterval* dtInterval,
 283                            UnicodeString&amp; appendTo,
 284                            FieldPosition&amp; fieldPosition,
 285                            UErrorCode&amp; status) const {
 286     if ( U_FAILURE(status) ) {
 287         return appendTo;
 288     }
<span class="line-modified"> 289     if (fDateFormat == NULL || fInfo == NULL) {</span>
 290         status = U_INVALID_STATE_ERROR;
 291         return appendTo;
 292     }
 293 
<span class="line-modified"> 294     FieldPositionOnlyHandler handler(fieldPosition);</span>
<span class="line-modified"> 295     handler.setAcceptFirstOnly(TRUE);</span>
<span class="line-modified"> 296     int8_t ignore;</span>
<span class="line-modified"> 297 </span>
<span class="line-added"> 298     Mutex lock(gFormatterMutex());</span>
<span class="line-added"> 299     return formatIntervalImpl(*dtInterval, appendTo, ignore, handler, status);</span>
<span class="line-added"> 300 }</span>
<span class="line-added"> 301 </span>
<span class="line-added"> 302 </span>
<span class="line-added"> 303 FormattedDateInterval DateIntervalFormat::formatToValue(</span>
<span class="line-added"> 304         const DateInterval&amp; dtInterval,</span>
<span class="line-added"> 305         UErrorCode&amp; status) const {</span>
<span class="line-added"> 306     LocalPointer&lt;FormattedDateIntervalData&gt; result(new FormattedDateIntervalData(status), status);</span>
<span class="line-added"> 307     if (U_FAILURE(status)) {</span>
<span class="line-added"> 308         return FormattedDateInterval(status);</span>
<span class="line-added"> 309     }</span>
<span class="line-added"> 310     UnicodeString string;</span>
<span class="line-added"> 311     int8_t firstIndex;</span>
<span class="line-added"> 312     auto handler = result-&gt;getHandler(status);</span>
<span class="line-added"> 313     handler.setCategory(UFIELD_CATEGORY_DATE);</span>
<span class="line-added"> 314     {</span>
<span class="line-added"> 315         Mutex lock(gFormatterMutex());</span>
<span class="line-added"> 316         formatIntervalImpl(dtInterval, string, firstIndex, handler, status);</span>
<span class="line-added"> 317     }</span>
<span class="line-added"> 318     handler.getError(status);</span>
<span class="line-added"> 319     result-&gt;appendString(string, status);</span>
<span class="line-added"> 320     if (U_FAILURE(status)) {</span>
<span class="line-added"> 321         return FormattedDateInterval(status);</span>
<span class="line-added"> 322     }</span>
<span class="line-added"> 323 </span>
<span class="line-added"> 324     // Compute the span fields and sort them into place:</span>
<span class="line-added"> 325     if (firstIndex != -1) {</span>
<span class="line-added"> 326         result-&gt;addOverlapSpans(UFIELD_CATEGORY_DATE_INTERVAL_SPAN, firstIndex, status);</span>
<span class="line-added"> 327         if (U_FAILURE(status)) {</span>
<span class="line-added"> 328             return FormattedDateInterval(status);</span>
<span class="line-added"> 329         }</span>
<span class="line-added"> 330         result-&gt;sort();</span>
<span class="line-added"> 331     }</span>
<span class="line-added"> 332 </span>
<span class="line-added"> 333     return FormattedDateInterval(result.orphan());</span>
 334 }
 335 
 336 
 337 UnicodeString&amp;
 338 DateIntervalFormat::format(Calendar&amp; fromCalendar,
 339                            Calendar&amp; toCalendar,
 340                            UnicodeString&amp; appendTo,
 341                            FieldPosition&amp; pos,
 342                            UErrorCode&amp; status) const {
<span class="line-modified"> 343     FieldPositionOnlyHandler handler(pos);</span>
<span class="line-modified"> 344     handler.setAcceptFirstOnly(TRUE);</span>
<span class="line-added"> 345     int8_t ignore;</span>
<span class="line-added"> 346 </span>
<span class="line-added"> 347     Mutex lock(gFormatterMutex());</span>
<span class="line-added"> 348     return formatImpl(fromCalendar, toCalendar, appendTo, ignore, handler, status);</span>
<span class="line-added"> 349 }</span>
<span class="line-added"> 350 </span>
<span class="line-added"> 351 </span>
<span class="line-added"> 352 FormattedDateInterval DateIntervalFormat::formatToValue(</span>
<span class="line-added"> 353         Calendar&amp; fromCalendar,</span>
<span class="line-added"> 354         Calendar&amp; toCalendar,</span>
<span class="line-added"> 355         UErrorCode&amp; status) const {</span>
<span class="line-added"> 356     LocalPointer&lt;FormattedDateIntervalData&gt; result(new FormattedDateIntervalData(status), status);</span>
<span class="line-added"> 357     if (U_FAILURE(status)) {</span>
<span class="line-added"> 358         return FormattedDateInterval(status);</span>
<span class="line-added"> 359     }</span>
<span class="line-added"> 360     UnicodeString string;</span>
<span class="line-added"> 361     int8_t firstIndex;</span>
<span class="line-added"> 362     auto handler = result-&gt;getHandler(status);</span>
<span class="line-added"> 363     handler.setCategory(UFIELD_CATEGORY_DATE);</span>
<span class="line-added"> 364     {</span>
<span class="line-added"> 365         Mutex lock(gFormatterMutex());</span>
<span class="line-added"> 366         formatImpl(fromCalendar, toCalendar, string, firstIndex, handler, status);</span>
<span class="line-added"> 367     }</span>
<span class="line-added"> 368     handler.getError(status);</span>
<span class="line-added"> 369     result-&gt;appendString(string, status);</span>
<span class="line-added"> 370     if (U_FAILURE(status)) {</span>
<span class="line-added"> 371         return FormattedDateInterval(status);</span>
<span class="line-added"> 372     }</span>
<span class="line-added"> 373 </span>
<span class="line-added"> 374     // Compute the span fields and sort them into place:</span>
<span class="line-added"> 375     if (firstIndex != -1) {</span>
<span class="line-added"> 376         result-&gt;addOverlapSpans(UFIELD_CATEGORY_DATE_INTERVAL_SPAN, firstIndex, status);</span>
<span class="line-added"> 377         result-&gt;sort();</span>
<span class="line-added"> 378     }</span>
<span class="line-added"> 379 </span>
<span class="line-added"> 380     return FormattedDateInterval(result.orphan());</span>
<span class="line-added"> 381 }</span>
<span class="line-added"> 382 </span>
<span class="line-added"> 383 </span>
<span class="line-added"> 384 UnicodeString&amp; DateIntervalFormat::formatIntervalImpl(</span>
<span class="line-added"> 385         const DateInterval&amp; dtInterval,</span>
<span class="line-added"> 386         UnicodeString&amp; appendTo,</span>
<span class="line-added"> 387         int8_t&amp; firstIndex,</span>
<span class="line-added"> 388         FieldPositionHandler&amp; fphandler,</span>
<span class="line-added"> 389         UErrorCode&amp; status) const {</span>
<span class="line-added"> 390     if (U_FAILURE(status)) {</span>
<span class="line-added"> 391         return appendTo;</span>
<span class="line-added"> 392     }</span>
<span class="line-added"> 393     if (fFromCalendar == nullptr || fToCalendar == nullptr) {</span>
<span class="line-added"> 394         status = U_INVALID_STATE_ERROR;</span>
<span class="line-added"> 395         return appendTo;</span>
<span class="line-added"> 396     }</span>
<span class="line-added"> 397     fFromCalendar-&gt;setTime(dtInterval.getFromDate(), status);</span>
<span class="line-added"> 398     fToCalendar-&gt;setTime(dtInterval.getToDate(), status);</span>
<span class="line-added"> 399     return formatImpl(*fFromCalendar, *fToCalendar, appendTo, firstIndex, fphandler, status);</span>
 400 }
 401 
 402 
 403 UnicodeString&amp;
 404 DateIntervalFormat::formatImpl(Calendar&amp; fromCalendar,
 405                            Calendar&amp; toCalendar,
 406                            UnicodeString&amp; appendTo,
<span class="line-modified"> 407                            int8_t&amp; firstIndex,</span>
<span class="line-added"> 408                            FieldPositionHandler&amp; fphandler,</span>
 409                            UErrorCode&amp; status) const {
 410     if ( U_FAILURE(status) ) {
 411         return appendTo;
 412     }
 413 
<span class="line-added"> 414     // Initialize firstIndex to -1 (single date, no range)</span>
<span class="line-added"> 415     firstIndex = -1;</span>
<span class="line-added"> 416 </span>
 417     // not support different calendar types and time zones
 418     //if ( fromCalendar.getType() != toCalendar.getType() ) {
 419     if ( !fromCalendar.isEquivalentTo(toCalendar) ) {
 420         status = U_ILLEGAL_ARGUMENT_ERROR;
 421         return appendTo;
 422     }
 423 
 424     // First, find the largest different calendar field.
 425     UCalendarDateFields field = UCAL_FIELD_COUNT;
 426 
 427     if ( fromCalendar.get(UCAL_ERA,status) != toCalendar.get(UCAL_ERA,status)) {
 428         field = UCAL_ERA;
 429     } else if ( fromCalendar.get(UCAL_YEAR, status) !=
 430                 toCalendar.get(UCAL_YEAR, status) ) {
 431         field = UCAL_YEAR;
 432     } else if ( fromCalendar.get(UCAL_MONTH, status) !=
 433                 toCalendar.get(UCAL_MONTH, status) ) {
 434         field = UCAL_MONTH;
 435     } else if ( fromCalendar.get(UCAL_DATE, status) !=
 436                 toCalendar.get(UCAL_DATE, status) ) {
</pre>
<hr />
<pre>
 439                 toCalendar.get(UCAL_AM_PM, status) ) {
 440         field = UCAL_AM_PM;
 441     } else if ( fromCalendar.get(UCAL_HOUR, status) !=
 442                 toCalendar.get(UCAL_HOUR, status) ) {
 443         field = UCAL_HOUR;
 444     } else if ( fromCalendar.get(UCAL_MINUTE, status) !=
 445                 toCalendar.get(UCAL_MINUTE, status) ) {
 446         field = UCAL_MINUTE;
 447     } else if ( fromCalendar.get(UCAL_SECOND, status) !=
 448                 toCalendar.get(UCAL_SECOND, status) ) {
 449         field = UCAL_SECOND;
 450     }
 451 
 452     if ( U_FAILURE(status) ) {
 453         return appendTo;
 454     }
 455     if ( field == UCAL_FIELD_COUNT ) {
 456         /* ignore the millisecond etc. small fields&#39; difference.
 457          * use single date when all the above are the same.
 458          */
<span class="line-modified"> 459         return fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
 460     }
 461     UBool fromToOnSameDay = (field==UCAL_AM_PM || field==UCAL_HOUR || field==UCAL_MINUTE || field==UCAL_SECOND);
 462 
 463     // following call should not set wrong status,
 464     // all the pass-in fields are valid till here
 465     int32_t itvPtnIndex = DateIntervalInfo::calendarFieldToIntervalIndex(field,
 466                                                                         status);
 467     const PatternInfo&amp; intervalPattern = fIntervalPatterns[itvPtnIndex];
 468 
 469     if ( intervalPattern.firstPart.isEmpty() &amp;&amp;
 470          intervalPattern.secondPart.isEmpty() ) {
 471         if ( fDateFormat-&gt;isFieldUnitIgnored(field) ) {
 472             /* the largest different calendar field is small than
 473              * the smallest calendar field in pattern,
 474              * return single date format.
 475              */
<span class="line-modified"> 476             return fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
 477         }
<span class="line-modified"> 478         return fallbackFormat(fromCalendar, toCalendar, fromToOnSameDay, appendTo, firstIndex, fphandler, status);</span>
 479     }
 480     // If the first part in interval pattern is empty,
 481     // the 2nd part of it saves the full-pattern used in fall-back.
 482     // For a &#39;real&#39; interval pattern, the first part will never be empty.
 483     if ( intervalPattern.firstPart.isEmpty() ) {
 484         // fall back
 485         UnicodeString originalPattern;
 486         fDateFormat-&gt;toPattern(originalPattern);
 487         fDateFormat-&gt;applyPattern(intervalPattern.secondPart);
<span class="line-modified"> 488         appendTo = fallbackFormat(fromCalendar, toCalendar, fromToOnSameDay, appendTo, firstIndex, fphandler, status);</span>
 489         fDateFormat-&gt;applyPattern(originalPattern);
 490         return appendTo;
 491     }
 492     Calendar* firstCal;
 493     Calendar* secondCal;
 494     if ( intervalPattern.laterDateFirst ) {
 495         firstCal = &amp;toCalendar;
 496         secondCal = &amp;fromCalendar;
<span class="line-added"> 497         firstIndex = 1;</span>
 498     } else {
 499         firstCal = &amp;fromCalendar;
 500         secondCal = &amp;toCalendar;
<span class="line-added"> 501         firstIndex = 0;</span>
 502     }
 503     // break the interval pattern into 2 parts,
 504     // first part should not be empty,
 505     UnicodeString originalPattern;
 506     fDateFormat-&gt;toPattern(originalPattern);
 507     fDateFormat-&gt;applyPattern(intervalPattern.firstPart);
<span class="line-modified"> 508     fDateFormat-&gt;_format(*firstCal, appendTo, fphandler, status);</span>
<span class="line-added"> 509 </span>
 510     if ( !intervalPattern.secondPart.isEmpty() ) {
 511         fDateFormat-&gt;applyPattern(intervalPattern.secondPart);
<span class="line-modified"> 512         fDateFormat-&gt;_format(*secondCal, appendTo, fphandler, status);</span>





 513     }
 514     fDateFormat-&gt;applyPattern(originalPattern);
 515     return appendTo;
 516 }
 517 
 518 
 519 
 520 void
 521 DateIntervalFormat::parseObject(const UnicodeString&amp; /* source */,
 522                                 Formattable&amp; /* result */,
 523                                 ParsePosition&amp; /* parse_pos */) const {
 524     // parseObject(const UnicodeString&amp;, Formattable&amp;, UErrorCode&amp;) const
 525     // will set status as U_INVALID_FORMAT_ERROR if
 526     // parse_pos is still 0
 527 }
 528 
 529 
 530 
 531 
 532 const DateIntervalInfo*
</pre>
<hr />
<pre>
 583 void
 584 DateIntervalFormat::setTimeZone(const TimeZone&amp; zone)
 585 {
 586     if (fDateFormat != NULL) {
 587         fDateFormat-&gt;setTimeZone(zone);
 588     }
 589     // The fDateFormat has the master calendar for the DateIntervalFormat;
 590     // fFromCalendar and fToCalendar are internal work clones of that calendar.
 591     if (fFromCalendar) {
 592         fFromCalendar-&gt;setTimeZone(zone);
 593     }
 594     if (fToCalendar) {
 595         fToCalendar-&gt;setTimeZone(zone);
 596     }
 597 }
 598 
 599 const TimeZone&amp;
 600 DateIntervalFormat::getTimeZone() const
 601 {
 602     if (fDateFormat != NULL) {
<span class="line-modified"> 603         Mutex lock(gFormatterMutex());</span>
 604         return fDateFormat-&gt;getTimeZone();
 605     }
 606     // If fDateFormat is NULL (unexpected), create default timezone.
 607     return *(TimeZone::createDefault());
 608 }
 609 
 610 DateIntervalFormat::DateIntervalFormat(const Locale&amp; locale,
 611                                        DateIntervalInfo* dtItvInfo,
 612                                        const UnicodeString* skeleton,
 613                                        UErrorCode&amp; status)
 614 :   fInfo(NULL),
 615     fDateFormat(NULL),
 616     fFromCalendar(NULL),
 617     fToCalendar(NULL),
 618     fLocale(locale),
 619     fDatePattern(NULL),
 620     fTimePattern(NULL),
 621     fDateTimeFormat(NULL)
 622 {
 623     LocalPointer&lt;DateIntervalInfo&gt; info(dtItvInfo, status);
</pre>
<hr />
<pre>
 968           case LOW_J:
 969           case LOW_S:
 970           case CAP_S:
 971           case CAP_A:
 972             timeSkeleton.append(ch);
 973             normalizedTimeSkeleton.append(ch);
 974             break;
 975         }
 976     }
 977 
 978     /* generate normalized form for date*/
 979     if ( yCount != 0 ) {
 980         for (i = 0; i &lt; yCount; ++i) {
 981             normalizedDateSkeleton.append(LOW_Y);
 982         }
 983     }
 984     if ( MCount != 0 ) {
 985         if ( MCount &lt; 3 ) {
 986             normalizedDateSkeleton.append(CAP_M);
 987         } else {
<span class="line-modified"> 988             for ( int32_t j = 0; j &lt; MCount &amp;&amp; j &lt; MAX_M_COUNT; ++j) {</span>

 989                  normalizedDateSkeleton.append(CAP_M);
 990             }
 991         }
 992     }
 993     if ( ECount != 0 ) {
 994         if ( ECount &lt;= 3 ) {
 995             normalizedDateSkeleton.append(CAP_E);
 996         } else {
<span class="line-modified"> 997             for ( int32_t j = 0; j &lt; ECount &amp;&amp; j &lt; MAX_E_COUNT; ++j ) {</span>

 998                  normalizedDateSkeleton.append(CAP_E);
 999             }
1000         }
1001     }
1002     if ( dCount != 0 ) {
1003         normalizedDateSkeleton.append(LOW_D);
1004     }
1005 
1006     /* generate normalized form for time */
1007     if ( HCount != 0 ) {
1008         normalizedTimeSkeleton.append(CAP_H);
1009     }
1010     else if ( hCount != 0 ) {
1011         normalizedTimeSkeleton.append(LOW_H);
1012     }
1013     if ( mCount != 0 ) {
1014         normalizedTimeSkeleton.append(LOW_M);
1015     }
1016     if ( zCount != 0 ) {
1017         normalizedTimeSkeleton.append(LOW_Z);
</pre>
<hr />
<pre>
1113         return false;
1114     }
1115 
1116     if ( timeSkeleton.length() == 0 ) {
1117         UnicodeString extendedSkeleton;
1118         UnicodeString extendedBestSkeleton;
1119         // only has date skeleton
1120         setIntervalPattern(UCAL_DATE, skeleton, bestSkeleton, differenceInfo,
1121                            &amp;extendedSkeleton, &amp;extendedBestSkeleton);
1122 
1123         UBool extended = setIntervalPattern(UCAL_MONTH, skeleton, bestSkeleton,
1124                                      differenceInfo,
1125                                      &amp;extendedSkeleton, &amp;extendedBestSkeleton);
1126 
1127         if ( extended ) {
1128             bestSkeleton = &amp;extendedBestSkeleton;
1129             skeleton = &amp;extendedSkeleton;
1130         }
1131         setIntervalPattern(UCAL_YEAR, skeleton, bestSkeleton, differenceInfo,
1132                            &amp;extendedSkeleton, &amp;extendedBestSkeleton);
<span class="line-modified">1133         setIntervalPattern(UCAL_ERA, skeleton, bestSkeleton, differenceInfo,</span>
<span class="line-added">1134                            &amp;extendedSkeleton, &amp;extendedBestSkeleton);</span>
<span class="line-added">1135      } else {</span>
1136         setIntervalPattern(UCAL_MINUTE, skeleton, bestSkeleton, differenceInfo);
1137         setIntervalPattern(UCAL_HOUR, skeleton, bestSkeleton, differenceInfo);
1138         setIntervalPattern(UCAL_AM_PM, skeleton, bestSkeleton, differenceInfo);
1139     }
1140     return true;
1141 }
1142 
1143 
1144 
1145 void
1146 DateIntervalFormat::setFallbackPattern(UCalendarDateFields field,
1147                                        const UnicodeString&amp; skeleton,
1148                                        UErrorCode&amp; status) {
1149     if ( U_FAILURE(status) ) {
1150         return;
1151     }
1152     UnicodeString pattern = DateFormat::getBestPattern(
1153             fLocale, skeleton, status);
1154     if ( U_FAILURE(status) ) {
1155         return;
</pre>
<hr />
<pre>
1387         }
1388         else if (!inQuote &amp;&amp; ((ch &gt;= 0x0061 /*&#39;a&#39;*/ &amp;&amp; ch &lt;= 0x007A /*&#39;z&#39;*/)
1389                     || (ch &gt;= 0x0041 /*&#39;A&#39;*/ &amp;&amp; ch &lt;= 0x005A /*&#39;Z&#39;*/))) {
1390             // ch is a date-time pattern character
1391             prevCh = ch;
1392             ++count;
1393         }
1394     }
1395     // check last pattern char, distinguish
1396     // &quot;dd MM&quot; ( no repetition ),
1397     // &quot;d-d&quot;(last char repeated ), and
1398     // &quot;d-d MM&quot; ( repetition found )
1399     if ( count &gt; 0 &amp;&amp; foundRepetition == FALSE ) {
1400         if ( patternRepeated[(int)(prevCh - PATTERN_CHAR_BASE)] == FALSE ) {
1401             count = 0;
1402         }
1403     }
1404     return (i - count);
1405 }
1406 
<span class="line-modified">1407 void DateIntervalFormat::fallbackFormatRange(</span>
<span class="line-modified">1408         Calendar&amp; fromCalendar,</span>
<span class="line-modified">1409         Calendar&amp; toCalendar,</span>
<span class="line-modified">1410         UnicodeString&amp; appendTo,</span>
<span class="line-modified">1411         int8_t&amp; firstIndex,</span>
<span class="line-modified">1412         FieldPositionHandler&amp; fphandler,</span>
<span class="line-modified">1413         UErrorCode&amp; status) const {</span>
<span class="line-modified">1414     UnicodeString fallbackPattern;</span>
<span class="line-modified">1415     fInfo-&gt;getFallbackIntervalPattern(fallbackPattern);</span>
<span class="line-modified">1416     SimpleFormatter sf(fallbackPattern, 2, 2, status);</span>
<span class="line-modified">1417     if (U_FAILURE(status)) {</span>
1418         return;
1419     }
<span class="line-modified">1420     int32_t offsets[2];</span>
<span class="line-modified">1421     UnicodeString patternBody = sf.getTextWithNoArguments(offsets, 2);</span>
<span class="line-modified">1422 </span>
<span class="line-modified">1423     // TODO(ICU-20406): Use SimpleFormatter Iterator interface when available.</span>
<span class="line-modified">1424     if (offsets[0] &lt; offsets[1]) {</span>
<span class="line-modified">1425         firstIndex = 0;</span>
<span class="line-modified">1426         appendTo.append(patternBody.tempSubStringBetween(0, offsets[0]));</span>
<span class="line-modified">1427         fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">1428         appendTo.append(patternBody.tempSubStringBetween(offsets[0], offsets[1]));</span>
<span class="line-modified">1429         fDateFormat-&gt;_format(toCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">1430         appendTo.append(patternBody.tempSubStringBetween(offsets[1]));</span>
1431     } else {
<span class="line-modified">1432         firstIndex = 1;</span>
<span class="line-modified">1433         appendTo.append(patternBody.tempSubStringBetween(0, offsets[1]));</span>
<span class="line-modified">1434         fDateFormat-&gt;_format(toCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">1435         appendTo.append(patternBody.tempSubStringBetween(offsets[1], offsets[0]));</span>
<span class="line-modified">1436         fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">1437         appendTo.append(patternBody.tempSubStringBetween(offsets[0]));</span>



1438     }
1439 }
1440 
1441 UnicodeString&amp;
1442 DateIntervalFormat::fallbackFormat(Calendar&amp; fromCalendar,
1443                                    Calendar&amp; toCalendar,
1444                                    UBool fromToOnSameDay, // new
1445                                    UnicodeString&amp; appendTo,
<span class="line-modified">1446                                    int8_t&amp; firstIndex,</span>
<span class="line-added">1447                                    FieldPositionHandler&amp; fphandler,</span>
1448                                    UErrorCode&amp; status) const {
1449     if ( U_FAILURE(status) ) {
1450         return appendTo;
1451     }
<span class="line-modified">1452 </span>
1453     UBool formatDatePlusTimeRange = (fromToOnSameDay &amp;&amp; fDatePattern &amp;&amp; fTimePattern);

1454     if (formatDatePlusTimeRange) {
<span class="line-added">1455         SimpleFormatter sf(*fDateTimeFormat, 2, 2, status);</span>
<span class="line-added">1456         if (U_FAILURE(status)) {</span>
<span class="line-added">1457             return appendTo;</span>
<span class="line-added">1458         }</span>
<span class="line-added">1459         int32_t offsets[2];</span>
<span class="line-added">1460         UnicodeString patternBody = sf.getTextWithNoArguments(offsets, 2);</span>
<span class="line-added">1461 </span>
<span class="line-added">1462         UnicodeString fullPattern; // for saving the pattern in fDateFormat</span>
1463         fDateFormat-&gt;toPattern(fullPattern); // save current pattern, restore later
<span class="line-modified">1464 </span>
<span class="line-modified">1465         // {0} is time range</span>
<span class="line-modified">1466         // {1} is single date portion</span>
<span class="line-modified">1467         // TODO(ICU-20406): Use SimpleFormatter Iterator interface when available.</span>
<span class="line-modified">1468         if (offsets[0] &lt; offsets[1]) {</span>
<span class="line-modified">1469             appendTo.append(patternBody.tempSubStringBetween(0, offsets[0]));</span>
<span class="line-modified">1470             fDateFormat-&gt;applyPattern(*fTimePattern);</span>
<span class="line-modified">1471             fallbackFormatRange(fromCalendar, toCalendar, appendTo, firstIndex, fphandler, status);</span>
<span class="line-modified">1472             appendTo.append(patternBody.tempSubStringBetween(offsets[0], offsets[1]));</span>
<span class="line-modified">1473             fDateFormat-&gt;applyPattern(*fDatePattern);</span>
<span class="line-modified">1474             fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">1475             appendTo.append(patternBody.tempSubStringBetween(offsets[1]));</span>
<span class="line-modified">1476         } else {</span>
<span class="line-modified">1477             appendTo.append(patternBody.tempSubStringBetween(0, offsets[1]));</span>
<span class="line-modified">1478             fDateFormat-&gt;applyPattern(*fDatePattern);</span>
<span class="line-modified">1479             fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">1480             appendTo.append(patternBody.tempSubStringBetween(offsets[1], offsets[0]));</span>
<span class="line-modified">1481             fDateFormat-&gt;applyPattern(*fTimePattern);</span>
<span class="line-modified">1482             fallbackFormatRange(fromCalendar, toCalendar, appendTo, firstIndex, fphandler, status);</span>
<span class="line-modified">1483             appendTo.append(patternBody.tempSubStringBetween(offsets[0]));</span>
<span class="line-modified">1484         }</span>
<span class="line-modified">1485 </span>











1486         // restore full pattern
1487         fDateFormat-&gt;applyPattern(fullPattern);
<span class="line-added">1488     } else {</span>
<span class="line-added">1489         fallbackFormatRange(fromCalendar, toCalendar, appendTo, firstIndex, fphandler, status);</span>
1490     }
1491     return appendTo;
1492 }
1493 
1494 
1495 
1496 
1497 UBool  U_EXPORT2
1498 DateIntervalFormat::fieldExistsInSkeleton(UCalendarDateFields field,
1499                                           const UnicodeString&amp; skeleton)
1500 {
1501     const UChar fieldChar = fgCalendarFieldToPatternLetter[field];
1502     return ( (skeleton.indexOf(fieldChar) == -1)?FALSE:TRUE ) ;
1503 }
1504 
1505 
1506 
1507 void  U_EXPORT2
1508 DateIntervalFormat::adjustFieldWidth(const UnicodeString&amp; inputSkeleton,
1509                  const UnicodeString&amp; bestMatchSkeleton,
</pre>
<hr />
<pre>
1641     // else: fall back
1642     // it should not happen if the interval format defined is valid
1643 }
1644 
1645 
1646 
1647 const UChar
1648 DateIntervalFormat::fgCalendarFieldToPatternLetter[] =
1649 {
1650     /*GyM*/ CAP_G, LOW_Y, CAP_M,
1651     /*wWd*/ LOW_W, CAP_W, LOW_D,
1652     /*DEF*/ CAP_D, CAP_E, CAP_F,
1653     /*ahH*/ LOW_A, LOW_H, CAP_H,
1654     /*msS*/ LOW_M, LOW_S, CAP_S, // MINUTE, SECOND, MILLISECOND
1655     /*z.Y*/ LOW_Z, SPACE, CAP_Y, // ZONE_OFFSET, DST_OFFSET, YEAR_WOY,
1656     /*eug*/ LOW_E, LOW_U, LOW_G, // DOW_LOCAL, EXTENDED_YEAR, JULIAN_DAY,
1657     /*A..*/ CAP_A, SPACE, SPACE, // MILLISECONDS_IN_DAY, IS_LEAP_MONTH, FIELD_COUNT
1658 };
1659 
1660 
<span class="line-added">1661 </span>
1662 U_NAMESPACE_END
1663 
1664 #endif
</pre>
</td>
</tr>
</table>
<center><a href="dtfmtsym.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="dtitvinf.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>