<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/measfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 * Copyright (c) 2004-2016, International Business Machines
   6 * Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8 * Author: Alan Liu
   9 * Created: April 20, 2004
  10 * Since: ICU 3.0
  11 **********************************************************************
  12 */
  13 #include &quot;utypeinfo.h&quot;  // for &#39;typeid&#39; to work
  14 #include &quot;unicode/utypes.h&quot;
  15 
  16 #if !UCONFIG_NO_FORMATTING
  17 
  18 #include &quot;unicode/measfmt.h&quot;
  19 #include &quot;unicode/numfmt.h&quot;
  20 #include &quot;currfmt.h&quot;
  21 #include &quot;unicode/localpointer.h&quot;
  22 #include &quot;resource.h&quot;
  23 #include &quot;unicode/simpleformatter.h&quot;
  24 #include &quot;quantityformatter.h&quot;
  25 #include &quot;unicode/plurrule.h&quot;
  26 #include &quot;unicode/decimfmt.h&quot;
  27 #include &quot;uresimp.h&quot;
  28 #include &quot;unicode/ures.h&quot;
  29 #include &quot;unicode/ustring.h&quot;
  30 #include &quot;ureslocs.h&quot;
  31 #include &quot;cstring.h&quot;
  32 #include &quot;mutex.h&quot;
  33 #include &quot;ucln_in.h&quot;
  34 #include &quot;unicode/listformatter.h&quot;
  35 #include &quot;charstr.h&quot;
  36 #include &quot;unicode/putil.h&quot;
  37 #include &quot;unicode/smpdtfmt.h&quot;
  38 #include &quot;uassert.h&quot;
<a name="1" id="anc1"></a>

  39 
  40 #include &quot;sharednumberformat.h&quot;
  41 #include &quot;sharedpluralrules.h&quot;
  42 #include &quot;standardplural.h&quot;
  43 #include &quot;unifiedcache.h&quot;
  44 
  45 
  46 U_NAMESPACE_BEGIN
  47 
<a name="2" id="anc2"></a><span class="line-removed">  48 static constexpr int32_t PER_UNIT_INDEX = StandardPlural::COUNT;</span>
<span class="line-removed">  49 static constexpr int32_t PATTERN_COUNT = PER_UNIT_INDEX + 1;</span>
<span class="line-removed">  50 static constexpr int32_t MEAS_UNIT_COUNT = 138;  // see assertion in MeasureFormatCacheData constructor</span>
  51 static constexpr int32_t WIDTH_INDEX_COUNT = UMEASFMT_WIDTH_NARROW + 1;
  52 
  53 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(MeasureFormat)
  54 
  55 // Used to format durations like 5:47 or 21:35:42.
  56 class NumericDateFormatters : public UMemory {
  57 public:
  58     // Formats like H:mm
  59     SimpleDateFormat hourMinute;
  60 
  61     // formats like M:ss
  62     SimpleDateFormat minuteSecond;
  63 
  64     // formats like H:mm:ss
  65     SimpleDateFormat hourMinuteSecond;
  66 
  67     // Constructor that takes the actual patterns for hour-minute,
  68     // minute-second, and hour-minute-second respectively.
  69     NumericDateFormatters(
  70             const UnicodeString &amp;hm,
  71             const UnicodeString &amp;ms,
  72             const UnicodeString &amp;hms,
  73             UErrorCode &amp;status) :
  74             hourMinute(hm, status),
  75             minuteSecond(ms, status),
  76             hourMinuteSecond(hms, status) {
  77         const TimeZone *gmt = TimeZone::getGMT();
  78         hourMinute.setTimeZone(*gmt);
  79         minuteSecond.setTimeZone(*gmt);
  80         hourMinuteSecond.setTimeZone(*gmt);
  81     }
  82 private:
  83     NumericDateFormatters(const NumericDateFormatters &amp;other);
  84     NumericDateFormatters &amp;operator=(const NumericDateFormatters &amp;other);
  85 };
  86 
  87 static UMeasureFormatWidth getRegularWidth(UMeasureFormatWidth width) {
  88     if (width &gt;= WIDTH_INDEX_COUNT) {
  89         return UMEASFMT_WIDTH_NARROW;
  90     }
  91     return width;
  92 }
  93 
<a name="3" id="anc3"></a>












  94 /**
  95  * Instances contain all MeasureFormat specific data for a particular locale.
  96  * This data is cached. It is never copied, but is shared via shared pointers.
  97  *
  98  * Note: We might change the cache data to have an array[WIDTH_INDEX_COUNT] of
  99  * complete sets of unit &amp; per patterns,
 100  * to correspond to the resource data and its aliases.
 101  *
 102  * TODO: Maybe store more sparsely in general, with pointers rather than potentially-empty objects.
 103  */
 104 class MeasureFormatCacheData : public SharedObject {
 105 public:
 106 
 107     /**
 108      * Redirection data from root-bundle, top-level sideways aliases.
 109      * - UMEASFMT_WIDTH_COUNT: initial value, just fall back to root
 110      * - UMEASFMT_WIDTH_WIDE/SHORT/NARROW: sideways alias for missing data
 111      */
 112     UMeasureFormatWidth widthFallback[WIDTH_INDEX_COUNT];
<a name="4" id="anc4"></a><span class="line-removed"> 113     /** Measure unit -&gt; format width -&gt; array of patterns (&quot;{0} meters&quot;) (plurals + PER_UNIT_INDEX) */</span>
<span class="line-removed"> 114     SimpleFormatter* patterns[MEAS_UNIT_COUNT][WIDTH_INDEX_COUNT][PATTERN_COUNT];</span>
<span class="line-removed"> 115     const UChar* dnams[MEAS_UNIT_COUNT][WIDTH_INDEX_COUNT];</span>
<span class="line-removed"> 116     SimpleFormatter perFormatters[WIDTH_INDEX_COUNT];</span>
 117 
 118     MeasureFormatCacheData();
 119     virtual ~MeasureFormatCacheData();
 120 
<a name="5" id="anc5"></a><span class="line-removed"> 121     UBool hasPerFormatter(int32_t width) const {</span>
<span class="line-removed"> 122         // TODO: Create a more obvious way to test if the per-formatter has been set?</span>
<span class="line-removed"> 123         // Use pointers, check for NULL? Or add an isValid() method?</span>
<span class="line-removed"> 124         return perFormatters[width].getArgumentLimit() == 2;</span>
<span class="line-removed"> 125     }</span>
<span class="line-removed"> 126 </span>
 127     void adoptCurrencyFormat(int32_t widthIndex, NumberFormat *nfToAdopt) {
 128         delete currencyFormats[widthIndex];
 129         currencyFormats[widthIndex] = nfToAdopt;
 130     }
 131     const NumberFormat *getCurrencyFormat(UMeasureFormatWidth width) const {
 132         return currencyFormats[getRegularWidth(width)];
 133     }
 134     void adoptIntegerFormat(NumberFormat *nfToAdopt) {
 135         delete integerFormat;
 136         integerFormat = nfToAdopt;
 137     }
 138     const NumberFormat *getIntegerFormat() const {
 139         return integerFormat;
 140     }
 141     void adoptNumericDateFormatters(NumericDateFormatters *formattersToAdopt) {
 142         delete numericDateFormatters;
 143         numericDateFormatters = formattersToAdopt;
 144     }
 145     const NumericDateFormatters *getNumericDateFormatters() const {
 146         return numericDateFormatters;
 147     }
 148 
 149 private:
 150     NumberFormat* currencyFormats[WIDTH_INDEX_COUNT];
 151     NumberFormat* integerFormat;
 152     NumericDateFormatters* numericDateFormatters;
 153 
 154     MeasureFormatCacheData(const MeasureFormatCacheData &amp;other);
 155     MeasureFormatCacheData &amp;operator=(const MeasureFormatCacheData &amp;other);
 156 };
 157 
 158 MeasureFormatCacheData::MeasureFormatCacheData()
 159         : integerFormat(nullptr), numericDateFormatters(nullptr) {
<a name="6" id="anc6"></a><span class="line-removed"> 160     // Please update MEAS_UNIT_COUNT if it gets out of sync with the true count!</span>
<span class="line-removed"> 161     U_ASSERT(MEAS_UNIT_COUNT == MeasureUnit::getIndexCount());</span>
<span class="line-removed"> 162 </span>
 163     for (int32_t i = 0; i &lt; WIDTH_INDEX_COUNT; ++i) {
 164         widthFallback[i] = UMEASFMT_WIDTH_COUNT;
 165     }
<a name="7" id="anc7"></a><span class="line-removed"> 166     memset(&amp;patterns[0][0][0], 0, sizeof(patterns));</span>
<span class="line-removed"> 167     memset(&amp;dnams[0][0], 0, sizeof(dnams));</span>
 168     memset(currencyFormats, 0, sizeof(currencyFormats));
 169 }
 170 
 171 MeasureFormatCacheData::~MeasureFormatCacheData() {
 172     for (int32_t i = 0; i &lt; UPRV_LENGTHOF(currencyFormats); ++i) {
 173         delete currencyFormats[i];
 174     }
<a name="8" id="anc8"></a><span class="line-removed"> 175     for (int32_t i = 0; i &lt; MEAS_UNIT_COUNT; ++i) {</span>
<span class="line-removed"> 176         for (int32_t j = 0; j &lt; WIDTH_INDEX_COUNT; ++j) {</span>
<span class="line-removed"> 177             for (int32_t k = 0; k &lt; PATTERN_COUNT; ++k) {</span>
<span class="line-removed"> 178                 delete patterns[i][j][k];</span>
<span class="line-removed"> 179             }</span>
<span class="line-removed"> 180         }</span>
<span class="line-removed"> 181     }</span>
 182     // Note: the contents of &#39;dnams&#39; are pointers into the resource bundle
 183     delete integerFormat;
 184     delete numericDateFormatters;
 185 }
 186 
 187 static UBool isCurrency(const MeasureUnit &amp;unit) {
 188     return (uprv_strcmp(unit.getType(), &quot;currency&quot;) == 0);
 189 }
 190 
 191 static UBool getString(
 192         const UResourceBundle *resource,
 193         UnicodeString &amp;result,
 194         UErrorCode &amp;status) {
 195     int32_t len = 0;
 196     const UChar *resStr = ures_getString(resource, &amp;len, &amp;status);
 197     if (U_FAILURE(status)) {
 198         return FALSE;
 199     }
 200     result.setTo(TRUE, resStr, len);
 201     return TRUE;
 202 }
 203 
<a name="9" id="anc9"></a><span class="line-removed"> 204 namespace {</span>
<span class="line-removed"> 205 </span>
<span class="line-removed"> 206 static const UChar g_LOCALE_units[] = {</span>
<span class="line-removed"> 207     0x2F, 0x4C, 0x4F, 0x43, 0x41, 0x4C, 0x45, 0x2F,</span>
<span class="line-removed"> 208     0x75, 0x6E, 0x69, 0x74, 0x73</span>
<span class="line-removed"> 209 };</span>
<span class="line-removed"> 210 static const UChar gShort[] = { 0x53, 0x68, 0x6F, 0x72, 0x74 };</span>
<span class="line-removed"> 211 static const UChar gNarrow[] = { 0x4E, 0x61, 0x72, 0x72, 0x6F, 0x77 };</span>
<span class="line-removed"> 212 </span>
<span class="line-removed"> 213 /**</span>
<span class="line-removed"> 214  * Sink for enumerating all of the measurement unit display names.</span>
<span class="line-removed"> 215  * Contains inner sink classes, each one corresponding to a type of resource table.</span>
<span class="line-removed"> 216  * The outer sink handles the top-level units, unitsNarrow, and unitsShort tables.</span>
<span class="line-removed"> 217  *</span>
<span class="line-removed"> 218  * More specific bundles (en_GB) are enumerated before their parents (en_001, en, root):</span>
<span class="line-removed"> 219  * Only store a value if it is still missing, that is, it has not been overridden.</span>
<span class="line-removed"> 220  *</span>
<span class="line-removed"> 221  * C++: Each inner sink class has a reference to the main outer sink.</span>
<span class="line-removed"> 222  * Java: Use non-static inner classes instead.</span>
<span class="line-removed"> 223  */</span>
<span class="line-removed"> 224 struct UnitDataSink : public ResourceSink {</span>
<span class="line-removed"> 225 </span>
<span class="line-removed"> 226     // Output data.</span>
<span class="line-removed"> 227     MeasureFormatCacheData &amp;cacheData;</span>
<span class="line-removed"> 228 </span>
<span class="line-removed"> 229     // Path to current data.</span>
<span class="line-removed"> 230     UMeasureFormatWidth width;</span>
<span class="line-removed"> 231     const char *type;</span>
<span class="line-removed"> 232     int32_t unitIndex;</span>
<span class="line-removed"> 233 </span>
<span class="line-removed"> 234     UnitDataSink(MeasureFormatCacheData &amp;outputData)</span>
<span class="line-removed"> 235             : cacheData(outputData),</span>
<span class="line-removed"> 236               width(UMEASFMT_WIDTH_COUNT), type(NULL), unitIndex(0) {}</span>
<span class="line-removed"> 237     ~UnitDataSink();</span>
<span class="line-removed"> 238 </span>
<span class="line-removed"> 239     void setFormatterIfAbsent(int32_t index, const ResourceValue &amp;value,</span>
<span class="line-removed"> 240                                 int32_t minPlaceholders, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 241         U_ASSERT(unitIndex &lt; MEAS_UNIT_COUNT);</span>
<span class="line-removed"> 242         U_ASSERT(width &lt; WIDTH_INDEX_COUNT);</span>
<span class="line-removed"> 243         U_ASSERT(index &lt; PATTERN_COUNT);</span>
<span class="line-removed"> 244         SimpleFormatter **patterns = &amp;cacheData.patterns[unitIndex][width][0];</span>
<span class="line-removed"> 245         if (U_SUCCESS(errorCode) &amp;&amp; patterns[index] == NULL) {</span>
<span class="line-removed"> 246             if (minPlaceholders &gt;= 0) {</span>
<span class="line-removed"> 247                 patterns[index] = new SimpleFormatter(</span>
<span class="line-removed"> 248                         value.getUnicodeString(errorCode), minPlaceholders, 1, errorCode);</span>
<span class="line-removed"> 249             }</span>
<span class="line-removed"> 250             if (U_SUCCESS(errorCode) &amp;&amp; patterns[index] == NULL) {</span>
<span class="line-removed"> 251                 errorCode = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed"> 252             }</span>
<span class="line-removed"> 253         }</span>
<span class="line-removed"> 254     }</span>
<span class="line-removed"> 255 </span>
<span class="line-removed"> 256     void setDnamIfAbsent(const ResourceValue &amp;value, UErrorCode&amp; errorCode) {</span>
<span class="line-removed"> 257         U_ASSERT(unitIndex &lt; MEAS_UNIT_COUNT);</span>
<span class="line-removed"> 258         U_ASSERT(width &lt; WIDTH_INDEX_COUNT);</span>
<span class="line-removed"> 259         if (cacheData.dnams[unitIndex][width] == NULL) {</span>
<span class="line-removed"> 260             int32_t length;</span>
<span class="line-removed"> 261             cacheData.dnams[unitIndex][width] = value.getString(length, errorCode);</span>
<span class="line-removed"> 262         }</span>
<span class="line-removed"> 263     }</span>
<span class="line-removed"> 264 </span>
<span class="line-removed"> 265     /**</span>
<span class="line-removed"> 266      * Consume a display pattern. For example,</span>
<span class="line-removed"> 267      * unitsShort/duration/hour contains other{&quot;{0} hrs&quot;}.</span>
<span class="line-removed"> 268      */</span>
<span class="line-removed"> 269     void consumePattern(const char *key, const ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 270         if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 271         if (uprv_strcmp(key, &quot;dnam&quot;) == 0) {</span>
<span class="line-removed"> 272             // The display name for the unit in the current width.</span>
<span class="line-removed"> 273             setDnamIfAbsent(value, errorCode);</span>
<span class="line-removed"> 274         } else if (uprv_strcmp(key, &quot;per&quot;) == 0) {</span>
<span class="line-removed"> 275             // For example, &quot;{0}/h&quot;.</span>
<span class="line-removed"> 276             setFormatterIfAbsent(PER_UNIT_INDEX, value, 1, errorCode);</span>
<span class="line-removed"> 277         } else {</span>
<span class="line-removed"> 278             // The key must be one of the plural form strings. For example:</span>
<span class="line-removed"> 279             // one{&quot;{0} hr&quot;}</span>
<span class="line-removed"> 280             // other{&quot;{0} hrs&quot;}</span>
<span class="line-removed"> 281             setFormatterIfAbsent(StandardPlural::indexFromString(key, errorCode), value, 0,</span>
<span class="line-removed"> 282                                     errorCode);</span>
<span class="line-removed"> 283         }</span>
<span class="line-removed"> 284     }</span>
<span class="line-removed"> 285 </span>
<span class="line-removed"> 286     /**</span>
<span class="line-removed"> 287      * Consume a table of per-unit tables. For example,</span>
<span class="line-removed"> 288      * unitsShort/duration contains tables for duration-unit subtypes day &amp; hour.</span>
<span class="line-removed"> 289      */</span>
<span class="line-removed"> 290     void consumeSubtypeTable(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 291         if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 292         unitIndex = MeasureUnit::internalGetIndexForTypeAndSubtype(type, key);</span>
<span class="line-removed"> 293         if (unitIndex &lt; 0) {</span>
<span class="line-removed"> 294             // TODO: How to handle unexpected data?</span>
<span class="line-removed"> 295             // See http://bugs.icu-project.org/trac/ticket/12597</span>
<span class="line-removed"> 296             return;</span>
<span class="line-removed"> 297         }</span>
<span class="line-removed"> 298 </span>
<span class="line-removed"> 299         // We no longer handle units like &quot;coordinate&quot; here (which do not have plural variants)</span>
<span class="line-removed"> 300         if (value.getType() == URES_TABLE) {</span>
<span class="line-removed"> 301             // Units that have plural variants</span>
<span class="line-removed"> 302             ResourceTable patternTableTable = value.getTable(errorCode);</span>
<span class="line-removed"> 303             if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 304             for (int i = 0; patternTableTable.getKeyAndValue(i, key, value); ++i) {</span>
<span class="line-removed"> 305                 consumePattern(key, value, errorCode);</span>
<span class="line-removed"> 306             }</span>
<span class="line-removed"> 307         } else {</span>
<span class="line-removed"> 308             // TODO: How to handle unexpected data?</span>
<span class="line-removed"> 309             // See http://bugs.icu-project.org/trac/ticket/12597</span>
<span class="line-removed"> 310             return;</span>
<span class="line-removed"> 311         }</span>
<span class="line-removed"> 312     }</span>
<span class="line-removed"> 313 </span>
<span class="line-removed"> 314     /**</span>
<span class="line-removed"> 315      * Consume compound x-per-y display pattern. For example,</span>
<span class="line-removed"> 316      * unitsShort/compound/per may be &quot;{0}/{1}&quot;.</span>
<span class="line-removed"> 317      */</span>
<span class="line-removed"> 318     void consumeCompoundPattern(const char *key, const ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 319         if (U_SUCCESS(errorCode) &amp;&amp; uprv_strcmp(key, &quot;per&quot;) == 0) {</span>
<span class="line-removed"> 320             cacheData.perFormatters[width].</span>
<span class="line-removed"> 321                     applyPatternMinMaxArguments(value.getUnicodeString(errorCode), 2, 2, errorCode);</span>
<span class="line-removed"> 322         }</span>
<span class="line-removed"> 323     }</span>
<span class="line-removed"> 324 </span>
<span class="line-removed"> 325     /**</span>
<span class="line-removed"> 326      * Consume a table of unit type tables. For example,</span>
<span class="line-removed"> 327      * unitsShort contains tables for area &amp; duration.</span>
<span class="line-removed"> 328      * It also contains a table for the compound/per pattern.</span>
<span class="line-removed"> 329      */</span>
<span class="line-removed"> 330     void consumeUnitTypesTable(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 331         if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 332         if (uprv_strcmp(key, &quot;currency&quot;) == 0) {</span>
<span class="line-removed"> 333             // Skip.</span>
<span class="line-removed"> 334         } else if (uprv_strcmp(key, &quot;compound&quot;) == 0) {</span>
<span class="line-removed"> 335             if (!cacheData.hasPerFormatter(width)) {</span>
<span class="line-removed"> 336                 ResourceTable compoundTable = value.getTable(errorCode);</span>
<span class="line-removed"> 337                 if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 338                 for (int i = 0; compoundTable.getKeyAndValue(i, key, value); ++i) {</span>
<span class="line-removed"> 339                     consumeCompoundPattern(key, value, errorCode);</span>
<span class="line-removed"> 340                 }</span>
<span class="line-removed"> 341             }</span>
<span class="line-removed"> 342         } else if (uprv_strcmp(key, &quot;coordinate&quot;) == 0) {</span>
<span class="line-removed"> 343             // special handling but we need to determine what that is</span>
<span class="line-removed"> 344         } else {</span>
<span class="line-removed"> 345             type = key;</span>
<span class="line-removed"> 346             ResourceTable subtypeTable = value.getTable(errorCode);</span>
<span class="line-removed"> 347             if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 348             for (int i = 0; subtypeTable.getKeyAndValue(i, key, value); ++i) {</span>
<span class="line-removed"> 349                 consumeSubtypeTable(key, value, errorCode);</span>
<span class="line-removed"> 350             }</span>
<span class="line-removed"> 351         }</span>
<span class="line-removed"> 352     }</span>
<span class="line-removed"> 353 </span>
<span class="line-removed"> 354     void consumeAlias(const char *key, const ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 355         // Handle aliases like</span>
<span class="line-removed"> 356         // units:alias{&quot;/LOCALE/unitsShort&quot;}</span>
<span class="line-removed"> 357         // which should only occur in the root bundle.</span>
<span class="line-removed"> 358         UMeasureFormatWidth sourceWidth = widthFromKey(key);</span>
<span class="line-removed"> 359         if (sourceWidth == UMEASFMT_WIDTH_COUNT) {</span>
<span class="line-removed"> 360             // Alias from something we don&#39;t care about.</span>
<span class="line-removed"> 361             return;</span>
<span class="line-removed"> 362         }</span>
<span class="line-removed"> 363         UMeasureFormatWidth targetWidth = widthFromAlias(value, errorCode);</span>
<span class="line-removed"> 364         if (targetWidth == UMEASFMT_WIDTH_COUNT) {</span>
<span class="line-removed"> 365             // We do not recognize what to fall back to.</span>
<span class="line-removed"> 366             errorCode = U_INVALID_FORMAT_ERROR;</span>
<span class="line-removed"> 367             return;</span>
<span class="line-removed"> 368         }</span>
<span class="line-removed"> 369         // Check that we do not fall back to another fallback.</span>
<span class="line-removed"> 370         if (cacheData.widthFallback[targetWidth] != UMEASFMT_WIDTH_COUNT) {</span>
<span class="line-removed"> 371             errorCode = U_INVALID_FORMAT_ERROR;</span>
<span class="line-removed"> 372             return;</span>
<span class="line-removed"> 373         }</span>
<span class="line-removed"> 374         cacheData.widthFallback[sourceWidth] = targetWidth;</span>
<span class="line-removed"> 375     }</span>
<span class="line-removed"> 376 </span>
<span class="line-removed"> 377     void consumeTable(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 378         if (U_SUCCESS(errorCode) &amp;&amp; (width = widthFromKey(key)) != UMEASFMT_WIDTH_COUNT) {</span>
<span class="line-removed"> 379             ResourceTable unitTypesTable = value.getTable(errorCode);</span>
<span class="line-removed"> 380             if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 381             for (int i = 0; unitTypesTable.getKeyAndValue(i, key, value); ++i) {</span>
<span class="line-removed"> 382                 consumeUnitTypesTable(key, value, errorCode);</span>
<span class="line-removed"> 383             }</span>
<span class="line-removed"> 384         }</span>
<span class="line-removed"> 385     }</span>
<span class="line-removed"> 386 </span>
<span class="line-removed"> 387     static UMeasureFormatWidth widthFromKey(const char *key) {</span>
<span class="line-removed"> 388         if (uprv_strncmp(key, &quot;units&quot;, 5) == 0) {</span>
<span class="line-removed"> 389             key += 5;</span>
<span class="line-removed"> 390             if (*key == 0) {</span>
<span class="line-removed"> 391                 return UMEASFMT_WIDTH_WIDE;</span>
<span class="line-removed"> 392             } else if (uprv_strcmp(key, &quot;Short&quot;) == 0) {</span>
<span class="line-removed"> 393                 return UMEASFMT_WIDTH_SHORT;</span>
<span class="line-removed"> 394             } else if (uprv_strcmp(key, &quot;Narrow&quot;) == 0) {</span>
<span class="line-removed"> 395                 return UMEASFMT_WIDTH_NARROW;</span>
<span class="line-removed"> 396             }</span>
<span class="line-removed"> 397         }</span>
<span class="line-removed"> 398         return UMEASFMT_WIDTH_COUNT;</span>
<span class="line-removed"> 399     }</span>
<span class="line-removed"> 400 </span>
<span class="line-removed"> 401     static UMeasureFormatWidth widthFromAlias(const ResourceValue &amp;value, UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 402         int32_t length;</span>
<span class="line-removed"> 403         const UChar *s = value.getAliasString(length, errorCode);</span>
<span class="line-removed"> 404         // For example: &quot;/LOCALE/unitsShort&quot;</span>
<span class="line-removed"> 405         if (U_SUCCESS(errorCode) &amp;&amp; length &gt;= 13 &amp;&amp; u_memcmp(s, g_LOCALE_units, 13) == 0) {</span>
<span class="line-removed"> 406             s += 13;</span>
<span class="line-removed"> 407             length -= 13;</span>
<span class="line-removed"> 408             if (*s == 0) {</span>
<span class="line-removed"> 409                 return UMEASFMT_WIDTH_WIDE;</span>
<span class="line-removed"> 410             } else if (u_strCompare(s, length, gShort, 5, FALSE) == 0) {</span>
<span class="line-removed"> 411                 return UMEASFMT_WIDTH_SHORT;</span>
<span class="line-removed"> 412             } else if (u_strCompare(s, length, gNarrow, 6, FALSE) == 0) {</span>
<span class="line-removed"> 413                 return UMEASFMT_WIDTH_NARROW;</span>
<span class="line-removed"> 414             }</span>
<span class="line-removed"> 415         }</span>
<span class="line-removed"> 416         return UMEASFMT_WIDTH_COUNT;</span>
<span class="line-removed"> 417     }</span>
<span class="line-removed"> 418 </span>
<span class="line-removed"> 419     virtual void put(const char *key, ResourceValue &amp;value, UBool /*noFallback*/,</span>
<span class="line-removed"> 420             UErrorCode &amp;errorCode) {</span>
<span class="line-removed"> 421         // Main entry point to sink</span>
<span class="line-removed"> 422         ResourceTable widthsTable = value.getTable(errorCode);</span>
<span class="line-removed"> 423         if (U_FAILURE(errorCode)) { return; }</span>
<span class="line-removed"> 424         for (int i = 0; widthsTable.getKeyAndValue(i, key, value); ++i) {</span>
<span class="line-removed"> 425             if (value.getType() == URES_ALIAS) {</span>
<span class="line-removed"> 426                 consumeAlias(key, value, errorCode);</span>
<span class="line-removed"> 427             } else {</span>
<span class="line-removed"> 428                 consumeTable(key, value, errorCode);</span>
<span class="line-removed"> 429             }</span>
<span class="line-removed"> 430         }</span>
<span class="line-removed"> 431     }</span>
<span class="line-removed"> 432 };</span>
<span class="line-removed"> 433 </span>
<span class="line-removed"> 434 // Virtual destructors must be defined out of line.</span>
<span class="line-removed"> 435 UnitDataSink::~UnitDataSink() {}</span>
<span class="line-removed"> 436 </span>
<span class="line-removed"> 437 }  // namespace</span>
<span class="line-removed"> 438 </span>
<span class="line-removed"> 439 static UBool loadMeasureUnitData(</span>
<span class="line-removed"> 440         const UResourceBundle *resource,</span>
<span class="line-removed"> 441         MeasureFormatCacheData &amp;cacheData,</span>
<span class="line-removed"> 442         UErrorCode &amp;status) {</span>
<span class="line-removed"> 443     UnitDataSink sink(cacheData);</span>
<span class="line-removed"> 444     ures_getAllItemsWithFallback(resource, &quot;&quot;, sink, status);</span>
<span class="line-removed"> 445     return U_SUCCESS(status);</span>
<span class="line-removed"> 446 }</span>
<span class="line-removed"> 447 </span>
 448 static UnicodeString loadNumericDateFormatterPattern(
 449         const UResourceBundle *resource,
 450         const char *pattern,
 451         UErrorCode &amp;status) {
 452     UnicodeString result;
 453     if (U_FAILURE(status)) {
 454         return result;
 455     }
 456     CharString chs;
 457     chs.append(&quot;durationUnits&quot;, status)
 458             .append(&quot;/&quot;, status).append(pattern, status);
 459     LocalUResourceBundlePointer patternBundle(
 460             ures_getByKeyWithFallback(
 461                 resource,
 462                 chs.data(),
 463                 NULL,
 464                 &amp;status));
 465     if (U_FAILURE(status)) {
 466         return result;
 467     }
 468     getString(patternBundle.getAlias(), result, status);
 469     // Replace &#39;h&#39; with &#39;H&#39;
 470     int32_t len = result.length();
 471     UChar *buffer = result.getBuffer(len);
 472     for (int32_t i = 0; i &lt; len; ++i) {
 473         if (buffer[i] == 0x68) { // &#39;h&#39;
 474             buffer[i] = 0x48; // &#39;H&#39;
 475         }
 476     }
 477     result.releaseBuffer(len);
 478     return result;
 479 }
 480 
 481 static NumericDateFormatters *loadNumericDateFormatters(
 482         const UResourceBundle *resource,
 483         UErrorCode &amp;status) {
 484     if (U_FAILURE(status)) {
 485         return NULL;
 486     }
 487     NumericDateFormatters *result = new NumericDateFormatters(
 488         loadNumericDateFormatterPattern(resource, &quot;hm&quot;, status),
 489         loadNumericDateFormatterPattern(resource, &quot;ms&quot;, status),
 490         loadNumericDateFormatterPattern(resource, &quot;hms&quot;, status),
 491         status);
 492     if (U_FAILURE(status)) {
 493         delete result;
 494         return NULL;
 495     }
 496     return result;
 497 }
 498 
 499 template&lt;&gt; U_I18N_API
 500 const MeasureFormatCacheData *LocaleCacheKey&lt;MeasureFormatCacheData&gt;::createObject(
 501         const void * /*unused*/, UErrorCode &amp;status) const {
 502     const char *localeId = fLoc.getName();
 503     LocalUResourceBundlePointer unitsBundle(ures_open(U_ICUDATA_UNIT, localeId, &amp;status));
 504     static UNumberFormatStyle currencyStyles[] = {
 505             UNUM_CURRENCY_PLURAL, UNUM_CURRENCY_ISO, UNUM_CURRENCY};
 506     LocalPointer&lt;MeasureFormatCacheData&gt; result(new MeasureFormatCacheData(), status);
 507     if (U_FAILURE(status)) {
 508         return NULL;
 509     }
<a name="10" id="anc10"></a><span class="line-removed"> 510     if (!loadMeasureUnitData(</span>
<span class="line-removed"> 511             unitsBundle.getAlias(),</span>
<span class="line-removed"> 512             *result,</span>
<span class="line-removed"> 513             status)) {</span>
<span class="line-removed"> 514         return NULL;</span>
<span class="line-removed"> 515     }</span>
 516     result-&gt;adoptNumericDateFormatters(loadNumericDateFormatters(
 517             unitsBundle.getAlias(), status));
 518     if (U_FAILURE(status)) {
 519         return NULL;
 520     }
 521 
 522     for (int32_t i = 0; i &lt; WIDTH_INDEX_COUNT; ++i) {
 523         // NumberFormat::createInstance can erase warning codes from status, so pass it
 524         // a separate status instance
 525         UErrorCode localStatus = U_ZERO_ERROR;
 526         result-&gt;adoptCurrencyFormat(i, NumberFormat::createInstance(
 527                 localeId, currencyStyles[i], localStatus));
 528         if (localStatus != U_ZERO_ERROR) {
 529             status = localStatus;
 530         }
 531         if (U_FAILURE(status)) {
 532             return NULL;
 533         }
 534     }
 535     NumberFormat *inf = NumberFormat::createInstance(
 536             localeId, UNUM_DECIMAL, status);
 537     if (U_FAILURE(status)) {
 538         return NULL;
 539     }
 540     inf-&gt;setMaximumFractionDigits(0);
 541     DecimalFormat *decfmt = dynamic_cast&lt;DecimalFormat *&gt;(inf);
 542     if (decfmt != NULL) {
 543         decfmt-&gt;setRoundingMode(DecimalFormat::kRoundDown);
 544     }
 545     result-&gt;adoptIntegerFormat(inf);
 546     result-&gt;addRef();
 547     return result.orphan();
 548 }
 549 
 550 static UBool isTimeUnit(const MeasureUnit &amp;mu, const char *tu) {
 551     return uprv_strcmp(mu.getType(), &quot;duration&quot;) == 0 &amp;&amp;
 552             uprv_strcmp(mu.getSubtype(), tu) == 0;
 553 }
 554 
 555 // Converts a composite measure into hours-minutes-seconds and stores at hms
 556 // array. [0] is hours; [1] is minutes; [2] is seconds. Returns a bit map of
 557 // units found: 1=hours, 2=minutes, 4=seconds. For example, if measures
 558 // contains hours-minutes, this function would return 3.
 559 //
 560 // If measures cannot be converted into hours, minutes, seconds or if amounts
 561 // are negative, or if hours, minutes, seconds are out of order, returns 0.
 562 static int32_t toHMS(
 563         const Measure *measures,
 564         int32_t measureCount,
 565         Formattable *hms,
 566         UErrorCode &amp;status) {
 567     if (U_FAILURE(status)) {
 568         return 0;
 569     }
 570     int32_t result = 0;
 571     if (U_FAILURE(status)) {
 572         return 0;
 573     }
 574     // We use copy constructor to ensure that both sides of equality operator
 575     // are instances of MeasureUnit base class and not a subclass. Otherwise,
 576     // operator== will immediately return false.
 577     for (int32_t i = 0; i &lt; measureCount; ++i) {
 578         if (isTimeUnit(measures[i].getUnit(), &quot;hour&quot;)) {
 579             // hour must come first
 580             if (result &gt;= 1) {
 581                 return 0;
 582             }
 583             hms[0] = measures[i].getNumber();
 584             if (hms[0].getDouble() &lt; 0.0) {
 585                 return 0;
 586             }
 587             result |= 1;
 588         } else if (isTimeUnit(measures[i].getUnit(), &quot;minute&quot;)) {
 589             // minute must come after hour
 590             if (result &gt;= 2) {
 591                 return 0;
 592             }
 593             hms[1] = measures[i].getNumber();
 594             if (hms[1].getDouble() &lt; 0.0) {
 595                 return 0;
 596             }
 597             result |= 2;
 598         } else if (isTimeUnit(measures[i].getUnit(), &quot;second&quot;)) {
 599             // second must come after hour and minute
 600             if (result &gt;= 4) {
 601                 return 0;
 602             }
 603             hms[2] = measures[i].getNumber();
 604             if (hms[2].getDouble() &lt; 0.0) {
 605                 return 0;
 606             }
 607             result |= 4;
 608         } else {
 609             return 0;
 610         }
 611     }
 612     return result;
 613 }
 614 
 615 
 616 MeasureFormat::MeasureFormat(
 617         const Locale &amp;locale, UMeasureFormatWidth w, UErrorCode &amp;status)
 618         : cache(NULL),
 619           numberFormat(NULL),
 620           pluralRules(NULL),
<a name="11" id="anc11"></a><span class="line-modified"> 621           width(w),</span>
 622           listFormatter(NULL) {
 623     initMeasureFormat(locale, w, NULL, status);
 624 }
 625 
 626 MeasureFormat::MeasureFormat(
 627         const Locale &amp;locale,
 628         UMeasureFormatWidth w,
 629         NumberFormat *nfToAdopt,
 630         UErrorCode &amp;status)
 631         : cache(NULL),
 632           numberFormat(NULL),
 633           pluralRules(NULL),
<a name="12" id="anc12"></a><span class="line-modified"> 634           width(w),</span>
 635           listFormatter(NULL) {
 636     initMeasureFormat(locale, w, nfToAdopt, status);
 637 }
 638 
 639 MeasureFormat::MeasureFormat(const MeasureFormat &amp;other) :
 640         Format(other),
 641         cache(other.cache),
 642         numberFormat(other.numberFormat),
 643         pluralRules(other.pluralRules),
<a name="13" id="anc13"></a><span class="line-modified"> 644         width(other.width),</span>
 645         listFormatter(NULL) {
 646     cache-&gt;addRef();
 647     numberFormat-&gt;addRef();
 648     pluralRules-&gt;addRef();
 649     if (other.listFormatter != NULL) {
 650         listFormatter = new ListFormatter(*other.listFormatter);
 651     }
 652 }
 653 
 654 MeasureFormat &amp;MeasureFormat::operator=(const MeasureFormat &amp;other) {
 655     if (this == &amp;other) {
 656         return *this;
 657     }
 658     Format::operator=(other);
 659     SharedObject::copyPtr(other.cache, cache);
 660     SharedObject::copyPtr(other.numberFormat, numberFormat);
 661     SharedObject::copyPtr(other.pluralRules, pluralRules);
<a name="14" id="anc14"></a><span class="line-modified"> 662     width = other.width;</span>
 663     delete listFormatter;
 664     if (other.listFormatter != NULL) {
 665         listFormatter = new ListFormatter(*other.listFormatter);
 666     } else {
 667         listFormatter = NULL;
 668     }
 669     return *this;
 670 }
 671 
 672 MeasureFormat::MeasureFormat() :
 673         cache(NULL),
 674         numberFormat(NULL),
 675         pluralRules(NULL),
<a name="15" id="anc15"></a><span class="line-modified"> 676         width(UMEASFMT_WIDTH_SHORT),</span>
 677         listFormatter(NULL) {
 678 }
 679 
 680 MeasureFormat::~MeasureFormat() {
 681     if (cache != NULL) {
 682         cache-&gt;removeRef();
 683     }
 684     if (numberFormat != NULL) {
 685         numberFormat-&gt;removeRef();
 686     }
 687     if (pluralRules != NULL) {
 688         pluralRules-&gt;removeRef();
 689     }
 690     delete listFormatter;
 691 }
 692 
 693 UBool MeasureFormat::operator==(const Format &amp;other) const {
 694     if (this == &amp;other) { // Same object, equal
 695         return TRUE;
 696     }
 697     if (!Format::operator==(other)) {
 698         return FALSE;
 699     }
 700     const MeasureFormat &amp;rhs = static_cast&lt;const MeasureFormat &amp;&gt;(other);
 701 
 702     // Note: Since the ListFormatter depends only on Locale and width, we
 703     // don&#39;t have to check it here.
 704 
 705     // differing widths aren&#39;t equivalent
<a name="16" id="anc16"></a><span class="line-modified"> 706     if (width != rhs.width) {</span>
 707         return FALSE;
 708     }
 709     // Width the same check locales.
 710     // We don&#39;t need to check locales if both objects have same cache.
 711     if (cache != rhs.cache) {
 712         UErrorCode status = U_ZERO_ERROR;
 713         const char *localeId = getLocaleID(status);
 714         const char *rhsLocaleId = rhs.getLocaleID(status);
 715         if (U_FAILURE(status)) {
 716             // On failure, assume not equal
 717             return FALSE;
 718         }
 719         if (uprv_strcmp(localeId, rhsLocaleId) != 0) {
 720             return FALSE;
 721         }
 722     }
 723     // Locales same, check NumberFormat if shared data differs.
 724     return (
 725             numberFormat == rhs.numberFormat ||
 726             **numberFormat == **rhs.numberFormat);
 727 }
 728 
 729 Format *MeasureFormat::clone() const {
 730     return new MeasureFormat(*this);
 731 }
 732 
 733 UnicodeString &amp;MeasureFormat::format(
 734         const Formattable &amp;obj,
 735         UnicodeString &amp;appendTo,
 736         FieldPosition &amp;pos,
 737         UErrorCode &amp;status) const {
 738     if (U_FAILURE(status)) return appendTo;
 739     if (obj.getType() == Formattable::kObject) {
 740         const UObject* formatObj = obj.getObject();
 741         const Measure* amount = dynamic_cast&lt;const Measure*&gt;(formatObj);
 742         if (amount != NULL) {
 743             return formatMeasure(
 744                     *amount, **numberFormat, appendTo, pos, status);
 745         }
 746     }
 747     status = U_ILLEGAL_ARGUMENT_ERROR;
 748     return appendTo;
 749 }
 750 
 751 void MeasureFormat::parseObject(
 752         const UnicodeString &amp; /*source*/,
 753         Formattable &amp; /*result*/,
 754         ParsePosition&amp; /*pos*/) const {
 755     return;
 756 }
 757 
 758 UnicodeString &amp;MeasureFormat::formatMeasurePerUnit(
 759         const Measure &amp;measure,
 760         const MeasureUnit &amp;perUnit,
 761         UnicodeString &amp;appendTo,
 762         FieldPosition &amp;pos,
 763         UErrorCode &amp;status) const {
 764     if (U_FAILURE(status)) {
 765         return appendTo;
 766     }
<a name="17" id="anc17"></a><span class="line-modified"> 767     bool isResolved = false;</span>
<span class="line-modified"> 768     MeasureUnit resolvedUnit =</span>
<span class="line-modified"> 769         MeasureUnit::resolveUnitPerUnit(measure.getUnit(), perUnit, &amp;isResolved);</span>
<span class="line-modified"> 770     if (isResolved) {</span>
<span class="line-removed"> 771         Measure newMeasure(measure.getNumber(), new MeasureUnit(resolvedUnit), status);</span>
<span class="line-removed"> 772         return formatMeasure(</span>
<span class="line-removed"> 773                 newMeasure, **numberFormat, appendTo, pos, status);</span>
<span class="line-removed"> 774     }</span>
<span class="line-removed"> 775     FieldPosition fpos(pos.getField());</span>
<span class="line-removed"> 776     UnicodeString result;</span>
<span class="line-removed"> 777     int32_t offset = withPerUnitAndAppend(</span>
<span class="line-removed"> 778             formatMeasure(</span>
<span class="line-removed"> 779                     measure, **numberFormat, result, fpos, status),</span>
<span class="line-removed"> 780             perUnit,</span>
<span class="line-removed"> 781             appendTo,</span>
<span class="line-removed"> 782             status);</span>
<span class="line-removed"> 783     if (U_FAILURE(status)) {</span>
 784         return appendTo;
 785     }
<a name="18" id="anc18"></a><span class="line-modified"> 786     if (fpos.getBeginIndex() != 0 || fpos.getEndIndex() != 0) {</span>
<span class="line-modified"> 787         pos.setBeginIndex(fpos.getBeginIndex() + offset);</span>
<span class="line-modified"> 788         pos.setEndIndex(fpos.getEndIndex() + offset);</span>



 789     }
<a name="19" id="anc19"></a>

 790     return appendTo;
 791 }
 792 
 793 UnicodeString &amp;MeasureFormat::formatMeasures(
 794         const Measure *measures,
 795         int32_t measureCount,
 796         UnicodeString &amp;appendTo,
 797         FieldPosition &amp;pos,
 798         UErrorCode &amp;status) const {
 799     if (U_FAILURE(status)) {
 800         return appendTo;
 801     }
 802     if (measureCount == 0) {
 803         return appendTo;
 804     }
 805     if (measureCount == 1) {
 806         return formatMeasure(measures[0], **numberFormat, appendTo, pos, status);
 807     }
<a name="20" id="anc20"></a><span class="line-modified"> 808     if (width == UMEASFMT_WIDTH_NUMERIC) {</span>
 809         Formattable hms[3];
 810         int32_t bitMap = toHMS(measures, measureCount, hms, status);
 811         if (bitMap &gt; 0) {
 812             return formatNumeric(hms, bitMap, appendTo, status);
 813         }
 814     }
 815     if (pos.getField() != FieldPosition::DONT_CARE) {
 816         return formatMeasuresSlowTrack(
 817                 measures, measureCount, appendTo, pos, status);
 818     }
 819     UnicodeString *results = new UnicodeString[measureCount];
 820     if (results == NULL) {
 821         status = U_MEMORY_ALLOCATION_ERROR;
 822         return appendTo;
 823     }
 824     for (int32_t i = 0; i &lt; measureCount; ++i) {
 825         const NumberFormat *nf = cache-&gt;getIntegerFormat();
 826         if (i == measureCount - 1) {
 827             nf = numberFormat-&gt;get();
 828         }
 829         formatMeasure(
 830                 measures[i],
 831                 *nf,
 832                 results[i],
 833                 pos,
 834                 status);
 835     }
 836     listFormatter-&gt;format(results, measureCount, appendTo, status);
 837     delete [] results;
 838     return appendTo;
 839 }
 840 
<a name="21" id="anc21"></a><span class="line-modified"> 841 UnicodeString MeasureFormat::getUnitDisplayName(const MeasureUnit&amp; unit, UErrorCode&amp; /*status*/) const {</span>
<span class="line-modified"> 842     UMeasureFormatWidth width = getRegularWidth(this-&gt;width);</span>
<span class="line-modified"> 843     const UChar* const* styleToDnam = cache-&gt;dnams[unit.getIndex()];</span>
<span class="line-modified"> 844     const UChar* dnam = styleToDnam[width];</span>
<span class="line-modified"> 845     if (dnam == NULL) {</span>
<span class="line-modified"> 846         int32_t fallbackWidth = cache-&gt;widthFallback[width];</span>
<span class="line-removed"> 847         dnam = styleToDnam[fallbackWidth];</span>
<span class="line-removed"> 848     }</span>
<span class="line-removed"> 849 </span>
<span class="line-removed"> 850     UnicodeString result;</span>
<span class="line-removed"> 851     if (dnam == NULL) {</span>
<span class="line-removed"> 852         result.setToBogus();</span>
<span class="line-removed"> 853     } else {</span>
<span class="line-removed"> 854         result.setTo(dnam, -1);</span>
<span class="line-removed"> 855     }</span>
<span class="line-removed"> 856     return result;</span>
 857 }
 858 
 859 void MeasureFormat::initMeasureFormat(
 860         const Locale &amp;locale,
 861         UMeasureFormatWidth w,
 862         NumberFormat *nfToAdopt,
 863         UErrorCode &amp;status) {
 864     static const char *listStyles[] = {&quot;unit&quot;, &quot;unit-short&quot;, &quot;unit-narrow&quot;};
 865     LocalPointer&lt;NumberFormat&gt; nf(nfToAdopt);
 866     if (U_FAILURE(status)) {
 867         return;
 868     }
 869     const char *name = locale.getName();
 870     setLocaleIDs(name, name);
 871 
 872     UnifiedCache::getByLocale(locale, cache, status);
 873     if (U_FAILURE(status)) {
 874         return;
 875     }
 876 
 877     const SharedPluralRules *pr = PluralRules::createSharedInstance(
 878             locale, UPLURAL_TYPE_CARDINAL, status);
 879     if (U_FAILURE(status)) {
 880         return;
 881     }
 882     SharedObject::copyPtr(pr, pluralRules);
 883     pr-&gt;removeRef();
 884     if (nf.isNull()) {
<a name="22" id="anc22"></a>
 885         const SharedNumberFormat *shared = NumberFormat::createSharedInstance(
 886                 locale, UNUM_DECIMAL, status);
 887         if (U_FAILURE(status)) {
 888             return;
 889         }
 890         SharedObject::copyPtr(shared, numberFormat);
 891         shared-&gt;removeRef();
 892     } else {
 893         adoptNumberFormat(nf.orphan(), status);
 894         if (U_FAILURE(status)) {
 895             return;
 896         }
 897     }
<a name="23" id="anc23"></a><span class="line-modified"> 898     width = w;</span>
 899     delete listFormatter;
 900     listFormatter = ListFormatter::createInstance(
 901             locale,
<a name="24" id="anc24"></a><span class="line-modified"> 902             listStyles[getRegularWidth(width)],</span>
 903             status);
 904 }
 905 
 906 void MeasureFormat::adoptNumberFormat(
 907         NumberFormat *nfToAdopt, UErrorCode &amp;status) {
 908     LocalPointer&lt;NumberFormat&gt; nf(nfToAdopt);
 909     if (U_FAILURE(status)) {
 910         return;
 911     }
 912     SharedNumberFormat *shared = new SharedNumberFormat(nf.getAlias());
 913     if (shared == NULL) {
 914         status = U_MEMORY_ALLOCATION_ERROR;
 915         return;
 916     }
 917     nf.orphan();
 918     SharedObject::copyPtr(shared, numberFormat);
 919 }
 920 
 921 UBool MeasureFormat::setMeasureFormatLocale(const Locale &amp;locale, UErrorCode &amp;status) {
 922     if (U_FAILURE(status) || locale == getLocale(status)) {
 923         return FALSE;
 924     }
<a name="25" id="anc25"></a><span class="line-modified"> 925     initMeasureFormat(locale, width, NULL, status);</span>
 926     return U_SUCCESS(status);
 927 }
 928 
<a name="26" id="anc26"></a><span class="line-modified"> 929 const NumberFormat &amp;MeasureFormat::getNumberFormat() const {</span>
 930     return **numberFormat;
 931 }
 932 
<a name="27" id="anc27"></a>



 933 const PluralRules &amp;MeasureFormat::getPluralRules() const {
 934     return **pluralRules;
 935 }
 936 
 937 Locale MeasureFormat::getLocale(UErrorCode &amp;status) const {
 938     return Format::getLocale(ULOC_VALID_LOCALE, status);
 939 }
 940 
 941 const char *MeasureFormat::getLocaleID(UErrorCode &amp;status) const {
 942     return Format::getLocaleID(ULOC_VALID_LOCALE, status);
 943 }
 944 
 945 UnicodeString &amp;MeasureFormat::formatMeasure(
 946         const Measure &amp;measure,
 947         const NumberFormat &amp;nf,
 948         UnicodeString &amp;appendTo,
 949         FieldPosition &amp;pos,
 950         UErrorCode &amp;status) const {
 951     if (U_FAILURE(status)) {
 952         return appendTo;
 953     }
 954     const Formattable&amp; amtNumber = measure.getNumber();
 955     const MeasureUnit&amp; amtUnit = measure.getUnit();
 956     if (isCurrency(amtUnit)) {
 957         UChar isoCode[4];
 958         u_charsToUChars(amtUnit.getSubtype(), isoCode, 4);
<a name="28" id="anc28"></a><span class="line-modified"> 959         return cache-&gt;getCurrencyFormat(width)-&gt;format(</span>
 960                 new CurrencyAmount(amtNumber, isoCode, status),
 961                 appendTo,
 962                 pos,
 963                 status);
 964     }
<a name="29" id="anc29"></a><span class="line-modified"> 965     UnicodeString formattedNumber;</span>
<span class="line-modified"> 966     StandardPlural::Form pluralForm = QuantityFormatter::selectPlural(</span>
<span class="line-modified"> 967             amtNumber, nf, **pluralRules, formattedNumber, pos, status);</span>
<span class="line-modified"> 968     const SimpleFormatter *formatter = getPluralFormatter(amtUnit, width, pluralForm, status);</span>
<span class="line-modified"> 969     return QuantityFormatter::format(*formatter, formattedNumber, appendTo, pos, status);</span>










 970 }
 971 
 972 // Formats hours-minutes-seconds as 5:37:23 or similar.
 973 UnicodeString &amp;MeasureFormat::formatNumeric(
 974         const Formattable *hms,  // always length 3
 975         int32_t bitMap,   // 1=hourset, 2=minuteset, 4=secondset
 976         UnicodeString &amp;appendTo,
 977         UErrorCode &amp;status) const {
 978     if (U_FAILURE(status)) {
 979         return appendTo;
 980     }
 981     UDate millis =
 982         (UDate) (((uprv_trunc(hms[0].getDouble(status)) * 60.0
 983              + uprv_trunc(hms[1].getDouble(status))) * 60.0
 984                   + uprv_trunc(hms[2].getDouble(status))) * 1000.0);
 985     switch (bitMap) {
 986     case 5: // hs
 987     case 7: // hms
 988         return formatNumeric(
 989                 millis,
 990                 cache-&gt;getNumericDateFormatters()-&gt;hourMinuteSecond,
 991                 UDAT_SECOND_FIELD,
 992                 hms[2],
 993                 appendTo,
 994                 status);
 995         break;
 996     case 6: // ms
 997         return formatNumeric(
 998                 millis,
 999                 cache-&gt;getNumericDateFormatters()-&gt;minuteSecond,
1000                 UDAT_SECOND_FIELD,
1001                 hms[2],
1002                 appendTo,
1003                 status);
1004         break;
1005     case 3: // hm
1006         return formatNumeric(
1007                 millis,
1008                 cache-&gt;getNumericDateFormatters()-&gt;hourMinute,
1009                 UDAT_MINUTE_FIELD,
1010                 hms[1],
1011                 appendTo,
1012                 status);
1013         break;
1014     default:
1015         status = U_INTERNAL_PROGRAM_ERROR;
1016         return appendTo;
1017         break;
1018     }
<a name="30" id="anc30"></a><span class="line-removed">1019     return appendTo;</span>
1020 }
1021 
1022 static void appendRange(
1023         const UnicodeString &amp;src,
1024         int32_t start,
1025         int32_t end,
1026         UnicodeString &amp;dest) {
1027     dest.append(src, start, end - start);
1028 }
1029 
1030 static void appendRange(
1031         const UnicodeString &amp;src,
1032         int32_t end,
1033         UnicodeString &amp;dest) {
1034     dest.append(src, end, src.length() - end);
1035 }
1036 
1037 // Formats time like 5:37:23
1038 UnicodeString &amp;MeasureFormat::formatNumeric(
1039         UDate date, // Time since epoch 1:30:00 would be 5400000
1040         const DateFormat &amp;dateFmt, // h:mm, m:ss, or h:mm:ss
1041         UDateFormatField smallestField, // seconds in 5:37:23.5
1042         const Formattable &amp;smallestAmount, // 23.5 for 5:37:23.5
1043         UnicodeString &amp;appendTo,
1044         UErrorCode &amp;status) const {
1045     if (U_FAILURE(status)) {
1046         return appendTo;
1047     }
1048     // Format the smallest amount with this object&#39;s NumberFormat
1049     UnicodeString smallestAmountFormatted;
1050 
1051     // We keep track of the integer part of smallest amount so that
1052     // we can replace it later so that we get &#39;0:00:09.3&#39; instead of
1053     // &#39;0:00:9.3&#39;
1054     FieldPosition intFieldPosition(UNUM_INTEGER_FIELD);
1055     (*numberFormat)-&gt;format(
1056             smallestAmount, smallestAmountFormatted, intFieldPosition, status);
1057     if (
1058             intFieldPosition.getBeginIndex() == 0 &amp;&amp;
1059             intFieldPosition.getEndIndex() == 0) {
1060         status = U_INTERNAL_PROGRAM_ERROR;
1061         return appendTo;
1062     }
1063 
1064     // Format time. draft becomes something like &#39;5:30:45&#39;
1065     // #13606: DateFormat is not thread-safe, but MeasureFormat advertises itself as thread-safe.
1066     FieldPosition smallestFieldPosition(smallestField);
1067     UnicodeString draft;
1068     static UMutex dateFmtMutex = U_MUTEX_INITIALIZER;
1069     umtx_lock(&amp;dateFmtMutex);
1070     dateFmt.format(date, draft, smallestFieldPosition, status);
1071     umtx_unlock(&amp;dateFmtMutex);
1072 
1073     // If we find field for smallest amount replace it with the formatted
1074     // smallest amount from above taking care to replace the integer part
1075     // with what is in original time. For example, If smallest amount
1076     // is 9.35s and the formatted time is 0:00:09 then 9.35 becomes 09.35
1077     // and replacing yields 0:00:09.35
1078     if (smallestFieldPosition.getBeginIndex() != 0 ||
1079             smallestFieldPosition.getEndIndex() != 0) {
1080         appendRange(draft, 0, smallestFieldPosition.getBeginIndex(), appendTo);
1081         appendRange(
1082                 smallestAmountFormatted,
1083                 0,
1084                 intFieldPosition.getBeginIndex(),
1085                 appendTo);
1086         appendRange(
1087                 draft,
1088                 smallestFieldPosition.getBeginIndex(),
1089                 smallestFieldPosition.getEndIndex(),
1090                 appendTo);
1091         appendRange(
1092                 smallestAmountFormatted,
1093                 intFieldPosition.getEndIndex(),
1094                 appendTo);
1095         appendRange(
1096                 draft,
1097                 smallestFieldPosition.getEndIndex(),
1098                 appendTo);
1099     } else {
1100         appendTo.append(draft);
1101     }
1102     return appendTo;
1103 }
1104 
<a name="31" id="anc31"></a><span class="line-removed">1105 const SimpleFormatter *MeasureFormat::getFormatterOrNull(</span>
<span class="line-removed">1106         const MeasureUnit &amp;unit, UMeasureFormatWidth width, int32_t index) const {</span>
<span class="line-removed">1107     width = getRegularWidth(width);</span>
<span class="line-removed">1108     SimpleFormatter *const (*unitPatterns)[PATTERN_COUNT] = &amp;cache-&gt;patterns[unit.getIndex()][0];</span>
<span class="line-removed">1109     if (unitPatterns[width][index] != NULL) {</span>
<span class="line-removed">1110         return unitPatterns[width][index];</span>
<span class="line-removed">1111     }</span>
<span class="line-removed">1112     int32_t fallbackWidth = cache-&gt;widthFallback[width];</span>
<span class="line-removed">1113     if (fallbackWidth != UMEASFMT_WIDTH_COUNT &amp;&amp; unitPatterns[fallbackWidth][index] != NULL) {</span>
<span class="line-removed">1114         return unitPatterns[fallbackWidth][index];</span>
<span class="line-removed">1115     }</span>
<span class="line-removed">1116     return NULL;</span>
<span class="line-removed">1117 }</span>
<span class="line-removed">1118 </span>
<span class="line-removed">1119 const SimpleFormatter *MeasureFormat::getFormatter(</span>
<span class="line-removed">1120         const MeasureUnit &amp;unit, UMeasureFormatWidth width, int32_t index,</span>
<span class="line-removed">1121         UErrorCode &amp;errorCode) const {</span>
<span class="line-removed">1122     if (U_FAILURE(errorCode)) {</span>
<span class="line-removed">1123         return NULL;</span>
<span class="line-removed">1124     }</span>
<span class="line-removed">1125     const SimpleFormatter *pattern = getFormatterOrNull(unit, width, index);</span>
<span class="line-removed">1126     if (pattern == NULL) {</span>
<span class="line-removed">1127         errorCode = U_MISSING_RESOURCE_ERROR;</span>
<span class="line-removed">1128     }</span>
<span class="line-removed">1129     return pattern;</span>
<span class="line-removed">1130 }</span>
<span class="line-removed">1131 </span>
<span class="line-removed">1132 const SimpleFormatter *MeasureFormat::getPluralFormatter(</span>
<span class="line-removed">1133         const MeasureUnit &amp;unit, UMeasureFormatWidth width, int32_t index,</span>
<span class="line-removed">1134         UErrorCode &amp;errorCode) const {</span>
<span class="line-removed">1135     if (U_FAILURE(errorCode)) {</span>
<span class="line-removed">1136         return NULL;</span>
<span class="line-removed">1137     }</span>
<span class="line-removed">1138     if (index != StandardPlural::OTHER) {</span>
<span class="line-removed">1139         const SimpleFormatter *pattern = getFormatterOrNull(unit, width, index);</span>
<span class="line-removed">1140         if (pattern != NULL) {</span>
<span class="line-removed">1141             return pattern;</span>
<span class="line-removed">1142         }</span>
<span class="line-removed">1143     }</span>
<span class="line-removed">1144     return getFormatter(unit, width, StandardPlural::OTHER, errorCode);</span>
<span class="line-removed">1145 }</span>
<span class="line-removed">1146 </span>
<span class="line-removed">1147 const SimpleFormatter *MeasureFormat::getPerFormatter(</span>
<span class="line-removed">1148         UMeasureFormatWidth width,</span>
<span class="line-removed">1149         UErrorCode &amp;status) const {</span>
<span class="line-removed">1150     if (U_FAILURE(status)) {</span>
<span class="line-removed">1151         return NULL;</span>
<span class="line-removed">1152     }</span>
<span class="line-removed">1153     width = getRegularWidth(width);</span>
<span class="line-removed">1154     const SimpleFormatter * perFormatters = cache-&gt;perFormatters;</span>
<span class="line-removed">1155     if (perFormatters[width].getArgumentLimit() == 2) {</span>
<span class="line-removed">1156         return &amp;perFormatters[width];</span>
<span class="line-removed">1157     }</span>
<span class="line-removed">1158     int32_t fallbackWidth = cache-&gt;widthFallback[width];</span>
<span class="line-removed">1159     if (fallbackWidth != UMEASFMT_WIDTH_COUNT &amp;&amp;</span>
<span class="line-removed">1160             perFormatters[fallbackWidth].getArgumentLimit() == 2) {</span>
<span class="line-removed">1161         return &amp;perFormatters[fallbackWidth];</span>
<span class="line-removed">1162     }</span>
<span class="line-removed">1163     status = U_MISSING_RESOURCE_ERROR;</span>
<span class="line-removed">1164     return NULL;</span>
<span class="line-removed">1165 }</span>
<span class="line-removed">1166 </span>
<span class="line-removed">1167 int32_t MeasureFormat::withPerUnitAndAppend(</span>
<span class="line-removed">1168         const UnicodeString &amp;formatted,</span>
<span class="line-removed">1169         const MeasureUnit &amp;perUnit,</span>
<span class="line-removed">1170         UnicodeString &amp;appendTo,</span>
<span class="line-removed">1171         UErrorCode &amp;status) const {</span>
<span class="line-removed">1172     int32_t offset = -1;</span>
<span class="line-removed">1173     if (U_FAILURE(status)) {</span>
<span class="line-removed">1174         return offset;</span>
<span class="line-removed">1175     }</span>
<span class="line-removed">1176     const SimpleFormatter *perUnitFormatter = getFormatterOrNull(perUnit, width, PER_UNIT_INDEX);</span>
<span class="line-removed">1177     if (perUnitFormatter != NULL) {</span>
<span class="line-removed">1178         const UnicodeString *params[] = {&amp;formatted};</span>
<span class="line-removed">1179         perUnitFormatter-&gt;formatAndAppend(</span>
<span class="line-removed">1180                 params,</span>
<span class="line-removed">1181                 UPRV_LENGTHOF(params),</span>
<span class="line-removed">1182                 appendTo,</span>
<span class="line-removed">1183                 &amp;offset,</span>
<span class="line-removed">1184                 1,</span>
<span class="line-removed">1185                 status);</span>
<span class="line-removed">1186         return offset;</span>
<span class="line-removed">1187     }</span>
<span class="line-removed">1188     const SimpleFormatter *perFormatter = getPerFormatter(width, status);</span>
<span class="line-removed">1189     const SimpleFormatter *pattern =</span>
<span class="line-removed">1190             getPluralFormatter(perUnit, width, StandardPlural::ONE, status);</span>
<span class="line-removed">1191     if (U_FAILURE(status)) {</span>
<span class="line-removed">1192         return offset;</span>
<span class="line-removed">1193     }</span>
<span class="line-removed">1194     UnicodeString perUnitString = pattern-&gt;getTextWithNoArguments();</span>
<span class="line-removed">1195     perUnitString.trim();</span>
<span class="line-removed">1196     const UnicodeString *params[] = {&amp;formatted, &amp;perUnitString};</span>
<span class="line-removed">1197     perFormatter-&gt;formatAndAppend(</span>
<span class="line-removed">1198             params,</span>
<span class="line-removed">1199             UPRV_LENGTHOF(params),</span>
<span class="line-removed">1200             appendTo,</span>
<span class="line-removed">1201             &amp;offset,</span>
<span class="line-removed">1202             1,</span>
<span class="line-removed">1203             status);</span>
<span class="line-removed">1204     return offset;</span>
<span class="line-removed">1205 }</span>
<span class="line-removed">1206 </span>
1207 UnicodeString &amp;MeasureFormat::formatMeasuresSlowTrack(
1208         const Measure *measures,
1209         int32_t measureCount,
1210         UnicodeString&amp; appendTo,
1211         FieldPosition&amp; pos,
1212         UErrorCode&amp; status) const {
1213     if (U_FAILURE(status)) {
1214         return appendTo;
1215     }
1216     FieldPosition dontCare(FieldPosition::DONT_CARE);
1217     FieldPosition fpos(pos.getField());
<a name="32" id="anc32"></a><span class="line-modified">1218     UnicodeString *results = new UnicodeString[measureCount];</span>
1219     int32_t fieldPositionFoundIndex = -1;
1220     for (int32_t i = 0; i &lt; measureCount; ++i) {
1221         const NumberFormat *nf = cache-&gt;getIntegerFormat();
1222         if (i == measureCount - 1) {
1223             nf = numberFormat-&gt;get();
1224         }
1225         if (fieldPositionFoundIndex == -1) {
1226             formatMeasure(measures[i], *nf, results[i], fpos, status);
1227             if (U_FAILURE(status)) {
<a name="33" id="anc33"></a><span class="line-removed">1228                 delete [] results;</span>
1229                 return appendTo;
1230             }
1231             if (fpos.getBeginIndex() != 0 || fpos.getEndIndex() != 0) {
1232                 fieldPositionFoundIndex = i;
1233             }
1234         } else {
1235             formatMeasure(measures[i], *nf, results[i], dontCare, status);
1236         }
1237     }
1238     int32_t offset;
1239     listFormatter-&gt;format(
<a name="34" id="anc34"></a><span class="line-modified">1240             results,</span>
1241             measureCount,
1242             appendTo,
1243             fieldPositionFoundIndex,
1244             offset,
1245             status);
1246     if (U_FAILURE(status)) {
<a name="35" id="anc35"></a><span class="line-removed">1247         delete [] results;</span>
1248         return appendTo;
1249     }
<a name="36" id="anc36"></a>
1250     if (offset != -1) {
1251         pos.setBeginIndex(fpos.getBeginIndex() + offset);
1252         pos.setEndIndex(fpos.getEndIndex() + offset);
1253     }
<a name="37" id="anc37"></a><span class="line-removed">1254     delete [] results;</span>
1255     return appendTo;
1256 }
1257 
1258 MeasureFormat* U_EXPORT2 MeasureFormat::createCurrencyFormat(const Locale&amp; locale,
1259                                                    UErrorCode&amp; ec) {
<a name="38" id="anc38"></a><span class="line-modified">1260     CurrencyFormat* fmt = NULL;</span>
<span class="line-modified">1261     if (U_SUCCESS(ec)) {</span>
<span class="line-removed">1262         fmt = new CurrencyFormat(locale, ec);</span>
<span class="line-removed">1263         if (U_FAILURE(ec)) {</span>
<span class="line-removed">1264             delete fmt;</span>
<span class="line-removed">1265             fmt = NULL;</span>
<span class="line-removed">1266         }</span>
1267     }
<a name="39" id="anc39"></a><span class="line-modified">1268     return fmt;</span>

1269 }
1270 
1271 MeasureFormat* U_EXPORT2 MeasureFormat::createCurrencyFormat(UErrorCode&amp; ec) {
1272     if (U_FAILURE(ec)) {
<a name="40" id="anc40"></a><span class="line-modified">1273         return NULL;</span>
1274     }
1275     return MeasureFormat::createCurrencyFormat(Locale::getDefault(), ec);
1276 }
1277 
1278 U_NAMESPACE_END
1279 
1280 #endif /* #if !UCONFIG_NO_FORMATTING */
<a name="41" id="anc41"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="41" type="hidden" />
</body>
</html>