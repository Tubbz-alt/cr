<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/loadednormalizer2impl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="hash.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="localsvc.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/loadednormalizer2impl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 *******************************************************************************
  5 * Copyright (C) 2014, International Business Machines
  6 * Corporation and others.  All Rights Reserved.
  7 *******************************************************************************
  8 * loadednormalizer2impl.cpp
  9 *
 10 * created on: 2014sep03
 11 * created by: Markus W. Scherer
 12 */
 13 
 14 #include &quot;unicode/utypes.h&quot;
 15 
 16 #if !UCONFIG_NO_NORMALIZATION
 17 
 18 #include &quot;unicode/udata.h&quot;
 19 #include &quot;unicode/localpointer.h&quot;
 20 #include &quot;unicode/normalizer2.h&quot;

 21 #include &quot;unicode/unistr.h&quot;
 22 #include &quot;unicode/unorm.h&quot;
 23 #include &quot;cstring.h&quot;
 24 #include &quot;mutex.h&quot;
 25 #include &quot;norm2allmodes.h&quot;
 26 #include &quot;normalizer2impl.h&quot;
 27 #include &quot;uassert.h&quot;
 28 #include &quot;ucln_cmn.h&quot;
 29 #include &quot;uhash.h&quot;
 30 
 31 U_NAMESPACE_BEGIN
 32 
 33 class LoadedNormalizer2Impl : public Normalizer2Impl {
 34 public:
 35     LoadedNormalizer2Impl() : memory(NULL), ownedTrie(NULL) {}
 36     virtual ~LoadedNormalizer2Impl();
 37 
 38     void load(const char *packageName, const char *name, UErrorCode &amp;errorCode);
 39 
 40 private:
 41     static UBool U_CALLCONV
 42     isAcceptable(void *context, const char *type, const char *name, const UDataInfo *pInfo);
 43 
 44     UDataMemory *memory;
<span class="line-modified"> 45     UTrie2 *ownedTrie;</span>
 46 };
 47 
 48 LoadedNormalizer2Impl::~LoadedNormalizer2Impl() {
 49     udata_close(memory);
<span class="line-modified"> 50     utrie2_close(ownedTrie);</span>
 51 }
 52 
 53 UBool U_CALLCONV
 54 LoadedNormalizer2Impl::isAcceptable(void * /*context*/,
 55                                     const char * /* type */, const char * /*name*/,
 56                                     const UDataInfo *pInfo) {
 57     if(
 58         pInfo-&gt;size&gt;=20 &amp;&amp;
 59         pInfo-&gt;isBigEndian==U_IS_BIG_ENDIAN &amp;&amp;
 60         pInfo-&gt;charsetFamily==U_CHARSET_FAMILY &amp;&amp;
 61         pInfo-&gt;dataFormat[0]==0x4e &amp;&amp;    /* dataFormat=&quot;Nrm2&quot; */
 62         pInfo-&gt;dataFormat[1]==0x72 &amp;&amp;
 63         pInfo-&gt;dataFormat[2]==0x6d &amp;&amp;
 64         pInfo-&gt;dataFormat[3]==0x32 &amp;&amp;
<span class="line-modified"> 65         pInfo-&gt;formatVersion[0]==3</span>
 66     ) {
 67         // Normalizer2Impl *me=(Normalizer2Impl *)context;
 68         // uprv_memcpy(me-&gt;dataVersion, pInfo-&gt;dataVersion, 4);
 69         return TRUE;
 70     } else {
 71         return FALSE;
 72     }
 73 }
 74 
 75 void
 76 LoadedNormalizer2Impl::load(const char *packageName, const char *name, UErrorCode &amp;errorCode) {
 77     if(U_FAILURE(errorCode)) {
 78         return;
 79     }
 80     memory=udata_openChoice(packageName, &quot;nrm&quot;, name, isAcceptable, this, &amp;errorCode);
 81     if(U_FAILURE(errorCode)) {
 82         return;
 83     }
 84     const uint8_t *inBytes=(const uint8_t *)udata_getMemory(memory);
 85     const int32_t *inIndexes=(const int32_t *)inBytes;
 86     int32_t indexesLength=inIndexes[IX_NORM_TRIE_OFFSET]/4;
 87     if(indexesLength&lt;=IX_MIN_LCCC_CP) {
 88         errorCode=U_INVALID_FORMAT_ERROR;  // Not enough indexes.
 89         return;
 90     }
 91 
 92     int32_t offset=inIndexes[IX_NORM_TRIE_OFFSET];
 93     int32_t nextOffset=inIndexes[IX_EXTRA_DATA_OFFSET];
<span class="line-modified"> 94     ownedTrie=utrie2_openFromSerialized(UTRIE2_16_VALUE_BITS,</span>
<span class="line-modified"> 95                                         inBytes+offset, nextOffset-offset, NULL,</span>
<span class="line-modified"> 96                                         &amp;errorCode);</span>
 97     if(U_FAILURE(errorCode)) {
 98         return;
 99     }
100 
101     offset=nextOffset;
102     nextOffset=inIndexes[IX_SMALL_FCD_OFFSET];
103     const uint16_t *inExtraData=(const uint16_t *)(inBytes+offset);
104 
105     // smallFCD: new in formatVersion 2
106     offset=nextOffset;
107     const uint8_t *inSmallFCD=inBytes+offset;
108 
109     init(inIndexes, ownedTrie, inExtraData, inSmallFCD);
110 }
111 
112 // instance cache ---------------------------------------------------------- ***
113 
114 Norm2AllModes *
115 Norm2AllModes::createInstance(const char *packageName,
116                               const char *name,
117                               UErrorCode &amp;errorCode) {
118     if(U_FAILURE(errorCode)) {
119         return NULL;
120     }
121     LoadedNormalizer2Impl *impl=new LoadedNormalizer2Impl;
122     if(impl==NULL) {
123         errorCode=U_MEMORY_ALLOCATION_ERROR;
124         return NULL;
125     }
126     impl-&gt;load(packageName, name, errorCode);
127     return createInstance(impl, errorCode);
128 }
129 
130 U_CDECL_BEGIN
131 static UBool U_CALLCONV uprv_loaded_normalizer2_cleanup();
132 U_CDECL_END
133 
<span class="line-modified">134 static Norm2AllModes *nfkcSingleton;</span>
<span class="line-modified">135 static Norm2AllModes *nfkc_cfSingleton;</span>
<span class="line-modified">136 static UHashtable    *cache=NULL;</span>

137 

138 static icu::UInitOnce nfkcInitOnce = U_INITONCE_INITIALIZER;


139 static icu::UInitOnce nfkc_cfInitOnce = U_INITONCE_INITIALIZER;
140 


141 // UInitOnce singleton initialization function
142 static void U_CALLCONV initSingletons(const char *what, UErrorCode &amp;errorCode) {





143     if (uprv_strcmp(what, &quot;nfkc&quot;) == 0) {
144         nfkcSingleton    = Norm2AllModes::createInstance(NULL, &quot;nfkc&quot;, errorCode);
145     } else if (uprv_strcmp(what, &quot;nfkc_cf&quot;) == 0) {
146         nfkc_cfSingleton = Norm2AllModes::createInstance(NULL, &quot;nfkc_cf&quot;, errorCode);
147     } else {
<span class="line-modified">148         U_ASSERT(FALSE);   // Unknown singleton</span>
149     }
150     ucln_common_registerCleanup(UCLN_COMMON_LOADED_NORMALIZER2, uprv_loaded_normalizer2_cleanup);
151 }
152 
153 U_CDECL_BEGIN
154 
155 static void U_CALLCONV deleteNorm2AllModes(void *allModes) {
156     delete (Norm2AllModes *)allModes;
157 }
158 
159 static UBool U_CALLCONV uprv_loaded_normalizer2_cleanup() {






160     delete nfkcSingleton;
161     nfkcSingleton = NULL;


162     delete nfkc_cfSingleton;
163     nfkc_cfSingleton = NULL;


164     uhash_close(cache);
165     cache=NULL;
<span class="line-removed">166     nfkcInitOnce.reset();</span>
<span class="line-removed">167     nfkc_cfInitOnce.reset();</span>
168     return TRUE;
169 }
170 
171 U_CDECL_END
172 









173 const Norm2AllModes *
174 Norm2AllModes::getNFKCInstance(UErrorCode &amp;errorCode) {
175     if(U_FAILURE(errorCode)) { return NULL; }
176     umtx_initOnce(nfkcInitOnce, &amp;initSingletons, &quot;nfkc&quot;, errorCode);
177     return nfkcSingleton;
178 }
179 
180 const Norm2AllModes *
181 Norm2AllModes::getNFKC_CFInstance(UErrorCode &amp;errorCode) {
182     if(U_FAILURE(errorCode)) { return NULL; }
183     umtx_initOnce(nfkc_cfInitOnce, &amp;initSingletons, &quot;nfkc_cf&quot;, errorCode);
184     return nfkc_cfSingleton;
185 }
186 






























187 const Normalizer2 *
188 Normalizer2::getNFKCInstance(UErrorCode &amp;errorCode) {
189     const Norm2AllModes *allModes=Norm2AllModes::getNFKCInstance(errorCode);
190     return allModes!=NULL ? &amp;allModes-&gt;comp : NULL;
191 }
192 
193 const Normalizer2 *
194 Normalizer2::getNFKDInstance(UErrorCode &amp;errorCode) {
195     const Norm2AllModes *allModes=Norm2AllModes::getNFKCInstance(errorCode);
196     return allModes!=NULL ? &amp;allModes-&gt;decomp : NULL;
197 }
198 
199 const Normalizer2 *
200 Normalizer2::getNFKCCasefoldInstance(UErrorCode &amp;errorCode) {
201     const Norm2AllModes *allModes=Norm2AllModes::getNFKC_CFInstance(errorCode);
202     return allModes!=NULL ? &amp;allModes-&gt;comp : NULL;
203 }
204 
205 const Normalizer2 *
206 Normalizer2::getInstance(const char *packageName,
</pre>
<hr />
<pre>
230             if(cache!=NULL) {
231                 allModes=(Norm2AllModes *)uhash_get(cache, name);
232             }
233         }
234         if(allModes==NULL) {
235             ucln_common_registerCleanup(UCLN_COMMON_LOADED_NORMALIZER2, uprv_loaded_normalizer2_cleanup);
236             LocalPointer&lt;Norm2AllModes&gt; localAllModes(
237                 Norm2AllModes::createInstance(packageName, name, errorCode));
238             if(U_SUCCESS(errorCode)) {
239                 Mutex lock;
240                 if(cache==NULL) {
241                     cache=uhash_open(uhash_hashChars, uhash_compareChars, NULL, &amp;errorCode);
242                     if(U_FAILURE(errorCode)) {
243                         return NULL;
244                     }
245                     uhash_setKeyDeleter(cache, uprv_free);
246                     uhash_setValueDeleter(cache, deleteNorm2AllModes);
247                 }
248                 void *temp=uhash_get(cache, name);
249                 if(temp==NULL) {
<span class="line-modified">250                     int32_t keyLength=uprv_strlen(name)+1;</span>
251                     char *nameCopy=(char *)uprv_malloc(keyLength);
252                     if(nameCopy==NULL) {
253                         errorCode=U_MEMORY_ALLOCATION_ERROR;
254                         return NULL;
255                     }
256                     uprv_memcpy(nameCopy, name, keyLength);
257                     allModes=localAllModes.getAlias();
258                     uhash_put(cache, nameCopy, localAllModes.orphan(), &amp;errorCode);
259                 } else {
260                     // race condition
261                     allModes=(Norm2AllModes *)temp;
262                 }
263             }
264         }
265     }
266     if(allModes!=NULL &amp;&amp; U_SUCCESS(errorCode)) {
267         switch(mode) {
268         case UNORM2_COMPOSE:
269             return &amp;allModes-&gt;comp;
270         case UNORM2_DECOMPOSE:
</pre>
</td>
<td>
<hr />
<pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 *******************************************************************************
  5 * Copyright (C) 2014, International Business Machines
  6 * Corporation and others.  All Rights Reserved.
  7 *******************************************************************************
  8 * loadednormalizer2impl.cpp
  9 *
 10 * created on: 2014sep03
 11 * created by: Markus W. Scherer
 12 */
 13 
 14 #include &quot;unicode/utypes.h&quot;
 15 
 16 #if !UCONFIG_NO_NORMALIZATION
 17 
 18 #include &quot;unicode/udata.h&quot;
 19 #include &quot;unicode/localpointer.h&quot;
 20 #include &quot;unicode/normalizer2.h&quot;
<span class="line-added"> 21 #include &quot;unicode/ucptrie.h&quot;</span>
 22 #include &quot;unicode/unistr.h&quot;
 23 #include &quot;unicode/unorm.h&quot;
 24 #include &quot;cstring.h&quot;
 25 #include &quot;mutex.h&quot;
 26 #include &quot;norm2allmodes.h&quot;
 27 #include &quot;normalizer2impl.h&quot;
 28 #include &quot;uassert.h&quot;
 29 #include &quot;ucln_cmn.h&quot;
 30 #include &quot;uhash.h&quot;
 31 
 32 U_NAMESPACE_BEGIN
 33 
 34 class LoadedNormalizer2Impl : public Normalizer2Impl {
 35 public:
 36     LoadedNormalizer2Impl() : memory(NULL), ownedTrie(NULL) {}
 37     virtual ~LoadedNormalizer2Impl();
 38 
 39     void load(const char *packageName, const char *name, UErrorCode &amp;errorCode);
 40 
 41 private:
 42     static UBool U_CALLCONV
 43     isAcceptable(void *context, const char *type, const char *name, const UDataInfo *pInfo);
 44 
 45     UDataMemory *memory;
<span class="line-modified"> 46     UCPTrie *ownedTrie;</span>
 47 };
 48 
 49 LoadedNormalizer2Impl::~LoadedNormalizer2Impl() {
 50     udata_close(memory);
<span class="line-modified"> 51     ucptrie_close(ownedTrie);</span>
 52 }
 53 
 54 UBool U_CALLCONV
 55 LoadedNormalizer2Impl::isAcceptable(void * /*context*/,
 56                                     const char * /* type */, const char * /*name*/,
 57                                     const UDataInfo *pInfo) {
 58     if(
 59         pInfo-&gt;size&gt;=20 &amp;&amp;
 60         pInfo-&gt;isBigEndian==U_IS_BIG_ENDIAN &amp;&amp;
 61         pInfo-&gt;charsetFamily==U_CHARSET_FAMILY &amp;&amp;
 62         pInfo-&gt;dataFormat[0]==0x4e &amp;&amp;    /* dataFormat=&quot;Nrm2&quot; */
 63         pInfo-&gt;dataFormat[1]==0x72 &amp;&amp;
 64         pInfo-&gt;dataFormat[2]==0x6d &amp;&amp;
 65         pInfo-&gt;dataFormat[3]==0x32 &amp;&amp;
<span class="line-modified"> 66         pInfo-&gt;formatVersion[0]==4</span>
 67     ) {
 68         // Normalizer2Impl *me=(Normalizer2Impl *)context;
 69         // uprv_memcpy(me-&gt;dataVersion, pInfo-&gt;dataVersion, 4);
 70         return TRUE;
 71     } else {
 72         return FALSE;
 73     }
 74 }
 75 
 76 void
 77 LoadedNormalizer2Impl::load(const char *packageName, const char *name, UErrorCode &amp;errorCode) {
 78     if(U_FAILURE(errorCode)) {
 79         return;
 80     }
 81     memory=udata_openChoice(packageName, &quot;nrm&quot;, name, isAcceptable, this, &amp;errorCode);
 82     if(U_FAILURE(errorCode)) {
 83         return;
 84     }
 85     const uint8_t *inBytes=(const uint8_t *)udata_getMemory(memory);
 86     const int32_t *inIndexes=(const int32_t *)inBytes;
 87     int32_t indexesLength=inIndexes[IX_NORM_TRIE_OFFSET]/4;
 88     if(indexesLength&lt;=IX_MIN_LCCC_CP) {
 89         errorCode=U_INVALID_FORMAT_ERROR;  // Not enough indexes.
 90         return;
 91     }
 92 
 93     int32_t offset=inIndexes[IX_NORM_TRIE_OFFSET];
 94     int32_t nextOffset=inIndexes[IX_EXTRA_DATA_OFFSET];
<span class="line-modified"> 95     ownedTrie=ucptrie_openFromBinary(UCPTRIE_TYPE_FAST, UCPTRIE_VALUE_BITS_16,</span>
<span class="line-modified"> 96                                      inBytes+offset, nextOffset-offset, NULL,</span>
<span class="line-modified"> 97                                      &amp;errorCode);</span>
 98     if(U_FAILURE(errorCode)) {
 99         return;
100     }
101 
102     offset=nextOffset;
103     nextOffset=inIndexes[IX_SMALL_FCD_OFFSET];
104     const uint16_t *inExtraData=(const uint16_t *)(inBytes+offset);
105 
106     // smallFCD: new in formatVersion 2
107     offset=nextOffset;
108     const uint8_t *inSmallFCD=inBytes+offset;
109 
110     init(inIndexes, ownedTrie, inExtraData, inSmallFCD);
111 }
112 
113 // instance cache ---------------------------------------------------------- ***
114 
115 Norm2AllModes *
116 Norm2AllModes::createInstance(const char *packageName,
117                               const char *name,
118                               UErrorCode &amp;errorCode) {
119     if(U_FAILURE(errorCode)) {
120         return NULL;
121     }
122     LoadedNormalizer2Impl *impl=new LoadedNormalizer2Impl;
123     if(impl==NULL) {
124         errorCode=U_MEMORY_ALLOCATION_ERROR;
125         return NULL;
126     }
127     impl-&gt;load(packageName, name, errorCode);
128     return createInstance(impl, errorCode);
129 }
130 
131 U_CDECL_BEGIN
132 static UBool U_CALLCONV uprv_loaded_normalizer2_cleanup();
133 U_CDECL_END
134 
<span class="line-modified">135 #if !NORM2_HARDCODE_NFC_DATA</span>
<span class="line-modified">136 static Norm2AllModes *nfcSingleton;</span>
<span class="line-modified">137 static icu::UInitOnce nfcInitOnce = U_INITONCE_INITIALIZER;</span>
<span class="line-added">138 #endif</span>
139 
<span class="line-added">140 static Norm2AllModes *nfkcSingleton;</span>
141 static icu::UInitOnce nfkcInitOnce = U_INITONCE_INITIALIZER;
<span class="line-added">142 </span>
<span class="line-added">143 static Norm2AllModes *nfkc_cfSingleton;</span>
144 static icu::UInitOnce nfkc_cfInitOnce = U_INITONCE_INITIALIZER;
145 
<span class="line-added">146 static UHashtable    *cache=NULL;</span>
<span class="line-added">147 </span>
148 // UInitOnce singleton initialization function
149 static void U_CALLCONV initSingletons(const char *what, UErrorCode &amp;errorCode) {
<span class="line-added">150 #if !NORM2_HARDCODE_NFC_DATA</span>
<span class="line-added">151     if (uprv_strcmp(what, &quot;nfc&quot;) == 0) {</span>
<span class="line-added">152         nfcSingleton    = Norm2AllModes::createInstance(NULL, &quot;nfc&quot;, errorCode);</span>
<span class="line-added">153     } else</span>
<span class="line-added">154 #endif</span>
155     if (uprv_strcmp(what, &quot;nfkc&quot;) == 0) {
156         nfkcSingleton    = Norm2AllModes::createInstance(NULL, &quot;nfkc&quot;, errorCode);
157     } else if (uprv_strcmp(what, &quot;nfkc_cf&quot;) == 0) {
158         nfkc_cfSingleton = Norm2AllModes::createInstance(NULL, &quot;nfkc_cf&quot;, errorCode);
159     } else {
<span class="line-modified">160         UPRV_UNREACHABLE;   // Unknown singleton</span>
161     }
162     ucln_common_registerCleanup(UCLN_COMMON_LOADED_NORMALIZER2, uprv_loaded_normalizer2_cleanup);
163 }
164 
165 U_CDECL_BEGIN
166 
167 static void U_CALLCONV deleteNorm2AllModes(void *allModes) {
168     delete (Norm2AllModes *)allModes;
169 }
170 
171 static UBool U_CALLCONV uprv_loaded_normalizer2_cleanup() {
<span class="line-added">172 #if !NORM2_HARDCODE_NFC_DATA</span>
<span class="line-added">173     delete nfcSingleton;</span>
<span class="line-added">174     nfcSingleton = NULL;</span>
<span class="line-added">175     nfcInitOnce.reset();</span>
<span class="line-added">176 #endif</span>
<span class="line-added">177 </span>
178     delete nfkcSingleton;
179     nfkcSingleton = NULL;
<span class="line-added">180     nfkcInitOnce.reset();</span>
<span class="line-added">181 </span>
182     delete nfkc_cfSingleton;
183     nfkc_cfSingleton = NULL;
<span class="line-added">184     nfkc_cfInitOnce.reset();</span>
<span class="line-added">185 </span>
186     uhash_close(cache);
187     cache=NULL;


188     return TRUE;
189 }
190 
191 U_CDECL_END
192 
<span class="line-added">193 #if !NORM2_HARDCODE_NFC_DATA</span>
<span class="line-added">194 const Norm2AllModes *</span>
<span class="line-added">195 Norm2AllModes::getNFCInstance(UErrorCode &amp;errorCode) {</span>
<span class="line-added">196     if(U_FAILURE(errorCode)) { return NULL; }</span>
<span class="line-added">197     umtx_initOnce(nfcInitOnce, &amp;initSingletons, &quot;nfc&quot;, errorCode);</span>
<span class="line-added">198     return nfcSingleton;</span>
<span class="line-added">199 }</span>
<span class="line-added">200 #endif</span>
<span class="line-added">201 </span>
202 const Norm2AllModes *
203 Norm2AllModes::getNFKCInstance(UErrorCode &amp;errorCode) {
204     if(U_FAILURE(errorCode)) { return NULL; }
205     umtx_initOnce(nfkcInitOnce, &amp;initSingletons, &quot;nfkc&quot;, errorCode);
206     return nfkcSingleton;
207 }
208 
209 const Norm2AllModes *
210 Norm2AllModes::getNFKC_CFInstance(UErrorCode &amp;errorCode) {
211     if(U_FAILURE(errorCode)) { return NULL; }
212     umtx_initOnce(nfkc_cfInitOnce, &amp;initSingletons, &quot;nfkc_cf&quot;, errorCode);
213     return nfkc_cfSingleton;
214 }
215 
<span class="line-added">216 #if !NORM2_HARDCODE_NFC_DATA</span>
<span class="line-added">217 const Normalizer2 *</span>
<span class="line-added">218 Normalizer2::getNFCInstance(UErrorCode &amp;errorCode) {</span>
<span class="line-added">219     const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);</span>
<span class="line-added">220     return allModes!=NULL ? &amp;allModes-&gt;comp : NULL;</span>
<span class="line-added">221 }</span>
<span class="line-added">222 </span>
<span class="line-added">223 const Normalizer2 *</span>
<span class="line-added">224 Normalizer2::getNFDInstance(UErrorCode &amp;errorCode) {</span>
<span class="line-added">225     const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);</span>
<span class="line-added">226     return allModes!=NULL ? &amp;allModes-&gt;decomp : NULL;</span>
<span class="line-added">227 }</span>
<span class="line-added">228 </span>
<span class="line-added">229 const Normalizer2 *Normalizer2Factory::getFCDInstance(UErrorCode &amp;errorCode) {</span>
<span class="line-added">230     const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);</span>
<span class="line-added">231     return allModes!=NULL ? &amp;allModes-&gt;fcd : NULL;</span>
<span class="line-added">232 }</span>
<span class="line-added">233 </span>
<span class="line-added">234 const Normalizer2 *Normalizer2Factory::getFCCInstance(UErrorCode &amp;errorCode) {</span>
<span class="line-added">235     const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);</span>
<span class="line-added">236     return allModes!=NULL ? &amp;allModes-&gt;fcc : NULL;</span>
<span class="line-added">237 }</span>
<span class="line-added">238 </span>
<span class="line-added">239 const Normalizer2Impl *</span>
<span class="line-added">240 Normalizer2Factory::getNFCImpl(UErrorCode &amp;errorCode) {</span>
<span class="line-added">241     const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);</span>
<span class="line-added">242     return allModes!=NULL ? allModes-&gt;impl : NULL;</span>
<span class="line-added">243 }</span>
<span class="line-added">244 #endif</span>
<span class="line-added">245 </span>
246 const Normalizer2 *
247 Normalizer2::getNFKCInstance(UErrorCode &amp;errorCode) {
248     const Norm2AllModes *allModes=Norm2AllModes::getNFKCInstance(errorCode);
249     return allModes!=NULL ? &amp;allModes-&gt;comp : NULL;
250 }
251 
252 const Normalizer2 *
253 Normalizer2::getNFKDInstance(UErrorCode &amp;errorCode) {
254     const Norm2AllModes *allModes=Norm2AllModes::getNFKCInstance(errorCode);
255     return allModes!=NULL ? &amp;allModes-&gt;decomp : NULL;
256 }
257 
258 const Normalizer2 *
259 Normalizer2::getNFKCCasefoldInstance(UErrorCode &amp;errorCode) {
260     const Norm2AllModes *allModes=Norm2AllModes::getNFKC_CFInstance(errorCode);
261     return allModes!=NULL ? &amp;allModes-&gt;comp : NULL;
262 }
263 
264 const Normalizer2 *
265 Normalizer2::getInstance(const char *packageName,
</pre>
<hr />
<pre>
289             if(cache!=NULL) {
290                 allModes=(Norm2AllModes *)uhash_get(cache, name);
291             }
292         }
293         if(allModes==NULL) {
294             ucln_common_registerCleanup(UCLN_COMMON_LOADED_NORMALIZER2, uprv_loaded_normalizer2_cleanup);
295             LocalPointer&lt;Norm2AllModes&gt; localAllModes(
296                 Norm2AllModes::createInstance(packageName, name, errorCode));
297             if(U_SUCCESS(errorCode)) {
298                 Mutex lock;
299                 if(cache==NULL) {
300                     cache=uhash_open(uhash_hashChars, uhash_compareChars, NULL, &amp;errorCode);
301                     if(U_FAILURE(errorCode)) {
302                         return NULL;
303                     }
304                     uhash_setKeyDeleter(cache, uprv_free);
305                     uhash_setValueDeleter(cache, deleteNorm2AllModes);
306                 }
307                 void *temp=uhash_get(cache, name);
308                 if(temp==NULL) {
<span class="line-modified">309                     int32_t keyLength= static_cast&lt;int32_t&gt;(uprv_strlen(name)+1);</span>
310                     char *nameCopy=(char *)uprv_malloc(keyLength);
311                     if(nameCopy==NULL) {
312                         errorCode=U_MEMORY_ALLOCATION_ERROR;
313                         return NULL;
314                     }
315                     uprv_memcpy(nameCopy, name, keyLength);
316                     allModes=localAllModes.getAlias();
317                     uhash_put(cache, nameCopy, localAllModes.orphan(), &amp;errorCode);
318                 } else {
319                     // race condition
320                     allModes=(Norm2AllModes *)temp;
321                 }
322             }
323         }
324     }
325     if(allModes!=NULL &amp;&amp; U_SUCCESS(errorCode)) {
326         switch(mode) {
327         case UNORM2_COMPOSE:
328             return &amp;allModes-&gt;comp;
329         case UNORM2_DECOMPOSE:
</pre>
</td>
</tr>
</table>
<center><a href="hash.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="localsvc.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>