<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/char16ptr.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2017 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 
  4 // char16ptr.h
  5 // created: 2017feb28 Markus W. Scherer
  6 
  7 #ifndef __CHAR16PTR_H__
  8 #define __CHAR16PTR_H__
  9 
 10 #include &lt;cstddef&gt;
 11 #include &quot;unicode/utypes.h&quot;
 12 
 13 /**
 14  * \file
 15  * \brief C++ API: char16_t pointer wrappers with
 16  *        implicit conversion from bit-compatible raw pointer types.
 17  *        Also conversion functions from char16_t * to UChar * and OldUChar *.
 18  */
 19 
 20 U_NAMESPACE_BEGIN
 21 
 22 /**
 23  * \def U_ALIASING_BARRIER
 24  * Barrier for pointer anti-aliasing optimizations even across function boundaries.
 25  * @internal
 26  */
 27 #ifdef U_ALIASING_BARRIER
 28     // Use the predefined value.
 29 #elif (defined(__clang__) || defined(__GNUC__)) &amp;&amp; U_PLATFORM != U_PF_BROWSER_NATIVE_CLIENT
 30 #   define U_ALIASING_BARRIER(ptr) asm volatile(&quot;&quot; : : &quot;rm&quot;(ptr) : &quot;memory&quot;)
 31 #endif
 32 
 33 /**
 34  * char16_t * wrapper with implicit conversion from distinct but bit-compatible pointer types.
 35  * @stable ICU 59
 36  */
 37 class U_COMMON_API Char16Ptr U_FINAL {
 38 public:
 39     /**
 40      * Copies the pointer.
 41      * @param p pointer
 42      * @stable ICU 59
 43      */
 44     inline Char16Ptr(char16_t *p);
 45 #if !U_CHAR16_IS_TYPEDEF
 46     /**
 47      * Converts the pointer to char16_t *.
 48      * @param p pointer to be converted
 49      * @stable ICU 59
 50      */
 51     inline Char16Ptr(uint16_t *p);
 52 #endif
 53 #if U_SIZEOF_WCHAR_T==2 || defined(U_IN_DOXYGEN)
 54     /**
 55      * Converts the pointer to char16_t *.
 56      * (Only defined if U_SIZEOF_WCHAR_T==2.)
 57      * @param p pointer to be converted
 58      * @stable ICU 59
 59      */
 60     inline Char16Ptr(wchar_t *p);
 61 #endif
 62     /**
 63      * nullptr constructor.
 64      * @param p nullptr
 65      * @stable ICU 59
 66      */
 67     inline Char16Ptr(std::nullptr_t p);
 68     /**
 69      * Destructor.
 70      * @stable ICU 59
 71      */
 72     inline ~Char16Ptr();
 73 
 74     /**
 75      * Pointer access.
 76      * @return the wrapped pointer
 77      * @stable ICU 59
 78      */
 79     inline char16_t *get() const;
 80     /**
 81      * char16_t pointer access via type conversion (e.g., static_cast).
 82      * @return the wrapped pointer
 83      * @stable ICU 59
 84      */
 85     inline operator char16_t *() const { return get(); }
 86 
 87 private:
 88     Char16Ptr() = delete;
 89 
 90 #ifdef U_ALIASING_BARRIER
 91     template&lt;typename T&gt; static char16_t *cast(T *t) {
 92         U_ALIASING_BARRIER(t);
 93         return reinterpret_cast&lt;char16_t *&gt;(t);
 94     }
 95 
 96     char16_t *p_;
 97 #else
 98     union {
 99         char16_t *cp;
100         uint16_t *up;
101         wchar_t *wp;
102     } u_;
103 #endif
104 };
105 
106 #ifdef U_ALIASING_BARRIER
107 
108 Char16Ptr::Char16Ptr(char16_t *p) : p_(p) {}
109 #if !U_CHAR16_IS_TYPEDEF
110 Char16Ptr::Char16Ptr(uint16_t *p) : p_(cast(p)) {}
111 #endif
112 #if U_SIZEOF_WCHAR_T==2
113 Char16Ptr::Char16Ptr(wchar_t *p) : p_(cast(p)) {}
114 #endif
115 Char16Ptr::Char16Ptr(std::nullptr_t p) : p_(p) {}
116 Char16Ptr::~Char16Ptr() {
117     U_ALIASING_BARRIER(p_);
118 }
119 
120 char16_t *Char16Ptr::get() const { return p_; }
121 
122 #else
123 
124 Char16Ptr::Char16Ptr(char16_t *p) { u_.cp = p; }
125 #if !U_CHAR16_IS_TYPEDEF
126 Char16Ptr::Char16Ptr(uint16_t *p) { u_.up = p; }
127 #endif
128 #if U_SIZEOF_WCHAR_T==2
129 Char16Ptr::Char16Ptr(wchar_t *p) { u_.wp = p; }
130 #endif
131 Char16Ptr::Char16Ptr(std::nullptr_t p) { u_.cp = p; }
132 Char16Ptr::~Char16Ptr() {}
133 
134 char16_t *Char16Ptr::get() const { return u_.cp; }
135 
136 #endif
137 
138 /**
139  * const char16_t * wrapper with implicit conversion from distinct but bit-compatible pointer types.
140  * @stable ICU 59
141  */
142 class U_COMMON_API ConstChar16Ptr U_FINAL {
143 public:
144     /**
145      * Copies the pointer.
146      * @param p pointer
147      * @stable ICU 59
148      */
149     inline ConstChar16Ptr(const char16_t *p);
150 #if !U_CHAR16_IS_TYPEDEF
151     /**
152      * Converts the pointer to char16_t *.
153      * @param p pointer to be converted
154      * @stable ICU 59
155      */
156     inline ConstChar16Ptr(const uint16_t *p);
157 #endif
158 #if U_SIZEOF_WCHAR_T==2 || defined(U_IN_DOXYGEN)
159     /**
160      * Converts the pointer to char16_t *.
161      * (Only defined if U_SIZEOF_WCHAR_T==2.)
162      * @param p pointer to be converted
163      * @stable ICU 59
164      */
165     inline ConstChar16Ptr(const wchar_t *p);
166 #endif
167     /**
168      * nullptr constructor.
169      * @param p nullptr
170      * @stable ICU 59
171      */
172     inline ConstChar16Ptr(const std::nullptr_t p);
173 
174     /**
175      * Destructor.
176      * @stable ICU 59
177      */
178     inline ~ConstChar16Ptr();
179 
180     /**
181      * Pointer access.
182      * @return the wrapped pointer
183      * @stable ICU 59
184      */
185     inline const char16_t *get() const;
186     /**
187      * char16_t pointer access via type conversion (e.g., static_cast).
188      * @return the wrapped pointer
189      * @stable ICU 59
190      */
191     inline operator const char16_t *() const { return get(); }
192 
193 private:
194     ConstChar16Ptr() = delete;
195 
196 #ifdef U_ALIASING_BARRIER
197     template&lt;typename T&gt; static const char16_t *cast(const T *t) {
198         U_ALIASING_BARRIER(t);
199         return reinterpret_cast&lt;const char16_t *&gt;(t);
200     }
201 
202     const char16_t *p_;
203 #else
204     union {
205         const char16_t *cp;
206         const uint16_t *up;
207         const wchar_t *wp;
208     } u_;
209 #endif
210 };
211 
212 #ifdef U_ALIASING_BARRIER
213 
214 ConstChar16Ptr::ConstChar16Ptr(const char16_t *p) : p_(p) {}
215 #if !U_CHAR16_IS_TYPEDEF
216 ConstChar16Ptr::ConstChar16Ptr(const uint16_t *p) : p_(cast(p)) {}
217 #endif
218 #if U_SIZEOF_WCHAR_T==2
219 ConstChar16Ptr::ConstChar16Ptr(const wchar_t *p) : p_(cast(p)) {}
220 #endif
221 ConstChar16Ptr::ConstChar16Ptr(const std::nullptr_t p) : p_(p) {}
222 ConstChar16Ptr::~ConstChar16Ptr() {
223     U_ALIASING_BARRIER(p_);
224 }
225 
226 const char16_t *ConstChar16Ptr::get() const { return p_; }
227 
228 #else
229 
230 ConstChar16Ptr::ConstChar16Ptr(const char16_t *p) { u_.cp = p; }
231 #if !U_CHAR16_IS_TYPEDEF
232 ConstChar16Ptr::ConstChar16Ptr(const uint16_t *p) { u_.up = p; }
233 #endif
234 #if U_SIZEOF_WCHAR_T==2
235 ConstChar16Ptr::ConstChar16Ptr(const wchar_t *p) { u_.wp = p; }
236 #endif
237 ConstChar16Ptr::ConstChar16Ptr(const std::nullptr_t p) { u_.cp = p; }
238 ConstChar16Ptr::~ConstChar16Ptr() {}
239 
240 const char16_t *ConstChar16Ptr::get() const { return u_.cp; }
241 
242 #endif
243 
244 /**
245  * Converts from const char16_t * to const UChar *.
246  * Includes an aliasing barrier if available.
247  * @param p pointer
248  * @return p as const UChar *
249  * @stable ICU 59
250  */
251 inline const UChar *toUCharPtr(const char16_t *p) {
252 #ifdef U_ALIASING_BARRIER
253     U_ALIASING_BARRIER(p);
254 #endif
255     return reinterpret_cast&lt;const UChar *&gt;(p);
256 }
257 
258 /**
259  * Converts from char16_t * to UChar *.
260  * Includes an aliasing barrier if available.
261  * @param p pointer
262  * @return p as UChar *
263  * @stable ICU 59
264  */
265 inline UChar *toUCharPtr(char16_t *p) {
266 #ifdef U_ALIASING_BARRIER
267     U_ALIASING_BARRIER(p);
268 #endif
269     return reinterpret_cast&lt;UChar *&gt;(p);
270 }
271 
272 /**
273  * Converts from const char16_t * to const OldUChar *.
274  * Includes an aliasing barrier if available.
275  * @param p pointer
276  * @return p as const OldUChar *
277  * @stable ICU 59
278  */
279 inline const OldUChar *toOldUCharPtr(const char16_t *p) {
280 #ifdef U_ALIASING_BARRIER
281     U_ALIASING_BARRIER(p);
282 #endif
283     return reinterpret_cast&lt;const OldUChar *&gt;(p);
284 }
285 
286 /**
287  * Converts from char16_t * to OldUChar *.
288  * Includes an aliasing barrier if available.
289  * @param p pointer
290  * @return p as OldUChar *
291  * @stable ICU 59
292  */
293 inline OldUChar *toOldUCharPtr(char16_t *p) {
294 #ifdef U_ALIASING_BARRIER
295     U_ALIASING_BARRIER(p);
296 #endif
297     return reinterpret_cast&lt;OldUChar *&gt;(p);
298 }
299 
300 U_NAMESPACE_END
301 
302 #endif  // __CHAR16PTR_H__
    </pre>
  </body>
</html>