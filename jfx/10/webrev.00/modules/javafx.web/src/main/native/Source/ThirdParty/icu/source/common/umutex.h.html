<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/umutex.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 **********************************************************************
  5 *   Copyright (C) 1997-2015, International Business Machines
  6 *   Corporation and others.  All Rights Reserved.
  7 **********************************************************************
  8 *
  9 * File UMUTEX.H
 10 *
 11 * Modification History:
 12 *
 13 *   Date        Name        Description
 14 *   04/02/97  aliu        Creation.
 15 *   04/07/99  srl         rewrite - C interface, multiple mutices
 16 *   05/13/99  stephen     Changed to umutex (from cmutex)
 17 ******************************************************************************
 18 */
 19 
 20 #ifndef UMUTEX_H
 21 #define UMUTEX_H
 22 
 23 #include &lt;atomic&gt;
 24 #include &lt;condition_variable&gt;
 25 #include &lt;mutex&gt;
 26 
 27 #include &quot;unicode/utypes.h&quot;
 28 #include &quot;unicode/uclean.h&quot;
 29 #include &quot;unicode/uobject.h&quot;
 30 
 31 #include &quot;putilimp.h&quot;
 32 
 33 #if defined(U_USER_ATOMICS_H) || defined(U_USER_MUTEX_H)
 34 // Support for including an alternate implementation of atomic &amp; mutex operations has been withdrawn.
 35 // See issue ICU-20185.
 36 #error U_USER_ATOMICS and U_USER_MUTEX_H are not supported
 37 #endif
 38 
 39 
 40 // Export an explicit template instantiation of std::atomic&lt;int32_t&gt;.
 41 // When building DLLs for Windows this is required as it is used as a data member of the exported SharedObject class.
 42 // See digitlst.h, pluralaffix.h, datefmt.h, and others for similar examples.
 43 #if U_PF_WINDOWS &lt;= U_PLATFORM &amp;&amp; U_PLATFORM &lt;= U_PF_CYGWIN &amp;&amp; !defined(U_IN_DOXYGEN)
 44 #if defined(__clang__) || defined(_MSC_VER)
 45   #if defined(__clang__)
 46     // Suppress the warning that the explicit instantiation after explicit specialization has no effect.
 47     #pragma clang diagnostic push
 48     #pragma clang diagnostic ignored &quot;-Winstantiation-after-specialization&quot;
 49   #endif
 50 template struct U_COMMON_API std::atomic&lt;int32_t&gt;;
 51   #if defined(__clang__)
 52     #pragma clang diagnostic pop
 53   #endif
 54 #elif defined(__GNUC__)
 55 // For GCC this class is already exported/visible, so no need for U_COMMON_API.
 56 template struct std::atomic&lt;int32_t&gt;;
 57 #endif
 58 #endif
 59 
 60 
 61 U_NAMESPACE_BEGIN
 62 
 63 /****************************************************************************
 64  *
 65  *   Low Level Atomic Operations, ICU wrappers for.
 66  *
 67  ****************************************************************************/
 68 
 69 typedef std::atomic&lt;int32_t&gt; u_atomic_int32_t;
 70 #define ATOMIC_INT32_T_INITIALIZER(val) ATOMIC_VAR_INIT(val)
 71 
 72 inline int32_t umtx_loadAcquire(u_atomic_int32_t &amp;var) {
 73     return var.load(std::memory_order_acquire);
 74 }
 75 
 76 inline void umtx_storeRelease(u_atomic_int32_t &amp;var, int32_t val) {
 77     var.store(val, std::memory_order_release);
 78 }
 79 
 80 inline int32_t umtx_atomic_inc(u_atomic_int32_t *var) {
 81     return var-&gt;fetch_add(1) + 1;
 82 }
 83 
 84 inline int32_t umtx_atomic_dec(u_atomic_int32_t *var) {
 85     return var-&gt;fetch_sub(1) - 1;
 86 }
 87 
 88 
 89 /*************************************************************************************************
 90  *
 91  *  UInitOnce Definitions.
 92  *
 93  *************************************************************************************************/
 94 
 95 struct UInitOnce {
 96     u_atomic_int32_t   fState;
 97     UErrorCode       fErrCode;
 98     void reset() {fState = 0;}
 99     UBool isReset() {return umtx_loadAcquire(fState) == 0;}
100 // Note: isReset() is used by service registration code.
101 //                 Thread safety of this usage needs review.
102 };
103 
104 #define U_INITONCE_INITIALIZER {ATOMIC_INT32_T_INITIALIZER(0), U_ZERO_ERROR}
105 
106 
107 U_COMMON_API UBool U_EXPORT2 umtx_initImplPreInit(UInitOnce &amp;);
108 U_COMMON_API void  U_EXPORT2 umtx_initImplPostInit(UInitOnce &amp;);
109 
110 template&lt;class T&gt; void umtx_initOnce(UInitOnce &amp;uio, T *obj, void (U_CALLCONV T::*fp)()) {
111     if (umtx_loadAcquire(uio.fState) == 2) {
112         return;
113     }
114     if (umtx_initImplPreInit(uio)) {
115         (obj-&gt;*fp)();
116         umtx_initImplPostInit(uio);
117     }
118 }
119 
120 
121 // umtx_initOnce variant for plain functions, or static class functions.
122 //               No context parameter.
123 inline void umtx_initOnce(UInitOnce &amp;uio, void (U_CALLCONV *fp)()) {
124     if (umtx_loadAcquire(uio.fState) == 2) {
125         return;
126     }
127     if (umtx_initImplPreInit(uio)) {
128         (*fp)();
129         umtx_initImplPostInit(uio);
130     }
131 }
132 
133 // umtx_initOnce variant for plain functions, or static class functions.
134 //               With ErrorCode, No context parameter.
135 inline void umtx_initOnce(UInitOnce &amp;uio, void (U_CALLCONV *fp)(UErrorCode &amp;), UErrorCode &amp;errCode) {
136     if (U_FAILURE(errCode)) {
137         return;
138     }
139     if (umtx_loadAcquire(uio.fState) != 2 &amp;&amp; umtx_initImplPreInit(uio)) {
140         // We run the initialization.
141         (*fp)(errCode);
142         uio.fErrCode = errCode;
143         umtx_initImplPostInit(uio);
144     } else {
145         // Someone else already ran the initialization.
146         if (U_FAILURE(uio.fErrCode)) {
147             errCode = uio.fErrCode;
148         }
149     }
150 }
151 
152 // umtx_initOnce variant for plain functions, or static class functions,
153 //               with a context parameter.
154 template&lt;class T&gt; void umtx_initOnce(UInitOnce &amp;uio, void (U_CALLCONV *fp)(T), T context) {
155     if (umtx_loadAcquire(uio.fState) == 2) {
156         return;
157     }
158     if (umtx_initImplPreInit(uio)) {
159         (*fp)(context);
160         umtx_initImplPostInit(uio);
161     }
162 }
163 
164 // umtx_initOnce variant for plain functions, or static class functions,
165 //               with a context parameter and an error code.
166 template&lt;class T&gt; void umtx_initOnce(UInitOnce &amp;uio, void (U_CALLCONV *fp)(T, UErrorCode &amp;), T context, UErrorCode &amp;errCode) {
167     if (U_FAILURE(errCode)) {
168         return;
169     }
170     if (umtx_loadAcquire(uio.fState) != 2 &amp;&amp; umtx_initImplPreInit(uio)) {
171         // We run the initialization.
172         (*fp)(context, errCode);
173         uio.fErrCode = errCode;
174         umtx_initImplPostInit(uio);
175     } else {
176         // Someone else already ran the initialization.
177         if (U_FAILURE(uio.fErrCode)) {
178             errCode = uio.fErrCode;
179         }
180     }
181 }
182 
183 
184 /*************************************************************************************************
185  *
186  * ICU Mutex wrappers.  Originally wrapped operating system mutexes, giving the rest of ICU a
187  * platform independent set of mutex operations.  Now vestigial, wrapping std::mutex only.
188  * For internal ICU use only.
189  *
190  *************************************************************************************************/
191 
192 struct UMutex : public icu::UMemory {
193     UMutex() = default;
194     ~UMutex() = default;
195     UMutex(const UMutex &amp;other) = delete;
196     UMutex &amp;operator =(const UMutex &amp;other) = delete;
197 
198     std::mutex   fMutex = {};    // Note: struct - pubic members - because most access is from
199     //                           //       plain C style functions (umtx_lock(), etc.)
200 };
201 
202 
203 struct UConditionVar : public icu::UMemory {
204     U_COMMON_API UConditionVar();
205     U_COMMON_API ~UConditionVar();
206     UConditionVar(const UConditionVar &amp;other) = delete;
207     UConditionVar &amp;operator =(const UConditionVar &amp;other) = delete;
208 
209     std::condition_variable_any fCV;
210 };
211 
212 #define U_MUTEX_INITIALIZER {}
213 #define U_CONDITION_INITIALIZER {}
214 
215 // Implementation notes for UConditionVar:
216 //
217 // Use an out-of-line constructor to reduce problems with the ICU dependency checker.
218 // On Linux, the default constructor of std::condition_variable_any
219 // produces an in-line reference to global operator new(), which the
220 // dependency checker flags for any file that declares a UConditionVar. With
221 // an out-of-line constructor, the dependency is constrained to umutex.o
222 //
223 // Do not export (U_COMMON_API) the entire class, but only the constructor
224 // and destructor, to avoid Windows build problems with attempting to export the
225 // std::condition_variable_any.
226 
227 /* Lock a mutex.
228  * @param mutex The given mutex to be locked.  Pass NULL to specify
229  *              the global ICU mutex.  Recursive locks are an error
230  *              and may cause a deadlock on some platforms.
231  */
232 U_INTERNAL void U_EXPORT2 umtx_lock(UMutex* mutex);
233 
234 /* Unlock a mutex.
235  * @param mutex The given mutex to be unlocked.  Pass NULL to specify
236  *              the global ICU mutex.
237  */
238 U_INTERNAL void U_EXPORT2 umtx_unlock (UMutex* mutex);
239 
240 /*
241  * Wait on a condition variable.
242  * The calling thread will unlock the mutex and wait on the condition variable.
243  * The mutex must be locked by the calling thread when invoking this function.
244  *
245  * @param cond the condition variable to wait on.
246  * @param mutex the associated mutex.
247  */
248 
249 U_INTERNAL void U_EXPORT2 umtx_condWait(UConditionVar *cond, UMutex *mutex);
250 
251 
252 /*
253  * Broadcast wakeup of all threads waiting on a Condition.
254  *
255  * @param cond the condition variable.
256  */
257 U_INTERNAL void U_EXPORT2 umtx_condBroadcast(UConditionVar *cond);
258 
259 /*
260  * Signal a condition variable, waking up one waiting thread.
261  */
262 U_INTERNAL void U_EXPORT2 umtx_condSignal(UConditionVar *cond);
263 
264 
265 U_NAMESPACE_END
266 
267 #endif /* UMUTEX_H */
268 /*eof*/
    </pre>
  </body>
</html>