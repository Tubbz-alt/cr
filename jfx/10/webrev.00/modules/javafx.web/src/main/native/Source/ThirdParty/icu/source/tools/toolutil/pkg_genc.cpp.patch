diff a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/tools/toolutil/pkg_genc.cpp b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/tools/toolutil/pkg_genc.cpp
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/tools/toolutil/pkg_genc.cpp
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/tools/toolutil/pkg_genc.cpp
@@ -307,20 +307,15 @@
         entry, entry, entry, entry);
     T_FileStream_writeLine(out, bufferStr);
     T_FileStream_writeLine(out, assemblyHeader[assemblyHeaderIndex].beginLine);
 
     for(;;) {
+        memset(buffer, 0, sizeof(buffer));
         length=T_FileStream_read(in, buffer, sizeof(buffer));
         if(length==0) {
             break;
         }
-        if (length != sizeof(buffer)) {
-            /* pad with extra 0's when at the end of the file */
-            for(i=0; i < (length % sizeof(uint32_t)); ++i) {
-                buffer[length+i] = 0;
-            }
-        }
         for(i=0; i<(length/sizeof(buffer[0])); i++) {
             column = write32(out, buffer[i], column);
         }
     }
 
@@ -683,27 +678,34 @@
         /* set EM_386 because elf.h does not provide better defaults */
         *pCPU=EM_386;
         *pBits=32;
         *pIsBigEndian=(UBool)(U_IS_BIG_ENDIAN ? ELFDATA2MSB : ELFDATA2LSB);
 #elif U_PLATFORM_HAS_WIN32_API
-/* _M_IA64 should be defined in windows.h */
-#   if defined(_M_IA64)
-        *pCPU=IMAGE_FILE_MACHINE_IA64;
-        *pBits = 64;
-#   elif defined(_M_AMD64)
-// link.exe does not really care about the .obj machine type and this will
-// allow us to build a dll for both ARM & x64 with an amd64 built tool
-// ARM is same as x64 except for first 2 bytes of object file
-        *pCPU = IMAGE_FILE_MACHINE_UNKNOWN;
-        // *pCPU = IMAGE_FILE_MACHINE_ARMNT;   // If we wanted to be explicit
-        // *pCPU = IMAGE_FILE_MACHINE_AMD64;   // We would use one of these names
-        *pBits = 64;                           // Doesn't seem to be used for anything interesting?
+        // Windows always runs in little-endian mode.
+        *pIsBigEndian = FALSE;
+
+        // Note: The various _M_<arch> macros are predefined by the MSVC compiler based
+        // on the target compilation architecture.
+        // https://docs.microsoft.com/cpp/preprocessor/predefined-macros
+
+        // link.exe will link an IMAGE_FILE_MACHINE_UNKNOWN data-only .obj file
+        // no matter what architecture it is targeting (though other values are
+        // required to match). Unfortunately, the variable name decoration/mangling
+        // is slightly different on x86, which means we can't use the UNKNOWN type
+        // for all architectures though.
+#   if defined(_M_IX86)
+        *pCPU = IMAGE_FILE_MACHINE_I386;
 #   else
-        *pCPU=IMAGE_FILE_MACHINE_I386;    // We would use one of these names
+        *pCPU = IMAGE_FILE_MACHINE_UNKNOWN;
+#   endif
+#   if defined(_M_IA64) || defined(_M_AMD64) || defined (_M_ARM64)
+        *pBits = 64; // Doesn't seem to be used for anything interesting though?
+#   elif defined(_M_IX86) || defined(_M_ARM)
         *pBits = 32;
+#   else
+#      error "Unknown platform for CAN_GENERATE_OBJECTS."
 #   endif
-        *pIsBigEndian=FALSE;
 #else
 #   error "Unknown platform for CAN_GENERATE_OBJECTS."
 #endif
         return;
     }
