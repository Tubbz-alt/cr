<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/translit.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4  **********************************************************************
   5  *   Copyright (C) 1999-2016, International Business Machines
   6  *   Corporation and others.  All Rights Reserved.
   7  **********************************************************************
   8  *   Date        Name        Description
   9  *   11/17/99    aliu        Creation.
  10  **********************************************************************
  11  */
  12 
  13 #include &quot;utypeinfo.h&quot;  // for &#39;typeid&#39; to work
  14 
  15 #include &quot;unicode/utypes.h&quot;
  16 
  17 #if !UCONFIG_NO_TRANSLITERATION
  18 
  19 #include &quot;unicode/putil.h&quot;
  20 #include &quot;unicode/translit.h&quot;
  21 #include &quot;unicode/locid.h&quot;
  22 #include &quot;unicode/msgfmt.h&quot;
  23 #include &quot;unicode/rep.h&quot;
  24 #include &quot;unicode/resbund.h&quot;
  25 #include &quot;unicode/unifilt.h&quot;
  26 #include &quot;unicode/uniset.h&quot;
  27 #include &quot;unicode/uscript.h&quot;
  28 #include &quot;unicode/strenum.h&quot;
  29 #include &quot;unicode/utf16.h&quot;
  30 #include &quot;cpdtrans.h&quot;
  31 #include &quot;nultrans.h&quot;
  32 #include &quot;rbt_data.h&quot;
  33 #include &quot;rbt_pars.h&quot;
  34 #include &quot;rbt.h&quot;
  35 #include &quot;transreg.h&quot;
  36 #include &quot;name2uni.h&quot;
  37 #include &quot;nortrans.h&quot;
  38 #include &quot;remtrans.h&quot;
  39 #include &quot;titletrn.h&quot;
  40 #include &quot;tolowtrn.h&quot;
  41 #include &quot;toupptrn.h&quot;
  42 #include &quot;uni2name.h&quot;
  43 #include &quot;brktrans.h&quot;
  44 #include &quot;esctrn.h&quot;
  45 #include &quot;unesctrn.h&quot;
  46 #include &quot;tridpars.h&quot;
  47 #include &quot;anytrans.h&quot;
  48 #include &quot;util.h&quot;
  49 #include &quot;hash.h&quot;
  50 #include &quot;mutex.h&quot;
  51 #include &quot;ucln_in.h&quot;
  52 #include &quot;uassert.h&quot;
  53 #include &quot;cmemory.h&quot;
  54 #include &quot;cstring.h&quot;
  55 #include &quot;uinvchar.h&quot;
  56 
  57 static const UChar TARGET_SEP  = 0x002D; /*-*/
  58 static const UChar ID_DELIM    = 0x003B; /*;*/
  59 static const UChar VARIANT_SEP = 0x002F; // &#39;/&#39;
  60 
  61 /**
  62  * Prefix for resource bundle key for the display name for a
  63  * transliterator.  The ID is appended to this to form the key.
  64  * The resource bundle value should be a String.
  65  */
  66 static const char RB_DISPLAY_NAME_PREFIX[] = &quot;%Translit%%&quot;;
  67 
  68 /**
  69  * Prefix for resource bundle key for the display name for a
  70  * transliterator SCRIPT.  The ID is appended to this to form the key.
  71  * The resource bundle value should be a String.
  72  */
  73 static const char RB_SCRIPT_DISPLAY_NAME_PREFIX[] = &quot;%Translit%&quot;;
  74 
  75 /**
  76  * Resource bundle key for display name pattern.
  77  * The resource bundle value should be a String forming a
  78  * MessageFormat pattern, e.g.:
  79  * &quot;{0,choice,0#|1#{1} Transliterator|2#{1} to {2} Transliterator}&quot;.
  80  */
  81 static const char RB_DISPLAY_NAME_PATTERN[] = &quot;TransliteratorNamePattern&quot;;
  82 
  83 /**
  84  * Resource bundle key for the list of RuleBasedTransliterator IDs.
  85  * The resource bundle value should be a String[] with each element
  86  * being a valid ID.  The ID will be appended to RB_RULE_BASED_PREFIX
  87  * to obtain the class name in which the RB_RULE key will be sought.
  88  */
  89 static const char RB_RULE_BASED_IDS[] = &quot;RuleBasedTransliteratorIDs&quot;;
  90 
  91 /**
  92  * The mutex controlling access to registry object.
  93  */
<a name="1" id="anc1"></a><span class="line-modified">  94 static UMutex registryMutex = U_MUTEX_INITIALIZER;</span>



  95 
  96 /**
  97  * System transliterator registry; non-null when initialized.
  98  */
  99 static icu::TransliteratorRegistry* registry = 0;
 100 
 101 // Macro to check/initialize the registry. ONLY USE WITHIN
 102 // MUTEX. Avoids function call when registry is initialized.
 103 #define HAVE_REGISTRY(status) (registry!=0 || initializeRegistry(status))
 104 
 105 U_NAMESPACE_BEGIN
 106 
 107 UOBJECT_DEFINE_ABSTRACT_RTTI_IMPLEMENTATION(Transliterator)
 108 
 109 /**
 110  * Return TRUE if the given UTransPosition is valid for text of
 111  * the given length.
 112  */
 113 static inline UBool positionIsValid(UTransPosition&amp; index, int32_t len) {
 114     return !(index.contextStart &lt; 0 ||
 115              index.start &lt; index.contextStart ||
 116              index.limit &lt; index.start ||
 117              index.contextLimit &lt; index.limit ||
 118              len &lt; index.contextLimit);
 119 }
 120 
 121 /**
 122  * Default constructor.
 123  * @param theID the string identifier for this transliterator
 124  * @param theFilter the filter.  Any character for which
 125  * &lt;tt&gt;filter.contains()&lt;/tt&gt; returns &lt;tt&gt;FALSE&lt;/tt&gt; will not be
 126  * altered by this transliterator.  If &lt;tt&gt;filter&lt;/tt&gt; is
 127  * &lt;tt&gt;null&lt;/tt&gt; then no filtering is applied.
 128  */
 129 Transliterator::Transliterator(const UnicodeString&amp; theID,
 130                                UnicodeFilter* adoptedFilter) :
 131     UObject(), ID(theID), filter(adoptedFilter),
 132     maximumContextLength(0)
 133 {
 134     // NUL-terminate the ID string, which is a non-aliased copy.
 135     ID.append((UChar)0);
 136     ID.truncate(ID.length()-1);
 137 }
 138 
 139 /**
 140  * Destructor.
 141  */
 142 Transliterator::~Transliterator() {
 143     if (filter) {
 144         delete filter;
 145     }
 146 }
 147 
 148 /**
 149  * Copy constructor.
 150  */
 151 Transliterator::Transliterator(const Transliterator&amp; other) :
 152     UObject(other), ID(other.ID), filter(0),
 153     maximumContextLength(other.maximumContextLength)
 154 {
 155     // NUL-terminate the ID string, which is a non-aliased copy.
 156     ID.append((UChar)0);
 157     ID.truncate(ID.length()-1);
 158 
 159     if (other.filter != 0) {
 160         // We own the filter, so we must have our own copy
 161         filter = (UnicodeFilter*) other.filter-&gt;clone();
 162     }
 163 }
 164 
 165 Transliterator* Transliterator::clone() const {
 166     return NULL;
 167 }
 168 
 169 /**
 170  * Assignment operator.
 171  */
 172 Transliterator&amp; Transliterator::operator=(const Transliterator&amp; other) {
 173     ID = other.ID;
 174     // NUL-terminate the ID string
 175     ID.getTerminatedBuffer();
 176 
 177     maximumContextLength = other.maximumContextLength;
 178     adoptFilter((other.filter == 0) ? 0 : (UnicodeFilter*) other.filter-&gt;clone());
 179     return *this;
 180 }
 181 
 182 /**
 183  * Transliterates a segment of a string.  &lt;code&gt;Transliterator&lt;/code&gt; API.
 184  * @param text the string to be transliterated
 185  * @param start the beginning index, inclusive; &lt;code&gt;0 &lt;= start
 186  * &lt;= limit&lt;/code&gt;.
 187  * @param limit the ending index, exclusive; &lt;code&gt;start &lt;= limit
 188  * &lt;= text.length()&lt;/code&gt;.
 189  * @return the new limit index, or -1
 190  */
 191 int32_t Transliterator::transliterate(Replaceable&amp; text,
 192                                       int32_t start, int32_t limit) const {
 193     if (start &lt; 0 ||
 194         limit &lt; start ||
 195         text.length() &lt; limit) {
 196         return -1;
 197     }
 198 
 199     UTransPosition offsets;
 200     offsets.contextStart= start;
 201     offsets.contextLimit = limit;
 202     offsets.start = start;
 203     offsets.limit = limit;
 204     filteredTransliterate(text, offsets, FALSE, TRUE);
 205     return offsets.limit;
 206 }
 207 
 208 /**
 209  * Transliterates an entire string in place. Convenience method.
 210  * @param text the string to be transliterated
 211  */
 212 void Transliterator::transliterate(Replaceable&amp; text) const {
 213     transliterate(text, 0, text.length());
 214 }
 215 
 216 /**
 217  * Transliterates the portion of the text buffer that can be
 218  * transliterated unambiguosly after new text has been inserted,
 219  * typically as a result of a keyboard event.  The new text in
 220  * &lt;code&gt;insertion&lt;/code&gt; will be inserted into &lt;code&gt;text&lt;/code&gt;
 221  * at &lt;code&gt;index.contextLimit&lt;/code&gt;, advancing
 222  * &lt;code&gt;index.contextLimit&lt;/code&gt; by &lt;code&gt;insertion.length()&lt;/code&gt;.
 223  * Then the transliterator will try to transliterate characters of
 224  * &lt;code&gt;text&lt;/code&gt; between &lt;code&gt;index.start&lt;/code&gt; and
 225  * &lt;code&gt;index.contextLimit&lt;/code&gt;.  Characters before
 226  * &lt;code&gt;index.start&lt;/code&gt; will not be changed.
 227  *
 228  * &lt;p&gt;Upon return, values in &lt;code&gt;index&lt;/code&gt; will be updated.
 229  * &lt;code&gt;index.contextStart&lt;/code&gt; will be advanced to the first
 230  * character that future calls to this method will read.
 231  * &lt;code&gt;index.start&lt;/code&gt; and &lt;code&gt;index.contextLimit&lt;/code&gt; will
 232  * be adjusted to delimit the range of text that future calls to
 233  * this method may change.
 234  *
 235  * &lt;p&gt;Typical usage of this method begins with an initial call
 236  * with &lt;code&gt;index.contextStart&lt;/code&gt; and &lt;code&gt;index.contextLimit&lt;/code&gt;
 237  * set to indicate the portion of &lt;code&gt;text&lt;/code&gt; to be
 238  * transliterated, and &lt;code&gt;index.start == index.contextStart&lt;/code&gt;.
 239  * Thereafter, &lt;code&gt;index&lt;/code&gt; can be used without
 240  * modification in future calls, provided that all changes to
 241  * &lt;code&gt;text&lt;/code&gt; are made via this method.
 242  *
 243  * &lt;p&gt;This method assumes that future calls may be made that will
 244  * insert new text into the buffer.  As a result, it only performs
 245  * unambiguous transliterations.  After the last call to this
 246  * method, there may be untransliterated text that is waiting for
 247  * more input to resolve an ambiguity.  In order to perform these
 248  * pending transliterations, clients should call {@link
 249  * #finishKeyboardTransliteration} after the last call to this
 250  * method has been made.
 251  *
 252  * @param text the buffer holding transliterated and untransliterated text
 253  * @param index an array of three integers.
 254  *
 255  * &lt;ul&gt;&lt;li&gt;&lt;code&gt;index.contextStart&lt;/code&gt;: the beginning index,
 256  * inclusive; &lt;code&gt;0 &lt;= index.contextStart &lt;= index.contextLimit&lt;/code&gt;.
 257  *
 258  * &lt;li&gt;&lt;code&gt;index.contextLimit&lt;/code&gt;: the ending index, exclusive;
 259  * &lt;code&gt;index.contextStart &lt;= index.contextLimit &lt;= text.length()&lt;/code&gt;.
 260  * &lt;code&gt;insertion&lt;/code&gt; is inserted at
 261  * &lt;code&gt;index.contextLimit&lt;/code&gt;.
 262  *
 263  * &lt;li&gt;&lt;code&gt;index.start&lt;/code&gt;: the next character to be
 264  * considered for transliteration; &lt;code&gt;index.contextStart &lt;=
 265  * index.start &lt;= index.contextLimit&lt;/code&gt;.  Characters before
 266  * &lt;code&gt;index.start&lt;/code&gt; will not be changed by future calls
 267  * to this method.&lt;/ul&gt;
 268  *
 269  * @param insertion text to be inserted and possibly
 270  * transliterated into the translation buffer at
 271  * &lt;code&gt;index.contextLimit&lt;/code&gt;.  If &lt;code&gt;null&lt;/code&gt; then no text
 272  * is inserted.
 273  * @see #START
 274  * @see #LIMIT
 275  * @see #CURSOR
 276  * @see #handleTransliterate
 277  * @exception IllegalArgumentException if &lt;code&gt;index&lt;/code&gt;
 278  * is invalid
 279  */
 280 void Transliterator::transliterate(Replaceable&amp; text,
 281                                    UTransPosition&amp; index,
 282                                    const UnicodeString&amp; insertion,
 283                                    UErrorCode &amp;status) const {
 284     _transliterate(text, index, &amp;insertion, status);
 285 }
 286 
 287 /**
 288  * Transliterates the portion of the text buffer that can be
 289  * transliterated unambiguosly after a new character has been
 290  * inserted, typically as a result of a keyboard event.  This is a
 291  * convenience method; see {@link
 292  * #transliterate(Replaceable, int[], String)} for details.
 293  * @param text the buffer holding transliterated and
 294  * untransliterated text
 295  * @param index an array of three integers.  See {@link
 296  * #transliterate(Replaceable, int[], String)}.
 297  * @param insertion text to be inserted and possibly
 298  * transliterated into the translation buffer at
 299  * &lt;code&gt;index.contextLimit&lt;/code&gt;.
 300  * @see #transliterate(Replaceable, int[], String)
 301  */
 302 void Transliterator::transliterate(Replaceable&amp; text,
 303                                    UTransPosition&amp; index,
 304                                    UChar32 insertion,
 305                                    UErrorCode&amp; status) const {
 306     UnicodeString str(insertion);
 307     _transliterate(text, index, &amp;str, status);
 308 }
 309 
 310 /**
 311  * Transliterates the portion of the text buffer that can be
 312  * transliterated unambiguosly.  This is a convenience method; see
 313  * {@link #transliterate(Replaceable, int[], String)} for
 314  * details.
 315  * @param text the buffer holding transliterated and
 316  * untransliterated text
 317  * @param index an array of three integers.  See {@link
 318  * #transliterate(Replaceable, int[], String)}.
 319  * @see #transliterate(Replaceable, int[], String)
 320  */
 321 void Transliterator::transliterate(Replaceable&amp; text,
 322                                    UTransPosition&amp; index,
 323                                    UErrorCode&amp; status) const {
 324     _transliterate(text, index, 0, status);
 325 }
 326 
 327 /**
 328  * Finishes any pending transliterations that were waiting for
 329  * more characters.  Clients should call this method as the last
 330  * call after a sequence of one or more calls to
 331  * &lt;code&gt;transliterate()&lt;/code&gt;.
 332  * @param text the buffer holding transliterated and
 333  * untransliterated text.
 334  * @param index the array of indices previously passed to {@link
 335  * #transliterate}
 336  */
 337 void Transliterator::finishTransliteration(Replaceable&amp; text,
 338                                            UTransPosition&amp; index) const {
 339     if (!positionIsValid(index, text.length())) {
 340         return;
 341     }
 342 
 343     filteredTransliterate(text, index, FALSE, TRUE);
 344 }
 345 
 346 /**
 347  * This internal method does keyboard transliteration.  If the
 348  * &#39;insertion&#39; is non-null then we append it to &#39;text&#39; before
 349  * proceeding.  This method calls through to the pure virtual
 350  * framework method handleTransliterate() to do the actual
 351  * work.
 352  */
 353 void Transliterator::_transliterate(Replaceable&amp; text,
 354                                     UTransPosition&amp; index,
 355                                     const UnicodeString* insertion,
 356                                     UErrorCode &amp;status) const {
 357     if (U_FAILURE(status)) {
 358         return;
 359     }
 360 
 361     if (!positionIsValid(index, text.length())) {
 362         status = U_ILLEGAL_ARGUMENT_ERROR;
 363         return;
 364     }
 365 
 366 //    int32_t originalStart = index.contextStart;
 367     if (insertion != 0) {
 368         text.handleReplaceBetween(index.limit, index.limit, *insertion);
 369         index.limit += insertion-&gt;length();
 370         index.contextLimit += insertion-&gt;length();
 371     }
 372 
 373     if (index.limit &gt; 0 &amp;&amp;
 374         U16_IS_LEAD(text.charAt(index.limit - 1))) {
 375         // Oops, there is a dangling lead surrogate in the buffer.
 376         // This will break most transliterators, since they will
 377         // assume it is part of a pair.  Don&#39;t transliterate until
 378         // more text comes in.
 379         return;
 380     }
 381 
 382     filteredTransliterate(text, index, TRUE, TRUE);
 383 
 384 #if 0
 385     // TODO
 386     // I CAN&#39;T DO what I&#39;m attempting below now that the Kleene star
 387     // operator is supported.  For example, in the rule
 388 
 389     //   ([:Lu:]+) { x } &gt; $1;
 390 
 391     // what is the maximum context length?  getMaximumContextLength()
 392     // will return 1, but this is just the length of the ante context
 393     // part of the pattern string -- 1 character, which is a standin
 394     // for a Quantifier, which contains a StringMatcher, which
 395     // contains a UnicodeSet.
 396 
 397     // There is a complicated way to make this work again, and that&#39;s
 398     // to add a &quot;maximum left context&quot; protocol into the
 399     // UnicodeMatcher hierarchy.  At present I&#39;m not convinced this is
 400     // worth it.
 401 
 402     // ---
 403 
 404     // The purpose of the code below is to keep the context small
 405     // while doing incremental transliteration.  When part of the left
 406     // context (between contextStart and start) is no longer needed,
 407     // we try to advance contextStart past that portion.  We use the
 408     // maximum context length to do so.
 409     int32_t newCS = index.start;
 410     int32_t n = getMaximumContextLength();
 411     while (newCS &gt; originalStart &amp;&amp; n-- &gt; 0) {
 412         --newCS;
 413         newCS -= U16_LENGTH(text.char32At(newCS)) - 1;
 414     }
 415     index.contextStart = uprv_max(newCS, originalStart);
 416 #endif
 417 }
 418 
 419 /**
 420  * This method breaks up the input text into runs of unfiltered
 421  * characters.  It passes each such run to
 422  * &lt;subclass&gt;.handleTransliterate().  Subclasses that can handle the
 423  * filter logic more efficiently themselves may override this method.
 424  *
 425  * All transliteration calls in this class go through this method.
 426  */
 427 void Transliterator::filteredTransliterate(Replaceable&amp; text,
 428                                            UTransPosition&amp; index,
 429                                            UBool incremental,
 430                                            UBool rollback) const {
 431     // Short circuit path for transliterators with no filter in
 432     // non-incremental mode.
 433     if (filter == 0 &amp;&amp; !rollback) {
 434         handleTransliterate(text, index, incremental);
 435         return;
 436     }
 437 
 438     //----------------------------------------------------------------------
 439     // This method processes text in two groupings:
 440     //
 441     // RUNS -- A run is a contiguous group of characters which are contained
 442     // in the filter for this transliterator (filter.contains(ch) == TRUE).
 443     // Text outside of runs may appear as context but it is not modified.
 444     // The start and limit Position values are narrowed to each run.
 445     //
 446     // PASSES (incremental only) -- To make incremental mode work correctly,
 447     // each run is broken up into n passes, where n is the length (in code
 448     // points) of the run.  Each pass contains the first n characters.  If a
 449     // pass is completely transliterated, it is committed, and further passes
 450     // include characters after the committed text.  If a pass is blocked,
 451     // and does not transliterate completely, then this method rolls back
 452     // the changes made during the pass, extends the pass by one code point,
 453     // and tries again.
 454     //----------------------------------------------------------------------
 455 
 456     // globalLimit is the limit value for the entire operation.  We
 457     // set index.limit to the end of each unfiltered run before
 458     // calling handleTransliterate(), so we need to maintain the real
 459     // value of index.limit here.  After each transliteration, we
 460     // update globalLimit for insertions or deletions that have
 461     // happened.
 462     int32_t globalLimit = index.limit;
 463 
 464     // If there is a non-null filter, then break the input text up.  Say the
 465     // input text has the form:
 466     //   xxxabcxxdefxx
 467     // where &#39;x&#39; represents a filtered character (filter.contains(&#39;x&#39;) ==
 468     // false).  Then we break this up into:
 469     //   xxxabc xxdef xx
 470     // Each pass through the loop consumes a run of filtered
 471     // characters (which are ignored) and a subsequent run of
 472     // unfiltered characters (which are transliterated).
 473 
 474     for (;;) {
 475 
 476         if (filter != NULL) {
 477             // Narrow the range to be transliterated to the first segment
 478             // of unfiltered characters at or after index.start.
 479 
 480             // Advance past filtered chars
 481             UChar32 c;
 482             while (index.start &lt; globalLimit &amp;&amp;
 483                    !filter-&gt;contains(c=text.char32At(index.start))) {
 484                 index.start += U16_LENGTH(c);
 485             }
 486 
 487             // Find the end of this run of unfiltered chars
 488             index.limit = index.start;
 489             while (index.limit &lt; globalLimit &amp;&amp;
 490                    filter-&gt;contains(c=text.char32At(index.limit))) {
 491                 index.limit += U16_LENGTH(c);
 492             }
 493         }
 494 
 495         // Check to see if the unfiltered run is empty.  This only
 496         // happens at the end of the string when all the remaining
 497         // characters are filtered.
 498         if (index.limit == index.start) {
 499             // assert(index.start == globalLimit);
 500             break;
 501         }
 502 
 503         // Is this run incremental?  If there is additional
 504         // filtered text (if limit &lt; globalLimit) then we pass in
 505         // an incremental value of FALSE to force the subclass to
 506         // complete the transliteration for this run.
 507         UBool isIncrementalRun =
 508             (index.limit &lt; globalLimit ? FALSE : incremental);
 509 
 510         int32_t delta;
 511 
 512         // Implement rollback.  To understand the need for rollback,
 513         // consider the following transliterator:
 514         //
 515         //  &quot;t&quot; is &quot;a &gt; A;&quot;
 516         //  &quot;u&quot; is &quot;A &gt; b;&quot;
 517         //  &quot;v&quot; is a compound of &quot;t; NFD; u&quot; with a filter [:Ll:]
 518         //
 519         // Now apply &quot;c&quot; to the input text &quot;a&quot;.  The result is &quot;b&quot;.  But if
 520         // the transliteration is done incrementally, then the NFD holds
 521         // things up after &quot;t&quot; has already transformed &quot;a&quot; to &quot;A&quot;.  When
 522         // finishTransliterate() is called, &quot;A&quot; is _not_ processed because
 523         // it gets excluded by the [:Ll:] filter, and the end result is &quot;A&quot;
 524         // -- incorrect.  The problem is that the filter is applied to a
 525         // partially-transliterated result, when we only want it to apply to
 526         // input text.  Although this example hinges on a compound
 527         // transliterator containing NFD and a specific filter, it can
 528         // actually happen with any transliterator which may do a partial
 529         // transformation in incremental mode into characters outside its
 530         // filter.
 531         //
 532         // To handle this, when in incremental mode we supply characters to
 533         // handleTransliterate() in several passes.  Each pass adds one more
 534         // input character to the input text.  That is, for input &quot;ABCD&quot;, we
 535         // first try &quot;A&quot;, then &quot;AB&quot;, then &quot;ABC&quot;, and finally &quot;ABCD&quot;.  If at
 536         // any point we block (upon return, start &lt; limit) then we roll
 537         // back.  If at any point we complete the run (upon return start ==
 538         // limit) then we commit that run.
 539 
 540         if (rollback &amp;&amp; isIncrementalRun) {
 541 
 542             int32_t runStart = index.start;
 543             int32_t runLimit = index.limit;
 544             int32_t runLength =  runLimit - runStart;
 545 
 546             // Make a rollback copy at the end of the string
 547             int32_t rollbackOrigin = text.length();
 548             text.copy(runStart, runLimit, rollbackOrigin);
 549 
 550             // Variables reflecting the commitment of completely
 551             // transliterated text.  passStart is the runStart, advanced
 552             // past committed text.  rollbackStart is the rollbackOrigin,
 553             // advanced past rollback text that corresponds to committed
 554             // text.
 555             int32_t passStart = runStart;
 556             int32_t rollbackStart = rollbackOrigin;
 557 
 558             // The limit for each pass; we advance by one code point with
 559             // each iteration.
 560             int32_t passLimit = index.start;
 561 
 562             // Total length, in 16-bit code units, of uncommitted text.
 563             // This is the length to be rolled back.
 564             int32_t uncommittedLength = 0;
 565 
 566             // Total delta (change in length) for all passes
 567             int32_t totalDelta = 0;
 568 
 569             // PASS MAIN LOOP -- Start with a single character, and extend
 570             // the text by one character at a time.  Roll back partial
 571             // transliterations and commit complete transliterations.
 572             for (;;) {
 573                 // Length of additional code point, either one or two
 574                 int32_t charLength = U16_LENGTH(text.char32At(passLimit));
 575                 passLimit += charLength;
 576                 if (passLimit &gt; runLimit) {
 577                     break;
 578                 }
 579                 uncommittedLength += charLength;
 580 
 581                 index.limit = passLimit;
 582 
 583                 // Delegate to subclass for actual transliteration.  Upon
 584                 // return, start will be updated to point after the
 585                 // transliterated text, and limit and contextLimit will be
 586                 // adjusted for length changes.
 587                 handleTransliterate(text, index, TRUE);
 588 
 589                 delta = index.limit - passLimit; // change in length
 590 
 591                 // We failed to completely transliterate this pass.
 592                 // Roll back the text.  Indices remain unchanged; reset
 593                 // them where necessary.
 594                 if (index.start != index.limit) {
 595                     // Find the rollbackStart, adjusted for length changes
 596                     // and the deletion of partially transliterated text.
 597                     int32_t rs = rollbackStart + delta - (index.limit - passStart);
 598 
 599                     // Delete the partially transliterated text
 600                     text.handleReplaceBetween(passStart, index.limit, UnicodeString());
 601 
 602                     // Copy the rollback text back
 603                     text.copy(rs, rs + uncommittedLength, passStart);
 604 
 605                     // Restore indices to their original values
 606                     index.start = passStart;
 607                     index.limit = passLimit;
 608                     index.contextLimit -= delta;
 609                 }
 610 
 611                 // We did completely transliterate this pass.  Update the
 612                 // commit indices to record how far we got.  Adjust indices
 613                 // for length change.
 614                 else {
 615                     // Move the pass indices past the committed text.
 616                     passStart = passLimit = index.start;
 617 
 618                     // Adjust the rollbackStart for length changes and move
 619                     // it past the committed text.  All characters we&#39;ve
 620                     // processed to this point are committed now, so zero
 621                     // out the uncommittedLength.
 622                     rollbackStart += delta + uncommittedLength;
 623                     uncommittedLength = 0;
 624 
 625                     // Adjust indices for length changes.
 626                     runLimit += delta;
 627                     totalDelta += delta;
 628                 }
 629             }
 630 
 631             // Adjust overall limit and rollbackOrigin for insertions and
 632             // deletions.  Don&#39;t need to worry about contextLimit because
 633             // handleTransliterate() maintains that.
 634             rollbackOrigin += totalDelta;
 635             globalLimit += totalDelta;
 636 
 637             // Delete the rollback copy
 638             text.handleReplaceBetween(rollbackOrigin, rollbackOrigin + runLength, UnicodeString());
 639 
 640             // Move start past committed text
 641             index.start = passStart;
 642         }
 643 
 644         else {
 645             // Delegate to subclass for actual transliteration.
 646             int32_t limit = index.limit;
 647             handleTransliterate(text, index, isIncrementalRun);
 648             delta = index.limit - limit; // change in length
 649 
 650             // In a properly written transliterator, start == limit after
 651             // handleTransliterate() returns when incremental is false.
 652             // Catch cases where the subclass doesn&#39;t do this, and throw
 653             // an exception.  (Just pinning start to limit is a bad idea,
 654             // because what&#39;s probably happening is that the subclass
 655             // isn&#39;t transliterating all the way to the end, and it should
 656             // in non-incremental mode.)
 657             if (!incremental &amp;&amp; index.start != index.limit) {
 658                 // We can&#39;t throw an exception, so just fudge things
 659                 index.start = index.limit;
 660             }
 661 
 662             // Adjust overall limit for insertions/deletions.  Don&#39;t need
 663             // to worry about contextLimit because handleTransliterate()
 664             // maintains that.
 665             globalLimit += delta;
 666         }
 667 
 668         if (filter == NULL || isIncrementalRun) {
 669             break;
 670         }
 671 
 672         // If we did completely transliterate this
 673         // run, then repeat with the next unfiltered run.
 674     }
 675 
 676     // Start is valid where it is.  Limit needs to be put back where
 677     // it was, modulo adjustments for deletions/insertions.
 678     index.limit = globalLimit;
 679 }
 680 
 681 void Transliterator::filteredTransliterate(Replaceable&amp; text,
 682                                            UTransPosition&amp; index,
 683                                            UBool incremental) const {
 684     filteredTransliterate(text, index, incremental, FALSE);
 685 }
 686 
 687 /**
 688  * Method for subclasses to use to set the maximum context length.
 689  * @see #getMaximumContextLength
 690  */
 691 void Transliterator::setMaximumContextLength(int32_t maxContextLength) {
 692     maximumContextLength = maxContextLength;
 693 }
 694 
 695 /**
 696  * Returns a programmatic identifier for this transliterator.
 697  * If this identifier is passed to &lt;code&gt;getInstance()&lt;/code&gt;, it
 698  * will return this object, if it has been registered.
 699  * @see #registerInstance
 700  * @see #getAvailableIDs
 701  */
 702 const UnicodeString&amp; Transliterator::getID(void) const {
 703     return ID;
 704 }
 705 
 706 /**
 707  * Returns a name for this transliterator that is appropriate for
 708  * display to the user in the default locale.  See {@link
 709  * #getDisplayName(Locale)} for details.
 710  */
 711 UnicodeString&amp; U_EXPORT2 Transliterator::getDisplayName(const UnicodeString&amp; ID,
 712                                               UnicodeString&amp; result) {
 713     return getDisplayName(ID, Locale::getDefault(), result);
 714 }
 715 
 716 /**
 717  * Returns a name for this transliterator that is appropriate for
 718  * display to the user in the given locale.  This name is taken
 719  * from the locale resource data in the standard manner of the
 720  * &lt;code&gt;java.text&lt;/code&gt; package.
 721  *
 722  * &lt;p&gt;If no localized names exist in the system resource bundles,
 723  * a name is synthesized using a localized
 724  * &lt;code&gt;MessageFormat&lt;/code&gt; pattern from the resource data.  The
 725  * arguments to this pattern are an integer followed by one or two
 726  * strings.  The integer is the number of strings, either 1 or 2.
 727  * The strings are formed by splitting the ID for this
 728  * transliterator at the first TARGET_SEP.  If there is no TARGET_SEP, then the
 729  * entire ID forms the only string.
 730  * @param inLocale the Locale in which the display name should be
 731  * localized.
 732  * @see java.text.MessageFormat
 733  */
 734 UnicodeString&amp; U_EXPORT2 Transliterator::getDisplayName(const UnicodeString&amp; id,
 735                                               const Locale&amp; inLocale,
 736                                               UnicodeString&amp; result) {
 737     UErrorCode status = U_ZERO_ERROR;
 738 
 739     ResourceBundle bundle(U_ICUDATA_TRANSLIT, inLocale, status);
 740 
 741     // Suspend checking status until later...
 742 
 743     result.truncate(0);
 744 
 745     // Normalize the ID
 746     UnicodeString source, target, variant;
 747     UBool sawSource;
 748     TransliteratorIDParser::IDtoSTV(id, source, target, variant, sawSource);
 749     if (target.length() &lt; 1) {
 750         // No target; malformed id
 751         return result;
 752     }
 753     if (variant.length() &gt; 0) { // Change &quot;Foo&quot; to &quot;/Foo&quot;
 754         variant.insert(0, VARIANT_SEP);
 755     }
 756     UnicodeString ID(source);
 757     ID.append(TARGET_SEP).append(target).append(variant);
 758 
 759     // build the char* key
 760     if (uprv_isInvariantUString(ID.getBuffer(), ID.length())) {
 761         char key[200];
 762         uprv_strcpy(key, RB_DISPLAY_NAME_PREFIX);
 763         int32_t length=(int32_t)uprv_strlen(RB_DISPLAY_NAME_PREFIX);
 764         ID.extract(0, (int32_t)(sizeof(key)-length), key+length, (int32_t)(sizeof(key)-length), US_INV);
 765 
 766         // Try to retrieve a UnicodeString from the bundle.
 767         UnicodeString resString = bundle.getStringEx(key, status);
 768 
 769         if (U_SUCCESS(status) &amp;&amp; resString.length() != 0) {
 770             return result = resString; // [sic] assign &amp; return
 771         }
 772 
 773 #if !UCONFIG_NO_FORMATTING
 774         // We have failed to get a name from the locale data.  This is
 775         // typical, since most transliterators will not have localized
 776         // name data.  The next step is to retrieve the MessageFormat
 777         // pattern from the locale data and to use it to synthesize the
 778         // name from the ID.
 779 
 780         status = U_ZERO_ERROR;
 781         resString = bundle.getStringEx(RB_DISPLAY_NAME_PATTERN, status);
 782 
 783         if (U_SUCCESS(status) &amp;&amp; resString.length() != 0) {
 784             MessageFormat msg(resString, inLocale, status);
 785             // Suspend checking status until later...
 786 
 787             // We pass either 2 or 3 Formattable objects to msg.
 788             Formattable args[3];
 789             int32_t nargs;
 790             args[0].setLong(2); // # of args to follow
 791             args[1].setString(source);
 792             args[2].setString(target);
 793             nargs = 3;
 794 
 795             // Use display names for the scripts, if they exist
 796             UnicodeString s;
 797             length=(int32_t)uprv_strlen(RB_SCRIPT_DISPLAY_NAME_PREFIX);
 798             for (int j=1; j&lt;=2; ++j) {
 799                 status = U_ZERO_ERROR;
 800                 uprv_strcpy(key, RB_SCRIPT_DISPLAY_NAME_PREFIX);
 801                 args[j].getString(s);
 802                 if (uprv_isInvariantUString(s.getBuffer(), s.length())) {
 803                     s.extract(0, sizeof(key)-length-1, key+length, (int32_t)sizeof(key)-length-1, US_INV);
 804 
 805                     resString = bundle.getStringEx(key, status);
 806 
 807                     if (U_SUCCESS(status)) {
 808                         args[j] = resString;
 809                     }
 810                 }
 811             }
 812 
 813             status = U_ZERO_ERROR;
 814             FieldPosition pos; // ignored by msg
 815             msg.format(args, nargs, result, pos, status);
 816             if (U_SUCCESS(status)) {
 817                 result.append(variant);
 818                 return result;
 819             }
 820         }
 821 #endif
 822     }
 823 
 824     // We should not reach this point unless there is something
 825     // wrong with the build or the RB_DISPLAY_NAME_PATTERN has
 826     // been deleted from the root RB_LOCALE_ELEMENTS resource.
 827     result = ID;
 828     return result;
 829 }
 830 
 831 /**
 832  * Returns the filter used by this transliterator, or &lt;tt&gt;null&lt;/tt&gt;
 833  * if this transliterator uses no filter.  Caller musn&#39;t delete
 834  * the result!
 835  */
 836 const UnicodeFilter* Transliterator::getFilter(void) const {
 837     return filter;
 838 }
 839 
 840 /**
 841  * Returns the filter used by this transliterator, or
 842  * &lt;tt&gt;NULL&lt;/tt&gt; if this transliterator uses no filter.  The
 843  * caller must eventually delete the result.  After this call,
 844  * this transliterator&#39;s filter is set to &lt;tt&gt;NULL&lt;/tt&gt;.
 845  */
 846 UnicodeFilter* Transliterator::orphanFilter(void) {
 847     UnicodeFilter *result = filter;
 848     filter = NULL;
 849     return result;
 850 }
 851 
 852 /**
 853  * Changes the filter used by this transliterator.  If the filter
 854  * is set to &lt;tt&gt;null&lt;/tt&gt; then no filtering will occur.
 855  *
 856  * &lt;p&gt;Callers must take care if a transliterator is in use by
 857  * multiple threads.  The filter should not be changed by one
 858  * thread while another thread may be transliterating.
 859  */
 860 void Transliterator::adoptFilter(UnicodeFilter* filterToAdopt) {
 861     delete filter;
 862     filter = filterToAdopt;
 863 }
 864 
 865 /**
 866  * Returns this transliterator&#39;s inverse.  See the class
 867  * documentation for details.  This implementation simply inverts
 868  * the two entities in the ID and attempts to retrieve the
 869  * resulting transliterator.  That is, if &lt;code&gt;getID()&lt;/code&gt;
 870  * returns &quot;A-B&quot;, then this method will return the result of
 871  * &lt;code&gt;getInstance(&quot;B-A&quot;)&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if that
 872  * call fails.
 873  *
 874  * &lt;p&gt;This method does not take filtering into account.  The
 875  * returned transliterator will have no filter.
 876  *
 877  * &lt;p&gt;Subclasses with knowledge of their inverse may wish to
 878  * override this method.
 879  *
 880  * @return a transliterator that is an inverse, not necessarily
 881  * exact, of this transliterator, or &lt;code&gt;null&lt;/code&gt; if no such
 882  * transliterator is registered.
 883  * @see #registerInstance
 884  */
 885 Transliterator* Transliterator::createInverse(UErrorCode&amp; status) const {
 886     UParseError parseError;
 887     return Transliterator::createInstance(ID, UTRANS_REVERSE,parseError,status);
 888 }
 889 
 890 Transliterator* U_EXPORT2
 891 Transliterator::createInstance(const UnicodeString&amp; ID,
 892                                 UTransDirection dir,
 893                                 UErrorCode&amp; status)
 894 {
 895     UParseError parseError;
 896     return createInstance(ID, dir, parseError, status);
 897 }
 898 
 899 /**
 900  * Returns a &lt;code&gt;Transliterator&lt;/code&gt; object given its ID.
 901  * The ID must be either a system transliterator ID or a ID registered
 902  * using &lt;code&gt;registerInstance()&lt;/code&gt;.
 903  *
 904  * @param ID a valid ID, as enumerated by &lt;code&gt;getAvailableIDs()&lt;/code&gt;
 905  * @return A &lt;code&gt;Transliterator&lt;/code&gt; object with the given ID
 906  * @see #registerInstance
 907  * @see #getAvailableIDs
 908  * @see #getID
 909  */
 910 Transliterator* U_EXPORT2
 911 Transliterator::createInstance(const UnicodeString&amp; ID,
 912                                 UTransDirection dir,
 913                                 UParseError&amp; parseError,
 914                                 UErrorCode&amp; status)
 915 {
 916     if (U_FAILURE(status)) {
 917         return 0;
 918     }
 919 
 920     UnicodeString canonID;
 921     UVector list(status);
 922     if (U_FAILURE(status)) {
 923         return NULL;
 924     }
 925 
 926     UnicodeSet* globalFilter;
 927     // TODO add code for parseError...currently unused, but
 928     // later may be used by parsing code...
 929     if (!TransliteratorIDParser::parseCompoundID(ID, dir, canonID, list, globalFilter)) {
 930         status = U_INVALID_ID;
 931         return NULL;
 932     }
 933 
 934     TransliteratorIDParser::instantiateList(list, status);
 935     if (U_FAILURE(status)) {
 936         return NULL;
 937     }
 938 
 939     U_ASSERT(list.size() &gt; 0);
 940     Transliterator* t = NULL;
 941 
 942     if (list.size() &gt; 1 || canonID.indexOf(ID_DELIM) &gt;= 0) {
 943         // [NOTE: If it&#39;s a compoundID, we instantiate a CompoundTransliterator even if it only
 944         // has one child transliterator.  This is so that toRules() will return the right thing
 945         // (without any inactive ID), but our main ID still comes out correct.  That is, if we
 946         // instantiate &quot;(Lower);Latin-Greek;&quot;, we want the rules to come out as &quot;::Latin-Greek;&quot;
 947         // even though the ID is &quot;(Lower);Latin-Greek;&quot;.
 948         t = new CompoundTransliterator(list, parseError, status);
 949     }
 950     else {
 951         t = (Transliterator*)list.elementAt(0);
 952     }
 953     // Check null pointer
 954     if (t != NULL) {
 955         t-&gt;setID(canonID);
 956         if (globalFilter != NULL) {
 957             t-&gt;adoptFilter(globalFilter);
 958         }
 959     }
 960     else if (U_SUCCESS(status)) {
 961         status = U_MEMORY_ALLOCATION_ERROR;
 962     }
 963     return t;
 964 }
 965 
 966 /**
 967  * Create a transliterator from a basic ID.  This is an ID
 968  * containing only the forward direction source, target, and
 969  * variant.
 970  * @param id a basic ID of the form S-T or S-T/V.
 971  * @return a newly created Transliterator or null if the ID is
 972  * invalid.
 973  */
 974 Transliterator* Transliterator::createBasicInstance(const UnicodeString&amp; id,
 975                                                     const UnicodeString* canon) {
 976     UParseError pe;
 977     UErrorCode ec = U_ZERO_ERROR;
 978     TransliteratorAlias* alias = 0;
 979     Transliterator* t = 0;
 980 
<a name="2" id="anc2"></a><span class="line-modified"> 981     umtx_lock(&amp;registryMutex);</span>
 982     if (HAVE_REGISTRY(ec)) {
 983         t = registry-&gt;get(id, alias, ec);
 984     }
<a name="3" id="anc3"></a><span class="line-modified"> 985     umtx_unlock(&amp;registryMutex);</span>
 986 
 987     if (U_FAILURE(ec)) {
 988         delete t;
 989         delete alias;
 990         return 0;
 991     }
 992 
 993     // We may have not gotten a transliterator:  Because we can&#39;t
 994     // instantiate a transliterator from inside TransliteratorRegistry::
 995     // get() (that would deadlock), we sometimes pass back an alias.  This
 996     // contains the data we need to finish the instantiation outside the
 997     // registry mutex.  The alias may, in turn, generate another alias, so
 998     // we handle aliases in a loop.  The max times through the loop is two.
 999     // [alan]
1000     while (alias != 0) {
1001         U_ASSERT(t==0);
1002         // Rule-based aliases are handled with TransliteratorAlias::
1003         // parse(), followed by TransliteratorRegistry::reget().
1004         // Other aliases are handled with TransliteratorAlias::create().
1005         if (alias-&gt;isRuleBased()) {
1006             // Step 1. parse
1007             TransliteratorParser parser(ec);
1008             alias-&gt;parse(parser, pe, ec);
1009             delete alias;
1010             alias = 0;
1011 
1012             // Step 2. reget
<a name="4" id="anc4"></a><span class="line-modified">1013             umtx_lock(&amp;registryMutex);</span>
1014             if (HAVE_REGISTRY(ec)) {
1015                 t = registry-&gt;reget(id, parser, alias, ec);
1016             }
<a name="5" id="anc5"></a><span class="line-modified">1017             umtx_unlock(&amp;registryMutex);</span>
1018 
1019             // Step 3. Loop back around!
1020         } else {
1021             t = alias-&gt;create(pe, ec);
1022             delete alias;
1023             alias = 0;
1024             break;
1025         }
1026         if (U_FAILURE(ec)) {
1027             delete t;
1028             delete alias;
1029             t = NULL;
1030             break;
1031         }
1032     }
1033 
1034     if (t != NULL &amp;&amp; canon != NULL) {
1035         t-&gt;setID(*canon);
1036     }
1037 
1038     return t;
1039 }
1040 
1041 /**
1042  * Returns a &lt;code&gt;Transliterator&lt;/code&gt; object constructed from
1043  * the given rule string.  This will be a RuleBasedTransliterator,
1044  * if the rule string contains only rules, or a
1045  * CompoundTransliterator, if it contains ID blocks, or a
1046  * NullTransliterator, if it contains ID blocks which parse as
1047  * empty for the given direction.
1048  */
1049 Transliterator* U_EXPORT2
1050 Transliterator::createFromRules(const UnicodeString&amp; ID,
1051                                 const UnicodeString&amp; rules,
1052                                 UTransDirection dir,
1053                                 UParseError&amp; parseError,
1054                                 UErrorCode&amp; status)
1055 {
1056     Transliterator* t = NULL;
1057 
1058     TransliteratorParser parser(status);
1059     parser.parse(rules, dir, parseError, status);
1060 
1061     if (U_FAILURE(status)) {
1062         return 0;
1063     }
1064 
1065     // NOTE: The logic here matches that in TransliteratorRegistry.
1066     if (parser.idBlockVector.size() == 0 &amp;&amp; parser.dataVector.size() == 0) {
1067         t = new NullTransliterator();
1068     }
1069     else if (parser.idBlockVector.size() == 0 &amp;&amp; parser.dataVector.size() == 1) {
1070         t = new RuleBasedTransliterator(ID, (TransliterationRuleData*)parser.dataVector.orphanElementAt(0), TRUE);
1071     }
1072     else if (parser.idBlockVector.size() == 1 &amp;&amp; parser.dataVector.size() == 0) {
1073         // idBlock, no data -- this is an alias.  The ID has
1074         // been munged from reverse into forward mode, if
1075         // necessary, so instantiate the ID in the forward
1076         // direction.
1077         if (parser.compoundFilter != NULL) {
1078             UnicodeString filterPattern;
1079             parser.compoundFilter-&gt;toPattern(filterPattern, FALSE);
1080             t = createInstance(filterPattern + UnicodeString(ID_DELIM)
1081                     + *((UnicodeString*)parser.idBlockVector.elementAt(0)), UTRANS_FORWARD, parseError, status);
1082         }
1083         else
1084             t = createInstance(*((UnicodeString*)parser.idBlockVector.elementAt(0)), UTRANS_FORWARD, parseError, status);
1085 
1086 
1087         if (t != NULL) {
1088             t-&gt;setID(ID);
1089         }
1090     }
1091     else {
1092         UVector transliterators(status);
1093         int32_t passNumber = 1;
1094 
1095         int32_t limit = parser.idBlockVector.size();
1096         if (parser.dataVector.size() &gt; limit)
1097             limit = parser.dataVector.size();
1098 
1099         for (int32_t i = 0; i &lt; limit; i++) {
1100             if (i &lt; parser.idBlockVector.size()) {
1101                 UnicodeString* idBlock = (UnicodeString*)parser.idBlockVector.elementAt(i);
1102                 if (!idBlock-&gt;isEmpty()) {
1103                     Transliterator* temp = createInstance(*idBlock, UTRANS_FORWARD, parseError, status);
1104                     if (temp != NULL &amp;&amp; typeid(*temp) != typeid(NullTransliterator))
1105                         transliterators.addElement(temp, status);
1106                     else
1107                         delete temp;
1108                 }
1109             }
1110             if (!parser.dataVector.isEmpty()) {
1111                 TransliterationRuleData* data = (TransliterationRuleData*)parser.dataVector.orphanElementAt(0);
1112                 // TODO: Should passNumber be turned into a decimal-string representation (1 -&gt; &quot;1&quot;)?
1113                 RuleBasedTransliterator* temprbt = new RuleBasedTransliterator(UnicodeString(CompoundTransliterator::PASS_STRING) + UnicodeString(passNumber++),
1114                         data, TRUE);
1115                 // Check if NULL before adding it to transliterators to avoid future usage of NULL pointer.
1116                 if (temprbt == NULL) {
1117                     status = U_MEMORY_ALLOCATION_ERROR;
1118                     return t;
1119                 }
1120                 transliterators.addElement(temprbt, status);
1121             }
1122         }
1123 
1124         t = new CompoundTransliterator(transliterators, passNumber - 1, parseError, status);
1125         // Null pointer check
1126         if (t != NULL) {
1127             t-&gt;setID(ID);
1128             t-&gt;adoptFilter(parser.orphanCompoundFilter());
1129         }
1130     }
1131     if (U_SUCCESS(status) &amp;&amp; t == NULL) {
1132         status = U_MEMORY_ALLOCATION_ERROR;
1133     }
1134     return t;
1135 }
1136 
1137 UnicodeString&amp; Transliterator::toRules(UnicodeString&amp; rulesSource,
1138                                        UBool escapeUnprintable) const {
1139     // The base class implementation of toRules munges the ID into
1140     // the correct format.  That is: foo =&gt; ::foo
1141     if (escapeUnprintable) {
1142         rulesSource.truncate(0);
1143         UnicodeString id = getID();
1144         for (int32_t i=0; i&lt;id.length();) {
1145             UChar32 c = id.char32At(i);
1146             if (!ICU_Utility::escapeUnprintable(rulesSource, c)) {
1147                 rulesSource.append(c);
1148             }
1149             i += U16_LENGTH(c);
1150         }
1151     } else {
1152         rulesSource = getID();
1153     }
1154     // KEEP in sync with rbt_pars
1155     rulesSource.insert(0, UNICODE_STRING_SIMPLE(&quot;::&quot;));
1156     rulesSource.append(ID_DELIM);
1157     return rulesSource;
1158 }
1159 
1160 int32_t Transliterator::countElements() const {
1161     const CompoundTransliterator* ct = dynamic_cast&lt;const CompoundTransliterator*&gt;(this);
1162     return ct != NULL ? ct-&gt;getCount() : 0;
1163 }
1164 
1165 const Transliterator&amp; Transliterator::getElement(int32_t index, UErrorCode&amp; ec) const {
1166     if (U_FAILURE(ec)) {
1167         return *this;
1168     }
1169     const CompoundTransliterator* cpd = dynamic_cast&lt;const CompoundTransliterator*&gt;(this);
1170     int32_t n = (cpd == NULL) ? 1 : cpd-&gt;getCount();
1171     if (index &lt; 0 || index &gt;= n) {
1172         ec = U_INDEX_OUTOFBOUNDS_ERROR;
1173         return *this;
1174     } else {
1175         return (n == 1) ? *this : cpd-&gt;getTransliterator(index);
1176     }
1177 }
1178 
1179 UnicodeSet&amp; Transliterator::getSourceSet(UnicodeSet&amp; result) const {
1180     handleGetSourceSet(result);
1181     if (filter != NULL) {
1182         UnicodeSet* filterSet = dynamic_cast&lt;UnicodeSet*&gt;(filter);
1183         UBool deleteFilterSet = FALSE;
1184         // Most, but not all filters will be UnicodeSets.  Optimize for
1185         // the high-runner case.
1186         if (filterSet == NULL) {
1187             filterSet = new UnicodeSet();
1188             // Check null pointer
1189             if (filterSet == NULL) {
1190                 return result;
1191             }
1192             deleteFilterSet = TRUE;
1193             filter-&gt;addMatchSetTo(*filterSet);
1194         }
1195         result.retainAll(*filterSet);
1196         if (deleteFilterSet) {
1197             delete filterSet;
1198         }
1199     }
1200     return result;
1201 }
1202 
1203 void Transliterator::handleGetSourceSet(UnicodeSet&amp; result) const {
1204     result.clear();
1205 }
1206 
1207 UnicodeSet&amp; Transliterator::getTargetSet(UnicodeSet&amp; result) const {
1208     return result.clear();
1209 }
1210 
1211 // For public consumption
1212 void U_EXPORT2 Transliterator::registerFactory(const UnicodeString&amp; id,
1213                                      Transliterator::Factory factory,
1214                                      Transliterator::Token context) {
<a name="6" id="anc6"></a><span class="line-modified">1215     Mutex lock(&amp;registryMutex);</span>
1216     UErrorCode ec = U_ZERO_ERROR;
1217     if (HAVE_REGISTRY(ec)) {
1218         _registerFactory(id, factory, context);
1219     }
1220 }
1221 
1222 // To be called only by Transliterator subclasses that are called
1223 // to register themselves by initializeRegistry().
1224 void Transliterator::_registerFactory(const UnicodeString&amp; id,
1225                                       Transliterator::Factory factory,
1226                                       Transliterator::Token context) {
1227     UErrorCode ec = U_ZERO_ERROR;
1228     registry-&gt;put(id, factory, context, TRUE, ec);
1229 }
1230 
1231 // To be called only by Transliterator subclasses that are called
1232 // to register themselves by initializeRegistry().
1233 void Transliterator::_registerSpecialInverse(const UnicodeString&amp; target,
1234                                              const UnicodeString&amp; inverseTarget,
1235                                              UBool bidirectional) {
1236     UErrorCode status = U_ZERO_ERROR;
1237     TransliteratorIDParser::registerSpecialInverse(target, inverseTarget, bidirectional, status);
1238 }
1239 
1240 /**
1241  * Registers a instance &lt;tt&gt;obj&lt;/tt&gt; of a subclass of
1242  * &lt;code&gt;Transliterator&lt;/code&gt; with the system.  This object must
1243  * implement the &lt;tt&gt;clone()&lt;/tt&gt; method.  When
1244  * &lt;tt&gt;getInstance()&lt;/tt&gt; is called with an ID string that is
1245  * equal to &lt;tt&gt;obj.getID()&lt;/tt&gt;, then &lt;tt&gt;obj.clone()&lt;/tt&gt; is
1246  * returned.
1247  *
1248  * @param obj an instance of subclass of
1249  * &lt;code&gt;Transliterator&lt;/code&gt; that defines &lt;tt&gt;clone()&lt;/tt&gt;
1250  * @see #getInstance
1251  * @see #unregister
1252  */
1253 void U_EXPORT2 Transliterator::registerInstance(Transliterator* adoptedPrototype) {
<a name="7" id="anc7"></a><span class="line-modified">1254     Mutex lock(&amp;registryMutex);</span>
1255     UErrorCode ec = U_ZERO_ERROR;
1256     if (HAVE_REGISTRY(ec)) {
1257         _registerInstance(adoptedPrototype);
1258     }
1259 }
1260 
1261 void Transliterator::_registerInstance(Transliterator* adoptedPrototype) {
1262     UErrorCode ec = U_ZERO_ERROR;
1263     registry-&gt;put(adoptedPrototype, TRUE, ec);
1264 }
1265 
1266 void U_EXPORT2 Transliterator::registerAlias(const UnicodeString&amp; aliasID,
1267                                              const UnicodeString&amp; realID) {
<a name="8" id="anc8"></a><span class="line-modified">1268     Mutex lock(&amp;registryMutex);</span>
1269     UErrorCode ec = U_ZERO_ERROR;
1270     if (HAVE_REGISTRY(ec)) {
1271         _registerAlias(aliasID, realID);
1272     }
1273 }
1274 
1275 void Transliterator::_registerAlias(const UnicodeString&amp; aliasID,
1276                                     const UnicodeString&amp; realID) {
1277     UErrorCode ec = U_ZERO_ERROR;
1278     registry-&gt;put(aliasID, realID, FALSE, TRUE, ec);
1279 }
1280 
1281 /**
1282  * Unregisters a transliterator or class.  This may be either
1283  * a system transliterator or a user transliterator or class.
1284  *
1285  * @param ID the ID of the transliterator or class
1286  * @see #registerInstance
1287 
1288  */
1289 void U_EXPORT2 Transliterator::unregister(const UnicodeString&amp; ID) {
<a name="9" id="anc9"></a><span class="line-modified">1290     Mutex lock(&amp;registryMutex);</span>
1291     UErrorCode ec = U_ZERO_ERROR;
1292     if (HAVE_REGISTRY(ec)) {
1293         registry-&gt;remove(ID);
1294     }
1295 }
1296 
1297 /**
1298  * == OBSOLETE - remove in ICU 3.4 ==
1299  * Return the number of IDs currently registered with the system.
1300  * To retrieve the actual IDs, call getAvailableID(i) with
1301  * i from 0 to countAvailableIDs() - 1.
1302  */
1303 int32_t U_EXPORT2 Transliterator::countAvailableIDs(void) {
1304     int32_t retVal = 0;
<a name="10" id="anc10"></a><span class="line-modified">1305     Mutex lock(&amp;registryMutex);</span>
1306     UErrorCode ec = U_ZERO_ERROR;
1307     if (HAVE_REGISTRY(ec)) {
1308         retVal = registry-&gt;countAvailableIDs();
1309     }
1310     return retVal;
1311 }
1312 
1313 /**
1314  * == OBSOLETE - remove in ICU 3.4 ==
1315  * Return the index-th available ID.  index must be between 0
1316  * and countAvailableIDs() - 1, inclusive.  If index is out of
1317  * range, the result of getAvailableID(0) is returned.
1318  */
1319 const UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableID(int32_t index) {
1320     const UnicodeString* result = NULL;
<a name="11" id="anc11"></a><span class="line-modified">1321     umtx_lock(&amp;registryMutex);</span>
1322     UErrorCode ec = U_ZERO_ERROR;
1323     if (HAVE_REGISTRY(ec)) {
1324         result = &amp;registry-&gt;getAvailableID(index);
1325     }
<a name="12" id="anc12"></a><span class="line-modified">1326     umtx_unlock(&amp;registryMutex);</span>
1327     U_ASSERT(result != NULL); // fail if no registry
1328     return *result;
1329 }
1330 
1331 StringEnumeration* U_EXPORT2 Transliterator::getAvailableIDs(UErrorCode&amp; ec) {
1332     if (U_FAILURE(ec)) return NULL;
1333     StringEnumeration* result = NULL;
<a name="13" id="anc13"></a><span class="line-modified">1334     umtx_lock(&amp;registryMutex);</span>
1335     if (HAVE_REGISTRY(ec)) {
1336         result = registry-&gt;getAvailableIDs();
1337     }
<a name="14" id="anc14"></a><span class="line-modified">1338     umtx_unlock(&amp;registryMutex);</span>
1339     if (result == NULL) {
1340         ec = U_INTERNAL_TRANSLITERATOR_ERROR;
1341     }
1342     return result;
1343 }
1344 
1345 int32_t U_EXPORT2 Transliterator::countAvailableSources(void) {
<a name="15" id="anc15"></a><span class="line-modified">1346     Mutex lock(&amp;registryMutex);</span>
1347     UErrorCode ec = U_ZERO_ERROR;
1348     return HAVE_REGISTRY(ec) ? _countAvailableSources() : 0;
1349 }
1350 
1351 UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableSource(int32_t index,
1352                                                   UnicodeString&amp; result) {
<a name="16" id="anc16"></a><span class="line-modified">1353     Mutex lock(&amp;registryMutex);</span>
1354     UErrorCode ec = U_ZERO_ERROR;
1355     if (HAVE_REGISTRY(ec)) {
1356         _getAvailableSource(index, result);
1357     }
1358     return result;
1359 }
1360 
1361 int32_t U_EXPORT2 Transliterator::countAvailableTargets(const UnicodeString&amp; source) {
<a name="17" id="anc17"></a><span class="line-modified">1362     Mutex lock(&amp;registryMutex);</span>
1363     UErrorCode ec = U_ZERO_ERROR;
1364     return HAVE_REGISTRY(ec) ? _countAvailableTargets(source) : 0;
1365 }
1366 
1367 UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableTarget(int32_t index,
1368                                                   const UnicodeString&amp; source,
1369                                                   UnicodeString&amp; result) {
<a name="18" id="anc18"></a><span class="line-modified">1370     Mutex lock(&amp;registryMutex);</span>
1371     UErrorCode ec = U_ZERO_ERROR;
1372     if (HAVE_REGISTRY(ec)) {
1373         _getAvailableTarget(index, source, result);
1374     }
1375     return result;
1376 }
1377 
1378 int32_t U_EXPORT2 Transliterator::countAvailableVariants(const UnicodeString&amp; source,
1379                                                const UnicodeString&amp; target) {
<a name="19" id="anc19"></a><span class="line-modified">1380     Mutex lock(&amp;registryMutex);</span>
1381     UErrorCode ec = U_ZERO_ERROR;
1382     return HAVE_REGISTRY(ec) ? _countAvailableVariants(source, target) : 0;
1383 }
1384 
1385 UnicodeString&amp; U_EXPORT2 Transliterator::getAvailableVariant(int32_t index,
1386                                                    const UnicodeString&amp; source,
1387                                                    const UnicodeString&amp; target,
1388                                                    UnicodeString&amp; result) {
<a name="20" id="anc20"></a><span class="line-modified">1389     Mutex lock(&amp;registryMutex);</span>
1390     UErrorCode ec = U_ZERO_ERROR;
1391     if (HAVE_REGISTRY(ec)) {
1392         _getAvailableVariant(index, source, target, result);
1393     }
1394     return result;
1395 }
1396 
1397 int32_t Transliterator::_countAvailableSources(void) {
1398     return registry-&gt;countAvailableSources();
1399 }
1400 
1401 UnicodeString&amp; Transliterator::_getAvailableSource(int32_t index,
1402                                                   UnicodeString&amp; result) {
1403     return registry-&gt;getAvailableSource(index, result);
1404 }
1405 
1406 int32_t Transliterator::_countAvailableTargets(const UnicodeString&amp; source) {
1407     return registry-&gt;countAvailableTargets(source);
1408 }
1409 
1410 UnicodeString&amp; Transliterator::_getAvailableTarget(int32_t index,
1411                                                   const UnicodeString&amp; source,
1412                                                   UnicodeString&amp; result) {
1413     return registry-&gt;getAvailableTarget(index, source, result);
1414 }
1415 
1416 int32_t Transliterator::_countAvailableVariants(const UnicodeString&amp; source,
1417                                                const UnicodeString&amp; target) {
1418     return registry-&gt;countAvailableVariants(source, target);
1419 }
1420 
1421 UnicodeString&amp; Transliterator::_getAvailableVariant(int32_t index,
1422                                                    const UnicodeString&amp; source,
1423                                                    const UnicodeString&amp; target,
1424                                                    UnicodeString&amp; result) {
1425     return registry-&gt;getAvailableVariant(index, source, target, result);
1426 }
1427 
1428 #ifdef U_USE_DEPRECATED_TRANSLITERATOR_API
1429 
1430 /**
1431  * Method for subclasses to use to obtain a character in the given
1432  * string, with filtering.
1433  * @deprecated the new architecture provides filtering at the top
1434  * level.  This method will be removed Dec 31 2001.
1435  */
1436 UChar Transliterator::filteredCharAt(const Replaceable&amp; text, int32_t i) const {
1437     UChar c;
1438     const UnicodeFilter* localFilter = getFilter();
1439     return (localFilter == 0) ? text.charAt(i) :
1440         (localFilter-&gt;contains(c = text.charAt(i)) ? c : (UChar)0xFFFE);
1441 }
1442 
1443 #endif
1444 
1445 /**
1446  * If the registry is initialized, return TRUE.  If not, initialize it
1447  * and return TRUE.  If the registry cannot be initialized, return
1448  * FALSE (rare).
1449  *
1450  * IMPORTANT: Upon entry, registryMutex must be LOCKED.  The entire
1451  * initialization is done with the lock held.  There is NO REASON to
1452  * unlock, since no other thread that is waiting on the registryMutex
1453  * cannot itself proceed until the registry is initialized.
1454  */
1455 UBool Transliterator::initializeRegistry(UErrorCode &amp;status) {
1456     if (registry != 0) {
1457         return TRUE;
1458     }
1459 
1460     registry = new TransliteratorRegistry(status);
1461     if (registry == 0 || U_FAILURE(status)) {
1462         delete registry;
1463         registry = 0;
1464         return FALSE; // can&#39;t create registry, no recovery
1465     }
1466 
1467     /* The following code parses the index table located in
1468      * icu/data/translit/root.txt.  The index is an n x 4 table
1469      * that follows this format:
1470      *  &lt;id&gt;{
1471      *      file{
1472      *          resource{&quot;&lt;resource&gt;&quot;}
1473      *          direction{&quot;&lt;direction&gt;&quot;}
1474      *      }
1475      *  }
1476      *  &lt;id&gt;{
1477      *      internal{
1478      *          resource{&quot;&lt;resource&gt;&quot;}
1479      *          direction{&quot;&lt;direction&quot;}
1480      *       }
1481      *  }
1482      *  &lt;id&gt;{
1483      *      alias{&quot;&lt;getInstanceArg&quot;}
1484      *  }
1485      * &lt;id&gt; is the ID of the system transliterator being defined.  These
1486      * are public IDs enumerated by Transliterator.getAvailableIDs(),
1487      * unless the second field is &quot;internal&quot;.
1488      *
1489      * &lt;resource&gt; is a ResourceReader resource name.  Currently these refer
1490      * to file names under com/ibm/text/resources.  This string is passed
1491      * directly to ResourceReader, together with &lt;encoding&gt;.
1492      *
1493      * &lt;direction&gt; is either &quot;FORWARD&quot; or &quot;REVERSE&quot;.
1494      *
1495      * &lt;getInstanceArg&gt; is a string to be passed directly to
1496      * Transliterator.getInstance().  The returned Transliterator object
1497      * then has its ID changed to &lt;id&gt; and is returned.
1498      *
1499      * The extra blank field on &quot;alias&quot; lines is to make the array square.
1500      */
1501     //static const char translit_index[] = &quot;translit_index&quot;;
1502 
1503     UResourceBundle *bundle, *transIDs, *colBund;
1504     bundle = ures_open(U_ICUDATA_TRANSLIT, NULL/*open default locale*/, &amp;status);
1505     transIDs = ures_getByKey(bundle, RB_RULE_BASED_IDS, 0, &amp;status);
1506     const UnicodeString T_PART = UNICODE_STRING_SIMPLE(&quot;-t-&quot;);
1507 
1508     int32_t row, maxRows;
1509     if (U_SUCCESS(status)) {
1510         maxRows = ures_getSize(transIDs);
1511         for (row = 0; row &lt; maxRows; row++) {
1512             colBund = ures_getByIndex(transIDs, row, 0, &amp;status);
1513             if (U_SUCCESS(status)) {
1514                 UnicodeString id(ures_getKey(colBund), -1, US_INV);
1515                 if(id.indexOf(T_PART) != -1) {
1516                     ures_close(colBund);
1517                     continue;
1518                 }
1519                 UResourceBundle* res = ures_getNextResource(colBund, NULL, &amp;status);
1520                 const char* typeStr = ures_getKey(res);
1521                 UChar type;
1522                 u_charsToUChars(typeStr, &amp;type, 1);
1523 
1524                 if (U_SUCCESS(status)) {
1525                     int32_t len = 0;
1526                     const UChar *resString;
1527                     switch (type) {
1528                     case 0x66: // &#39;f&#39;
1529                     case 0x69: // &#39;i&#39;
1530                         // &#39;file&#39; or &#39;internal&#39;;
1531                         // row[2]=resource, row[3]=direction
1532                         {
1533 
1534                             resString = ures_getStringByKey(res, &quot;resource&quot;, &amp;len, &amp;status);
1535                             UBool visible = (type == 0x0066 /*f*/);
1536                             UTransDirection dir =
1537                                 (ures_getUnicodeStringByKey(res, &quot;direction&quot;, &amp;status).charAt(0) ==
1538                                  0x0046 /*F*/) ?
1539                                 UTRANS_FORWARD : UTRANS_REVERSE;
1540                             registry-&gt;put(id, UnicodeString(TRUE, resString, len), dir, TRUE, visible, status);
1541                         }
1542                         break;
1543                     case 0x61: // &#39;a&#39;
1544                         // &#39;alias&#39;; row[2]=createInstance argument
1545                         resString = ures_getString(res, &amp;len, &amp;status);
1546                         registry-&gt;put(id, UnicodeString(TRUE, resString, len), TRUE, TRUE, status);
1547                         break;
1548                     }
1549                 }
1550                 ures_close(res);
1551             }
1552             ures_close(colBund);
1553         }
1554     }
1555 
1556     ures_close(transIDs);
1557     ures_close(bundle);
1558 
1559     // Manually add prototypes that the system knows about to the
1560     // cache.  This is how new non-rule-based transliterators are
1561     // added to the system.
1562 
1563     // This is to allow for null pointer check
1564     NullTransliterator* tempNullTranslit = new NullTransliterator();
1565     LowercaseTransliterator* tempLowercaseTranslit = new LowercaseTransliterator();
1566     UppercaseTransliterator* tempUppercaseTranslit = new UppercaseTransliterator();
1567     TitlecaseTransliterator* tempTitlecaseTranslit = new TitlecaseTransliterator();
1568     UnicodeNameTransliterator* tempUnicodeTranslit = new UnicodeNameTransliterator();
1569     NameUnicodeTransliterator* tempNameUnicodeTranslit = new NameUnicodeTransliterator();
1570 #if !UCONFIG_NO_BREAK_ITERATION
1571      // TODO: could or should these transliterators be referenced polymorphically once constructed?
1572      BreakTransliterator* tempBreakTranslit         = new BreakTransliterator();
1573 #endif
1574     // Check for null pointers
1575     if (tempNullTranslit == NULL || tempLowercaseTranslit == NULL || tempUppercaseTranslit == NULL ||
1576         tempTitlecaseTranslit == NULL || tempUnicodeTranslit == NULL ||
1577 #if !UCONFIG_NO_BREAK_ITERATION
1578         tempBreakTranslit == NULL ||
1579 #endif
1580         tempNameUnicodeTranslit == NULL )
1581     {
1582         delete tempNullTranslit;
1583         delete tempLowercaseTranslit;
1584         delete tempUppercaseTranslit;
1585         delete tempTitlecaseTranslit;
1586         delete tempUnicodeTranslit;
1587         delete tempNameUnicodeTranslit;
1588 #if !UCONFIG_NO_BREAK_ITERATION
1589         delete tempBreakTranslit;
1590 #endif
1591         // Since there was an error, remove registry
1592         delete registry;
1593         registry = NULL;
1594 
1595         status = U_MEMORY_ALLOCATION_ERROR;
1596         return 0;
1597     }
1598 
1599     registry-&gt;put(tempNullTranslit, TRUE, status);
1600     registry-&gt;put(tempLowercaseTranslit, TRUE, status);
1601     registry-&gt;put(tempUppercaseTranslit, TRUE, status);
1602     registry-&gt;put(tempTitlecaseTranslit, TRUE, status);
1603     registry-&gt;put(tempUnicodeTranslit, TRUE, status);
1604     registry-&gt;put(tempNameUnicodeTranslit, TRUE, status);
1605 #if !UCONFIG_NO_BREAK_ITERATION
1606     registry-&gt;put(tempBreakTranslit, FALSE, status);   // FALSE means invisible.
1607 #endif
1608 
1609     RemoveTransliterator::registerIDs(); // Must be within mutex
1610     EscapeTransliterator::registerIDs();
1611     UnescapeTransliterator::registerIDs();
1612     NormalizationTransliterator::registerIDs();
1613     AnyTransliterator::registerIDs();
1614 
1615     _registerSpecialInverse(UNICODE_STRING_SIMPLE(&quot;Null&quot;),
1616                             UNICODE_STRING_SIMPLE(&quot;Null&quot;), FALSE);
1617     _registerSpecialInverse(UNICODE_STRING_SIMPLE(&quot;Upper&quot;),
1618                             UNICODE_STRING_SIMPLE(&quot;Lower&quot;), TRUE);
1619     _registerSpecialInverse(UNICODE_STRING_SIMPLE(&quot;Title&quot;),
1620                             UNICODE_STRING_SIMPLE(&quot;Lower&quot;), FALSE);
1621 
1622     ucln_i18n_registerCleanup(UCLN_I18N_TRANSLITERATOR, utrans_transliterator_cleanup);
1623 
1624     return TRUE;
1625 }
1626 
1627 U_NAMESPACE_END
1628 
1629 // Defined in transreg.h:
1630 
1631 /**
1632  * Release all static memory held by transliterator.  This will
1633  * necessarily invalidate any rule-based transliterators held by the
1634  * user, because RBTs hold pointers to common data objects.
1635  */
1636 U_CFUNC UBool utrans_transliterator_cleanup(void) {
1637     U_NAMESPACE_USE
1638     TransliteratorIDParser::cleanup();
1639     if (registry) {
1640         delete registry;
1641         registry = NULL;
1642     }
1643     return TRUE;
1644 }
1645 
1646 #endif /* #if !UCONFIG_NO_TRANSLITERATION */
1647 
1648 //eof
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>