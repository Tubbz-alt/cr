<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/numparse_scientific.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="numparse_parsednumber.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="numparse_symbols.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/numparse_scientific.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38     const UnicodeString&amp; minusSign = dfs.getConstSymbol(DecimalFormatSymbols::kMinusSignSymbol);
 39     if (minusSignSet().contains(minusSign)) {
 40         fCustomMinusSign.setToBogus();
 41     } else {
 42         fCustomMinusSign = minusSign;
 43     }
 44 
 45     const UnicodeString&amp; plusSign = dfs.getConstSymbol(DecimalFormatSymbols::kPlusSignSymbol);
 46     if (plusSignSet().contains(plusSign)) {
 47         fCustomPlusSign.setToBogus();
 48     } else {
 49         fCustomPlusSign = plusSign;
 50     }
 51 }
 52 
 53 bool ScientificMatcher::match(StringSegment&amp; segment, ParsedNumber&amp; result, UErrorCode&amp; status) const {
 54     // Only accept scientific notation after the mantissa.
 55     if (!result.seenNumber()) {
 56         return false;
 57     }





 58 
 59     // First match the scientific separator, and then match another number after it.
 60     // NOTE: This is guarded by the smoke test; no need to check fExponentSeparatorString length again.
 61     int overlap1 = segment.getCommonPrefixLength(fExponentSeparatorString);
 62     if (overlap1 == fExponentSeparatorString.length()) {
 63         // Full exponent separator match.
 64 
 65         // First attempt to get a code point, returning true if we can&#39;t get one.
 66         if (segment.length() == overlap1) {
 67             return true;
 68         }
 69         segment.adjustOffset(overlap1);
 70 
 71         // Allow a sign, and then try to match digits.
 72         int8_t exponentSign = 1;
 73         if (segment.startsWith(minusSignSet())) {
 74             exponentSign = -1;
 75             segment.adjustOffsetByCodePoint();
 76         } else if (segment.startsWith(plusSignSet())) {
 77             segment.adjustOffsetByCodePoint();
</pre>
</td>
<td>
<hr />
<pre>
 38     const UnicodeString&amp; minusSign = dfs.getConstSymbol(DecimalFormatSymbols::kMinusSignSymbol);
 39     if (minusSignSet().contains(minusSign)) {
 40         fCustomMinusSign.setToBogus();
 41     } else {
 42         fCustomMinusSign = minusSign;
 43     }
 44 
 45     const UnicodeString&amp; plusSign = dfs.getConstSymbol(DecimalFormatSymbols::kPlusSignSymbol);
 46     if (plusSignSet().contains(plusSign)) {
 47         fCustomPlusSign.setToBogus();
 48     } else {
 49         fCustomPlusSign = plusSign;
 50     }
 51 }
 52 
 53 bool ScientificMatcher::match(StringSegment&amp; segment, ParsedNumber&amp; result, UErrorCode&amp; status) const {
 54     // Only accept scientific notation after the mantissa.
 55     if (!result.seenNumber()) {
 56         return false;
 57     }
<span class="line-added"> 58 </span>
<span class="line-added"> 59     // Only accept one exponent per string.</span>
<span class="line-added"> 60     if (0 != (result.flags &amp; FLAG_HAS_EXPONENT)) {</span>
<span class="line-added"> 61         return false;</span>
<span class="line-added"> 62     }</span>
 63 
 64     // First match the scientific separator, and then match another number after it.
 65     // NOTE: This is guarded by the smoke test; no need to check fExponentSeparatorString length again.
 66     int overlap1 = segment.getCommonPrefixLength(fExponentSeparatorString);
 67     if (overlap1 == fExponentSeparatorString.length()) {
 68         // Full exponent separator match.
 69 
 70         // First attempt to get a code point, returning true if we can&#39;t get one.
 71         if (segment.length() == overlap1) {
 72             return true;
 73         }
 74         segment.adjustOffset(overlap1);
 75 
 76         // Allow a sign, and then try to match digits.
 77         int8_t exponentSign = 1;
 78         if (segment.startsWith(minusSignSet())) {
 79             exponentSign = -1;
 80             segment.adjustOffsetByCodePoint();
 81         } else if (segment.startsWith(plusSignSet())) {
 82             segment.adjustOffsetByCodePoint();
</pre>
</td>
</tr>
</table>
<center><a href="numparse_parsednumber.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="numparse_symbols.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>