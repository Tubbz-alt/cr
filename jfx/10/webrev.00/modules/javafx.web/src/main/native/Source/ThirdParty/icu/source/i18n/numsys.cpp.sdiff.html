<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/numsys.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="numparse_types.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="numsys_impl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/numsys.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9 *
 10 * File NUMSYS.CPP
 11 *
 12 * Modification History:*
 13 *   Date        Name        Description
 14 *
 15 ********************************************************************************
 16 */
 17 
 18 #include &quot;unicode/utypes.h&quot;
 19 #include &quot;unicode/localpointer.h&quot;
 20 #include &quot;unicode/uchar.h&quot;
 21 #include &quot;unicode/unistr.h&quot;
 22 #include &quot;unicode/ures.h&quot;
 23 #include &quot;unicode/ustring.h&quot;
 24 #include &quot;unicode/uloc.h&quot;
 25 #include &quot;unicode/schriter.h&quot;
 26 #include &quot;unicode/numsys.h&quot;
 27 #include &quot;cstring.h&quot;
 28 #include &quot;uassert.h&quot;


 29 #include &quot;uresimp.h&quot;
 30 #include &quot;numsys_impl.h&quot;
 31 
 32 #if !UCONFIG_NO_FORMATTING
 33 
 34 U_NAMESPACE_BEGIN
 35 
 36 // Useful constants
 37 
 38 #define DEFAULT_DIGITS UNICODE_STRING_SIMPLE(&quot;0123456789&quot;);
 39 static const char gNumberingSystems[] = &quot;numberingSystems&quot;;
 40 static const char gNumberElements[] = &quot;NumberElements&quot;;
 41 static const char gDefault[] = &quot;default&quot;;
 42 static const char gNative[] = &quot;native&quot;;
 43 static const char gTraditional[] = &quot;traditional&quot;;
 44 static const char gFinance[] = &quot;finance&quot;;
 45 static const char gDesc[] = &quot;desc&quot;;
 46 static const char gRadix[] = &quot;radix&quot;;
 47 static const char gAlgorithmic[] = &quot;algorithmic&quot;;
 48 static const char gLatn[] = &quot;latn&quot;;
</pre>
<hr />
<pre>
 62      algorithmic = FALSE;
 63      UnicodeString defaultDigits = DEFAULT_DIGITS;
 64      desc.setTo(defaultDigits);
 65      uprv_strcpy(name,gLatn);
 66 }
 67 
 68     /**
 69      * Copy constructor.
 70      * @draft ICU 4.2
 71      */
 72 
 73 NumberingSystem::NumberingSystem(const NumberingSystem&amp; other)
 74 :  UObject(other) {
 75     *this=other;
 76 }
 77 
 78 NumberingSystem* U_EXPORT2
 79 NumberingSystem::createInstance(int32_t radix_in, UBool isAlgorithmic_in, const UnicodeString &amp; desc_in, UErrorCode &amp;status) {
 80 
 81     if (U_FAILURE(status)) {
<span class="line-modified"> 82         return NULL;</span>
 83     }
 84 
 85     if ( radix_in &lt; 2 ) {
 86         status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified"> 87         return NULL;</span>
 88     }
 89 
 90     if ( !isAlgorithmic_in ) {
 91        if ( desc_in.countChar32() != radix_in ) {
 92            status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified"> 93            return NULL;</span>
 94        }
 95     }
 96 
<span class="line-modified"> 97     NumberingSystem *ns = new NumberingSystem();</span>



 98 
 99     ns-&gt;setRadix(radix_in);
100     ns-&gt;setDesc(desc_in);
101     ns-&gt;setAlgorithmic(isAlgorithmic_in);
<span class="line-modified">102     ns-&gt;setName(NULL);</span>
<span class="line-removed">103     return ns;</span>
104 

105 }
106 
<span class="line-removed">107 </span>
108 NumberingSystem* U_EXPORT2
109 NumberingSystem::createInstance(const Locale &amp; inLocale, UErrorCode&amp; status) {
110 
111     if (U_FAILURE(status)) {
<span class="line-modified">112         return NULL;</span>
113     }
114 
115     UBool nsResolved = TRUE;
116     UBool usingFallback = FALSE;
117     char buffer[ULOC_KEYWORDS_CAPACITY];
<span class="line-modified">118     int32_t count = inLocale.getKeywordValue(&quot;numbers&quot;,buffer, sizeof(buffer),status);</span>
119     if (U_FAILURE(status) || status == U_STRING_NOT_TERMINATED_WARNING) {
120         // the &quot;numbers&quot; keyword exceeds ULOC_KEYWORDS_CAPACITY; ignore and use default.
121         count = 0;
122         status = U_ZERO_ERROR;
123     }
124     if ( count &gt; 0 ) { // @numbers keyword was specified in the locale
125         U_ASSERT(count &lt; ULOC_KEYWORDS_CAPACITY);
126         buffer[count] = &#39;\0&#39;; // Make sure it is null terminated.
127         if ( !uprv_strcmp(buffer,gDefault) || !uprv_strcmp(buffer,gNative) ||
128              !uprv_strcmp(buffer,gTraditional) || !uprv_strcmp(buffer,gFinance)) {
129             nsResolved = FALSE;
130         }
131     } else {
<span class="line-modified">132         uprv_strcpy(buffer,gDefault);</span>
133         nsResolved = FALSE;
134     }
135 
136     if (!nsResolved) { // Resolve the numbering system ( default, native, traditional or finance ) into a &quot;real&quot; numbering system
137         UErrorCode localStatus = U_ZERO_ERROR;
<span class="line-modified">138         UResourceBundle *resource = ures_open(NULL, inLocale.getName(), &amp;localStatus);</span>
<span class="line-modified">139         UResourceBundle *numberElementsRes = ures_getByKey(resource,gNumberElements,NULL,&amp;localStatus);</span>





140         while (!nsResolved) {
141             localStatus = U_ZERO_ERROR;
142             count = 0;
<span class="line-modified">143             const UChar *nsName = ures_getStringByKeyWithFallback(numberElementsRes, buffer, &amp;count, &amp;localStatus);</span>





144             if ( count &gt; 0 &amp;&amp; count &lt; ULOC_KEYWORDS_CAPACITY ) { // numbering system found
<span class="line-modified">145                 u_UCharsToChars(nsName,buffer,count);</span>
146                 buffer[count] = &#39;\0&#39;; // Make sure it is null terminated.
147                 nsResolved = TRUE;
148             }
149 
150             if (!nsResolved) { // Fallback behavior per TR35 - traditional falls back to native, finance and native fall back to default
151                 if (!uprv_strcmp(buffer,gNative) || !uprv_strcmp(buffer,gFinance)) {
152                     uprv_strcpy(buffer,gDefault);
153                 } else if (!uprv_strcmp(buffer,gTraditional)) {
154                     uprv_strcpy(buffer,gNative);
155                 } else { // If we get here we couldn&#39;t find even the default numbering system
156                     usingFallback = TRUE;
157                     nsResolved = TRUE;
158                 }
159             }
160         }
<span class="line-removed">161         ures_close(numberElementsRes);</span>
<span class="line-removed">162         ures_close(resource);</span>
163     }
164 
165     if (usingFallback) {
166         status = U_USING_FALLBACK_WARNING;
167         NumberingSystem *ns = new NumberingSystem();



168         return ns;
169     } else {
<span class="line-modified">170         return NumberingSystem::createInstanceByName(buffer,status);</span>
171     }
172  }
173 
174 NumberingSystem* U_EXPORT2
175 NumberingSystem::createInstance(UErrorCode&amp; status) {
176     return NumberingSystem::createInstance(Locale::getDefault(), status);
177 }
178 
179 NumberingSystem* U_EXPORT2
180 NumberingSystem::createInstanceByName(const char *name, UErrorCode&amp; status) {
<span class="line-removed">181     UResourceBundle *numberingSystemsInfo = NULL;</span>
<span class="line-removed">182     UResourceBundle *nsTop, *nsCurrent;</span>
183     int32_t radix = 10;
184     int32_t algorithmic = 0;
185 
<span class="line-modified">186     numberingSystemsInfo = ures_openDirect(NULL,gNumberingSystems, &amp;status);</span>
<span class="line-modified">187     nsCurrent = ures_getByKey(numberingSystemsInfo,gNumberingSystems,NULL,&amp;status);</span>
<span class="line-modified">188     nsTop = ures_getByKey(nsCurrent,name,NULL,&amp;status);</span>
<span class="line-removed">189     UnicodeString nsd = ures_getUnicodeStringByKey(nsTop,gDesc,&amp;status);</span>
190 
<span class="line-modified">191     ures_getByKey(nsTop,gRadix,nsCurrent,&amp;status);</span>
<span class="line-removed">192     radix = ures_getInt(nsCurrent,&amp;status);</span>
193 
<span class="line-modified">194     ures_getByKey(nsTop,gAlgorithmic,nsCurrent,&amp;status);</span>
<span class="line-modified">195     algorithmic = ures_getInt(nsCurrent,&amp;status);</span>
196 
<span class="line-modified">197     UBool isAlgorithmic = ( algorithmic == 1 );</span>

198 
<span class="line-modified">199     ures_close(nsCurrent);</span>
<span class="line-removed">200     ures_close(nsTop);</span>
<span class="line-removed">201     ures_close(numberingSystemsInfo);</span>
202 
203     if (U_FAILURE(status)) {
<span class="line-modified">204         status = U_UNSUPPORTED_ERROR;</span>
<span class="line-modified">205         return NULL;</span>



206     }
207 
<span class="line-modified">208     NumberingSystem* ns = NumberingSystem::createInstance(radix,isAlgorithmic,nsd,status);</span>



209     ns-&gt;setName(name);
<span class="line-modified">210     return ns;</span>
211 }
212 
213     /**
214      * Destructor.
215      * @draft ICU 4.2
216      */
217 NumberingSystem::~NumberingSystem() {
218 }
219 
220 int32_t NumberingSystem::getRadix() const {
221     return radix;
222 }
223 
224 UnicodeString NumberingSystem::getDescription() const {
225     return desc;
226 }
227 
228 const char * NumberingSystem::getName() const {
229     return name;
230 }
231 
232 void NumberingSystem::setRadix(int32_t r) {
233     radix = r;
234 }
235 
236 void NumberingSystem::setAlgorithmic(UBool c) {
237     algorithmic = c;
238 }
239 
240 void NumberingSystem::setDesc(const UnicodeString &amp;d) {
241     desc.setTo(d);
242 }
243 void NumberingSystem::setName(const char *n) {
<span class="line-modified">244     if ( n == NULL ) {</span>
245         name[0] = (char) 0;
246     } else {
<span class="line-modified">247         uprv_strncpy(name,n,NUMSYS_NAME_CAPACITY);</span>
<span class="line-modified">248         name[NUMSYS_NAME_CAPACITY] = (char)0; // Make sure it is null terminated.</span>
249     }
250 }
251 UBool NumberingSystem::isAlgorithmic() const {
252     return ( algorithmic );
253 }
254 
<span class="line-modified">255 StringEnumeration* NumberingSystem::getAvailableNames(UErrorCode &amp;status) {</span>
<span class="line-modified">256     // TODO(ticket #11908): Init-once static cache, with u_cleanup() callback.</span>
<span class="line-modified">257     static StringEnumeration* availableNames = NULL;</span>








258 






259     if (U_FAILURE(status)) {
<span class="line-modified">260         return NULL;</span>
261     }
262 
<span class="line-modified">263     if ( availableNames == NULL ) {</span>
<span class="line-modified">264         // TODO: Simple array of UnicodeString objects, based on length of table resource?</span>
<span class="line-modified">265         LocalPointer&lt;UVector&gt; numsysNames(new UVector(uprv_deleteUObject, NULL, status), status);</span>
<span class="line-modified">266         if (U_FAILURE(status)) {</span>
<span class="line-modified">267             return NULL;</span>
<span class="line-modified">268         }</span>
<span class="line-modified">269 </span>
<span class="line-modified">270         UErrorCode rbstatus = U_ZERO_ERROR;</span>
<span class="line-modified">271         UResourceBundle *numberingSystemsInfo = ures_openDirect(NULL, &quot;numberingSystems&quot;, &amp;rbstatus);</span>
<span class="line-removed">272         numberingSystemsInfo = ures_getByKey(numberingSystemsInfo,&quot;numberingSystems&quot;,numberingSystemsInfo,&amp;rbstatus);</span>
<span class="line-removed">273         if(U_FAILURE(rbstatus)) {</span>
274             status = U_MISSING_RESOURCE_ERROR;
<span class="line-removed">275             ures_close(numberingSystemsInfo);</span>
<span class="line-removed">276             return NULL;</span>
<span class="line-removed">277         }</span>
<span class="line-removed">278 </span>
<span class="line-removed">279         while ( ures_hasNext(numberingSystemsInfo) ) {</span>
<span class="line-removed">280             UResourceBundle *nsCurrent = ures_getNextResource(numberingSystemsInfo,NULL,&amp;rbstatus);</span>
<span class="line-removed">281             const char *nsName = ures_getKey(nsCurrent);</span>
<span class="line-removed">282             numsysNames-&gt;addElement(new UnicodeString(nsName, -1, US_INV),status);</span>
<span class="line-removed">283             ures_close(nsCurrent);</span>
284         }
<span class="line-removed">285 </span>
286         ures_close(numberingSystemsInfo);
<span class="line-modified">287         if (U_FAILURE(status)) {</span>
<span class="line-modified">288             return NULL;</span>






289         }
<span class="line-modified">290         availableNames = new NumsysNameEnumeration(numsysNames.getAlias(), status);</span>
<span class="line-modified">291         if (availableNames == NULL) {</span>
<span class="line-modified">292             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">293             return NULL;</span>



294         }
<span class="line-removed">295         numsysNames.orphan();  // The names got adopted.</span>
296     }
297 
<span class="line-modified">298     return availableNames;</span>




299 }
300 
<span class="line-modified">301 NumsysNameEnumeration::NumsysNameEnumeration(UVector *numsysNames, UErrorCode&amp; /*status*/) {</span>
<span class="line-modified">302     pos=0;</span>
<span class="line-modified">303     fNumsysNames = numsysNames;</span>







304 }
305 
306 const UnicodeString*
307 NumsysNameEnumeration::snext(UErrorCode&amp; status) {
<span class="line-modified">308     if (U_SUCCESS(status) &amp;&amp; pos &lt; fNumsysNames-&gt;size()) {</span>
<span class="line-modified">309         return (const UnicodeString*)fNumsysNames-&gt;elementAt(pos++);</span>
310     }
<span class="line-modified">311     return NULL;</span>
312 }
313 
314 void
315 NumsysNameEnumeration::reset(UErrorCode&amp; /*status*/) {
316     pos=0;
317 }
318 
319 int32_t
320 NumsysNameEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">321     return (fNumsysNames==NULL) ? 0 : fNumsysNames-&gt;size();</span>
322 }
323 
324 NumsysNameEnumeration::~NumsysNameEnumeration() {
<span class="line-removed">325     delete fNumsysNames;</span>
326 }
327 U_NAMESPACE_END
328 
329 #endif /* #if !UCONFIG_NO_FORMATTING */
330 
331 //eof
</pre>
</td>
<td>
<hr />
<pre>
  9 *
 10 * File NUMSYS.CPP
 11 *
 12 * Modification History:*
 13 *   Date        Name        Description
 14 *
 15 ********************************************************************************
 16 */
 17 
 18 #include &quot;unicode/utypes.h&quot;
 19 #include &quot;unicode/localpointer.h&quot;
 20 #include &quot;unicode/uchar.h&quot;
 21 #include &quot;unicode/unistr.h&quot;
 22 #include &quot;unicode/ures.h&quot;
 23 #include &quot;unicode/ustring.h&quot;
 24 #include &quot;unicode/uloc.h&quot;
 25 #include &quot;unicode/schriter.h&quot;
 26 #include &quot;unicode/numsys.h&quot;
 27 #include &quot;cstring.h&quot;
 28 #include &quot;uassert.h&quot;
<span class="line-added"> 29 #include &quot;ucln_in.h&quot;</span>
<span class="line-added"> 30 #include &quot;umutex.h&quot;</span>
 31 #include &quot;uresimp.h&quot;
 32 #include &quot;numsys_impl.h&quot;
 33 
 34 #if !UCONFIG_NO_FORMATTING
 35 
 36 U_NAMESPACE_BEGIN
 37 
 38 // Useful constants
 39 
 40 #define DEFAULT_DIGITS UNICODE_STRING_SIMPLE(&quot;0123456789&quot;);
 41 static const char gNumberingSystems[] = &quot;numberingSystems&quot;;
 42 static const char gNumberElements[] = &quot;NumberElements&quot;;
 43 static const char gDefault[] = &quot;default&quot;;
 44 static const char gNative[] = &quot;native&quot;;
 45 static const char gTraditional[] = &quot;traditional&quot;;
 46 static const char gFinance[] = &quot;finance&quot;;
 47 static const char gDesc[] = &quot;desc&quot;;
 48 static const char gRadix[] = &quot;radix&quot;;
 49 static const char gAlgorithmic[] = &quot;algorithmic&quot;;
 50 static const char gLatn[] = &quot;latn&quot;;
</pre>
<hr />
<pre>
 64      algorithmic = FALSE;
 65      UnicodeString defaultDigits = DEFAULT_DIGITS;
 66      desc.setTo(defaultDigits);
 67      uprv_strcpy(name,gLatn);
 68 }
 69 
 70     /**
 71      * Copy constructor.
 72      * @draft ICU 4.2
 73      */
 74 
 75 NumberingSystem::NumberingSystem(const NumberingSystem&amp; other)
 76 :  UObject(other) {
 77     *this=other;
 78 }
 79 
 80 NumberingSystem* U_EXPORT2
 81 NumberingSystem::createInstance(int32_t radix_in, UBool isAlgorithmic_in, const UnicodeString &amp; desc_in, UErrorCode &amp;status) {
 82 
 83     if (U_FAILURE(status)) {
<span class="line-modified"> 84         return nullptr;</span>
 85     }
 86 
 87     if ( radix_in &lt; 2 ) {
 88         status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified"> 89         return nullptr;</span>
 90     }
 91 
 92     if ( !isAlgorithmic_in ) {
 93        if ( desc_in.countChar32() != radix_in ) {
 94            status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified"> 95            return nullptr;</span>
 96        }
 97     }
 98 
<span class="line-modified"> 99     LocalPointer&lt;NumberingSystem&gt; ns(new NumberingSystem(), status);</span>
<span class="line-added">100     if (U_FAILURE(status)) {</span>
<span class="line-added">101         return nullptr;</span>
<span class="line-added">102     }</span>
103 
104     ns-&gt;setRadix(radix_in);
105     ns-&gt;setDesc(desc_in);
106     ns-&gt;setAlgorithmic(isAlgorithmic_in);
<span class="line-modified">107     ns-&gt;setName(nullptr);</span>

108 
<span class="line-added">109     return ns.orphan();</span>
110 }
111 

112 NumberingSystem* U_EXPORT2
113 NumberingSystem::createInstance(const Locale &amp; inLocale, UErrorCode&amp; status) {
114 
115     if (U_FAILURE(status)) {
<span class="line-modified">116         return nullptr;</span>
117     }
118 
119     UBool nsResolved = TRUE;
120     UBool usingFallback = FALSE;
121     char buffer[ULOC_KEYWORDS_CAPACITY];
<span class="line-modified">122     int32_t count = inLocale.getKeywordValue(&quot;numbers&quot;, buffer, sizeof(buffer), status);</span>
123     if (U_FAILURE(status) || status == U_STRING_NOT_TERMINATED_WARNING) {
124         // the &quot;numbers&quot; keyword exceeds ULOC_KEYWORDS_CAPACITY; ignore and use default.
125         count = 0;
126         status = U_ZERO_ERROR;
127     }
128     if ( count &gt; 0 ) { // @numbers keyword was specified in the locale
129         U_ASSERT(count &lt; ULOC_KEYWORDS_CAPACITY);
130         buffer[count] = &#39;\0&#39;; // Make sure it is null terminated.
131         if ( !uprv_strcmp(buffer,gDefault) || !uprv_strcmp(buffer,gNative) ||
132              !uprv_strcmp(buffer,gTraditional) || !uprv_strcmp(buffer,gFinance)) {
133             nsResolved = FALSE;
134         }
135     } else {
<span class="line-modified">136         uprv_strcpy(buffer, gDefault);</span>
137         nsResolved = FALSE;
138     }
139 
140     if (!nsResolved) { // Resolve the numbering system ( default, native, traditional or finance ) into a &quot;real&quot; numbering system
141         UErrorCode localStatus = U_ZERO_ERROR;
<span class="line-modified">142         LocalUResourceBundlePointer resource(ures_open(nullptr, inLocale.getName(), &amp;localStatus));</span>
<span class="line-modified">143         LocalUResourceBundlePointer numberElementsRes(ures_getByKey(resource.getAlias(), gNumberElements, nullptr, &amp;localStatus));</span>
<span class="line-added">144         // Don&#39;t stomp on the catastrophic failure of OOM.</span>
<span class="line-added">145         if (localStatus == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added">146             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">147             return nullptr;</span>
<span class="line-added">148         }</span>
149         while (!nsResolved) {
150             localStatus = U_ZERO_ERROR;
151             count = 0;
<span class="line-modified">152             const UChar *nsName = ures_getStringByKeyWithFallback(numberElementsRes.getAlias(), buffer, &amp;count, &amp;localStatus);</span>
<span class="line-added">153             // Don&#39;t stomp on the catastrophic failure of OOM.</span>
<span class="line-added">154             if (localStatus == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added">155                 status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">156                 return nullptr;</span>
<span class="line-added">157             }</span>
158             if ( count &gt; 0 &amp;&amp; count &lt; ULOC_KEYWORDS_CAPACITY ) { // numbering system found
<span class="line-modified">159                 u_UCharsToChars(nsName, buffer, count);</span>
160                 buffer[count] = &#39;\0&#39;; // Make sure it is null terminated.
161                 nsResolved = TRUE;
162             }
163 
164             if (!nsResolved) { // Fallback behavior per TR35 - traditional falls back to native, finance and native fall back to default
165                 if (!uprv_strcmp(buffer,gNative) || !uprv_strcmp(buffer,gFinance)) {
166                     uprv_strcpy(buffer,gDefault);
167                 } else if (!uprv_strcmp(buffer,gTraditional)) {
168                     uprv_strcpy(buffer,gNative);
169                 } else { // If we get here we couldn&#39;t find even the default numbering system
170                     usingFallback = TRUE;
171                     nsResolved = TRUE;
172                 }
173             }
174         }


175     }
176 
177     if (usingFallback) {
178         status = U_USING_FALLBACK_WARNING;
179         NumberingSystem *ns = new NumberingSystem();
<span class="line-added">180         if (ns == nullptr) {</span>
<span class="line-added">181             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">182         }</span>
183         return ns;
184     } else {
<span class="line-modified">185         return NumberingSystem::createInstanceByName(buffer, status);</span>
186     }
187  }
188 
189 NumberingSystem* U_EXPORT2
190 NumberingSystem::createInstance(UErrorCode&amp; status) {
191     return NumberingSystem::createInstance(Locale::getDefault(), status);
192 }
193 
194 NumberingSystem* U_EXPORT2
195 NumberingSystem::createInstanceByName(const char *name, UErrorCode&amp; status) {


196     int32_t radix = 10;
197     int32_t algorithmic = 0;
198 
<span class="line-modified">199     LocalUResourceBundlePointer numberingSystemsInfo(ures_openDirect(nullptr, gNumberingSystems, &amp;status));</span>
<span class="line-modified">200     LocalUResourceBundlePointer nsCurrent(ures_getByKey(numberingSystemsInfo.getAlias(), gNumberingSystems, nullptr, &amp;status));</span>
<span class="line-modified">201     LocalUResourceBundlePointer nsTop(ures_getByKey(nsCurrent.getAlias(), name, nullptr, &amp;status));</span>

202 
<span class="line-modified">203     UnicodeString nsd = ures_getUnicodeStringByKey(nsTop.getAlias(), gDesc, &amp;status);</span>

204 
<span class="line-modified">205     ures_getByKey(nsTop.getAlias(), gRadix, nsCurrent.getAlias(), &amp;status);</span>
<span class="line-modified">206     radix = ures_getInt(nsCurrent.getAlias(), &amp;status);</span>
207 
<span class="line-modified">208     ures_getByKey(nsTop.getAlias(), gAlgorithmic, nsCurrent.getAlias(), &amp;status);</span>
<span class="line-added">209     algorithmic = ures_getInt(nsCurrent.getAlias(), &amp;status);</span>
210 
<span class="line-modified">211     UBool isAlgorithmic = ( algorithmic == 1 );</span>


212 
213     if (U_FAILURE(status)) {
<span class="line-modified">214         // Don&#39;t stomp on the catastrophic failure of OOM.</span>
<span class="line-modified">215         if (status != U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added">216             status = U_UNSUPPORTED_ERROR;</span>
<span class="line-added">217         }</span>
<span class="line-added">218         return nullptr;</span>
219     }
220 
<span class="line-modified">221     LocalPointer&lt;NumberingSystem&gt; ns(NumberingSystem::createInstance(radix, isAlgorithmic, nsd, status), status);</span>
<span class="line-added">222     if (U_FAILURE(status)) {</span>
<span class="line-added">223         return nullptr;</span>
<span class="line-added">224     }</span>
225     ns-&gt;setName(name);
<span class="line-modified">226     return ns.orphan();</span>
227 }
228 
229     /**
230      * Destructor.
231      * @draft ICU 4.2
232      */
233 NumberingSystem::~NumberingSystem() {
234 }
235 
236 int32_t NumberingSystem::getRadix() const {
237     return radix;
238 }
239 
240 UnicodeString NumberingSystem::getDescription() const {
241     return desc;
242 }
243 
244 const char * NumberingSystem::getName() const {
245     return name;
246 }
247 
248 void NumberingSystem::setRadix(int32_t r) {
249     radix = r;
250 }
251 
252 void NumberingSystem::setAlgorithmic(UBool c) {
253     algorithmic = c;
254 }
255 
256 void NumberingSystem::setDesc(const UnicodeString &amp;d) {
257     desc.setTo(d);
258 }
259 void NumberingSystem::setName(const char *n) {
<span class="line-modified">260     if ( n == nullptr ) {</span>
261         name[0] = (char) 0;
262     } else {
<span class="line-modified">263         uprv_strncpy(name,n,kInternalNumSysNameCapacity);</span>
<span class="line-modified">264         name[kInternalNumSysNameCapacity] = &#39;\0&#39;; // Make sure it is null terminated.</span>
265     }
266 }
267 UBool NumberingSystem::isAlgorithmic() const {
268     return ( algorithmic );
269 }
270 
<span class="line-modified">271 namespace {</span>
<span class="line-modified">272 </span>
<span class="line-modified">273 UVector* gNumsysNames = nullptr;</span>
<span class="line-added">274 UInitOnce gNumSysInitOnce = U_INITONCE_INITIALIZER;</span>
<span class="line-added">275 </span>
<span class="line-added">276 U_CFUNC UBool U_CALLCONV numSysCleanup() {</span>
<span class="line-added">277     delete gNumsysNames;</span>
<span class="line-added">278     gNumsysNames = nullptr;</span>
<span class="line-added">279     gNumSysInitOnce.reset();</span>
<span class="line-added">280     return true;</span>
<span class="line-added">281 }</span>
282 
<span class="line-added">283 U_CFUNC void initNumsysNames(UErrorCode &amp;status) {</span>
<span class="line-added">284     U_ASSERT(gNumsysNames == nullptr);</span>
<span class="line-added">285     ucln_i18n_registerCleanup(UCLN_I18N_NUMSYS, numSysCleanup);</span>
<span class="line-added">286 </span>
<span class="line-added">287     // TODO: Simple array of UnicodeString objects, based on length of table resource?</span>
<span class="line-added">288     LocalPointer&lt;UVector&gt; numsysNames(new UVector(uprv_deleteUObject, nullptr, status), status);</span>
289     if (U_FAILURE(status)) {
<span class="line-modified">290         return;</span>
291     }
292 
<span class="line-modified">293     UErrorCode rbstatus = U_ZERO_ERROR;</span>
<span class="line-modified">294     UResourceBundle *numberingSystemsInfo = ures_openDirect(nullptr, &quot;numberingSystems&quot;, &amp;rbstatus);</span>
<span class="line-modified">295     numberingSystemsInfo =</span>
<span class="line-modified">296             ures_getByKey(numberingSystemsInfo, &quot;numberingSystems&quot;, numberingSystemsInfo, &amp;rbstatus);</span>
<span class="line-modified">297     if (U_FAILURE(rbstatus)) {</span>
<span class="line-modified">298         // Don&#39;t stomp on the catastrophic failure of OOM.</span>
<span class="line-modified">299         if (rbstatus == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-modified">300             status = rbstatus;</span>
<span class="line-modified">301         } else {</span>


302             status = U_MISSING_RESOURCE_ERROR;









303         }

304         ures_close(numberingSystemsInfo);
<span class="line-modified">305         return;</span>
<span class="line-modified">306     }</span>
<span class="line-added">307 </span>
<span class="line-added">308     while ( ures_hasNext(numberingSystemsInfo) &amp;&amp; U_SUCCESS(status) ) {</span>
<span class="line-added">309         LocalUResourceBundlePointer nsCurrent(ures_getNextResource(numberingSystemsInfo, nullptr, &amp;rbstatus));</span>
<span class="line-added">310         if (rbstatus == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added">311             status = rbstatus; // we want to report OOM failure back to the caller.</span>
<span class="line-added">312             break;</span>
313         }
<span class="line-modified">314         const char *nsName = ures_getKey(nsCurrent.getAlias());</span>
<span class="line-modified">315         LocalPointer&lt;UnicodeString&gt; newElem(new UnicodeString(nsName, -1, US_INV), status);</span>
<span class="line-modified">316         if (U_SUCCESS(status)) {</span>
<span class="line-modified">317             numsysNames-&gt;addElement(newElem.getAlias(), status);</span>
<span class="line-added">318             if (U_SUCCESS(status)) {</span>
<span class="line-added">319                 newElem.orphan(); // on success, the numsysNames vector owns newElem.</span>
<span class="line-added">320             }</span>
321         }

322     }
323 
<span class="line-modified">324     ures_close(numberingSystemsInfo);</span>
<span class="line-added">325     if (U_SUCCESS(status)) {</span>
<span class="line-added">326         gNumsysNames = numsysNames.orphan();</span>
<span class="line-added">327     }</span>
<span class="line-added">328     return;</span>
329 }
330 
<span class="line-modified">331 }   // end anonymous namespace</span>
<span class="line-modified">332 </span>
<span class="line-modified">333 StringEnumeration* NumberingSystem::getAvailableNames(UErrorCode &amp;status) {</span>
<span class="line-added">334     umtx_initOnce(gNumSysInitOnce, &amp;initNumsysNames, status);</span>
<span class="line-added">335     LocalPointer&lt;StringEnumeration&gt; result(new NumsysNameEnumeration(status), status);</span>
<span class="line-added">336     return result.orphan();</span>
<span class="line-added">337 }</span>
<span class="line-added">338 </span>
<span class="line-added">339 NumsysNameEnumeration::NumsysNameEnumeration(UErrorCode&amp; status) : pos(0) {</span>
<span class="line-added">340     (void)status;</span>
341 }
342 
343 const UnicodeString*
344 NumsysNameEnumeration::snext(UErrorCode&amp; status) {
<span class="line-modified">345     if (U_SUCCESS(status) &amp;&amp; (gNumsysNames != nullptr) &amp;&amp; (pos &lt; gNumsysNames-&gt;size())) {</span>
<span class="line-modified">346         return (const UnicodeString*)gNumsysNames-&gt;elementAt(pos++);</span>
347     }
<span class="line-modified">348     return nullptr;</span>
349 }
350 
351 void
352 NumsysNameEnumeration::reset(UErrorCode&amp; /*status*/) {
353     pos=0;
354 }
355 
356 int32_t
357 NumsysNameEnumeration::count(UErrorCode&amp; /*status*/) const {
<span class="line-modified">358     return (gNumsysNames==nullptr) ? 0 : gNumsysNames-&gt;size();</span>
359 }
360 
361 NumsysNameEnumeration::~NumsysNameEnumeration() {

362 }
363 U_NAMESPACE_END
364 
365 #endif /* #if !UCONFIG_NO_FORMATTING */
366 
367 //eof
</pre>
</td>
</tr>
</table>
<center><a href="numparse_types.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="numsys_impl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>