<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/rbbitblb.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="rbbiscan.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rbbitblb.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/rbbitblb.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 426,12 ***</span>
  
      UVector ruleRootNodes(*fStatus);
      addRuleRootNodes(&amp;ruleRootNodes, tree);
  
      UVector matchStartNodes(*fStatus);
<span class="line-modified">!     for (int i=0; i&lt;ruleRootNodes.size(); ++i) {</span>
<span class="line-modified">!         RBBINode *node = static_cast&lt;RBBINode *&gt;(ruleRootNodes.elementAt(i));</span>
          if (node-&gt;fChainIn) {
              setAdd(&amp;matchStartNodes, node-&gt;fFirstPosSet);
          }
      }
      if (U_FAILURE(*fStatus)) {
<span class="line-new-header">--- 426,12 ---</span>
  
      UVector ruleRootNodes(*fStatus);
      addRuleRootNodes(&amp;ruleRootNodes, tree);
  
      UVector matchStartNodes(*fStatus);
<span class="line-modified">!     for (int j=0; j&lt;ruleRootNodes.size(); ++j) {</span>
<span class="line-modified">!         RBBINode *node = static_cast&lt;RBBINode *&gt;(ruleRootNodes.elementAt(j));</span>
          if (node-&gt;fChainIn) {
              setAdd(&amp;matchStartNodes, node-&gt;fFirstPosSet);
          }
      }
      if (U_FAILURE(*fStatus)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1080,25 ***</span>
  //
  bool RBBITableBuilder::findDuplCharClassFrom(IntPair *categories) {
      int32_t numStates = fDStates-&gt;size();
      int32_t numCols = fRB-&gt;fSetBuilder-&gt;getNumCharCategories();
  
<span class="line-removed">-     uint16_t table_base;</span>
<span class="line-removed">-     uint16_t table_dupl;</span>
      for (; categories-&gt;first &lt; numCols-1; categories-&gt;first++) {
          for (categories-&gt;second=categories-&gt;first+1; categories-&gt;second &lt; numCols; categories-&gt;second++) {
<span class="line-modified">!              for (int32_t state=0; state&lt;numStates; state++) {</span>
<span class="line-modified">!                  RBBIStateDescriptor *sd = (RBBIStateDescriptor *)fDStates-&gt;elementAt(state);</span>
<span class="line-modified">!                  table_base = (uint16_t)sd-&gt;fDtran-&gt;elementAti(categories-&gt;first);</span>
<span class="line-modified">!                  table_dupl = (uint16_t)sd-&gt;fDtran-&gt;elementAti(categories-&gt;second);</span>
<span class="line-modified">!                  if (table_base != table_dupl) {</span>
<span class="line-modified">!                      break;</span>
<span class="line-modified">!                  }</span>
<span class="line-modified">!              }</span>
<span class="line-modified">!              if (table_base == table_dupl) {</span>
<span class="line-modified">!                  return true;</span>
<span class="line-modified">!              }</span>
          }
      }
      return false;
  }
  
<span class="line-new-header">--- 1080,26 ---</span>
  //
  bool RBBITableBuilder::findDuplCharClassFrom(IntPair *categories) {
      int32_t numStates = fDStates-&gt;size();
      int32_t numCols = fRB-&gt;fSetBuilder-&gt;getNumCharCategories();
  
      for (; categories-&gt;first &lt; numCols-1; categories-&gt;first++) {
          for (categories-&gt;second=categories-&gt;first+1; categories-&gt;second &lt; numCols; categories-&gt;second++) {
<span class="line-modified">!             // Initialized to different values to prevent returning true if numStates = 0 (implies no duplicates).</span>
<span class="line-modified">!             uint16_t table_base = 0;</span>
<span class="line-modified">!             uint16_t table_dupl = 1;</span>
<span class="line-modified">!             for (int32_t state=0; state&lt;numStates; state++) {</span>
<span class="line-modified">!                 RBBIStateDescriptor *sd = (RBBIStateDescriptor *)fDStates-&gt;elementAt(state);</span>
<span class="line-modified">!                 table_base = (uint16_t)sd-&gt;fDtran-&gt;elementAti(categories-&gt;first);</span>
<span class="line-modified">!                 table_dupl = (uint16_t)sd-&gt;fDtran-&gt;elementAti(categories-&gt;second);</span>
<span class="line-modified">!                 if (table_base != table_dupl) {</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
<span class="line-added">+             if (table_base == table_dupl) {</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             }</span>
          }
      }
      return false;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1234,25 ***</span>
              if (existingVal == duplState) {
                  newVal = keepState;
              } else if (existingVal &gt; duplState) {
                  newVal = existingVal - 1;
              }
<span class="line-modified">!             sd-&gt;setCharAt(col, newVal);</span>
          }
      }
  }
  
  
  /*
   * RemoveDuplicateStates
   */
<span class="line-modified">! void RBBITableBuilder::removeDuplicateStates() {</span>
      IntPair dupls = {3, 0};
      while (findDuplicateState(&amp;dupls)) {
          // printf(&quot;Removing duplicate states (%d, %d)\n&quot;, dupls.first, dupls.second);
          removeState(dupls);
      }
  }
  
  
  //-----------------------------------------------------------------------------
  //
<span class="line-new-header">--- 1235,29 ---</span>
              if (existingVal == duplState) {
                  newVal = keepState;
              } else if (existingVal &gt; duplState) {
                  newVal = existingVal - 1;
              }
<span class="line-modified">!             sd-&gt;setCharAt(col, static_cast&lt;char16_t&gt;(newVal));</span>
          }
      }
  }
  
  
  /*
   * RemoveDuplicateStates
   */
<span class="line-modified">! int32_t RBBITableBuilder::removeDuplicateStates() {</span>
      IntPair dupls = {3, 0};
<span class="line-added">+     int32_t numStatesRemoved = 0;</span>
<span class="line-added">+ </span>
      while (findDuplicateState(&amp;dupls)) {
          // printf(&quot;Removing duplicate states (%d, %d)\n&quot;, dupls.first, dupls.second);
          removeState(dupls);
<span class="line-added">+         ++numStatesRemoved;</span>
      }
<span class="line-added">+     return numStatesRemoved;</span>
  }
  
  
  //-----------------------------------------------------------------------------
  //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1409,11 ***</span>
  
      // From the start state, each input char class transitions to the state for that input.
      UnicodeString &amp;startState = *static_cast&lt;UnicodeString *&gt;(fSafeTable-&gt;elementAt(1));
      for (int32_t charClass=0; charClass &lt; numCharClasses; ++charClass) {
          // Note: +2 for the start &amp; stop state.
<span class="line-modified">!         startState.setCharAt(charClass, charClass+2);</span>
      }
  
      // Initially make every other state table row look like the start state row,
      for (int32_t row=2; row&lt;numCharClasses+2; ++row) {
          UnicodeString &amp;rowState = *static_cast&lt;UnicodeString *&gt;(fSafeTable-&gt;elementAt(row));
<span class="line-new-header">--- 1414,11 ---</span>
  
      // From the start state, each input char class transitions to the state for that input.
      UnicodeString &amp;startState = *static_cast&lt;UnicodeString *&gt;(fSafeTable-&gt;elementAt(1));
      for (int32_t charClass=0; charClass &lt; numCharClasses; ++charClass) {
          // Note: +2 for the start &amp; stop state.
<span class="line-modified">!         startState.setCharAt(charClass, static_cast&lt;char16_t&gt;(charClass+2));</span>
      }
  
      // Initially make every other state table row look like the start state row,
      for (int32_t row=2; row&lt;numCharClasses+2; ++row) {
          UnicodeString &amp;rowState = *static_cast&lt;UnicodeString *&gt;(fSafeTable-&gt;elementAt(row));
</pre>
<center><a href="rbbiscan.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rbbitblb.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>