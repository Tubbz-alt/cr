<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/udata.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ******************************************************************************
   5 *
   6 *   Copyright (C) 1999-2016, International Business Machines
   7 *   Corporation and others.  All Rights Reserved.
   8 *
   9 ******************************************************************************
  10 *   file name:  udata.cpp
  11 *   encoding:   UTF-8
  12 *   tab size:   8 (not used)
  13 *   indentation:4
  14 *
  15 *   created on: 1999oct25
  16 *   created by: Markus W. Scherer
  17 */
  18 
  19 #include &quot;unicode/utypes.h&quot;  /* U_PLATFORM etc. */
  20 
  21 #ifdef __GNUC__
  22 /* if gcc
  23 #define ATTRIBUTE_WEAK __attribute__ ((weak))
  24 might have to #include some other header
  25 */
  26 #endif
  27 
  28 #include &quot;unicode/putil.h&quot;
  29 #include &quot;unicode/udata.h&quot;
  30 #include &quot;unicode/uversion.h&quot;
  31 #include &quot;charstr.h&quot;
  32 #include &quot;cmemory.h&quot;
  33 #include &quot;cstring.h&quot;
  34 #include &quot;mutex.h&quot;
  35 #include &quot;putilimp.h&quot;
  36 #include &quot;uassert.h&quot;
  37 #include &quot;ucln_cmn.h&quot;
  38 #include &quot;ucmndata.h&quot;
  39 #include &quot;udatamem.h&quot;
  40 #include &quot;uhash.h&quot;
  41 #include &quot;umapfile.h&quot;
  42 #include &quot;umutex.h&quot;
  43 
  44 /***********************************************************************
  45 *
  46 *   Notes on the organization of the ICU data implementation
  47 *
  48 *      All of the public API is defined in udata.h
  49 *
  50 *      The implementation is split into several files...
  51 *
  52 *         - udata.c  (this file) contains higher level code that knows about
  53 *                     the search paths for locating data, caching opened data, etc.
  54 *
  55 *         - umapfile.c  contains the low level platform-specific code for actually loading
  56 *                     (memory mapping, file reading, whatever) data into memory.
  57 *
  58 *         - ucmndata.c  deals with the tables of contents of ICU data items within
  59 *                     an ICU common format data file.  The implementation includes
  60 *                     an abstract interface and support for multiple TOC formats.
  61 *                     All knowledge of any specific TOC format is encapsulated here.
  62 *
  63 *         - udatamem.c has code for managing UDataMemory structs.  These are little
  64 *                     descriptor objects for blocks of memory holding ICU data of
  65 *                     various types.
  66 */
  67 
  68 /* configuration ---------------------------------------------------------- */
  69 
  70 /* If you are excruciatingly bored turn this on .. */
  71 /* #define UDATA_DEBUG 1 */
  72 
  73 #if defined(UDATA_DEBUG)
  74 #   include &lt;stdio.h&gt;
  75 #endif
  76 
  77 U_NAMESPACE_USE
  78 
  79 /*
  80  *  Forward declarations
  81  */
  82 static UDataMemory *udata_findCachedData(const char *path, UErrorCode &amp;err);
  83 
  84 /***********************************************************************
  85 *
  86 *    static (Global) data
  87 *
  88 ************************************************************************/
  89 
  90 /*
  91  * Pointers to the common ICU data.
  92  *
  93  * We store multiple pointers to ICU data packages and iterate through them
  94  * when looking for a data item.
  95  *
  96  * It is possible to combine this with dependency inversion:
  97  * One or more data package libraries may export
  98  * functions that each return a pointer to their piece of the ICU data,
  99  * and this file would import them as weak functions, without a
 100  * strong linker dependency from the common library on the data library.
 101  *
 102  * Then we can have applications depend on only that part of ICU&#39;s data
 103  * that they really need, reducing the size of binaries that take advantage
 104  * of this.
 105  */
 106 static UDataMemory *gCommonICUDataArray[10] = { NULL };   // Access protected by icu global mutex.
 107 
 108 static u_atomic_int32_t gHaveTriedToLoadCommonData = ATOMIC_INT32_T_INITIALIZER(0);  //  See extendICUData().
 109 
 110 static UHashtable  *gCommonDataCache = NULL;  /* Global hash table of opened ICU data files.  */
 111 static icu::UInitOnce gCommonDataCacheInitOnce = U_INITONCE_INITIALIZER;
 112 
 113 #if U_PLATFORM_HAS_WINUWP_API == 0
 114 static UDataFileAccess  gDataFileAccess = UDATA_DEFAULT_ACCESS;  // Access not synchronized.
 115                                                                  // Modifying is documented as thread-unsafe.
 116 #else
 117 static UDataFileAccess  gDataFileAccess = UDATA_NO_FILES;        // Windows UWP looks in one spot explicitly
 118 #endif
 119 
 120 static UBool U_CALLCONV
 121 udata_cleanup(void)
 122 {
 123     int32_t i;
 124 
 125     if (gCommonDataCache) {             /* Delete the cache of user data mappings.  */
 126         uhash_close(gCommonDataCache);  /*   Table owns the contents, and will delete them. */
 127         gCommonDataCache = NULL;        /*   Cleanup is not thread safe.                */
 128     }
 129     gCommonDataCacheInitOnce.reset();
 130 
 131     for (i = 0; i &lt; UPRV_LENGTHOF(gCommonICUDataArray) &amp;&amp; gCommonICUDataArray[i] != NULL; ++i) {
 132         udata_close(gCommonICUDataArray[i]);
 133         gCommonICUDataArray[i] = NULL;
 134     }
 135     gHaveTriedToLoadCommonData = 0;
 136 
 137     return TRUE;                   /* Everything was cleaned up */
 138 }
 139 
 140 static UBool U_CALLCONV
 141 findCommonICUDataByName(const char *inBasename, UErrorCode &amp;err)
 142 {
 143     UBool found = FALSE;
 144     int32_t i;
 145 
 146     UDataMemory  *pData = udata_findCachedData(inBasename, err);
 147     if (U_FAILURE(err) || pData == NULL)
 148         return FALSE;
 149 
 150     {
 151         Mutex lock;
 152         for (i = 0; i &lt; UPRV_LENGTHOF(gCommonICUDataArray); ++i) {
 153             if ((gCommonICUDataArray[i] != NULL) &amp;&amp; (gCommonICUDataArray[i]-&gt;pHeader == pData-&gt;pHeader)) {
 154                 /* The data pointer is already in the array. */
 155                 found = TRUE;
 156                 break;
 157             }
 158         }
 159     }
 160     return found;
 161 }
 162 
 163 
 164 /*
 165  * setCommonICUData.   Set a UDataMemory to be the global ICU Data
 166  */
 167 static UBool
 168 setCommonICUData(UDataMemory *pData,     /*  The new common data.  Belongs to caller, we copy it. */
 169                  UBool       warn,       /*  If true, set USING_DEFAULT warning if ICUData was    */
 170                                          /*    changed by another thread before we got to it.     */
 171                  UErrorCode *pErr)
 172 {
 173     UDataMemory  *newCommonData = UDataMemory_createNewInstance(pErr);
 174     int32_t i;
 175     UBool didUpdate = FALSE;
 176     if (U_FAILURE(*pErr)) {
 177         return FALSE;
 178     }
 179 
 180     /*  For the assignment, other threads must cleanly see either the old            */
 181     /*    or the new, not some partially initialized new.  The old can not be        */
 182     /*    deleted - someone may still have a pointer to it lying around in           */
 183     /*    their locals.                                                              */
 184     UDatamemory_assign(newCommonData, pData);
 185     umtx_lock(NULL);
 186     for (i = 0; i &lt; UPRV_LENGTHOF(gCommonICUDataArray); ++i) {
 187         if (gCommonICUDataArray[i] == NULL) {
 188             gCommonICUDataArray[i] = newCommonData;
 189             didUpdate = TRUE;
 190             break;
 191         } else if (gCommonICUDataArray[i]-&gt;pHeader == pData-&gt;pHeader) {
 192             /* The same data pointer is already in the array. */
 193             break;
 194         }
 195     }
 196     umtx_unlock(NULL);
 197 
 198     if (i == UPRV_LENGTHOF(gCommonICUDataArray) &amp;&amp; warn) {
 199         *pErr = U_USING_DEFAULT_WARNING;
 200     }
 201     if (didUpdate) {
 202         ucln_common_registerCleanup(UCLN_COMMON_UDATA, udata_cleanup);
 203     } else {
 204         uprv_free(newCommonData);
 205     }
 206     return didUpdate;
 207 }
 208 
 209 #if U_PLATFORM_HAS_WINUWP_API == 0
 210 
 211 static UBool
 212 setCommonICUDataPointer(const void *pData, UBool /*warn*/, UErrorCode *pErrorCode) {
 213     UDataMemory tData;
 214     UDataMemory_init(&amp;tData);
 215     UDataMemory_setData(&amp;tData, pData);
 216     udata_checkCommonData(&amp;tData, pErrorCode);
 217     return setCommonICUData(&amp;tData, FALSE, pErrorCode);
 218 }
 219 
 220 #endif
 221 
 222 static const char *
 223 findBasename(const char *path) {
 224     const char *basename=uprv_strrchr(path, U_FILE_SEP_CHAR);
 225     if(basename==NULL) {
 226         return path;
 227     } else {
 228         return basename+1;
 229     }
 230 }
 231 
 232 #ifdef UDATA_DEBUG
 233 static const char *
 234 packageNameFromPath(const char *path)
 235 {
 236     if((path == NULL) || (*path == 0)) {
 237         return U_ICUDATA_NAME;
 238     }
 239 
 240     path = findBasename(path);
 241 
 242     if((path == NULL) || (*path == 0)) {
 243         return U_ICUDATA_NAME;
 244     }
 245 
 246     return path;
 247 }
 248 #endif
 249 
 250 /*----------------------------------------------------------------------*
 251  *                                                                      *
 252  *   Cache for common data                                              *
 253  *      Functions for looking up or adding entries to a cache of        *
 254  *      data that has been previously opened.  Avoids a potentially     *
 255  *      expensive operation of re-opening the data for subsequent       *
 256  *      uses.                                                           *
 257  *                                                                      *
 258  *      Data remains cached for the duration of the process.            *
 259  *                                                                      *
 260  *----------------------------------------------------------------------*/
 261 
 262 typedef struct DataCacheElement {
 263     char          *name;
 264     UDataMemory   *item;
 265 } DataCacheElement;
 266 
 267 
 268 
 269 /*
 270  * Deleter function for DataCacheElements.
 271  *         udata cleanup function closes the hash table; hash table in turn calls back to
 272  *         here for each entry.
 273  */
 274 static void U_CALLCONV DataCacheElement_deleter(void *pDCEl) {
 275     DataCacheElement *p = (DataCacheElement *)pDCEl;
 276     udata_close(p-&gt;item);              /* unmaps storage */
 277     uprv_free(p-&gt;name);                /* delete the hash key string. */
 278     uprv_free(pDCEl);                  /* delete &#39;this&#39;          */
 279 }
 280 
 281 static void U_CALLCONV udata_initHashTable(UErrorCode &amp;err) {
 282     U_ASSERT(gCommonDataCache == NULL);
 283     gCommonDataCache = uhash_open(uhash_hashChars, uhash_compareChars, NULL, &amp;err);
 284     if (U_FAILURE(err)) {
 285        return;
 286     }
 287     U_ASSERT(gCommonDataCache != NULL);
 288     uhash_setValueDeleter(gCommonDataCache, DataCacheElement_deleter);
 289     ucln_common_registerCleanup(UCLN_COMMON_UDATA, udata_cleanup);
 290 }
 291 
 292  /*   udata_getCacheHashTable()
 293   *     Get the hash table used to store the data cache entries.
 294   *     Lazy create it if it doesn&#39;t yet exist.
 295   */
 296 static UHashtable *udata_getHashTable(UErrorCode &amp;err) {
 297     umtx_initOnce(gCommonDataCacheInitOnce, &amp;udata_initHashTable, err);
 298     return gCommonDataCache;
 299 }
 300 
 301 
 302 
 303 static UDataMemory *udata_findCachedData(const char *path, UErrorCode &amp;err)
 304 {
 305     UHashtable        *htable;
 306     UDataMemory       *retVal = NULL;
 307     DataCacheElement  *el;
 308     const char        *baseName;
 309 
 310     htable = udata_getHashTable(err);
 311     if (U_FAILURE(err)) {
 312         return NULL;
 313     }
 314 
 315     baseName = findBasename(path);   /* Cache remembers only the base name, not the full path. */
 316     umtx_lock(NULL);
 317     el = (DataCacheElement *)uhash_get(htable, baseName);
 318     umtx_unlock(NULL);
 319     if (el != NULL) {
 320         retVal = el-&gt;item;
 321     }
 322 #ifdef UDATA_DEBUG
 323     fprintf(stderr, &quot;Cache: [%s] -&gt; %p\n&quot;, baseName, retVal);
 324 #endif
 325     return retVal;
 326 }
 327 
 328 
 329 static UDataMemory *udata_cacheDataItem(const char *path, UDataMemory *item, UErrorCode *pErr) {
 330     DataCacheElement *newElement;
 331     const char       *baseName;
 332     int32_t           nameLen;
 333     UHashtable       *htable;
 334     DataCacheElement *oldValue = NULL;
 335     UErrorCode        subErr = U_ZERO_ERROR;
 336 
 337     htable = udata_getHashTable(*pErr);
 338     if (U_FAILURE(*pErr)) {
 339         return NULL;
 340     }
 341 
 342     /* Create a new DataCacheElement - the thingy we store in the hash table -
 343      * and copy the supplied path and UDataMemoryItems into it.
 344      */
 345     newElement = (DataCacheElement *)uprv_malloc(sizeof(DataCacheElement));
 346     if (newElement == NULL) {
 347         *pErr = U_MEMORY_ALLOCATION_ERROR;
 348         return NULL;
 349     }
 350     newElement-&gt;item = UDataMemory_createNewInstance(pErr);
 351     if (U_FAILURE(*pErr)) {
 352         uprv_free(newElement);
 353         return NULL;
 354     }
 355     UDatamemory_assign(newElement-&gt;item, item);
 356 
 357     baseName = findBasename(path);
 358     nameLen = (int32_t)uprv_strlen(baseName);
 359     newElement-&gt;name = (char *)uprv_malloc(nameLen+1);
 360     if (newElement-&gt;name == NULL) {
 361         *pErr = U_MEMORY_ALLOCATION_ERROR;
 362         uprv_free(newElement-&gt;item);
 363         uprv_free(newElement);
 364         return NULL;
 365     }
 366     uprv_strcpy(newElement-&gt;name, baseName);
 367 
 368     /* Stick the new DataCacheElement into the hash table.
 369     */
 370     umtx_lock(NULL);
 371     oldValue = (DataCacheElement *)uhash_get(htable, path);
 372     if (oldValue != NULL) {
 373         subErr = U_USING_DEFAULT_WARNING;
 374     }
 375     else {
 376         uhash_put(
 377             htable,
 378             newElement-&gt;name,               /* Key   */
 379             newElement,                     /* Value */
 380             &amp;subErr);
 381     }
 382     umtx_unlock(NULL);
 383 
 384 #ifdef UDATA_DEBUG
 385     fprintf(stderr, &quot;Cache: [%s] &lt;&lt;&lt; %p : %s. vFunc=%p\n&quot;, newElement-&gt;name,
 386     newElement-&gt;item, u_errorName(subErr), newElement-&gt;item-&gt;vFuncs);
 387 #endif
 388 
 389     if (subErr == U_USING_DEFAULT_WARNING || U_FAILURE(subErr)) {
 390         *pErr = subErr; /* copy sub err unto fillin ONLY if something happens. */
 391         uprv_free(newElement-&gt;name);
 392         uprv_free(newElement-&gt;item);
 393         uprv_free(newElement);
 394         return oldValue ? oldValue-&gt;item : NULL;
 395     }
 396 
 397     return newElement-&gt;item;
 398 }
 399 
 400 /*----------------------------------------------------------------------*==============
 401  *                                                                      *
 402  *  Path management.  Could be shared with other tools/etc if need be   *
 403  * later on.                                                            *
 404  *                                                                      *
 405  *----------------------------------------------------------------------*/
 406 
 407 U_NAMESPACE_BEGIN
 408 
 409 class UDataPathIterator
 410 {
 411 public:
 412     UDataPathIterator(const char *path, const char *pkg,
 413                       const char *item, const char *suffix, UBool doCheckLastFour,
 414                       UErrorCode *pErrorCode);
 415     const char *next(UErrorCode *pErrorCode);
 416 
 417 private:
 418     const char *path;                              /* working path (u_icudata_Dir) */
 419     const char *nextPath;                          /* path following this one */
 420     const char *basename;                          /* item&#39;s basename (icudt22e_mt.res)*/
<a name="1" id="anc1"></a><span class="line-modified"> 421     const char *suffix;                            /* item suffix (can be null) */</span>

 422 
 423     uint32_t    basenameLen;                       /* length of basename */
 424 
 425     CharString  itemPath;                          /* path passed in with item name */
 426     CharString  pathBuffer;                        /* output path for this it&#39;ion */
 427     CharString  packageStub;                       /* example:  &quot;/icudt28b&quot;. Will ignore that leaf in set paths. */
 428 
 429     UBool       checkLastFour;                     /* if TRUE then allow paths such as &#39;/foo/myapp.dat&#39;
 430                                                     * to match, checks last 4 chars of suffix with
 431                                                     * last 4 of path, then previous chars. */
 432 };
 433 
 434 /**
<a name="2" id="anc2"></a><span class="line-modified"> 435  * @param iter  The iterator to be initialized. Its current state does not matter.</span>
<span class="line-modified"> 436  * @param path  The full pathname to be iterated over.  If NULL, defaults to U_ICUDATA_NAME</span>
<span class="line-modified"> 437  * @param pkg   Package which is being searched for, ex &quot;icudt28l&quot;.  Will ignore leave directories such as /icudt28l</span>
<span class="line-modified"> 438  * @param item  Item to be searched for.  Can include full path, such as /a/b/foo.dat</span>
<span class="line-modified"> 439  * @param suffix  Optional item suffix, if not-null (ex. &quot;.dat&quot;) then &#39;path&#39; can contain &#39;item&#39; explicitly.</span>
<span class="line-modified"> 440  *               Ex:   &#39;stuff.dat&#39; would be found in &#39;/a/foo:/tmp/stuff.dat:/bar/baz&#39; as item #2.</span>
<span class="line-modified"> 441  *                     &#39;/blarg/stuff.dat&#39; would also be found.</span>


 442  */
 443 UDataPathIterator::UDataPathIterator(const char *inPath, const char *pkg,
 444                                      const char *item, const char *inSuffix, UBool doCheckLastFour,
 445                                      UErrorCode *pErrorCode)
 446 {
 447 #ifdef UDATA_DEBUG
 448         fprintf(stderr, &quot;SUFFIX1=%s PATH=%s\n&quot;, inSuffix, inPath);
 449 #endif
 450     /** Path **/
 451     if(inPath == NULL) {
 452         path = u_getDataDirectory();
 453     } else {
 454         path = inPath;
 455     }
 456 
 457     /** Package **/
 458     if(pkg != NULL) {
 459       packageStub.append(U_FILE_SEP_CHAR, *pErrorCode).append(pkg, *pErrorCode);
 460 #ifdef UDATA_DEBUG
 461       fprintf(stderr, &quot;STUB=%s [%d]\n&quot;, packageStub.data(), packageStub.length());
 462 #endif
 463     }
 464 
 465     /** Item **/
 466     basename = findBasename(item);
 467     basenameLen = (int32_t)uprv_strlen(basename);
 468 
 469     /** Item path **/
 470     if(basename == item) {
 471         nextPath = path;
 472     } else {
 473         itemPath.append(item, (int32_t)(basename-item), *pErrorCode);
 474         nextPath = itemPath.data();
 475     }
 476 #ifdef UDATA_DEBUG
 477     fprintf(stderr, &quot;SUFFIX=%s [%p]\n&quot;, inSuffix, inSuffix);
 478 #endif
 479 
 480     /** Suffix  **/
 481     if(inSuffix != NULL) {
 482         suffix = inSuffix;
 483     } else {
 484         suffix = &quot;&quot;;
 485     }
 486 
 487     checkLastFour = doCheckLastFour;
 488 
 489     /* pathBuffer will hold the output path strings returned by this iterator */
 490 
 491 #ifdef UDATA_DEBUG
 492     fprintf(stderr, &quot;%p: init %s -&gt; [path=%s], [base=%s], [suff=%s], [itempath=%s], [nextpath=%s], [checklast4=%s]\n&quot;,
 493             iter,
 494             item,
 495             path,
 496             basename,
 497             suffix,
 498             itemPath.data(),
 499             nextPath,
 500             checkLastFour?&quot;TRUE&quot;:&quot;false&quot;);
 501 #endif
 502 }
 503 
 504 /**
 505  * Get the next path on the list.
 506  *
 507  * @param iter The Iter to be used
 508  * @param len  If set, pointer to the length of the returned path, for convenience.
 509  * @return Pointer to the next path segment, or NULL if there are no more.
 510  */
 511 const char *UDataPathIterator::next(UErrorCode *pErrorCode)
 512 {
 513     if(U_FAILURE(*pErrorCode)) {
 514         return NULL;
 515     }
 516 
 517     const char *currentPath = NULL;
 518     int32_t     pathLen = 0;
 519     const char *pathBasename;
 520 
 521     do
 522     {
 523         if( nextPath == NULL ) {
 524             break;
 525         }
 526         currentPath = nextPath;
 527 
 528         if(nextPath == itemPath.data()) { /* we were processing item&#39;s path. */
 529             nextPath = path; /* start with regular path next tm. */
 530             pathLen = (int32_t)uprv_strlen(currentPath);
 531         } else {
 532             /* fix up next for next time */
 533             nextPath = uprv_strchr(currentPath, U_PATH_SEP_CHAR);
 534             if(nextPath == NULL) {
 535                 /* segment: entire path */
 536                 pathLen = (int32_t)uprv_strlen(currentPath);
 537             } else {
 538                 /* segment: until next segment */
 539                 pathLen = (int32_t)(nextPath - currentPath);
 540                 /* skip divider */
 541                 nextPath ++;
 542             }
 543         }
 544 
 545         if(pathLen == 0) {
 546             continue;
 547         }
 548 
 549 #ifdef UDATA_DEBUG
 550         fprintf(stderr, &quot;rest of path (IDD) = %s\n&quot;, currentPath);
 551         fprintf(stderr, &quot;                     &quot;);
 552         {
 553             uint32_t qqq;
 554             for(qqq=0;qqq&lt;pathLen;qqq++)
 555             {
 556                 fprintf(stderr, &quot; &quot;);
 557             }
 558 
 559             fprintf(stderr, &quot;^\n&quot;);
 560         }
 561 #endif
 562         pathBuffer.clear().append(currentPath, pathLen, *pErrorCode);
 563 
 564         /* check for .dat files */
 565         pathBasename = findBasename(pathBuffer.data());
 566 
 567         if(checkLastFour == TRUE &amp;&amp;
 568            (pathLen&gt;=4) &amp;&amp;
<a name="3" id="anc3"></a><span class="line-modified"> 569            uprv_strncmp(pathBuffer.data() +(pathLen-4), suffix, 4)==0 &amp;&amp; /* suffix matches */</span>
 570            uprv_strncmp(findBasename(pathBuffer.data()), basename, basenameLen)==0  &amp;&amp; /* base matches */
 571            uprv_strlen(pathBasename)==(basenameLen+4)) { /* base+suffix = full len */
 572 
 573 #ifdef UDATA_DEBUG
 574             fprintf(stderr, &quot;Have %s file on the path: %s\n&quot;, suffix, pathBuffer.data());
 575 #endif
 576             /* do nothing */
 577         }
 578         else
 579         {       /* regular dir path */
 580             if(pathBuffer[pathLen-1] != U_FILE_SEP_CHAR) {
 581                 if((pathLen&gt;=4) &amp;&amp;
 582                    uprv_strncmp(pathBuffer.data()+(pathLen-4), &quot;.dat&quot;, 4) == 0)
 583                 {
 584 #ifdef UDATA_DEBUG
 585                     fprintf(stderr, &quot;skipping non-directory .dat file %s\n&quot;, pathBuffer.data());
 586 #endif
 587                     continue;
 588                 }
 589 
 590                 /* Check if it is a directory with the same name as our package */
 591                 if(!packageStub.isEmpty() &amp;&amp;
 592                    (pathLen &gt; packageStub.length()) &amp;&amp;
 593                    !uprv_strcmp(pathBuffer.data() + pathLen - packageStub.length(), packageStub.data())) {
 594 #ifdef UDATA_DEBUG
 595                   fprintf(stderr, &quot;Found stub %s (will add package %s of len %d)\n&quot;, packageStub.data(), basename, basenameLen);
 596 #endif
 597                   pathBuffer.truncate(pathLen - packageStub.length());
 598                 }
 599                 pathBuffer.append(U_FILE_SEP_CHAR, *pErrorCode);
 600             }
 601 
 602             /* + basename */
 603             pathBuffer.append(packageStub.data()+1, packageStub.length()-1, *pErrorCode);
 604 
<a name="4" id="anc4"></a><span class="line-modified"> 605             if(*suffix)  /* tack on suffix */</span>
 606             {
<a name="5" id="anc5"></a>




 607                 pathBuffer.append(suffix, *pErrorCode);
 608             }
 609         }
 610 
 611 #ifdef UDATA_DEBUG
 612         fprintf(stderr, &quot; --&gt;  %s\n&quot;, pathBuffer.data());
 613 #endif
 614 
 615         return pathBuffer.data();
 616 
 617     } while(path);
 618 
 619     /* fell way off the end */
 620     return NULL;
 621 }
 622 
 623 U_NAMESPACE_END
 624 
 625 /* ==================================================================================*/
 626 
 627 
 628 /*----------------------------------------------------------------------*
 629  *                                                                      *
 630  *  Add a static reference to the common data library                   *
 631  *   Unless overridden by an explicit udata_setCommonData, this will be *
 632  *      our common data.                                                *
 633  *                                                                      *
 634  *----------------------------------------------------------------------*/
 635 #if U_PLATFORM_HAS_WINUWP_API == 0 // Windows UWP Platform does not support dll icu data at this time
 636 extern &quot;C&quot; const DataHeader U_DATA_API U_ICUDATA_ENTRY_POINT;
 637 #endif
 638 
 639 /*
 640  * This would be a good place for weak-linkage declarations of
 641  * partial-data-library access functions where each returns a pointer
 642  * to its data package, if it is linked in.
 643  */
 644 /*
 645 extern const void *uprv_getICUData_collation(void) ATTRIBUTE_WEAK;
 646 extern const void *uprv_getICUData_conversion(void) ATTRIBUTE_WEAK;
 647 */
 648 
 649 /*----------------------------------------------------------------------*
 650  *                                                                      *
 651  *   openCommonData   Attempt to open a common format (.dat) file       *
 652  *                    Map it into memory (if it&#39;s not there already)    *
 653  *                    and return a UDataMemory object for it.           *
 654  *                                                                      *
 655  *                    If the requested data is already open and cached  *
 656  *                       just return the cached UDataMem object.        *
 657  *                                                                      *
 658  *----------------------------------------------------------------------*/
 659 static UDataMemory *
 660 openCommonData(const char *path,          /*  Path from OpenChoice?          */
 661                int32_t commonDataIndex,   /*  ICU Data (index &gt;= 0) if path == NULL */
 662                UErrorCode *pErrorCode)
 663 {
 664     UDataMemory tData;
 665     const char *pathBuffer;
 666     const char *inBasename;
 667 
 668     if (U_FAILURE(*pErrorCode)) {
 669         return NULL;
 670     }
 671 
 672     UDataMemory_init(&amp;tData);
 673 
 674     /* ??????? TODO revisit this */
 675     if (commonDataIndex &gt;= 0) {
 676         /* &quot;mini-cache&quot; for common ICU data */
 677         if(commonDataIndex &gt;= UPRV_LENGTHOF(gCommonICUDataArray)) {
 678             return NULL;
 679         }
 680         {
 681             Mutex lock;
 682             if(gCommonICUDataArray[commonDataIndex] != NULL) {
 683                 return gCommonICUDataArray[commonDataIndex];
 684             }
 685 #if U_PLATFORM_HAS_WINUWP_API == 0 // Windows UWP Platform does not support dll icu data at this time
 686             int32_t i;
 687             for(i = 0; i &lt; commonDataIndex; ++i) {
 688                 if(gCommonICUDataArray[i]-&gt;pHeader == &amp;U_ICUDATA_ENTRY_POINT) {
 689                     /* The linked-in data is already in the list. */
 690                     return NULL;
 691                 }
 692             }
 693 #endif
 694         }
 695 
 696         /* Add the linked-in data to the list. */
 697         /*
 698          * This is where we would check and call weakly linked partial-data-library
 699          * access functions.
 700          */
 701         /*
 702         if (uprv_getICUData_collation) {
 703             setCommonICUDataPointer(uprv_getICUData_collation(), FALSE, pErrorCode);
 704         }
 705         if (uprv_getICUData_conversion) {
 706             setCommonICUDataPointer(uprv_getICUData_conversion(), FALSE, pErrorCode);
 707         }
 708         */
 709 #if U_PLATFORM_HAS_WINUWP_API == 0 // Windows UWP Platform does not support dll icu data at this time
 710         setCommonICUDataPointer(&amp;U_ICUDATA_ENTRY_POINT, FALSE, pErrorCode);
 711         {
 712             Mutex lock;
 713             return gCommonICUDataArray[commonDataIndex];
 714         }
 715 #endif
 716     }
 717 
 718 
 719     /* request is NOT for ICU Data.  */
 720 
 721     /* Find the base name portion of the supplied path.   */
 722     /*   inBasename will be left pointing somewhere within the original path string.      */
 723     inBasename = findBasename(path);
 724 #ifdef UDATA_DEBUG
 725     fprintf(stderr, &quot;inBasename = %s\n&quot;, inBasename);
 726 #endif
 727 
 728     if(*inBasename==0) {
 729         /* no basename.     This will happen if the original path was a directory name,   */
 730         /*    like  &quot;a/b/c/&quot;.   (Fallback to separate files will still work.)             */
 731 #ifdef UDATA_DEBUG
 732         fprintf(stderr, &quot;ocd: no basename in %s, bailing.\n&quot;, path);
 733 #endif
 734         if (U_SUCCESS(*pErrorCode)) {
 735             *pErrorCode=U_FILE_ACCESS_ERROR;
 736         }
 737         return NULL;
 738     }
 739 
 740    /* Is the requested common data file already open and cached?                     */
 741    /*   Note that the cache is keyed by the base name only.  The rest of the path,   */
 742    /*     if any, is not considered.                                                 */
 743     UDataMemory  *dataToReturn = udata_findCachedData(inBasename, *pErrorCode);
 744     if (dataToReturn != NULL || U_FAILURE(*pErrorCode)) {
 745         return dataToReturn;
 746     }
 747 
 748     /* Requested item is not in the cache.
 749      * Hunt it down, trying all the path locations
 750      */
 751 
 752     UDataPathIterator iter(u_getDataDirectory(), inBasename, path, &quot;.dat&quot;, TRUE, pErrorCode);
 753 
<a name="6" id="anc6"></a><span class="line-modified"> 754     while((UDataMemory_isLoaded(&amp;tData)==FALSE) &amp;&amp; (pathBuffer = iter.next(pErrorCode)) != NULL)</span>
 755     {
 756 #ifdef UDATA_DEBUG
 757         fprintf(stderr, &quot;ocd: trying path %s - &quot;, pathBuffer);
 758 #endif
<a name="7" id="anc7"></a><span class="line-modified"> 759         uprv_mapFile(&amp;tData, pathBuffer);</span>
 760 #ifdef UDATA_DEBUG
 761         fprintf(stderr, &quot;%s\n&quot;, UDataMemory_isLoaded(&amp;tData)?&quot;LOADED&quot;:&quot;not loaded&quot;);
 762 #endif
 763     }
<a name="8" id="anc8"></a>


 764 
 765 #if defined(OS390_STUBDATA) &amp;&amp; defined(OS390BATCH)
 766     if (!UDataMemory_isLoaded(&amp;tData)) {
 767         char ourPathBuffer[1024];
 768         /* One more chance, for extendCommonData() */
 769         uprv_strncpy(ourPathBuffer, path, 1019);
 770         ourPathBuffer[1019]=0;
 771         uprv_strcat(ourPathBuffer, &quot;.dat&quot;);
<a name="9" id="anc9"></a><span class="line-modified"> 772         uprv_mapFile(&amp;tData, ourPathBuffer);</span>
 773     }
 774 #endif
 775 
 776     if (U_FAILURE(*pErrorCode)) {
 777         return NULL;
 778     }
 779     if (!UDataMemory_isLoaded(&amp;tData)) {
 780         /* no common data */
 781         *pErrorCode=U_FILE_ACCESS_ERROR;
 782         return NULL;
 783     }
 784 
 785     /* we have mapped a file, check its header */
 786     udata_checkCommonData(&amp;tData, pErrorCode);
 787 
 788 
 789     /* Cache the UDataMemory struct for this .dat file,
 790      *   so we won&#39;t need to hunt it down and map it again next time
 791      *   something is needed from it.                */
 792     return udata_cacheDataItem(inBasename, &amp;tData, pErrorCode);
 793 }
 794 
 795 
 796 /*----------------------------------------------------------------------*
 797  *                                                                      *
 798  *   extendICUData   If the full set of ICU data was not loaded at      *
 799  *                   program startup, load it now.  This function will  *
 800  *                   be called when the lookup of an ICU data item in   *
 801  *                   the common ICU data fails.                         *
 802  *                                                                      *
 803  *                   return true if new data is loaded, false otherwise.*
 804  *                                                                      *
 805  *----------------------------------------------------------------------*/
 806 static UBool extendICUData(UErrorCode *pErr)
 807 {
 808     UDataMemory   *pData;
 809     UDataMemory   copyPData;
 810     UBool         didUpdate = FALSE;
 811 
 812     /*
 813      * There is a chance for a race condition here.
 814      * Normally, ICU data is loaded from a DLL or via mmap() and
 815      * setCommonICUData() will detect if the same address is set twice.
 816      * If ICU is built with data loading via fread() then the address will
 817      * be different each time the common data is loaded and we may add
 818      * multiple copies of the data.
 819      * In this case, use a mutex to prevent the race.
 820      * Use a specific mutex to avoid nested locks of the global mutex.
 821      */
 822 #if MAP_IMPLEMENTATION==MAP_STDIO
 823     static UMutex extendICUDataMutex = U_MUTEX_INITIALIZER;
 824     umtx_lock(&amp;extendICUDataMutex);
 825 #endif
 826     if(!umtx_loadAcquire(gHaveTriedToLoadCommonData)) {
 827         /* See if we can explicitly open a .dat file for the ICUData. */
 828         pData = openCommonData(
 829                    U_ICUDATA_NAME,            /*  &quot;icudt20l&quot; , for example.          */
 830                    -1,                        /*  Pretend we&#39;re not opening ICUData  */
 831                    pErr);
 832 
 833         /* How about if there is no pData, eh... */
 834 
 835        UDataMemory_init(&amp;copyPData);
 836        if(pData != NULL) {
 837           UDatamemory_assign(&amp;copyPData, pData);
 838           copyPData.map = 0;              /* The mapping for this data is owned by the hash table */
 839           copyPData.mapAddr = 0;          /*   which will unmap it when ICU is shut down.         */
 840                                           /* CommonICUData is also unmapped when ICU is shut down.*/
 841                                           /* To avoid unmapping the data twice, zero out the map  */
 842                                           /*   fields in the UDataMemory that we&#39;re assigning     */
 843                                           /*   to CommonICUData.                                  */
 844 
 845           didUpdate = /* no longer using this result */
 846               setCommonICUData(&amp;copyPData,/*  The new common data.                                */
 847                        FALSE,             /*  No warnings if write didn&#39;t happen                  */
 848                        pErr);             /*  setCommonICUData honors errors; NOP if error set    */
 849         }
 850 
 851         umtx_storeRelease(gHaveTriedToLoadCommonData, 1);
 852     }
 853 
 854     didUpdate = findCommonICUDataByName(U_ICUDATA_NAME, *pErr);  /* Return &#39;true&#39; when a racing writes out the extended                 */
 855                                                           /* data after another thread has failed to see it (in openCommonData), so     */
 856                                                           /* extended data can be examined.                                             */
 857                                                           /* Also handles a race through here before gHaveTriedToLoadCommonData is set. */
 858 
 859 #if MAP_IMPLEMENTATION==MAP_STDIO
 860     umtx_unlock(&amp;extendICUDataMutex);
 861 #endif
 862     return didUpdate;               /* Return true if ICUData pointer was updated.   */
<a name="10" id="anc10"></a><span class="line-modified"> 863                                     /*   (Could potentialy have been done by another thread racing */</span>
 864                                     /*   us through here, but that&#39;s fine, we still return true    */
 865                                     /*   so that current thread will also examine extended data.   */
 866 }
 867 
 868 /*----------------------------------------------------------------------*
 869  *                                                                      *
 870  *   udata_setCommonData                                                *
 871  *                                                                      *
 872  *----------------------------------------------------------------------*/
 873 U_CAPI void U_EXPORT2
 874 udata_setCommonData(const void *data, UErrorCode *pErrorCode) {
 875     UDataMemory dataMemory;
 876 
 877     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
 878         return;
 879     }
 880 
 881     if(data==NULL) {
 882         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
 883         return;
 884     }
 885 
 886     /* set the data pointer and test for validity */
 887     UDataMemory_init(&amp;dataMemory);
 888     UDataMemory_setData(&amp;dataMemory, data);
 889     udata_checkCommonData(&amp;dataMemory, pErrorCode);
 890     if (U_FAILURE(*pErrorCode)) {return;}
 891 
 892     /* we have good data */
 893     /* Set it up as the ICU Common Data.  */
 894     setCommonICUData(&amp;dataMemory, TRUE, pErrorCode);
 895 }
 896 
 897 /*---------------------------------------------------------------------------
 898  *
 899  *  udata_setAppData
 900  *
 901  *---------------------------------------------------------------------------- */
 902 U_CAPI void U_EXPORT2
 903 udata_setAppData(const char *path, const void *data, UErrorCode *err)
 904 {
 905     UDataMemory     udm;
 906 
 907     if(err==NULL || U_FAILURE(*err)) {
 908         return;
 909     }
 910     if(data==NULL) {
 911         *err=U_ILLEGAL_ARGUMENT_ERROR;
 912         return;
 913     }
 914 
 915     UDataMemory_init(&amp;udm);
 916     UDataMemory_setData(&amp;udm, data);
 917     udata_checkCommonData(&amp;udm, err);
 918     udata_cacheDataItem(path, &amp;udm, err);
 919 }
 920 
 921 /*----------------------------------------------------------------------------*
 922  *                                                                            *
 923  *  checkDataItem     Given a freshly located/loaded data item, either        *
 924  *                    an entry in a common file or a separately loaded file,  *
 925  *                    sanity check its header, and see if the data is         *
 926  *                    acceptable to the app.                                  *
 927  *                    If the data is good, create and return a UDataMemory    *
 928  *                    object that can be returned to the application.         *
 929  *                    Return NULL on any sort of failure.                     *
 930  *                                                                            *
 931  *----------------------------------------------------------------------------*/
 932 static UDataMemory *
 933 checkDataItem
 934 (
 935  const DataHeader         *pHeader,         /* The data item to be checked.                */
 936  UDataMemoryIsAcceptable  *isAcceptable,    /* App&#39;s call-back function                    */
 937  void                     *context,         /*   pass-thru param for above.                */
 938  const char               *type,            /*   pass-thru param for above.                */
 939  const char               *name,            /*   pass-thru param for above.                */
 940  UErrorCode               *nonFatalErr,     /* Error code if this data was not acceptable  */
 941                                             /*   but openChoice should continue with       */
 942                                             /*   trying to get data from fallback path.    */
 943  UErrorCode               *fatalErr         /* Bad error, caller should return immediately */
 944  )
 945 {
 946     UDataMemory  *rDataMem = NULL;          /* the new UDataMemory, to be returned.        */
 947 
 948     if (U_FAILURE(*fatalErr)) {
 949         return NULL;
 950     }
 951 
 952     if(pHeader-&gt;dataHeader.magic1==0xda &amp;&amp;
 953         pHeader-&gt;dataHeader.magic2==0x27 &amp;&amp;
 954         (isAcceptable==NULL || isAcceptable(context, type, name, &amp;pHeader-&gt;info))
 955     ) {
 956         rDataMem=UDataMemory_createNewInstance(fatalErr);
 957         if (U_FAILURE(*fatalErr)) {
 958             return NULL;
 959         }
 960         rDataMem-&gt;pHeader = pHeader;
 961     } else {
 962         /* the data is not acceptable, look further */
 963         /* If we eventually find something good, this errorcode will be */
 964         /*    cleared out.                                              */
 965         *nonFatalErr=U_INVALID_FORMAT_ERROR;
 966     }
 967     return rDataMem;
 968 }
 969 
 970 /**
 971  * @return 0 if not loaded, 1 if loaded or err
 972  */
 973 static UDataMemory *doLoadFromIndividualFiles(const char *pkgName,
 974         const char *dataPath, const char *tocEntryPathSuffix,
 975             /* following arguments are the same as doOpenChoice itself */
 976             const char *path, const char *type, const char *name,
 977              UDataMemoryIsAcceptable *isAcceptable, void *context,
 978              UErrorCode *subErrorCode,
 979              UErrorCode *pErrorCode)
 980 {
 981     const char         *pathBuffer;
 982     UDataMemory         dataMemory;
 983     UDataMemory *pEntryData;
 984 
 985     /* look in ind. files: package\nam.typ  ========================= */
 986     /* init path iterator for individual files */
 987     UDataPathIterator iter(dataPath, pkgName, path, tocEntryPathSuffix, FALSE, pErrorCode);
 988 
<a name="11" id="anc11"></a><span class="line-modified"> 989     while((pathBuffer = iter.next(pErrorCode)) != NULL)</span>
 990     {
 991 #ifdef UDATA_DEBUG
 992         fprintf(stderr, &quot;UDATA: trying individual file %s\n&quot;, pathBuffer);
 993 #endif
<a name="12" id="anc12"></a><span class="line-modified"> 994         if(uprv_mapFile(&amp;dataMemory, pathBuffer))</span>
 995         {
 996             pEntryData = checkDataItem(dataMemory.pHeader, isAcceptable, context, type, name, subErrorCode, pErrorCode);
 997             if (pEntryData != NULL) {
 998                 /* Data is good.
 999                 *  Hand off ownership of the backing memory to the user&#39;s UDataMemory.
1000                 *  and return it.   */
1001                 pEntryData-&gt;mapAddr = dataMemory.mapAddr;
1002                 pEntryData-&gt;map     = dataMemory.map;
1003 
1004 #ifdef UDATA_DEBUG
1005                 fprintf(stderr, &quot;** Mapped file: %s\n&quot;, pathBuffer);
1006 #endif
1007                 return pEntryData;
1008             }
1009 
<a name="13" id="anc13"></a><span class="line-modified">1010             /* the data is not acceptable, or some error occured.  Either way, unmap the memory */</span>
1011             udata_close(&amp;dataMemory);
1012 
1013             /* If we had a nasty error, bail out completely.  */
1014             if (U_FAILURE(*pErrorCode)) {
1015                 return NULL;
1016             }
1017 
1018             /* Otherwise remember that we found data but didn&#39;t like it for some reason  */
1019             *subErrorCode=U_INVALID_FORMAT_ERROR;
1020         }
1021 #ifdef UDATA_DEBUG
1022         fprintf(stderr, &quot;%s\n&quot;, UDataMemory_isLoaded(&amp;dataMemory)?&quot;LOADED&quot;:&quot;not loaded&quot;);
1023 #endif
1024     }
1025     return NULL;
1026 }
1027 
1028 /**
1029  * @return 0 if not loaded, 1 if loaded or err
1030  */
1031 static UDataMemory *doLoadFromCommonData(UBool isICUData, const char * /*pkgName*/,
1032         const char * /*dataPath*/, const char * /*tocEntryPathSuffix*/, const char *tocEntryName,
1033             /* following arguments are the same as doOpenChoice itself */
1034             const char *path, const char *type, const char *name,
1035              UDataMemoryIsAcceptable *isAcceptable, void *context,
1036              UErrorCode *subErrorCode,
1037              UErrorCode *pErrorCode)
1038 {
1039     UDataMemory        *pEntryData;
1040     const DataHeader   *pHeader;
1041     UDataMemory        *pCommonData;
1042     int32_t            commonDataIndex;
1043     UBool              checkedExtendedICUData = FALSE;
1044     /* try to get common data.  The loop is for platforms such as the 390 that do
1045      *  not initially load the full set of ICU data.  If the lookup of an ICU data item
1046      *  fails, the full (but slower to load) set is loaded, the and the loop repeats,
1047      *  trying the lookup again.  Once the full set of ICU data is loaded, the loop wont
1048      *  repeat because the full set will be checked the first time through.
1049      *
1050      *  The loop also handles the fallback to a .dat file if the application linked
1051      *   to the stub data library rather than a real library.
1052      */
1053     for (commonDataIndex = isICUData ? 0 : -1;;) {
1054         pCommonData=openCommonData(path, commonDataIndex, subErrorCode); /** search for pkg **/
1055 
1056         if(U_SUCCESS(*subErrorCode) &amp;&amp; pCommonData!=NULL) {
1057             int32_t length;
1058 
1059             /* look up the data piece in the common data */
1060             pHeader=pCommonData-&gt;vFuncs-&gt;Lookup(pCommonData, tocEntryName, &amp;length, subErrorCode);
1061 #ifdef UDATA_DEBUG
1062             fprintf(stderr, &quot;%s: pHeader=%p - %s\n&quot;, tocEntryName, pHeader, u_errorName(*subErrorCode));
1063 #endif
1064 
1065             if(pHeader!=NULL) {
1066                 pEntryData = checkDataItem(pHeader, isAcceptable, context, type, name, subErrorCode, pErrorCode);
1067 #ifdef UDATA_DEBUG
1068                 fprintf(stderr, &quot;pEntryData=%p\n&quot;, pEntryData);
1069 #endif
1070                 if (U_FAILURE(*pErrorCode)) {
1071                     return NULL;
1072                 }
1073                 if (pEntryData != NULL) {
1074                     pEntryData-&gt;length = length;
1075                     return pEntryData;
1076                 }
1077             }
1078         }
<a name="14" id="anc14"></a>




1079         /* Data wasn&#39;t found.  If we were looking for an ICUData item and there is
1080          * more data available, load it and try again,
1081          * otherwise break out of this loop. */
1082         if (!isICUData) {
1083             return NULL;
1084         } else if (pCommonData != NULL) {
1085             ++commonDataIndex;  /* try the next data package */
1086         } else if ((!checkedExtendedICUData) &amp;&amp; extendICUData(subErrorCode)) {
1087             checkedExtendedICUData = TRUE;
1088             /* try this data package slot again: it changed from NULL to non-NULL */
1089         } else {
1090             return NULL;
1091         }
1092     }
1093 }
1094 
1095 /*
1096  * Identify the Time Zone resources that are subject to special override data loading.
1097  */
1098 static UBool isTimeZoneFile(const char *name, const char *type) {
1099     return ((uprv_strcmp(type, &quot;res&quot;) == 0) &amp;&amp;
1100             (uprv_strcmp(name, &quot;zoneinfo64&quot;) == 0 ||
1101              uprv_strcmp(name, &quot;timezoneTypes&quot;) == 0 ||
1102              uprv_strcmp(name, &quot;windowsZones&quot;) == 0 ||
1103              uprv_strcmp(name, &quot;metaZones&quot;) == 0));
1104 }
1105 
1106 /*
1107  *  A note on the ownership of Mapped Memory
1108  *
1109  *  For common format files, ownership resides with the UDataMemory object
1110  *    that lives in the cache of opened common data.  These UDataMemorys are private
1111  *    to the udata implementation, and are never seen directly by users.
1112  *
1113  *    The UDataMemory objects returned to users will have the address of some desired
1114  *    data within the mapped region, but they wont have the mapping info itself, and thus
1115  *    won&#39;t cause anything to be removed from memory when they are closed.
1116  *
1117  *  For individual data files, the UDataMemory returned to the user holds the
1118  *  information necessary to unmap the data on close.  If the user independently
1119  *  opens the same data file twice, two completely independent mappings will be made.
1120  *  (There is no cache of opened data items from individual files, only a cache of
1121  *   opened Common Data files, that is, files containing a collection of data items.)
1122  *
1123  *  For common data passed in from the user via udata_setAppData() or
1124  *  udata_setCommonData(), ownership remains with the user.
1125  *
1126  *  UDataMemory objects themselves, as opposed to the memory they describe,
1127  *  can be anywhere - heap, stack/local or global.
1128  *  They have a flag to indicate when they&#39;re heap allocated and thus
1129  *  must be deleted when closed.
1130  */
1131 
1132 
1133 /*----------------------------------------------------------------------------*
1134  *                                                                            *
1135  * main data loading functions                                                *
1136  *                                                                            *
1137  *----------------------------------------------------------------------------*/
1138 static UDataMemory *
1139 doOpenChoice(const char *path, const char *type, const char *name,
1140              UDataMemoryIsAcceptable *isAcceptable, void *context,
1141              UErrorCode *pErrorCode)
1142 {
1143     UDataMemory         *retVal = NULL;
1144 
1145     const char         *dataPath;
1146 
1147     int32_t             tocEntrySuffixIndex;
1148     const char         *tocEntryPathSuffix;
1149     UErrorCode          subErrorCode=U_ZERO_ERROR;
1150     const char         *treeChar;
1151 
1152     UBool               isICUData = FALSE;
1153 
1154 
1155     /* Is this path ICU data? */
1156     if(path == NULL ||
1157        !strcmp(path, U_ICUDATA_ALIAS) ||  /* &quot;ICUDATA&quot; */
1158        !uprv_strncmp(path, U_ICUDATA_NAME U_TREE_SEPARATOR_STRING, /* &quot;icudt26e-&quot; */
1159                      uprv_strlen(U_ICUDATA_NAME U_TREE_SEPARATOR_STRING)) ||
1160        !uprv_strncmp(path, U_ICUDATA_ALIAS U_TREE_SEPARATOR_STRING, /* &quot;ICUDATA-&quot; */
1161                      uprv_strlen(U_ICUDATA_ALIAS U_TREE_SEPARATOR_STRING))) {
1162       isICUData = TRUE;
1163     }
1164 
1165 #if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)  /* Windows:  try &quot;foo\bar&quot; and &quot;foo/bar&quot; */
1166     /* remap from alternate path char to the main one */
1167     CharString altSepPath;
1168     if(path) {
1169         if(uprv_strchr(path,U_FILE_ALT_SEP_CHAR) != NULL) {
1170             altSepPath.append(path, *pErrorCode);
1171             char *p;
1172             while ((p = uprv_strchr(altSepPath.data(), U_FILE_ALT_SEP_CHAR)) != NULL) {
1173                 *p = U_FILE_SEP_CHAR;
1174             }
1175 #if defined (UDATA_DEBUG)
1176             fprintf(stderr, &quot;Changed path from [%s] to [%s]\n&quot;, path, altSepPath.s);
1177 #endif
1178             path = altSepPath.data();
1179         }
1180     }
1181 #endif
1182 
1183     CharString tocEntryName; /* entry name in tree format. ex:  &#39;icudt28b/coll/ar.res&#39; */
1184     CharString tocEntryPath; /* entry name in path format. ex:  &#39;icudt28b\\coll\\ar.res&#39; */
1185 
1186     CharString pkgName;
1187     CharString treeName;
1188 
1189     /* ======= Set up strings */
1190     if(path==NULL) {
1191         pkgName.append(U_ICUDATA_NAME, *pErrorCode);
1192     } else {
1193         const char *pkg;
1194         const char *first;
1195         pkg = uprv_strrchr(path, U_FILE_SEP_CHAR);
1196         first = uprv_strchr(path, U_FILE_SEP_CHAR);
1197         if(uprv_pathIsAbsolute(path) || (pkg != first)) { /* more than one slash in the path- not a tree name */
1198             /* see if this is an /absolute/path/to/package  path */
1199             if(pkg) {
1200                 pkgName.append(pkg+1, *pErrorCode);
1201             } else {
1202                 pkgName.append(path, *pErrorCode);
1203             }
1204         } else {
1205             treeChar = uprv_strchr(path, U_TREE_SEPARATOR);
1206             if(treeChar) {
1207                 treeName.append(treeChar+1, *pErrorCode); /* following &#39;-&#39; */
1208                 if(isICUData) {
1209                     pkgName.append(U_ICUDATA_NAME, *pErrorCode);
1210                 } else {
1211                     pkgName.append(path, (int32_t)(treeChar-path), *pErrorCode);
1212                     if (first == NULL) {
1213                         /*
1214                         This user data has no path, but there is a tree name.
1215                         Look up the correct path from the data cache later.
1216                         */
1217                         path = pkgName.data();
1218                     }
1219                 }
1220             } else {
1221                 if(isICUData) {
1222                     pkgName.append(U_ICUDATA_NAME, *pErrorCode);
1223                 } else {
1224                     pkgName.append(path, *pErrorCode);
1225                 }
1226             }
1227         }
1228     }
1229 
1230 #ifdef UDATA_DEBUG
1231     fprintf(stderr, &quot; P=%s T=%s\n&quot;, pkgName.data(), treeName.data());
1232 #endif
1233 
1234     /* setting up the entry name and file name
1235      * Make up a full name by appending the type to the supplied
1236      *  name, assuming that a type was supplied.
1237      */
1238 
1239     /* prepend the package */
1240     tocEntryName.append(pkgName, *pErrorCode);
1241     tocEntryPath.append(pkgName, *pErrorCode);
1242     tocEntrySuffixIndex = tocEntryName.length();
1243 
1244     if(!treeName.isEmpty()) {
1245         tocEntryName.append(U_TREE_ENTRY_SEP_CHAR, *pErrorCode).append(treeName, *pErrorCode);
1246         tocEntryPath.append(U_FILE_SEP_CHAR, *pErrorCode).append(treeName, *pErrorCode);
1247     }
1248 
1249     tocEntryName.append(U_TREE_ENTRY_SEP_CHAR, *pErrorCode).append(name, *pErrorCode);
1250     tocEntryPath.append(U_FILE_SEP_CHAR, *pErrorCode).append(name, *pErrorCode);
1251     if(type!=NULL &amp;&amp; *type!=0) {
1252         tocEntryName.append(&quot;.&quot;, *pErrorCode).append(type, *pErrorCode);
1253         tocEntryPath.append(&quot;.&quot;, *pErrorCode).append(type, *pErrorCode);
1254     }
<a name="15" id="anc15"></a><span class="line-modified">1255     tocEntryPathSuffix = tocEntryPath.data()+tocEntrySuffixIndex; /* suffix starts here */</span>

1256 
1257 #ifdef UDATA_DEBUG
1258     fprintf(stderr, &quot; tocEntryName = %s\n&quot;, tocEntryName.data());
1259     fprintf(stderr, &quot; tocEntryPath = %s\n&quot;, tocEntryName.data());
1260 #endif
1261 
1262 #if U_PLATFORM_HAS_WINUWP_API == 0 // Windows UWP Platform does not support dll icu data at this time
1263     if(path == NULL) {
1264         path = COMMON_DATA_NAME; /* &quot;icudt26e&quot; */
1265     }
1266 #else
1267     // Windows UWP expects only a single data file.
1268     path = COMMON_DATA_NAME; /* &quot;icudt26e&quot; */
1269 #endif
1270 
1271     /************************ Begin loop looking for ind. files ***************/
1272 #ifdef UDATA_DEBUG
1273     fprintf(stderr, &quot;IND: inBasename = %s, pkg=%s\n&quot;, &quot;(n/a)&quot;, packageNameFromPath(path));
1274 #endif
1275 
1276     /* End of dealing with a null basename */
1277     dataPath = u_getDataDirectory();
1278 
1279     /****    Time zone individual files override  */
1280     if (isICUData &amp;&amp; isTimeZoneFile(name, type)) {
1281         const char *tzFilesDir = u_getTimeZoneFilesDirectory(pErrorCode);
1282         if (tzFilesDir[0] != 0) {
1283 #ifdef UDATA_DEBUG
1284             fprintf(stderr, &quot;Trying Time Zone Files directory = %s\n&quot;, tzFilesDir);
1285 #endif
1286             retVal = doLoadFromIndividualFiles(/* pkgName.data() */ &quot;&quot;, tzFilesDir, tocEntryPathSuffix,
1287                             /* path */ &quot;&quot;, type, name, isAcceptable, context, &amp;subErrorCode, pErrorCode);
1288             if((retVal != NULL) || U_FAILURE(*pErrorCode)) {
1289                 return retVal;
1290             }
1291         }
1292     }
1293 
1294     /****    COMMON PACKAGE  - only if packages are first. */
1295     if(gDataFileAccess == UDATA_PACKAGES_FIRST) {
1296 #ifdef UDATA_DEBUG
1297         fprintf(stderr, &quot;Trying packages (UDATA_PACKAGES_FIRST)\n&quot;);
1298 #endif
1299         /* #2 */
1300         retVal = doLoadFromCommonData(isICUData,
1301                             pkgName.data(), dataPath, tocEntryPathSuffix, tocEntryName.data(),
1302                             path, type, name, isAcceptable, context, &amp;subErrorCode, pErrorCode);
1303         if((retVal != NULL) || U_FAILURE(*pErrorCode)) {
1304             return retVal;
1305         }
1306     }
1307 
1308     /****    INDIVIDUAL FILES  */
1309     if((gDataFileAccess==UDATA_PACKAGES_FIRST) ||
1310        (gDataFileAccess==UDATA_FILES_FIRST)) {
1311 #ifdef UDATA_DEBUG
1312         fprintf(stderr, &quot;Trying individual files\n&quot;);
1313 #endif
1314         /* Check to make sure that there is a dataPath to iterate over */
1315         if ((dataPath &amp;&amp; *dataPath) || !isICUData) {
1316             retVal = doLoadFromIndividualFiles(pkgName.data(), dataPath, tocEntryPathSuffix,
1317                             path, type, name, isAcceptable, context, &amp;subErrorCode, pErrorCode);
1318             if((retVal != NULL) || U_FAILURE(*pErrorCode)) {
1319                 return retVal;
1320             }
1321         }
1322     }
1323 
1324     /****    COMMON PACKAGE  */
1325     if((gDataFileAccess==UDATA_ONLY_PACKAGES) ||
1326        (gDataFileAccess==UDATA_FILES_FIRST)) {
1327 #ifdef UDATA_DEBUG
1328         fprintf(stderr, &quot;Trying packages (UDATA_ONLY_PACKAGES || UDATA_FILES_FIRST)\n&quot;);
1329 #endif
1330         retVal = doLoadFromCommonData(isICUData,
1331                             pkgName.data(), dataPath, tocEntryPathSuffix, tocEntryName.data(),
1332                             path, type, name, isAcceptable, context, &amp;subErrorCode, pErrorCode);
1333         if((retVal != NULL) || U_FAILURE(*pErrorCode)) {
1334             return retVal;
1335         }
1336     }
1337 
1338     /* Load from DLL.  If we haven&#39;t attempted package load, we also haven&#39;t had any chance to
1339         try a DLL (static or setCommonData/etc)  load.
1340          If we ever have a &quot;UDATA_ONLY_FILES&quot;, add it to the or list here.  */
1341     if(gDataFileAccess==UDATA_NO_FILES) {
1342 #ifdef UDATA_DEBUG
1343         fprintf(stderr, &quot;Trying common data (UDATA_NO_FILES)\n&quot;);
1344 #endif
1345         retVal = doLoadFromCommonData(isICUData,
1346                             pkgName.data(), &quot;&quot;, tocEntryPathSuffix, tocEntryName.data(),
1347                             path, type, name, isAcceptable, context, &amp;subErrorCode, pErrorCode);
1348         if((retVal != NULL) || U_FAILURE(*pErrorCode)) {
1349             return retVal;
1350         }
1351     }
1352 
1353     /* data not found */
1354     if(U_SUCCESS(*pErrorCode)) {
1355         if(U_SUCCESS(subErrorCode)) {
1356             /* file not found */
1357             *pErrorCode=U_FILE_ACCESS_ERROR;
1358         } else {
1359             /* entry point not found or rejected */
1360             *pErrorCode=subErrorCode;
1361         }
1362     }
1363     return retVal;
1364 }
1365 
1366 
1367 
1368 /* API ---------------------------------------------------------------------- */
1369 
1370 U_CAPI UDataMemory * U_EXPORT2
1371 udata_open(const char *path, const char *type, const char *name,
1372            UErrorCode *pErrorCode) {
1373 #ifdef UDATA_DEBUG
1374   fprintf(stderr, &quot;udata_open(): Opening: %s : %s . %s\n&quot;, (path?path:&quot;NULL&quot;), name, type);
1375     fflush(stderr);
1376 #endif
1377 
1378     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
1379         return NULL;
1380     } else if(name==NULL || *name==0) {
1381         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
1382         return NULL;
1383     } else {
1384         return doOpenChoice(path, type, name, NULL, NULL, pErrorCode);
1385     }
1386 }
1387 
1388 
1389 
1390 U_CAPI UDataMemory * U_EXPORT2
1391 udata_openChoice(const char *path, const char *type, const char *name,
1392                  UDataMemoryIsAcceptable *isAcceptable, void *context,
1393                  UErrorCode *pErrorCode) {
1394 #ifdef UDATA_DEBUG
1395   fprintf(stderr, &quot;udata_openChoice(): Opening: %s : %s . %s\n&quot;, (path?path:&quot;NULL&quot;), name, type);
1396 #endif
1397 
1398     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
1399         return NULL;
1400     } else if(name==NULL || *name==0 || isAcceptable==NULL) {
1401         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
1402         return NULL;
1403     } else {
1404         return doOpenChoice(path, type, name, isAcceptable, context, pErrorCode);
1405     }
1406 }
1407 
1408 
1409 
1410 U_CAPI void U_EXPORT2
1411 udata_getInfo(UDataMemory *pData, UDataInfo *pInfo) {
1412     if(pInfo!=NULL) {
1413         if(pData!=NULL &amp;&amp; pData-&gt;pHeader!=NULL) {
1414             const UDataInfo *info=&amp;pData-&gt;pHeader-&gt;info;
1415             uint16_t dataInfoSize=udata_getInfoSize(info);
1416             if(pInfo-&gt;size&gt;dataInfoSize) {
1417                 pInfo-&gt;size=dataInfoSize;
1418             }
1419             uprv_memcpy((uint16_t *)pInfo+1, (const uint16_t *)info+1, pInfo-&gt;size-2);
1420             if(info-&gt;isBigEndian!=U_IS_BIG_ENDIAN) {
1421                 /* opposite endianness */
1422                 uint16_t x=info-&gt;reservedWord;
1423                 pInfo-&gt;reservedWord=(uint16_t)((x&lt;&lt;8)|(x&gt;&gt;8));
1424             }
1425         } else {
1426             pInfo-&gt;size=0;
1427         }
1428     }
1429 }
1430 
1431 
1432 U_CAPI void U_EXPORT2 udata_setFileAccess(UDataFileAccess access, UErrorCode * /*status*/)
1433 {
1434     // Note: this function is documented as not thread safe.
1435     gDataFileAccess = access;
1436 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>