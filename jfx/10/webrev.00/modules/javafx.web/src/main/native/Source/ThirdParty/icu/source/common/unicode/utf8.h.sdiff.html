<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/utf8.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="utf16.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="utypes.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/utf8.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
592  * If the offset points to a UTF-8 trail byte,
593  * then the offset is moved backward to the corresponding lead byte.
594  * Otherwise, it is not modified.
595  *
596  * &quot;Safe&quot; macro, checks for illegal sequences and for string boundaries.
597  * Unlike U8_TRUNCATE_IF_INCOMPLETE(), this macro always reads s[i].
598  *
599  * @param s const uint8_t * string
600  * @param start int32_t starting string offset (usually 0)
601  * @param i int32_t string offset, must be start&lt;=i
602  * @see U8_SET_CP_START_UNSAFE
603  * @see U8_TRUNCATE_IF_INCOMPLETE
604  * @stable ICU 2.4
605  */
606 #define U8_SET_CP_START(s, start, i) { \
607     if(U8_IS_TRAIL((s)[(i)])) { \
608         (i)=utf8_back1SafeBody(s, start, (i)); \
609     } \
610 }
611 
<span class="line-removed">612 #ifndef U_HIDE_DRAFT_API</span>
613 /**
614  * If the string ends with a UTF-8 byte sequence that is valid so far
615  * but incomplete, then reduce the length of the string to end before
616  * the lead byte of that incomplete sequence.
617  * For example, if the string ends with E1 80, the length is reduced by 2.
618  *
619  * In all other cases (the string ends with a complete sequence, or it is not
620  * possible for any further trail byte to extend the trailing sequence)
621  * the length remains unchanged.
622  *
623  * Useful for processing text split across multiple buffers
624  * (save the incomplete sequence for later)
625  * and for optimizing iteration
626  * (check for string length only once per character).
627  *
628  * &quot;Safe&quot; macro, checks for illegal sequences and for string boundaries.
629  * Unlike U8_SET_CP_START(), this macro never reads s[length].
630  *
631  * (In UTF-16, simply check for U16_IS_LEAD(last code unit).)
632  *
633  * @param s const uint8_t * string
634  * @param start int32_t starting string offset (usually 0)
635  * @param length int32_t string length (usually start&lt;=length)
636  * @see U8_SET_CP_START
<span class="line-modified">637  * @draft ICU 61</span>
638  */
639 #define U8_TRUNCATE_IF_INCOMPLETE(s, start, length) \
640     if((length)&gt;(start)) { \
641         uint8_t __b1=s[(length)-1]; \
642         if(U8_IS_SINGLE(__b1)) { \
643             /* common ASCII character */ \
644         } else if(U8_IS_LEAD(__b1)) { \
645             --(length); \
646         } else if(U8_IS_TRAIL(__b1) &amp;&amp; ((length)-2)&gt;=(start)) { \
647             uint8_t __b2=s[(length)-2]; \
648             if(0xe0&lt;=__b2 &amp;&amp; __b2&lt;=0xf4) { \
649                 if(__b2&lt;0xf0 ? U8_IS_VALID_LEAD3_AND_T1(__b2, __b1) : \
650                         U8_IS_VALID_LEAD4_AND_T1(__b2, __b1)) { \
651                     (length)-=2; \
652                 } \
653             } else if(U8_IS_TRAIL(__b2) &amp;&amp; ((length)-3)&gt;=(start)) { \
654                 uint8_t __b3=s[(length)-3]; \
655                 if(0xf0&lt;=__b3 &amp;&amp; __b3&lt;=0xf4 &amp;&amp; U8_IS_VALID_LEAD4_AND_T1(__b3, __b2)) { \
656                     (length)-=3; \
657                 } \
<span class="line-removed">661 #endif  // U_HIDE_DRAFT_API</span>
662 
663 /* definitions with backward iteration -------------------------------------- */
664 
665 /**
666  * Move the string offset from one code point boundary to the previous one
667  * and get the code point between them.
668  * (Pre-decrementing backward iteration.)
669  * &quot;Unsafe&quot; macro, assumes well-formed UTF-8.
670  *
671  * The input offset may be the same as the string length.
672  * If the offset is behind a multi-byte sequence, then the macro will read
673  * the whole sequence.
674  * If the offset is behind a lead byte, then that itself
675  * will be returned as the code point.
676  * The result is undefined if the offset is behind an illegal UTF-8 sequence.
677  *
678  * @param s const uint8_t * string
679  * @param i string offset
680  * @param c output UChar32 variable
681  * @see U8_PREV
</pre>
</td>
<td>
<hr />
<pre>
592  * If the offset points to a UTF-8 trail byte,
593  * then the offset is moved backward to the corresponding lead byte.
594  * Otherwise, it is not modified.
595  *
596  * &quot;Safe&quot; macro, checks for illegal sequences and for string boundaries.
597  * Unlike U8_TRUNCATE_IF_INCOMPLETE(), this macro always reads s[i].
598  *
599  * @param s const uint8_t * string
600  * @param start int32_t starting string offset (usually 0)
601  * @param i int32_t string offset, must be start&lt;=i
602  * @see U8_SET_CP_START_UNSAFE
603  * @see U8_TRUNCATE_IF_INCOMPLETE
604  * @stable ICU 2.4
605  */
606 #define U8_SET_CP_START(s, start, i) { \
607     if(U8_IS_TRAIL((s)[(i)])) { \
608         (i)=utf8_back1SafeBody(s, start, (i)); \
609     } \
610 }
611 

612 /**
613  * If the string ends with a UTF-8 byte sequence that is valid so far
614  * but incomplete, then reduce the length of the string to end before
615  * the lead byte of that incomplete sequence.
616  * For example, if the string ends with E1 80, the length is reduced by 2.
617  *
618  * In all other cases (the string ends with a complete sequence, or it is not
619  * possible for any further trail byte to extend the trailing sequence)
620  * the length remains unchanged.
621  *
622  * Useful for processing text split across multiple buffers
623  * (save the incomplete sequence for later)
624  * and for optimizing iteration
625  * (check for string length only once per character).
626  *
627  * &quot;Safe&quot; macro, checks for illegal sequences and for string boundaries.
628  * Unlike U8_SET_CP_START(), this macro never reads s[length].
629  *
630  * (In UTF-16, simply check for U16_IS_LEAD(last code unit).)
631  *
632  * @param s const uint8_t * string
633  * @param start int32_t starting string offset (usually 0)
634  * @param length int32_t string length (usually start&lt;=length)
635  * @see U8_SET_CP_START
<span class="line-modified">636  * @stable ICU 61</span>
637  */
638 #define U8_TRUNCATE_IF_INCOMPLETE(s, start, length) \
639     if((length)&gt;(start)) { \
640         uint8_t __b1=s[(length)-1]; \
641         if(U8_IS_SINGLE(__b1)) { \
642             /* common ASCII character */ \
643         } else if(U8_IS_LEAD(__b1)) { \
644             --(length); \
645         } else if(U8_IS_TRAIL(__b1) &amp;&amp; ((length)-2)&gt;=(start)) { \
646             uint8_t __b2=s[(length)-2]; \
647             if(0xe0&lt;=__b2 &amp;&amp; __b2&lt;=0xf4) { \
648                 if(__b2&lt;0xf0 ? U8_IS_VALID_LEAD3_AND_T1(__b2, __b1) : \
649                         U8_IS_VALID_LEAD4_AND_T1(__b2, __b1)) { \
650                     (length)-=2; \
651                 } \
652             } else if(U8_IS_TRAIL(__b2) &amp;&amp; ((length)-3)&gt;=(start)) { \
653                 uint8_t __b3=s[(length)-3]; \
654                 if(0xf0&lt;=__b3 &amp;&amp; __b3&lt;=0xf4 &amp;&amp; U8_IS_VALID_LEAD4_AND_T1(__b3, __b2)) { \
655                     (length)-=3; \
656                 } \

660 
661 /* definitions with backward iteration -------------------------------------- */
662 
663 /**
664  * Move the string offset from one code point boundary to the previous one
665  * and get the code point between them.
666  * (Pre-decrementing backward iteration.)
667  * &quot;Unsafe&quot; macro, assumes well-formed UTF-8.
668  *
669  * The input offset may be the same as the string length.
670  * If the offset is behind a multi-byte sequence, then the macro will read
671  * the whole sequence.
672  * If the offset is behind a lead byte, then that itself
673  * will be returned as the code point.
674  * The result is undefined if the offset is behind an illegal UTF-8 sequence.
675  *
676  * @param s const uint8_t * string
677  * @param i string offset
678  * @param c output UChar32 variable
679  * @see U8_PREV
</pre>
</td>
</tr>
</table>
<center><a href="utf16.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="utypes.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>