diff a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc_tag.cpp b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc_tag.cpp
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc_tag.cpp
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc_tag.cpp
@@ -5,15 +5,19 @@
 *   Copyright (C) 2009-2015, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 **********************************************************************
 */
 
+#include "unicode/bytestream.h"
 #include "unicode/utypes.h"
 #include "unicode/ures.h"
+#include "unicode/localpointer.h"
 #include "unicode/putil.h"
+#include "unicode/uenum.h"
 #include "unicode/uloc.h"
 #include "ustr_imp.h"
+#include "charstr.h"
 #include "cmemory.h"
 #include "cstring.h"
 #include "putilimp.h"
 #include "uinvchar.h"
 #include "ulocimp.h"
@@ -25,21 +29,21 @@
     const char              *variant;
     struct VariantListEntry *next;
 } VariantListEntry;
 
 /* struct holding a single attribute value */
-typedef struct AttributeListEntry {
+struct AttributeListEntry : public icu::UMemory {
     const char              *attribute;
     struct AttributeListEntry *next;
-} AttributeListEntry;
+};
 
 /* struct holding a single extension */
-typedef struct ExtensionListEntry {
+struct ExtensionListEntry : public icu::UMemory {
     const char                  *key;
     const char                  *value;
     struct ExtensionListEntry   *next;
-} ExtensionListEntry;
+};
 
 #define MAXEXTLANG 3
 typedef struct ULanguageTag {
     char                *buf;   /* holding parsed subtags */
     const char          *language;
@@ -75,23 +79,38 @@
 static const char PRIVUSE_VARIANT_PREFIX[] = "lvariant";
 static const char LOCALE_TYPE_YES[] = "yes";
 
 #define LANG_UND_LEN 3
 
+/*
+ Updated on 2018-09-12 from
+ https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry .
+
+ This table has 2 parts. The parts for Grandfathered tags is generated by the
+ following scripts from the IANA language tag registry.
+
+ curl  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry |\
+ egrep -A 7 'Type: grandfathered' | \
+ egrep 'Tag|Prefe' | grep -B1 'Preferred' | grep -v '^--' | \
+ awk -n '/Tag/ {printf("    \"%s\", ", $2);} /Preferred/ {printf("\"%s\",\n", $2);}' |\
+ tr 'A-Z' 'a-z'
+
+
+ The 2nd part is made of five ICU-specific entries. They're kept for
+ the backward compatibility for now, even though there are no preferred
+ values. They may have to be removed for the strict BCP 47 compliance.
+
+*/
 static const char* const GRANDFATHERED[] = {
 /*  grandfathered   preferred */
     "art-lojban",   "jbo",
-    "cel-gaulish",  "xtg-x-cel-gaulish",
-    "en-GB-oed",    "en-GB-x-oed",
+    "en-gb-oed",    "en-gb-oxendict",
     "i-ami",        "ami",
     "i-bnn",        "bnn",
-    "i-default",    "en-x-i-default",
-    "i-enochian",   "und-x-i-enochian",
     "i-hak",        "hak",
     "i-klingon",    "tlh",
     "i-lux",        "lb",
-    "i-mingo",      "see-x-i-mingo",
     "i-navajo",     "nv",
     "i-pwn",        "pwn",
     "i-tao",        "tao",
     "i-tay",        "tay",
     "i-tsu",        "tsu",
@@ -100,21 +119,179 @@
     "sgn-be-fr",    "sfb",
     "sgn-be-nl",    "vgt",
     "sgn-ch-de",    "sgg",
     "zh-guoyu",     "cmn",
     "zh-hakka",     "hak",
-    "zh-min",       "nan-x-zh-min",
     "zh-min-nan",   "nan",
     "zh-xiang",     "hsn",
-    NULL,           NULL
+
+    // Grandfathered tags with no preferred value in the IANA
+    // registry. Kept for now for the backward compatibility
+    // because ICU has mapped them this way.
+    "cel-gaulish",  "xtg-x-cel-gaulish",
+    "i-default",    "en-x-i-default",
+    "i-enochian",   "und-x-i-enochian",
+    "i-mingo",      "see-x-i-mingo",
+    "zh-min",       "nan-x-zh-min",
+};
+
+/*
+ Updated on 2018-09-12 from
+ https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry .
+
+ The table lists redundant tags with preferred value in the IANA languate tag registry.
+ It's generated with the following command:
+
+ curl  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry |\
+ grep 'Type: redundant' -A 5 | egrep '^(Tag:|Prefer)' | grep -B1 'Preferred' | \
+ awk -n '/Tag/ {printf("    \"%s\",       ", $2);} /Preferred/ {printf("\"%s\",\n", $2);}' | \
+ tr 'A-Z' 'a-z'
+
+ In addition, ja-latn-hepburn-heploc is mapped to ja-latn-alalc97 because
+ a variant tag 'hepburn-heploc' has the preferred subtag, 'alaic97'.
+*/
+
+static const char* const REDUNDANT[] = {
+//  redundant       preferred
+    "sgn-br",       "bzs",
+    "sgn-co",       "csn",
+    "sgn-de",       "gsg",
+    "sgn-dk",       "dsl",
+    "sgn-es",       "ssp",
+    "sgn-fr",       "fsl",
+    "sgn-gb",       "bfi",
+    "sgn-gr",       "gss",
+    "sgn-ie",       "isg",
+    "sgn-it",       "ise",
+    "sgn-jp",       "jsl",
+    "sgn-mx",       "mfs",
+    "sgn-ni",       "ncs",
+    "sgn-nl",       "dse",
+    "sgn-no",       "nsl",
+    "sgn-pt",       "psr",
+    "sgn-se",       "swl",
+    "sgn-us",       "ase",
+    "sgn-za",       "sfs",
+    "zh-cmn",       "cmn",
+    "zh-cmn-hans",  "cmn-hans",
+    "zh-cmn-hant",  "cmn-hant",
+    "zh-gan",       "gan",
+    "zh-wuu",       "wuu",
+    "zh-yue",       "yue",
+
+    // variant tag with preferred value
+    "ja-latn-hepburn-heploc", "ja-latn-alalc97",
 };
 
+/*
+  Updated on 2018-09-12 from
+  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry .
+
+  grep 'Type: language' -A 7 language-subtag-registry  | egrep 'Subtag|Prefe' | \
+  grep -B1 'Preferred' | grep -v '^--' | \
+  awk -n '/Subtag/ {printf("    \"%s\",       ", $2);} /Preferred/ {printf("\"%s\",\n", $2);}'
+
+  Make sure that 2-letter language subtags come before 3-letter subtags.
+*/
 static const char DEPRECATEDLANGS[][4] = {
 /*  deprecated  new */
+    "in",       "id",
     "iw",       "he",
     "ji",       "yi",
-    "in",       "id"
+    "jw",       "jv",
+    "mo",       "ro",
+    "aam",       "aas",
+    "adp",       "dz",
+    "aue",       "ktz",
+    "ayx",       "nun",
+    "bgm",       "bcg",
+    "bjd",       "drl",
+    "ccq",       "rki",
+    "cjr",       "mom",
+    "cka",       "cmr",
+    "cmk",       "xch",
+    "coy",       "pij",
+    "cqu",       "quh",
+    "drh",       "khk",
+    "drw",       "prs",
+    "gav",       "dev",
+    "gfx",       "vaj",
+    "ggn",       "gvr",
+    "gti",       "nyc",
+    "guv",       "duz",
+    "hrr",       "jal",
+    "ibi",       "opa",
+    "ilw",       "gal",
+    "jeg",       "oyb",
+    "kgc",       "tdf",
+    "kgh",       "kml",
+    "koj",       "kwv",
+    "krm",       "bmf",
+    "ktr",       "dtp",
+    "kvs",       "gdj",
+    "kwq",       "yam",
+    "kxe",       "tvd",
+    "kzj",       "dtp",
+    "kzt",       "dtp",
+    "lii",       "raq",
+    "lmm",       "rmx",
+    "meg",       "cir",
+    "mst",       "mry",
+    "mwj",       "vaj",
+    "myt",       "mry",
+    "nad",       "xny",
+    "ncp",       "kdz",
+    "nnx",       "ngv",
+    "nts",       "pij",
+    "oun",       "vaj",
+    "pcr",       "adx",
+    "pmc",       "huw",
+    "pmu",       "phr",
+    "ppa",       "bfy",
+    "ppr",       "lcq",
+    "pry",       "prt",
+    "puz",       "pub",
+    "sca",       "hle",
+    "skk",       "oyb",
+    "tdu",       "dtp",
+    "thc",       "tpo",
+    "thx",       "oyb",
+    "tie",       "ras",
+    "tkk",       "twm",
+    "tlw",       "weo",
+    "tmp",       "tyj",
+    "tne",       "kak",
+    "tnf",       "prs",
+    "tsf",       "taj",
+    "uok",       "ema",
+    "xba",       "cax",
+    "xia",       "acn",
+    "xkh",       "waw",
+    "xsj",       "suj",
+    "ybd",       "rki",
+    "yma",       "lrr",
+    "ymt",       "mtm",
+    "yos",       "zom",
+    "yuu",       "yug",
+};
+
+/*
+  Updated on 2018-04-24 from
+
+  curl  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry | \
+  grep 'Type: region' -A 7 | egrep 'Subtag|Prefe' | \
+  grep -B1 'Preferred' | \
+  awk -n '/Subtag/ {printf("    \"%s\",       ", $2);} /Preferred/ {printf("\"%s\",\n", $2);}'
+*/
+static const char DEPRECATEDREGIONS[][3] = {
+/*  deprecated  new */
+    "BU",       "MM",
+    "DD",       "DE",
+    "FX",       "FR",
+    "TP",       "TL",
+    "YD",       "YE",
+    "ZR",       "CD",
 };
 
 /*
 * -------------------------------------------------
 *
@@ -170,10 +347,25 @@
 #if 0
 static const char*
 ultag_getGrandfathered(const ULanguageTag* langtag);
 #endif
 
+U_NAMESPACE_BEGIN
+
+/**
+ * \class LocalULanguageTagPointer
+ * "Smart pointer" class, closes a ULanguageTag via ultag_close().
+ * For most methods see the LocalPointerBase base class.
+ *
+ * @see LocalPointerBase
+ * @see LocalPointer
+ * @internal
+ */
+U_DEFINE_LOCAL_OPEN_POINTER(LocalULanguageTagPointer, ULanguageTag, ultag_close);
+
+U_NAMESPACE_END
+
 /*
 * -------------------------------------------------
 *
 * Language subtag syntax validation functions
 *
@@ -212,17 +404,26 @@
     }
     return TRUE;
 }
 
 static UBool
-_isLanguageSubtag(const char* s, int32_t len) {
+_isAlphaNumericStringLimitedLength(const char* s, int32_t len, int32_t min, int32_t max) {
+    if (len < 0) {
+        len = (int32_t)uprv_strlen(s);
+    }
+    if (len >= min && len <= max && _isAlphaNumericString(s, len)) {
+        return TRUE;
+    }
+    return FALSE;
+}
+
+U_CFUNC UBool
+ultag_isLanguageSubtag(const char* s, int32_t len) {
     /*
-     * language      = 2*3ALPHA            ; shortest ISO 639 code
-     *                 ["-" extlang]       ; sometimes followed by
-     *                                     ;   extended language subtags
-     *               / 4ALPHA              ; or reserved for future use
-     *               / 5*8ALPHA            ; or registered language subtag
+     * unicode_language_subtag = alpha{2,3} | alpha{5,8};
+     * NOTE: Per ICUTC 2019/01/23- accepting alpha 4
+     * See ICU-20372
      */
     if (len < 0) {
         len = (int32_t)uprv_strlen(s);
     }
     if (len >= 2 && len <= 8 && _isAlphaString(s, len)) {
@@ -244,12 +445,12 @@
         return TRUE;
     }
     return FALSE;
 }
 
-static UBool
-_isScriptSubtag(const char* s, int32_t len) {
+U_CFUNC UBool
+ultag_isScriptSubtag(const char* s, int32_t len) {
     /*
      * script        = 4ALPHA              ; ISO 15924 code
      */
     if (len < 0) {
         len = (int32_t)uprv_strlen(s);
@@ -258,12 +459,12 @@
         return TRUE;
     }
     return FALSE;
 }
 
-static UBool
-_isRegionSubtag(const char* s, int32_t len) {
+U_CFUNC UBool
+ultag_isRegionSubtag(const char* s, int32_t len) {
     /*
      * region        = 2ALPHA              ; ISO 3166-1 code
      *               / 3DIGIT              ; UN M.49 code
      */
     if (len < 0) {
@@ -285,172 +486,326 @@
      *               / (DIGIT 3alphanum)
      */
     if (len < 0) {
         len = (int32_t)uprv_strlen(s);
     }
-    if (len >= 5 && len <= 8 && _isAlphaNumericString(s, len)) {
+    if (_isAlphaNumericStringLimitedLength(s, len, 5, 8)) {
         return TRUE;
     }
     if (len == 4 && ISNUMERIC(*s) && _isAlphaNumericString(s + 1, 3)) {
         return TRUE;
     }
     return FALSE;
 }
 
+static UBool
+_isSepListOf(UBool (*test)(const char*, int32_t), const char* s, int32_t len) {
+    const char *p = s;
+    const char *pSubtag = NULL;
+
+    if (len < 0) {
+        len = (int32_t)uprv_strlen(s);
+    }
+
+    while ((p - s) < len) {
+        if (*p == SEP) {
+            if (pSubtag == NULL) {
+                return FALSE;
+            }
+            if (!test(pSubtag, (int32_t)(p - pSubtag))) {
+                return FALSE;
+            }
+            pSubtag = NULL;
+        } else if (pSubtag == NULL) {
+            pSubtag = p;
+        }
+        p++;
+    }
+    if (pSubtag == NULL) {
+        return FALSE;
+    }
+    return test(pSubtag, (int32_t)(p - pSubtag));
+}
+
+U_CFUNC UBool
+ultag_isVariantSubtags(const char* s, int32_t len) {
+    return _isSepListOf(&_isVariantSubtag, s, len);
+}
+
+// This is for the ICU-specific "lvariant" handling.
 static UBool
 _isPrivateuseVariantSubtag(const char* s, int32_t len) {
     /*
      * variant       = 1*8alphanum         ; registered variants
      *               / (DIGIT 3alphanum)
      */
-    if (len < 0) {
-        len = (int32_t)uprv_strlen(s);
-    }
-    if (len >= 1 && len <= 8 && _isAlphaNumericString(s, len)) {
-        return TRUE;
-    }
-    return FALSE;
+    return _isAlphaNumericStringLimitedLength(s, len , 1, 8);
 }
 
 static UBool
 _isExtensionSingleton(const char* s, int32_t len) {
     /*
      * extension     = singleton 1*("-" (2*8alphanum))
+     *
+     * singleton     = DIGIT               ; 0 - 9
+     *               / %x41-57             ; A - W
+     *               / %x59-5A             ; Y - Z
+     *               / %x61-77             ; a - w
+     *               / %x79-7A             ; y - z
      */
     if (len < 0) {
         len = (int32_t)uprv_strlen(s);
     }
-    if (len == 1 && ISALPHA(*s) && (uprv_tolower(*s) != PRIVATEUSE)) {
+    if (len == 1 && (ISALPHA(*s) || ISNUMERIC(*s)) && (uprv_tolower(*s) != PRIVATEUSE)) {
         return TRUE;
     }
     return FALSE;
 }
 
 static UBool
 _isExtensionSubtag(const char* s, int32_t len) {
     /*
      * extension     = singleton 1*("-" (2*8alphanum))
      */
+    return _isAlphaNumericStringLimitedLength(s, len, 2, 8);
+}
+
+U_CFUNC UBool
+ultag_isExtensionSubtags(const char* s, int32_t len) {
+    return _isSepListOf(&_isExtensionSubtag, s, len);
+}
+
+static UBool
+_isPrivateuseValueSubtag(const char* s, int32_t len) {
+    /*
+     * privateuse    = "x" 1*("-" (1*8alphanum))
+     */
+    return _isAlphaNumericStringLimitedLength(s, len, 1, 8);
+}
+
+U_CFUNC UBool
+ultag_isPrivateuseValueSubtags(const char* s, int32_t len) {
+    return _isSepListOf(&_isPrivateuseValueSubtag, s, len);
+}
+
+U_CFUNC UBool
+ultag_isUnicodeLocaleAttribute(const char* s, int32_t len) {
+    /*
+     * attribute = alphanum{3,8} ;
+     */
+    return _isAlphaNumericStringLimitedLength(s, len , 3, 8);
+}
+
+U_CFUNC UBool
+ultag_isUnicodeLocaleAttributes(const char* s, int32_t len) {
+    return _isSepListOf(&ultag_isUnicodeLocaleAttribute, s, len);
+}
+
+U_CFUNC UBool
+ultag_isUnicodeLocaleKey(const char* s, int32_t len) {
+    /*
+     * key = alphanum alpha ;
+     */
     if (len < 0) {
         len = (int32_t)uprv_strlen(s);
     }
-    if (len >= 2 && len <= 8 && _isAlphaNumericString(s, len)) {
+    if (len == 2 && (ISALPHA(*s) || ISNUMERIC(*s)) && ISALPHA(s[1])) {
         return TRUE;
     }
     return FALSE;
 }
 
-static UBool
-_isExtensionSubtags(const char* s, int32_t len) {
-    const char *p = s;
-    const char *pSubtag = NULL;
-
-    if (len < 0) {
-        len = (int32_t)uprv_strlen(s);
-    }
+U_CFUNC UBool
+_isUnicodeLocaleTypeSubtag(const char*s, int32_t len) {
+    /*
+     * alphanum{3,8}
+     */
+    return _isAlphaNumericStringLimitedLength(s, len , 3, 8);
+}
 
-    while ((p - s) < len) {
-        if (*p == SEP) {
-            if (pSubtag == NULL) {
-                return FALSE;
-            }
-            if (!_isExtensionSubtag(pSubtag, (int32_t)(p - pSubtag))) {
-                return FALSE;
-            }
-            pSubtag = NULL;
-        } else if (pSubtag == NULL) {
-            pSubtag = p;
-        }
-        p++;
-    }
-    if (pSubtag == NULL) {
-        return FALSE;
-    }
-    return _isExtensionSubtag(pSubtag, (int32_t)(p - pSubtag));
+U_CFUNC UBool
+ultag_isUnicodeLocaleType(const char*s, int32_t len) {
+    /*
+     * type = alphanum{3,8} (sep alphanum{3,8})* ;
+     */
+    return _isSepListOf(&_isUnicodeLocaleTypeSubtag, s, len);
 }
 
 static UBool
-_isPrivateuseValueSubtag(const char* s, int32_t len) {
+_isTKey(const char* s, int32_t len)
+{
     /*
-     * privateuse    = "x" 1*("-" (1*8alphanum))
+     * tkey = alpha digit ;
      */
     if (len < 0) {
         len = (int32_t)uprv_strlen(s);
     }
-    if (len >= 1 && len <= 8 && _isAlphaNumericString(s, len)) {
+    if (len == 2 && ISALPHA(*s) && ISNUMERIC(*(s + 1))) {
         return TRUE;
     }
     return FALSE;
 }
 
 static UBool
-_isPrivateuseValueSubtags(const char* s, int32_t len) {
-    const char *p = s;
-    const char *pSubtag = NULL;
-
-    if (len < 0) {
-        len = (int32_t)uprv_strlen(s);
-    }
+_isTValue(const char* s, int32_t len)
+{
+    /*
+     * tvalue = (sep alphanum{3,8})+ ;
+     */
+    return _isAlphaNumericStringLimitedLength(s, len , 3, 8);
+}
 
-    while ((p - s) < len) {
-        if (*p == SEP) {
-            if (pSubtag == NULL) {
-                return FALSE;
+static UBool
+_isTransformedExtensionSubtag(int32_t& state, const char* s, int32_t len)
+{
+    const int32_t kStart = 0;       // Start, wait for unicode_language_subtag, tkey or end
+    const int32_t kGotLanguage = 1; // Got unicode_language_subtag, wait for unicode_script_subtag,
+                                    // unicode_region_subtag, unicode_variant_subtag, tkey or end
+    const int32_t kGotScript = 2;   // Got unicode_script_subtag, wait for unicode_region_subtag,
+                                    // unicode_variant_subtag, tkey, or end
+    const int32_t kGotRegion = 3;   // Got unicode_region_subtag, wait for unicode_variant_subtag,
+                                    // tkey, or end.
+    const int32_t kGotVariant = 4;  // Got unicode_variant_subtag, wait for unicode_variant_subtag
+                                    // tkey or end.
+    const int32_t kGotTKey = -1;    // Got tkey, wait for tvalue. ERROR if stop here.
+    const int32_t kGotTValue = 6;   // Got tvalue, wait for tkey, tvalue or end
+
+    switch (state) {
+        case kStart:
+            if (ultag_isLanguageSubtag(s, len)) {
+                state = kGotLanguage;
+                return TRUE;
+            }
+            if (_isTKey(s, len)) {
+                state = kGotTKey;
+                return TRUE;
             }
-            if (!_isPrivateuseValueSubtag(pSubtag, (int32_t)(p - pSubtag))) {
-                return FALSE;
+            return FALSE;
+        case kGotLanguage:
+            if (ultag_isScriptSubtag(s, len)) {
+                state = kGotScript;
+                return TRUE;
+            }
+            U_FALLTHROUGH;
+        case kGotScript:
+            if (ultag_isRegionSubtag(s, len)) {
+                state = kGotRegion;
+                return TRUE;
+            }
+            U_FALLTHROUGH;
+        case kGotRegion:
+            U_FALLTHROUGH;
+        case kGotVariant:
+            if (_isVariantSubtag(s, len)) {
+                state = kGotVariant;
+                return TRUE;
+            }
+            if (_isTKey(s, len)) {
+                state = kGotTKey;
+                return TRUE;
             }
-            pSubtag = NULL;
-        } else if (pSubtag == NULL) {
-            pSubtag = p;
-        }
-        p++;
-    }
-    if (pSubtag == NULL) {
-        return FALSE;
+            return FALSE;
+        case kGotTKey:
+            if (_isTValue(s, len)) {
+                state = kGotTValue;
+                return TRUE;
+            }
+            return FALSE;
+        case kGotTValue:
+            if (_isTKey(s, len)) {
+                state = kGotTKey;
+                return TRUE;
+            }
+            if (_isTValue(s, len)) {
+                return TRUE;
+            }
+            return FALSE;
     }
-    return _isPrivateuseValueSubtag(pSubtag, (int32_t)(p - pSubtag));
+    return FALSE;
 }
 
-U_CFUNC UBool
-ultag_isUnicodeLocaleKey(const char* s, int32_t len) {
-    if (len < 0) {
-        len = (int32_t)uprv_strlen(s);
-    }
-    if (len == 2 && _isAlphaNumericString(s, len)) {
-        return TRUE;
+static UBool
+_isUnicodeExtensionSubtag(int32_t& state, const char* s, int32_t len)
+{
+    const int32_t kStart = 0;         // Start, wait for a key or attribute or end
+    const int32_t kGotKey = 1;        // Got a key, wait for type or key or end
+    const int32_t kGotType = 2;       // Got a type, wait for key or end
+
+    switch (state) {
+        case kStart:
+            if (ultag_isUnicodeLocaleKey(s, len)) {
+                state = kGotKey;
+                return TRUE;
+            }
+            if (ultag_isUnicodeLocaleAttribute(s, len)) {
+                return TRUE;
+            }
+            return FALSE;
+        case kGotKey:
+            if (ultag_isUnicodeLocaleKey(s, len)) {
+                return TRUE;
+            }
+            if (_isUnicodeLocaleTypeSubtag(s, len)) {
+                state = kGotType;
+                return TRUE;
+            }
+            return FALSE;
+        case kGotType:
+            if (ultag_isUnicodeLocaleKey(s, len)) {
+                state = kGotKey;
+                return TRUE;
+            }
+            if (_isUnicodeLocaleTypeSubtag(s, len)) {
+                return TRUE;
+            }
+            return FALSE;
     }
     return FALSE;
 }
 
-U_CFUNC UBool
-ultag_isUnicodeLocaleType(const char*s, int32_t len) {
+static UBool
+_isStatefulSepListOf(UBool (*test)(int32_t&, const char*, int32_t), const char* s, int32_t len)
+{
+    int32_t state = 0;
     const char* p;
+    const char* start = s;
     int32_t subtagLen = 0;
 
     if (len < 0) {
         len = (int32_t)uprv_strlen(s);
     }
 
     for (p = s; len > 0; p++, len--) {
         if (*p == SEP) {
-            if (subtagLen < 3) {
+            if (!test(state, start, subtagLen)) {
                 return FALSE;
             }
             subtagLen = 0;
-        } else if (ISALPHA(*p) || ISNUMERIC(*p)) {
-            subtagLen++;
-            if (subtagLen > 8) {
-                return FALSE;
-            }
+            start = p + 1;
         } else {
-            return FALSE;
+            subtagLen++;
         }
     }
 
-    return (subtagLen >= 3);
+    if (test(state, start, subtagLen) && state >= 0) {
+        return TRUE;
+    }
+    return FALSE;
+}
+
+U_CFUNC UBool
+ultag_isTransformedExtensionSubtags(const char* s, int32_t len)
+{
+    return _isStatefulSepListOf(&_isTransformedExtensionSubtag, s, len);
+}
+
+U_CFUNC UBool
+ultag_isUnicodeExtensionSubtags(const char* s, int32_t len) {
+    return _isStatefulSepListOf(&_isUnicodeExtensionSubtag, s, len);
 }
+
+
 /*
 * -------------------------------------------------
 *
 * Helper functions
 *
@@ -633,166 +988,146 @@
 
     langtag->grandfathered = EMPTY;
     langtag->privateuse = EMPTY;
 }
 
-static int32_t
-_appendLanguageToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UErrorCode* status) {
+static void
+_appendLanguageToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool strict, UErrorCode* status) {
     char buf[ULOC_LANG_CAPACITY];
     UErrorCode tmpStatus = U_ZERO_ERROR;
     int32_t len, i;
-    int32_t reslen = 0;
 
     if (U_FAILURE(*status)) {
-        return 0;
+        return;
     }
 
     len = uloc_getLanguage(localeID, buf, sizeof(buf), &tmpStatus);
     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
         if (strict) {
             *status = U_ILLEGAL_ARGUMENT_ERROR;
-            return 0;
+            return;
         }
         len = 0;
     }
 
     /* Note: returned language code is in lower case letters */
 
     if (len == 0) {
-        if (reslen < capacity) {
-            uprv_memcpy(appendAt + reslen, LANG_UND, uprv_min(LANG_UND_LEN, capacity - reslen));
-        }
-        reslen += LANG_UND_LEN;
-    } else if (!_isLanguageSubtag(buf, len)) {
+        sink.Append(LANG_UND, LANG_UND_LEN);
+    } else if (!ultag_isLanguageSubtag(buf, len)) {
             /* invalid language code */
         if (strict) {
             *status = U_ILLEGAL_ARGUMENT_ERROR;
-            return 0;
-        }
-        if (reslen < capacity) {
-            uprv_memcpy(appendAt + reslen, LANG_UND, uprv_min(LANG_UND_LEN, capacity - reslen));
+            return;
         }
-        reslen += LANG_UND_LEN;
+        sink.Append(LANG_UND, LANG_UND_LEN);
     } else {
         /* resolve deprecated */
         for (i = 0; i < UPRV_LENGTHOF(DEPRECATEDLANGS); i += 2) {
+            // 2-letter deprecated subtags are listede before 3-letter
+            // ones in DEPRECATEDLANGS[]. Get out of loop on coming
+            // across the 1st 3-letter subtag, if the input is a 2-letter code.
+            // to avoid continuing to try when there's no match.
+            if (uprv_strlen(buf) < uprv_strlen(DEPRECATEDLANGS[i])) break;
             if (uprv_compareInvCharsAsAscii(buf, DEPRECATEDLANGS[i]) == 0) {
                 uprv_strcpy(buf, DEPRECATEDLANGS[i + 1]);
                 len = (int32_t)uprv_strlen(buf);
                 break;
             }
         }
-        if (reslen < capacity) {
-            uprv_memcpy(appendAt + reslen, buf, uprv_min(len, capacity - reslen));
-        }
-        reslen += len;
+        sink.Append(buf, len);
     }
-    u_terminateChars(appendAt, capacity, reslen, status);
-    return reslen;
 }
 
-static int32_t
-_appendScriptToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UErrorCode* status) {
+static void
+_appendScriptToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool strict, UErrorCode* status) {
     char buf[ULOC_SCRIPT_CAPACITY];
     UErrorCode tmpStatus = U_ZERO_ERROR;
     int32_t len;
-    int32_t reslen = 0;
 
     if (U_FAILURE(*status)) {
-        return 0;
+        return;
     }
 
     len = uloc_getScript(localeID, buf, sizeof(buf), &tmpStatus);
     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
         if (strict) {
             *status = U_ILLEGAL_ARGUMENT_ERROR;
         }
-        return 0;
+        return;
     }
 
     if (len > 0) {
-        if (!_isScriptSubtag(buf, len)) {
+        if (!ultag_isScriptSubtag(buf, len)) {
             /* invalid script code */
             if (strict) {
                 *status = U_ILLEGAL_ARGUMENT_ERROR;
             }
-            return 0;
+            return;
         } else {
-            if (reslen < capacity) {
-                *(appendAt + reslen) = SEP;
-            }
-            reslen++;
-
-            if (reslen < capacity) {
-                uprv_memcpy(appendAt + reslen, buf, uprv_min(len, capacity - reslen));
-            }
-            reslen += len;
+            sink.Append("-", 1);
+            sink.Append(buf, len);
         }
     }
-    u_terminateChars(appendAt, capacity, reslen, status);
-    return reslen;
 }
 
-static int32_t
-_appendRegionToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UErrorCode* status) {
+static void
+_appendRegionToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool strict, UErrorCode* status) {
     char buf[ULOC_COUNTRY_CAPACITY];
     UErrorCode tmpStatus = U_ZERO_ERROR;
     int32_t len;
-    int32_t reslen = 0;
 
     if (U_FAILURE(*status)) {
-        return 0;
+        return;
     }
 
     len = uloc_getCountry(localeID, buf, sizeof(buf), &tmpStatus);
     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
         if (strict) {
             *status = U_ILLEGAL_ARGUMENT_ERROR;
         }
-        return 0;
+        return;
     }
 
     if (len > 0) {
-        if (!_isRegionSubtag(buf, len)) {
+        if (!ultag_isRegionSubtag(buf, len)) {
             /* invalid region code */
             if (strict) {
                 *status = U_ILLEGAL_ARGUMENT_ERROR;
             }
-            return 0;
+            return;
         } else {
-            if (reslen < capacity) {
-                *(appendAt + reslen) = SEP;
-            }
-            reslen++;
-
-            if (reslen < capacity) {
-                uprv_memcpy(appendAt + reslen, buf, uprv_min(len, capacity - reslen));
+            sink.Append("-", 1);
+            /* resolve deprecated */
+            for (int i = 0; i < UPRV_LENGTHOF(DEPRECATEDREGIONS); i += 2) {
+                if (uprv_compareInvCharsAsAscii(buf, DEPRECATEDREGIONS[i]) == 0) {
+                    uprv_strcpy(buf, DEPRECATEDREGIONS[i + 1]);
+                    len = (int32_t)uprv_strlen(buf);
+                    break;
+                }
             }
-            reslen += len;
+            sink.Append(buf, len);
         }
     }
-    u_terminateChars(appendAt, capacity, reslen, status);
-    return reslen;
 }
 
-static int32_t
-_appendVariantsToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UBool *hadPosix, UErrorCode* status) {
+static void
+_appendVariantsToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool strict, UBool *hadPosix, UErrorCode* status) {
     char buf[ULOC_FULLNAME_CAPACITY];
     UErrorCode tmpStatus = U_ZERO_ERROR;
     int32_t len, i;
-    int32_t reslen = 0;
 
     if (U_FAILURE(*status)) {
-        return 0;
+        return;
     }
 
     len = uloc_getVariant(localeID, buf, sizeof(buf), &tmpStatus);
     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
         if (strict) {
             *status = U_ILLEGAL_ARGUMENT_ERROR;
         }
-        return 0;
+        return;
     }
 
     if (len > 0) {
         char *p, *pVar;
         UBool bNext = TRUE;
@@ -865,19 +1200,13 @@
                 int32_t varLen;
 
                 /* write out validated/normalized variants to the target */
                 var = varFirst;
                 while (var != NULL) {
-                    if (reslen < capacity) {
-                        *(appendAt + reslen) = SEP;
-                    }
-                    reslen++;
+                    sink.Append("-", 1);
                     varLen = (int32_t)uprv_strlen(var->variant);
-                    if (reslen < capacity) {
-                        uprv_memcpy(appendAt + reslen, var->variant, uprv_min(varLen, capacity - reslen));
-                    }
-                    reslen += varLen;
+                    sink.Append(var->variant, varLen);
                     var = var->next;
                 }
             }
         }
 
@@ -888,65 +1217,92 @@
             uprv_free(var);
             var = tmpVar;
         }
 
         if (U_FAILURE(*status)) {
-            return 0;
+            return;
         }
     }
-
-    u_terminateChars(appendAt, capacity, reslen, status);
-    return reslen;
 }
 
-static int32_t
-_appendKeywordsToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UBool hadPosix, UErrorCode* status) {
-    char buf[ULOC_KEYWORD_AND_VALUES_CAPACITY];
+static void
+_appendKeywordsToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool strict, UBool hadPosix, UErrorCode* status) {
     char attrBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY] = { 0 };
     int32_t attrBufLength = 0;
-    UEnumeration *keywordEnum = NULL;
-    int32_t reslen = 0;
 
-    keywordEnum = uloc_openKeywords(localeID, status);
+    icu::MemoryPool<AttributeListEntry> attrPool;
+    icu::MemoryPool<ExtensionListEntry> extPool;
+    icu::MemoryPool<icu::CharString> strPool;
+
+    icu::LocalUEnumerationPointer keywordEnum(uloc_openKeywords(localeID, status));
     if (U_FAILURE(*status) && !hadPosix) {
-        uenum_close(keywordEnum);
-        return 0;
+        return;
     }
-    if (keywordEnum != NULL || hadPosix) {
+    if (keywordEnum.isValid() || hadPosix) {
         /* reorder extensions */
         int32_t len;
         const char *key;
         ExtensionListEntry *firstExt = NULL;
         ExtensionListEntry *ext;
         AttributeListEntry *firstAttr = NULL;
         AttributeListEntry *attr;
-        char *attrValue;
-        char extBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY];
-        char *pExtBuf = extBuf;
-        int32_t extBufCapacity = sizeof(extBuf);
+        icu::MemoryPool<icu::CharString> extBufPool;
         const char *bcpKey=nullptr, *bcpValue=nullptr;
         UErrorCode tmpStatus = U_ZERO_ERROR;
         int32_t keylen;
         UBool isBcpUExt;
 
         while (TRUE) {
-            key = uenum_next(keywordEnum, NULL, status);
+            icu::CharString buf;
+            key = uenum_next(keywordEnum.getAlias(), NULL, status);
             if (key == NULL) {
                 break;
             }
-            len = uloc_getKeywordValue(localeID, key, buf, sizeof(buf), &tmpStatus);
-            /* buf must be null-terminated */
-            if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
+            char* buffer;
+            int32_t resultCapacity = ULOC_KEYWORD_AND_VALUES_CAPACITY;
+
+            for (;;) {
+                buffer = buf.getAppendBuffer(
+                        /*minCapacity=*/resultCapacity,
+                        /*desiredCapacityHint=*/resultCapacity,
+                        resultCapacity,
+                        tmpStatus);
+
+                if (U_FAILURE(tmpStatus)) {
+                    break;
+                }
+
+                len = uloc_getKeywordValue(
+                        localeID, key, buffer, resultCapacity, &tmpStatus);
+
+                if (tmpStatus != U_BUFFER_OVERFLOW_ERROR) {
+                    break;
+                }
+
+                resultCapacity = len;
+                tmpStatus = U_ZERO_ERROR;
+            }
+
+            if (U_FAILURE(tmpStatus)) {
+                if (tmpStatus == U_MEMORY_ALLOCATION_ERROR) {
+                    *status = U_MEMORY_ALLOCATION_ERROR;
+                    break;
+                }
                 if (strict) {
                     *status = U_ILLEGAL_ARGUMENT_ERROR;
                     break;
                 }
                 /* ignore this keyword */
+            buf.append(buffer, len, tmpStatus);
+            if (tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
+                tmpStatus = U_ZERO_ERROR;  // Terminators provided by CharString.
+            }
+
             keylen = (int32_t)uprv_strlen(key);
             isBcpUExt = (keylen > 1);
 
             /* special keyword used for representing Unicode locale attributes */
             if (uprv_strcmp(key, LOCALE_ATTRIBUTE_KEY) == 0) {
@@ -968,26 +1324,27 @@
                         } else if (i >= len){
                             break;
                         }
 
                         /* create AttributeListEntry */
-                        attr = (AttributeListEntry*)uprv_malloc(sizeof(AttributeListEntry));
+                        attr = attrPool.create();
                         if (attr == NULL) {
                             *status = U_MEMORY_ALLOCATION_ERROR;
                             break;
                         }
-                        attrValue = (char*)uprv_malloc(attrBufLength + 1);
+                        icu::CharString* attrValue =
+                                strPool.create(attrBuf, attrBufLength, *status);
                         if (attrValue == NULL) {
                             *status = U_MEMORY_ALLOCATION_ERROR;
                             break;
                         }
-                        uprv_strcpy(attrValue, attrBuf);
-                        attr->attribute = attrValue;
+                        if (U_FAILURE(*status)) {
+                            break;
+                        }
+                        attr->attribute = attrValue->data();
 
                         if (!_addAttributeToList(&firstAttr, attr)) {
-                            uprv_free(attr);
-                            uprv_free(attrValue);
                             if (strict) {
                                 *status = U_ILLEGAL_ARGUMENT_ERROR;
                                 break;
                             }
                         }
@@ -1005,314 +1362,254 @@
                     }
                     continue;
                 }
 
                 /* we've checked buf is null-terminated above */
-                bcpValue = uloc_toUnicodeLocaleType(key, buf);
+                bcpValue = uloc_toUnicodeLocaleType(key, buf.data());
                 if (bcpValue == NULL) {
                     if (strict) {
                         *status = U_ILLEGAL_ARGUMENT_ERROR;
                         break;
                     }
                     continue;
                 }
-                if (bcpValue == buf) {
+                if (bcpValue == buf.data()) {
                     /*
                     When uloc_toUnicodeLocaleType(key, buf) returns the
                     input value as is, the value is well-formed, but has
                     no known mapping. This implementation normalizes the
-                    the value to lower case
+                    value to lower case
                     */
+                    icu::CharString* extBuf = extBufPool.create();
+                    if (extBuf == nullptr) {
+                        *status = U_MEMORY_ALLOCATION_ERROR;
+                        break;
+                    }
                     int32_t bcpValueLen = static_cast<int32_t>(uprv_strlen(bcpValue));
-                    if (bcpValueLen < extBufCapacity) {
-                        uprv_strcpy(pExtBuf, bcpValue);
-                        T_CString_toLowerCase(pExtBuf);
+                    int32_t resultCapacity;
+                    char* pExtBuf = extBuf->getAppendBuffer(
+                            /*minCapacity=*/bcpValueLen,
+                            /*desiredCapacityHint=*/bcpValueLen,
+                            resultCapacity,
+                            tmpStatus);
+                    if (U_FAILURE(tmpStatus)) {
+                        *status = tmpStatus;
+                        break;
+                    }
 
-                        bcpValue = pExtBuf;
+                    uprv_strcpy(pExtBuf, bcpValue);
+                    T_CString_toLowerCase(pExtBuf);
 
-                        pExtBuf += (bcpValueLen + 1);
-                        extBufCapacity -= (bcpValueLen + 1);
-                    } else {
-                        if (strict) {
-                            *status = U_ILLEGAL_ARGUMENT_ERROR;
-                            break;
-                        }
-                        continue;
+                    extBuf->append(pExtBuf, bcpValueLen, tmpStatus);
+                    if (U_FAILURE(tmpStatus)) {
+                        *status = tmpStatus;
+                        break;
                     }
+
+                    bcpValue = extBuf->data();
                 }
             } else {
                 if (*key == PRIVATEUSE) {
-                    if (!_isPrivateuseValueSubtags(buf, len)) {
+                    if (!ultag_isPrivateuseValueSubtags(buf.data(), len)) {
                         if (strict) {
                             *status = U_ILLEGAL_ARGUMENT_ERROR;
                             break;
                         }
                         continue;
                     }
                 } else {
-                    if (!_isExtensionSingleton(key, keylen) || !_isExtensionSubtags(buf, len)) {
+                    if (!_isExtensionSingleton(key, keylen) || !ultag_isExtensionSubtags(buf.data(), len)) {
                         if (strict) {
                             *status = U_ILLEGAL_ARGUMENT_ERROR;
                             break;
                         }
                         continue;
                     }
                 }
                 bcpKey = key;
-                if ((len + 1) < extBufCapacity) {
-                    uprv_memcpy(pExtBuf, buf, len);
-                    bcpValue = pExtBuf;
-
-                    pExtBuf += len;
-
-                    *pExtBuf = 0;
-                    pExtBuf++;
-
-                    extBufCapacity -= (len + 1);
-                } else {
-                    *status = U_ILLEGAL_ARGUMENT_ERROR;
+                icu::CharString* extBuf =
+                    extBufPool.create(buf.data(), len, tmpStatus);
+                if (extBuf == nullptr) {
+                    *status = U_MEMORY_ALLOCATION_ERROR;
+                    break;
+                }
+                if (U_FAILURE(tmpStatus)) {
+                    *status = tmpStatus;
                     break;
                 }
+                bcpValue = extBuf->data();
             }
 
             /* create ExtensionListEntry */
-            ext = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));
+            ext = extPool.create();
             if (ext == NULL) {
                 *status = U_MEMORY_ALLOCATION_ERROR;
                 break;
             }
             ext->key = bcpKey;
             ext->value = bcpValue;
 
             if (!_addExtensionToList(&firstExt, ext, TRUE)) {
-                uprv_free(ext);
                 if (strict) {
                     *status = U_ILLEGAL_ARGUMENT_ERROR;
                     break;
                 }
             }
         }
 
         /* Special handling for POSIX variant - add the keywords for POSIX */
         if (hadPosix) {
             /* create ExtensionListEntry for POSIX */
-            ext = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));
+            ext = extPool.create();
             if (ext == NULL) {
                 *status = U_MEMORY_ALLOCATION_ERROR;
-                goto cleanup;
+                return;
             }
             ext->key = POSIX_KEY;
             ext->value = POSIX_VALUE;
 
             if (!_addExtensionToList(&firstExt, ext, TRUE)) {
-                uprv_free(ext);
+                // Silently ignore errors.
             }
         }
 
         if (U_SUCCESS(*status) && (firstExt != NULL || firstAttr != NULL)) {
             UBool startLDMLExtension = FALSE;
             for (ext = firstExt; ext; ext = ext->next) {
                 if (!startLDMLExtension && uprv_strlen(ext->key) > 1) {
                     /* first LDML u singlton extension */
-                   if (reslen < capacity) {
-                       *(appendAt + reslen) = SEP;
-                   }
-                   reslen++;
-                   if (reslen < capacity) {
-                       *(appendAt + reslen) = LDMLEXT;
-                   }
-                   reslen++;
-
+                   sink.Append("-u", 2);
                    startLDMLExtension = TRUE;
                 }
 
                 /* write out the sorted BCP47 attributes, extensions and private use */
                 if (uprv_strcmp(ext->key, LOCALE_ATTRIBUTE_KEY) == 0) {
                     /* write the value for the attributes */
                     for (attr = firstAttr; attr; attr = attr->next) {
-                        if (reslen < capacity) {
-                            *(appendAt + reslen) = SEP;
-                        }
-                        reslen++;
-                        len = (int32_t)uprv_strlen(attr->attribute);
-                        if (reslen < capacity) {
-                            uprv_memcpy(appendAt + reslen, attr->attribute, uprv_min(len, capacity - reslen));
-                        }
-                        reslen += len;
+                        sink.Append("-", 1);
+                        sink.Append(
+                                attr->attribute, static_cast<int32_t>(uprv_strlen(attr->attribute)));
                     }
                 } else {
-                    if (reslen < capacity) {
-                        *(appendAt + reslen) = SEP;
-                    }
-                    reslen++;
-                    len = (int32_t)uprv_strlen(ext->key);
-                    if (reslen < capacity) {
-                        uprv_memcpy(appendAt + reslen, ext->key, uprv_min(len, capacity - reslen));
-                    }
-                    reslen += len;
-                    if (reslen < capacity) {
-                        *(appendAt + reslen) = SEP;
-                    }
-                    reslen++;
-                    len = (int32_t)uprv_strlen(ext->value);
-                    if (reslen < capacity) {
-                        uprv_memcpy(appendAt + reslen, ext->value, uprv_min(len, capacity - reslen));
-                    }
-                    reslen += len;
+                    sink.Append("-", 1);
+                    sink.Append(ext->key, static_cast<int32_t>(uprv_strlen(ext->key)));
+                    sink.Append("-", 1);
+                    sink.Append(ext->value, static_cast<int32_t>(uprv_strlen(ext->value)));
                 }
             }
         }
-cleanup:
-        /* clean up */
-        ext = firstExt;
-        while (ext != NULL) {
-            ExtensionListEntry *tmpExt = ext->next;
-            uprv_free(ext);
-            ext = tmpExt;
-        }
-
-        attr = firstAttr;
-        while (attr != NULL) {
-            AttributeListEntry *tmpAttr = attr->next;
-            char *pValue = (char *)attr->attribute;
-            uprv_free(pValue);
-            uprv_free(attr);
-            attr = tmpAttr;
-        }
-
-        uenum_close(keywordEnum);
-
-        if (U_FAILURE(*status)) {
-            return 0;
-        }
     }
-
-    return u_terminateChars(appendAt, capacity, reslen, status);
 }
 
 /**
  * Append keywords parsed from LDML extension value
  * e.g. "u-ca-gregory-co-trad" -> {calendar = gregorian} {collation = traditional}
  * Note: char* buf is used for storing keywords
  */
 static void
-_appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendTo, char* buf, int32_t bufSize, UBool *posixVariant, UErrorCode *status) {
+_appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendTo, icu::MemoryPool<ExtensionListEntry>& extPool, icu::MemoryPool<icu::CharString>& kwdBuf, UBool *posixVariant, UErrorCode *status) {
     const char *pTag;   /* beginning of current subtag */
     const char *pKwds;  /* beginning of key-type pairs */
     UBool variantExists = *posixVariant;
 
     ExtensionListEntry *kwdFirst = NULL;    /* first LDML keyword */
     ExtensionListEntry *kwd, *nextKwd;
 
-    AttributeListEntry *attrFirst = NULL;   /* first attribute */
-    AttributeListEntry *attr, *nextAttr;
-
     int32_t len;
-    int32_t bufIdx = 0;
-
-    char attrBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY];
-    int32_t attrBufIdx = 0;
 
     /* Reset the posixVariant value */
     *posixVariant = FALSE;
 
     pTag = ldmlext;
     pKwds = NULL;
 
-    /* Iterate through u extension attributes */
-    while (*pTag) {
-        /* locate next separator char */
-        for (len = 0; *(pTag + len) && *(pTag + len) != SEP; len++);
+    {
+        AttributeListEntry *attrFirst = NULL;   /* first attribute */
+        AttributeListEntry *attr, *nextAttr;
 
-        if (ultag_isUnicodeLocaleKey(pTag, len)) {
-            pKwds = pTag;
-            break;
-        }
+        char attrBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY];
+        int32_t attrBufIdx = 0;
 
-        /* add this attribute to the list */
-        attr = (AttributeListEntry*)uprv_malloc(sizeof(AttributeListEntry));
-        if (attr == NULL) {
-            *status = U_MEMORY_ALLOCATION_ERROR;
-            goto cleanup;
-        }
+        icu::MemoryPool<AttributeListEntry> attrPool;
 
-        if (len < (int32_t)sizeof(attrBuf) - attrBufIdx) {
-            uprv_memcpy(&attrBuf[attrBufIdx], pTag, len);
-            attrBuf[attrBufIdx + len] = 0;
-            attr->attribute = &attrBuf[attrBufIdx];
-            attrBufIdx += (len + 1);
-        } else {
-            *status = U_ILLEGAL_ARGUMENT_ERROR;
-            goto cleanup;
-        }
+        /* Iterate through u extension attributes */
+        while (*pTag) {
+            /* locate next separator char */
+            for (len = 0; *(pTag + len) && *(pTag + len) != SEP; len++);
 
-        if (!_addAttributeToList(&attrFirst, attr)) {
-            *status = U_ILLEGAL_ARGUMENT_ERROR;
-            uprv_free(attr);
-            goto cleanup;
-        }
+            if (ultag_isUnicodeLocaleKey(pTag, len)) {
+                pKwds = pTag;
+                break;
+            }
 
-        /* next tag */
-        pTag += len;
-        if (*pTag) {
-            /* next to the separator */
-            pTag++;
-        }
-    }
+            /* add this attribute to the list */
+            attr = attrPool.create();
+            if (attr == NULL) {
+                *status = U_MEMORY_ALLOCATION_ERROR;
+                return;
+            }
 
-    if (attrFirst) {
-        /* emit attributes as an LDML keyword, e.g. attribute=attr1-attr2 */
+            if (len < (int32_t)sizeof(attrBuf) - attrBufIdx) {
+                uprv_memcpy(&attrBuf[attrBufIdx], pTag, len);
+                attrBuf[attrBufIdx + len] = 0;
+                attr->attribute = &attrBuf[attrBufIdx];
+                attrBufIdx += (len + 1);
+            } else {
+                *status = U_ILLEGAL_ARGUMENT_ERROR;
+                return;
+            }
 
-        if (attrBufIdx > bufSize) {
-            /* attrBufIdx == <total length of attribute subtag> + 1 */
-            *status = U_ILLEGAL_ARGUMENT_ERROR;
-            goto cleanup;
-        }
+            if (!_addAttributeToList(&attrFirst, attr)) {
+                *status = U_ILLEGAL_ARGUMENT_ERROR;
+                return;
+            }
 
-        kwd = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));
-        if (kwd == NULL) {
-            *status = U_MEMORY_ALLOCATION_ERROR;
-            goto cleanup;
+            /* next tag */
+            pTag += len;
+            if (*pTag) {
+                /* next to the separator */
+                pTag++;
+            }
         }
 
-        kwd->key = LOCALE_ATTRIBUTE_KEY;
-        kwd->value = buf;
+        if (attrFirst) {
+            /* emit attributes as an LDML keyword, e.g. attribute=attr1-attr2 */
 
-        /* attribute subtags sorted in alphabetical order as type */
-        attr = attrFirst;
-        while (attr != NULL) {
-            nextAttr = attr->next;
-
-            /* buffer size check is done above */
-            if (attr != attrFirst) {
-                *(buf + bufIdx) = SEP;
-                bufIdx++;
+            kwd = extPool.create();
+            if (kwd == NULL) {
+                *status = U_MEMORY_ALLOCATION_ERROR;
+                return;
             }
 
-            len = static_cast<int32_t>(uprv_strlen(attr->attribute));
-            uprv_memcpy(buf + bufIdx, attr->attribute, len);
-            bufIdx += len;
+            icu::CharString* value = kwdBuf.create();
+            if (value == NULL) {
+                *status = U_MEMORY_ALLOCATION_ERROR;
+                return;
+            }
 
-            attr = nextAttr;
-        }
-        *(buf + bufIdx) = 0;
-        bufIdx++;
+            /* attribute subtags sorted in alphabetical order as type */
+            attr = attrFirst;
+            while (attr != NULL) {
+                nextAttr = attr->next;
+                if (attr != attrFirst) {
+                    value->append('-', *status);
+                }
+                value->append(attr->attribute, *status);
+                attr = nextAttr;
+            }
+            if (U_FAILURE(*status)) {
+                return;
+            }
 
-        if (!_addExtensionToList(&kwdFirst, kwd, FALSE)) {
-            *status = U_ILLEGAL_ARGUMENT_ERROR;
-            uprv_free(kwd);
-            goto cleanup;
-        }
+            kwd->key = LOCALE_ATTRIBUTE_KEY;
+            kwd->value = value->data();
 
-        /* once keyword entry is created, delete the attribute list */
-        attr = attrFirst;
-        while (attr != NULL) {
-            nextAttr = attr->next;
-            uprv_free(attr);
-            attr = nextAttr;
+            if (!_addExtensionToList(&kwdFirst, kwd, FALSE)) {
+                *status = U_ILLEGAL_ARGUMENT_ERROR;
+                return;
+            }
         }
-        attrFirst = NULL;
     }
 
     if (pKwds) {
         const char *pBcpKey = NULL;     /* u extenstion key subtag */
         const char *pBcpType = NULL;    /* beginning of u extension type subtag(s) */
@@ -1372,74 +1669,72 @@
                 U_ASSERT(pBcpKey != NULL);
 
                 if (bcpKeyLen >= (int32_t)sizeof(bcpKeyBuf)) {
                     /* the BCP key is invalid */
                     *status = U_ILLEGAL_ARGUMENT_ERROR;
-                    goto cleanup;
+                    return;
                 }
 
                 uprv_strncpy(bcpKeyBuf, pBcpKey, bcpKeyLen);
                 bcpKeyBuf[bcpKeyLen] = 0;
 
                 /* u extension key to LDML key */
                 pKey = uloc_toLegacyKey(bcpKeyBuf);
                 if (pKey == NULL) {
                     *status = U_ILLEGAL_ARGUMENT_ERROR;
-                    goto cleanup;
+                    return;
                 }
                 if (pKey == bcpKeyBuf) {
                     /*
                     The key returned by toLegacyKey points to the input buffer.
                     We normalize the result key to lower case.
                     */
                     T_CString_toLowerCase(bcpKeyBuf);
-                    if (bufSize - bufIdx - 1 >= bcpKeyLen) {
-                        uprv_memcpy(buf + bufIdx, bcpKeyBuf, bcpKeyLen);
-                        pKey = buf + bufIdx;
-                        bufIdx += bcpKeyLen;
-                        *(buf + bufIdx) = 0;
-                        bufIdx++;
-                    } else {
-                        *status = U_BUFFER_OVERFLOW_ERROR;
-                        goto cleanup;
+                    icu::CharString* key = kwdBuf.create(bcpKeyBuf, bcpKeyLen, *status);
+                    if (key == NULL) {
+                        *status = U_MEMORY_ALLOCATION_ERROR;
+                        return;
+                    }
+                    if (U_FAILURE(*status)) {
+                        return;
                     }
+                    pKey = key->data();
                 }
 
                 if (pBcpType) {
                     char bcpTypeBuf[128];       /* practically long enough even considering multiple subtag type */
                     if (bcpTypeLen >= (int32_t)sizeof(bcpTypeBuf)) {
                         /* the BCP type is too long */
                         *status = U_ILLEGAL_ARGUMENT_ERROR;
-                        goto cleanup;
+                        return;
                     }
 
                     uprv_strncpy(bcpTypeBuf, pBcpType, bcpTypeLen);
                     bcpTypeBuf[bcpTypeLen] = 0;
 
                     /* BCP type to locale type */
                     pType = uloc_toLegacyType(pKey, bcpTypeBuf);
                     if (pType == NULL) {
                         *status = U_ILLEGAL_ARGUMENT_ERROR;
-                        goto cleanup;
+                        return;
                     }
                     if (pType == bcpTypeBuf) {
                         /*
                         The type returned by toLegacyType points to the input buffer.
                         We normalize the result type to lower case.
                         */
                         /* normalize to lower case */
                         T_CString_toLowerCase(bcpTypeBuf);
-                        if (bufSize - bufIdx - 1 >= bcpTypeLen) {
-                            uprv_memcpy(buf + bufIdx, bcpTypeBuf, bcpTypeLen);
-                            pType = buf + bufIdx;
-                            bufIdx += bcpTypeLen;
-                            *(buf + bufIdx) = 0;
-                            bufIdx++;
-                        } else {
-                            *status = U_BUFFER_OVERFLOW_ERROR;
-                            goto cleanup;
+                        icu::CharString* type = kwdBuf.create(bcpTypeBuf, bcpTypeLen, *status);
+                        if (type == NULL) {
+                            *status = U_MEMORY_ALLOCATION_ERROR;
+                            return;
                         }
+                        if (U_FAILURE(*status)) {
+                            return;
+                        }
+                        pType = type->data();
                     }
                 } else {
                     /* typeless - default type value is "yes" */
                     pType = LOCALE_TYPE_YES;
                 }
@@ -1448,23 +1743,22 @@
                    not as a keyword */
                 if (!variantExists && !uprv_strcmp(pKey, POSIX_KEY) && !uprv_strcmp(pType, POSIX_VALUE) ) {
                     *posixVariant = TRUE;
                 } else {
                     /* create an ExtensionListEntry for this keyword */
-                    kwd = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));
+                    kwd = extPool.create();
                     if (kwd == NULL) {
                         *status = U_MEMORY_ALLOCATION_ERROR;
-                        goto cleanup;
+                        return;
                     }
 
                     kwd->key = pKey;
                     kwd->value = pType;
 
                     if (!_addExtensionToList(&kwdFirst, kwd, FALSE)) {
-                        *status = U_ILLEGAL_ARGUMENT_ERROR;
-                        uprv_free(kwd);
-                        goto cleanup;
+                        // duplicate keyword is allowed, Only the first
+                        // is honored.
                     }
                 }
 
                 pBcpKey = pNextBcpKey;
                 bcpKeyLen = pNextBcpKey != NULL ? nextBcpKeyLen : 0;
@@ -1478,50 +1772,26 @@
     while (kwd != NULL) {
         nextKwd = kwd->next;
         _addExtensionToList(appendTo, kwd, FALSE);
         kwd = nextKwd;
     }
-
-    return;
-
-cleanup:
-    attr = attrFirst;
-    while (attr != NULL) {
-        nextAttr = attr->next;
-        uprv_free(attr);
-        attr = nextAttr;
-    }
-
-    kwd = kwdFirst;
-    while (kwd != NULL) {
-        nextKwd = kwd->next;
-        uprv_free(kwd);
-        kwd = nextKwd;
-    }
 }
 
 
-static int32_t
-_appendKeywords(ULanguageTag* langtag, char* appendAt, int32_t capacity, UErrorCode* status) {
-    int32_t reslen = 0;
+static void
+_appendKeywords(ULanguageTag* langtag, icu::ByteSink& sink, UErrorCode* status) {
     int32_t i, n;
     int32_t len;
     ExtensionListEntry *kwdFirst = NULL;
     ExtensionListEntry *kwd;
     const char *key, *type;
-    char *kwdBuf = NULL;
-    int32_t kwdBufLength = capacity;
+    icu::MemoryPool<ExtensionListEntry> extPool;
+    icu::MemoryPool<icu::CharString> kwdBuf;
     UBool posixVariant = FALSE;
 
     if (U_FAILURE(*status)) {
-        return 0;
-    }
-
-    kwdBuf = (char*)uprv_malloc(kwdBufLength);
-    if (kwdBuf == NULL) {
-        *status = U_MEMORY_ALLOCATION_ERROR;
-        return 0;
+        return;
     }
 
     /* Determine if variants already exists */
     if (ultag_getVariantsSize(langtag)) {
         posixVariant = TRUE;
@@ -1532,135 +1802,99 @@
     /* resolve locale keywords and reordering keys */
     for (i = 0; i < n; i++) {
         key = ultag_getExtensionKey(langtag, i);
         type = ultag_getExtensionValue(langtag, i);
         if (*key == LDMLEXT) {
-            _appendLDMLExtensionAsKeywords(type, &kwdFirst, kwdBuf, kwdBufLength, &posixVariant, status);
+            _appendLDMLExtensionAsKeywords(type, &kwdFirst, extPool, kwdBuf, &posixVariant, status);
             if (U_FAILURE(*status)) {
                 break;
             }
         } else {
-            kwd = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));
+            kwd = extPool.create();
             if (kwd == NULL) {
                 *status = U_MEMORY_ALLOCATION_ERROR;
                 break;
             }
             kwd->key = key;
             kwd->value = type;
             if (!_addExtensionToList(&kwdFirst, kwd, FALSE)) {
-                uprv_free(kwd);
                 *status = U_ILLEGAL_ARGUMENT_ERROR;
                 break;
             }
         }
     }
 
     if (U_SUCCESS(*status)) {
         type = ultag_getPrivateUse(langtag);
         if ((int32_t)uprv_strlen(type) > 0) {
             /* add private use as a keyword */
-            kwd = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));
+            kwd = extPool.create();
             if (kwd == NULL) {
                 *status = U_MEMORY_ALLOCATION_ERROR;
             } else {
                 kwd->key = PRIVATEUSE_KEY;
                 kwd->value = type;
                 if (!_addExtensionToList(&kwdFirst, kwd, FALSE)) {
-                    uprv_free(kwd);
                     *status = U_ILLEGAL_ARGUMENT_ERROR;
                 }
             }
         }
     }
 
     /* If a POSIX variant was in the extensions, write it out before writing the keywords. */
 
     if (U_SUCCESS(*status) && posixVariant) {
         len = (int32_t) uprv_strlen(_POSIX);
-        if (reslen < capacity) {
-            uprv_memcpy(appendAt + reslen, _POSIX, uprv_min(len, capacity - reslen));
-        }
-        reslen += len;
+        sink.Append(_POSIX, len);
     }
 
     if (U_SUCCESS(*status) && kwdFirst != NULL) {
         /* write out the sorted keywords */
         UBool firstValue = TRUE;
         kwd = kwdFirst;
         do {
-            if (reslen < capacity) {
-                if (firstValue) {
-                    /* '@' */
-                    *(appendAt + reslen) = LOCALE_EXT_SEP;
-                    firstValue = FALSE;
-                } else {
-                    /* ';' */
-                    *(appendAt + reslen) = LOCALE_KEYWORD_SEP;
-                }
+            if (firstValue) {
+                sink.Append("@", 1);
+                firstValue = FALSE;
+            } else {
+                sink.Append(";", 1);
             }
-            reslen++;
 
             /* key */
             len = (int32_t)uprv_strlen(kwd->key);
-            if (reslen < capacity) {
-                uprv_memcpy(appendAt + reslen, kwd->key, uprv_min(len, capacity - reslen));
-            }
-            reslen += len;
-
-            /* '=' */
-            if (reslen < capacity) {
-                *(appendAt + reslen) = LOCALE_KEY_TYPE_SEP;
-            }
-            reslen++;
+            sink.Append(kwd->key, len);
+            sink.Append("=", 1);
 
             /* type */
             len = (int32_t)uprv_strlen(kwd->value);
-            if (reslen < capacity) {
-                uprv_memcpy(appendAt + reslen, kwd->value, uprv_min(len, capacity - reslen));
-            }
-            reslen += len;
+            sink.Append(kwd->value, len);
 
             kwd = kwd->next;
         } while (kwd);
     }
-
-    /* clean up */
-    kwd = kwdFirst;
-    while (kwd != NULL) {
-        ExtensionListEntry *tmpKwd = kwd->next;
-        uprv_free(kwd);
-        kwd = tmpKwd;
-    }
-
-    uprv_free(kwdBuf);
-
-    if (U_FAILURE(*status)) {
-        return 0;
-    }
-
-    return u_terminateChars(appendAt, capacity, reslen, status);
 }
 
-static int32_t
-_appendPrivateuseToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UBool hadPosix, UErrorCode* status) {
+static void
+_appendPrivateuseToLanguageTag(const char* localeID, icu::ByteSink& sink, UBool strict, UBool hadPosix, UErrorCode* status) {
     (void)hadPosix;
     char buf[ULOC_FULLNAME_CAPACITY];
     char tmpAppend[ULOC_FULLNAME_CAPACITY];
     UErrorCode tmpStatus = U_ZERO_ERROR;
     int32_t len, i;
     int32_t reslen = 0;
+    int32_t capacity = sizeof tmpAppend;
 
     if (U_FAILURE(*status)) {
-        return 0;
+        return;
     }
 
     len = uloc_getVariant(localeID, buf, sizeof(buf), &tmpStatus);
     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
         if (strict) {
             *status = U_ILLEGAL_ARGUMENT_ERROR;
         }
-        return 0;
+        return;
     }
 
     if (len > 0) {
         char *p, *pPriv;
         UBool bNext = TRUE;
@@ -1740,24 +1974,18 @@
             }
             p++;
         }
 
         if (U_FAILURE(*status)) {
-            return 0;
+            return;
         }
     }
 
     if (U_SUCCESS(*status)) {
         len = reslen;
-        if (reslen < capacity) {
-            uprv_memcpy(appendAt, tmpAppend, uprv_min(len, capacity - reslen));
-        }
+        sink.Append(tmpAppend, len);
     }
-
-    u_terminateChars(appendAt, capacity, reslen, status);
-
-    return reslen;
 }
 
 /*
 * -------------------------------------------------
 *
@@ -1785,11 +2013,10 @@
 #pragma optimize( "", off )
 #endif
 
 static ULanguageTag*
 ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* status) {
-    ULanguageTag *t;
     char *tagBuf;
     int16_t next;
     char *pSubtag, *pNext, *pLastGoodPosition;
     int32_t subtagLen;
     int32_t extlangIdx;
@@ -1819,47 +2046,94 @@
     }
     uprv_memcpy(tagBuf, tag, tagLen);
     *(tagBuf + tagLen) = 0;
 
     /* create a ULanguageTag */
-    t = (ULanguageTag*)uprv_malloc(sizeof(ULanguageTag));
-    if (t == NULL) {
+    icu::LocalULanguageTagPointer t(
+            (ULanguageTag*)uprv_malloc(sizeof(ULanguageTag)));
+    if (t.isNull()) {
         uprv_free(tagBuf);
         *status = U_MEMORY_ALLOCATION_ERROR;
         return NULL;
     }
-    _initializeULanguageTag(t);
+    _initializeULanguageTag(t.getAlias());
     t->buf = tagBuf;
 
     if (tagLen < MINLEN) {
         /* the input tag is too short - return empty ULanguageTag */
-        return t;
+        return t.orphan();
     }
 
+    size_t parsedLenDelta = 0;
+    // Grandfathered tag will be consider together. Grandfathered tag with intervening
+    // script and region such as art-DE-lojban or art-Latn-lojban won't be
+    // matched.
     /* check if the tag is grandfathered */
-    for (i = 0; GRANDFATHERED[i] != NULL; i += 2) {
-        if (uprv_stricmp(GRANDFATHERED[i], tagBuf) == 0) {
+    for (i = 0; i < UPRV_LENGTHOF(GRANDFATHERED); i += 2) {
+        int32_t checkGrandfatheredLen = static_cast<int32_t>(uprv_strlen(GRANDFATHERED[i]));
+        if (tagLen < checkGrandfatheredLen) {
+            continue;
+        }
+        if (tagLen > checkGrandfatheredLen && tagBuf[checkGrandfatheredLen] != '-') {
+            // make sure next char is '-'.
+            continue;
+        }
+        if (uprv_strnicmp(GRANDFATHERED[i], tagBuf, checkGrandfatheredLen) == 0) {
             int32_t newTagLength;
 
-            grandfatheredLen = tagLen;  /* back up for output parsedLen */
-            newTagLength = static_cast<int32_t>(uprv_strlen(GRANDFATHERED[i+1]));
+            grandfatheredLen = checkGrandfatheredLen;  /* back up for output parsedLen */
+            int32_t replacementLen = static_cast<int32_t>(uprv_strlen(GRANDFATHERED[i+1]));
+            newTagLength = replacementLen + tagLen - checkGrandfatheredLen;
             if (tagLen < newTagLength) {
                 uprv_free(tagBuf);
                 tagBuf = (char*)uprv_malloc(newTagLength + 1);
                 if (tagBuf == NULL) {
                     *status = U_MEMORY_ALLOCATION_ERROR;
-                    ultag_close(t);
                     return NULL;
                 }
                 t->buf = tagBuf;
                 tagLen = newTagLength;
             }
+            parsedLenDelta = checkGrandfatheredLen - replacementLen;
             uprv_strcpy(t->buf, GRANDFATHERED[i + 1]);
+            if (checkGrandfatheredLen != tagLen) {
+                uprv_strcpy(t->buf + replacementLen, tag + checkGrandfatheredLen);
+            }
             break;
         }
     }
 
+    if (grandfatheredLen == 0) {
+        for (i = 0; i < UPRV_LENGTHOF(REDUNDANT); i += 2) {
+            const char* redundantTag = REDUNDANT[i];
+            size_t redundantTagLen = uprv_strlen(redundantTag);
+            // The preferred tag for a redundant tag is always shorter than redundant
+            // tag. A redundant tag may or may not be followed by other subtags.
+            // (i.e. "zh-yue" or "zh-yue-u-co-pinyin").
+            if (uprv_strnicmp(redundantTag, tagBuf, static_cast<uint32_t>(redundantTagLen)) == 0) {
+                const char* redundantTagEnd = tagBuf + redundantTagLen;
+                if (*redundantTagEnd  == '\0' || *redundantTagEnd == SEP) {
+                    const char* preferredTag = REDUNDANT[i + 1];
+                    size_t preferredTagLen = uprv_strlen(preferredTag);
+                    uprv_strncpy(t->buf, preferredTag, preferredTagLen);
+                    if (*redundantTagEnd == SEP) {
+                        uprv_memmove(tagBuf + preferredTagLen,
+                                     redundantTagEnd,
+                                     tagLen - redundantTagLen + 1);
+                    } else {
+                        tagBuf[preferredTagLen] = '\0';
+                    }
+                    // parsedLen should be the length of the input
+                    // before redundantTag is replaced by preferredTag.
+                    // Save the delta to add it back later.
+                    parsedLenDelta = redundantTagLen - preferredTagLen;
+                    break;
+                }
+            }
+        }
+    }
+
     /*
      * langtag      =   language
      *                  ["-" script]
      *                  ["-" region]
      *                  *("-" variant)
@@ -1894,16 +2168,19 @@
             pNext = pSep + 1;
         }
         subtagLen = (int32_t)(pSep - pSubtag);
 
         if (next & LANG) {
-            if (_isLanguageSubtag(pSubtag, subtagLen)) {
+            if (ultag_isLanguageSubtag(pSubtag, subtagLen)) {
                 *pSep = 0;  /* terminate */
+                // TODO: move deprecated language code handling here.
                 t->language = T_CString_toLowerCase(pSubtag);
 
                 pLastGoodPosition = pSep;
-                next = EXTL | SCRT | REGN | VART | EXTS | PRIV;
+                next = SCRT | REGN | VART | EXTS | PRIV;
+                if (subtagLen <= 3)
+                  next |= EXTL;
                 continue;
             }
         }
         if (next & EXTL) {
             if (_isExtlangSubtag(pSubtag, subtagLen)) {
@@ -1918,11 +2195,11 @@
                 }
                 continue;
             }
         }
         if (next & SCRT) {
-            if (_isScriptSubtag(pSubtag, subtagLen)) {
+            if (ultag_isScriptSubtag(pSubtag, subtagLen)) {
                 char *p = pSubtag;
 
                 *pSep = 0;
 
                 /* to title case */
@@ -1938,12 +2215,13 @@
                 next = REGN | VART | EXTS | PRIV;
                 continue;
             }
         }
         if (next & REGN) {
-            if (_isRegionSubtag(pSubtag, subtagLen)) {
+            if (ultag_isRegionSubtag(pSubtag, subtagLen)) {
                 *pSep = 0;
+                // TODO: move deprecated region code handling here.
                 t->region = T_CString_toUpperCase(pSubtag);
 
                 pLastGoodPosition = pSep;
                 next = VART | EXTS | PRIV;
                 continue;
@@ -1956,11 +2234,11 @@
                 UBool isAdded;
 
                 var = (VariantListEntry*)uprv_malloc(sizeof(VariantListEntry));
                 if (var == NULL) {
                     *status = U_MEMORY_ALLOCATION_ERROR;
-                    goto error;
+                    return NULL;
                 }
                 *pSep = 0;
                 var->variant = T_CString_toUpperCase(pSubtag);
                 isAdded = _addVariantToList(&(t->variants), var);
                 if (!isAdded) {
@@ -2000,11 +2278,11 @@
 
                 /* create a new extension */
                 pExtension = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));
                 if (pExtension == NULL) {
                     *status = U_MEMORY_ALLOCATION_ERROR;
-                    goto error;
+                    return NULL;
                 }
                 *pSep = 0;
                 pExtension->key = T_CString_toLowerCase(pSubtag);
                 pExtension->value = NULL;   /* will be set later */
 
@@ -2033,11 +2311,11 @@
 
                 continue;
             }
         }
         if (next & PRIV) {
-            if (uprv_tolower(*pSubtag) == PRIVATEUSE) {
+            if (uprv_tolower(*pSubtag) == PRIVATEUSE && subtagLen == 1) {
                 char *pPrivuseVal;
 
                 if (pExtension != NULL) {
                     /* Process the last extension */
                     if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
@@ -2136,18 +2414,14 @@
             }
         }
     }
 
     if (parsedLen != NULL) {
-        *parsedLen = (grandfatheredLen > 0) ? grandfatheredLen : (int32_t)(pLastGoodPosition - t->buf);
+        *parsedLen = (int32_t)(pLastGoodPosition - t->buf + parsedLenDelta);
     }
 
-    return t;
-
-error:
-    ultag_close(t);
-    return NULL;
+    return t.orphan();
 }
 
 /**
 * Ticket #12705 - Turn optimization back on.
 */
@@ -2333,53 +2607,111 @@
 uloc_toLanguageTag(const char* localeID,
                    char* langtag,
                    int32_t langtagCapacity,
                    UBool strict,
                    UErrorCode* status) {
-    /* char canonical[ULOC_FULLNAME_CAPACITY]; */ /* See #6822 */
-    char canonical[256];
-    int32_t reslen = 0;
+    if (U_FAILURE(*status)) {
+        return 0;
+    }
+
+    icu::CheckedArrayByteSink sink(langtag, langtagCapacity);
+    ulocimp_toLanguageTag(localeID, sink, strict, status);
+
+    int32_t reslen = sink.NumberOfBytesAppended();
+
+    if (U_FAILURE(*status)) {
+        return reslen;
+    }
+
+    if (sink.Overflowed()) {
+        *status = U_BUFFER_OVERFLOW_ERROR;
+    } else {
+        u_terminateChars(langtag, langtagCapacity, reslen, status);
+    }
+
+    return reslen;
+}
+
+
+U_CAPI void U_EXPORT2
+ulocimp_toLanguageTag(const char* localeID,
+                      icu::ByteSink& sink,
+                      UBool strict,
+                      UErrorCode* status) {
+    icu::CharString canonical;
+    int32_t reslen;
     UErrorCode tmpStatus = U_ZERO_ERROR;
     UBool hadPosix = FALSE;
     const char* pKeywordStart;
 
     /* Note: uloc_canonicalize returns "en_US_POSIX" for input locale ID "".  See #6835 */
-    canonical[0] = 0;
-    if (uprv_strlen(localeID) > 0) {
-        uloc_canonicalize(localeID, canonical, sizeof(canonical), &tmpStatus);
-        if (tmpStatus != U_ZERO_ERROR) {
+    int32_t resultCapacity = static_cast<int32_t>(uprv_strlen(localeID));
+    if (resultCapacity > 0) {
+        char* buffer;
+
+        for (;;) {
+            buffer = canonical.getAppendBuffer(
+                    /*minCapacity=*/resultCapacity,
+                    /*desiredCapacityHint=*/resultCapacity,
+                    resultCapacity,
+                    tmpStatus);
+
+            if (U_FAILURE(tmpStatus)) {
+                *status = tmpStatus;
+                return;
+            }
+
+            reslen =
+                uloc_canonicalize(localeID, buffer, resultCapacity, &tmpStatus);
+
+            if (tmpStatus != U_BUFFER_OVERFLOW_ERROR) {
+                break;
+            }
+
+            resultCapacity = reslen;
+            tmpStatus = U_ZERO_ERROR;
+        }
+
+        if (U_FAILURE(tmpStatus)) {
             *status = U_ILLEGAL_ARGUMENT_ERROR;
-            return 0;
+            return;
+        }
+
+        canonical.append(buffer, reslen, tmpStatus);
+        if (tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
+            tmpStatus = U_ZERO_ERROR;  // Terminators provided by CharString.
+        }
+
+        if (U_FAILURE(tmpStatus)) {
+            *status = tmpStatus;
+            return;
         }
     }
 
     /* For handling special case - private use only tag */
-    pKeywordStart = locale_getKeywordsStart(canonical);
-    if (pKeywordStart == canonical) {
-        UEnumeration *kwdEnum;
+    pKeywordStart = locale_getKeywordsStart(canonical.data());
+    if (pKeywordStart == canonical.data()) {
         int kwdCnt = 0;
         UBool done = FALSE;
 
-        kwdEnum = uloc_openKeywords((const char*)canonical, &tmpStatus);
-        if (kwdEnum != NULL) {
-            kwdCnt = uenum_count(kwdEnum, &tmpStatus);
+        icu::LocalUEnumerationPointer kwdEnum(uloc_openKeywords(canonical.data(), &tmpStatus));
+        if (U_SUCCESS(tmpStatus)) {
+            kwdCnt = uenum_count(kwdEnum.getAlias(), &tmpStatus);
             if (kwdCnt == 1) {
                 const char *key;
                 int32_t len = 0;
 
-                key = uenum_next(kwdEnum, &len, &tmpStatus);
+                key = uenum_next(kwdEnum.getAlias(), &len, &tmpStatus);
                 if (len == 1 && *key == PRIVATEUSE) {
                     char buf[ULOC_KEYWORD_AND_VALUES_CAPACITY];
                     buf[0] = PRIVATEUSE;
                     buf[1] = SEP;
                     len = uloc_getKeywordValue(localeID, key, &buf[2], sizeof(buf) - 2, &tmpStatus);
                     if (U_SUCCESS(tmpStatus)) {
-                        if (_isPrivateuseValueSubtags(&buf[2], len)) {
+                        if (ultag_isPrivateuseValueSubtags(&buf[2], len)) {
                             /* return private use only tag */
-                            reslen = len + 2;
-                            uprv_memcpy(langtag, buf, uprv_min(reslen, langtagCapacity));
-                            u_terminateChars(langtag, langtagCapacity, reslen, status);
+                            sink.Append(buf, len + 2);
                             done = TRUE;
                         } else if (strict) {
                             *status = U_ILLEGAL_ARGUMENT_ERROR;
                             done = TRUE;
                         }
@@ -2388,145 +2720,139 @@
                         *status = U_ILLEGAL_ARGUMENT_ERROR;
                         done = TRUE;
                     }
                 }
             }
-            uenum_close(kwdEnum);
             if (done) {
-                return reslen;
+                return;
             }
         }
     }
 
-    reslen += _appendLanguageToLanguageTag(canonical, langtag, langtagCapacity, strict, status);
-    reslen += _appendScriptToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, status);
-    reslen += _appendRegionToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, status);
-    reslen += _appendVariantsToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, &hadPosix, status);
-    reslen += _appendKeywordsToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, hadPosix, status);
-    reslen += _appendPrivateuseToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, hadPosix, status);
-
-    return reslen;
+    _appendLanguageToLanguageTag(canonical.data(), sink, strict, status);
+    _appendScriptToLanguageTag(canonical.data(), sink, strict, status);
+    _appendRegionToLanguageTag(canonical.data(), sink, strict, status);
+    _appendVariantsToLanguageTag(canonical.data(), sink, strict, &hadPosix, status);
+    _appendKeywordsToLanguageTag(canonical.data(), sink, strict, hadPosix, status);
+    _appendPrivateuseToLanguageTag(canonical.data(), sink, strict, hadPosix, status);
 }
 
 
 U_CAPI int32_t U_EXPORT2
 uloc_forLanguageTag(const char* langtag,
                     char* localeID,
                     int32_t localeIDCapacity,
                     int32_t* parsedLength,
                     UErrorCode* status) {
-    ULanguageTag *lt;
-    int32_t reslen = 0;
+    if (U_FAILURE(*status)) {
+        return 0;
+    }
+
+    icu::CheckedArrayByteSink sink(localeID, localeIDCapacity);
+    ulocimp_forLanguageTag(langtag, -1, sink, parsedLength, status);
+
+    int32_t reslen = sink.NumberOfBytesAppended();
+
+    if (U_FAILURE(*status)) {
+        return reslen;
+    }
+
+    if (sink.Overflowed()) {
+        *status = U_BUFFER_OVERFLOW_ERROR;
+    } else {
+        u_terminateChars(localeID, localeIDCapacity, reslen, status);
+    }
+
+    return reslen;
+}
+
+
+U_CAPI void U_EXPORT2
+ulocimp_forLanguageTag(const char* langtag,
+                       int32_t tagLen,
+                       icu::ByteSink& sink,
+                       int32_t* parsedLength,
+                       UErrorCode* status) {
+    UBool isEmpty = TRUE;
     const char *subtag, *p;
     int32_t len;
     int32_t i, n;
     UBool noRegion = TRUE;
 
-    lt = ultag_parse(langtag, -1, parsedLength, status);
+    icu::LocalULanguageTagPointer lt(ultag_parse(langtag, tagLen, parsedLength, status));
     if (U_FAILURE(*status)) {
-        return 0;
+        return;
     }
 
     /* language */
-    subtag = ultag_getExtlangSize(lt) > 0 ? ultag_getExtlang(lt, 0) : ultag_getLanguage(lt);
+    subtag = ultag_getExtlangSize(lt.getAlias()) > 0 ? ultag_getExtlang(lt.getAlias(), 0) : ultag_getLanguage(lt.getAlias());
     if (uprv_compareInvCharsAsAscii(subtag, LANG_UND) != 0) {
         len = (int32_t)uprv_strlen(subtag);
         if (len > 0) {
-            if (reslen < localeIDCapacity) {
-                uprv_memcpy(localeID, subtag, uprv_min(len, localeIDCapacity - reslen));
-            }
-            reslen += len;
+            sink.Append(subtag, len);
+            isEmpty = FALSE;
         }
     }
 
     /* script */
-    subtag = ultag_getScript(lt);
+    subtag = ultag_getScript(lt.getAlias());
     len = (int32_t)uprv_strlen(subtag);
     if (len > 0) {
-        if (reslen < localeIDCapacity) {
-            *(localeID + reslen) = LOCALE_SEP;
-        }
-        reslen++;
+        sink.Append("_", 1);
+        isEmpty = FALSE;
 
         /* write out the script in title case */
-        p = subtag;
-        while (*p) {
-            if (reslen < localeIDCapacity) {
-                if (p == subtag) {
-                    *(localeID + reslen) = uprv_toupper(*p);
-                } else {
-                    *(localeID + reslen) = *p;
-                }
-            }
-            reslen++;
-            p++;
-        }
+        char c = uprv_toupper(*subtag);
+        sink.Append(&c, 1);
+        sink.Append(subtag + 1, len - 1);
     }
 
     /* region */
-    subtag = ultag_getRegion(lt);
+    subtag = ultag_getRegion(lt.getAlias());
     len = (int32_t)uprv_strlen(subtag);
     if (len > 0) {
-        if (reslen < localeIDCapacity) {
-            *(localeID + reslen) = LOCALE_SEP;
-        }
-        reslen++;
-        /* write out the retion in upper case */
+        sink.Append("_", 1);
+        isEmpty = FALSE;
+
+        /* write out the region in upper case */
         p = subtag;
         while (*p) {
-            if (reslen < localeIDCapacity) {
-                *(localeID + reslen) = uprv_toupper(*p);
-            }
-            reslen++;
+            char c = uprv_toupper(*p);
+            sink.Append(&c, 1);
             p++;
         }
         noRegion = FALSE;
     }
 
     /* variants */
-    n = ultag_getVariantsSize(lt);
+    n = ultag_getVariantsSize(lt.getAlias());
     if (n > 0) {
         if (noRegion) {
-            if (reslen < localeIDCapacity) {
-                *(localeID + reslen) = LOCALE_SEP;
-            }
-            reslen++;
+            sink.Append("_", 1);
+            isEmpty = FALSE;
         }
 
         for (i = 0; i < n; i++) {
-            subtag = ultag_getVariant(lt, i);
-            if (reslen < localeIDCapacity) {
-                *(localeID + reslen) = LOCALE_SEP;
-            }
-            reslen++;
+            subtag = ultag_getVariant(lt.getAlias(), i);
+            sink.Append("_", 1);
+
             /* write out the variant in upper case */
             p = subtag;
             while (*p) {
-                if (reslen < localeIDCapacity) {
-                    *(localeID + reslen) = uprv_toupper(*p);
-                }
-                reslen++;
+                char c = uprv_toupper(*p);
+                sink.Append(&c, 1);
                 p++;
             }
         }
     }
 
     /* keywords */
-    n = ultag_getExtensionsSize(lt);
-    subtag = ultag_getPrivateUse(lt);
+    n = ultag_getExtensionsSize(lt.getAlias());
+    subtag = ultag_getPrivateUse(lt.getAlias());
     if (n > 0 || uprv_strlen(subtag) > 0) {
-        if (reslen == 0 && n > 0) {
+        if (isEmpty && n > 0) {
             /* need a language */
-            if (reslen < localeIDCapacity) {
-                uprv_memcpy(localeID + reslen, LANG_UND, uprv_min(LANG_UND_LEN, localeIDCapacity - reslen));
-            }
-            reslen += LANG_UND_LEN;
+            sink.Append(LANG_UND, LANG_UND_LEN);
         }
-        len = _appendKeywords(lt, localeID + reslen, localeIDCapacity - reslen, status);
-        reslen += len;
+        _appendKeywords(lt.getAlias(), sink, status);
     }
-
-    ultag_close(lt);
-    return u_terminateChars(localeID, localeIDCapacity, reslen, status);
 }
-
-
