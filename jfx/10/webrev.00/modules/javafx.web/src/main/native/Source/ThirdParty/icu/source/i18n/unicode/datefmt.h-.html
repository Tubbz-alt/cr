<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/datefmt.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4  ********************************************************************************
  5  *   Copyright (C) 1997-2016, International Business Machines
  6  *   Corporation and others.  All Rights Reserved.
  7  ********************************************************************************
  8  *
  9  * File DATEFMT.H
 10  *
 11  * Modification History:
 12  *
 13  *   Date        Name        Description
 14  *   02/19/97    aliu        Converted from java.
 15  *   04/01/97    aliu        Added support for centuries.
 16  *   07/23/98    stephen     JDK 1.2 sync
 17  *   11/15/99    weiv        Added support for week of year/day of week formatting
 18  ********************************************************************************
 19  */
 20 
 21 #ifndef DATEFMT_H
 22 #define DATEFMT_H
 23 
 24 #include &quot;unicode/utypes.h&quot;
 25 
 26 #if !UCONFIG_NO_FORMATTING
 27 
 28 #include &quot;unicode/udat.h&quot;
 29 #include &quot;unicode/calendar.h&quot;
 30 #include &quot;unicode/numfmt.h&quot;
 31 #include &quot;unicode/format.h&quot;
 32 #include &quot;unicode/locid.h&quot;
 33 #include &quot;unicode/enumset.h&quot;
 34 #include &quot;unicode/udisplaycontext.h&quot;
 35 
 36 /**
 37  * \file
 38  * \brief C++ API: Abstract class for converting dates.
 39  */
 40 
 41 U_NAMESPACE_BEGIN
 42 
 43 class TimeZone;
 44 class DateTimePatternGenerator;
 45 
 46 // explicit template instantiation. see digitlst.h
 47 // (When building DLLs for Windows this is required.)
 48 #if U_PF_WINDOWS &lt;= U_PLATFORM &amp;&amp; U_PLATFORM &lt;= U_PF_CYGWIN
 49 template class U_I18N_API EnumSet&lt;UDateFormatBooleanAttribute,
 50             0,
 51             UDAT_BOOLEAN_ATTRIBUTE_COUNT&gt;;
 52 #endif
 53 
 54 /**
 55  * DateFormat is an abstract class for a family of classes that convert dates and
 56  * times from their internal representations to textual form and back again in a
 57  * language-independent manner. Converting from the internal representation (milliseconds
 58  * since midnight, January 1, 1970) to text is known as &quot;formatting,&quot; and converting
 59  * from text to millis is known as &quot;parsing.&quot;  We currently define only one concrete
 60  * subclass of DateFormat: SimpleDateFormat, which can handle pretty much all normal
 61  * date formatting and parsing actions.
 62  * &lt;P&gt;
 63  * DateFormat helps you to format and parse dates for any locale. Your code can
 64  * be completely independent of the locale conventions for months, days of the
 65  * week, or even the calendar format: lunar vs. solar.
 66  * &lt;P&gt;
 67  * To format a date for the current Locale, use one of the static factory
 68  * methods:
 69  * &lt;pre&gt;
 70  * \code
 71  *      DateFormat* dfmt = DateFormat::createDateInstance();
 72  *      UDate myDate = Calendar::getNow();
 73  *      UnicodeString myString;
 74  *      myString = dfmt-&gt;format( myDate, myString );
 75  * \endcode
 76  * &lt;/pre&gt;
 77  * If you are formatting multiple numbers, it is more efficient to get the
 78  * format and use it multiple times so that the system doesn&#39;t have to fetch the
 79  * information about the local language and country conventions multiple times.
 80  * &lt;pre&gt;
 81  * \code
 82  *      DateFormat* df = DateFormat::createDateInstance();
 83  *      UnicodeString myString;
 84  *      UDate myDateArr[] = { 0.0, 100000000.0, 2000000000.0 }; // test values
 85  *      for (int32_t i = 0; i &lt; 3; ++i) {
 86  *          myString.remove();
 87  *          cout &lt;&lt; df-&gt;format( myDateArr[i], myString ) &lt;&lt; endl;
 88  *      }
 89  * \endcode
 90  * &lt;/pre&gt;
 91  * To get specific fields of a date, you can use UFieldPosition to
 92  * get specific fields.
 93  * &lt;pre&gt;
 94  * \code
 95  *      DateFormat* dfmt = DateFormat::createDateInstance();
 96  *      FieldPosition pos(DateFormat::YEAR_FIELD);
 97  *      UnicodeString myString;
 98  *      myString = dfmt-&gt;format( myDate, myString );
 99  *      cout &lt;&lt; myString &lt;&lt; endl;
100  *      cout &lt;&lt; pos.getBeginIndex() &lt;&lt; &quot;,&quot; &lt;&lt; pos. getEndIndex() &lt;&lt; endl;
101  * \endcode
102  * &lt;/pre&gt;
103  * To format a date for a different Locale, specify it in the call to
104  * createDateInstance().
105  * &lt;pre&gt;
106  * \code
107  *       DateFormat* df =
108  *           DateFormat::createDateInstance( DateFormat::SHORT, Locale::getFrance());
109  * \endcode
110  * &lt;/pre&gt;
111  * You can use a DateFormat to parse also.
112  * &lt;pre&gt;
113  * \code
114  *       UErrorCode status = U_ZERO_ERROR;
115  *       UDate myDate = df-&gt;parse(myString, status);
116  * \endcode
117  * &lt;/pre&gt;
118  * Use createDateInstance() to produce the normal date format for that country.
119  * There are other static factory methods available. Use createTimeInstance()
120  * to produce the normal time format for that country. Use createDateTimeInstance()
121  * to produce a DateFormat that formats both date and time. You can pass in
122  * different options to these factory methods to control the length of the
123  * result; from SHORT to MEDIUM to LONG to FULL. The exact result depends on the
124  * locale, but generally:
125  * &lt;ul type=round&gt;
126  *   &lt;li&gt;   SHORT is completely numeric, such as 12/13/52 or 3:30pm
127  *   &lt;li&gt;   MEDIUM is longer, such as Jan 12, 1952
128  *   &lt;li&gt;   LONG is longer, such as January 12, 1952 or 3:30:32pm
129  *   &lt;li&gt;   FULL is pretty completely specified, such as
130  *          Tuesday, April 12, 1952 AD or 3:30:42pm PST.
131  * &lt;/ul&gt;
132  * You can also set the time zone on the format if you wish. If you want even
133  * more control over the format or parsing, (or want to give your users more
134  * control), you can try casting the DateFormat you get from the factory methods
135  * to a SimpleDateFormat. This will work for the majority of countries; just
136  * remember to chck getDynamicClassID() before carrying out the cast.
137  * &lt;P&gt;
138  * You can also use forms of the parse and format methods with ParsePosition and
139  * FieldPosition to allow you to
140  * &lt;ul type=round&gt;
141  *   &lt;li&gt;   Progressively parse through pieces of a string.
142  *   &lt;li&gt;   Align any particular field, or find out where it is for selection
143  *          on the screen.
144  * &lt;/ul&gt;
145  *
146  * &lt;p&gt;&lt;em&gt;User subclasses are not supported.&lt;/em&gt; While clients may write
147  * subclasses, such code will not necessarily work and will not be
148  * guaranteed to work stably from release to release.
149  */
150 class U_I18N_API DateFormat : public Format {
151 public:
152 
153     /**
154      * Constants for various style patterns. These reflect the order of items in
155      * the DateTimePatterns resource. There are 4 time patterns, 4 date patterns,
156      * the default date-time pattern, and 4 date-time patterns. Each block of 4 values
157      * in the resource occurs in the order full, long, medium, short.
158      * @stable ICU 2.4
159      */
160     enum EStyle
161     {
162         kNone   = -1,
163 
164         kFull   = 0,
165         kLong   = 1,
166         kMedium = 2,
167         kShort  = 3,
168 
169         kDateOffset   = kShort + 1,
170      // kFull   + kDateOffset = 4
171      // kLong   + kDateOffset = 5
172      // kMedium + kDateOffset = 6
173      // kShort  + kDateOffset = 7
174 
175         kDateTime             = 8,
176      // Default DateTime
177 
178         kDateTimeOffset = kDateTime + 1,
179      // kFull   + kDateTimeOffset = 9
180      // kLong   + kDateTimeOffset = 10
181      // kMedium + kDateTimeOffset = 11
182      // kShort  + kDateTimeOffset = 12
183 
184         // relative dates
185         kRelative = (1 &lt;&lt; 7),
186 
187         kFullRelative = (kFull | kRelative),
188 
189         kLongRelative = kLong | kRelative,
190 
191         kMediumRelative = kMedium | kRelative,
192 
193         kShortRelative = kShort | kRelative,
194 
195 
196         kDefault      = kMedium,
197 
198 
199 
200     /**
201      * These constants are provided for backwards compatibility only.
202      * Please use the C++ style constants defined above.
203      */
204         FULL        = kFull,
205         LONG        = kLong,
206         MEDIUM        = kMedium,
207         SHORT        = kShort,
208         DEFAULT        = kDefault,
209         DATE_OFFSET    = kDateOffset,
210         NONE        = kNone,
211         DATE_TIME    = kDateTime
212     };
213 
214     /**
215      * Destructor.
216      * @stable ICU 2.0
217      */
218     virtual ~DateFormat();
219 
220     /**
221      * Equality operator.  Returns true if the two formats have the same behavior.
222      * @stable ICU 2.0
223      */
224     virtual UBool operator==(const Format&amp;) const;
225 
226 
227     using Format::format;
228 
229     /**
230      * Format an object to produce a string. This method handles Formattable
231      * objects with a UDate type. If a the Formattable object type is not a Date,
232      * then it returns a failing UErrorCode.
233      *
234      * @param obj       The object to format. Must be a Date.
235      * @param appendTo  Output parameter to receive result.
236      *                  Result is appended to existing contents.
237      * @param pos       On input: an alignment field, if desired.
238      *                  On output: the offsets of the alignment field.
239      * @param status    Output param filled with success/failure status.
240      * @return          Reference to &#39;appendTo&#39; parameter.
241      * @stable ICU 2.0
242      */
243     virtual UnicodeString&amp; format(const Formattable&amp; obj,
244                                   UnicodeString&amp; appendTo,
245                                   FieldPosition&amp; pos,
246                                   UErrorCode&amp; status) const;
247 
248     /**
249      * Format an object to produce a string. This method handles Formattable
250      * objects with a UDate type. If a the Formattable object type is not a Date,
251      * then it returns a failing UErrorCode.
252      *
253      * @param obj       The object to format. Must be a Date.
254      * @param appendTo  Output parameter to receive result.
255      *                  Result is appended to existing contents.
256      * @param posIter   On return, can be used to iterate over positions
257      *                  of fields generated by this format call.  Field values
258      *                  are defined in UDateFormatField.  Can be NULL.
259      * @param status    Output param filled with success/failure status.
260      * @return          Reference to &#39;appendTo&#39; parameter.
261      * @stable ICU 4.4
262      */
263     virtual UnicodeString&amp; format(const Formattable&amp; obj,
264                                   UnicodeString&amp; appendTo,
265                                   FieldPositionIterator* posIter,
266                                   UErrorCode&amp; status) const;
267     /**
268      * Formats a date into a date/time string. This is an abstract method which
269      * concrete subclasses must implement.
270      * &lt;P&gt;
271      * On input, the FieldPosition parameter may have its &quot;field&quot; member filled with
272      * an enum value specifying a field.  On output, the FieldPosition will be filled
273      * in with the text offsets for that field.
274      * &lt;P&gt; For example, given a time text
275      * &quot;1996.07.10 AD at 15:08:56 PDT&quot;, if the given fieldPosition.field is
276      * UDAT_YEAR_FIELD, the offsets fieldPosition.beginIndex and
277      * statfieldPositionus.getEndIndex will be set to 0 and 4, respectively.
278      * &lt;P&gt; Notice
279      * that if the same time field appears more than once in a pattern, the status will
280      * be set for the first occurence of that time field. For instance,
281      * formatting a UDate to the time string &quot;1 PM PDT (Pacific Daylight Time)&quot;
282      * using the pattern &quot;h a z (zzzz)&quot; and the alignment field
283      * DateFormat::TIMEZONE_FIELD, the offsets fieldPosition.beginIndex and
284      * fieldPosition.getEndIndex will be set to 5 and 8, respectively, for the first
285      * occurence of the timezone pattern character &#39;z&#39;.
286      *
287      * @param cal           Calendar set to the date and time to be formatted
288      *                      into a date/time string.  When the calendar type is
289      *                      different from the internal calendar held by this
290      *                      DateFormat instance, the date and the time zone will
291      *                      be inherited from the input calendar, but other calendar
292      *                      field values will be calculated by the internal calendar.
293      * @param appendTo      Output parameter to receive result.
294      *                      Result is appended to existing contents.
295      * @param fieldPosition On input: an alignment field, if desired (see examples above)
296      *                      On output: the offsets of the alignment field (see examples above)
297      * @return              Reference to &#39;appendTo&#39; parameter.
298      * @stable ICU 2.1
299      */
300     virtual UnicodeString&amp; format(  Calendar&amp; cal,
301                                     UnicodeString&amp; appendTo,
302                                     FieldPosition&amp; fieldPosition) const = 0;
303 
304     /**
305      * Formats a date into a date/time string. Subclasses should implement this method.
306      *
307      * @param cal       Calendar set to the date and time to be formatted
308      *                  into a date/time string.  When the calendar type is
309      *                  different from the internal calendar held by this
310      *                  DateFormat instance, the date and the time zone will
311      *                  be inherited from the input calendar, but other calendar
312      *                  field values will be calculated by the internal calendar.
313      * @param appendTo  Output parameter to receive result.
314      *                  Result is appended to existing contents.
315      * @param posIter   On return, can be used to iterate over positions
316      *                  of fields generated by this format call.  Field values
317      *                  are defined in UDateFormatField.  Can be NULL.
318      * @param status    error status.
319      * @return          Reference to &#39;appendTo&#39; parameter.
320      * @stable ICU 4.4
321      */
322     virtual UnicodeString&amp; format(Calendar&amp; cal,
323                                   UnicodeString&amp; appendTo,
324                                   FieldPositionIterator* posIter,
325                                   UErrorCode&amp; status) const;
326     /**
327      * Formats a UDate into a date/time string.
328      * &lt;P&gt;
329      * On input, the FieldPosition parameter may have its &quot;field&quot; member filled with
330      * an enum value specifying a field.  On output, the FieldPosition will be filled
331      * in with the text offsets for that field.
332      * &lt;P&gt; For example, given a time text
333      * &quot;1996.07.10 AD at 15:08:56 PDT&quot;, if the given fieldPosition.field is
334      * UDAT_YEAR_FIELD, the offsets fieldPosition.beginIndex and
335      * statfieldPositionus.getEndIndex will be set to 0 and 4, respectively.
336      * &lt;P&gt; Notice
337      * that if the same time field appears more than once in a pattern, the status will
338      * be set for the first occurence of that time field. For instance,
339      * formatting a UDate to the time string &quot;1 PM PDT (Pacific Daylight Time)&quot;
340      * using the pattern &quot;h a z (zzzz)&quot; and the alignment field
341      * DateFormat::TIMEZONE_FIELD, the offsets fieldPosition.beginIndex and
342      * fieldPosition.getEndIndex will be set to 5 and 8, respectively, for the first
343      * occurence of the timezone pattern character &#39;z&#39;.
344      *
345      * @param date          UDate to be formatted into a date/time string.
346      * @param appendTo      Output parameter to receive result.
347      *                      Result is appended to existing contents.
348      * @param fieldPosition On input: an alignment field, if desired (see examples above)
349      *                      On output: the offsets of the alignment field (see examples above)
350      * @return              Reference to &#39;appendTo&#39; parameter.
351      * @stable ICU 2.0
352      */
353     UnicodeString&amp; format(  UDate date,
354                             UnicodeString&amp; appendTo,
355                             FieldPosition&amp; fieldPosition) const;
356 
357     /**
358      * Formats a UDate into a date/time string.
359      *
360      * @param date      UDate to be formatted into a date/time string.
361      * @param appendTo  Output parameter to receive result.
362      *                  Result is appended to existing contents.
363      * @param posIter   On return, can be used to iterate over positions
364      *                  of fields generated by this format call.  Field values
365      *                  are defined in UDateFormatField.  Can be NULL.
366      * @param status    error status.
367      * @return          Reference to &#39;appendTo&#39; parameter.
368      * @stable ICU 4.4
369      */
370     UnicodeString&amp; format(UDate date,
371                           UnicodeString&amp; appendTo,
372                           FieldPositionIterator* posIter,
373                           UErrorCode&amp; status) const;
374     /**
375      * Formats a UDate into a date/time string. If there is a problem, you won&#39;t
376      * know, using this method. Use the overloaded format() method which takes a
377      * FieldPosition&amp; to detect formatting problems.
378      *
379      * @param date      The UDate value to be formatted into a string.
380      * @param appendTo  Output parameter to receive result.
381      *                  Result is appended to existing contents.
382      * @return          Reference to &#39;appendTo&#39; parameter.
383      * @stable ICU 2.0
384      */
385     UnicodeString&amp; format(UDate date, UnicodeString&amp; appendTo) const;
386 
387     /**
388      * Parse a date/time string. For example, a time text &quot;07/10/96 4:5 PM, PDT&quot;
389      * will be parsed into a UDate that is equivalent to Date(837039928046).
390      * Parsing begins at the beginning of the string and proceeds as far as
391      * possible.  Assuming no parse errors were encountered, this function
392      * doesn&#39;t return any information about how much of the string was consumed
393      * by the parsing.  If you need that information, use the version of
394      * parse() that takes a ParsePosition.
395      * &lt;P&gt;
396      * By default, parsing is lenient: If the input is not in the form used by
397      * this object&#39;s format method but can still be parsed as a date, then the
398      * parse succeeds. Clients may insist on strict adherence to the format by
399      * calling setLenient(false).
400      * @see DateFormat::setLenient(boolean)
401      * &lt;P&gt;
402      * Note that the normal date formats associated with some calendars - such
403      * as the Chinese lunar calendar - do not specify enough fields to enable
404      * dates to be parsed unambiguously. In the case of the Chinese lunar
405      * calendar, while the year within the current 60-year cycle is specified,
406      * the number of such cycles since the start date of the calendar (in the
407      * ERA field of the Calendar object) is not normally part of the format,
408      * and parsing may assume the wrong era. For cases such as this it is
409      * recommended that clients parse using the method
410      * parse(const UnicodeString&amp;, Calendar&amp; cal, ParsePosition&amp;)
411      * with the Calendar passed in set to the current date, or to a date
412      * within the era/cycle that should be assumed if absent in the format.
413      *
414      * @param text      The date/time string to be parsed into a UDate value.
415      * @param status    Output param to be set to success/failure code. If
416      *                  &#39;text&#39; cannot be parsed, it will be set to a failure
417      *                  code.
418      * @return          The parsed UDate value, if successful.
419      * @stable ICU 2.0
420      */
421     virtual UDate parse( const UnicodeString&amp; text,
422                         UErrorCode&amp; status) const;
423 
424     /**
425      * Parse a date/time string beginning at the given parse position. For
426      * example, a time text &quot;07/10/96 4:5 PM, PDT&quot; will be parsed into a Date
427      * that is equivalent to Date(837039928046).
428      * &lt;P&gt;
429      * By default, parsing is lenient: If the input is not in the form used by
430      * this object&#39;s format method but can still be parsed as a date, then the
431      * parse succeeds. Clients may insist on strict adherence to the format by
432      * calling setLenient(false).
433      * @see DateFormat::setLenient(boolean)
434      *
435      * @param text  The date/time string to be parsed.
436      * @param cal   A Calendar set on input to the date and time to be used for
437      *              missing values in the date/time string being parsed, and set
438      *              on output to the parsed date/time. When the calendar type is
439      *              different from the internal calendar held by this DateFormat
440      *              instance, the internal calendar will be cloned to a work
441      *              calendar set to the same milliseconds and time zone as the
442      *              cal parameter, field values will be parsed based on the work
443      *              calendar, then the result (milliseconds and time zone) will
444      *              be set in this calendar.
445      * @param pos   On input, the position at which to start parsing; on
446      *              output, the position at which parsing terminated, or the
447      *              start position if the parse failed.
448      * @stable ICU 2.1
449      */
450     virtual void parse( const UnicodeString&amp; text,
451                         Calendar&amp; cal,
452                         ParsePosition&amp; pos) const = 0;
453 
454     /**
455      * Parse a date/time string beginning at the given parse position. For
456      * example, a time text &quot;07/10/96 4:5 PM, PDT&quot; will be parsed into a Date
457      * that is equivalent to Date(837039928046).
458      * &lt;P&gt;
459      * By default, parsing is lenient: If the input is not in the form used by
460      * this object&#39;s format method but can still be parsed as a date, then the
461      * parse succeeds. Clients may insist on strict adherence to the format by
462      * calling setLenient(false).
463      * @see DateFormat::setLenient(boolean)
464      * &lt;P&gt;
465      * Note that the normal date formats associated with some calendars - such
466      * as the Chinese lunar calendar - do not specify enough fields to enable
467      * dates to be parsed unambiguously. In the case of the Chinese lunar
468      * calendar, while the year within the current 60-year cycle is specified,
469      * the number of such cycles since the start date of the calendar (in the
470      * ERA field of the Calendar object) is not normally part of the format,
471      * and parsing may assume the wrong era. For cases such as this it is
472      * recommended that clients parse using the method
473      * parse(const UnicodeString&amp;, Calendar&amp; cal, ParsePosition&amp;)
474      * with the Calendar passed in set to the current date, or to a date
475      * within the era/cycle that should be assumed if absent in the format.
476      *
477      * @param text  The date/time string to be parsed into a UDate value.
478      * @param pos   On input, the position at which to start parsing; on
479      *              output, the position at which parsing terminated, or the
480      *              start position if the parse failed.
481      * @return      A valid UDate if the input could be parsed.
482      * @stable ICU 2.0
483      */
484     UDate parse( const UnicodeString&amp; text,
485                  ParsePosition&amp; pos) const;
486 
487     /**
488      * Parse a string to produce an object. This methods handles parsing of
489      * date/time strings into Formattable objects with UDate types.
490      * &lt;P&gt;
491      * Before calling, set parse_pos.index to the offset you want to start
492      * parsing at in the source. After calling, parse_pos.index is the end of
493      * the text you parsed. If error occurs, index is unchanged.
494      * &lt;P&gt;
495      * When parsing, leading whitespace is discarded (with a successful parse),
496      * while trailing whitespace is left as is.
497      * &lt;P&gt;
498      * See Format::parseObject() for more.
499      *
500      * @param source    The string to be parsed into an object.
501      * @param result    Formattable to be set to the parse result.
502      *                  If parse fails, return contents are undefined.
503      * @param parse_pos The position to start parsing at. Upon return
504      *                  this param is set to the position after the
505      *                  last character successfully parsed. If the
506      *                  source is not parsed successfully, this param
507      *                  will remain unchanged.
508      * @stable ICU 2.0
509      */
510     virtual void parseObject(const UnicodeString&amp; source,
511                              Formattable&amp; result,
512                              ParsePosition&amp; parse_pos) const;
513 
514     /**
515      * Create a default date/time formatter that uses the SHORT style for both
516      * the date and the time.
517      *
518      * @return A date/time formatter which the caller owns.
519      * @stable ICU 2.0
520      */
521     static DateFormat* U_EXPORT2 createInstance(void);
522 
523     /**
524      * Creates a time formatter with the given formatting style for the given
525      * locale.
526      *
527      * @param style     The given formatting style. For example,
528      *                  SHORT for &quot;h:mm a&quot; in the US locale. Relative
529      *                  time styles are not currently supported.
530      * @param aLocale   The given locale.
531      * @return          A time formatter which the caller owns.
532      * @stable ICU 2.0
533      */
534     static DateFormat* U_EXPORT2 createTimeInstance(EStyle style = kDefault,
535                                           const Locale&amp; aLocale = Locale::getDefault());
536 
537     /**
538      * Creates a date formatter with the given formatting style for the given
539      * const locale.
540      *
541      * @param style     The given formatting style. For example, SHORT for &quot;M/d/yy&quot; in the
542      *                  US locale. As currently implemented, relative date formatting only
543      *                  affects a limited range of calendar days before or after the
544      *                  current date, based on the CLDR &amp;lt;field type=&quot;day&quot;&amp;gt;/&amp;lt;relative&amp;gt; data:
545      *                  For example, in English, &quot;Yesterday&quot;, &quot;Today&quot;, and &quot;Tomorrow&quot;.
546      *                  Outside of this range, dates are formatted using the corresponding
547      *                  non-relative style.
548      * @param aLocale   The given locale.
549      * @return          A date formatter which the caller owns.
550      * @stable ICU 2.0
551      */
552     static DateFormat* U_EXPORT2 createDateInstance(EStyle style = kDefault,
553                                           const Locale&amp; aLocale = Locale::getDefault());
554 
555     /**
556      * Creates a date/time formatter with the given formatting styles for the
557      * given locale.
558      *
559      * @param dateStyle The given formatting style for the date portion of the result.
560      *                  For example, SHORT for &quot;M/d/yy&quot; in the US locale. As currently
561      *                  implemented, relative date formatting only affects a limited range
562      *                  of calendar days before or after the current date, based on the
563      *                  CLDR &amp;lt;field type=&quot;day&quot;&amp;gt;/&amp;lt;relative&amp;gt; data: For example, in English,
564      *                  &quot;Yesterday&quot;, &quot;Today&quot;, and &quot;Tomorrow&quot;. Outside of this range, dates
565      *                  are formatted using the corresponding non-relative style.
566      * @param timeStyle The given formatting style for the time portion of the result.
567      *                  For example, SHORT for &quot;h:mm a&quot; in the US locale. Relative
568      *                  time styles are not currently supported.
569      * @param aLocale   The given locale.
570      * @return          A date/time formatter which the caller owns.
571      * @stable ICU 2.0
572      */
573     static DateFormat* U_EXPORT2 createDateTimeInstance(EStyle dateStyle = kDefault,
574                                               EStyle timeStyle = kDefault,
575                                               const Locale&amp; aLocale = Locale::getDefault());
576 
577 #ifndef U_HIDE_INTERNAL_API
578     /**
579      * Returns the best pattern given a skeleton and locale.
580      * @param locale the locale
581      * @param skeleton the skeleton
582      * @param status ICU error returned here
583      * @return the best pattern.
584      * @internal For ICU use only.
585      */
586     static UnicodeString getBestPattern(
587             const Locale &amp;locale,
588             const UnicodeString &amp;skeleton,
589             UErrorCode &amp;status);
590 #endif  /* U_HIDE_INTERNAL_API */
591 
592     /**
593      * Creates a date/time formatter for the given skeleton and
594      * default locale.
595      *
596      * @param skeleton The skeleton e.g &quot;yMMMMd.&quot; Fields in the skeleton can
597      *                 be in any order, and this method uses the locale to
598      *                 map the skeleton to a pattern that includes locale
599      *                 specific separators with the fields in the appropriate
600      *                 order for that locale.
601      * @param status   Any error returned here.
602      * @return         A date/time formatter which the caller owns.
603      * @stable ICU 55
604      */
605     static DateFormat* U_EXPORT2 createInstanceForSkeleton(
606             const UnicodeString&amp; skeleton,
607             UErrorCode &amp;status);
608 
609     /**
610      * Creates a date/time formatter for the given skeleton and locale.
611      *
612      * @param skeleton The skeleton e.g &quot;yMMMMd.&quot; Fields in the skeleton can
613      *                 be in any order, and this method uses the locale to
614      *                 map the skeleton to a pattern that includes locale
615      *                 specific separators with the fields in the appropriate
616      *                 order for that locale.
617      * @param locale  The given locale.
618      * @param status   Any error returned here.
619      * @return         A date/time formatter which the caller owns.
620      * @stable ICU 55
621      */
622     static DateFormat* U_EXPORT2 createInstanceForSkeleton(
623             const UnicodeString&amp; skeleton,
624             const Locale &amp;locale,
625             UErrorCode &amp;status);
626 
627     /**
628      * Creates a date/time formatter for the given skeleton and locale.
629      *
630      * @param calendarToAdopt the calendar returned DateFormat is to use.
631      * @param skeleton The skeleton e.g &quot;yMMMMd.&quot; Fields in the skeleton can
632      *                 be in any order, and this method uses the locale to
633      *                 map the skeleton to a pattern that includes locale
634      *                 specific separators with the fields in the appropriate
635      *                 order for that locale.
636      * @param locale  The given locale.
637      * @param status   Any error returned here.
638      * @return         A date/time formatter which the caller owns.
639      * @stable ICU 55
640      */
641     static DateFormat* U_EXPORT2 createInstanceForSkeleton(
642             Calendar *calendarToAdopt,
643             const UnicodeString&amp; skeleton,
644             const Locale &amp;locale,
645             UErrorCode &amp;status);
646 
647 
648     /**
649      * Gets the set of locales for which DateFormats are installed.
650      * @param count Filled in with the number of locales in the list that is returned.
651      * @return the set of locales for which DateFormats are installed.  The caller
652      *  does NOT own this list and must not delete it.
653      * @stable ICU 2.0
654      */
655     static const Locale* U_EXPORT2 getAvailableLocales(int32_t&amp; count);
656 
657     /**
658      * Returns whether both date/time parsing in the encapsulated Calendar object and DateFormat whitespace &amp;
659      * numeric processing is lenient.
660      * @stable ICU 2.0
661      */
662     virtual UBool isLenient(void) const;
663 
664     /**
665      * Specifies whether date/time parsing is to be lenient.  With
666      * lenient parsing, the parser may use heuristics to interpret inputs that
667      * do not precisely match this object&#39;s format.  Without lenient parsing,
668      * inputs must match this object&#39;s format more closely.
669      *
670      * Note: ICU 53 introduced finer grained control of leniency (and added
671      * new control points) making the preferred method a combination of
672      * setCalendarLenient() &amp; setBooleanAttribute() calls.
673      * This method supports prior functionality but may not support all
674      * future leniency control &amp; behavior of DateFormat. For control of pre 53 leniency,
675      * Calendar and DateFormat whitespace &amp; numeric tolerance, this method is safe to
676      * use. However, mixing leniency control via this method and modification of the
677      * newer attributes via setBooleanAttribute() may produce undesirable
678      * results.
679      *
680      * @param lenient  True specifies date/time interpretation to be lenient.
681      * @see Calendar::setLenient
682      * @stable ICU 2.0
683      */
684     virtual void setLenient(UBool lenient);
685 
686 
687     /**
688      * Returns whether date/time parsing in the encapsulated Calendar object processing is lenient.
689      * @stable ICU 53
690      */
691     virtual UBool isCalendarLenient(void) const;
692 
693 
694     /**
695      * Specifies whether encapsulated Calendar date/time parsing is to be lenient.  With
696      * lenient parsing, the parser may use heuristics to interpret inputs that
697      * do not precisely match this object&#39;s format.  Without lenient parsing,
698      * inputs must match this object&#39;s format more closely.
699      * @param lenient when true, parsing is lenient
700      * @see com.ibm.icu.util.Calendar#setLenient
701      * @stable ICU 53
702      */
703     virtual void setCalendarLenient(UBool lenient);
704 
705 
706     /**
707      * Gets the calendar associated with this date/time formatter.
708      * The calendar is owned by the formatter and must not be modified.
709      * Also, the calendar does not reflect the results of a parse operation.
710      * To parse to a calendar, use {@link #parse(const UnicodeString&amp;, Calendar&amp; cal, ParsePosition&amp;) const parse(const UnicodeString&amp;, Calendar&amp; cal, ParsePosition&amp;)}
711      * @return the calendar associated with this date/time formatter.
712      * @stable ICU 2.0
713      */
714     virtual const Calendar* getCalendar(void) const;
715 
716     /**
717      * Set the calendar to be used by this date format. Initially, the default
718      * calendar for the specified or default locale is used.  The caller should
719      * not delete the Calendar object after it is adopted by this call.
720      * Adopting a new calendar will change to the default symbols.
721      *
722      * @param calendarToAdopt    Calendar object to be adopted.
723      * @stable ICU 2.0
724      */
725     virtual void adoptCalendar(Calendar* calendarToAdopt);
726 
727     /**
728      * Set the calendar to be used by this date format. Initially, the default
729      * calendar for the specified or default locale is used.
730      *
731      * @param newCalendar Calendar object to be set.
732      * @stable ICU 2.0
733      */
734     virtual void setCalendar(const Calendar&amp; newCalendar);
735 
736 
737     /**
738      * Gets the number formatter which this date/time formatter uses to format
739      * and parse the numeric portions of the pattern.
740      * @return the number formatter which this date/time formatter uses.
741      * @stable ICU 2.0
742      */
743     virtual const NumberFormat* getNumberFormat(void) const;
744 
745     /**
746      * Allows you to set the number formatter.  The caller should
747      * not delete the NumberFormat object after it is adopted by this call.
748      * @param formatToAdopt     NumberFormat object to be adopted.
749      * @stable ICU 2.0
750      */
751     virtual void adoptNumberFormat(NumberFormat* formatToAdopt);
752 
753     /**
754      * Allows you to set the number formatter.
755      * @param newNumberFormat  NumberFormat object to be set.
756      * @stable ICU 2.0
757      */
758     virtual void setNumberFormat(const NumberFormat&amp; newNumberFormat);
759 
760     /**
761      * Returns a reference to the TimeZone used by this DateFormat&#39;s calendar.
762      * @return the time zone associated with the calendar of DateFormat.
763      * @stable ICU 2.0
764      */
765     virtual const TimeZone&amp; getTimeZone(void) const;
766 
767     /**
768      * Sets the time zone for the calendar of this DateFormat object. The caller
769      * no longer owns the TimeZone object and should not delete it after this call.
770      * @param zoneToAdopt the TimeZone to be adopted.
771      * @stable ICU 2.0
772      */
773     virtual void adoptTimeZone(TimeZone* zoneToAdopt);
774 
775     /**
776      * Sets the time zone for the calendar of this DateFormat object.
777      * @param zone the new time zone.
778      * @stable ICU 2.0
779      */
780     virtual void setTimeZone(const TimeZone&amp; zone);
781 
782     /**
783      * Set a particular UDisplayContext value in the formatter, such as
784      * UDISPCTX_CAPITALIZATION_FOR_STANDALONE.
785      * @param value The UDisplayContext value to set.
786      * @param status Input/output status. If at entry this indicates a failure
787      *               status, the function will do nothing; otherwise this will be
788      *               updated with any new status from the function.
789      * @stable ICU 53
790      */
791     virtual void setContext(UDisplayContext value, UErrorCode&amp; status);
792 
793     /**
794      * Get the formatter&#39;s UDisplayContext value for the specified UDisplayContextType,
795      * such as UDISPCTX_TYPE_CAPITALIZATION.
796      * @param type The UDisplayContextType whose value to return
797      * @param status Input/output status. If at entry this indicates a failure
798      *               status, the function will do nothing; otherwise this will be
799      *               updated with any new status from the function.
800      * @return The UDisplayContextValue for the specified type.
801      * @stable ICU 53
802      */
803     virtual UDisplayContext getContext(UDisplayContextType type, UErrorCode&amp; status) const;
804 
805    /**
806      * Sets an boolean attribute on this DateFormat.
807      * May return U_UNSUPPORTED_ERROR if this instance does not support
808      * the specified attribute.
809      * @param attr the attribute to set
810      * @param newvalue new value
811      * @param status the error type
812      * @return *this - for chaining (example: format.setAttribute(...).setAttribute(...) )
813      * @stable ICU 53
814      */
815 
816     virtual DateFormat&amp;  U_EXPORT2 setBooleanAttribute(UDateFormatBooleanAttribute attr,
817                                         UBool newvalue,
818                                         UErrorCode &amp;status);
819 
820     /**
821      * Returns a boolean from this DateFormat
822      * May return U_UNSUPPORTED_ERROR if this instance does not support
823      * the specified attribute.
824      * @param attr the attribute to set
825      * @param status the error type
826      * @return the attribute value. Undefined if there is an error.
827      * @stable ICU 53
828      */
829     virtual UBool U_EXPORT2 getBooleanAttribute(UDateFormatBooleanAttribute attr, UErrorCode &amp;status) const;
830 
831 protected:
832     /**
833      * Default constructor.  Creates a DateFormat with no Calendar or NumberFormat
834      * associated with it.  This constructor depends on the subclasses to fill in
835      * the calendar and numberFormat fields.
836      * @stable ICU 2.0
837      */
838     DateFormat();
839 
840     /**
841      * Copy constructor.
842      * @stable ICU 2.0
843      */
844     DateFormat(const DateFormat&amp;);
845 
846     /**
847      * Default assignment operator.
848      * @stable ICU 2.0
849      */
850     DateFormat&amp; operator=(const DateFormat&amp;);
851 
852     /**
853      * The calendar that DateFormat uses to produce the time field values needed
854      * to implement date/time formatting. Subclasses should generally initialize
855      * this to the default calendar for the locale associated with this DateFormat.
856      * @stable ICU 2.4
857      */
858     Calendar* fCalendar;
859 
860     /**
861      * The number formatter that DateFormat uses to format numbers in dates and
862      * times. Subclasses should generally initialize this to the default number
863      * format for the locale associated with this DateFormat.
864      * @stable ICU 2.4
865      */
866     NumberFormat* fNumberFormat;
867 
868 
869 private:
870 
871     /**
872      * Gets the date/time formatter with the given formatting styles for the
873      * given locale.
874      * @param dateStyle the given date formatting style.
875      * @param timeStyle the given time formatting style.
876      * @param inLocale the given locale.
877      * @return a date/time formatter, or 0 on failure.
878      */
879     static DateFormat* U_EXPORT2 create(EStyle timeStyle, EStyle dateStyle, const Locale&amp; inLocale);
880 
881 
882     /**
883      * enum set of active boolean attributes for this instance
884      */
885     EnumSet&lt;UDateFormatBooleanAttribute, 0, UDAT_BOOLEAN_ATTRIBUTE_COUNT&gt; fBoolFlags;
886 
887 
888     UDisplayContext fCapitalizationContext;
889     friend class DateFmtKeyByStyle;
890 
891 public:
892 #ifndef U_HIDE_OBSOLETE_API
893     /**
894      * Field selector for FieldPosition for DateFormat fields.
895      * @obsolete ICU 3.4 use UDateFormatField instead, since this API will be
896      * removed in that release
897      */
898     enum EField
899     {
900         // Obsolete; use UDateFormatField instead
901         kEraField = UDAT_ERA_FIELD,
902         kYearField = UDAT_YEAR_FIELD,
903         kMonthField = UDAT_MONTH_FIELD,
904         kDateField = UDAT_DATE_FIELD,
905         kHourOfDay1Field = UDAT_HOUR_OF_DAY1_FIELD,
906         kHourOfDay0Field = UDAT_HOUR_OF_DAY0_FIELD,
907         kMinuteField = UDAT_MINUTE_FIELD,
908         kSecondField = UDAT_SECOND_FIELD,
909         kMillisecondField = UDAT_FRACTIONAL_SECOND_FIELD,
910         kDayOfWeekField = UDAT_DAY_OF_WEEK_FIELD,
911         kDayOfYearField = UDAT_DAY_OF_YEAR_FIELD,
912         kDayOfWeekInMonthField = UDAT_DAY_OF_WEEK_IN_MONTH_FIELD,
913         kWeekOfYearField = UDAT_WEEK_OF_YEAR_FIELD,
914         kWeekOfMonthField = UDAT_WEEK_OF_MONTH_FIELD,
915         kAmPmField = UDAT_AM_PM_FIELD,
916         kHour1Field = UDAT_HOUR1_FIELD,
917         kHour0Field = UDAT_HOUR0_FIELD,
918         kTimezoneField = UDAT_TIMEZONE_FIELD,
919         kYearWOYField = UDAT_YEAR_WOY_FIELD,
920         kDOWLocalField = UDAT_DOW_LOCAL_FIELD,
921         kExtendedYearField = UDAT_EXTENDED_YEAR_FIELD,
922         kJulianDayField = UDAT_JULIAN_DAY_FIELD,
923         kMillisecondsInDayField = UDAT_MILLISECONDS_IN_DAY_FIELD,
924 
925         // Obsolete; use UDateFormatField instead
926         ERA_FIELD = UDAT_ERA_FIELD,
927         YEAR_FIELD = UDAT_YEAR_FIELD,
928         MONTH_FIELD = UDAT_MONTH_FIELD,
929         DATE_FIELD = UDAT_DATE_FIELD,
930         HOUR_OF_DAY1_FIELD = UDAT_HOUR_OF_DAY1_FIELD,
931         HOUR_OF_DAY0_FIELD = UDAT_HOUR_OF_DAY0_FIELD,
932         MINUTE_FIELD = UDAT_MINUTE_FIELD,
933         SECOND_FIELD = UDAT_SECOND_FIELD,
934         MILLISECOND_FIELD = UDAT_FRACTIONAL_SECOND_FIELD,
935         DAY_OF_WEEK_FIELD = UDAT_DAY_OF_WEEK_FIELD,
936         DAY_OF_YEAR_FIELD = UDAT_DAY_OF_YEAR_FIELD,
937         DAY_OF_WEEK_IN_MONTH_FIELD = UDAT_DAY_OF_WEEK_IN_MONTH_FIELD,
938         WEEK_OF_YEAR_FIELD = UDAT_WEEK_OF_YEAR_FIELD,
939         WEEK_OF_MONTH_FIELD = UDAT_WEEK_OF_MONTH_FIELD,
940         AM_PM_FIELD = UDAT_AM_PM_FIELD,
941         HOUR1_FIELD = UDAT_HOUR1_FIELD,
942         HOUR0_FIELD = UDAT_HOUR0_FIELD,
943         TIMEZONE_FIELD = UDAT_TIMEZONE_FIELD
944     };
945 #endif  /* U_HIDE_OBSOLETE_API */
946 };
947 
948 U_NAMESPACE_END
949 
950 #endif /* #if !UCONFIG_NO_FORMATTING */
951 
952 #endif // _DATEFMT
953 //eof
    </pre>
  </body>
</html>