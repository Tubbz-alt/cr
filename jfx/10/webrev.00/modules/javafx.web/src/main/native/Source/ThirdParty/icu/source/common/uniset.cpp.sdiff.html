<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uniset.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="unifiedcache.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uniset_closure.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uniset.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 *   Copyright (C) 1999-2015, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8 *   Date        Name        Description
   9 *   10/20/99    alan        Creation.
  10 **********************************************************************
  11 */
  12 
  13 #include &quot;unicode/utypes.h&quot;
  14 #include &quot;unicode/parsepos.h&quot;
  15 #include &quot;unicode/symtable.h&quot;
  16 #include &quot;unicode/uniset.h&quot;

  17 #include &quot;unicode/utf8.h&quot;
  18 #include &quot;unicode/utf16.h&quot;
  19 #include &quot;ruleiter.h&quot;
  20 #include &quot;cmemory.h&quot;
  21 #include &quot;cstring.h&quot;
  22 #include &quot;patternprops.h&quot;
  23 #include &quot;uelement.h&quot;
  24 #include &quot;util.h&quot;
  25 #include &quot;uvector.h&quot;
  26 #include &quot;charstr.h&quot;
  27 #include &quot;ustrfmt.h&quot;
  28 #include &quot;uassert.h&quot;
  29 #include &quot;bmpset.h&quot;
  30 #include &quot;unisetspan.h&quot;
  31 
  32 // Define UChar constants using hex for EBCDIC compatibility
  33 // Used #define to reduce private static exports and memory access time.
  34 #define SET_OPEN        ((UChar)0x005B) /*[*/
  35 #define SET_CLOSE       ((UChar)0x005D) /*]*/
  36 #define HYPHEN          ((UChar)0x002D) /*-*/
  37 #define COMPLEMENT      ((UChar)0x005E) /*^*/
  38 #define COLON           ((UChar)0x003A) /*:*/
  39 #define BACKSLASH       ((UChar)0x005C) /*\*/
  40 #define INTERSECTION    ((UChar)0x0026) /*&amp;*/
  41 #define UPPER_U         ((UChar)0x0055) /*U*/
  42 #define LOWER_U         ((UChar)0x0075) /*u*/
  43 #define OPEN_BRACE      ((UChar)123)    /*{*/
  44 #define CLOSE_BRACE     ((UChar)125)    /*}*/
  45 #define UPPER_P         ((UChar)0x0050) /*P*/
  46 #define LOWER_P         ((UChar)0x0070) /*p*/
  47 #define UPPER_N         ((UChar)78)     /*N*/
  48 #define EQUALS          ((UChar)0x003D) /*=*/
  49 
  50 // HIGH_VALUE &gt; all valid values. 110000 for codepoints
  51 #define UNICODESET_HIGH 0x0110000
  52 
  53 // LOW &lt;= all valid values. ZERO for codepoints
  54 #define UNICODESET_LOW 0x000000
  55 
<span class="line-modified">  56 // initial storage. Must be &gt;= 0</span>
<span class="line-modified">  57 #define START_EXTRA 16</span>
<span class="line-removed">  58 </span>
<span class="line-removed">  59 // extra amount for growth. Must be &gt;= 0</span>
<span class="line-removed">  60 #define GROW_EXTRA START_EXTRA</span>
  61 
  62 U_NAMESPACE_BEGIN
  63 
  64 SymbolTable::~SymbolTable() {}
  65 
  66 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(UnicodeSet)
  67 
  68 /**
  69  * Modify the given UChar32 variable so that it is in range, by
  70  * pinning values &lt; UNICODESET_LOW to UNICODESET_LOW, and
  71  * pinning values &gt; UNICODESET_HIGH-1 to UNICODESET_HIGH-1.
  72  * It modifies its argument in-place and also returns it.
  73  */
  74 static inline UChar32 pinCodePoint(UChar32&amp; c) {
  75     if (c &lt; UNICODESET_LOW) {
  76         c = UNICODESET_LOW;
  77     } else if (c &gt; (UNICODESET_HIGH-1)) {
  78         c = (UNICODESET_HIGH-1);
  79     }
  80     return c;
</pre>
<hr />
<pre>
 120 
 121 #define _dbgct(set)
 122 #define _dbgdt(set)
 123 
 124 #endif
 125 
 126 //----------------------------------------------------------------
 127 // UnicodeString in UVector support
 128 //----------------------------------------------------------------
 129 
 130 static void U_CALLCONV cloneUnicodeString(UElement *dst, UElement *src) {
 131     dst-&gt;pointer = new UnicodeString(*(UnicodeString*)src-&gt;pointer);
 132 }
 133 
 134 static int8_t U_CALLCONV compareUnicodeString(UElement t1, UElement t2) {
 135     const UnicodeString &amp;a = *(const UnicodeString*)t1.pointer;
 136     const UnicodeString &amp;b = *(const UnicodeString*)t2.pointer;
 137     return a.compare(b);
 138 }
 139 












 140 //----------------------------------------------------------------
 141 // Constructors &amp;c
 142 //----------------------------------------------------------------
 143 
 144 /**
 145  * Constructs an empty set.
 146  */
<span class="line-modified"> 147 UnicodeSet::UnicodeSet() :</span>
<span class="line-modified"> 148     len(1), capacity(1 + START_EXTRA), list(0), bmpSet(0), buffer(0),</span>
<span class="line-removed"> 149     bufferCapacity(0), patLen(0), pat(NULL), strings(NULL), stringSpan(NULL),</span>
<span class="line-removed"> 150     fFlags(0)</span>
<span class="line-removed"> 151 {</span>
<span class="line-removed"> 152     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-removed"> 153     allocateStrings(status);</span>
<span class="line-removed"> 154     if (U_FAILURE(status)) {</span>
<span class="line-removed"> 155         return;</span>
<span class="line-removed"> 156     }</span>
<span class="line-removed"> 157     list = (UChar32*) uprv_malloc(sizeof(UChar32) * capacity);</span>
<span class="line-removed"> 158     if(list!=NULL){</span>
<span class="line-removed"> 159         list[0] = UNICODESET_HIGH;</span>
<span class="line-removed"> 160     } else { // If memory allocation failed, set to bogus state.</span>
<span class="line-removed"> 161         setToBogus();</span>
<span class="line-removed"> 162         return;</span>
<span class="line-removed"> 163     }</span>
 164     _dbgct(this);
 165 }
 166 
 167 /**
 168  * Constructs a set containing the given range. If &lt;code&gt;end &gt;
 169  * start&lt;/code&gt; then an empty set is created.
 170  *
 171  * @param start first character, inclusive, of range
 172  * @param end last character, inclusive, of range
 173  */
<span class="line-modified"> 174 UnicodeSet::UnicodeSet(UChar32 start, UChar32 end) :</span>
<span class="line-modified"> 175     len(1), capacity(1 + START_EXTRA), list(0), bmpSet(0), buffer(0),</span>
<span class="line-modified"> 176     bufferCapacity(0), patLen(0), pat(NULL), strings(NULL), stringSpan(NULL),</span>
<span class="line-removed"> 177     fFlags(0)</span>
<span class="line-removed"> 178 {</span>
<span class="line-removed"> 179     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-removed"> 180     allocateStrings(status);</span>
<span class="line-removed"> 181     if (U_FAILURE(status)) {</span>
<span class="line-removed"> 182         return;</span>
<span class="line-removed"> 183     }</span>
<span class="line-removed"> 184     list = (UChar32*) uprv_malloc(sizeof(UChar32) * capacity);</span>
<span class="line-removed"> 185     if(list!=NULL){</span>
<span class="line-removed"> 186         list[0] = UNICODESET_HIGH;</span>
<span class="line-removed"> 187         complement(start, end);</span>
<span class="line-removed"> 188     } else { // If memory allocation failed, set to bogus state.</span>
<span class="line-removed"> 189         setToBogus();</span>
<span class="line-removed"> 190         return;</span>
<span class="line-removed"> 191     }</span>
 192     _dbgct(this);
 193 }
 194 
 195 /**
 196  * Constructs a set that is identical to the given UnicodeSet.
 197  */
<span class="line-modified"> 198 UnicodeSet::UnicodeSet(const UnicodeSet&amp; o) :</span>
<span class="line-modified"> 199     UnicodeFilter(o),</span>
<span class="line-removed"> 200     len(0), capacity(o.isFrozen() ? o.len : o.len + GROW_EXTRA), list(0),</span>
<span class="line-removed"> 201     bmpSet(0),</span>
<span class="line-removed"> 202     buffer(0), bufferCapacity(0),</span>
<span class="line-removed"> 203     patLen(0), pat(NULL), strings(NULL), stringSpan(NULL),</span>
<span class="line-removed"> 204     fFlags(0)</span>
<span class="line-removed"> 205 {</span>
<span class="line-removed"> 206     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-removed"> 207     allocateStrings(status);</span>
<span class="line-removed"> 208     if (U_FAILURE(status)) {</span>
<span class="line-removed"> 209         return;</span>
<span class="line-removed"> 210     }</span>
<span class="line-removed"> 211     list = (UChar32*) uprv_malloc(sizeof(UChar32) * capacity);</span>
<span class="line-removed"> 212     if(list!=NULL){</span>
<span class="line-removed"> 213         *this = o;</span>
<span class="line-removed"> 214     } else { // If memory allocation failed, set to bogus state.</span>
<span class="line-removed"> 215         setToBogus();</span>
<span class="line-removed"> 216         return;</span>
<span class="line-removed"> 217     }</span>
 218     _dbgct(this);
 219 }
 220 
 221 // Copy-construct as thawed.
<span class="line-modified"> 222 UnicodeSet::UnicodeSet(const UnicodeSet&amp; o, UBool /* asThawed */) :</span>
<span class="line-modified"> 223     UnicodeFilter(o),</span>
<span class="line-removed"> 224     len(0), capacity(o.len + GROW_EXTRA), list(0),</span>
<span class="line-removed"> 225     bmpSet(0),</span>
<span class="line-removed"> 226     buffer(0), bufferCapacity(0),</span>
<span class="line-removed"> 227     patLen(0), pat(NULL), strings(NULL), stringSpan(NULL),</span>
<span class="line-removed"> 228     fFlags(0)</span>
<span class="line-removed"> 229 {</span>
<span class="line-removed"> 230     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-removed"> 231     allocateStrings(status);</span>
<span class="line-removed"> 232     if (U_FAILURE(status)) {</span>
<span class="line-removed"> 233         return;</span>
<span class="line-removed"> 234     }</span>
<span class="line-removed"> 235     list = (UChar32*) uprv_malloc(sizeof(UChar32) * capacity);</span>
<span class="line-removed"> 236     if(list!=NULL){</span>
 237         // *this = o except for bmpSet and stringSpan
 238         len = o.len;
 239         uprv_memcpy(list, o.list, (size_t)len*sizeof(UChar32));
<span class="line-modified"> 240         if (strings != NULL &amp;&amp; o.strings != NULL) {</span>
<span class="line-modified"> 241             strings-&gt;assign(*o.strings, cloneUnicodeString, status);</span>
<span class="line-modified"> 242         } else { // Invalid strings.</span>
<span class="line-modified"> 243             setToBogus();</span>
<span class="line-modified"> 244             return;</span>


 245         }
 246         if (o.pat) {
<span class="line-modified"> 247             setPattern(UnicodeString(o.pat, o.patLen));</span>
 248         }
<span class="line-modified"> 249     } else { // If memory allocation failed, set to bogus state.</span>
<span class="line-removed"> 250         setToBogus();</span>
<span class="line-removed"> 251         return;</span>
 252     }
<span class="line-removed"> 253     _dbgct(this);</span>
 254 }
 255 
 256 /**
 257  * Destructs the set.
 258  */
 259 UnicodeSet::~UnicodeSet() {
 260     _dbgdt(this); // first!
<span class="line-modified"> 261     uprv_free(list);</span>


 262     delete bmpSet;
<span class="line-modified"> 263     if (buffer) {</span>
 264         uprv_free(buffer);
 265     }
 266     delete strings;
 267     delete stringSpan;
 268     releasePattern();
 269 }
 270 
 271 /**
 272  * Assigns this object to be a copy of another.
 273  */
 274 UnicodeSet&amp; UnicodeSet::operator=(const UnicodeSet&amp; o) {




 275     if (this == &amp;o) {
 276         return *this;
 277     }
 278     if (isFrozen()) {
 279         return *this;
 280     }
 281     if (o.isBogus()) {
 282         setToBogus();
 283         return *this;
 284     }
<span class="line-modified"> 285     UErrorCode ec = U_ZERO_ERROR;</span>
<span class="line-modified"> 286     ensureCapacity(o.len, ec);</span>
<span class="line-modified"> 287     if (U_FAILURE(ec)) {</span>
<span class="line-removed"> 288         return *this; // There is no way to report this error :-(</span>
 289     }
 290     len = o.len;
 291     uprv_memcpy(list, o.list, (size_t)len*sizeof(UChar32));
<span class="line-modified"> 292     if (o.bmpSet == NULL) {</span>
<span class="line-removed"> 293         bmpSet = NULL;</span>
<span class="line-removed"> 294     } else {</span>
 295         bmpSet = new BMPSet(*o.bmpSet, list, len);
 296         if (bmpSet == NULL) { // Check for memory allocation error.
 297             setToBogus();
 298             return *this;
 299         }
 300     }
<span class="line-modified"> 301     if (strings != NULL &amp;&amp; o.strings != NULL) {</span>
<span class="line-modified"> 302         strings-&gt;assign(*o.strings, cloneUnicodeString, ec);</span>
<span class="line-modified"> 303     } else { // Invalid strings.</span>
<span class="line-modified"> 304         setToBogus();</span>
<span class="line-modified"> 305         return *this;</span>




 306     }
<span class="line-modified"> 307     if (o.stringSpan == NULL) {</span>
<span class="line-removed"> 308         stringSpan = NULL;</span>
<span class="line-removed"> 309     } else {</span>
 310         stringSpan = new UnicodeSetStringSpan(*o.stringSpan, *strings);
 311         if (stringSpan == NULL) { // Check for memory allocation error.
 312             setToBogus();
 313             return *this;
 314         }
 315     }
 316     releasePattern();
 317     if (o.pat) {
<span class="line-modified"> 318         setPattern(UnicodeString(o.pat, o.patLen));</span>
 319     }
 320     return *this;
 321 }
 322 
 323 /**
 324  * Returns a copy of this object.  All UnicodeMatcher objects have
 325  * to support cloning in order to allow classes using
 326  * UnicodeMatchers, such as Transliterator, to implement cloning.
 327  */
 328 UnicodeFunctor* UnicodeSet::clone() const {
 329     return new UnicodeSet(*this);
 330 }
 331 
 332 UnicodeFunctor *UnicodeSet::cloneAsThawed() const {
 333     return new UnicodeSet(*this, TRUE);
 334 }
 335 
 336 /**
 337  * Compares the specified object with this set for equality.  Returns
 338  * &lt;tt&gt;true&lt;/tt&gt; if the two sets
 339  * have the same size, and every member of the specified set is
 340  * contained in this set (or equivalently, every member of this set is
 341  * contained in the specified set).
 342  *
 343  * @param o set to be compared for equality with this set.
 344  * @return &lt;tt&gt;true&lt;/tt&gt; if the specified set is equal to this set.
 345  */
 346 UBool UnicodeSet::operator==(const UnicodeSet&amp; o) const {
 347     if (len != o.len) return FALSE;
 348     for (int32_t i = 0; i &lt; len; ++i) {
 349         if (list[i] != o.list[i]) return FALSE;
 350     }
<span class="line-modified"> 351     if (*strings != *o.strings) return FALSE;</span>

 352     return TRUE;
 353 }
 354 
 355 /**
 356  * Returns the hash code value for this set.
 357  *
 358  * @return the hash code value for this set.
 359  * @see Object#hashCode()
 360  */
 361 int32_t UnicodeSet::hashCode(void) const {
<span class="line-modified"> 362     int32_t result = len;</span>
 363     for (int32_t i = 0; i &lt; len; ++i) {
<span class="line-modified"> 364         result *= 1000003;</span>
 365         result += list[i];
 366     }
<span class="line-modified"> 367     return result;</span>
 368 }
 369 
 370 //----------------------------------------------------------------
 371 // Public API
 372 //----------------------------------------------------------------
 373 
 374 /**
 375  * Returns the number of elements in this set (its cardinality),
 376  * Note than the elements of a set may include both individual
 377  * codepoints and strings.
 378  *
 379  * @return the number of elements in this set (its cardinality).
 380  */
 381 int32_t UnicodeSet::size(void) const {
 382     int32_t n = 0;
 383     int32_t count = getRangeCount();
 384     for (int32_t i = 0; i &lt; count; ++i) {
 385         n += getRangeEnd(i) - getRangeStart(i) + 1;
 386     }
<span class="line-modified"> 387     return n + strings-&gt;size();</span>
 388 }
 389 
 390 /**
 391  * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements.
 392  *
 393  * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements.
 394  */
 395 UBool UnicodeSet::isEmpty(void) const {
<span class="line-modified"> 396     return len == 1 &amp;&amp; strings-&gt;size() == 0;</span>
 397 }
 398 
 399 /**
 400  * Returns true if this set contains the given character.
 401  * @param c character to be checked for containment
 402  * @return true if the test condition is met
 403  */
 404 UBool UnicodeSet::contains(UChar32 c) const {
 405     // Set i to the index of the start item greater than ch
 406     // We know we will terminate without length test!
 407     // LATER: for large sets, add binary search
 408     //int32_t i = -1;
 409     //for (;;) {
 410     //    if (c &lt; list[++i]) break;
 411     //}
 412     if (bmpSet != NULL) {
 413         return bmpSet-&gt;contains(c);
 414     }
 415     if (stringSpan != NULL) {
 416         return stringSpan-&gt;contains(c);
</pre>
<hr />
<pre>
 476  */
 477 UBool UnicodeSet::contains(UChar32 start, UChar32 end) const {
 478     //int32_t i = -1;
 479     //for (;;) {
 480     //    if (start &lt; list[++i]) break;
 481     //}
 482     int32_t i = findCodePoint(start);
 483     return ((i &amp; 1) != 0 &amp;&amp; end &lt; list[i]);
 484 }
 485 
 486 /**
 487  * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains the given
 488  * multicharacter string.
 489  * @param s string to be checked for containment
 490  * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified string
 491  */
 492 UBool UnicodeSet::contains(const UnicodeString&amp; s) const {
 493     if (s.length() == 0) return FALSE;
 494     int32_t cp = getSingleCP(s);
 495     if (cp &lt; 0) {
<span class="line-modified"> 496         return strings-&gt;contains((void*) &amp;s);</span>
 497     } else {
 498         return contains((UChar32) cp);
 499     }
 500 }
 501 
 502 /**
 503  * Returns true if this set contains all the characters and strings
 504  * of the given set.
 505  * @param c set to be checked for containment
 506  * @return true if the test condition is met
 507  */
 508 UBool UnicodeSet::containsAll(const UnicodeSet&amp; c) const {
 509     // The specified set is a subset if all of its pairs are contained in
 510     // this set.  It&#39;s possible to code this more efficiently in terms of
 511     // direct manipulation of the inversion lists if the need arises.
 512     int32_t n = c.getRangeCount();
 513     for (int i=0; i&lt;n; ++i) {
 514         if (!contains(c.getRangeStart(i), c.getRangeEnd(i))) {
 515             return FALSE;
 516         }
 517     }
<span class="line-modified"> 518     if (!strings-&gt;containsAll(*c.strings)) return FALSE;</span>
<span class="line-removed"> 519     return TRUE;</span>
 520 }
 521 
 522 /**
 523  * Returns true if this set contains all the characters
 524  * of the given string.
 525  * @param s string containing characters to be checked for containment
 526  * @return true if the test condition is met
 527  */
 528 UBool UnicodeSet::containsAll(const UnicodeString&amp; s) const {
 529     return (UBool)(span(s.getBuffer(), s.length(), USET_SPAN_CONTAINED) ==
 530                    s.length());
 531 }
 532 
 533 /**
 534  * Returns true if this set contains none of the characters
 535  * of the given range.
 536  * @param start first character, inclusive, of the range
 537  * @param end last character, inclusive, of the range
 538  * @return true if the test condition is met
 539  */
</pre>
<hr />
<pre>
 545     int32_t i = findCodePoint(start);
 546     return ((i &amp; 1) == 0 &amp;&amp; end &lt; list[i]);
 547 }
 548 
 549 /**
 550  * Returns true if this set contains none of the characters and strings
 551  * of the given set.
 552  * @param c set to be checked for containment
 553  * @return true if the test condition is met
 554  */
 555 UBool UnicodeSet::containsNone(const UnicodeSet&amp; c) const {
 556     // The specified set is a subset if all of its pairs are contained in
 557     // this set.  It&#39;s possible to code this more efficiently in terms of
 558     // direct manipulation of the inversion lists if the need arises.
 559     int32_t n = c.getRangeCount();
 560     for (int32_t i=0; i&lt;n; ++i) {
 561         if (!containsNone(c.getRangeStart(i), c.getRangeEnd(i))) {
 562             return FALSE;
 563         }
 564     }
<span class="line-modified"> 565     if (!strings-&gt;containsNone(*c.strings)) return FALSE;</span>
<span class="line-removed"> 566     return TRUE;</span>
 567 }
 568 
 569 /**
 570  * Returns true if this set contains none of the characters
 571  * of the given string.
 572  * @param s string containing characters to be checked for containment
 573  * @return true if the test condition is met
 574  */
 575 UBool UnicodeSet::containsNone(const UnicodeString&amp; s) const {
 576     return (UBool)(span(s.getBuffer(), s.length(), USET_SPAN_NOT_CONTAINED) ==
 577                    s.length());
 578 }
 579 
 580 /**
 581  * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains any character whose low byte
 582  * is the given value.  This is used by &lt;tt&gt;RuleBasedTransliterator&lt;/tt&gt; for
 583  * indexing.
 584  */
 585 UBool UnicodeSet::matchesIndexValue(uint8_t v) const {
 586     /* The index value v, in the range [0,255], is contained in this set if
 587      * it is contained in any pair of this set.  Pairs either have the high
 588      * bytes equal, or unequal.  If the high bytes are equal, then we have
 589      * aaxx..aayy, where aa is the high byte.  Then v is contained if xx &lt;=
 590      * v &lt;= yy.  If the high bytes are unequal we have aaxx..bbyy, bb&gt;aa.
 591      * Then v is contained if xx &lt;= v || v &lt;= yy.  (This is identical to the
 592      * time zone month containment logic.)
 593      */
 594     int32_t i;
 595     int32_t rangeCount=getRangeCount();
 596     for (i=0; i&lt;rangeCount; ++i) {
 597         UChar32 low = getRangeStart(i);
 598         UChar32 high = getRangeEnd(i);
 599         if ((low &amp; ~0xFF) == (high &amp; ~0xFF)) {
 600             if ((low &amp; 0xFF) &lt;= v &amp;&amp; v &lt;= (high &amp; 0xFF)) {
 601                 return TRUE;
 602             }
 603         } else if ((low &amp; 0xFF) &lt;= v || v &lt;= (high &amp; 0xFF)) {
 604             return TRUE;
 605         }
 606     }
<span class="line-modified"> 607     if (strings-&gt;size() != 0) {</span>
 608         for (i=0; i&lt;strings-&gt;size(); ++i) {
 609             const UnicodeString&amp; s = *(const UnicodeString*)strings-&gt;elementAt(i);
 610             //if (s.length() == 0) {
 611             //    // Empty strings match everything
 612             //    return TRUE;
 613             //}
 614             // assert(s.length() != 0); // We enforce this elsewhere
 615             UChar32 c = s.char32At(0);
 616             if ((c &amp; 0xFF) == v) {
 617                 return TRUE;
 618             }
 619         }
 620     }
 621     return FALSE;
 622 }
 623 
 624 /**
 625  * Implementation of UnicodeMatcher::matches().  Always matches the
 626  * longest possible multichar string.
 627  */
 628 UMatchDegree UnicodeSet::matches(const Replaceable&amp; text,
 629                                  int32_t&amp; offset,
 630                                  int32_t limit,
 631                                  UBool incremental) {
 632     if (offset == limit) {
 633         // Strings, if any, have length != 0, so we don&#39;t worry
 634         // about them here.  If we ever allow zero-length strings
 635         // we much check for them here.
 636         if (contains(U_ETHER)) {
 637             return incremental ? U_PARTIAL_MATCH : U_MATCH;
 638         } else {
 639             return U_MISMATCH;
 640         }
 641     } else {
<span class="line-modified"> 642         if (strings-&gt;size() != 0) { // try strings first</span>
 643 
 644             // might separate forward and backward loops later
 645             // for now they are combined
 646 
 647             // TODO Improve efficiency of this, at least in the forward
 648             // direction, if not in both.  In the forward direction we
 649             // can assume the strings are sorted.
 650 
 651             int32_t i;
 652             UBool forward = offset &lt; limit;
 653 
 654             // firstChar is the leftmost char to match in the
 655             // forward direction or the rightmost char to match in
 656             // the reverse direction.
 657             UChar firstChar = text.charAt(offset);
 658 
 659             // If there are multiple strings that can match we
 660             // return the longest match.
 661             int32_t highWaterLength = 0;
 662 
</pre>
<hr />
<pre>
 823  */
 824 UnicodeSet&amp; UnicodeSet::set(UChar32 start, UChar32 end) {
 825     clear();
 826     complement(start, end);
 827     return *this;
 828 }
 829 
 830 /**
 831  * Adds the specified range to this set if it is not already
 832  * present.  If this set already contains the specified range,
 833  * the call leaves this set unchanged.  If &lt;code&gt;end &gt; start&lt;/code&gt;
 834  * then an empty range is added, leaving the set unchanged.
 835  *
 836  * @param start first character, inclusive, of range to be added
 837  * to this set.
 838  * @param end last character, inclusive, of range to be added
 839  * to this set.
 840  */
 841 UnicodeSet&amp; UnicodeSet::add(UChar32 start, UChar32 end) {
 842     if (pinCodePoint(start) &lt; pinCodePoint(end)) {
<span class="line-modified"> 843         UChar32 range[3] = { start, end+1, UNICODESET_HIGH };</span>
































 844         add(range, 2, 0);
 845     } else if (start == end) {
 846         add(start);
 847     }
 848     return *this;
 849 }
 850 
 851 // #define DEBUG_US_ADD
 852 
 853 #ifdef DEBUG_US_ADD
 854 #include &lt;stdio.h&gt;
 855 void dump(UChar32 c) {
 856     if (c &lt;= 0xFF) {
 857         printf(&quot;%c&quot;, (char)c);
 858     } else {
 859         printf(&quot;U+%04X&quot;, c);
 860     }
 861 }
 862 void dump(const UChar32* list, int32_t len) {
 863     printf(&quot;[&quot;);
</pre>
<hr />
<pre>
 892     // [..., start_k-1, limit_k-1, start_k, limit_k, ..., HIGH]
 893     //                             ^
 894     //                             list[i]
 895 
 896     // i == 0 means c is before the first range
 897 
 898 #ifdef DEBUG_US_ADD
 899     printf(&quot;Add of &quot;);
 900     dump(c);
 901     printf(&quot; found at %d&quot;, i);
 902     printf(&quot;: &quot;);
 903     dump(list, len);
 904     printf(&quot; =&gt; &quot;);
 905 #endif
 906 
 907     if (c == list[i]-1) {
 908         // c is before start of next range
 909         list[i] = c;
 910         // if we touched the HIGH mark, then add a new one
 911         if (c == (UNICODESET_HIGH - 1)) {
<span class="line-modified"> 912             UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified"> 913             ensureCapacity(len+1, status);</span>
<span class="line-modified"> 914             if (U_FAILURE(status)) {</span>
<span class="line-removed"> 915                 return *this; // There is no way to report this error :-(</span>
 916             }
 917             list[len++] = UNICODESET_HIGH;
 918         }
 919         if (i &gt; 0 &amp;&amp; c == list[i-1]) {
 920             // collapse adjacent ranges
 921 
 922             // [..., start_k-1, c, c, limit_k, ..., HIGH]
 923             //                     ^
 924             //                     list[i]
 925 
 926             //for (int32_t k=i-1; k&lt;len-2; ++k) {
 927             //    list[k] = list[k+2];
 928             //}
 929             UChar32* dst = list + i - 1;
 930             UChar32* src = dst + 2;
 931             UChar32* srclimit = list + len;
 932             while (src &lt; srclimit) *(dst++) = *(src++);
 933 
 934             len -= 2;
 935         }
</pre>
<hr />
<pre>
 937 
 938     else if (i &gt; 0 &amp;&amp; c == list[i-1]) {
 939         // c is after end of prior range
 940         list[i-1]++;
 941         // no need to check for collapse here
 942     }
 943 
 944     else {
 945         // At this point we know the new char is not adjacent to
 946         // any existing ranges, and it is not 10FFFF.
 947 
 948 
 949         // [..., start_k-1, limit_k-1, start_k, limit_k, ..., HIGH]
 950         //                             ^
 951         //                             list[i]
 952 
 953         // [..., start_k-1, limit_k-1, c, c+1, start_k, limit_k, ..., HIGH]
 954         //                             ^
 955         //                             list[i]
 956 
<span class="line-modified"> 957         UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified"> 958         ensureCapacity(len+2, status);</span>
<span class="line-modified"> 959         if (U_FAILURE(status)) {</span>
<span class="line-removed"> 960             return *this; // There is no way to report this error :-(</span>
 961         }
 962 
<span class="line-modified"> 963         //for (int32_t k=len-1; k&gt;=i; --k) {</span>
<span class="line-modified"> 964         //    list[k+2] = list[k];</span>
<span class="line-removed"> 965         //}</span>
<span class="line-removed"> 966         UChar32* src = list + len;</span>
<span class="line-removed"> 967         UChar32* dst = src + 2;</span>
<span class="line-removed"> 968         UChar32* srclimit = list + i;</span>
<span class="line-removed"> 969         while (src &gt; srclimit) *(--dst) = *(--src);</span>
<span class="line-removed"> 970 </span>
 971         list[i] = c;
 972         list[i+1] = c+1;
 973         len += 2;
 974     }
 975 
 976 #ifdef DEBUG_US_ADD
 977     dump(list, len);
 978     printf(&quot;\n&quot;);
 979 
 980     for (i=1; i&lt;len; ++i) {
 981         if (list[i] &lt;= list[i-1]) {
 982             // Corrupt array!
 983             printf(&quot;ERROR: list has been corrupted\n&quot;);
 984             exit(1);
 985         }
 986     }
 987 #endif
 988 
 989     releasePattern();
 990     return *this;
 991 }
 992 
 993 /**
 994  * Adds the specified multicharacter to this set if it is not already
 995  * present.  If this set already contains the multicharacter,
 996  * the call leaves this set unchanged.
 997  * Thus &quot;ch&quot; =&gt; {&quot;ch&quot;}
 998  * &lt;br&gt;&lt;b&gt;Warning: you cannot add an empty string (&quot;&quot;) to a UnicodeSet.&lt;/b&gt;
 999  * @param s the source string
1000  * @return the modified set, for chaining
1001  */
1002 UnicodeSet&amp; UnicodeSet::add(const UnicodeString&amp; s) {
1003     if (s.length() == 0 || isFrozen() || isBogus()) return *this;
1004     int32_t cp = getSingleCP(s);
1005     if (cp &lt; 0) {
<span class="line-modified">1006         if (!strings-&gt;contains((void*) &amp;s)) {</span>
1007             _add(s);
1008             releasePattern();
1009         }
1010     } else {
1011         add((UChar32)cp);
1012     }
1013     return *this;
1014 }
1015 
1016 /**
1017  * Adds the given string, in order, to &#39;strings&#39;.  The given string
1018  * must have been checked by the caller to not be empty and to not
1019  * already be in &#39;strings&#39;.
1020  */
1021 void UnicodeSet::_add(const UnicodeString&amp; s) {
1022     if (isFrozen() || isBogus()) {
1023         return;
1024     }





1025     UnicodeString* t = new UnicodeString(s);
1026     if (t == NULL) { // Check for memory allocation error.
1027         setToBogus();
1028         return;
1029     }
<span class="line-removed">1030     UErrorCode ec = U_ZERO_ERROR;</span>
1031     strings-&gt;sortedInsert(t, compareUnicodeString, ec);
1032     if (U_FAILURE(ec)) {
1033         setToBogus();
1034         delete t;
1035     }
1036 }
1037 
1038 /**
1039  * @return a code point IF the string consists of a single one.
1040  * otherwise returns -1.
1041  * @param string to test
1042  */
1043 int32_t UnicodeSet::getSingleCP(const UnicodeString&amp; s) {
1044     //if (s.length() &lt; 1) {
1045     //    throw new IllegalArgumentException(&quot;Can&#39;t use zero-length strings in UnicodeSet&quot;);
1046     //}
1047     if (s.length() &gt; 2) return -1;
1048     if (s.length() == 1) return s.charAt(0);
1049 
1050     // at this point, len = 2
</pre>
<hr />
<pre>
1093     UnicodeSet set;
1094     set.addAll(s);
1095     complementAll(set);
1096     return *this;
1097 }
1098 
1099 /**
1100  * Remove EACH of the characters in this string. Note: &quot;ch&quot; == {&quot;c&quot;, &quot;h&quot;}
1101  * If this set already any particular character, it has no effect on that character.
1102  * @param the source string
1103  * @return the modified set, for chaining
1104  */
1105 UnicodeSet&amp; UnicodeSet::removeAll(const UnicodeString&amp; s) {
1106     UnicodeSet set;
1107     set.addAll(s);
1108     removeAll(set);
1109     return *this;
1110 }
1111 
1112 UnicodeSet&amp; UnicodeSet::removeAllStrings() {
<span class="line-modified">1113     strings-&gt;removeAllElements();</span>



1114     return *this;
1115 }
1116 
1117 
1118 /**
1119  * Makes a set from a multicharacter string. Thus &quot;ch&quot; =&gt; {&quot;ch&quot;}
1120  * &lt;br&gt;&lt;b&gt;Warning: you cannot add an empty string (&quot;&quot;) to a UnicodeSet.&lt;/b&gt;
1121  * @param the source string
1122  * @return a newly created set containing the given string
1123  */
1124 UnicodeSet* U_EXPORT2 UnicodeSet::createFrom(const UnicodeString&amp; s) {
1125     UnicodeSet *set = new UnicodeSet();
1126     if (set != NULL) { // Check for memory allocation error.
1127         set-&gt;add(s);
1128     }
1129     return set;
1130 }
1131 
1132 
1133 /**
</pre>
<hr />
<pre>
1189 /**
1190  * Removes the specified character from this set if it is present.
1191  * The set will not contain the specified range once the call
1192  * returns.
1193  */
1194 UnicodeSet&amp; UnicodeSet::remove(UChar32 c) {
1195     return remove(c, c);
1196 }
1197 
1198 /**
1199  * Removes the specified string from this set if it is present.
1200  * The set will not contain the specified character once the call
1201  * returns.
1202  * @param the source string
1203  * @return the modified set, for chaining
1204  */
1205 UnicodeSet&amp; UnicodeSet::remove(const UnicodeString&amp; s) {
1206     if (s.length() == 0 || isFrozen() || isBogus()) return *this;
1207     int32_t cp = getSingleCP(s);
1208     if (cp &lt; 0) {
<span class="line-modified">1209         strings-&gt;removeElement((void*) &amp;s);</span>
<span class="line-modified">1210         releasePattern();</span>

1211     } else {
1212         remove((UChar32)cp, (UChar32)cp);
1213     }
1214     return *this;
1215 }
1216 
1217 /**
1218  * Complements the specified range in this set.  Any character in
1219  * the range will be removed if it is in this set, or will be
1220  * added if it is not in this set.  If &lt;code&gt;end &gt; start&lt;/code&gt;
1221  * then an empty range is xor&#39;ed, leaving the set unchanged.
1222  *
1223  * @param start first character, inclusive, of range to be removed
1224  * from this set.
1225  * @param end last character, inclusive, of range to be removed
1226  * from this set.
1227  */
1228 UnicodeSet&amp; UnicodeSet::complement(UChar32 start, UChar32 end) {
1229     if (isFrozen() || isBogus()) {
1230         return *this;
</pre>
<hr />
<pre>
1232     if (pinCodePoint(start) &lt;= pinCodePoint(end)) {
1233         UChar32 range[3] = { start, end+1, UNICODESET_HIGH };
1234         exclusiveOr(range, 2, 0);
1235     }
1236     releasePattern();
1237     return *this;
1238 }
1239 
1240 UnicodeSet&amp; UnicodeSet::complement(UChar32 c) {
1241     return complement(c, c);
1242 }
1243 
1244 /**
1245  * This is equivalent to
1246  * &lt;code&gt;complement(MIN_VALUE, MAX_VALUE)&lt;/code&gt;.
1247  */
1248 UnicodeSet&amp; UnicodeSet::complement(void) {
1249     if (isFrozen() || isBogus()) {
1250         return *this;
1251     }
<span class="line-removed">1252     UErrorCode status = U_ZERO_ERROR;</span>
1253     if (list[0] == UNICODESET_LOW) {
<span class="line-modified">1254         ensureBufferCapacity(len-1, status);</span>
<span class="line-removed">1255         if (U_FAILURE(status)) {</span>
<span class="line-removed">1256             return *this;</span>
<span class="line-removed">1257         }</span>
<span class="line-removed">1258         uprv_memcpy(buffer, list + 1, (size_t)(len-1)*sizeof(UChar32));</span>
1259         --len;
1260     } else {
<span class="line-modified">1261         ensureBufferCapacity(len+1, status);</span>
<span class="line-removed">1262         if (U_FAILURE(status)) {</span>
1263             return *this;
1264         }
<span class="line-modified">1265         uprv_memcpy(buffer + 1, list, (size_t)len*sizeof(UChar32));</span>
<span class="line-modified">1266         buffer[0] = UNICODESET_LOW;</span>
1267         ++len;
1268     }
<span class="line-removed">1269     swapBuffers();</span>
1270     releasePattern();
1271     return *this;
1272 }
1273 
1274 /**
1275  * Complement the specified string in this set.
1276  * The set will not contain the specified string once the call
1277  * returns.
1278  * &lt;br&gt;&lt;b&gt;Warning: you cannot add an empty string (&quot;&quot;) to a UnicodeSet.&lt;/b&gt;
1279  * @param s the string to complement
1280  * @return this object, for chaining
1281  */
1282 UnicodeSet&amp; UnicodeSet::complement(const UnicodeString&amp; s) {
1283     if (s.length() == 0 || isFrozen() || isBogus()) return *this;
1284     int32_t cp = getSingleCP(s);
1285     if (cp &lt; 0) {
<span class="line-modified">1286         if (strings-&gt;contains((void*) &amp;s)) {</span>
1287             strings-&gt;removeElement((void*) &amp;s);
1288         } else {
1289             _add(s);
1290         }
1291         releasePattern();
1292     } else {
1293         complement((UChar32)cp, (UChar32)cp);
1294     }
1295     return *this;
1296 }
1297 
1298 /**
1299  * Adds all of the elements in the specified set to this set if
1300  * they&#39;re not already present.  This operation effectively
1301  * modifies this set so that its value is the &lt;i&gt;union&lt;/i&gt; of the two
1302  * sets.  The behavior of this operation is unspecified if the specified
1303  * collection is modified while the operation is in progress.
1304  *
1305  * @param c set whose elements are to be added to this set.
1306  * @see #add(char, char)
1307  */
1308 UnicodeSet&amp; UnicodeSet::addAll(const UnicodeSet&amp; c) {
1309     if ( c.len&gt;0 &amp;&amp; c.list!=NULL ) {
1310         add(c.list, c.len, 0);
1311     }
1312 
1313     // Add strings in order
1314     if ( c.strings!=NULL ) {
1315         for (int32_t i=0; i&lt;c.strings-&gt;size(); ++i) {
1316             const UnicodeString* s = (const UnicodeString*)c.strings-&gt;elementAt(i);
<span class="line-modified">1317             if (!strings-&gt;contains((void*) s)) {</span>
1318                 _add(*s);
1319             }
1320         }
1321     }
1322     return *this;
1323 }
1324 
1325 /**
1326  * Retains only the elements in this set that are contained in the
1327  * specified set.  In other words, removes from this set all of
1328  * its elements that are not contained in the specified set.  This
1329  * operation effectively modifies this set so that its value is
1330  * the &lt;i&gt;intersection&lt;/i&gt; of the two sets.
1331  *
1332  * @param c set that defines which elements this set will retain.
1333  */
1334 UnicodeSet&amp; UnicodeSet::retainAll(const UnicodeSet&amp; c) {
1335     if (isFrozen() || isBogus()) {
1336         return *this;
1337     }
1338     retain(c.list, c.len, 0);
<span class="line-modified">1339     strings-&gt;retainAll(*c.strings);</span>






1340     return *this;
1341 }
1342 
1343 /**
1344  * Removes from this set all of its elements that are contained in the
1345  * specified set.  This operation effectively modifies this
1346  * set so that its value is the &lt;i&gt;asymmetric set difference&lt;/i&gt; of
1347  * the two sets.
1348  *
1349  * @param c set that defines which elements will be removed from
1350  *          this set.
1351  */
1352 UnicodeSet&amp; UnicodeSet::removeAll(const UnicodeSet&amp; c) {
1353     if (isFrozen() || isBogus()) {
1354         return *this;
1355     }
1356     retain(c.list, c.len, 2);
<span class="line-modified">1357     strings-&gt;removeAll(*c.strings);</span>


1358     return *this;
1359 }
1360 
1361 /**
1362  * Complements in this set all elements contained in the specified
1363  * set.  Any character in the other set will be removed if it is
1364  * in this set, or will be added if it is not in this set.
1365  *
1366  * @param c set that defines which elements will be xor&#39;ed from
1367  *          this set.
1368  */
1369 UnicodeSet&amp; UnicodeSet::complementAll(const UnicodeSet&amp; c) {
1370     if (isFrozen() || isBogus()) {
1371         return *this;
1372     }
1373     exclusiveOr(c.list, c.len, 0);
1374 
<span class="line-modified">1375     for (int32_t i=0; i&lt;c.strings-&gt;size(); ++i) {</span>
<span class="line-modified">1376         void* e = c.strings-&gt;elementAt(i);</span>
<span class="line-modified">1377         if (!strings-&gt;removeElement(e)) {</span>
<span class="line-modified">1378             _add(*(const UnicodeString*)e);</span>


1379         }
1380     }
1381     return *this;
1382 }
1383 
1384 /**
1385  * Removes all of the elements from this set.  This set will be
1386  * empty after this call returns.
1387  */
1388 UnicodeSet&amp; UnicodeSet::clear(void) {
1389     if (isFrozen()) {
1390         return *this;
1391     }
<span class="line-modified">1392     if (list != NULL) {</span>
<span class="line-removed">1393         list[0] = UNICODESET_HIGH;</span>
<span class="line-removed">1394     }</span>
1395     len = 1;
1396     releasePattern();
1397     if (strings != NULL) {
1398         strings-&gt;removeAllElements();
1399     }
<span class="line-modified">1400     if (list != NULL &amp;&amp; strings != NULL) {</span>
<span class="line-modified">1401         // Remove bogus</span>
<span class="line-removed">1402         fFlags = 0;</span>
<span class="line-removed">1403     }</span>
1404     return *this;
1405 }
1406 
1407 /**
1408  * Iteration method that returns the number of ranges contained in
1409  * this set.
1410  * @see #getRangeStart
1411  * @see #getRangeEnd
1412  */
1413 int32_t UnicodeSet::getRangeCount() const {
1414     return len/2;
1415 }
1416 
1417 /**
1418  * Iteration method that returns the first character in the
1419  * specified range of this set.
1420  * @see #getRangeCount
1421  * @see #getRangeEnd
1422  */
1423 UChar32 UnicodeSet::getRangeStart(int32_t index) const {
1424     return list[index*2];
1425 }
1426 
1427 /**
1428  * Iteration method that returns the last character in the
1429  * specified range of this set.
1430  * @see #getRangeStart
1431  * @see #getRangeEnd
1432  */
1433 UChar32 UnicodeSet::getRangeEnd(int32_t index) const {
1434     return list[index*2 + 1] - 1;
1435 }
1436 
<span class="line-removed">1437 int32_t UnicodeSet::getStringCount() const {</span>
<span class="line-removed">1438     return strings-&gt;size();</span>
<span class="line-removed">1439 }</span>
<span class="line-removed">1440 </span>
1441 const UnicodeString* UnicodeSet::getString(int32_t index) const {
1442     return (const UnicodeString*) strings-&gt;elementAt(index);
1443 }
1444 
1445 /**
1446  * Reallocate this objects internal structures to take up the least
1447  * possible space, without changing this object&#39;s value.
1448  */
1449 UnicodeSet&amp; UnicodeSet::compact() {
1450     if (isFrozen() || isBogus()) {
1451         return *this;
1452     }
1453     // Delete buffer first to defragment memory less.
<span class="line-modified">1454     if (buffer != NULL) {</span>
1455         uprv_free(buffer);
1456         buffer = NULL;
<span class="line-modified">1457     }</span>
<span class="line-modified">1458     if (len &lt; capacity) {</span>
<span class="line-modified">1459         // Make the capacity equal to len or 1.</span>
<span class="line-modified">1460         // We don&#39;t want to realloc of 0 size.</span>
<span class="line-modified">1461         int32_t newCapacity = len + (len == 0);</span>
<span class="line-modified">1462         UChar32* temp = (UChar32*) uprv_realloc(list, sizeof(UChar32) * newCapacity);</span>






1463         if (temp) {
1464             list = temp;
<span class="line-modified">1465             capacity = newCapacity;</span>
1466         }
1467         // else what the heck happened?! We allocated less memory!
1468         // Oh well. We&#39;ll keep our original array.
1469     }




1470     return *this;
1471 }
1472 
1473 #ifdef DEBUG_SERIALIZE
1474 #include &lt;stdio.h&gt;
1475 #endif
1476 
1477 /**
1478  * Deserialize constructor.
1479  */
<span class="line-modified">1480 UnicodeSet::UnicodeSet(const uint16_t data[], int32_t dataLen, ESerialization serialization, UErrorCode &amp;ec)</span>
<span class="line-modified">1481   : len(1), capacity(1+START_EXTRA), list(0), bmpSet(0), buffer(0),</span>
<span class="line-removed">1482     bufferCapacity(0), patLen(0), pat(NULL), strings(NULL), stringSpan(NULL),</span>
<span class="line-removed">1483     fFlags(0) {</span>
1484 
1485   if(U_FAILURE(ec)) {
1486     setToBogus();
1487     return;
1488   }
1489 
1490   if( (serialization != kSerialized)
1491       || (data==NULL)
1492       || (dataLen &lt; 1)) {
1493     ec = U_ILLEGAL_ARGUMENT_ERROR;
1494     setToBogus();
1495     return;
1496   }
1497 
<span class="line-removed">1498   allocateStrings(ec);</span>
<span class="line-removed">1499   if (U_FAILURE(ec)) {</span>
<span class="line-removed">1500     setToBogus();</span>
<span class="line-removed">1501     return;</span>
<span class="line-removed">1502   }</span>
<span class="line-removed">1503 </span>
1504   // bmp?
1505   int32_t headerSize = ((data[0]&amp;0x8000)) ?2:1;
1506   int32_t bmpLength = (headerSize==1)?data[0]:data[1];
1507 
<span class="line-modified">1508   len = (((data[0]&amp;0x7FFF)-bmpLength)/2)+bmpLength;</span>
1509 #ifdef DEBUG_SERIALIZE
<span class="line-modified">1510   printf(&quot;dataLen %d headerSize %d bmpLen %d len %d. data[0]=%X/%X/%X/%X\n&quot;, dataLen,headerSize,bmpLength,len, data[0],data[1],data[2],data[3]);</span>
1511 #endif
<span class="line-modified">1512   capacity = len+1;</span>
<span class="line-removed">1513   list = (UChar32*) uprv_malloc(sizeof(UChar32) * capacity);</span>
<span class="line-removed">1514   if(!list || U_FAILURE(ec)) {</span>
<span class="line-removed">1515     setToBogus();</span>
1516     return;
1517   }
1518   // copy bmp
1519   int32_t i;
1520   for(i = 0; i&lt; bmpLength;i++) {
1521     list[i] = data[i+headerSize];
1522 #ifdef DEBUG_SERIALIZE
1523     printf(&quot;&lt;&lt;16@%d[%d] %X\n&quot;, i+headerSize, i, list[i]);
1524 #endif
1525   }
1526   // copy smp
<span class="line-modified">1527   for(i=bmpLength;i&lt;len;i++) {</span>
1528     list[i] = ((UChar32)data[headerSize+bmpLength+(i-bmpLength)*2+0] &lt;&lt; 16) +
1529               ((UChar32)data[headerSize+bmpLength+(i-bmpLength)*2+1]);
1530 #ifdef DEBUG_SERIALIZE
1531     printf(&quot;&lt;&lt;32@%d+[%d] %lX\n&quot;, headerSize+bmpLength+i, i, list[i]);
1532 #endif
1533   }
<span class="line-modified">1534   // terminator</span>
<span class="line-modified">1535   list[len++]=UNICODESET_HIGH;</span>



1536 }
1537 
1538 
1539 int32_t UnicodeSet::serialize(uint16_t *dest, int32_t destCapacity, UErrorCode&amp; ec) const {
1540     int32_t bmpLength, length, destLength;
1541 
1542     if (U_FAILURE(ec)) {
1543         return 0;
1544     }
1545 
1546     if (destCapacity&lt;0 || (destCapacity&gt;0 &amp;&amp; dest==NULL)) {
1547         ec=U_ILLEGAL_ARGUMENT_ERROR;
1548         return 0;
1549     }
1550 
1551     /* count necessary 16-bit units */
1552     length=this-&gt;len-1; // Subtract 1 to ignore final UNICODESET_HIGH
1553     // assert(length&gt;=0);
1554     if (length==0) {
1555         /* empty set */
</pre>
<hr />
<pre>
1636  * Allocate our strings vector and return TRUE if successful.
1637  */
1638 UBool UnicodeSet::allocateStrings(UErrorCode &amp;status) {
1639     if (U_FAILURE(status)) {
1640         return FALSE;
1641     }
1642     strings = new UVector(uprv_deleteUObject,
1643                           uhash_compareUnicodeString, 1, status);
1644     if (strings == NULL) { // Check for memory allocation error.
1645         status = U_MEMORY_ALLOCATION_ERROR;
1646         return FALSE;
1647     }
1648     if (U_FAILURE(status)) {
1649         delete strings;
1650         strings = NULL;
1651         return FALSE;
1652     }
1653     return TRUE;
1654 }
1655 
<span class="line-modified">1656 void UnicodeSet::ensureCapacity(int32_t newLen, UErrorCode&amp; ec) {</span>
<span class="line-modified">1657     if (newLen &lt;= capacity)</span>
<span class="line-modified">1658         return;</span>
<span class="line-modified">1659     UChar32* temp = (UChar32*) uprv_realloc(list, sizeof(UChar32) * (newLen + GROW_EXTRA));</span>




















1660     if (temp == NULL) {
<span class="line-modified">1661         ec = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1662         setToBogus();</span>
<span class="line-modified">1663         return;</span>




1664     }
1665     list = temp;
<span class="line-modified">1666     capacity = newLen + GROW_EXTRA;</span>
<span class="line-modified">1667     // else we keep the original contents on the memory failure.</span>
1668 }
1669 
<span class="line-modified">1670 void UnicodeSet::ensureBufferCapacity(int32_t newLen, UErrorCode&amp; ec) {</span>
<span class="line-modified">1671     if (buffer != NULL &amp;&amp; newLen &lt;= bufferCapacity)</span>
<span class="line-modified">1672         return;</span>
<span class="line-modified">1673     UChar32* temp = (UChar32*) uprv_realloc(buffer, sizeof(UChar32) * (newLen + GROW_EXTRA));</span>





1674     if (temp == NULL) {
<span class="line-removed">1675         ec = U_MEMORY_ALLOCATION_ERROR;</span>
1676         setToBogus();
<span class="line-modified">1677         return;</span>





1678     }
1679     buffer = temp;
<span class="line-modified">1680     bufferCapacity = newLen + GROW_EXTRA;</span>
<span class="line-modified">1681     // else we keep the original contents on the memory failure.</span>
1682 }
1683 
1684 /**
1685  * Swap list and buffer.
1686  */
1687 void UnicodeSet::swapBuffers(void) {
1688     // swap list and buffer
1689     UChar32* temp = list;
1690     list = buffer;
1691     buffer = temp;
1692 
1693     int32_t c = capacity;
1694     capacity = bufferCapacity;
1695     bufferCapacity = c;
1696 }
1697 
1698 void UnicodeSet::setToBogus() {
1699     clear(); // Remove everything in the set.
1700     fFlags = kIsBogus;
1701 }
1702 
1703 //----------------------------------------------------------------
1704 // Implementation: Fundamental operators
1705 //----------------------------------------------------------------
1706 
1707 static inline UChar32 max(UChar32 a, UChar32 b) {
1708     return (a &gt; b) ? a : b;
1709 }
1710 
1711 // polarity = 0, 3 is normal: x xor y
1712 // polarity = 1, 2: x xor ~y == x === y
1713 
1714 void UnicodeSet::exclusiveOr(const UChar32* other, int32_t otherLen, int8_t polarity) {
1715     if (isFrozen() || isBogus()) {
1716         return;
1717     }
<span class="line-modified">1718     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-removed">1719     ensureBufferCapacity(len + otherLen, status);</span>
<span class="line-removed">1720     if (U_FAILURE(status)) {</span>
1721         return;
1722     }
1723 
1724     int32_t i = 0, j = 0, k = 0;
1725     UChar32 a = list[i++];
1726     UChar32 b;
1727     if (polarity == 1 || polarity == 2) {
1728         b = UNICODESET_LOW;
1729         if (other[j] == UNICODESET_LOW) { // skip base if already LOW
1730             ++j;
1731             b = other[j];
1732         }
1733     } else {
1734         b = other[j++];
1735     }
1736     // simplest of all the routines
1737     // sort the values, discarding identicals!
1738     for (;;) {
1739         if (a &lt; b) {
1740             buffer[k++] = a;
</pre>
<hr />
<pre>
1748             b = other[j++];
1749         } else { // DONE!
1750             buffer[k++] = UNICODESET_HIGH;
1751             len = k;
1752             break;
1753         }
1754     }
1755     swapBuffers();
1756     releasePattern();
1757 }
1758 
1759 // polarity = 0 is normal: x union y
1760 // polarity = 2: x union ~y
1761 // polarity = 1: ~x union y
1762 // polarity = 3: ~x union ~y
1763 
1764 void UnicodeSet::add(const UChar32* other, int32_t otherLen, int8_t polarity) {
1765     if (isFrozen() || isBogus() || other==NULL) {
1766         return;
1767     }
<span class="line-modified">1768     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-removed">1769     ensureBufferCapacity(len + otherLen, status);</span>
<span class="line-removed">1770     if (U_FAILURE(status)) {</span>
1771         return;
1772     }
1773 
1774     int32_t i = 0, j = 0, k = 0;
1775     UChar32 a = list[i++];
1776     UChar32 b = other[j++];
1777     // change from xor is that we have to check overlapping pairs
1778     // polarity bit 1 means a is second, bit 2 means b is.
1779     for (;;) {
1780         switch (polarity) {
1781           case 0: // both first; take lower if unequal
1782             if (a &lt; b) { // take a
1783                 // Back up over overlapping ranges in buffer[]
1784                 if (k &gt; 0 &amp;&amp; a &lt;= buffer[k-1]) {
1785                     // Pick latter end value in buffer[] vs. list[]
1786                     a = max(list[i], buffer[--k]);
1787                 } else {
1788                     // No overlap
1789                     buffer[k++] = a;
1790                     a = list[i];
</pre>
<hr />
<pre>
1861             }
1862             break;
1863         }
1864     }
1865  loop_end:
1866     buffer[k++] = UNICODESET_HIGH;    // terminate
1867     len = k;
1868     swapBuffers();
1869     releasePattern();
1870 }
1871 
1872 // polarity = 0 is normal: x intersect y
1873 // polarity = 2: x intersect ~y == set-minus
1874 // polarity = 1: ~x intersect y
1875 // polarity = 3: ~x intersect ~y
1876 
1877 void UnicodeSet::retain(const UChar32* other, int32_t otherLen, int8_t polarity) {
1878     if (isFrozen() || isBogus()) {
1879         return;
1880     }
<span class="line-modified">1881     UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-removed">1882     ensureBufferCapacity(len + otherLen, status);</span>
<span class="line-removed">1883     if (U_FAILURE(status)) {</span>
1884         return;
1885     }
1886 
1887     int32_t i = 0, j = 0, k = 0;
1888     UChar32 a = list[i++];
1889     UChar32 b = other[j++];
1890     // change from xor is that we have to check overlapping pairs
1891     // polarity bit 1 means a is second, bit 2 means b is.
1892     for (;;) {
1893         switch (polarity) {
1894           case 0: // both first; drop the smaller
1895             if (a &lt; b) { // drop a
1896                 a = list[i++];
1897                 polarity ^= 1;
1898             } else if (b &lt; a) { // drop b
1899                 b = other[j++];
1900                 polarity ^= 2;
1901             } else { // a == b, take one, drop other
1902                 if (a == UNICODESET_HIGH) goto loop_end;
1903                 buffer[k++] = a;
</pre>
<hr />
<pre>
2109                 _appendToPat(result, end, escapeUnprintable);
2110             }
2111         }
2112     }
2113 
2114     // Default; emit the ranges as pairs
2115     else {
2116         for (int32_t i = 0; i &lt; count; ++i) {
2117             UChar32 start = getRangeStart(i);
2118             UChar32 end = getRangeEnd(i);
2119             _appendToPat(result, start, escapeUnprintable);
2120             if (start != end) {
2121                 if ((start+1) != end) {
2122                     result.append(HYPHEN);
2123                 }
2124                 _appendToPat(result, end, escapeUnprintable);
2125             }
2126         }
2127     }
2128 
<span class="line-modified">2129     for (int32_t i = 0; i&lt;strings-&gt;size(); ++i) {</span>
<span class="line-modified">2130         result.append(OPEN_BRACE);</span>
<span class="line-modified">2131         _appendToPat(result,</span>
<span class="line-modified">2132                      *(const UnicodeString*) strings-&gt;elementAt(i),</span>
<span class="line-modified">2133                      escapeUnprintable);</span>
<span class="line-modified">2134         result.append(CLOSE_BRACE);</span>


2135     }
2136     return result.append(SET_CLOSE);
2137 }
2138 
2139 /**
2140 * Release existing cached pattern
2141 */
2142 void UnicodeSet::releasePattern() {
2143     if (pat) {
2144         uprv_free(pat);
2145         pat = NULL;
2146         patLen = 0;
2147     }
2148 }
2149 
2150 /**
2151 * Set the new pattern to cache.
2152 */
<span class="line-modified">2153 void UnicodeSet::setPattern(const UnicodeString&amp; newPat) {</span>
2154     releasePattern();
<span class="line-removed">2155     int32_t newPatLen = newPat.length();</span>
2156     pat = (UChar *)uprv_malloc((newPatLen + 1) * sizeof(UChar));
2157     if (pat) {
2158         patLen = newPatLen;
<span class="line-modified">2159         newPat.extractBetween(0, patLen, pat);</span>
2160         pat[patLen] = 0;
2161     }
2162     // else we don&#39;t care if malloc failed. This was just a nice cache.
2163     // We can regenerate an equivalent pattern later when requested.
2164 }
2165 
2166 UnicodeFunctor *UnicodeSet::freeze() {
2167     if(!isFrozen() &amp;&amp; !isBogus()) {
<span class="line-modified">2168         // Do most of what compact() does before freezing because</span>
<span class="line-removed">2169         // compact() will not work when the set is frozen.</span>
<span class="line-removed">2170         // Small modification: Don&#39;t shrink if the savings would be tiny (&lt;=GROW_EXTRA).</span>
<span class="line-removed">2171 </span>
<span class="line-removed">2172         // Delete buffer first to defragment memory less.</span>
<span class="line-removed">2173         if (buffer != NULL) {</span>
<span class="line-removed">2174             uprv_free(buffer);</span>
<span class="line-removed">2175             buffer = NULL;</span>
<span class="line-removed">2176         }</span>
<span class="line-removed">2177         if (capacity &gt; (len + GROW_EXTRA)) {</span>
<span class="line-removed">2178             // Make the capacity equal to len or 1.</span>
<span class="line-removed">2179             // We don&#39;t want to realloc of 0 size.</span>
<span class="line-removed">2180             capacity = len + (len == 0);</span>
<span class="line-removed">2181             list = (UChar32*) uprv_realloc(list, sizeof(UChar32) * capacity);</span>
<span class="line-removed">2182             if (list == NULL) { // Check for memory allocation error.</span>
<span class="line-removed">2183                 setToBogus();</span>
<span class="line-removed">2184                 return this;</span>
<span class="line-removed">2185             }</span>
<span class="line-removed">2186         }</span>
2187 
2188         // Optimize contains() and span() and similar functions.
<span class="line-modified">2189         if (!strings-&gt;isEmpty()) {</span>
2190             stringSpan = new UnicodeSetStringSpan(*this, *strings, UnicodeSetStringSpan::ALL);
<span class="line-modified">2191             if (stringSpan != NULL &amp;&amp; !stringSpan-&gt;needsStringSpanUTF16()) {</span>



2192                 // All strings are irrelevant for span() etc. because
2193                 // all of each string&#39;s code points are contained in this set.
2194                 // Do not check needsStringSpanUTF8() because UTF-8 has at most as
2195                 // many relevant strings as UTF-16.
2196                 // (Thus needsStringSpanUTF8() implies needsStringSpanUTF16().)
2197                 delete stringSpan;
2198                 stringSpan = NULL;
2199             }
2200         }
2201         if (stringSpan == NULL) {
2202             // No span-relevant strings: Optimize for code point spans.
2203             bmpSet=new BMPSet(list, len);
2204             if (bmpSet == NULL) { // Check for memory allocation error.
2205                 setToBogus();
2206             }
2207         }
2208     }
2209     return this;
2210 }
2211 
2212 int32_t UnicodeSet::span(const UChar *s, int32_t length, USetSpanCondition spanCondition) const {
2213     if(length&gt;0 &amp;&amp; bmpSet!=NULL) {
2214         return (int32_t)(bmpSet-&gt;span(s, s+length, spanCondition)-s);
2215     }
2216     if(length&lt;0) {
2217         length=u_strlen(s);
2218     }
2219     if(length==0) {
2220         return 0;
2221     }
2222     if(stringSpan!=NULL) {
2223         return stringSpan-&gt;span(s, length, spanCondition);
<span class="line-modified">2224     } else if(!strings-&gt;isEmpty()) {</span>
2225         uint32_t which= spanCondition==USET_SPAN_NOT_CONTAINED ?
2226                             UnicodeSetStringSpan::FWD_UTF16_NOT_CONTAINED :
2227                             UnicodeSetStringSpan::FWD_UTF16_CONTAINED;
2228         UnicodeSetStringSpan strSpan(*this, *strings, which);
2229         if(strSpan.needsStringSpanUTF16()) {
2230             return strSpan.span(s, length, spanCondition);
2231         }
2232     }
2233 
2234     if(spanCondition!=USET_SPAN_NOT_CONTAINED) {
2235         spanCondition=USET_SPAN_CONTAINED;  // Pin to 0/1 values.
2236     }
2237 
2238     UChar32 c;
2239     int32_t start=0, prev=0;
2240     do {
2241         U16_NEXT(s, start, length, c);
2242         if(spanCondition!=contains(c)) {
2243             break;
2244         }
2245     } while((prev=start)&lt;length);
2246     return prev;
2247 }
2248 
2249 int32_t UnicodeSet::spanBack(const UChar *s, int32_t length, USetSpanCondition spanCondition) const {
2250     if(length&gt;0 &amp;&amp; bmpSet!=NULL) {
2251         return (int32_t)(bmpSet-&gt;spanBack(s, s+length, spanCondition)-s);
2252     }
2253     if(length&lt;0) {
2254         length=u_strlen(s);
2255     }
2256     if(length==0) {
2257         return 0;
2258     }
2259     if(stringSpan!=NULL) {
2260         return stringSpan-&gt;spanBack(s, length, spanCondition);
<span class="line-modified">2261     } else if(!strings-&gt;isEmpty()) {</span>
2262         uint32_t which= spanCondition==USET_SPAN_NOT_CONTAINED ?
2263                             UnicodeSetStringSpan::BACK_UTF16_NOT_CONTAINED :
2264                             UnicodeSetStringSpan::BACK_UTF16_CONTAINED;
2265         UnicodeSetStringSpan strSpan(*this, *strings, which);
2266         if(strSpan.needsStringSpanUTF16()) {
2267             return strSpan.spanBack(s, length, spanCondition);
2268         }
2269     }
2270 
2271     if(spanCondition!=USET_SPAN_NOT_CONTAINED) {
2272         spanCondition=USET_SPAN_CONTAINED;  // Pin to 0/1 values.
2273     }
2274 
2275     UChar32 c;
2276     int32_t prev=length;
2277     do {
2278         U16_PREV(s, 0, length, c);
2279         if(spanCondition!=contains(c)) {
2280             break;
2281         }
2282     } while((prev=length)&gt;0);
2283     return prev;
2284 }
2285 
2286 int32_t UnicodeSet::spanUTF8(const char *s, int32_t length, USetSpanCondition spanCondition) const {
2287     if(length&gt;0 &amp;&amp; bmpSet!=NULL) {
2288         const uint8_t *s0=(const uint8_t *)s;
2289         return (int32_t)(bmpSet-&gt;spanUTF8(s0, length, spanCondition)-s0);
2290     }
2291     if(length&lt;0) {
2292         length=(int32_t)uprv_strlen(s);
2293     }
2294     if(length==0) {
2295         return 0;
2296     }
2297     if(stringSpan!=NULL) {
2298         return stringSpan-&gt;spanUTF8((const uint8_t *)s, length, spanCondition);
<span class="line-modified">2299     } else if(!strings-&gt;isEmpty()) {</span>
2300         uint32_t which= spanCondition==USET_SPAN_NOT_CONTAINED ?
2301                             UnicodeSetStringSpan::FWD_UTF8_NOT_CONTAINED :
2302                             UnicodeSetStringSpan::FWD_UTF8_CONTAINED;
2303         UnicodeSetStringSpan strSpan(*this, *strings, which);
2304         if(strSpan.needsStringSpanUTF8()) {
2305             return strSpan.spanUTF8((const uint8_t *)s, length, spanCondition);
2306         }
2307     }
2308 
2309     if(spanCondition!=USET_SPAN_NOT_CONTAINED) {
2310         spanCondition=USET_SPAN_CONTAINED;  // Pin to 0/1 values.
2311     }
2312 
2313     UChar32 c;
2314     int32_t start=0, prev=0;
2315     do {
2316         U8_NEXT_OR_FFFD(s, start, length, c);
2317         if(spanCondition!=contains(c)) {
2318             break;
2319         }
2320     } while((prev=start)&lt;length);
2321     return prev;
2322 }
2323 
2324 int32_t UnicodeSet::spanBackUTF8(const char *s, int32_t length, USetSpanCondition spanCondition) const {
2325     if(length&gt;0 &amp;&amp; bmpSet!=NULL) {
2326         const uint8_t *s0=(const uint8_t *)s;
2327         return bmpSet-&gt;spanBackUTF8(s0, length, spanCondition);
2328     }
2329     if(length&lt;0) {
2330         length=(int32_t)uprv_strlen(s);
2331     }
2332     if(length==0) {
2333         return 0;
2334     }
2335     if(stringSpan!=NULL) {
2336         return stringSpan-&gt;spanBackUTF8((const uint8_t *)s, length, spanCondition);
<span class="line-modified">2337     } else if(!strings-&gt;isEmpty()) {</span>
2338         uint32_t which= spanCondition==USET_SPAN_NOT_CONTAINED ?
2339                             UnicodeSetStringSpan::BACK_UTF8_NOT_CONTAINED :
2340                             UnicodeSetStringSpan::BACK_UTF8_CONTAINED;
2341         UnicodeSetStringSpan strSpan(*this, *strings, which);
2342         if(strSpan.needsStringSpanUTF8()) {
2343             return strSpan.spanBackUTF8((const uint8_t *)s, length, spanCondition);
2344         }
2345     }
2346 
2347     if(spanCondition!=USET_SPAN_NOT_CONTAINED) {
2348         spanCondition=USET_SPAN_CONTAINED;  // Pin to 0/1 values.
2349     }
2350 
2351     UChar32 c;
2352     int32_t prev=length;
2353     do {
2354         U8_PREV_OR_FFFD(s, 0, length, c);
2355         if(spanCondition!=contains(c)) {
2356             break;
2357         }
</pre>
</td>
<td>
<hr />
<pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 *   Copyright (C) 1999-2015, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8 *   Date        Name        Description
   9 *   10/20/99    alan        Creation.
  10 **********************************************************************
  11 */
  12 
  13 #include &quot;unicode/utypes.h&quot;
  14 #include &quot;unicode/parsepos.h&quot;
  15 #include &quot;unicode/symtable.h&quot;
  16 #include &quot;unicode/uniset.h&quot;
<span class="line-added">  17 #include &quot;unicode/ustring.h&quot;</span>
  18 #include &quot;unicode/utf8.h&quot;
  19 #include &quot;unicode/utf16.h&quot;
  20 #include &quot;ruleiter.h&quot;
  21 #include &quot;cmemory.h&quot;
  22 #include &quot;cstring.h&quot;
  23 #include &quot;patternprops.h&quot;
  24 #include &quot;uelement.h&quot;
  25 #include &quot;util.h&quot;
  26 #include &quot;uvector.h&quot;
  27 #include &quot;charstr.h&quot;
  28 #include &quot;ustrfmt.h&quot;
  29 #include &quot;uassert.h&quot;
  30 #include &quot;bmpset.h&quot;
  31 #include &quot;unisetspan.h&quot;
  32 
  33 // Define UChar constants using hex for EBCDIC compatibility
  34 // Used #define to reduce private static exports and memory access time.
  35 #define SET_OPEN        ((UChar)0x005B) /*[*/
  36 #define SET_CLOSE       ((UChar)0x005D) /*]*/
  37 #define HYPHEN          ((UChar)0x002D) /*-*/
  38 #define COMPLEMENT      ((UChar)0x005E) /*^*/
  39 #define COLON           ((UChar)0x003A) /*:*/
  40 #define BACKSLASH       ((UChar)0x005C) /*\*/
  41 #define INTERSECTION    ((UChar)0x0026) /*&amp;*/
  42 #define UPPER_U         ((UChar)0x0055) /*U*/
  43 #define LOWER_U         ((UChar)0x0075) /*u*/
  44 #define OPEN_BRACE      ((UChar)123)    /*{*/
  45 #define CLOSE_BRACE     ((UChar)125)    /*}*/
  46 #define UPPER_P         ((UChar)0x0050) /*P*/
  47 #define LOWER_P         ((UChar)0x0070) /*p*/
  48 #define UPPER_N         ((UChar)78)     /*N*/
  49 #define EQUALS          ((UChar)0x003D) /*=*/
  50 
  51 // HIGH_VALUE &gt; all valid values. 110000 for codepoints
  52 #define UNICODESET_HIGH 0x0110000
  53 
  54 // LOW &lt;= all valid values. ZERO for codepoints
  55 #define UNICODESET_LOW 0x000000
  56 
<span class="line-modified">  57 /** Max list [0, 1, 2, ..., max code point, HIGH] */</span>
<span class="line-modified">  58 constexpr int32_t MAX_LENGTH = UNICODESET_HIGH + 1;</span>



  59 
  60 U_NAMESPACE_BEGIN
  61 
  62 SymbolTable::~SymbolTable() {}
  63 
  64 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(UnicodeSet)
  65 
  66 /**
  67  * Modify the given UChar32 variable so that it is in range, by
  68  * pinning values &lt; UNICODESET_LOW to UNICODESET_LOW, and
  69  * pinning values &gt; UNICODESET_HIGH-1 to UNICODESET_HIGH-1.
  70  * It modifies its argument in-place and also returns it.
  71  */
  72 static inline UChar32 pinCodePoint(UChar32&amp; c) {
  73     if (c &lt; UNICODESET_LOW) {
  74         c = UNICODESET_LOW;
  75     } else if (c &gt; (UNICODESET_HIGH-1)) {
  76         c = (UNICODESET_HIGH-1);
  77     }
  78     return c;
</pre>
<hr />
<pre>
 118 
 119 #define _dbgct(set)
 120 #define _dbgdt(set)
 121 
 122 #endif
 123 
 124 //----------------------------------------------------------------
 125 // UnicodeString in UVector support
 126 //----------------------------------------------------------------
 127 
 128 static void U_CALLCONV cloneUnicodeString(UElement *dst, UElement *src) {
 129     dst-&gt;pointer = new UnicodeString(*(UnicodeString*)src-&gt;pointer);
 130 }
 131 
 132 static int8_t U_CALLCONV compareUnicodeString(UElement t1, UElement t2) {
 133     const UnicodeString &amp;a = *(const UnicodeString*)t1.pointer;
 134     const UnicodeString &amp;b = *(const UnicodeString*)t2.pointer;
 135     return a.compare(b);
 136 }
 137 
<span class="line-added"> 138 UBool UnicodeSet::hasStrings() const {</span>
<span class="line-added"> 139     return strings != nullptr &amp;&amp; !strings-&gt;isEmpty();</span>
<span class="line-added"> 140 }</span>
<span class="line-added"> 141 </span>
<span class="line-added"> 142 int32_t UnicodeSet::stringsSize() const {</span>
<span class="line-added"> 143     return strings == nullptr ? 0 : strings-&gt;size();</span>
<span class="line-added"> 144 }</span>
<span class="line-added"> 145 </span>
<span class="line-added"> 146 UBool UnicodeSet::stringsContains(const UnicodeString &amp;s) const {</span>
<span class="line-added"> 147     return strings != nullptr &amp;&amp; strings-&gt;contains((void*) &amp;s);</span>
<span class="line-added"> 148 }</span>
<span class="line-added"> 149 </span>
 150 //----------------------------------------------------------------
 151 // Constructors &amp;c
 152 //----------------------------------------------------------------
 153 
 154 /**
 155  * Constructs an empty set.
 156  */
<span class="line-modified"> 157 UnicodeSet::UnicodeSet() {</span>
<span class="line-modified"> 158     list[0] = UNICODESET_HIGH;</span>















 159     _dbgct(this);
 160 }
 161 
 162 /**
 163  * Constructs a set containing the given range. If &lt;code&gt;end &gt;
 164  * start&lt;/code&gt; then an empty set is created.
 165  *
 166  * @param start first character, inclusive, of range
 167  * @param end last character, inclusive, of range
 168  */
<span class="line-modified"> 169 UnicodeSet::UnicodeSet(UChar32 start, UChar32 end) {</span>
<span class="line-modified"> 170     list[0] = UNICODESET_HIGH;</span>
<span class="line-modified"> 171     add(start, end);</span>















 172     _dbgct(this);
 173 }
 174 
 175 /**
 176  * Constructs a set that is identical to the given UnicodeSet.
 177  */
<span class="line-modified"> 178 UnicodeSet::UnicodeSet(const UnicodeSet&amp; o) : UnicodeFilter(o) {</span>
<span class="line-modified"> 179     *this = o;</span>


















 180     _dbgct(this);
 181 }
 182 
 183 // Copy-construct as thawed.
<span class="line-modified"> 184 UnicodeSet::UnicodeSet(const UnicodeSet&amp; o, UBool /* asThawed */) : UnicodeFilter(o) {</span>
<span class="line-modified"> 185     if (ensureCapacity(o.len)) {</span>













 186         // *this = o except for bmpSet and stringSpan
 187         len = o.len;
 188         uprv_memcpy(list, o.list, (size_t)len*sizeof(UChar32));
<span class="line-modified"> 189         if (o.hasStrings()) {</span>
<span class="line-modified"> 190             UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified"> 191             if (!allocateStrings(status) ||</span>
<span class="line-modified"> 192                     (strings-&gt;assign(*o.strings, cloneUnicodeString, status), U_FAILURE(status))) {</span>
<span class="line-modified"> 193                 setToBogus();</span>
<span class="line-added"> 194                 return;</span>
<span class="line-added"> 195             }</span>
 196         }
 197         if (o.pat) {
<span class="line-modified"> 198             setPattern(o.pat, o.patLen);</span>
 199         }
<span class="line-modified"> 200         _dbgct(this);</span>


 201     }

 202 }
 203 
 204 /**
 205  * Destructs the set.
 206  */
 207 UnicodeSet::~UnicodeSet() {
 208     _dbgdt(this); // first!
<span class="line-modified"> 209     if (list != stackList) {</span>
<span class="line-added"> 210         uprv_free(list);</span>
<span class="line-added"> 211     }</span>
 212     delete bmpSet;
<span class="line-modified"> 213     if (buffer != stackList) {</span>
 214         uprv_free(buffer);
 215     }
 216     delete strings;
 217     delete stringSpan;
 218     releasePattern();
 219 }
 220 
 221 /**
 222  * Assigns this object to be a copy of another.
 223  */
 224 UnicodeSet&amp; UnicodeSet::operator=(const UnicodeSet&amp; o) {
<span class="line-added"> 225     return copyFrom(o, FALSE);</span>
<span class="line-added"> 226 }</span>
<span class="line-added"> 227 </span>
<span class="line-added"> 228 UnicodeSet&amp; UnicodeSet::copyFrom(const UnicodeSet&amp; o, UBool asThawed) {</span>
 229     if (this == &amp;o) {
 230         return *this;
 231     }
 232     if (isFrozen()) {
 233         return *this;
 234     }
 235     if (o.isBogus()) {
 236         setToBogus();
 237         return *this;
 238     }
<span class="line-modified"> 239     if (!ensureCapacity(o.len)) {</span>
<span class="line-modified"> 240         // ensureCapacity will mark the UnicodeSet as Bogus if OOM failure happens.</span>
<span class="line-modified"> 241         return *this;</span>

 242     }
 243     len = o.len;
 244     uprv_memcpy(list, o.list, (size_t)len*sizeof(UChar32));
<span class="line-modified"> 245     if (o.bmpSet != nullptr &amp;&amp; !asThawed) {</span>


 246         bmpSet = new BMPSet(*o.bmpSet, list, len);
 247         if (bmpSet == NULL) { // Check for memory allocation error.
 248             setToBogus();
 249             return *this;
 250         }
 251     }
<span class="line-modified"> 252     if (o.hasStrings()) {</span>
<span class="line-modified"> 253         UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified"> 254         if ((strings == nullptr &amp;&amp; !allocateStrings(status)) ||</span>
<span class="line-modified"> 255                 (strings-&gt;assign(*o.strings, cloneUnicodeString, status), U_FAILURE(status))) {</span>
<span class="line-modified"> 256             setToBogus();</span>
<span class="line-added"> 257             return *this;</span>
<span class="line-added"> 258         }</span>
<span class="line-added"> 259     } else if (hasStrings()) {</span>
<span class="line-added"> 260         strings-&gt;removeAllElements();</span>
 261     }
<span class="line-modified"> 262     if (o.stringSpan != nullptr &amp;&amp; !asThawed) {</span>


 263         stringSpan = new UnicodeSetStringSpan(*o.stringSpan, *strings);
 264         if (stringSpan == NULL) { // Check for memory allocation error.
 265             setToBogus();
 266             return *this;
 267         }
 268     }
 269     releasePattern();
 270     if (o.pat) {
<span class="line-modified"> 271         setPattern(o.pat, o.patLen);</span>
 272     }
 273     return *this;
 274 }
 275 
 276 /**
 277  * Returns a copy of this object.  All UnicodeMatcher objects have
 278  * to support cloning in order to allow classes using
 279  * UnicodeMatchers, such as Transliterator, to implement cloning.
 280  */
 281 UnicodeFunctor* UnicodeSet::clone() const {
 282     return new UnicodeSet(*this);
 283 }
 284 
 285 UnicodeFunctor *UnicodeSet::cloneAsThawed() const {
 286     return new UnicodeSet(*this, TRUE);
 287 }
 288 
 289 /**
 290  * Compares the specified object with this set for equality.  Returns
 291  * &lt;tt&gt;true&lt;/tt&gt; if the two sets
 292  * have the same size, and every member of the specified set is
 293  * contained in this set (or equivalently, every member of this set is
 294  * contained in the specified set).
 295  *
 296  * @param o set to be compared for equality with this set.
 297  * @return &lt;tt&gt;true&lt;/tt&gt; if the specified set is equal to this set.
 298  */
 299 UBool UnicodeSet::operator==(const UnicodeSet&amp; o) const {
 300     if (len != o.len) return FALSE;
 301     for (int32_t i = 0; i &lt; len; ++i) {
 302         if (list[i] != o.list[i]) return FALSE;
 303     }
<span class="line-modified"> 304     if (hasStrings() != o.hasStrings()) { return FALSE; }</span>
<span class="line-added"> 305     if (hasStrings() &amp;&amp; *strings != *o.strings) return FALSE;</span>
 306     return TRUE;
 307 }
 308 
 309 /**
 310  * Returns the hash code value for this set.
 311  *
 312  * @return the hash code value for this set.
 313  * @see Object#hashCode()
 314  */
 315 int32_t UnicodeSet::hashCode(void) const {
<span class="line-modified"> 316     uint32_t result = static_cast&lt;uint32_t&gt;(len);</span>
 317     for (int32_t i = 0; i &lt; len; ++i) {
<span class="line-modified"> 318         result *= 1000003u;</span>
 319         result += list[i];
 320     }
<span class="line-modified"> 321     return static_cast&lt;int32_t&gt;(result);</span>
 322 }
 323 
 324 //----------------------------------------------------------------
 325 // Public API
 326 //----------------------------------------------------------------
 327 
 328 /**
 329  * Returns the number of elements in this set (its cardinality),
 330  * Note than the elements of a set may include both individual
 331  * codepoints and strings.
 332  *
 333  * @return the number of elements in this set (its cardinality).
 334  */
 335 int32_t UnicodeSet::size(void) const {
 336     int32_t n = 0;
 337     int32_t count = getRangeCount();
 338     for (int32_t i = 0; i &lt; count; ++i) {
 339         n += getRangeEnd(i) - getRangeStart(i) + 1;
 340     }
<span class="line-modified"> 341     return n + stringsSize();</span>
 342 }
 343 
 344 /**
 345  * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements.
 346  *
 347  * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements.
 348  */
 349 UBool UnicodeSet::isEmpty(void) const {
<span class="line-modified"> 350     return len == 1 &amp;&amp; !hasStrings();</span>
 351 }
 352 
 353 /**
 354  * Returns true if this set contains the given character.
 355  * @param c character to be checked for containment
 356  * @return true if the test condition is met
 357  */
 358 UBool UnicodeSet::contains(UChar32 c) const {
 359     // Set i to the index of the start item greater than ch
 360     // We know we will terminate without length test!
 361     // LATER: for large sets, add binary search
 362     //int32_t i = -1;
 363     //for (;;) {
 364     //    if (c &lt; list[++i]) break;
 365     //}
 366     if (bmpSet != NULL) {
 367         return bmpSet-&gt;contains(c);
 368     }
 369     if (stringSpan != NULL) {
 370         return stringSpan-&gt;contains(c);
</pre>
<hr />
<pre>
 430  */
 431 UBool UnicodeSet::contains(UChar32 start, UChar32 end) const {
 432     //int32_t i = -1;
 433     //for (;;) {
 434     //    if (start &lt; list[++i]) break;
 435     //}
 436     int32_t i = findCodePoint(start);
 437     return ((i &amp; 1) != 0 &amp;&amp; end &lt; list[i]);
 438 }
 439 
 440 /**
 441  * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains the given
 442  * multicharacter string.
 443  * @param s string to be checked for containment
 444  * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified string
 445  */
 446 UBool UnicodeSet::contains(const UnicodeString&amp; s) const {
 447     if (s.length() == 0) return FALSE;
 448     int32_t cp = getSingleCP(s);
 449     if (cp &lt; 0) {
<span class="line-modified"> 450         return stringsContains(s);</span>
 451     } else {
 452         return contains((UChar32) cp);
 453     }
 454 }
 455 
 456 /**
 457  * Returns true if this set contains all the characters and strings
 458  * of the given set.
 459  * @param c set to be checked for containment
 460  * @return true if the test condition is met
 461  */
 462 UBool UnicodeSet::containsAll(const UnicodeSet&amp; c) const {
 463     // The specified set is a subset if all of its pairs are contained in
 464     // this set.  It&#39;s possible to code this more efficiently in terms of
 465     // direct manipulation of the inversion lists if the need arises.
 466     int32_t n = c.getRangeCount();
 467     for (int i=0; i&lt;n; ++i) {
 468         if (!contains(c.getRangeStart(i), c.getRangeEnd(i))) {
 469             return FALSE;
 470         }
 471     }
<span class="line-modified"> 472     return !c.hasStrings() || (strings != nullptr &amp;&amp; strings-&gt;containsAll(*c.strings));</span>

 473 }
 474 
 475 /**
 476  * Returns true if this set contains all the characters
 477  * of the given string.
 478  * @param s string containing characters to be checked for containment
 479  * @return true if the test condition is met
 480  */
 481 UBool UnicodeSet::containsAll(const UnicodeString&amp; s) const {
 482     return (UBool)(span(s.getBuffer(), s.length(), USET_SPAN_CONTAINED) ==
 483                    s.length());
 484 }
 485 
 486 /**
 487  * Returns true if this set contains none of the characters
 488  * of the given range.
 489  * @param start first character, inclusive, of the range
 490  * @param end last character, inclusive, of the range
 491  * @return true if the test condition is met
 492  */
</pre>
<hr />
<pre>
 498     int32_t i = findCodePoint(start);
 499     return ((i &amp; 1) == 0 &amp;&amp; end &lt; list[i]);
 500 }
 501 
 502 /**
 503  * Returns true if this set contains none of the characters and strings
 504  * of the given set.
 505  * @param c set to be checked for containment
 506  * @return true if the test condition is met
 507  */
 508 UBool UnicodeSet::containsNone(const UnicodeSet&amp; c) const {
 509     // The specified set is a subset if all of its pairs are contained in
 510     // this set.  It&#39;s possible to code this more efficiently in terms of
 511     // direct manipulation of the inversion lists if the need arises.
 512     int32_t n = c.getRangeCount();
 513     for (int32_t i=0; i&lt;n; ++i) {
 514         if (!containsNone(c.getRangeStart(i), c.getRangeEnd(i))) {
 515             return FALSE;
 516         }
 517     }
<span class="line-modified"> 518     return strings == nullptr || !c.hasStrings() || strings-&gt;containsNone(*c.strings);</span>

 519 }
 520 
 521 /**
 522  * Returns true if this set contains none of the characters
 523  * of the given string.
 524  * @param s string containing characters to be checked for containment
 525  * @return true if the test condition is met
 526  */
 527 UBool UnicodeSet::containsNone(const UnicodeString&amp; s) const {
 528     return (UBool)(span(s.getBuffer(), s.length(), USET_SPAN_NOT_CONTAINED) ==
 529                    s.length());
 530 }
 531 
 532 /**
 533  * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains any character whose low byte
 534  * is the given value.  This is used by &lt;tt&gt;RuleBasedTransliterator&lt;/tt&gt; for
 535  * indexing.
 536  */
 537 UBool UnicodeSet::matchesIndexValue(uint8_t v) const {
 538     /* The index value v, in the range [0,255], is contained in this set if
 539      * it is contained in any pair of this set.  Pairs either have the high
 540      * bytes equal, or unequal.  If the high bytes are equal, then we have
 541      * aaxx..aayy, where aa is the high byte.  Then v is contained if xx &lt;=
 542      * v &lt;= yy.  If the high bytes are unequal we have aaxx..bbyy, bb&gt;aa.
 543      * Then v is contained if xx &lt;= v || v &lt;= yy.  (This is identical to the
 544      * time zone month containment logic.)
 545      */
 546     int32_t i;
 547     int32_t rangeCount=getRangeCount();
 548     for (i=0; i&lt;rangeCount; ++i) {
 549         UChar32 low = getRangeStart(i);
 550         UChar32 high = getRangeEnd(i);
 551         if ((low &amp; ~0xFF) == (high &amp; ~0xFF)) {
 552             if ((low &amp; 0xFF) &lt;= v &amp;&amp; v &lt;= (high &amp; 0xFF)) {
 553                 return TRUE;
 554             }
 555         } else if ((low &amp; 0xFF) &lt;= v || v &lt;= (high &amp; 0xFF)) {
 556             return TRUE;
 557         }
 558     }
<span class="line-modified"> 559     if (hasStrings()) {</span>
 560         for (i=0; i&lt;strings-&gt;size(); ++i) {
 561             const UnicodeString&amp; s = *(const UnicodeString*)strings-&gt;elementAt(i);
 562             //if (s.length() == 0) {
 563             //    // Empty strings match everything
 564             //    return TRUE;
 565             //}
 566             // assert(s.length() != 0); // We enforce this elsewhere
 567             UChar32 c = s.char32At(0);
 568             if ((c &amp; 0xFF) == v) {
 569                 return TRUE;
 570             }
 571         }
 572     }
 573     return FALSE;
 574 }
 575 
 576 /**
 577  * Implementation of UnicodeMatcher::matches().  Always matches the
 578  * longest possible multichar string.
 579  */
 580 UMatchDegree UnicodeSet::matches(const Replaceable&amp; text,
 581                                  int32_t&amp; offset,
 582                                  int32_t limit,
 583                                  UBool incremental) {
 584     if (offset == limit) {
 585         // Strings, if any, have length != 0, so we don&#39;t worry
 586         // about them here.  If we ever allow zero-length strings
 587         // we much check for them here.
 588         if (contains(U_ETHER)) {
 589             return incremental ? U_PARTIAL_MATCH : U_MATCH;
 590         } else {
 591             return U_MISMATCH;
 592         }
 593     } else {
<span class="line-modified"> 594         if (hasStrings()) { // try strings first</span>
 595 
 596             // might separate forward and backward loops later
 597             // for now they are combined
 598 
 599             // TODO Improve efficiency of this, at least in the forward
 600             // direction, if not in both.  In the forward direction we
 601             // can assume the strings are sorted.
 602 
 603             int32_t i;
 604             UBool forward = offset &lt; limit;
 605 
 606             // firstChar is the leftmost char to match in the
 607             // forward direction or the rightmost char to match in
 608             // the reverse direction.
 609             UChar firstChar = text.charAt(offset);
 610 
 611             // If there are multiple strings that can match we
 612             // return the longest match.
 613             int32_t highWaterLength = 0;
 614 
</pre>
<hr />
<pre>
 775  */
 776 UnicodeSet&amp; UnicodeSet::set(UChar32 start, UChar32 end) {
 777     clear();
 778     complement(start, end);
 779     return *this;
 780 }
 781 
 782 /**
 783  * Adds the specified range to this set if it is not already
 784  * present.  If this set already contains the specified range,
 785  * the call leaves this set unchanged.  If &lt;code&gt;end &gt; start&lt;/code&gt;
 786  * then an empty range is added, leaving the set unchanged.
 787  *
 788  * @param start first character, inclusive, of range to be added
 789  * to this set.
 790  * @param end last character, inclusive, of range to be added
 791  * to this set.
 792  */
 793 UnicodeSet&amp; UnicodeSet::add(UChar32 start, UChar32 end) {
 794     if (pinCodePoint(start) &lt; pinCodePoint(end)) {
<span class="line-modified"> 795         UChar32 limit = end + 1;</span>
<span class="line-added"> 796         // Fast path for adding a new range after the last one.</span>
<span class="line-added"> 797         // Odd list length: [..., lastStart, lastLimit, HIGH]</span>
<span class="line-added"> 798         if ((len &amp; 1) != 0) {</span>
<span class="line-added"> 799             // If the list is empty, set lastLimit low enough to not be adjacent to 0.</span>
<span class="line-added"> 800             UChar32 lastLimit = len == 1 ? -2 : list[len - 2];</span>
<span class="line-added"> 801             if (lastLimit &lt;= start &amp;&amp; !isFrozen() &amp;&amp; !isBogus()) {</span>
<span class="line-added"> 802                 if (lastLimit == start) {</span>
<span class="line-added"> 803                     // Extend the last range.</span>
<span class="line-added"> 804                     list[len - 2] = limit;</span>
<span class="line-added"> 805                     if (limit == UNICODESET_HIGH) {</span>
<span class="line-added"> 806                         --len;</span>
<span class="line-added"> 807                     }</span>
<span class="line-added"> 808                 } else {</span>
<span class="line-added"> 809                     list[len - 1] = start;</span>
<span class="line-added"> 810                     if (limit &lt; UNICODESET_HIGH) {</span>
<span class="line-added"> 811                         if (ensureCapacity(len + 2)) {</span>
<span class="line-added"> 812                             list[len++] = limit;</span>
<span class="line-added"> 813                             list[len++] = UNICODESET_HIGH;</span>
<span class="line-added"> 814                         }</span>
<span class="line-added"> 815                     } else {  // limit == UNICODESET_HIGH</span>
<span class="line-added"> 816                         if (ensureCapacity(len + 1)) {</span>
<span class="line-added"> 817                             list[len++] = UNICODESET_HIGH;</span>
<span class="line-added"> 818                         }</span>
<span class="line-added"> 819                     }</span>
<span class="line-added"> 820                 }</span>
<span class="line-added"> 821                 releasePattern();</span>
<span class="line-added"> 822                 return *this;</span>
<span class="line-added"> 823             }</span>
<span class="line-added"> 824         }</span>
<span class="line-added"> 825         // This is slow. Could be much faster using findCodePoint(start)</span>
<span class="line-added"> 826         // and modifying the list, dealing with adjacent &amp; overlapping ranges.</span>
<span class="line-added"> 827         UChar32 range[3] = { start, limit, UNICODESET_HIGH };</span>
 828         add(range, 2, 0);
 829     } else if (start == end) {
 830         add(start);
 831     }
 832     return *this;
 833 }
 834 
 835 // #define DEBUG_US_ADD
 836 
 837 #ifdef DEBUG_US_ADD
 838 #include &lt;stdio.h&gt;
 839 void dump(UChar32 c) {
 840     if (c &lt;= 0xFF) {
 841         printf(&quot;%c&quot;, (char)c);
 842     } else {
 843         printf(&quot;U+%04X&quot;, c);
 844     }
 845 }
 846 void dump(const UChar32* list, int32_t len) {
 847     printf(&quot;[&quot;);
</pre>
<hr />
<pre>
 876     // [..., start_k-1, limit_k-1, start_k, limit_k, ..., HIGH]
 877     //                             ^
 878     //                             list[i]
 879 
 880     // i == 0 means c is before the first range
 881 
 882 #ifdef DEBUG_US_ADD
 883     printf(&quot;Add of &quot;);
 884     dump(c);
 885     printf(&quot; found at %d&quot;, i);
 886     printf(&quot;: &quot;);
 887     dump(list, len);
 888     printf(&quot; =&gt; &quot;);
 889 #endif
 890 
 891     if (c == list[i]-1) {
 892         // c is before start of next range
 893         list[i] = c;
 894         // if we touched the HIGH mark, then add a new one
 895         if (c == (UNICODESET_HIGH - 1)) {
<span class="line-modified"> 896             if (!ensureCapacity(len+1)) {</span>
<span class="line-modified"> 897                 // ensureCapacity will mark the object as Bogus if OOM failure happens.</span>
<span class="line-modified"> 898                 return *this;</span>

 899             }
 900             list[len++] = UNICODESET_HIGH;
 901         }
 902         if (i &gt; 0 &amp;&amp; c == list[i-1]) {
 903             // collapse adjacent ranges
 904 
 905             // [..., start_k-1, c, c, limit_k, ..., HIGH]
 906             //                     ^
 907             //                     list[i]
 908 
 909             //for (int32_t k=i-1; k&lt;len-2; ++k) {
 910             //    list[k] = list[k+2];
 911             //}
 912             UChar32* dst = list + i - 1;
 913             UChar32* src = dst + 2;
 914             UChar32* srclimit = list + len;
 915             while (src &lt; srclimit) *(dst++) = *(src++);
 916 
 917             len -= 2;
 918         }
</pre>
<hr />
<pre>
 920 
 921     else if (i &gt; 0 &amp;&amp; c == list[i-1]) {
 922         // c is after end of prior range
 923         list[i-1]++;
 924         // no need to check for collapse here
 925     }
 926 
 927     else {
 928         // At this point we know the new char is not adjacent to
 929         // any existing ranges, and it is not 10FFFF.
 930 
 931 
 932         // [..., start_k-1, limit_k-1, start_k, limit_k, ..., HIGH]
 933         //                             ^
 934         //                             list[i]
 935 
 936         // [..., start_k-1, limit_k-1, c, c+1, start_k, limit_k, ..., HIGH]
 937         //                             ^
 938         //                             list[i]
 939 
<span class="line-modified"> 940         if (!ensureCapacity(len+2)) {</span>
<span class="line-modified"> 941             // ensureCapacity will mark the object as Bogus if OOM failure happens.</span>
<span class="line-modified"> 942             return *this;</span>

 943         }
 944 
<span class="line-modified"> 945         UChar32 *p = list + i;</span>
<span class="line-modified"> 946         uprv_memmove(p + 2, p, (len - i) * sizeof(*p));</span>






 947         list[i] = c;
 948         list[i+1] = c+1;
 949         len += 2;
 950     }
 951 
 952 #ifdef DEBUG_US_ADD
 953     dump(list, len);
 954     printf(&quot;\n&quot;);
 955 
 956     for (i=1; i&lt;len; ++i) {
 957         if (list[i] &lt;= list[i-1]) {
 958             // Corrupt array!
 959             printf(&quot;ERROR: list has been corrupted\n&quot;);
 960             exit(1);
 961         }
 962     }
 963 #endif
 964 
 965     releasePattern();
 966     return *this;
 967 }
 968 
 969 /**
 970  * Adds the specified multicharacter to this set if it is not already
 971  * present.  If this set already contains the multicharacter,
 972  * the call leaves this set unchanged.
 973  * Thus &quot;ch&quot; =&gt; {&quot;ch&quot;}
 974  * &lt;br&gt;&lt;b&gt;Warning: you cannot add an empty string (&quot;&quot;) to a UnicodeSet.&lt;/b&gt;
 975  * @param s the source string
 976  * @return the modified set, for chaining
 977  */
 978 UnicodeSet&amp; UnicodeSet::add(const UnicodeString&amp; s) {
 979     if (s.length() == 0 || isFrozen() || isBogus()) return *this;
 980     int32_t cp = getSingleCP(s);
 981     if (cp &lt; 0) {
<span class="line-modified"> 982         if (!stringsContains(s)) {</span>
 983             _add(s);
 984             releasePattern();
 985         }
 986     } else {
 987         add((UChar32)cp);
 988     }
 989     return *this;
 990 }
 991 
 992 /**
 993  * Adds the given string, in order, to &#39;strings&#39;.  The given string
 994  * must have been checked by the caller to not be empty and to not
 995  * already be in &#39;strings&#39;.
 996  */
 997 void UnicodeSet::_add(const UnicodeString&amp; s) {
 998     if (isFrozen() || isBogus()) {
 999         return;
1000     }
<span class="line-added">1001     UErrorCode ec = U_ZERO_ERROR;</span>
<span class="line-added">1002     if (strings == nullptr &amp;&amp; !allocateStrings(ec)) {</span>
<span class="line-added">1003         setToBogus();</span>
<span class="line-added">1004         return;</span>
<span class="line-added">1005     }</span>
1006     UnicodeString* t = new UnicodeString(s);
1007     if (t == NULL) { // Check for memory allocation error.
1008         setToBogus();
1009         return;
1010     }

1011     strings-&gt;sortedInsert(t, compareUnicodeString, ec);
1012     if (U_FAILURE(ec)) {
1013         setToBogus();
1014         delete t;
1015     }
1016 }
1017 
1018 /**
1019  * @return a code point IF the string consists of a single one.
1020  * otherwise returns -1.
1021  * @param string to test
1022  */
1023 int32_t UnicodeSet::getSingleCP(const UnicodeString&amp; s) {
1024     //if (s.length() &lt; 1) {
1025     //    throw new IllegalArgumentException(&quot;Can&#39;t use zero-length strings in UnicodeSet&quot;);
1026     //}
1027     if (s.length() &gt; 2) return -1;
1028     if (s.length() == 1) return s.charAt(0);
1029 
1030     // at this point, len = 2
</pre>
<hr />
<pre>
1073     UnicodeSet set;
1074     set.addAll(s);
1075     complementAll(set);
1076     return *this;
1077 }
1078 
1079 /**
1080  * Remove EACH of the characters in this string. Note: &quot;ch&quot; == {&quot;c&quot;, &quot;h&quot;}
1081  * If this set already any particular character, it has no effect on that character.
1082  * @param the source string
1083  * @return the modified set, for chaining
1084  */
1085 UnicodeSet&amp; UnicodeSet::removeAll(const UnicodeString&amp; s) {
1086     UnicodeSet set;
1087     set.addAll(s);
1088     removeAll(set);
1089     return *this;
1090 }
1091 
1092 UnicodeSet&amp; UnicodeSet::removeAllStrings() {
<span class="line-modified">1093     if (!isFrozen() &amp;&amp; hasStrings()) {</span>
<span class="line-added">1094         strings-&gt;removeAllElements();</span>
<span class="line-added">1095         releasePattern();</span>
<span class="line-added">1096     }</span>
1097     return *this;
1098 }
1099 
1100 
1101 /**
1102  * Makes a set from a multicharacter string. Thus &quot;ch&quot; =&gt; {&quot;ch&quot;}
1103  * &lt;br&gt;&lt;b&gt;Warning: you cannot add an empty string (&quot;&quot;) to a UnicodeSet.&lt;/b&gt;
1104  * @param the source string
1105  * @return a newly created set containing the given string
1106  */
1107 UnicodeSet* U_EXPORT2 UnicodeSet::createFrom(const UnicodeString&amp; s) {
1108     UnicodeSet *set = new UnicodeSet();
1109     if (set != NULL) { // Check for memory allocation error.
1110         set-&gt;add(s);
1111     }
1112     return set;
1113 }
1114 
1115 
1116 /**
</pre>
<hr />
<pre>
1172 /**
1173  * Removes the specified character from this set if it is present.
1174  * The set will not contain the specified range once the call
1175  * returns.
1176  */
1177 UnicodeSet&amp; UnicodeSet::remove(UChar32 c) {
1178     return remove(c, c);
1179 }
1180 
1181 /**
1182  * Removes the specified string from this set if it is present.
1183  * The set will not contain the specified character once the call
1184  * returns.
1185  * @param the source string
1186  * @return the modified set, for chaining
1187  */
1188 UnicodeSet&amp; UnicodeSet::remove(const UnicodeString&amp; s) {
1189     if (s.length() == 0 || isFrozen() || isBogus()) return *this;
1190     int32_t cp = getSingleCP(s);
1191     if (cp &lt; 0) {
<span class="line-modified">1192         if (strings != nullptr &amp;&amp; strings-&gt;removeElement((void*) &amp;s)) {</span>
<span class="line-modified">1193             releasePattern();</span>
<span class="line-added">1194         }</span>
1195     } else {
1196         remove((UChar32)cp, (UChar32)cp);
1197     }
1198     return *this;
1199 }
1200 
1201 /**
1202  * Complements the specified range in this set.  Any character in
1203  * the range will be removed if it is in this set, or will be
1204  * added if it is not in this set.  If &lt;code&gt;end &gt; start&lt;/code&gt;
1205  * then an empty range is xor&#39;ed, leaving the set unchanged.
1206  *
1207  * @param start first character, inclusive, of range to be removed
1208  * from this set.
1209  * @param end last character, inclusive, of range to be removed
1210  * from this set.
1211  */
1212 UnicodeSet&amp; UnicodeSet::complement(UChar32 start, UChar32 end) {
1213     if (isFrozen() || isBogus()) {
1214         return *this;
</pre>
<hr />
<pre>
1216     if (pinCodePoint(start) &lt;= pinCodePoint(end)) {
1217         UChar32 range[3] = { start, end+1, UNICODESET_HIGH };
1218         exclusiveOr(range, 2, 0);
1219     }
1220     releasePattern();
1221     return *this;
1222 }
1223 
1224 UnicodeSet&amp; UnicodeSet::complement(UChar32 c) {
1225     return complement(c, c);
1226 }
1227 
1228 /**
1229  * This is equivalent to
1230  * &lt;code&gt;complement(MIN_VALUE, MAX_VALUE)&lt;/code&gt;.
1231  */
1232 UnicodeSet&amp; UnicodeSet::complement(void) {
1233     if (isFrozen() || isBogus()) {
1234         return *this;
1235     }

1236     if (list[0] == UNICODESET_LOW) {
<span class="line-modified">1237         uprv_memmove(list, list + 1, (size_t)(len-1)*sizeof(UChar32));</span>




1238         --len;
1239     } else {
<span class="line-modified">1240         if (!ensureCapacity(len+1)) {</span>

1241             return *this;
1242         }
<span class="line-modified">1243         uprv_memmove(list + 1, list, (size_t)len*sizeof(UChar32));</span>
<span class="line-modified">1244         list[0] = UNICODESET_LOW;</span>
1245         ++len;
1246     }

1247     releasePattern();
1248     return *this;
1249 }
1250 
1251 /**
1252  * Complement the specified string in this set.
1253  * The set will not contain the specified string once the call
1254  * returns.
1255  * &lt;br&gt;&lt;b&gt;Warning: you cannot add an empty string (&quot;&quot;) to a UnicodeSet.&lt;/b&gt;
1256  * @param s the string to complement
1257  * @return this object, for chaining
1258  */
1259 UnicodeSet&amp; UnicodeSet::complement(const UnicodeString&amp; s) {
1260     if (s.length() == 0 || isFrozen() || isBogus()) return *this;
1261     int32_t cp = getSingleCP(s);
1262     if (cp &lt; 0) {
<span class="line-modified">1263         if (stringsContains(s)) {</span>
1264             strings-&gt;removeElement((void*) &amp;s);
1265         } else {
1266             _add(s);
1267         }
1268         releasePattern();
1269     } else {
1270         complement((UChar32)cp, (UChar32)cp);
1271     }
1272     return *this;
1273 }
1274 
1275 /**
1276  * Adds all of the elements in the specified set to this set if
1277  * they&#39;re not already present.  This operation effectively
1278  * modifies this set so that its value is the &lt;i&gt;union&lt;/i&gt; of the two
1279  * sets.  The behavior of this operation is unspecified if the specified
1280  * collection is modified while the operation is in progress.
1281  *
1282  * @param c set whose elements are to be added to this set.
1283  * @see #add(char, char)
1284  */
1285 UnicodeSet&amp; UnicodeSet::addAll(const UnicodeSet&amp; c) {
1286     if ( c.len&gt;0 &amp;&amp; c.list!=NULL ) {
1287         add(c.list, c.len, 0);
1288     }
1289 
1290     // Add strings in order
1291     if ( c.strings!=NULL ) {
1292         for (int32_t i=0; i&lt;c.strings-&gt;size(); ++i) {
1293             const UnicodeString* s = (const UnicodeString*)c.strings-&gt;elementAt(i);
<span class="line-modified">1294             if (!stringsContains(*s)) {</span>
1295                 _add(*s);
1296             }
1297         }
1298     }
1299     return *this;
1300 }
1301 
1302 /**
1303  * Retains only the elements in this set that are contained in the
1304  * specified set.  In other words, removes from this set all of
1305  * its elements that are not contained in the specified set.  This
1306  * operation effectively modifies this set so that its value is
1307  * the &lt;i&gt;intersection&lt;/i&gt; of the two sets.
1308  *
1309  * @param c set that defines which elements this set will retain.
1310  */
1311 UnicodeSet&amp; UnicodeSet::retainAll(const UnicodeSet&amp; c) {
1312     if (isFrozen() || isBogus()) {
1313         return *this;
1314     }
1315     retain(c.list, c.len, 0);
<span class="line-modified">1316     if (hasStrings()) {</span>
<span class="line-added">1317         if (!c.hasStrings()) {</span>
<span class="line-added">1318             strings-&gt;removeAllElements();</span>
<span class="line-added">1319         } else {</span>
<span class="line-added">1320             strings-&gt;retainAll(*c.strings);</span>
<span class="line-added">1321         }</span>
<span class="line-added">1322     }</span>
1323     return *this;
1324 }
1325 
1326 /**
1327  * Removes from this set all of its elements that are contained in the
1328  * specified set.  This operation effectively modifies this
1329  * set so that its value is the &lt;i&gt;asymmetric set difference&lt;/i&gt; of
1330  * the two sets.
1331  *
1332  * @param c set that defines which elements will be removed from
1333  *          this set.
1334  */
1335 UnicodeSet&amp; UnicodeSet::removeAll(const UnicodeSet&amp; c) {
1336     if (isFrozen() || isBogus()) {
1337         return *this;
1338     }
1339     retain(c.list, c.len, 2);
<span class="line-modified">1340     if (hasStrings() &amp;&amp; c.hasStrings()) {</span>
<span class="line-added">1341         strings-&gt;removeAll(*c.strings);</span>
<span class="line-added">1342     }</span>
1343     return *this;
1344 }
1345 
1346 /**
1347  * Complements in this set all elements contained in the specified
1348  * set.  Any character in the other set will be removed if it is
1349  * in this set, or will be added if it is not in this set.
1350  *
1351  * @param c set that defines which elements will be xor&#39;ed from
1352  *          this set.
1353  */
1354 UnicodeSet&amp; UnicodeSet::complementAll(const UnicodeSet&amp; c) {
1355     if (isFrozen() || isBogus()) {
1356         return *this;
1357     }
1358     exclusiveOr(c.list, c.len, 0);
1359 
<span class="line-modified">1360     if (c.strings != nullptr) {</span>
<span class="line-modified">1361         for (int32_t i=0; i&lt;c.strings-&gt;size(); ++i) {</span>
<span class="line-modified">1362             void* e = c.strings-&gt;elementAt(i);</span>
<span class="line-modified">1363             if (strings == nullptr || !strings-&gt;removeElement(e)) {</span>
<span class="line-added">1364                 _add(*(const UnicodeString*)e);</span>
<span class="line-added">1365             }</span>
1366         }
1367     }
1368     return *this;
1369 }
1370 
1371 /**
1372  * Removes all of the elements from this set.  This set will be
1373  * empty after this call returns.
1374  */
1375 UnicodeSet&amp; UnicodeSet::clear(void) {
1376     if (isFrozen()) {
1377         return *this;
1378     }
<span class="line-modified">1379     list[0] = UNICODESET_HIGH;</span>


1380     len = 1;
1381     releasePattern();
1382     if (strings != NULL) {
1383         strings-&gt;removeAllElements();
1384     }
<span class="line-modified">1385     // Remove bogus</span>
<span class="line-modified">1386     fFlags = 0;</span>


1387     return *this;
1388 }
1389 
1390 /**
1391  * Iteration method that returns the number of ranges contained in
1392  * this set.
1393  * @see #getRangeStart
1394  * @see #getRangeEnd
1395  */
1396 int32_t UnicodeSet::getRangeCount() const {
1397     return len/2;
1398 }
1399 
1400 /**
1401  * Iteration method that returns the first character in the
1402  * specified range of this set.
1403  * @see #getRangeCount
1404  * @see #getRangeEnd
1405  */
1406 UChar32 UnicodeSet::getRangeStart(int32_t index) const {
1407     return list[index*2];
1408 }
1409 
1410 /**
1411  * Iteration method that returns the last character in the
1412  * specified range of this set.
1413  * @see #getRangeStart
1414  * @see #getRangeEnd
1415  */
1416 UChar32 UnicodeSet::getRangeEnd(int32_t index) const {
1417     return list[index*2 + 1] - 1;
1418 }
1419 




1420 const UnicodeString* UnicodeSet::getString(int32_t index) const {
1421     return (const UnicodeString*) strings-&gt;elementAt(index);
1422 }
1423 
1424 /**
1425  * Reallocate this objects internal structures to take up the least
1426  * possible space, without changing this object&#39;s value.
1427  */
1428 UnicodeSet&amp; UnicodeSet::compact() {
1429     if (isFrozen() || isBogus()) {
1430         return *this;
1431     }
1432     // Delete buffer first to defragment memory less.
<span class="line-modified">1433     if (buffer != stackList) {</span>
1434         uprv_free(buffer);
1435         buffer = NULL;
<span class="line-modified">1436         bufferCapacity = 0;</span>
<span class="line-modified">1437     }</span>
<span class="line-modified">1438     if (list == stackList) {</span>
<span class="line-modified">1439         // pass</span>
<span class="line-modified">1440     } else if (len &lt;= INITIAL_CAPACITY) {</span>
<span class="line-modified">1441         uprv_memcpy(stackList, list, len * sizeof(UChar32));</span>
<span class="line-added">1442         uprv_free(list);</span>
<span class="line-added">1443         list = stackList;</span>
<span class="line-added">1444         capacity = INITIAL_CAPACITY;</span>
<span class="line-added">1445     } else if ((len + 7) &lt; capacity) {</span>
<span class="line-added">1446         // If we have more than a little unused capacity, shrink it to len.</span>
<span class="line-added">1447         UChar32* temp = (UChar32*) uprv_realloc(list, sizeof(UChar32) * len);</span>
1448         if (temp) {
1449             list = temp;
<span class="line-modified">1450             capacity = len;</span>
1451         }
1452         // else what the heck happened?! We allocated less memory!
1453         // Oh well. We&#39;ll keep our original array.
1454     }
<span class="line-added">1455     if (strings != nullptr &amp;&amp; strings-&gt;isEmpty()) {</span>
<span class="line-added">1456         delete strings;</span>
<span class="line-added">1457         strings = nullptr;</span>
<span class="line-added">1458     }</span>
1459     return *this;
1460 }
1461 
1462 #ifdef DEBUG_SERIALIZE
1463 #include &lt;stdio.h&gt;
1464 #endif
1465 
1466 /**
1467  * Deserialize constructor.
1468  */
<span class="line-modified">1469 UnicodeSet::UnicodeSet(const uint16_t data[], int32_t dataLen, ESerialization serialization,</span>
<span class="line-modified">1470                        UErrorCode &amp;ec) {</span>


1471 
1472   if(U_FAILURE(ec)) {
1473     setToBogus();
1474     return;
1475   }
1476 
1477   if( (serialization != kSerialized)
1478       || (data==NULL)
1479       || (dataLen &lt; 1)) {
1480     ec = U_ILLEGAL_ARGUMENT_ERROR;
1481     setToBogus();
1482     return;
1483   }
1484 






1485   // bmp?
1486   int32_t headerSize = ((data[0]&amp;0x8000)) ?2:1;
1487   int32_t bmpLength = (headerSize==1)?data[0]:data[1];
1488 
<span class="line-modified">1489   int32_t newLength = (((data[0]&amp;0x7FFF)-bmpLength)/2)+bmpLength;</span>
1490 #ifdef DEBUG_SERIALIZE
<span class="line-modified">1491   printf(&quot;dataLen %d headerSize %d bmpLen %d len %d. data[0]=%X/%X/%X/%X\n&quot;, dataLen,headerSize,bmpLength,newLength, data[0],data[1],data[2],data[3]);</span>
1492 #endif
<span class="line-modified">1493   if(!ensureCapacity(newLength + 1)) {  // +1 for HIGH</span>



1494     return;
1495   }
1496   // copy bmp
1497   int32_t i;
1498   for(i = 0; i&lt; bmpLength;i++) {
1499     list[i] = data[i+headerSize];
1500 #ifdef DEBUG_SERIALIZE
1501     printf(&quot;&lt;&lt;16@%d[%d] %X\n&quot;, i+headerSize, i, list[i]);
1502 #endif
1503   }
1504   // copy smp
<span class="line-modified">1505   for(i=bmpLength;i&lt;newLength;i++) {</span>
1506     list[i] = ((UChar32)data[headerSize+bmpLength+(i-bmpLength)*2+0] &lt;&lt; 16) +
1507               ((UChar32)data[headerSize+bmpLength+(i-bmpLength)*2+1]);
1508 #ifdef DEBUG_SERIALIZE
1509     printf(&quot;&lt;&lt;32@%d+[%d] %lX\n&quot;, headerSize+bmpLength+i, i, list[i]);
1510 #endif
1511   }
<span class="line-modified">1512   U_ASSERT(i == newLength);</span>
<span class="line-modified">1513   if (i == 0 || list[i - 1] != UNICODESET_HIGH) {</span>
<span class="line-added">1514     list[i++] = UNICODESET_HIGH;</span>
<span class="line-added">1515   }</span>
<span class="line-added">1516   len = i;</span>
1517 }
1518 
1519 
1520 int32_t UnicodeSet::serialize(uint16_t *dest, int32_t destCapacity, UErrorCode&amp; ec) const {
1521     int32_t bmpLength, length, destLength;
1522 
1523     if (U_FAILURE(ec)) {
1524         return 0;
1525     }
1526 
1527     if (destCapacity&lt;0 || (destCapacity&gt;0 &amp;&amp; dest==NULL)) {
1528         ec=U_ILLEGAL_ARGUMENT_ERROR;
1529         return 0;
1530     }
1531 
1532     /* count necessary 16-bit units */
1533     length=this-&gt;len-1; // Subtract 1 to ignore final UNICODESET_HIGH
1534     // assert(length&gt;=0);
1535     if (length==0) {
1536         /* empty set */
</pre>
<hr />
<pre>
1617  * Allocate our strings vector and return TRUE if successful.
1618  */
1619 UBool UnicodeSet::allocateStrings(UErrorCode &amp;status) {
1620     if (U_FAILURE(status)) {
1621         return FALSE;
1622     }
1623     strings = new UVector(uprv_deleteUObject,
1624                           uhash_compareUnicodeString, 1, status);
1625     if (strings == NULL) { // Check for memory allocation error.
1626         status = U_MEMORY_ALLOCATION_ERROR;
1627         return FALSE;
1628     }
1629     if (U_FAILURE(status)) {
1630         delete strings;
1631         strings = NULL;
1632         return FALSE;
1633     }
1634     return TRUE;
1635 }
1636 
<span class="line-modified">1637 int32_t UnicodeSet::nextCapacity(int32_t minCapacity) {</span>
<span class="line-modified">1638     // Grow exponentially to reduce the frequency of allocations.</span>
<span class="line-modified">1639     if (minCapacity &lt; INITIAL_CAPACITY) {</span>
<span class="line-modified">1640         return minCapacity + INITIAL_CAPACITY;</span>
<span class="line-added">1641     } else if (minCapacity &lt;= 2500) {</span>
<span class="line-added">1642         return 5 * minCapacity;</span>
<span class="line-added">1643     } else {</span>
<span class="line-added">1644         int32_t newCapacity = 2 * minCapacity;</span>
<span class="line-added">1645         if (newCapacity &gt; MAX_LENGTH) {</span>
<span class="line-added">1646             newCapacity = MAX_LENGTH;</span>
<span class="line-added">1647         }</span>
<span class="line-added">1648         return newCapacity;</span>
<span class="line-added">1649     }</span>
<span class="line-added">1650 }</span>
<span class="line-added">1651 </span>
<span class="line-added">1652 bool UnicodeSet::ensureCapacity(int32_t newLen) {</span>
<span class="line-added">1653     if (newLen &gt; MAX_LENGTH) {</span>
<span class="line-added">1654         newLen = MAX_LENGTH;</span>
<span class="line-added">1655     }</span>
<span class="line-added">1656     if (newLen &lt;= capacity) {</span>
<span class="line-added">1657         return true;</span>
<span class="line-added">1658     }</span>
<span class="line-added">1659     int32_t newCapacity = nextCapacity(newLen);</span>
<span class="line-added">1660     UChar32* temp = (UChar32*) uprv_malloc(newCapacity * sizeof(UChar32));</span>
1661     if (temp == NULL) {
<span class="line-modified">1662         setToBogus(); // set the object to bogus state if an OOM failure occurred.</span>
<span class="line-modified">1663         return false;</span>
<span class="line-modified">1664     }</span>
<span class="line-added">1665     // Copy only the actual contents.</span>
<span class="line-added">1666     uprv_memcpy(temp, list, len * sizeof(UChar32));</span>
<span class="line-added">1667     if (list != stackList) {</span>
<span class="line-added">1668         uprv_free(list);</span>
1669     }
1670     list = temp;
<span class="line-modified">1671     capacity = newCapacity;</span>
<span class="line-modified">1672     return true;</span>
1673 }
1674 
<span class="line-modified">1675 bool UnicodeSet::ensureBufferCapacity(int32_t newLen) {</span>
<span class="line-modified">1676     if (newLen &gt; MAX_LENGTH) {</span>
<span class="line-modified">1677         newLen = MAX_LENGTH;</span>
<span class="line-modified">1678     }</span>
<span class="line-added">1679     if (newLen &lt;= bufferCapacity) {</span>
<span class="line-added">1680         return true;</span>
<span class="line-added">1681     }</span>
<span class="line-added">1682     int32_t newCapacity = nextCapacity(newLen);</span>
<span class="line-added">1683     UChar32* temp = (UChar32*) uprv_malloc(newCapacity * sizeof(UChar32));</span>
1684     if (temp == NULL) {

1685         setToBogus();
<span class="line-modified">1686         return false;</span>
<span class="line-added">1687     }</span>
<span class="line-added">1688     // The buffer has no contents to be copied.</span>
<span class="line-added">1689     // It is always filled from scratch after this call.</span>
<span class="line-added">1690     if (buffer != stackList) {</span>
<span class="line-added">1691         uprv_free(buffer);</span>
1692     }
1693     buffer = temp;
<span class="line-modified">1694     bufferCapacity = newCapacity;</span>
<span class="line-modified">1695     return true;</span>
1696 }
1697 
1698 /**
1699  * Swap list and buffer.
1700  */
1701 void UnicodeSet::swapBuffers(void) {
1702     // swap list and buffer
1703     UChar32* temp = list;
1704     list = buffer;
1705     buffer = temp;
1706 
1707     int32_t c = capacity;
1708     capacity = bufferCapacity;
1709     bufferCapacity = c;
1710 }
1711 
1712 void UnicodeSet::setToBogus() {
1713     clear(); // Remove everything in the set.
1714     fFlags = kIsBogus;
1715 }
1716 
1717 //----------------------------------------------------------------
1718 // Implementation: Fundamental operators
1719 //----------------------------------------------------------------
1720 
1721 static inline UChar32 max(UChar32 a, UChar32 b) {
1722     return (a &gt; b) ? a : b;
1723 }
1724 
1725 // polarity = 0, 3 is normal: x xor y
1726 // polarity = 1, 2: x xor ~y == x === y
1727 
1728 void UnicodeSet::exclusiveOr(const UChar32* other, int32_t otherLen, int8_t polarity) {
1729     if (isFrozen() || isBogus()) {
1730         return;
1731     }
<span class="line-modified">1732     if (!ensureBufferCapacity(len + otherLen)) {</span>


1733         return;
1734     }
1735 
1736     int32_t i = 0, j = 0, k = 0;
1737     UChar32 a = list[i++];
1738     UChar32 b;
1739     if (polarity == 1 || polarity == 2) {
1740         b = UNICODESET_LOW;
1741         if (other[j] == UNICODESET_LOW) { // skip base if already LOW
1742             ++j;
1743             b = other[j];
1744         }
1745     } else {
1746         b = other[j++];
1747     }
1748     // simplest of all the routines
1749     // sort the values, discarding identicals!
1750     for (;;) {
1751         if (a &lt; b) {
1752             buffer[k++] = a;
</pre>
<hr />
<pre>
1760             b = other[j++];
1761         } else { // DONE!
1762             buffer[k++] = UNICODESET_HIGH;
1763             len = k;
1764             break;
1765         }
1766     }
1767     swapBuffers();
1768     releasePattern();
1769 }
1770 
1771 // polarity = 0 is normal: x union y
1772 // polarity = 2: x union ~y
1773 // polarity = 1: ~x union y
1774 // polarity = 3: ~x union ~y
1775 
1776 void UnicodeSet::add(const UChar32* other, int32_t otherLen, int8_t polarity) {
1777     if (isFrozen() || isBogus() || other==NULL) {
1778         return;
1779     }
<span class="line-modified">1780     if (!ensureBufferCapacity(len + otherLen)) {</span>


1781         return;
1782     }
1783 
1784     int32_t i = 0, j = 0, k = 0;
1785     UChar32 a = list[i++];
1786     UChar32 b = other[j++];
1787     // change from xor is that we have to check overlapping pairs
1788     // polarity bit 1 means a is second, bit 2 means b is.
1789     for (;;) {
1790         switch (polarity) {
1791           case 0: // both first; take lower if unequal
1792             if (a &lt; b) { // take a
1793                 // Back up over overlapping ranges in buffer[]
1794                 if (k &gt; 0 &amp;&amp; a &lt;= buffer[k-1]) {
1795                     // Pick latter end value in buffer[] vs. list[]
1796                     a = max(list[i], buffer[--k]);
1797                 } else {
1798                     // No overlap
1799                     buffer[k++] = a;
1800                     a = list[i];
</pre>
<hr />
<pre>
1871             }
1872             break;
1873         }
1874     }
1875  loop_end:
1876     buffer[k++] = UNICODESET_HIGH;    // terminate
1877     len = k;
1878     swapBuffers();
1879     releasePattern();
1880 }
1881 
1882 // polarity = 0 is normal: x intersect y
1883 // polarity = 2: x intersect ~y == set-minus
1884 // polarity = 1: ~x intersect y
1885 // polarity = 3: ~x intersect ~y
1886 
1887 void UnicodeSet::retain(const UChar32* other, int32_t otherLen, int8_t polarity) {
1888     if (isFrozen() || isBogus()) {
1889         return;
1890     }
<span class="line-modified">1891     if (!ensureBufferCapacity(len + otherLen)) {</span>


1892         return;
1893     }
1894 
1895     int32_t i = 0, j = 0, k = 0;
1896     UChar32 a = list[i++];
1897     UChar32 b = other[j++];
1898     // change from xor is that we have to check overlapping pairs
1899     // polarity bit 1 means a is second, bit 2 means b is.
1900     for (;;) {
1901         switch (polarity) {
1902           case 0: // both first; drop the smaller
1903             if (a &lt; b) { // drop a
1904                 a = list[i++];
1905                 polarity ^= 1;
1906             } else if (b &lt; a) { // drop b
1907                 b = other[j++];
1908                 polarity ^= 2;
1909             } else { // a == b, take one, drop other
1910                 if (a == UNICODESET_HIGH) goto loop_end;
1911                 buffer[k++] = a;
</pre>
<hr />
<pre>
2117                 _appendToPat(result, end, escapeUnprintable);
2118             }
2119         }
2120     }
2121 
2122     // Default; emit the ranges as pairs
2123     else {
2124         for (int32_t i = 0; i &lt; count; ++i) {
2125             UChar32 start = getRangeStart(i);
2126             UChar32 end = getRangeEnd(i);
2127             _appendToPat(result, start, escapeUnprintable);
2128             if (start != end) {
2129                 if ((start+1) != end) {
2130                     result.append(HYPHEN);
2131                 }
2132                 _appendToPat(result, end, escapeUnprintable);
2133             }
2134         }
2135     }
2136 
<span class="line-modified">2137     if (strings != nullptr) {</span>
<span class="line-modified">2138         for (int32_t i = 0; i&lt;strings-&gt;size(); ++i) {</span>
<span class="line-modified">2139             result.append(OPEN_BRACE);</span>
<span class="line-modified">2140             _appendToPat(result,</span>
<span class="line-modified">2141                          *(const UnicodeString*) strings-&gt;elementAt(i),</span>
<span class="line-modified">2142                          escapeUnprintable);</span>
<span class="line-added">2143             result.append(CLOSE_BRACE);</span>
<span class="line-added">2144         }</span>
2145     }
2146     return result.append(SET_CLOSE);
2147 }
2148 
2149 /**
2150 * Release existing cached pattern
2151 */
2152 void UnicodeSet::releasePattern() {
2153     if (pat) {
2154         uprv_free(pat);
2155         pat = NULL;
2156         patLen = 0;
2157     }
2158 }
2159 
2160 /**
2161 * Set the new pattern to cache.
2162 */
<span class="line-modified">2163 void UnicodeSet::setPattern(const char16_t *newPat, int32_t newPatLen) {</span>
2164     releasePattern();

2165     pat = (UChar *)uprv_malloc((newPatLen + 1) * sizeof(UChar));
2166     if (pat) {
2167         patLen = newPatLen;
<span class="line-modified">2168         u_memcpy(pat, newPat, patLen);</span>
2169         pat[patLen] = 0;
2170     }
2171     // else we don&#39;t care if malloc failed. This was just a nice cache.
2172     // We can regenerate an equivalent pattern later when requested.
2173 }
2174 
2175 UnicodeFunctor *UnicodeSet::freeze() {
2176     if(!isFrozen() &amp;&amp; !isBogus()) {
<span class="line-modified">2177         compact();</span>


















2178 
2179         // Optimize contains() and span() and similar functions.
<span class="line-modified">2180         if (hasStrings()) {</span>
2181             stringSpan = new UnicodeSetStringSpan(*this, *strings, UnicodeSetStringSpan::ALL);
<span class="line-modified">2182             if (stringSpan == nullptr) {</span>
<span class="line-added">2183                 setToBogus();</span>
<span class="line-added">2184                 return this;</span>
<span class="line-added">2185             } else if (!stringSpan-&gt;needsStringSpanUTF16()) {</span>
2186                 // All strings are irrelevant for span() etc. because
2187                 // all of each string&#39;s code points are contained in this set.
2188                 // Do not check needsStringSpanUTF8() because UTF-8 has at most as
2189                 // many relevant strings as UTF-16.
2190                 // (Thus needsStringSpanUTF8() implies needsStringSpanUTF16().)
2191                 delete stringSpan;
2192                 stringSpan = NULL;
2193             }
2194         }
2195         if (stringSpan == NULL) {
2196             // No span-relevant strings: Optimize for code point spans.
2197             bmpSet=new BMPSet(list, len);
2198             if (bmpSet == NULL) { // Check for memory allocation error.
2199                 setToBogus();
2200             }
2201         }
2202     }
2203     return this;
2204 }
2205 
2206 int32_t UnicodeSet::span(const UChar *s, int32_t length, USetSpanCondition spanCondition) const {
2207     if(length&gt;0 &amp;&amp; bmpSet!=NULL) {
2208         return (int32_t)(bmpSet-&gt;span(s, s+length, spanCondition)-s);
2209     }
2210     if(length&lt;0) {
2211         length=u_strlen(s);
2212     }
2213     if(length==0) {
2214         return 0;
2215     }
2216     if(stringSpan!=NULL) {
2217         return stringSpan-&gt;span(s, length, spanCondition);
<span class="line-modified">2218     } else if(hasStrings()) {</span>
2219         uint32_t which= spanCondition==USET_SPAN_NOT_CONTAINED ?
2220                             UnicodeSetStringSpan::FWD_UTF16_NOT_CONTAINED :
2221                             UnicodeSetStringSpan::FWD_UTF16_CONTAINED;
2222         UnicodeSetStringSpan strSpan(*this, *strings, which);
2223         if(strSpan.needsStringSpanUTF16()) {
2224             return strSpan.span(s, length, spanCondition);
2225         }
2226     }
2227 
2228     if(spanCondition!=USET_SPAN_NOT_CONTAINED) {
2229         spanCondition=USET_SPAN_CONTAINED;  // Pin to 0/1 values.
2230     }
2231 
2232     UChar32 c;
2233     int32_t start=0, prev=0;
2234     do {
2235         U16_NEXT(s, start, length, c);
2236         if(spanCondition!=contains(c)) {
2237             break;
2238         }
2239     } while((prev=start)&lt;length);
2240     return prev;
2241 }
2242 
2243 int32_t UnicodeSet::spanBack(const UChar *s, int32_t length, USetSpanCondition spanCondition) const {
2244     if(length&gt;0 &amp;&amp; bmpSet!=NULL) {
2245         return (int32_t)(bmpSet-&gt;spanBack(s, s+length, spanCondition)-s);
2246     }
2247     if(length&lt;0) {
2248         length=u_strlen(s);
2249     }
2250     if(length==0) {
2251         return 0;
2252     }
2253     if(stringSpan!=NULL) {
2254         return stringSpan-&gt;spanBack(s, length, spanCondition);
<span class="line-modified">2255     } else if(hasStrings()) {</span>
2256         uint32_t which= spanCondition==USET_SPAN_NOT_CONTAINED ?
2257                             UnicodeSetStringSpan::BACK_UTF16_NOT_CONTAINED :
2258                             UnicodeSetStringSpan::BACK_UTF16_CONTAINED;
2259         UnicodeSetStringSpan strSpan(*this, *strings, which);
2260         if(strSpan.needsStringSpanUTF16()) {
2261             return strSpan.spanBack(s, length, spanCondition);
2262         }
2263     }
2264 
2265     if(spanCondition!=USET_SPAN_NOT_CONTAINED) {
2266         spanCondition=USET_SPAN_CONTAINED;  // Pin to 0/1 values.
2267     }
2268 
2269     UChar32 c;
2270     int32_t prev=length;
2271     do {
2272         U16_PREV(s, 0, length, c);
2273         if(spanCondition!=contains(c)) {
2274             break;
2275         }
2276     } while((prev=length)&gt;0);
2277     return prev;
2278 }
2279 
2280 int32_t UnicodeSet::spanUTF8(const char *s, int32_t length, USetSpanCondition spanCondition) const {
2281     if(length&gt;0 &amp;&amp; bmpSet!=NULL) {
2282         const uint8_t *s0=(const uint8_t *)s;
2283         return (int32_t)(bmpSet-&gt;spanUTF8(s0, length, spanCondition)-s0);
2284     }
2285     if(length&lt;0) {
2286         length=(int32_t)uprv_strlen(s);
2287     }
2288     if(length==0) {
2289         return 0;
2290     }
2291     if(stringSpan!=NULL) {
2292         return stringSpan-&gt;spanUTF8((const uint8_t *)s, length, spanCondition);
<span class="line-modified">2293     } else if(hasStrings()) {</span>
2294         uint32_t which= spanCondition==USET_SPAN_NOT_CONTAINED ?
2295                             UnicodeSetStringSpan::FWD_UTF8_NOT_CONTAINED :
2296                             UnicodeSetStringSpan::FWD_UTF8_CONTAINED;
2297         UnicodeSetStringSpan strSpan(*this, *strings, which);
2298         if(strSpan.needsStringSpanUTF8()) {
2299             return strSpan.spanUTF8((const uint8_t *)s, length, spanCondition);
2300         }
2301     }
2302 
2303     if(spanCondition!=USET_SPAN_NOT_CONTAINED) {
2304         spanCondition=USET_SPAN_CONTAINED;  // Pin to 0/1 values.
2305     }
2306 
2307     UChar32 c;
2308     int32_t start=0, prev=0;
2309     do {
2310         U8_NEXT_OR_FFFD(s, start, length, c);
2311         if(spanCondition!=contains(c)) {
2312             break;
2313         }
2314     } while((prev=start)&lt;length);
2315     return prev;
2316 }
2317 
2318 int32_t UnicodeSet::spanBackUTF8(const char *s, int32_t length, USetSpanCondition spanCondition) const {
2319     if(length&gt;0 &amp;&amp; bmpSet!=NULL) {
2320         const uint8_t *s0=(const uint8_t *)s;
2321         return bmpSet-&gt;spanBackUTF8(s0, length, spanCondition);
2322     }
2323     if(length&lt;0) {
2324         length=(int32_t)uprv_strlen(s);
2325     }
2326     if(length==0) {
2327         return 0;
2328     }
2329     if(stringSpan!=NULL) {
2330         return stringSpan-&gt;spanBackUTF8((const uint8_t *)s, length, spanCondition);
<span class="line-modified">2331     } else if(hasStrings()) {</span>
2332         uint32_t which= spanCondition==USET_SPAN_NOT_CONTAINED ?
2333                             UnicodeSetStringSpan::BACK_UTF8_NOT_CONTAINED :
2334                             UnicodeSetStringSpan::BACK_UTF8_CONTAINED;
2335         UnicodeSetStringSpan strSpan(*this, *strings, which);
2336         if(strSpan.needsStringSpanUTF8()) {
2337             return strSpan.spanBackUTF8((const uint8_t *)s, length, spanCondition);
2338         }
2339     }
2340 
2341     if(spanCondition!=USET_SPAN_NOT_CONTAINED) {
2342         spanCondition=USET_SPAN_CONTAINED;  // Pin to 0/1 values.
2343     }
2344 
2345     UChar32 c;
2346     int32_t prev=length;
2347     do {
2348         U8_PREV_OR_FFFD(s, 0, length, c);
2349         if(spanCondition!=contains(c)) {
2350             break;
2351         }
</pre>
</td>
</tr>
</table>
<center><a href="unifiedcache.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uniset_closure.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>