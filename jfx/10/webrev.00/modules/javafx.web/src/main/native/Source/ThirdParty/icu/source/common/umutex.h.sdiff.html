<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/umutex.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="umutex.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="unames.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/umutex.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  3 /*
  4 **********************************************************************
  5 *   Copyright (C) 1997-2015, International Business Machines
  6 *   Corporation and others.  All Rights Reserved.
  7 **********************************************************************
  8 *
  9 * File UMUTEX.H
 10 *
 11 * Modification History:
 12 *
 13 *   Date        Name        Description
 14 *   04/02/97  aliu        Creation.
 15 *   04/07/99  srl         rewrite - C interface, multiple mutices
 16 *   05/13/99  stephen     Changed to umutex (from cmutex)
 17 ******************************************************************************
 18 */
 19 
 20 #ifndef UMUTEX_H
 21 #define UMUTEX_H
 22 




 23 #include &quot;unicode/utypes.h&quot;
 24 #include &quot;unicode/uclean.h&quot;


 25 #include &quot;putilimp.h&quot;
 26 





 27 
 28 
<span class="line-modified"> 29 // Forward Declarations. UMutex is not in the ICU namespace (yet) because</span>
<span class="line-modified"> 30 //                       there are some remaining references from plain C.</span>
<span class="line-modified"> 31 struct UMutex;</span>
<span class="line-modified"> 32 struct UConditionVar;</span>















 33 
<span class="line-removed"> 34 U_NAMESPACE_BEGIN</span>
<span class="line-removed"> 35 struct UInitOnce;</span>
<span class="line-removed"> 36 U_NAMESPACE_END</span>
 37 
<span class="line-modified"> 38 // Stringify macros, to allow #include of user supplied atomic &amp; mutex files.</span>
<span class="line-removed"> 39 #define U_MUTEX_STR(s) #s</span>
<span class="line-removed"> 40 #define U_MUTEX_XSTR(s) U_MUTEX_STR(s)</span>
 41 
 42 /****************************************************************************
 43  *
<span class="line-modified"> 44  *   Low Level Atomic Operations.</span>
<span class="line-removed"> 45  *      Compiler dependent. Not operating system dependent.</span>
 46  *
 47  ****************************************************************************/
<span class="line-removed"> 48 #if defined (U_USER_ATOMICS_H)</span>
<span class="line-removed"> 49 #include U_MUTEX_XSTR(U_USER_ATOMICS_H)</span>
<span class="line-removed"> 50 </span>
<span class="line-removed"> 51 #elif U_HAVE_STD_ATOMICS</span>
<span class="line-removed"> 52 </span>
<span class="line-removed"> 53 //  C++11 atomics are available.</span>
<span class="line-removed"> 54 </span>
<span class="line-removed"> 55 #include &lt;atomic&gt;</span>
<span class="line-removed"> 56 </span>
<span class="line-removed"> 57 U_NAMESPACE_BEGIN</span>
 58 
 59 typedef std::atomic&lt;int32_t&gt; u_atomic_int32_t;
 60 #define ATOMIC_INT32_T_INITIALIZER(val) ATOMIC_VAR_INIT(val)
 61 
 62 inline int32_t umtx_loadAcquire(u_atomic_int32_t &amp;var) {
 63     return var.load(std::memory_order_acquire);
 64 }
 65 
 66 inline void umtx_storeRelease(u_atomic_int32_t &amp;var, int32_t val) {
 67     var.store(val, std::memory_order_release);
 68 }
 69 
 70 inline int32_t umtx_atomic_inc(u_atomic_int32_t *var) {
 71     return var-&gt;fetch_add(1) + 1;
 72 }
 73 
 74 inline int32_t umtx_atomic_dec(u_atomic_int32_t *var) {
 75     return var-&gt;fetch_sub(1) - 1;
 76 }
<span class="line-removed"> 77 U_NAMESPACE_END</span>
<span class="line-removed"> 78 </span>
<span class="line-removed"> 79 #elif U_PLATFORM_HAS_WIN32_API</span>
<span class="line-removed"> 80 </span>
<span class="line-removed"> 81 // MSVC compiler. Reads and writes of volatile variables have</span>
<span class="line-removed"> 82 //                acquire and release memory semantics, respectively.</span>
<span class="line-removed"> 83 //                This is a Microsoft extension, not standard C++ behavior.</span>
<span class="line-removed"> 84 //</span>
<span class="line-removed"> 85 //   Update:      can&#39;t use this because of MinGW, built with gcc.</span>
<span class="line-removed"> 86 //                Original plan was to use gcc atomics for MinGW, but they</span>
<span class="line-removed"> 87 //                aren&#39;t supported, so we fold MinGW into this path.</span>
<span class="line-removed"> 88 </span>
<span class="line-removed"> 89 #ifndef WIN32_LEAN_AND_MEAN</span>
<span class="line-removed"> 90 # define WIN32_LEAN_AND_MEAN</span>
<span class="line-removed"> 91 #endif</span>
<span class="line-removed"> 92 # define VC_EXTRALEAN</span>
<span class="line-removed"> 93 # define NOUSER</span>
<span class="line-removed"> 94 # define NOSERVICE</span>
<span class="line-removed"> 95 # define NOIME</span>
<span class="line-removed"> 96 # define NOMCX</span>
<span class="line-removed"> 97 # ifndef NOMINMAX</span>
<span class="line-removed"> 98 # define NOMINMAX</span>
<span class="line-removed"> 99 # endif</span>
<span class="line-removed">100 # include &lt;windows.h&gt;</span>
<span class="line-removed">101 </span>
<span class="line-removed">102 U_NAMESPACE_BEGIN</span>
<span class="line-removed">103 typedef volatile LONG u_atomic_int32_t;</span>
<span class="line-removed">104 #define ATOMIC_INT32_T_INITIALIZER(val) val</span>
<span class="line-removed">105 </span>
<span class="line-removed">106 inline int32_t umtx_loadAcquire(u_atomic_int32_t &amp;var) {</span>
<span class="line-removed">107     return InterlockedCompareExchange(&amp;var, 0, 0);</span>
<span class="line-removed">108 }</span>
<span class="line-removed">109 </span>
<span class="line-removed">110 inline void umtx_storeRelease(u_atomic_int32_t &amp;var, int32_t val) {</span>
<span class="line-removed">111     InterlockedExchange(&amp;var, val);</span>
<span class="line-removed">112 }</span>
<span class="line-removed">113 </span>
<span class="line-removed">114 </span>
<span class="line-removed">115 inline int32_t umtx_atomic_inc(u_atomic_int32_t *var) {</span>
<span class="line-removed">116     return InterlockedIncrement(var);</span>
<span class="line-removed">117 }</span>
<span class="line-removed">118 </span>
<span class="line-removed">119 inline int32_t umtx_atomic_dec(u_atomic_int32_t *var) {</span>
<span class="line-removed">120     return InterlockedDecrement(var);</span>
<span class="line-removed">121 }</span>
<span class="line-removed">122 U_NAMESPACE_END</span>
<span class="line-removed">123 </span>
<span class="line-removed">124 </span>
<span class="line-removed">125 #elif U_HAVE_CLANG_ATOMICS</span>
<span class="line-removed">126 /*</span>
<span class="line-removed">127  *  Clang __c11 atomic built-ins</span>
<span class="line-removed">128  */</span>
<span class="line-removed">129 </span>
<span class="line-removed">130 U_NAMESPACE_BEGIN</span>
<span class="line-removed">131 typedef _Atomic(int32_t) u_atomic_int32_t;</span>
<span class="line-removed">132 #define ATOMIC_INT32_T_INITIALIZER(val) val</span>
<span class="line-removed">133 </span>
<span class="line-removed">134 inline int32_t umtx_loadAcquire(u_atomic_int32_t &amp;var) {</span>
<span class="line-removed">135      return __c11_atomic_load(&amp;var, __ATOMIC_ACQUIRE);</span>
<span class="line-removed">136 }</span>
<span class="line-removed">137 </span>
<span class="line-removed">138 inline void umtx_storeRelease(u_atomic_int32_t &amp;var, int32_t val) {</span>
<span class="line-removed">139    return __c11_atomic_store(&amp;var, val, __ATOMIC_RELEASE);</span>
<span class="line-removed">140 }</span>
<span class="line-removed">141 </span>
<span class="line-removed">142 inline int32_t umtx_atomic_inc(u_atomic_int32_t *var) {</span>
<span class="line-removed">143     return __c11_atomic_fetch_add(var, 1, __ATOMIC_SEQ_CST) + 1;</span>
<span class="line-removed">144 }</span>
<span class="line-removed">145 </span>
<span class="line-removed">146 inline int32_t umtx_atomic_dec(u_atomic_int32_t *var) {</span>
<span class="line-removed">147     return __c11_atomic_fetch_sub(var, 1, __ATOMIC_SEQ_CST) - 1;</span>
<span class="line-removed">148 }</span>
<span class="line-removed">149 U_NAMESPACE_END</span>
<span class="line-removed">150 </span>
<span class="line-removed">151 </span>
<span class="line-removed">152 #elif U_HAVE_GCC_ATOMICS</span>
<span class="line-removed">153 /*</span>
<span class="line-removed">154  * gcc atomic ops. These are available on several other compilers as well.</span>
<span class="line-removed">155  */</span>
<span class="line-removed">156 </span>
<span class="line-removed">157 U_NAMESPACE_BEGIN</span>
<span class="line-removed">158 typedef int32_t u_atomic_int32_t;</span>
<span class="line-removed">159 #define ATOMIC_INT32_T_INITIALIZER(val) val</span>
<span class="line-removed">160 </span>
<span class="line-removed">161 inline int32_t umtx_loadAcquire(u_atomic_int32_t &amp;var) {</span>
<span class="line-removed">162     int32_t val = var;</span>
<span class="line-removed">163     __sync_synchronize();</span>
<span class="line-removed">164     return val;</span>
<span class="line-removed">165 }</span>
<span class="line-removed">166 </span>
<span class="line-removed">167 inline void umtx_storeRelease(u_atomic_int32_t &amp;var, int32_t val) {</span>
<span class="line-removed">168     __sync_synchronize();</span>
<span class="line-removed">169     var = val;</span>
<span class="line-removed">170 }</span>
<span class="line-removed">171 </span>
<span class="line-removed">172 inline int32_t umtx_atomic_inc(u_atomic_int32_t *p)  {</span>
<span class="line-removed">173    return __sync_add_and_fetch(p, 1);</span>
<span class="line-removed">174 }</span>
<span class="line-removed">175 </span>
<span class="line-removed">176 inline int32_t umtx_atomic_dec(u_atomic_int32_t *p)  {</span>
<span class="line-removed">177    return __sync_sub_and_fetch(p, 1);</span>
<span class="line-removed">178 }</span>
<span class="line-removed">179 U_NAMESPACE_END</span>
<span class="line-removed">180 </span>
<span class="line-removed">181 #else</span>
<span class="line-removed">182 </span>
<span class="line-removed">183 /*</span>
<span class="line-removed">184  * Unknown Platform. Use out-of-line functions, which in turn use mutexes.</span>
<span class="line-removed">185  *                   Slow but correct.</span>
<span class="line-removed">186  */</span>
<span class="line-removed">187 </span>
<span class="line-removed">188 #define U_NO_PLATFORM_ATOMICS</span>
<span class="line-removed">189 </span>
<span class="line-removed">190 U_NAMESPACE_BEGIN</span>
<span class="line-removed">191 typedef int32_t u_atomic_int32_t;</span>
<span class="line-removed">192 #define ATOMIC_INT32_T_INITIALIZER(val) val</span>
<span class="line-removed">193 </span>
<span class="line-removed">194 U_COMMON_API int32_t U_EXPORT2</span>
<span class="line-removed">195 umtx_loadAcquire(u_atomic_int32_t &amp;var);</span>
<span class="line-removed">196 </span>
<span class="line-removed">197 U_COMMON_API void U_EXPORT2</span>
<span class="line-removed">198 umtx_storeRelease(u_atomic_int32_t &amp;var, int32_t val);</span>
<span class="line-removed">199 </span>
<span class="line-removed">200 U_COMMON_API int32_t U_EXPORT2</span>
<span class="line-removed">201 umtx_atomic_inc(u_atomic_int32_t *p);</span>
<span class="line-removed">202 </span>
<span class="line-removed">203 U_COMMON_API int32_t U_EXPORT2</span>
<span class="line-removed">204 umtx_atomic_dec(u_atomic_int32_t *p);</span>
<span class="line-removed">205 </span>
<span class="line-removed">206 U_NAMESPACE_END</span>
<span class="line-removed">207 </span>
<span class="line-removed">208 #endif  /* Low Level Atomic Ops Platfrom Chain */</span>
<span class="line-removed">209 </span>
210 
211 
212 /*************************************************************************************************
213  *
214  *  UInitOnce Definitions.
<span class="line-removed">215  *     These are platform neutral.</span>
216  *
217  *************************************************************************************************/
218 
<span class="line-removed">219 U_NAMESPACE_BEGIN</span>
<span class="line-removed">220 </span>
221 struct UInitOnce {
222     u_atomic_int32_t   fState;
223     UErrorCode       fErrCode;
<span class="line-modified">224     void reset() {fState = 0;};</span>
<span class="line-modified">225     UBool isReset() {return umtx_loadAcquire(fState) == 0;};</span>
226 // Note: isReset() is used by service registration code.
227 //                 Thread safety of this usage needs review.
228 };
229 
230 #define U_INITONCE_INITIALIZER {ATOMIC_INT32_T_INITIALIZER(0), U_ZERO_ERROR}
231 
232 
233 U_COMMON_API UBool U_EXPORT2 umtx_initImplPreInit(UInitOnce &amp;);
234 U_COMMON_API void  U_EXPORT2 umtx_initImplPostInit(UInitOnce &amp;);
235 
236 template&lt;class T&gt; void umtx_initOnce(UInitOnce &amp;uio, T *obj, void (U_CALLCONV T::*fp)()) {
237     if (umtx_loadAcquire(uio.fState) == 2) {
238         return;
239     }
240     if (umtx_initImplPreInit(uio)) {
241         (obj-&gt;*fp)();
242         umtx_initImplPostInit(uio);
243     }
244 }
245 
</pre>
<hr />
<pre>
289 
290 // umtx_initOnce variant for plain functions, or static class functions,
291 //               with a context parameter and an error code.
292 template&lt;class T&gt; void umtx_initOnce(UInitOnce &amp;uio, void (U_CALLCONV *fp)(T, UErrorCode &amp;), T context, UErrorCode &amp;errCode) {
293     if (U_FAILURE(errCode)) {
294         return;
295     }
296     if (umtx_loadAcquire(uio.fState) != 2 &amp;&amp; umtx_initImplPreInit(uio)) {
297         // We run the initialization.
298         (*fp)(context, errCode);
299         uio.fErrCode = errCode;
300         umtx_initImplPostInit(uio);
301     } else {
302         // Someone else already ran the initialization.
303         if (U_FAILURE(uio.fErrCode)) {
304             errCode = uio.fErrCode;
305         }
306     }
307 }
308 
<span class="line-removed">309 U_NAMESPACE_END</span>
<span class="line-removed">310 </span>
<span class="line-removed">311 </span>
312 
313 /*************************************************************************************************
314  *
<span class="line-modified">315  *  Mutex Definitions. Platform Dependent, #if platform chain follows.</span>
<span class="line-modified">316  *         TODO:  Add a C++11 version.</span>
<span class="line-modified">317  *                Need to convert all mutex using files to C++ first.</span>
318  *
319  *************************************************************************************************/
320 
<span class="line-modified">321 #if defined(U_USER_MUTEX_H)</span>
<span class="line-modified">322 // #inlcude &quot;U_USER_MUTEX_H&quot;</span>
<span class="line-modified">323 #include U_MUTEX_XSTR(U_USER_MUTEX_H)</span>


324 
<span class="line-modified">325 #elif U_PLATFORM_USES_ONLY_WIN32_API</span>
<span class="line-modified">326 </span>
<span class="line-removed">327 /* For CRITICAL_SECTION */</span>
<span class="line-removed">328 </span>
<span class="line-removed">329 /*</span>
<span class="line-removed">330  *   Note: there is an earlier include of windows.h in this file, but it is in</span>
<span class="line-removed">331  *         different conditionals.</span>
<span class="line-removed">332  *         This one is needed if we are using C++11 for atomic ops, but</span>
<span class="line-removed">333  *         win32 APIs for Critical Sections.</span>
<span class="line-removed">334  */</span>
<span class="line-removed">335 </span>
<span class="line-removed">336 #ifndef WIN32_LEAN_AND_MEAN</span>
<span class="line-removed">337 # define WIN32_LEAN_AND_MEAN</span>
<span class="line-removed">338 #endif</span>
<span class="line-removed">339 # define VC_EXTRALEAN</span>
<span class="line-removed">340 # define NOUSER</span>
<span class="line-removed">341 # define NOSERVICE</span>
<span class="line-removed">342 # define NOIME</span>
<span class="line-removed">343 # define NOMCX</span>
<span class="line-removed">344 # ifndef NOMINMAX</span>
<span class="line-removed">345 # define NOMINMAX</span>
<span class="line-removed">346 # endif</span>
<span class="line-removed">347 # include &lt;windows.h&gt;</span>
<span class="line-removed">348 </span>
<span class="line-removed">349 </span>
<span class="line-removed">350 typedef struct UMutex {</span>
<span class="line-removed">351     icu::UInitOnce    fInitOnce;</span>
<span class="line-removed">352     CRITICAL_SECTION  fCS;</span>
<span class="line-removed">353 } UMutex;</span>
<span class="line-removed">354 </span>
<span class="line-removed">355 /* Initializer for a static UMUTEX. Deliberately contains no value for the</span>
<span class="line-removed">356  *  CRITICAL_SECTION.</span>
<span class="line-removed">357  */</span>
<span class="line-removed">358 #define U_MUTEX_INITIALIZER {U_INITONCE_INITIALIZER}</span>
<span class="line-removed">359 </span>
<span class="line-removed">360 struct UConditionVar {</span>
<span class="line-removed">361     HANDLE           fEntryGate;</span>
<span class="line-removed">362     HANDLE           fExitGate;</span>
<span class="line-removed">363     int32_t          fWaitCount;</span>
364 };
365 
<span class="line-removed">366 #define U_CONDITION_INITIALIZER {NULL, NULL, 0}</span>
367 





368 
<span class="line-modified">369 </span>
<span class="line-removed">370 #elif U_PLATFORM_IMPLEMENTS_POSIX</span>
<span class="line-removed">371 </span>
<span class="line-removed">372 /*</span>
<span class="line-removed">373  *  POSIX platform</span>
<span class="line-removed">374  */</span>
<span class="line-removed">375 </span>
<span class="line-removed">376 #include &lt;pthread.h&gt;</span>
<span class="line-removed">377 </span>
<span class="line-removed">378 struct UMutex {</span>
<span class="line-removed">379     pthread_mutex_t  fMutex;</span>
<span class="line-removed">380 };</span>
<span class="line-removed">381 typedef struct UMutex UMutex;</span>
<span class="line-removed">382 #define U_MUTEX_INITIALIZER  {PTHREAD_MUTEX_INITIALIZER}</span>
<span class="line-removed">383 </span>
<span class="line-removed">384 struct UConditionVar {</span>
<span class="line-removed">385     pthread_cond_t   fCondition;</span>
386 };
<span class="line-removed">387 #define U_CONDITION_INITIALIZER {PTHREAD_COND_INITIALIZER}</span>
388 
<span class="line-modified">389 #else</span>

390 
<span class="line-modified">391 /*</span>
<span class="line-modified">392  *  Unknow platform type.</span>
<span class="line-modified">393  *      This is an error condition. ICU requires mutexes.</span>
<span class="line-modified">394  */</span>
<span class="line-modified">395 </span>
<span class="line-modified">396 #error Unknown Platform.</span>
<span class="line-modified">397 </span>
<span class="line-modified">398 #endif</span>
<span class="line-modified">399 </span>
<span class="line-modified">400 </span>
<span class="line-modified">401 </span>
<span class="line-removed">402 /**************************************************************************************</span>
<span class="line-removed">403  *</span>
<span class="line-removed">404  *  Mutex Implementation function declaratations.</span>
<span class="line-removed">405  *     Declarations are platform neutral.</span>
<span class="line-removed">406  *     Implementations, in umutex.cpp, are platform specific.</span>
<span class="line-removed">407  *</span>
<span class="line-removed">408  ************************************************************************************/</span>
409 
410 /* Lock a mutex.
411  * @param mutex The given mutex to be locked.  Pass NULL to specify
412  *              the global ICU mutex.  Recursive locks are an error
413  *              and may cause a deadlock on some platforms.
414  */
415 U_INTERNAL void U_EXPORT2 umtx_lock(UMutex* mutex);
416 
417 /* Unlock a mutex.
418  * @param mutex The given mutex to be unlocked.  Pass NULL to specify
419  *              the global ICU mutex.
420  */
421 U_INTERNAL void U_EXPORT2 umtx_unlock (UMutex* mutex);
422 
423 /*
424  * Wait on a condition variable.
425  * The calling thread will unlock the mutex and wait on the condition variable.
426  * The mutex must be locked by the calling thread when invoking this function.
427  *
428  * @param cond the condition variable to wait on.
429  * @param mutex the associated mutex.
430  */
431 
432 U_INTERNAL void U_EXPORT2 umtx_condWait(UConditionVar *cond, UMutex *mutex);
433 
434 
435 /*
436  * Broadcast wakeup of all threads waiting on a Condition.
<span class="line-removed">437  * The associated mutex must be locked by the calling thread when calling</span>
<span class="line-removed">438  * this function; this is a temporary ICU restriction.</span>
439  *
440  * @param cond the condition variable.
441  */
442 U_INTERNAL void U_EXPORT2 umtx_condBroadcast(UConditionVar *cond);
443 
444 /*
445  * Signal a condition variable, waking up one waiting thread.
<span class="line-removed">446  * CAUTION: Do not use. Place holder only. Not implemented for Windows.</span>
447  */
448 U_INTERNAL void U_EXPORT2 umtx_condSignal(UConditionVar *cond);
449 



450 #endif /* UMUTEX_H */
451 /*eof*/
</pre>
</td>
<td>
<hr />
<pre>
  3 /*
  4 **********************************************************************
  5 *   Copyright (C) 1997-2015, International Business Machines
  6 *   Corporation and others.  All Rights Reserved.
  7 **********************************************************************
  8 *
  9 * File UMUTEX.H
 10 *
 11 * Modification History:
 12 *
 13 *   Date        Name        Description
 14 *   04/02/97  aliu        Creation.
 15 *   04/07/99  srl         rewrite - C interface, multiple mutices
 16 *   05/13/99  stephen     Changed to umutex (from cmutex)
 17 ******************************************************************************
 18 */
 19 
 20 #ifndef UMUTEX_H
 21 #define UMUTEX_H
 22 
<span class="line-added"> 23 #include &lt;atomic&gt;</span>
<span class="line-added"> 24 #include &lt;condition_variable&gt;</span>
<span class="line-added"> 25 #include &lt;mutex&gt;</span>
<span class="line-added"> 26 </span>
 27 #include &quot;unicode/utypes.h&quot;
 28 #include &quot;unicode/uclean.h&quot;
<span class="line-added"> 29 #include &quot;unicode/uobject.h&quot;</span>
<span class="line-added"> 30 </span>
 31 #include &quot;putilimp.h&quot;
 32 
<span class="line-added"> 33 #if defined(U_USER_ATOMICS_H) || defined(U_USER_MUTEX_H)</span>
<span class="line-added"> 34 // Support for including an alternate implementation of atomic &amp; mutex operations has been withdrawn.</span>
<span class="line-added"> 35 // See issue ICU-20185.</span>
<span class="line-added"> 36 #error U_USER_ATOMICS and U_USER_MUTEX_H are not supported</span>
<span class="line-added"> 37 #endif</span>
 38 
 39 
<span class="line-modified"> 40 // Export an explicit template instantiation of std::atomic&lt;int32_t&gt;.</span>
<span class="line-modified"> 41 // When building DLLs for Windows this is required as it is used as a data member of the exported SharedObject class.</span>
<span class="line-modified"> 42 // See digitlst.h, pluralaffix.h, datefmt.h, and others for similar examples.</span>
<span class="line-modified"> 43 #if U_PF_WINDOWS &lt;= U_PLATFORM &amp;&amp; U_PLATFORM &lt;= U_PF_CYGWIN &amp;&amp; !defined(U_IN_DOXYGEN)</span>
<span class="line-added"> 44 #if defined(__clang__) || defined(_MSC_VER)</span>
<span class="line-added"> 45   #if defined(__clang__)</span>
<span class="line-added"> 46     // Suppress the warning that the explicit instantiation after explicit specialization has no effect.</span>
<span class="line-added"> 47     #pragma clang diagnostic push</span>
<span class="line-added"> 48     #pragma clang diagnostic ignored &quot;-Winstantiation-after-specialization&quot;</span>
<span class="line-added"> 49   #endif</span>
<span class="line-added"> 50 template struct U_COMMON_API std::atomic&lt;int32_t&gt;;</span>
<span class="line-added"> 51   #if defined(__clang__)</span>
<span class="line-added"> 52     #pragma clang diagnostic pop</span>
<span class="line-added"> 53   #endif</span>
<span class="line-added"> 54 #elif defined(__GNUC__)</span>
<span class="line-added"> 55 // For GCC this class is already exported/visible, so no need for U_COMMON_API.</span>
<span class="line-added"> 56 template struct std::atomic&lt;int32_t&gt;;</span>
<span class="line-added"> 57 #endif</span>
<span class="line-added"> 58 #endif</span>
 59 



 60 
<span class="line-modified"> 61 U_NAMESPACE_BEGIN</span>


 62 
 63 /****************************************************************************
 64  *
<span class="line-modified"> 65  *   Low Level Atomic Operations, ICU wrappers for.</span>

 66  *
 67  ****************************************************************************/










 68 
 69 typedef std::atomic&lt;int32_t&gt; u_atomic_int32_t;
 70 #define ATOMIC_INT32_T_INITIALIZER(val) ATOMIC_VAR_INIT(val)
 71 
 72 inline int32_t umtx_loadAcquire(u_atomic_int32_t &amp;var) {
 73     return var.load(std::memory_order_acquire);
 74 }
 75 
 76 inline void umtx_storeRelease(u_atomic_int32_t &amp;var, int32_t val) {
 77     var.store(val, std::memory_order_release);
 78 }
 79 
 80 inline int32_t umtx_atomic_inc(u_atomic_int32_t *var) {
 81     return var-&gt;fetch_add(1) + 1;
 82 }
 83 
 84 inline int32_t umtx_atomic_dec(u_atomic_int32_t *var) {
 85     return var-&gt;fetch_sub(1) - 1;
 86 }





































































































































 87 
 88 
 89 /*************************************************************************************************
 90  *
 91  *  UInitOnce Definitions.

 92  *
 93  *************************************************************************************************/
 94 


 95 struct UInitOnce {
 96     u_atomic_int32_t   fState;
 97     UErrorCode       fErrCode;
<span class="line-modified"> 98     void reset() {fState = 0;}</span>
<span class="line-modified"> 99     UBool isReset() {return umtx_loadAcquire(fState) == 0;}</span>
100 // Note: isReset() is used by service registration code.
101 //                 Thread safety of this usage needs review.
102 };
103 
104 #define U_INITONCE_INITIALIZER {ATOMIC_INT32_T_INITIALIZER(0), U_ZERO_ERROR}
105 
106 
107 U_COMMON_API UBool U_EXPORT2 umtx_initImplPreInit(UInitOnce &amp;);
108 U_COMMON_API void  U_EXPORT2 umtx_initImplPostInit(UInitOnce &amp;);
109 
110 template&lt;class T&gt; void umtx_initOnce(UInitOnce &amp;uio, T *obj, void (U_CALLCONV T::*fp)()) {
111     if (umtx_loadAcquire(uio.fState) == 2) {
112         return;
113     }
114     if (umtx_initImplPreInit(uio)) {
115         (obj-&gt;*fp)();
116         umtx_initImplPostInit(uio);
117     }
118 }
119 
</pre>
<hr />
<pre>
163 
164 // umtx_initOnce variant for plain functions, or static class functions,
165 //               with a context parameter and an error code.
166 template&lt;class T&gt; void umtx_initOnce(UInitOnce &amp;uio, void (U_CALLCONV *fp)(T, UErrorCode &amp;), T context, UErrorCode &amp;errCode) {
167     if (U_FAILURE(errCode)) {
168         return;
169     }
170     if (umtx_loadAcquire(uio.fState) != 2 &amp;&amp; umtx_initImplPreInit(uio)) {
171         // We run the initialization.
172         (*fp)(context, errCode);
173         uio.fErrCode = errCode;
174         umtx_initImplPostInit(uio);
175     } else {
176         // Someone else already ran the initialization.
177         if (U_FAILURE(uio.fErrCode)) {
178             errCode = uio.fErrCode;
179         }
180     }
181 }
182 



183 
184 /*************************************************************************************************
185  *
<span class="line-modified">186  * ICU Mutex wrappers.  Originally wrapped operating system mutexes, giving the rest of ICU a</span>
<span class="line-modified">187  * platform independent set of mutex operations.  Now vestigial, wrapping std::mutex only.</span>
<span class="line-modified">188  * For internal ICU use only.</span>
189  *
190  *************************************************************************************************/
191 
<span class="line-modified">192 struct UMutex : public icu::UMemory {</span>
<span class="line-modified">193     UMutex() = default;</span>
<span class="line-modified">194     ~UMutex() = default;</span>
<span class="line-added">195     UMutex(const UMutex &amp;other) = delete;</span>
<span class="line-added">196     UMutex &amp;operator =(const UMutex &amp;other) = delete;</span>
197 
<span class="line-modified">198     std::mutex   fMutex = {};    // Note: struct - pubic members - because most access is from</span>
<span class="line-modified">199     //                           //       plain C style functions (umtx_lock(), etc.)</span>





































200 };
201 

202 
<span class="line-added">203 struct UConditionVar : public icu::UMemory {</span>
<span class="line-added">204     U_COMMON_API UConditionVar();</span>
<span class="line-added">205     U_COMMON_API ~UConditionVar();</span>
<span class="line-added">206     UConditionVar(const UConditionVar &amp;other) = delete;</span>
<span class="line-added">207     UConditionVar &amp;operator =(const UConditionVar &amp;other) = delete;</span>
208 
<span class="line-modified">209     std::condition_variable_any fCV;</span>
















210 };

211 
<span class="line-modified">212 #define U_MUTEX_INITIALIZER {}</span>
<span class="line-added">213 #define U_CONDITION_INITIALIZER {}</span>
214 
<span class="line-modified">215 // Implementation notes for UConditionVar:</span>
<span class="line-modified">216 //</span>
<span class="line-modified">217 // Use an out-of-line constructor to reduce problems with the ICU dependency checker.</span>
<span class="line-modified">218 // On Linux, the default constructor of std::condition_variable_any</span>
<span class="line-modified">219 // produces an in-line reference to global operator new(), which the</span>
<span class="line-modified">220 // dependency checker flags for any file that declares a UConditionVar. With</span>
<span class="line-modified">221 // an out-of-line constructor, the dependency is constrained to umutex.o</span>
<span class="line-modified">222 //</span>
<span class="line-modified">223 // Do not export (U_COMMON_API) the entire class, but only the constructor</span>
<span class="line-modified">224 // and destructor, to avoid Windows build problems with attempting to export the</span>
<span class="line-modified">225 // std::condition_variable_any.</span>







226 
227 /* Lock a mutex.
228  * @param mutex The given mutex to be locked.  Pass NULL to specify
229  *              the global ICU mutex.  Recursive locks are an error
230  *              and may cause a deadlock on some platforms.
231  */
232 U_INTERNAL void U_EXPORT2 umtx_lock(UMutex* mutex);
233 
234 /* Unlock a mutex.
235  * @param mutex The given mutex to be unlocked.  Pass NULL to specify
236  *              the global ICU mutex.
237  */
238 U_INTERNAL void U_EXPORT2 umtx_unlock (UMutex* mutex);
239 
240 /*
241  * Wait on a condition variable.
242  * The calling thread will unlock the mutex and wait on the condition variable.
243  * The mutex must be locked by the calling thread when invoking this function.
244  *
245  * @param cond the condition variable to wait on.
246  * @param mutex the associated mutex.
247  */
248 
249 U_INTERNAL void U_EXPORT2 umtx_condWait(UConditionVar *cond, UMutex *mutex);
250 
251 
252 /*
253  * Broadcast wakeup of all threads waiting on a Condition.


254  *
255  * @param cond the condition variable.
256  */
257 U_INTERNAL void U_EXPORT2 umtx_condBroadcast(UConditionVar *cond);
258 
259 /*
260  * Signal a condition variable, waking up one waiting thread.

261  */
262 U_INTERNAL void U_EXPORT2 umtx_condSignal(UConditionVar *cond);
263 
<span class="line-added">264 </span>
<span class="line-added">265 U_NAMESPACE_END</span>
<span class="line-added">266 </span>
267 #endif /* UMUTEX_H */
268 /*eof*/
</pre>
</td>
</tr>
</table>
<center><a href="umutex.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="unames.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>