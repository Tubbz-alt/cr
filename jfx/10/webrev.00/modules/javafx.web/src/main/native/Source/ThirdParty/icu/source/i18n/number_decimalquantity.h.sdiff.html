<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_decimalquantity.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="number_decimalquantity.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_decimfmtprops.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_decimalquantity.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 36     DecimalQuantity(const DecimalQuantity &amp;other);
 37 
 38     /** Move constructor. */
 39     DecimalQuantity(DecimalQuantity &amp;&amp;src) U_NOEXCEPT;
 40 
 41     DecimalQuantity();
 42 
 43     ~DecimalQuantity() override;
 44 
 45     /**
 46      * Sets this instance to be equal to another instance.
 47      *
 48      * @param other The instance to copy from.
 49      */
 50     DecimalQuantity &amp;operator=(const DecimalQuantity &amp;other);
 51 
 52     /** Move assignment */
 53     DecimalQuantity &amp;operator=(DecimalQuantity&amp;&amp; src) U_NOEXCEPT;
 54 
 55     /**
<span class="line-modified"> 56      * Sets the minimum and maximum integer digits that this {@link DecimalQuantity} should generate.</span>
 57      * This method does not perform rounding.
 58      *
 59      * @param minInt The minimum number of integer digits.
<span class="line-removed"> 60      * @param maxInt The maximum number of integer digits.</span>
 61      */
<span class="line-modified"> 62     void setIntegerLength(int32_t minInt, int32_t maxInt);</span>
 63 
 64     /**
<span class="line-modified"> 65      * Sets the minimum and maximum fraction digits that this {@link DecimalQuantity} should generate.</span>
 66      * This method does not perform rounding.
 67      *
 68      * @param minFrac The minimum number of fraction digits.
<span class="line-removed"> 69      * @param maxFrac The maximum number of fraction digits.</span>
 70      */
<span class="line-modified"> 71     void setFractionLength(int32_t minFrac, int32_t maxFrac);</span>








 72 
 73     /**
 74      * Rounds the number to a specified interval, such as 0.05.
 75      *
 76      * &lt;p&gt;If rounding to a power of ten, use the more efficient {@link #roundToMagnitude} instead.
 77      *
 78      * @param roundingIncrement The increment to which to round.
<span class="line-modified"> 79      * @param mathContext The {@link RoundingMode} to use if rounding is necessary.</span>
 80      */
 81     void roundToIncrement(double roundingIncrement, RoundingMode roundingMode,
<span class="line-modified"> 82                           int32_t maxFrac, UErrorCode&amp; status);</span>
 83 
 84     /** Removes all fraction digits. */
 85     void truncate();
 86 









 87     /**
 88      * Rounds the number to a specified magnitude (power of ten).
 89      *
 90      * @param roundingMagnitude The power of ten to which to round. For example, a value of -2 will
 91      *     round to 2 decimal places.
<span class="line-modified"> 92      * @param mathContext The {@link RoundingMode} to use if rounding is necessary.</span>
 93      */
 94     void roundToMagnitude(int32_t magnitude, RoundingMode roundingMode, UErrorCode&amp; status);
 95 
 96     /**
 97      * Rounds the number to an infinite number of decimal points. This has no effect except for
 98      * forcing the double in {@link DecimalQuantity_AbstractBCD} to adopt its exact representation.
 99      */
100     void roundToInfinity();
101 
102     /**
103      * Multiply the internal value. Uses decNumber.
104      *
105      * @param multiplicand The value by which to multiply.
106      */
107     void multiplyBy(const DecNum&amp; multiplicand, UErrorCode&amp; status);
108 
109     /**
110      * Divide the internal value. Uses decNumber.
111      *
112      * @param multiplicand The value by which to multiply.
</pre>
<hr />
<pre>
243 
244     /**
245      * Checks whether the bytes stored in this instance are all valid. For internal unit testing only.
246      *
247      * @return An error message if this instance is invalid, or null if this instance is healthy.
248      */
249     const char16_t* checkHealth() const;
250 
251     UnicodeString toString() const;
252 
253     /** Returns the string in standard exponential notation. */
254     UnicodeString toScientificString() const;
255 
256     /** Returns the string without exponential notation. Slightly slower than toScientificString(). */
257     UnicodeString toPlainString() const;
258 
259     /** Visible for testing */
260     inline bool isUsingBytes() { return usingBytes; }
261 
262     /** Visible for testing */
<span class="line-modified">263     inline bool isExplicitExactDouble() { return explicitExactDouble; };</span>
264 
265     bool operator==(const DecimalQuantity&amp; other) const;
266 
267     inline bool operator!=(const DecimalQuantity&amp; other) const {
268         return !(*this == other);
269     }
270 
271     /**
272      * Bogus flag for when a DecimalQuantity is stored on the stack.
273      */
274     bool bogus = false;
275 
276   private:
277     /**
278      * The power of ten corresponding to the least significant digit in the BCD. For example, if this
279      * object represents the number &quot;3.14&quot;, the BCD will be &quot;0x314&quot; and the scale will be -2.
280      *
281      * &lt;p&gt;Note that in {@link java.math.BigDecimal}, the scale is defined differently: the number of
282      * digits after the decimal place, which is the negative of our definition of scale.
283      */
</pre>
<hr />
<pre>
310     // you don&#39;t round, assertions will fail in certain other methods if you try calling them.
311 
312     /**
313      * Whether the value in the BCD comes from the double fast path without having been rounded to
314      * ensure correctness
315      */
316     UBool isApproximate;
317 
318     /**
319      * The original number provided by the user and which is represented in BCD. Used when we need to
320      * re-compute the BCD for an exact double representation.
321      */
322     double origDouble;
323 
324     /**
325      * The change in magnitude relative to the original double. Used when we need to re-compute the
326      * BCD for an exact double representation.
327      */
328     int32_t origDelta;
329 
<span class="line-modified">330     // Four positions: left optional &#39;(&#39;, left required &#39;[&#39;, right required &#39;]&#39;, right optional &#39;)&#39;.</span>
<span class="line-modified">331     // These four positions determine which digits are displayed in the output string.  They do NOT</span>
<span class="line-modified">332     // affect rounding.  These positions are internal-only and can be specified only by the public</span>
<span class="line-removed">333     // endpoints like setFractionLength, setIntegerLength, and setSignificantDigits, among others.</span>
<span class="line-removed">334     //</span>
<span class="line-removed">335     //   * Digits between lReqPos and rReqPos are in the &quot;required zone&quot; and are always displayed.</span>
<span class="line-removed">336     //   * Digits between lOptPos and rOptPos but outside the required zone are in the &quot;optional zone&quot;</span>
<span class="line-removed">337     //     and are displayed unless they are trailing off the left or right edge of the number and</span>
<span class="line-removed">338     //     have a numerical value of zero.  In order to be &quot;trailing&quot;, the digits need to be beyond</span>
<span class="line-removed">339     //     the decimal point in their respective directions.</span>
<span class="line-removed">340     //   * Digits outside of the &quot;optional zone&quot; are never displayed.</span>
<span class="line-removed">341     //</span>
<span class="line-removed">342     // See the table below for illustrative examples.</span>
<span class="line-removed">343     //</span>
<span class="line-removed">344     // +---------+---------+---------+---------+------------+------------------------+--------------+</span>
<span class="line-removed">345     // | lOptPos | lReqPos | rReqPos | rOptPos |   number   |        positions       | en-US string |</span>
<span class="line-removed">346     // +---------+---------+---------+---------+------------+------------------------+--------------+</span>
<span class="line-removed">347     // |    5    |    2    |   -1    |   -5    |   1234.567 |     ( 12[34.5]67  )    |   1,234.567  |</span>
<span class="line-removed">348     // |    3    |    2    |   -1    |   -5    |   1234.567 |      1(2[34.5]67  )    |     234.567  |</span>
<span class="line-removed">349     // |    3    |    2    |   -1    |   -2    |   1234.567 |      1(2[34.5]6)7      |     234.56   |</span>
<span class="line-removed">350     // |    6    |    4    |    2    |   -5    | 123456789. |  123(45[67]89.     )   | 456,789.     |</span>
<span class="line-removed">351     // |    6    |    4    |    2    |    1    | 123456789. |     123(45[67]8)9.     | 456,780.     |</span>
<span class="line-removed">352     // |   -1    |   -1    |   -3    |   -4    | 0.123456   |     0.1([23]4)56       |        .0234 |</span>
<span class="line-removed">353     // |    6    |    4    |   -2    |   -2    |     12.3   |     (  [  12.3 ])      |    0012.30   |</span>
<span class="line-removed">354     // +---------+---------+---------+---------+------------+------------------------+--------------+</span>
<span class="line-removed">355     //</span>
<span class="line-removed">356     int32_t lOptPos = INT32_MAX;</span>
357     int32_t lReqPos = 0;
358     int32_t rReqPos = 0;
<span class="line-removed">359     int32_t rOptPos = INT32_MIN;</span>
360 
361     /**
362      * The BCD of the 16 digits of the number represented by this object. Every 4 bits of the long map
363      * to one digit. For example, the number &quot;12345&quot; in BCD is &quot;0x12345&quot;.
364      *
365      * &lt;p&gt;Whenever bcd changes internally, {@link #compact()} must be called, except in special cases
366      * like setting the digit to zero.
367      */
368     union {
369         struct {
370             int8_t *ptr;
371             int32_t len;
372         } bcdBytes;
373         uint64_t bcdLong;
374     } fBCD;
375 
376     bool usingBytes = false;
377 
378     /**
379      * Whether this {@link DecimalQuantity} has been explicitly converted to an exact double. true if


385     /**
386      * Returns a single digit from the BCD list. No internal state is changed by calling this method.
387      *
388      * @param position The position of the digit to pop, counted in BCD units from the least
389      *     significant digit. If outside the range supported by the implementation, zero is returned.
390      * @return The digit at the specified location.
391      */
392     int8_t getDigitPos(int32_t position) const;
393 
394     /**
395      * Sets the digit in the BCD list. This method only sets the digit; it is the caller&#39;s
396      * responsibility to call {@link #compact} after setting the digit.
397      *
398      * @param position The position of the digit to pop, counted in BCD units from the least
399      *     significant digit. If outside the range supported by the implementation, an AssertionError
400      *     is thrown.
401      * @param value The digit to set at the specified location.
402      */
403     void setDigitPos(int32_t position, int8_t value);
404 






413     void shiftRight(int32_t numDigits);
414 








415     /**
416      * Sets the internal representation to zero. Clears any values stored in scale, precision,
417      * hasDouble, origDouble, origDelta, and BCD data.
418      */
419     void setBcdToZero();
420 
421     /**
422      * Sets the internal BCD state to represent the value in the given int. The int is guaranteed to
423      * be either positive. The internal state is guaranteed to be empty when this method is called.
424      *
425      * @param n The value to consume.
426      */
427     void readIntToBcd(int32_t n);
428 
429     /**
430      * Sets the internal BCD state to represent the value in the given long. The long is guaranteed to
431      * be either positive. The internal state is guaranteed to be empty when this method is called.
432      *
433      * @param n The value to consume.
434      */
</pre>
</td>
<td>
<hr />
<pre>
 36     DecimalQuantity(const DecimalQuantity &amp;other);
 37 
 38     /** Move constructor. */
 39     DecimalQuantity(DecimalQuantity &amp;&amp;src) U_NOEXCEPT;
 40 
 41     DecimalQuantity();
 42 
 43     ~DecimalQuantity() override;
 44 
 45     /**
 46      * Sets this instance to be equal to another instance.
 47      *
 48      * @param other The instance to copy from.
 49      */
 50     DecimalQuantity &amp;operator=(const DecimalQuantity &amp;other);
 51 
 52     /** Move assignment */
 53     DecimalQuantity &amp;operator=(DecimalQuantity&amp;&amp; src) U_NOEXCEPT;
 54 
 55     /**
<span class="line-modified"> 56      * Sets the minimum integer digits that this {@link DecimalQuantity} should generate.</span>
 57      * This method does not perform rounding.
 58      *
 59      * @param minInt The minimum number of integer digits.

 60      */
<span class="line-modified"> 61     void setMinInteger(int32_t minInt);</span>
 62 
 63     /**
<span class="line-modified"> 64      * Sets the minimum fraction digits that this {@link DecimalQuantity} should generate.</span>
 65      * This method does not perform rounding.
 66      *
 67      * @param minFrac The minimum number of fraction digits.

 68      */
<span class="line-modified"> 69     void setMinFraction(int32_t minFrac);</span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71     /**</span>
<span class="line-added"> 72      * Truncates digits from the upper magnitude of the number in order to satisfy the</span>
<span class="line-added"> 73      * specified maximum number of integer digits.</span>
<span class="line-added"> 74      *</span>
<span class="line-added"> 75      * @param maxInt The maximum number of integer digits.</span>
<span class="line-added"> 76      */</span>
<span class="line-added"> 77     void applyMaxInteger(int32_t maxInt);</span>
 78 
 79     /**
 80      * Rounds the number to a specified interval, such as 0.05.
 81      *
 82      * &lt;p&gt;If rounding to a power of ten, use the more efficient {@link #roundToMagnitude} instead.
 83      *
 84      * @param roundingIncrement The increment to which to round.
<span class="line-modified"> 85      * @param roundingMode The {@link RoundingMode} to use if rounding is necessary.</span>
 86      */
 87     void roundToIncrement(double roundingIncrement, RoundingMode roundingMode,
<span class="line-modified"> 88                           UErrorCode&amp; status);</span>
 89 
 90     /** Removes all fraction digits. */
 91     void truncate();
 92 
<span class="line-added"> 93     /**</span>
<span class="line-added"> 94      * Rounds the number to the nearest multiple of 5 at the specified magnitude.</span>
<span class="line-added"> 95      * For example, when magnitude == -2, this performs rounding to the nearest 0.05.</span>
<span class="line-added"> 96      *</span>
<span class="line-added"> 97      * @param magnitude The magnitude at which the digit should become either 0 or 5.</span>
<span class="line-added"> 98      * @param roundingMode Rounding strategy.</span>
<span class="line-added"> 99      */</span>
<span class="line-added">100     void roundToNickel(int32_t magnitude, RoundingMode roundingMode, UErrorCode&amp; status);</span>
<span class="line-added">101 </span>
102     /**
103      * Rounds the number to a specified magnitude (power of ten).
104      *
105      * @param roundingMagnitude The power of ten to which to round. For example, a value of -2 will
106      *     round to 2 decimal places.
<span class="line-modified">107      * @param roundingMode The {@link RoundingMode} to use if rounding is necessary.</span>
108      */
109     void roundToMagnitude(int32_t magnitude, RoundingMode roundingMode, UErrorCode&amp; status);
110 
111     /**
112      * Rounds the number to an infinite number of decimal points. This has no effect except for
113      * forcing the double in {@link DecimalQuantity_AbstractBCD} to adopt its exact representation.
114      */
115     void roundToInfinity();
116 
117     /**
118      * Multiply the internal value. Uses decNumber.
119      *
120      * @param multiplicand The value by which to multiply.
121      */
122     void multiplyBy(const DecNum&amp; multiplicand, UErrorCode&amp; status);
123 
124     /**
125      * Divide the internal value. Uses decNumber.
126      *
127      * @param multiplicand The value by which to multiply.
</pre>
<hr />
<pre>
258 
259     /**
260      * Checks whether the bytes stored in this instance are all valid. For internal unit testing only.
261      *
262      * @return An error message if this instance is invalid, or null if this instance is healthy.
263      */
264     const char16_t* checkHealth() const;
265 
266     UnicodeString toString() const;
267 
268     /** Returns the string in standard exponential notation. */
269     UnicodeString toScientificString() const;
270 
271     /** Returns the string without exponential notation. Slightly slower than toScientificString(). */
272     UnicodeString toPlainString() const;
273 
274     /** Visible for testing */
275     inline bool isUsingBytes() { return usingBytes; }
276 
277     /** Visible for testing */
<span class="line-modified">278     inline bool isExplicitExactDouble() { return explicitExactDouble; }</span>
279 
280     bool operator==(const DecimalQuantity&amp; other) const;
281 
282     inline bool operator!=(const DecimalQuantity&amp; other) const {
283         return !(*this == other);
284     }
285 
286     /**
287      * Bogus flag for when a DecimalQuantity is stored on the stack.
288      */
289     bool bogus = false;
290 
291   private:
292     /**
293      * The power of ten corresponding to the least significant digit in the BCD. For example, if this
294      * object represents the number &quot;3.14&quot;, the BCD will be &quot;0x314&quot; and the scale will be -2.
295      *
296      * &lt;p&gt;Note that in {@link java.math.BigDecimal}, the scale is defined differently: the number of
297      * digits after the decimal place, which is the negative of our definition of scale.
298      */
</pre>
<hr />
<pre>
325     // you don&#39;t round, assertions will fail in certain other methods if you try calling them.
326 
327     /**
328      * Whether the value in the BCD comes from the double fast path without having been rounded to
329      * ensure correctness
330      */
331     UBool isApproximate;
332 
333     /**
334      * The original number provided by the user and which is represented in BCD. Used when we need to
335      * re-compute the BCD for an exact double representation.
336      */
337     double origDouble;
338 
339     /**
340      * The change in magnitude relative to the original double. Used when we need to re-compute the
341      * BCD for an exact double representation.
342      */
343     int32_t origDelta;
344 
<span class="line-modified">345     // Positions to keep track of leading and trailing zeros.</span>
<span class="line-modified">346     // lReqPos is the magnitude of the first required leading zero.</span>
<span class="line-modified">347     // rReqPos is the magnitude of the last required trailing zero.</span>
























348     int32_t lReqPos = 0;
349     int32_t rReqPos = 0;

350 
351     /**
352      * The BCD of the 16 digits of the number represented by this object. Every 4 bits of the long map
353      * to one digit. For example, the number &quot;12345&quot; in BCD is &quot;0x12345&quot;.
354      *
355      * &lt;p&gt;Whenever bcd changes internally, {@link #compact()} must be called, except in special cases
356      * like setting the digit to zero.
357      */
358     union {
359         struct {
360             int8_t *ptr;
361             int32_t len;
362         } bcdBytes;
363         uint64_t bcdLong;
364     } fBCD;
365 
366     bool usingBytes = false;
367 
368     /**
369      * Whether this {@link DecimalQuantity} has been explicitly converted to an exact double. true if
<span class="line-added">375     void roundToMagnitude(int32_t magnitude, RoundingMode roundingMode, bool nickel, UErrorCode&amp; status);</span>
<span class="line-added">376 </span>
377     /**
378      * Returns a single digit from the BCD list. No internal state is changed by calling this method.
379      *
380      * @param position The position of the digit to pop, counted in BCD units from the least
381      *     significant digit. If outside the range supported by the implementation, zero is returned.
382      * @return The digit at the specified location.
383      */
384     int8_t getDigitPos(int32_t position) const;
385 
386     /**
387      * Sets the digit in the BCD list. This method only sets the digit; it is the caller&#39;s
388      * responsibility to call {@link #compact} after setting the digit.
389      *
390      * @param position The position of the digit to pop, counted in BCD units from the least
391      *     significant digit. If outside the range supported by the implementation, an AssertionError
392      *     is thrown.
393      * @param value The digit to set at the specified location.
394      */
395     void setDigitPos(int32_t position, int8_t value);
396 
<span class="line-added">405     /**</span>
<span class="line-added">406      * Directly removes digits from the end of the BCD list.</span>
<span class="line-added">407      * Updates the scale and precision.</span>
<span class="line-added">408      *</span>
<span class="line-added">409      * CAUTION: it is the caller&#39;s responsibility to call {@link #compact} after this method.</span>
<span class="line-added">410      */</span>
411     void shiftRight(int32_t numDigits);
412 
<span class="line-added">413     /**</span>
<span class="line-added">414      * Directly removes digits from the front of the BCD list.</span>
<span class="line-added">415      * Updates precision.</span>
<span class="line-added">416      *</span>
<span class="line-added">417      * CAUTION: it is the caller&#39;s responsibility to call {@link #compact} after this method.</span>
<span class="line-added">418      */</span>
<span class="line-added">419     void popFromLeft(int32_t numDigits);</span>
<span class="line-added">420 </span>
421     /**
422      * Sets the internal representation to zero. Clears any values stored in scale, precision,
423      * hasDouble, origDouble, origDelta, and BCD data.
424      */
425     void setBcdToZero();
426 
427     /**
428      * Sets the internal BCD state to represent the value in the given int. The int is guaranteed to
429      * be either positive. The internal state is guaranteed to be empty when this method is called.
430      *
431      * @param n The value to consume.
432      */
433     void readIntToBcd(int32_t n);
434 
435     /**
436      * Sets the internal BCD state to represent the value in the given long. The long is guaranteed to
437      * be either positive. The internal state is guaranteed to be empty when this method is called.
438      *
439      * @param n The value to consume.
440      */
</pre>
</td>
</tr>
</table>
<center><a href="number_decimalquantity.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_decimfmtprops.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>