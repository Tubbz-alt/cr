<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/plurrule.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 *******************************************************************************
  5 * Copyright (C) 2008-2015, International Business Machines Corporation and
  6 * others. All Rights Reserved.
  7 *******************************************************************************
  8 *
  9 *
 10 * File PLURRULE.H
 11 *
 12 * Modification History:*
 13 *   Date        Name        Description
 14 *
 15 ********************************************************************************
 16 */
 17 
 18 #ifndef PLURRULE
 19 #define PLURRULE
 20 
 21 #include &quot;unicode/utypes.h&quot;
 22 
 23 /**
 24  * \file
 25  * \brief C++ API: PluralRules object
 26  */
 27 
 28 #if !UCONFIG_NO_FORMATTING
 29 
 30 #include &quot;unicode/format.h&quot;
 31 #include &quot;unicode/upluralrules.h&quot;
 32 #ifndef U_HIDE_INTERNAL_API
 33 #include &quot;unicode/numfmt.h&quot;
 34 #endif  /* U_HIDE_INTERNAL_API */
 35 
 36 /**
 37  * Value returned by PluralRules::getUniqueKeywordValue() when there is no
 38  * unique value to return.
 39  * @stable ICU 4.8
 40  */
 41 #define UPLRULES_NO_UNIQUE_VALUE ((double)-0.00123456777)
 42 
 43 U_NAMESPACE_BEGIN
 44 
 45 class Hashtable;
 46 class IFixedDecimal;
 47 class RuleChain;
 48 class PluralRuleParser;
 49 class PluralKeywordEnumeration;
 50 class AndConstraint;
 51 class SharedPluralRules;
 52 
 53 namespace number {
 54 class FormattedNumber;
 55 }
 56 
 57 /**
 58  * Defines rules for mapping non-negative numeric values onto a small set of
 59  * keywords. Rules are constructed from a text description, consisting
 60  * of a series of keywords and conditions.  The {@link #select} method
 61  * examines each condition in order and returns the keyword for the
 62  * first condition that matches the number.  If none match,
 63  * default rule(other) is returned.
 64  *
 65  * For more information, details, and tips for writing rules, see the
 66  * LDML spec, C.11 Language Plural Rules:
 67  * http://www.unicode.org/draft/reports/tr35/tr35.html#Language_Plural_Rules
 68  *
 69  * Examples:&lt;pre&gt;
 70  *   &quot;one: n is 1; few: n in 2..4&quot;&lt;/pre&gt;
 71  *  This defines two rules, for &#39;one&#39; and &#39;few&#39;.  The condition for
 72  *  &#39;one&#39; is &quot;n is 1&quot; which means that the number must be equal to
 73  *  1 for this condition to pass.  The condition for &#39;few&#39; is
 74  *  &quot;n in 2..4&quot; which means that the number must be between 2 and
 75  *  4 inclusive for this condition to pass.  All other numbers
 76  *  are assigned the keyword &quot;other&quot; by the default rule.
 77  *  &lt;/p&gt;&lt;pre&gt;
 78  *    &quot;zero: n is 0; one: n is 1; zero: n mod 100 in 1..19&quot;&lt;/pre&gt;
 79  *  This illustrates that the same keyword can be defined multiple times.
 80  *  Each rule is examined in order, and the first keyword whose condition
 81  *  passes is the one returned.  Also notes that a modulus is applied
 82  *  to n in the last rule.  Thus its condition holds for 119, 219, 319...
 83  *  &lt;/p&gt;&lt;pre&gt;
 84  *    &quot;one: n is 1; few: n mod 10 in 2..4 and n mod 100 not in 12..14&quot;&lt;/pre&gt;
 85  *  This illustrates conjunction and negation.  The condition for &#39;few&#39;
 86  *  has two parts, both of which must be met: &quot;n mod 10 in 2..4&quot; and
 87  *  &quot;n mod 100 not in 12..14&quot;.  The first part applies a modulus to n
 88  *  before the test as in the previous example.  The second part applies
 89  *  a different modulus and also uses negation, thus it matches all
 90  *  numbers _not_ in 12, 13, 14, 112, 113, 114, 212, 213, 214...
 91  *  &lt;/p&gt;
 92  *  &lt;p&gt;
 93  * Syntax:&lt;pre&gt;
 94  * \code
 95  * rules         = rule (&#39;;&#39; rule)*
 96  * rule          = keyword &#39;:&#39; condition
 97  * keyword       = &lt;identifier&gt;
 98  * condition     = and_condition (&#39;or&#39; and_condition)*
 99  * and_condition = relation (&#39;and&#39; relation)*
100  * relation      = is_relation | in_relation | within_relation | &#39;n&#39; &lt;EOL&gt;
101  * is_relation   = expr &#39;is&#39; (&#39;not&#39;)? value
102  * in_relation   = expr (&#39;not&#39;)? &#39;in&#39; range_list
103  * within_relation = expr (&#39;not&#39;)? &#39;within&#39; range
104  * expr          = (&#39;n&#39; | &#39;i&#39; | &#39;f&#39; | &#39;v&#39; | &#39;j&#39;) (&#39;mod&#39; value)?
105  * range_list    = (range | value) (&#39;,&#39; range_list)*
106  * value         = digit+  (&#39;.&#39; digit+)?
107  * digit         = 0|1|2|3|4|5|6|7|8|9
108  * range         = value&#39;..&#39;value
109  * \endcode
110  * &lt;/pre&gt;&lt;/p&gt;
111  * &lt;p&gt;
112  * &lt;p&gt;
113  * The i, f, and v values are defined as follows:
114  * &lt;/p&gt;
115  * &lt;ul&gt;
116  * &lt;li&gt;i to be the integer digits.&lt;/li&gt;
117  * &lt;li&gt;f to be the visible fractional digits, as an integer.&lt;/li&gt;
118  * &lt;li&gt;v to be the number of visible fraction digits.&lt;/li&gt;
119  * &lt;li&gt;j is defined to only match integers. That is j is 3 fails if v != 0 (eg for 3.1 or 3.0).&lt;/li&gt;
120  * &lt;/ul&gt;
121  * &lt;p&gt;
122  * Examples are in the following table:
123  * &lt;/p&gt;
124  * &lt;table border=&#39;1&#39; style=&quot;border-collapse:collapse&quot;&gt;
125  * &lt;tr&gt;
126  * &lt;th&gt;n&lt;/th&gt;
127  * &lt;th&gt;i&lt;/th&gt;
128  * &lt;th&gt;f&lt;/th&gt;
129  * &lt;th&gt;v&lt;/th&gt;
130  * &lt;/tr&gt;
131  * &lt;tr&gt;
132  * &lt;td&gt;1.0&lt;/td&gt;
133  * &lt;td&gt;1&lt;/td&gt;
134  * &lt;td align=&quot;right&quot;&gt;0&lt;/td&gt;
135  * &lt;td&gt;1&lt;/td&gt;
136  * &lt;/tr&gt;
137  * &lt;tr&gt;
138  * &lt;td&gt;1.00&lt;/td&gt;
139  * &lt;td&gt;1&lt;/td&gt;
140  * &lt;td align=&quot;right&quot;&gt;0&lt;/td&gt;
141  * &lt;td&gt;2&lt;/td&gt;
142  * &lt;/tr&gt;
143  * &lt;tr&gt;
144  * &lt;td&gt;1.3&lt;/td&gt;
145  * &lt;td&gt;1&lt;/td&gt;
146  * &lt;td align=&quot;right&quot;&gt;3&lt;/td&gt;
147  * &lt;td&gt;1&lt;/td&gt;
148  * &lt;/tr&gt;
149  * &lt;tr&gt;
150  * &lt;td&gt;1.03&lt;/td&gt;
151  * &lt;td&gt;1&lt;/td&gt;
152  * &lt;td align=&quot;right&quot;&gt;3&lt;/td&gt;
153  * &lt;td&gt;2&lt;/td&gt;
154  * &lt;/tr&gt;
155  * &lt;tr&gt;
156  * &lt;td&gt;1.23&lt;/td&gt;
157  * &lt;td&gt;1&lt;/td&gt;
158  * &lt;td align=&quot;right&quot;&gt;23&lt;/td&gt;
159  * &lt;td&gt;2&lt;/td&gt;
160  * &lt;/tr&gt;
161  * &lt;/table&gt;
162  * &lt;p&gt;
163  * The difference between &#39;in&#39; and &#39;within&#39; is that &#39;in&#39; only includes integers in the specified range, while &#39;within&#39;
164  * includes all values. Using &#39;within&#39; with a range_list consisting entirely of values is the same as using &#39;in&#39; (it&#39;s
165  * not an error).
166  * &lt;/p&gt;
167 
168  * An &quot;identifier&quot; is a sequence of characters that do not have the
169  * Unicode Pattern_Syntax or Pattern_White_Space properties.
170  * &lt;p&gt;
171  * The difference between &#39;in&#39; and &#39;within&#39; is that &#39;in&#39; only includes
172  * integers in the specified range, while &#39;within&#39; includes all values.
173  * Using &#39;within&#39; with a range_list consisting entirely of values is the
174  * same as using &#39;in&#39; (it&#39;s not an error).
175  *&lt;/p&gt;
176  * &lt;p&gt;
177  * Keywords
178  * could be defined by users or from ICU locale data. There are 6
179  * predefined values in ICU - &#39;zero&#39;, &#39;one&#39;, &#39;two&#39;, &#39;few&#39;, &#39;many&#39; and
180  * &#39;other&#39;. Callers need to check the value of keyword returned by
181  * {@link #select} method.
182  * &lt;/p&gt;
183  *
184  * Examples:&lt;pre&gt;
185  * UnicodeString keyword = pl-&gt;select(number);
186  * if (keyword== UnicodeString(&quot;one&quot;) {
187  *     ...
188  * }
189  * else if ( ... )
190  * &lt;/pre&gt;
191  * &lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;
192  *  &lt;p&gt;
193  *   ICU defines plural rules for many locales based on CLDR &lt;i&gt;Language Plural Rules&lt;/i&gt;.
194  *   For these predefined rules, see CLDR page at
195  *    http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
196  * &lt;/p&gt;
197  */
198 class U_I18N_API PluralRules : public UObject {
199 public:
200 
201     /**
202      * Constructor.
203      * @param status  Output param set to success/failure code on exit, which
204      *                must not indicate a failure before the function call.
205      *
206      * @stable ICU 4.0
207      */
208     PluralRules(UErrorCode&amp; status);
209 
210     /**
211      * Copy constructor.
212      * @stable ICU 4.0
213      */
214     PluralRules(const PluralRules&amp; other);
215 
216     /**
217      * Destructor.
218      * @stable ICU 4.0
219      */
220     virtual ~PluralRules();
221 
222     /**
223      * Clone
224      * @stable ICU 4.0
225      */
226     PluralRules* clone() const;
227 
228     /**
229       * Assignment operator.
230       * @stable ICU 4.0
231       */
232     PluralRules&amp; operator=(const PluralRules&amp;);
233 
234     /**
235      * Creates a PluralRules from a description if it is parsable, otherwise
236      * returns NULL.
237      *
238      * @param description rule description
239      * @param status      Output param set to success/failure code on exit, which
240      *                    must not indicate a failure before the function call.
241      * @return            new PluralRules pointer. NULL if there is an error.
242      * @stable ICU 4.0
243      */
244     static PluralRules* U_EXPORT2 createRules(const UnicodeString&amp; description,
245                                               UErrorCode&amp; status);
246 
247     /**
248      * The default rules that accept any number.
249      *
250      * @param status  Output param set to success/failure code on exit, which
251      *                must not indicate a failure before the function call.
252      * @return        new PluralRules pointer. NULL if there is an error.
253      * @stable ICU 4.0
254      */
255     static PluralRules* U_EXPORT2 createDefaultRules(UErrorCode&amp; status);
256 
257     /**
258      * Provides access to the predefined cardinal-number &lt;code&gt;PluralRules&lt;/code&gt; for a given
259      * locale.
260      * Same as forLocale(locale, UPLURAL_TYPE_CARDINAL, status).
261      *
262      * @param locale  The locale for which a &lt;code&gt;PluralRules&lt;/code&gt; object is
263      *                returned.
264      * @param status  Output param set to success/failure code on exit, which
265      *                must not indicate a failure before the function call.
266      * @return        The predefined &lt;code&gt;PluralRules&lt;/code&gt; object pointer for
267      *                this locale. If there&#39;s no predefined rules for this locale,
268      *                the rules for the closest parent in the locale hierarchy
269      *                that has one will  be returned.  The final fallback always
270      *                returns the default &#39;other&#39; rules.
271      * @stable ICU 4.0
272      */
273     static PluralRules* U_EXPORT2 forLocale(const Locale&amp; locale, UErrorCode&amp; status);
274 
275     /**
276      * Provides access to the predefined &lt;code&gt;PluralRules&lt;/code&gt; for a given
277      * locale and the plural type.
278      *
279      * @param locale  The locale for which a &lt;code&gt;PluralRules&lt;/code&gt; object is
280      *                returned.
281      * @param type    The plural type (e.g., cardinal or ordinal).
282      * @param status  Output param set to success/failure code on exit, which
283      *                must not indicate a failure before the function call.
284      * @return        The predefined &lt;code&gt;PluralRules&lt;/code&gt; object pointer for
285      *                this locale. If there&#39;s no predefined rules for this locale,
286      *                the rules for the closest parent in the locale hierarchy
287      *                that has one will  be returned.  The final fallback always
288      *                returns the default &#39;other&#39; rules.
289      * @stable ICU 50
290      */
291     static PluralRules* U_EXPORT2 forLocale(const Locale&amp; locale, UPluralType type, UErrorCode&amp; status);
292 
293 #ifndef U_HIDE_INTERNAL_API
294     /**
295      * Return a StringEnumeration over the locales for which there is plurals data.
296      * @return a StringEnumeration over the locales available.
297      * @internal
298      */
299     static StringEnumeration* U_EXPORT2 getAvailableLocales(UErrorCode &amp;status);
300 
301     /**
302      * Returns whether or not there are overrides.
303      * @param locale       the locale to check.
304      * @return
305      * @internal
306      */
307     static UBool hasOverride(const Locale &amp;locale);
308 
309     /**
310      * For ICU use only.
311      * creates a  SharedPluralRules object
312      * @internal
313      */
314     static PluralRules* U_EXPORT2 internalForLocale(const Locale&amp; locale, UPluralType type, UErrorCode&amp; status);
315 
316     /**
317      * For ICU use only.
318      * Returns handle to the shared, cached PluralRules instance.
319      * Caller must call removeRef() on returned value once it is done with
320      * the shared instance.
321      * @internal
322      */
323     static const SharedPluralRules* U_EXPORT2 createSharedInstance(
324             const Locale&amp; locale, UPluralType type, UErrorCode&amp; status);
325 
326 
327 #endif  /* U_HIDE_INTERNAL_API */
328 
329     /**
330      * Given an integer, returns the keyword of the first rule
331      * that applies to  the number.  This function can be used with
332      * isKeyword* functions to determine the keyword for default plural rules.
333      *
334      * @param number  The number for which the rule has to be determined.
335      * @return        The keyword of the selected rule.
336      * @stable ICU 4.0
337      */
338     UnicodeString select(int32_t number) const;
339 
340     /**
341      * Given a floating-point number, returns the keyword of the first rule
342      * that applies to  the number.  This function can be used with
343      * isKeyword* functions to determine the keyword for default plural rules.
344      *
345      * @param number  The number for which the rule has to be determined.
346      * @return        The keyword of the selected rule.
347      * @stable ICU 4.0
348      */
349     UnicodeString select(double number) const;
350 
351 #ifndef U_HIDE_DRAFT_API
352     /**
353      * Given a formatted number, returns the keyword of the first rule
354      * that applies to  the number.  This function can be used with
355      * isKeyword* functions to determine the keyword for default plural rules.
356      *
357      * A FormattedNumber allows you to specify an exponent or trailing zeros,
358      * which can affect the plural category. To get a FormattedNumber, see
359      * NumberFormatter.
360      *
361      * @param number  The number for which the rule has to be determined.
362      * @param status  Set if an error occurs while selecting plural keyword.
363      *                This could happen if the FormattedNumber is invalid.
364      * @return        The keyword of the selected rule.
365      * @draft ICU 64
366      */
367     UnicodeString select(const number::FormattedNumber&amp; number, UErrorCode&amp; status) const;
368 #endif  /* U_HIDE_DRAFT_API */
369 
370 #ifndef U_HIDE_INTERNAL_API
371     /**
372       * @internal
373       */
374     UnicodeString select(const IFixedDecimal &amp;number) const;
375 #endif  /* U_HIDE_INTERNAL_API */
376 
377     /**
378      * Returns a list of all rule keywords used in this &lt;code&gt;PluralRules&lt;/code&gt;
379      * object.  The rule &#39;other&#39; is always present by default.
380      *
381      * @param status Output param set to success/failure code on exit, which
382      *               must not indicate a failure before the function call.
383      * @return       StringEnumeration with the keywords.
384      *               The caller must delete the object.
385      * @stable ICU 4.0
386      */
387     StringEnumeration* getKeywords(UErrorCode&amp; status) const;
388 
389 #ifndef U_HIDE_DEPRECATED_API
390     /**
391      * Deprecated Function, does not return useful results.
392      *
393      * Originally intended to return a unique value for this keyword if it exists,
394      * else the constant UPLRULES_NO_UNIQUE_VALUE.
395      *
396      * @param keyword The keyword.
397      * @return        Stub deprecated function returns UPLRULES_NO_UNIQUE_VALUE always.
398      * @deprecated ICU 55
399      */
400     double getUniqueKeywordValue(const UnicodeString&amp; keyword);
401 
402     /**
403      * Deprecated Function, does not produce useful results.
404      *
405      * Originally intended to return all the values for which select() would return the keyword.
406      * If the keyword is unknown, returns no values, but this is not an error.  If
407      * the number of values is unlimited, returns no values and -1 as the
408      * count.
409      *
410      * The number of returned values is typically small.
411      *
412      * @param keyword      The keyword.
413      * @param dest         Array into which to put the returned values.  May
414      *                     be NULL if destCapacity is 0.
415      * @param destCapacity The capacity of the array, must be at least 0.
416      * @param status       The error code. Deprecated function, always sets U_UNSUPPORTED_ERROR.
417      * @return             The count of values available, or -1.  This count
418      *                     can be larger than destCapacity, but no more than
419      *                     destCapacity values will be written.
420      * @deprecated ICU 55
421      */
422     int32_t getAllKeywordValues(const UnicodeString &amp;keyword,
423                                 double *dest, int32_t destCapacity,
424                                 UErrorCode&amp; status);
425 #endif  /* U_HIDE_DEPRECATED_API */
426 
427     /**
428      * Returns sample values for which select() would return the keyword.  If
429      * the keyword is unknown, returns no values, but this is not an error.
430      *
431      * The number of returned values is typically small.
432      *
433      * @param keyword      The keyword.
434      * @param dest         Array into which to put the returned values.  May
435      *                     be NULL if destCapacity is 0.
436      * @param destCapacity The capacity of the array, must be at least 0.
437      * @param status       The error code.
438      * @return             The count of values written.
439      *                     If more than destCapacity samples are available, then
440      *                     only destCapacity are written, and destCapacity is returned as the count,
441      *                     rather than setting a U_BUFFER_OVERFLOW_ERROR.
442      *                     (The actual number of keyword values could be unlimited.)
443      * @stable ICU 4.8
444      */
445     int32_t getSamples(const UnicodeString &amp;keyword,
446                        double *dest, int32_t destCapacity,
447                        UErrorCode&amp; status);
448 
449     /**
450      * Returns TRUE if the given keyword is defined in this
451      * &lt;code&gt;PluralRules&lt;/code&gt; object.
452      *
453      * @param keyword  the input keyword.
454      * @return         TRUE if the input keyword is defined.
455      *                 Otherwise, return FALSE.
456      * @stable ICU 4.0
457      */
458     UBool isKeyword(const UnicodeString&amp; keyword) const;
459 
460 
461     /**
462      * Returns keyword for default plural form.
463      *
464      * @return         keyword for default plural form.
465      * @stable ICU 4.0
466      */
467     UnicodeString getKeywordOther() const;
468 
469 #ifndef U_HIDE_INTERNAL_API
470     /**
471      *
472      * @internal
473      */
474      UnicodeString getRules() const;
475 #endif  /* U_HIDE_INTERNAL_API */
476 
477     /**
478      * Compares the equality of two PluralRules objects.
479      *
480      * @param other The other PluralRules object to be compared with.
481      * @return      True if the given PluralRules is the same as this
482      *              PluralRules; false otherwise.
483      * @stable ICU 4.0
484      */
485     virtual UBool operator==(const PluralRules&amp; other) const;
486 
487     /**
488      * Compares the inequality of two PluralRules objects.
489      *
490      * @param other The PluralRules object to be compared with.
491      * @return      True if the given PluralRules is not the same as this
492      *              PluralRules; false otherwise.
493      * @stable ICU 4.0
494      */
495     UBool operator!=(const PluralRules&amp; other) const  {return !operator==(other);}
496 
497 
498     /**
499      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for this class.
500      *
501      * @stable ICU 4.0
502      *
503     */
504     static UClassID U_EXPORT2 getStaticClassID(void);
505 
506     /**
507      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for the actual class.
508      *
509      * @stable ICU 4.0
510      */
511     virtual UClassID getDynamicClassID() const;
512 
513 
514 private:
515     RuleChain  *mRules;
516 
517     PluralRules();   // default constructor not implemented
518     void            parseDescription(const UnicodeString&amp; ruleData, UErrorCode &amp;status);
519     int32_t         getNumberValue(const UnicodeString&amp; token) const;
520     UnicodeString   getRuleFromResource(const Locale&amp; locale, UPluralType type, UErrorCode&amp; status);
521     RuleChain      *rulesForKeyword(const UnicodeString &amp;keyword) const;
522 
523     /**
524     * An internal status variable used to indicate that the object is in an &#39;invalid&#39; state.
525     * Used by copy constructor, the assignment operator and the clone method.
526     */
527     UErrorCode mInternalStatus;
528 
529     friend class PluralRuleParser;
530 };
531 
532 U_NAMESPACE_END
533 
534 #endif /* #if !UCONFIG_NO_FORMATTING */
535 
536 #endif // _PLURRULE
537 //eof
    </pre>
  </body>
</html>