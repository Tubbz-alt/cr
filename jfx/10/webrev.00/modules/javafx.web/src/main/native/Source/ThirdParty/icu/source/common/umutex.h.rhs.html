<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/umutex.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 **********************************************************************
  5 *   Copyright (C) 1997-2015, International Business Machines
  6 *   Corporation and others.  All Rights Reserved.
  7 **********************************************************************
  8 *
  9 * File UMUTEX.H
 10 *
 11 * Modification History:
 12 *
 13 *   Date        Name        Description
 14 *   04/02/97  aliu        Creation.
 15 *   04/07/99  srl         rewrite - C interface, multiple mutices
 16 *   05/13/99  stephen     Changed to umutex (from cmutex)
 17 ******************************************************************************
 18 */
 19 
 20 #ifndef UMUTEX_H
 21 #define UMUTEX_H
 22 
<a name="1" id="anc1"></a><span class="line-added"> 23 #include &lt;atomic&gt;</span>
<span class="line-added"> 24 #include &lt;condition_variable&gt;</span>
<span class="line-added"> 25 #include &lt;mutex&gt;</span>
<span class="line-added"> 26 </span>
 27 #include &quot;unicode/utypes.h&quot;
 28 #include &quot;unicode/uclean.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 29 #include &quot;unicode/uobject.h&quot;</span>
<span class="line-added"> 30 </span>
 31 #include &quot;putilimp.h&quot;
 32 
<a name="3" id="anc3"></a><span class="line-added"> 33 #if defined(U_USER_ATOMICS_H) || defined(U_USER_MUTEX_H)</span>
<span class="line-added"> 34 // Support for including an alternate implementation of atomic &amp; mutex operations has been withdrawn.</span>
<span class="line-added"> 35 // See issue ICU-20185.</span>
<span class="line-added"> 36 #error U_USER_ATOMICS and U_USER_MUTEX_H are not supported</span>
<span class="line-added"> 37 #endif</span>
 38 
 39 
<a name="4" id="anc4"></a><span class="line-modified"> 40 // Export an explicit template instantiation of std::atomic&lt;int32_t&gt;.</span>
<span class="line-modified"> 41 // When building DLLs for Windows this is required as it is used as a data member of the exported SharedObject class.</span>
<span class="line-modified"> 42 // See digitlst.h, pluralaffix.h, datefmt.h, and others for similar examples.</span>
<span class="line-modified"> 43 #if U_PF_WINDOWS &lt;= U_PLATFORM &amp;&amp; U_PLATFORM &lt;= U_PF_CYGWIN &amp;&amp; !defined(U_IN_DOXYGEN)</span>
<span class="line-added"> 44 #if defined(__clang__) || defined(_MSC_VER)</span>
<span class="line-added"> 45   #if defined(__clang__)</span>
<span class="line-added"> 46     // Suppress the warning that the explicit instantiation after explicit specialization has no effect.</span>
<span class="line-added"> 47     #pragma clang diagnostic push</span>
<span class="line-added"> 48     #pragma clang diagnostic ignored &quot;-Winstantiation-after-specialization&quot;</span>
<span class="line-added"> 49   #endif</span>
<span class="line-added"> 50 template struct U_COMMON_API std::atomic&lt;int32_t&gt;;</span>
<span class="line-added"> 51   #if defined(__clang__)</span>
<span class="line-added"> 52     #pragma clang diagnostic pop</span>
<span class="line-added"> 53   #endif</span>
<span class="line-added"> 54 #elif defined(__GNUC__)</span>
<span class="line-added"> 55 // For GCC this class is already exported/visible, so no need for U_COMMON_API.</span>
<span class="line-added"> 56 template struct std::atomic&lt;int32_t&gt;;</span>
<span class="line-added"> 57 #endif</span>
<span class="line-added"> 58 #endif</span>
 59 
<a name="5" id="anc5"></a>


 60 
<a name="6" id="anc6"></a><span class="line-modified"> 61 U_NAMESPACE_BEGIN</span>


 62 
 63 /****************************************************************************
 64  *
<a name="7" id="anc7"></a><span class="line-modified"> 65  *   Low Level Atomic Operations, ICU wrappers for.</span>

 66  *
 67  ****************************************************************************/
<a name="8" id="anc8"></a>









 68 
 69 typedef std::atomic&lt;int32_t&gt; u_atomic_int32_t;
 70 #define ATOMIC_INT32_T_INITIALIZER(val) ATOMIC_VAR_INIT(val)
 71 
 72 inline int32_t umtx_loadAcquire(u_atomic_int32_t &amp;var) {
 73     return var.load(std::memory_order_acquire);
 74 }
 75 
 76 inline void umtx_storeRelease(u_atomic_int32_t &amp;var, int32_t val) {
 77     var.store(val, std::memory_order_release);
 78 }
 79 
 80 inline int32_t umtx_atomic_inc(u_atomic_int32_t *var) {
 81     return var-&gt;fetch_add(1) + 1;
 82 }
 83 
 84 inline int32_t umtx_atomic_dec(u_atomic_int32_t *var) {
 85     return var-&gt;fetch_sub(1) - 1;
 86 }
<a name="9" id="anc9"></a>




































































































































 87 
 88 
 89 /*************************************************************************************************
 90  *
 91  *  UInitOnce Definitions.
<a name="10" id="anc10"></a>
 92  *
 93  *************************************************************************************************/
 94 
<a name="11" id="anc11"></a>

 95 struct UInitOnce {
 96     u_atomic_int32_t   fState;
 97     UErrorCode       fErrCode;
<a name="12" id="anc12"></a><span class="line-modified"> 98     void reset() {fState = 0;}</span>
<span class="line-modified"> 99     UBool isReset() {return umtx_loadAcquire(fState) == 0;}</span>
100 // Note: isReset() is used by service registration code.
101 //                 Thread safety of this usage needs review.
102 };
103 
104 #define U_INITONCE_INITIALIZER {ATOMIC_INT32_T_INITIALIZER(0), U_ZERO_ERROR}
105 
106 
107 U_COMMON_API UBool U_EXPORT2 umtx_initImplPreInit(UInitOnce &amp;);
108 U_COMMON_API void  U_EXPORT2 umtx_initImplPostInit(UInitOnce &amp;);
109 
110 template&lt;class T&gt; void umtx_initOnce(UInitOnce &amp;uio, T *obj, void (U_CALLCONV T::*fp)()) {
111     if (umtx_loadAcquire(uio.fState) == 2) {
112         return;
113     }
114     if (umtx_initImplPreInit(uio)) {
115         (obj-&gt;*fp)();
116         umtx_initImplPostInit(uio);
117     }
118 }
119 
120 
121 // umtx_initOnce variant for plain functions, or static class functions.
122 //               No context parameter.
123 inline void umtx_initOnce(UInitOnce &amp;uio, void (U_CALLCONV *fp)()) {
124     if (umtx_loadAcquire(uio.fState) == 2) {
125         return;
126     }
127     if (umtx_initImplPreInit(uio)) {
128         (*fp)();
129         umtx_initImplPostInit(uio);
130     }
131 }
132 
133 // umtx_initOnce variant for plain functions, or static class functions.
134 //               With ErrorCode, No context parameter.
135 inline void umtx_initOnce(UInitOnce &amp;uio, void (U_CALLCONV *fp)(UErrorCode &amp;), UErrorCode &amp;errCode) {
136     if (U_FAILURE(errCode)) {
137         return;
138     }
139     if (umtx_loadAcquire(uio.fState) != 2 &amp;&amp; umtx_initImplPreInit(uio)) {
140         // We run the initialization.
141         (*fp)(errCode);
142         uio.fErrCode = errCode;
143         umtx_initImplPostInit(uio);
144     } else {
145         // Someone else already ran the initialization.
146         if (U_FAILURE(uio.fErrCode)) {
147             errCode = uio.fErrCode;
148         }
149     }
150 }
151 
152 // umtx_initOnce variant for plain functions, or static class functions,
153 //               with a context parameter.
154 template&lt;class T&gt; void umtx_initOnce(UInitOnce &amp;uio, void (U_CALLCONV *fp)(T), T context) {
155     if (umtx_loadAcquire(uio.fState) == 2) {
156         return;
157     }
158     if (umtx_initImplPreInit(uio)) {
159         (*fp)(context);
160         umtx_initImplPostInit(uio);
161     }
162 }
163 
164 // umtx_initOnce variant for plain functions, or static class functions,
165 //               with a context parameter and an error code.
166 template&lt;class T&gt; void umtx_initOnce(UInitOnce &amp;uio, void (U_CALLCONV *fp)(T, UErrorCode &amp;), T context, UErrorCode &amp;errCode) {
167     if (U_FAILURE(errCode)) {
168         return;
169     }
170     if (umtx_loadAcquire(uio.fState) != 2 &amp;&amp; umtx_initImplPreInit(uio)) {
171         // We run the initialization.
172         (*fp)(context, errCode);
173         uio.fErrCode = errCode;
174         umtx_initImplPostInit(uio);
175     } else {
176         // Someone else already ran the initialization.
177         if (U_FAILURE(uio.fErrCode)) {
178             errCode = uio.fErrCode;
179         }
180     }
181 }
182 
<a name="13" id="anc13"></a>


183 
184 /*************************************************************************************************
185  *
<a name="14" id="anc14"></a><span class="line-modified">186  * ICU Mutex wrappers.  Originally wrapped operating system mutexes, giving the rest of ICU a</span>
<span class="line-modified">187  * platform independent set of mutex operations.  Now vestigial, wrapping std::mutex only.</span>
<span class="line-modified">188  * For internal ICU use only.</span>
189  *
190  *************************************************************************************************/
191 
<a name="15" id="anc15"></a><span class="line-modified">192 struct UMutex : public icu::UMemory {</span>
<span class="line-modified">193     UMutex() = default;</span>
<span class="line-modified">194     ~UMutex() = default;</span>
<span class="line-added">195     UMutex(const UMutex &amp;other) = delete;</span>
<span class="line-added">196     UMutex &amp;operator =(const UMutex &amp;other) = delete;</span>
197 
<a name="16" id="anc16"></a><span class="line-modified">198     std::mutex   fMutex = {};    // Note: struct - pubic members - because most access is from</span>
<span class="line-modified">199     //                           //       plain C style functions (umtx_lock(), etc.)</span>





































200 };
201 
<a name="17" id="anc17"></a>
202 
<a name="18" id="anc18"></a><span class="line-added">203 struct UConditionVar : public icu::UMemory {</span>
<span class="line-added">204     U_COMMON_API UConditionVar();</span>
<span class="line-added">205     U_COMMON_API ~UConditionVar();</span>
<span class="line-added">206     UConditionVar(const UConditionVar &amp;other) = delete;</span>
<span class="line-added">207     UConditionVar &amp;operator =(const UConditionVar &amp;other) = delete;</span>
208 
<a name="19" id="anc19"></a><span class="line-modified">209     std::condition_variable_any fCV;</span>
















210 };
<a name="20" id="anc20"></a>
211 
<a name="21" id="anc21"></a><span class="line-modified">212 #define U_MUTEX_INITIALIZER {}</span>
<span class="line-added">213 #define U_CONDITION_INITIALIZER {}</span>
214 
<a name="22" id="anc22"></a><span class="line-modified">215 // Implementation notes for UConditionVar:</span>
<span class="line-modified">216 //</span>
<span class="line-modified">217 // Use an out-of-line constructor to reduce problems with the ICU dependency checker.</span>
<span class="line-modified">218 // On Linux, the default constructor of std::condition_variable_any</span>
<span class="line-modified">219 // produces an in-line reference to global operator new(), which the</span>
<span class="line-modified">220 // dependency checker flags for any file that declares a UConditionVar. With</span>
<span class="line-modified">221 // an out-of-line constructor, the dependency is constrained to umutex.o</span>
<span class="line-modified">222 //</span>
<span class="line-modified">223 // Do not export (U_COMMON_API) the entire class, but only the constructor</span>
<span class="line-modified">224 // and destructor, to avoid Windows build problems with attempting to export the</span>
<span class="line-modified">225 // std::condition_variable_any.</span>







226 
227 /* Lock a mutex.
228  * @param mutex The given mutex to be locked.  Pass NULL to specify
229  *              the global ICU mutex.  Recursive locks are an error
230  *              and may cause a deadlock on some platforms.
231  */
232 U_INTERNAL void U_EXPORT2 umtx_lock(UMutex* mutex);
233 
234 /* Unlock a mutex.
235  * @param mutex The given mutex to be unlocked.  Pass NULL to specify
236  *              the global ICU mutex.
237  */
238 U_INTERNAL void U_EXPORT2 umtx_unlock (UMutex* mutex);
239 
240 /*
241  * Wait on a condition variable.
242  * The calling thread will unlock the mutex and wait on the condition variable.
243  * The mutex must be locked by the calling thread when invoking this function.
244  *
245  * @param cond the condition variable to wait on.
246  * @param mutex the associated mutex.
247  */
248 
249 U_INTERNAL void U_EXPORT2 umtx_condWait(UConditionVar *cond, UMutex *mutex);
250 
251 
252 /*
253  * Broadcast wakeup of all threads waiting on a Condition.
<a name="23" id="anc23"></a>

254  *
255  * @param cond the condition variable.
256  */
257 U_INTERNAL void U_EXPORT2 umtx_condBroadcast(UConditionVar *cond);
258 
259 /*
260  * Signal a condition variable, waking up one waiting thread.
<a name="24" id="anc24"></a>
261  */
262 U_INTERNAL void U_EXPORT2 umtx_condSignal(UConditionVar *cond);
263 
<a name="25" id="anc25"></a><span class="line-added">264 </span>
<span class="line-added">265 U_NAMESPACE_END</span>
<span class="line-added">266 </span>
267 #endif /* UMUTEX_H */
268 /*eof*/
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>