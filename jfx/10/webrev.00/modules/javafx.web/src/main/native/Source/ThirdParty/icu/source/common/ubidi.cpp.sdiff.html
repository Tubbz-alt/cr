<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/ubidi.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="uassert.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ubidi_props_data.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/ubidi.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 607             flags|=DIRPROP_FLAG(LRI);
 608             break;
 609         }
 610         state=previousStateStack[stackLast];
 611         stackLast--;
 612     }
 613     /* When streaming, ignore text after the last paragraph separator */
 614     if(pBiDi-&gt;reorderingOptions &amp; UBIDI_OPTION_STREAMING) {
 615         if(pBiDi-&gt;length&lt;originalLength)
 616             pBiDi-&gt;paraCount--;
 617     } else {
 618         pBiDi-&gt;paras[pBiDi-&gt;paraCount-1].limit=originalLength;
 619         pBiDi-&gt;controlCount=controlCount;
 620     }
 621     /* For inverse bidi, default para direction is RTL if there is
 622        a strong R or AL at either end of the paragraph */
 623     if(isDefaultLevelInverse &amp;&amp; lastStrong==R) {
 624         pBiDi-&gt;paras[pBiDi-&gt;paraCount-1].level=1;
 625     }
 626     if(isDefaultLevel) {
<span class="line-modified"> 627         pBiDi-&gt;paraLevel=pBiDi-&gt;paras[0].level;</span>
 628     }
 629     /* The following is needed to resolve the text direction for default level
 630        paragraphs containing no strong character */
 631     for(i=0; i&lt;pBiDi-&gt;paraCount; i++)
 632         flags|=DIRPROP_FLAG_LR(pBiDi-&gt;paras[i].level);
 633 
 634     if(pBiDi-&gt;orderParagraphsLTR &amp;&amp; (flags&amp;DIRPROP_FLAG(B))) {
 635         flags|=DIRPROP_FLAG(L);
 636     }
 637     pBiDi-&gt;flags=flags;
 638     pBiDi-&gt;lastArabicPos=lastArabicPos;
 639     return TRUE;
 640 }
 641 
 642 /* determine the paragraph level at position index */
 643 U_CFUNC UBiDiLevel
 644 ubidi_getParaLevelAtIndex(const UBiDi *pBiDi, int32_t pindex) {
 645     int32_t i;
 646     for(i=0; i&lt;pBiDi-&gt;paraCount; i++)
 647         if(pindex&lt;pBiDi-&gt;paras[i].limit)
</pre>
<hr />
<pre>
 808 
 809     /* The stable flag is set when brackets are paired and their
 810        level is resolved and cannot be changed by what will be
 811        found later in the source string.
 812        An unstable match can occur only when applying N0c, where
 813        the resolved level depends on the preceding context, and
 814        this context may be affected by text occurring later.
 815        Example: RTL paragraph containing:  abc[(latin) HEBREW]
 816        When the closing parenthesis is encountered, it appears
 817        that N0c1 must be applied since &#39;abc&#39; sets an opposite
 818        direction context and both parentheses receive level 2.
 819        However, when the closing square bracket is processed,
 820        N0b applies because of &#39;HEBREW&#39; being included within the
 821        brackets, thus the square brackets are treated like R and
 822        receive level 1. However, this changes the preceding
 823        context of the opening parenthesis, and it now appears
 824        that N0c2 must be applied to the parentheses rather than
 825        N0c1. */
 826 
 827     if((direction==0 &amp;&amp; pOpening-&gt;flags&amp;FOUND_L) ||
<span class="line-modified"> 828        (direction==1 &amp;&amp; pOpening-&gt;flags&amp;FOUND_R)) { /* N0b */</span>
<span class="line-modified"> 829         newProp=direction;</span>
 830     }
<span class="line-modified"> 831     else if(pOpening-&gt;flags&amp;(FOUND_L|FOUND_R)) {    /* N0c */</span>
 832         /* it is stable if there is no containing pair or in
 833            conditions too complicated and not worth checking */
 834         stable=(openIdx==pLastIsoRun-&gt;start);
 835         if(direction!=pOpening-&gt;contextDir)
<span class="line-modified"> 836             newProp=pOpening-&gt;contextDir;           /* N0c1 */</span>
 837         else
<span class="line-modified"> 838             newProp=direction;                      /* N0c2 */</span>
 839     } else {
 840         /* forget this and any brackets nested within this pair */
<span class="line-modified"> 841         pLastIsoRun-&gt;limit=openIdx;</span>
<span class="line-modified"> 842         return ON;                                  /* N0d */</span>
 843     }
 844     bd-&gt;pBiDi-&gt;dirProps[pOpening-&gt;position]=newProp;
 845     bd-&gt;pBiDi-&gt;dirProps[position]=newProp;
 846     /* Update nested N0c pairs that may be affected */
 847     fixN0c(bd, openIdx, pOpening-&gt;position, newProp);
 848     if(stable) {
<span class="line-modified"> 849         pLastIsoRun-&gt;limit=openIdx; /* forget any brackets nested within this pair */</span>
 850         /* remove lower located synonyms if any */
 851         while(pLastIsoRun-&gt;limit&gt;pLastIsoRun-&gt;start &amp;&amp;
 852               bd-&gt;openings[pLastIsoRun-&gt;limit-1].position==pOpening-&gt;position)
 853             pLastIsoRun-&gt;limit--;
 854     } else {
 855         int32_t k;
 856         pOpening-&gt;match=-position;
 857         /* neutralize lower located synonyms if any */
 858         k=openIdx-1;
 859         while(k&gt;=pLastIsoRun-&gt;start &amp;&amp;
 860               bd-&gt;openings[k].position==pOpening-&gt;position)
 861             bd-&gt;openings[k--].match=0;
 862         /* neutralize any unmatched opening between the current pair;
 863            this will also neutralize higher located synonyms if any */
 864         for(k=openIdx+1; k&lt;pLastIsoRun-&gt;limit; k++) {
 865             qOpening=&amp;bd-&gt;openings[k];
 866             if(qOpening-&gt;position&gt;=position)
 867                 break;
 868             if(qOpening-&gt;match&gt;0)
 869                 qOpening-&gt;match=0;
</pre>
<hr />
<pre>
 901             level=bd-&gt;pBiDi-&gt;levels[position];
 902             if(level&amp;UBIDI_LEVEL_OVERRIDE) {    /* X4, X5 */
 903                 uint16_t flag;
 904                 int32_t i;
 905                 newProp=level&amp;1;
 906                 pLastIsoRun-&gt;lastStrong=newProp;
 907                 flag=DIRPROP_FLAG(newProp);
 908                 for(i=pLastIsoRun-&gt;start; i&lt;idx; i++)
 909                     bd-&gt;openings[i].flags|=flag;
 910                 /* matching brackets are not overridden by LRO/RLO */
 911                 bd-&gt;pBiDi-&gt;levels[position]&amp;=~UBIDI_LEVEL_OVERRIDE;
 912             }
 913             /* matching brackets are not overridden by LRO/RLO */
 914             bd-&gt;pBiDi-&gt;levels[bd-&gt;openings[idx].position]&amp;=~UBIDI_LEVEL_OVERRIDE;
 915             return TRUE;
 916         }
 917         /* We get here only if the ON character is not a matching closing
 918            bracket or it is a case of N0d */
 919         /* Now see if it is an opening bracket */
 920         if(c)
<span class="line-modified"> 921             match=u_getBidiPairedBracket(c);    /* get the matching char */</span>
 922         else
 923             match=0;
 924         if(match!=c &amp;&amp;                  /* has a matching char */
 925            ubidi_getPairedBracketType(c)==U_BPT_OPEN) { /* opening bracket */
 926             /* special case: process synonyms
 927                create an opening entry for each synonym */
 928             if(match==0x232A) {     /* RIGHT-POINTING ANGLE BRACKET */
 929                 if(!bracketAddOpening(bd, 0x3009, position))
 930                     return FALSE;
 931             }
 932             else if(match==0x3009) {         /* RIGHT ANGLE BRACKET */
 933                 if(!bracketAddOpening(bd, 0x232A, position))
 934                     return FALSE;
 935             }
 936             if(!bracketAddOpening(bd, match, position))
 937                 return FALSE;
 938         }
 939     }
 940     level=bd-&gt;pBiDi-&gt;levels[position];
 941     if(level&amp;UBIDI_LEVEL_OVERRIDE) {    /* X4, X5 */
 942         newProp=level&amp;1;
 943         if(dirProp!=S &amp;&amp; dirProp!=WS &amp;&amp; dirProp!=ON)
 944             dirProps[position]=newProp;
 945         pLastIsoRun-&gt;lastBase=newProp;
 946         pLastIsoRun-&gt;lastStrong=newProp;
 947         pLastIsoRun-&gt;contextDir=(UBiDiDirection)newProp;
 948         pLastIsoRun-&gt;contextPos=position;
 949     }
 950     else if(dirProp&lt;=R || dirProp==AL) {
<span class="line-modified"> 951         newProp=DIR_FROM_STRONG(dirProp);</span>
 952         pLastIsoRun-&gt;lastBase=dirProp;
 953         pLastIsoRun-&gt;lastStrong=dirProp;
 954         pLastIsoRun-&gt;contextDir=(UBiDiDirection)newProp;
 955         pLastIsoRun-&gt;contextPos=position;
 956     }
 957     else if(dirProp==EN) {
 958         pLastIsoRun-&gt;lastBase=EN;
 959         if(pLastIsoRun-&gt;lastStrong==L) {
 960             newProp=L;                  /* W7 */
 961             if(!bd-&gt;isNumbersSpecial)
 962                 dirProps[position]=ENL;
 963             pLastIsoRun-&gt;contextDir=(UBiDiDirection)L;
 964             pLastIsoRun-&gt;contextPos=position;
 965         }
 966         else {
 967             newProp=R;                  /* N0 */
 968             if(pLastIsoRun-&gt;lastStrong==AL)
 969                 dirProps[position]=AN;  /* W2 */
 970             else
 971                 dirProps[position]=ENR;
</pre>
<hr />
<pre>
1084     if(U_FAILURE(*pErrorCode)) { return UBIDI_LTR; }
1085 
1086     /* determine if the text is mixed-directional or single-directional */
1087     direction=directionFromFlags(pBiDi);
1088 
1089     /* we may not need to resolve any explicit levels */
1090     if((direction!=UBIDI_MIXED)) {
1091         /* not mixed directionality: levels don&#39;t matter - trailingWSStart will be 0 */
1092         return direction;
1093     }
1094     if(pBiDi-&gt;reorderingMode &gt; UBIDI_REORDER_LAST_LOGICAL_TO_VISUAL) {
1095         /* inverse BiDi: mixed, but all characters are at the same embedding level */
1096         /* set all levels to the paragraph level */
1097         int32_t paraIndex, start, limit;
1098         for(paraIndex=0; paraIndex&lt;pBiDi-&gt;paraCount; paraIndex++) {
1099             if(paraIndex==0)
1100                 start=0;
1101             else
1102                 start=pBiDi-&gt;paras[paraIndex-1].limit;
1103             limit=pBiDi-&gt;paras[paraIndex].limit;
<span class="line-modified">1104             level=pBiDi-&gt;paras[paraIndex].level;</span>
1105             for(i=start; i&lt;limit; i++)
1106                 levels[i]=level;
1107         }
1108         return direction;   /* no bracket matching for inverse BiDi */
1109     }
1110     if(!(flags&amp;(MASK_EXPLICIT|MASK_ISO))) {
1111         /* no embeddings, set all levels to the paragraph level */
1112         /* we still have to perform bracket matching */
1113         int32_t paraIndex, start, limit;
1114         BracketData bracketData;
1115         bracketInit(pBiDi, &amp;bracketData);
1116         for(paraIndex=0; paraIndex&lt;pBiDi-&gt;paraCount; paraIndex++) {
1117             if(paraIndex==0)
1118                 start=0;
1119             else
1120                 start=pBiDi-&gt;paras[paraIndex-1].limit;
1121             limit=pBiDi-&gt;paras[paraIndex].limit;
<span class="line-modified">1122             level=pBiDi-&gt;paras[paraIndex].level;</span>
1123             for(i=start; i&lt;limit; i++) {
1124                 levels[i]=level;
1125                 dirProp=dirProps[i];
1126                 if(dirProp==BN)
1127                     continue;
1128                 if(dirProp==B) {
1129                     if((i+1)&lt;length) {
1130                         if(text[i]==CR &amp;&amp; text[i+1]==LF)
1131                             continue;   /* skip CR when followed by LF */
1132                         bracketProcessB(&amp;bracketData, level);
1133                     }
1134                     continue;
1135                 }
1136                 if(!bracketProcessChar(&amp;bracketData, i)) {
1137                     *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
1138                     return UBIDI_LTR;
1139                 }
1140             }
1141         }
1142         return direction;
</pre>
<hr />
<pre>
2030                     }
2031                 }
2032                 if(levels[k]==level+2) {
2033                     levels[k]=level;
2034                     continue;
2035                 }
2036                 levels[k]=level+1;
2037             }
2038             break;
2039 
2040         case 14:                        /* R after L+ON+EN/AN/ON */
2041             level=pLevState-&gt;runLevel+1;
2042             for(k=start0-1; k&gt;=pLevState-&gt;startON; k--) {
2043                 if(levels[k]&gt;level) {
2044                     levels[k]-=2;
2045                 }
2046             }
2047             break;
2048 
2049         default:                        /* we should never get here */
<span class="line-modified">2050             U_ASSERT(FALSE);</span>
<span class="line-removed">2051             break;</span>
2052         }
2053     }
2054     if((addLevel) || (start &lt; start0)) {
2055         level=pLevState-&gt;runLevel + addLevel;
2056         if(start&gt;=pLevState-&gt;runStart) {
2057             for(k=start; k&lt;limit; k++) {
2058                 levels[k]=level;
2059             }
2060         } else {
2061             setLevelsOutsideIsolates(pBiDi, start, limit, level);
2062         }
2063     }
2064 }
2065 
2066 /**
2067  * Returns the directionality of the last strong character at the end of the prologue, if any.
2068  * Requires prologue!=null.
2069  */
2070 static DirProp
2071 lastL_R_AL(UBiDi *pBiDi) {
</pre>
<hr />
<pre>
2234             resProp=impTabProps[oldStateImp][IMPTABPROPS_RES];
2235             switch(actionImp) {
2236             case 1:             /* process current seq1, init new seq1 */
2237                 processPropertySeq(pBiDi, &amp;levState, resProp, start1, i);
2238                 start1=i;
2239                 break;
2240             case 2:             /* init new seq2 */
2241                 start2=i;
2242                 break;
2243             case 3:             /* process seq1, process seq2, init new seq1 */
2244                 processPropertySeq(pBiDi, &amp;levState, resProp, start1, start2);
2245                 processPropertySeq(pBiDi, &amp;levState, DirProp_ON, start2, i);
2246                 start1=i;
2247                 break;
2248             case 4:             /* process seq1, set seq1=seq2, init new seq2 */
2249                 processPropertySeq(pBiDi, &amp;levState, resProp, start1, start2);
2250                 start1=start2;
2251                 start2=i;
2252                 break;
2253             default:            /* we should never get here */
<span class="line-modified">2254                 U_ASSERT(FALSE);</span>
<span class="line-removed">2255                 break;</span>
2256             }
2257         }
2258     }
2259 
2260     /* flush possible pending sequence, e.g. ON */
2261     if(limit==pBiDi-&gt;length &amp;&amp; pBiDi-&gt;epiLength&gt;0) {
2262         DirProp firstStrong=firstL_R_AL_EN_AN(pBiDi);
2263         if(firstStrong!=DirProp_ON) {
2264             eor=firstStrong;
2265         }
2266     }
2267 
2268     /* look for the last char not a BN or LRE/RLE/LRO/RLO/PDF */
2269     for(i=limit-1; i&gt;start&amp;&amp;(DIRPROP_FLAG(dirProps[i])&amp;MASK_BN_EXPLICIT); i--);
2270     dirProp=dirProps[i];
2271     if((dirProp==LRI || dirProp==RLI) &amp;&amp; limit&lt;pBiDi-&gt;length) {
2272         pBiDi-&gt;isolateCount++;
2273         pBiDi-&gt;isolates[pBiDi-&gt;isolateCount].stateImp=stateImp;
2274         pBiDi-&gt;isolates[pBiDi-&gt;isolateCount].state=levState.state;
2275         pBiDi-&gt;isolates[pBiDi-&gt;isolateCount].start1=start1;
</pre>
<hr />
<pre>
2709             break;
2710         case UBIDI_REORDER_INVERSE_NUMBERS_AS_L:
2711             pBiDi-&gt;pImpTabPair=&amp;impTab_INVERSE_NUMBERS_AS_L;
2712             break;
2713         case UBIDI_REORDER_INVERSE_LIKE_DIRECT:
2714             if (pBiDi-&gt;reorderingOptions &amp; UBIDI_OPTION_INSERT_MARKS) {
2715                 pBiDi-&gt;pImpTabPair=&amp;impTab_INVERSE_LIKE_DIRECT_WITH_MARKS;
2716             } else {
2717                 pBiDi-&gt;pImpTabPair=&amp;impTab_INVERSE_LIKE_DIRECT;
2718             }
2719             break;
2720         case UBIDI_REORDER_INVERSE_FOR_NUMBERS_SPECIAL:
2721             if (pBiDi-&gt;reorderingOptions &amp; UBIDI_OPTION_INSERT_MARKS) {
2722                 pBiDi-&gt;pImpTabPair=&amp;impTab_INVERSE_FOR_NUMBERS_SPECIAL_WITH_MARKS;
2723             } else {
2724                 pBiDi-&gt;pImpTabPair=&amp;impTab_INVERSE_FOR_NUMBERS_SPECIAL;
2725             }
2726             break;
2727         default:
2728             /* we should never get here */
<span class="line-modified">2729             U_ASSERT(FALSE);</span>
<span class="line-removed">2730             break;</span>
2731         }
2732         /*
2733          * If there are no external levels specified and there
2734          * are no significant explicit level codes in the text,
2735          * then we can treat the entire paragraph as one run.
2736          * Otherwise, we need to perform the following rules on runs of
2737          * the text with the same embedding levels. (X10)
2738          * &quot;Significant&quot; explicit level codes are ones that actually
2739          * affect non-BN characters.
2740          * Examples for &quot;insignificant&quot; ones are empty embeddings
2741          * LRE-PDF, LRE-RLE-PDF-PDF, etc.
2742          */
2743         if(embeddingLevels==NULL &amp;&amp; pBiDi-&gt;paraCount&lt;=1 &amp;&amp;
2744                                    !(pBiDi-&gt;flags&amp;DIRPROP_FLAG_MULTI_RUNS)) {
2745             resolveImplicitLevels(pBiDi, 0, length,
2746                                     GET_LR_FROM_LEVEL(GET_PARALEVEL(pBiDi, 0)),
2747                                     GET_LR_FROM_LEVEL(GET_PARALEVEL(pBiDi, length-1)));
2748         } else {
2749             /* sor, eor: start and end types of same-level-run */
2750             UBiDiLevel *levels=pBiDi-&gt;levels;
</pre>
<hr />
<pre>
2810         {
2811             *pErrorCode=pBiDi-&gt;insertPoints.errorCode;
2812             return;
2813         }
2814         /* reset the embedding levels for some non-graphic characters (L1), (X9) */
2815         adjustWSLevels(pBiDi);
2816         break;
2817     }
2818     /* add RLM for inverse Bidi with contextual orientation resolving
2819      * to RTL which would not round-trip otherwise
2820      */
2821     if((pBiDi-&gt;defaultParaLevel&gt;0) &amp;&amp;
2822        (pBiDi-&gt;reorderingOptions &amp; UBIDI_OPTION_INSERT_MARKS) &amp;&amp;
2823        ((pBiDi-&gt;reorderingMode==UBIDI_REORDER_INVERSE_LIKE_DIRECT) ||
2824         (pBiDi-&gt;reorderingMode==UBIDI_REORDER_INVERSE_FOR_NUMBERS_SPECIAL))) {
2825         int32_t i, j, start, last;
2826         UBiDiLevel level;
2827         DirProp dirProp;
2828         for(i=0; i&lt;pBiDi-&gt;paraCount; i++) {
2829             last=(pBiDi-&gt;paras[i].limit)-1;
<span class="line-modified">2830             level=pBiDi-&gt;paras[i].level;</span>
2831             if(level==0)
2832                 continue;           /* LTR paragraph */
2833             start= i==0 ? 0 : pBiDi-&gt;paras[i-1].limit;
2834             for(j=last; j&gt;=start; j--) {
2835                 dirProp=dirProps[j];
2836                 if(dirProp==L) {
2837                     if(j&lt;last) {
2838                         while(dirProps[last]==B) {
2839                             last--;
2840                         }
2841                     }
2842                     addPoint(pBiDi, last, RLM_BEFORE);
2843                     break;
2844                 }
2845                 if(DIRPROP_FLAG(dirProp) &amp; MASK_R_AL) {
2846                     break;
2847                 }
2848             }
2849         }
2850     }
</pre>
</td>
<td>
<hr />
<pre>
 607             flags|=DIRPROP_FLAG(LRI);
 608             break;
 609         }
 610         state=previousStateStack[stackLast];
 611         stackLast--;
 612     }
 613     /* When streaming, ignore text after the last paragraph separator */
 614     if(pBiDi-&gt;reorderingOptions &amp; UBIDI_OPTION_STREAMING) {
 615         if(pBiDi-&gt;length&lt;originalLength)
 616             pBiDi-&gt;paraCount--;
 617     } else {
 618         pBiDi-&gt;paras[pBiDi-&gt;paraCount-1].limit=originalLength;
 619         pBiDi-&gt;controlCount=controlCount;
 620     }
 621     /* For inverse bidi, default para direction is RTL if there is
 622        a strong R or AL at either end of the paragraph */
 623     if(isDefaultLevelInverse &amp;&amp; lastStrong==R) {
 624         pBiDi-&gt;paras[pBiDi-&gt;paraCount-1].level=1;
 625     }
 626     if(isDefaultLevel) {
<span class="line-modified"> 627         pBiDi-&gt;paraLevel=static_cast&lt;UBiDiLevel&gt;(pBiDi-&gt;paras[0].level);</span>
 628     }
 629     /* The following is needed to resolve the text direction for default level
 630        paragraphs containing no strong character */
 631     for(i=0; i&lt;pBiDi-&gt;paraCount; i++)
 632         flags|=DIRPROP_FLAG_LR(pBiDi-&gt;paras[i].level);
 633 
 634     if(pBiDi-&gt;orderParagraphsLTR &amp;&amp; (flags&amp;DIRPROP_FLAG(B))) {
 635         flags|=DIRPROP_FLAG(L);
 636     }
 637     pBiDi-&gt;flags=flags;
 638     pBiDi-&gt;lastArabicPos=lastArabicPos;
 639     return TRUE;
 640 }
 641 
 642 /* determine the paragraph level at position index */
 643 U_CFUNC UBiDiLevel
 644 ubidi_getParaLevelAtIndex(const UBiDi *pBiDi, int32_t pindex) {
 645     int32_t i;
 646     for(i=0; i&lt;pBiDi-&gt;paraCount; i++)
 647         if(pindex&lt;pBiDi-&gt;paras[i].limit)
</pre>
<hr />
<pre>
 808 
 809     /* The stable flag is set when brackets are paired and their
 810        level is resolved and cannot be changed by what will be
 811        found later in the source string.
 812        An unstable match can occur only when applying N0c, where
 813        the resolved level depends on the preceding context, and
 814        this context may be affected by text occurring later.
 815        Example: RTL paragraph containing:  abc[(latin) HEBREW]
 816        When the closing parenthesis is encountered, it appears
 817        that N0c1 must be applied since &#39;abc&#39; sets an opposite
 818        direction context and both parentheses receive level 2.
 819        However, when the closing square bracket is processed,
 820        N0b applies because of &#39;HEBREW&#39; being included within the
 821        brackets, thus the square brackets are treated like R and
 822        receive level 1. However, this changes the preceding
 823        context of the opening parenthesis, and it now appears
 824        that N0c2 must be applied to the parentheses rather than
 825        N0c1. */
 826 
 827     if((direction==0 &amp;&amp; pOpening-&gt;flags&amp;FOUND_L) ||
<span class="line-modified"> 828        (direction==1 &amp;&amp; pOpening-&gt;flags&amp;FOUND_R)) {                         /* N0b */</span>
<span class="line-modified"> 829         newProp=static_cast&lt;DirProp&gt;(direction);</span>
 830     }
<span class="line-modified"> 831     else if(pOpening-&gt;flags&amp;(FOUND_L|FOUND_R)) {                            /* N0c */</span>
 832         /* it is stable if there is no containing pair or in
 833            conditions too complicated and not worth checking */
 834         stable=(openIdx==pLastIsoRun-&gt;start);
 835         if(direction!=pOpening-&gt;contextDir)
<span class="line-modified"> 836             newProp= static_cast&lt;DirProp&gt;(pOpening-&gt;contextDir);           /* N0c1 */</span>
 837         else
<span class="line-modified"> 838             newProp= static_cast&lt;DirProp&gt;(direction);                      /* N0c2 */</span>
 839     } else {
 840         /* forget this and any brackets nested within this pair */
<span class="line-modified"> 841         pLastIsoRun-&gt;limit= static_cast&lt;uint16_t&gt;(openIdx);</span>
<span class="line-modified"> 842         return ON;                                                          /* N0d */</span>
 843     }
 844     bd-&gt;pBiDi-&gt;dirProps[pOpening-&gt;position]=newProp;
 845     bd-&gt;pBiDi-&gt;dirProps[position]=newProp;
 846     /* Update nested N0c pairs that may be affected */
 847     fixN0c(bd, openIdx, pOpening-&gt;position, newProp);
 848     if(stable) {
<span class="line-modified"> 849         pLastIsoRun-&gt;limit= static_cast&lt;uint16_t&gt;(openIdx); /* forget any brackets nested within this pair */</span>
 850         /* remove lower located synonyms if any */
 851         while(pLastIsoRun-&gt;limit&gt;pLastIsoRun-&gt;start &amp;&amp;
 852               bd-&gt;openings[pLastIsoRun-&gt;limit-1].position==pOpening-&gt;position)
 853             pLastIsoRun-&gt;limit--;
 854     } else {
 855         int32_t k;
 856         pOpening-&gt;match=-position;
 857         /* neutralize lower located synonyms if any */
 858         k=openIdx-1;
 859         while(k&gt;=pLastIsoRun-&gt;start &amp;&amp;
 860               bd-&gt;openings[k].position==pOpening-&gt;position)
 861             bd-&gt;openings[k--].match=0;
 862         /* neutralize any unmatched opening between the current pair;
 863            this will also neutralize higher located synonyms if any */
 864         for(k=openIdx+1; k&lt;pLastIsoRun-&gt;limit; k++) {
 865             qOpening=&amp;bd-&gt;openings[k];
 866             if(qOpening-&gt;position&gt;=position)
 867                 break;
 868             if(qOpening-&gt;match&gt;0)
 869                 qOpening-&gt;match=0;
</pre>
<hr />
<pre>
 901             level=bd-&gt;pBiDi-&gt;levels[position];
 902             if(level&amp;UBIDI_LEVEL_OVERRIDE) {    /* X4, X5 */
 903                 uint16_t flag;
 904                 int32_t i;
 905                 newProp=level&amp;1;
 906                 pLastIsoRun-&gt;lastStrong=newProp;
 907                 flag=DIRPROP_FLAG(newProp);
 908                 for(i=pLastIsoRun-&gt;start; i&lt;idx; i++)
 909                     bd-&gt;openings[i].flags|=flag;
 910                 /* matching brackets are not overridden by LRO/RLO */
 911                 bd-&gt;pBiDi-&gt;levels[position]&amp;=~UBIDI_LEVEL_OVERRIDE;
 912             }
 913             /* matching brackets are not overridden by LRO/RLO */
 914             bd-&gt;pBiDi-&gt;levels[bd-&gt;openings[idx].position]&amp;=~UBIDI_LEVEL_OVERRIDE;
 915             return TRUE;
 916         }
 917         /* We get here only if the ON character is not a matching closing
 918            bracket or it is a case of N0d */
 919         /* Now see if it is an opening bracket */
 920         if(c)
<span class="line-modified"> 921             match= static_cast&lt;UChar&gt;(u_getBidiPairedBracket(c));    /* get the matching char */</span>
 922         else
 923             match=0;
 924         if(match!=c &amp;&amp;                  /* has a matching char */
 925            ubidi_getPairedBracketType(c)==U_BPT_OPEN) { /* opening bracket */
 926             /* special case: process synonyms
 927                create an opening entry for each synonym */
 928             if(match==0x232A) {     /* RIGHT-POINTING ANGLE BRACKET */
 929                 if(!bracketAddOpening(bd, 0x3009, position))
 930                     return FALSE;
 931             }
 932             else if(match==0x3009) {         /* RIGHT ANGLE BRACKET */
 933                 if(!bracketAddOpening(bd, 0x232A, position))
 934                     return FALSE;
 935             }
 936             if(!bracketAddOpening(bd, match, position))
 937                 return FALSE;
 938         }
 939     }
 940     level=bd-&gt;pBiDi-&gt;levels[position];
 941     if(level&amp;UBIDI_LEVEL_OVERRIDE) {    /* X4, X5 */
 942         newProp=level&amp;1;
 943         if(dirProp!=S &amp;&amp; dirProp!=WS &amp;&amp; dirProp!=ON)
 944             dirProps[position]=newProp;
 945         pLastIsoRun-&gt;lastBase=newProp;
 946         pLastIsoRun-&gt;lastStrong=newProp;
 947         pLastIsoRun-&gt;contextDir=(UBiDiDirection)newProp;
 948         pLastIsoRun-&gt;contextPos=position;
 949     }
 950     else if(dirProp&lt;=R || dirProp==AL) {
<span class="line-modified"> 951         newProp= static_cast&lt;DirProp&gt;(DIR_FROM_STRONG(dirProp));</span>
 952         pLastIsoRun-&gt;lastBase=dirProp;
 953         pLastIsoRun-&gt;lastStrong=dirProp;
 954         pLastIsoRun-&gt;contextDir=(UBiDiDirection)newProp;
 955         pLastIsoRun-&gt;contextPos=position;
 956     }
 957     else if(dirProp==EN) {
 958         pLastIsoRun-&gt;lastBase=EN;
 959         if(pLastIsoRun-&gt;lastStrong==L) {
 960             newProp=L;                  /* W7 */
 961             if(!bd-&gt;isNumbersSpecial)
 962                 dirProps[position]=ENL;
 963             pLastIsoRun-&gt;contextDir=(UBiDiDirection)L;
 964             pLastIsoRun-&gt;contextPos=position;
 965         }
 966         else {
 967             newProp=R;                  /* N0 */
 968             if(pLastIsoRun-&gt;lastStrong==AL)
 969                 dirProps[position]=AN;  /* W2 */
 970             else
 971                 dirProps[position]=ENR;
</pre>
<hr />
<pre>
1084     if(U_FAILURE(*pErrorCode)) { return UBIDI_LTR; }
1085 
1086     /* determine if the text is mixed-directional or single-directional */
1087     direction=directionFromFlags(pBiDi);
1088 
1089     /* we may not need to resolve any explicit levels */
1090     if((direction!=UBIDI_MIXED)) {
1091         /* not mixed directionality: levels don&#39;t matter - trailingWSStart will be 0 */
1092         return direction;
1093     }
1094     if(pBiDi-&gt;reorderingMode &gt; UBIDI_REORDER_LAST_LOGICAL_TO_VISUAL) {
1095         /* inverse BiDi: mixed, but all characters are at the same embedding level */
1096         /* set all levels to the paragraph level */
1097         int32_t paraIndex, start, limit;
1098         for(paraIndex=0; paraIndex&lt;pBiDi-&gt;paraCount; paraIndex++) {
1099             if(paraIndex==0)
1100                 start=0;
1101             else
1102                 start=pBiDi-&gt;paras[paraIndex-1].limit;
1103             limit=pBiDi-&gt;paras[paraIndex].limit;
<span class="line-modified">1104             level= static_cast&lt;UBiDiLevel&gt;(pBiDi-&gt;paras[paraIndex].level);</span>
1105             for(i=start; i&lt;limit; i++)
1106                 levels[i]=level;
1107         }
1108         return direction;   /* no bracket matching for inverse BiDi */
1109     }
1110     if(!(flags&amp;(MASK_EXPLICIT|MASK_ISO))) {
1111         /* no embeddings, set all levels to the paragraph level */
1112         /* we still have to perform bracket matching */
1113         int32_t paraIndex, start, limit;
1114         BracketData bracketData;
1115         bracketInit(pBiDi, &amp;bracketData);
1116         for(paraIndex=0; paraIndex&lt;pBiDi-&gt;paraCount; paraIndex++) {
1117             if(paraIndex==0)
1118                 start=0;
1119             else
1120                 start=pBiDi-&gt;paras[paraIndex-1].limit;
1121             limit=pBiDi-&gt;paras[paraIndex].limit;
<span class="line-modified">1122             level= static_cast&lt;UBiDiLevel&gt;(pBiDi-&gt;paras[paraIndex].level);</span>
1123             for(i=start; i&lt;limit; i++) {
1124                 levels[i]=level;
1125                 dirProp=dirProps[i];
1126                 if(dirProp==BN)
1127                     continue;
1128                 if(dirProp==B) {
1129                     if((i+1)&lt;length) {
1130                         if(text[i]==CR &amp;&amp; text[i+1]==LF)
1131                             continue;   /* skip CR when followed by LF */
1132                         bracketProcessB(&amp;bracketData, level);
1133                     }
1134                     continue;
1135                 }
1136                 if(!bracketProcessChar(&amp;bracketData, i)) {
1137                     *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
1138                     return UBIDI_LTR;
1139                 }
1140             }
1141         }
1142         return direction;
</pre>
<hr />
<pre>
2030                     }
2031                 }
2032                 if(levels[k]==level+2) {
2033                     levels[k]=level;
2034                     continue;
2035                 }
2036                 levels[k]=level+1;
2037             }
2038             break;
2039 
2040         case 14:                        /* R after L+ON+EN/AN/ON */
2041             level=pLevState-&gt;runLevel+1;
2042             for(k=start0-1; k&gt;=pLevState-&gt;startON; k--) {
2043                 if(levels[k]&gt;level) {
2044                     levels[k]-=2;
2045                 }
2046             }
2047             break;
2048 
2049         default:                        /* we should never get here */
<span class="line-modified">2050             UPRV_UNREACHABLE;</span>

2051         }
2052     }
2053     if((addLevel) || (start &lt; start0)) {
2054         level=pLevState-&gt;runLevel + addLevel;
2055         if(start&gt;=pLevState-&gt;runStart) {
2056             for(k=start; k&lt;limit; k++) {
2057                 levels[k]=level;
2058             }
2059         } else {
2060             setLevelsOutsideIsolates(pBiDi, start, limit, level);
2061         }
2062     }
2063 }
2064 
2065 /**
2066  * Returns the directionality of the last strong character at the end of the prologue, if any.
2067  * Requires prologue!=null.
2068  */
2069 static DirProp
2070 lastL_R_AL(UBiDi *pBiDi) {
</pre>
<hr />
<pre>
2233             resProp=impTabProps[oldStateImp][IMPTABPROPS_RES];
2234             switch(actionImp) {
2235             case 1:             /* process current seq1, init new seq1 */
2236                 processPropertySeq(pBiDi, &amp;levState, resProp, start1, i);
2237                 start1=i;
2238                 break;
2239             case 2:             /* init new seq2 */
2240                 start2=i;
2241                 break;
2242             case 3:             /* process seq1, process seq2, init new seq1 */
2243                 processPropertySeq(pBiDi, &amp;levState, resProp, start1, start2);
2244                 processPropertySeq(pBiDi, &amp;levState, DirProp_ON, start2, i);
2245                 start1=i;
2246                 break;
2247             case 4:             /* process seq1, set seq1=seq2, init new seq2 */
2248                 processPropertySeq(pBiDi, &amp;levState, resProp, start1, start2);
2249                 start1=start2;
2250                 start2=i;
2251                 break;
2252             default:            /* we should never get here */
<span class="line-modified">2253                 UPRV_UNREACHABLE;</span>

2254             }
2255         }
2256     }
2257 
2258     /* flush possible pending sequence, e.g. ON */
2259     if(limit==pBiDi-&gt;length &amp;&amp; pBiDi-&gt;epiLength&gt;0) {
2260         DirProp firstStrong=firstL_R_AL_EN_AN(pBiDi);
2261         if(firstStrong!=DirProp_ON) {
2262             eor=firstStrong;
2263         }
2264     }
2265 
2266     /* look for the last char not a BN or LRE/RLE/LRO/RLO/PDF */
2267     for(i=limit-1; i&gt;start&amp;&amp;(DIRPROP_FLAG(dirProps[i])&amp;MASK_BN_EXPLICIT); i--);
2268     dirProp=dirProps[i];
2269     if((dirProp==LRI || dirProp==RLI) &amp;&amp; limit&lt;pBiDi-&gt;length) {
2270         pBiDi-&gt;isolateCount++;
2271         pBiDi-&gt;isolates[pBiDi-&gt;isolateCount].stateImp=stateImp;
2272         pBiDi-&gt;isolates[pBiDi-&gt;isolateCount].state=levState.state;
2273         pBiDi-&gt;isolates[pBiDi-&gt;isolateCount].start1=start1;
</pre>
<hr />
<pre>
2707             break;
2708         case UBIDI_REORDER_INVERSE_NUMBERS_AS_L:
2709             pBiDi-&gt;pImpTabPair=&amp;impTab_INVERSE_NUMBERS_AS_L;
2710             break;
2711         case UBIDI_REORDER_INVERSE_LIKE_DIRECT:
2712             if (pBiDi-&gt;reorderingOptions &amp; UBIDI_OPTION_INSERT_MARKS) {
2713                 pBiDi-&gt;pImpTabPair=&amp;impTab_INVERSE_LIKE_DIRECT_WITH_MARKS;
2714             } else {
2715                 pBiDi-&gt;pImpTabPair=&amp;impTab_INVERSE_LIKE_DIRECT;
2716             }
2717             break;
2718         case UBIDI_REORDER_INVERSE_FOR_NUMBERS_SPECIAL:
2719             if (pBiDi-&gt;reorderingOptions &amp; UBIDI_OPTION_INSERT_MARKS) {
2720                 pBiDi-&gt;pImpTabPair=&amp;impTab_INVERSE_FOR_NUMBERS_SPECIAL_WITH_MARKS;
2721             } else {
2722                 pBiDi-&gt;pImpTabPair=&amp;impTab_INVERSE_FOR_NUMBERS_SPECIAL;
2723             }
2724             break;
2725         default:
2726             /* we should never get here */
<span class="line-modified">2727             UPRV_UNREACHABLE;</span>

2728         }
2729         /*
2730          * If there are no external levels specified and there
2731          * are no significant explicit level codes in the text,
2732          * then we can treat the entire paragraph as one run.
2733          * Otherwise, we need to perform the following rules on runs of
2734          * the text with the same embedding levels. (X10)
2735          * &quot;Significant&quot; explicit level codes are ones that actually
2736          * affect non-BN characters.
2737          * Examples for &quot;insignificant&quot; ones are empty embeddings
2738          * LRE-PDF, LRE-RLE-PDF-PDF, etc.
2739          */
2740         if(embeddingLevels==NULL &amp;&amp; pBiDi-&gt;paraCount&lt;=1 &amp;&amp;
2741                                    !(pBiDi-&gt;flags&amp;DIRPROP_FLAG_MULTI_RUNS)) {
2742             resolveImplicitLevels(pBiDi, 0, length,
2743                                     GET_LR_FROM_LEVEL(GET_PARALEVEL(pBiDi, 0)),
2744                                     GET_LR_FROM_LEVEL(GET_PARALEVEL(pBiDi, length-1)));
2745         } else {
2746             /* sor, eor: start and end types of same-level-run */
2747             UBiDiLevel *levels=pBiDi-&gt;levels;
</pre>
<hr />
<pre>
2807         {
2808             *pErrorCode=pBiDi-&gt;insertPoints.errorCode;
2809             return;
2810         }
2811         /* reset the embedding levels for some non-graphic characters (L1), (X9) */
2812         adjustWSLevels(pBiDi);
2813         break;
2814     }
2815     /* add RLM for inverse Bidi with contextual orientation resolving
2816      * to RTL which would not round-trip otherwise
2817      */
2818     if((pBiDi-&gt;defaultParaLevel&gt;0) &amp;&amp;
2819        (pBiDi-&gt;reorderingOptions &amp; UBIDI_OPTION_INSERT_MARKS) &amp;&amp;
2820        ((pBiDi-&gt;reorderingMode==UBIDI_REORDER_INVERSE_LIKE_DIRECT) ||
2821         (pBiDi-&gt;reorderingMode==UBIDI_REORDER_INVERSE_FOR_NUMBERS_SPECIAL))) {
2822         int32_t i, j, start, last;
2823         UBiDiLevel level;
2824         DirProp dirProp;
2825         for(i=0; i&lt;pBiDi-&gt;paraCount; i++) {
2826             last=(pBiDi-&gt;paras[i].limit)-1;
<span class="line-modified">2827             level= static_cast&lt;UBiDiLevel&gt;(pBiDi-&gt;paras[i].level);</span>
2828             if(level==0)
2829                 continue;           /* LTR paragraph */
2830             start= i==0 ? 0 : pBiDi-&gt;paras[i-1].limit;
2831             for(j=last; j&gt;=start; j--) {
2832                 dirProp=dirProps[j];
2833                 if(dirProp==L) {
2834                     if(j&lt;last) {
2835                         while(dirProps[last]==B) {
2836                             last--;
2837                         }
2838                     }
2839                     addPoint(pBiDi, last, RLM_BEFORE);
2840                     break;
2841                 }
2842                 if(DIRPROP_FLAG(dirProp) &amp; MASK_R_AL) {
2843                     break;
2844                 }
2845             }
2846         }
2847     }
</pre>
</td>
</tr>
</table>
<center><a href="uassert.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ubidi_props_data.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>