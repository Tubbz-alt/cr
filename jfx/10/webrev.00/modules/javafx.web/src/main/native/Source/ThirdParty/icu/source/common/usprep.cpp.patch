diff a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/usprep.cpp b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/usprep.cpp
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/usprep.cpp
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/usprep.cpp
@@ -45,11 +45,14 @@
 Static cache for already opened StringPrep profiles
 */
 static UHashtable *SHARED_DATA_HASHTABLE = NULL;
 static icu::UInitOnce gSharedDataInitOnce;
 
-static UMutex usprepMutex = U_MUTEX_INITIALIZER;
+static UMutex *usprepMutex() {
+    static UMutex m = U_MUTEX_INITIALIZER;
+    return &m;
+}
 
 /* format version of spp file */
 //static uint8_t formatVersion[4]={ 0, 0, 0, 0 };
 
 /* the Unicode version of the sprep data */
@@ -110,11 +113,13 @@
 hashEntry(const UHashTok parm) {
     UStringPrepKey *b = (UStringPrepKey *)parm.pointer;
     UHashTok namekey, pathkey;
     namekey.pointer = b->name;
     pathkey.pointer = b->path;
-    return uhash_hashChars(namekey)+37*uhash_hashChars(pathkey);
+    uint32_t unsignedHash = static_cast<uint32_t>(uhash_hashChars(namekey)) +
+            37u * static_cast<uint32_t>(uhash_hashChars(pathkey));
+    return static_cast<int32_t>(unsignedHash);
 }
 
 /* compares two entries */
 static UBool U_CALLCONV
 compareEntries(const UHashTok p1, const UHashTok p2) {
@@ -144,13 +149,13 @@
 
     /*
      * if shared data hasn't even been lazy evaluated yet
      * return 0
      */
-    umtx_lock(&usprepMutex);
+    umtx_lock(usprepMutex());
     if (SHARED_DATA_HASHTABLE == NULL) {
-        umtx_unlock(&usprepMutex);
+        umtx_unlock(usprepMutex());
         return 0;
     }
 
     /*creates an enumeration to iterate through every element in the table */
     while ((e = uhash_nextElement(SHARED_DATA_HASHTABLE, &pos)) != NULL)
@@ -177,11 +182,11 @@
             uprv_free(profile);
             uprv_free(key);
         }
 
     }
-    umtx_unlock(&usprepMutex);
+    umtx_unlock(usprepMutex());
 
     return deletedNum;
 }
 
 /* Works just like ucnv_flushCache()
@@ -255,20 +260,20 @@
         udata_close(dataMemory);
         return FALSE;
     }
 
     /* in the mutex block, set the data for this process */
-    umtx_lock(&usprepMutex);
+    umtx_lock(usprepMutex());
     if(profile->sprepData==NULL) {
         profile->sprepData=dataMemory;
         dataMemory=NULL;
         uprv_memcpy(&profile->indexes, p, sizeof(profile->indexes));
         uprv_memcpy(&profile->sprepTrie, &_sprepTrie, sizeof(UTrie));
     } else {
         p=(const int32_t *)udata_getMemory(profile->sprepData);
     }
-    umtx_unlock(&usprepMutex);
+    umtx_unlock(usprepMutex());
     /* initialize some variables */
     profile->mappingData=(uint16_t *)((uint8_t *)(p+_SPREP_INDEX_TOP)+profile->indexes[_SPREP_INDEX_TRIE_SIZE]);
 
     u_getUnicodeVersion(normUnicodeVersion);
     normUniVer = (normUnicodeVersion[0] << 24) + (normUnicodeVersion[1] << 16) +
@@ -321,16 +326,16 @@
      */
     stackKey.name = (char*) name;
     stackKey.path = (char*) path;
 
     /* fetch the data from the cache */
-    umtx_lock(&usprepMutex);
+    umtx_lock(usprepMutex());
     profile = (UStringPrepProfile*) (uhash_get(SHARED_DATA_HASHTABLE,&stackKey));
     if(profile != NULL) {
         profile->refCount++;
     }
-    umtx_unlock(&usprepMutex);
+    umtx_unlock(usprepMutex());
 
     if(profile == NULL) {
         /* else load the data and put the data in the cache */
         LocalMemory<UStringPrepProfile> newProfile;
         if(newProfile.allocateInsteadAndReset() == NULL) {
@@ -349,20 +354,20 @@
 
         LocalMemory<UStringPrepKey> key;
         LocalMemory<char> keyName;
         LocalMemory<char> keyPath;
         if( key.allocateInsteadAndReset() == NULL ||
-            keyName.allocateInsteadAndCopy(uprv_strlen(name)+1) == NULL ||
+            keyName.allocateInsteadAndCopy(static_cast<int32_t>(uprv_strlen(name)+1)) == NULL ||
             (path != NULL &&
-             keyPath.allocateInsteadAndCopy(uprv_strlen(path)+1) == NULL)
+             keyPath.allocateInsteadAndCopy(static_cast<int32_t>(uprv_strlen(path)+1)) == NULL)
          ) {
             *status = U_MEMORY_ALLOCATION_ERROR;
             usprep_unload(newProfile.getAlias());
             return NULL;
         }
 
-        umtx_lock(&usprepMutex);
+        umtx_lock(usprepMutex());
         // If another thread already inserted the same key/value, refcount and cleanup our thread data
         profile = (UStringPrepProfile*) (uhash_get(SHARED_DATA_HASHTABLE,&stackKey));
         if(profile != NULL) {
             profile->refCount++;
             usprep_unload(newProfile.getAlias());
@@ -379,11 +384,11 @@
 
             /* add the data object to the cache */
             profile->refCount = 1;
             uhash_put(SHARED_DATA_HASHTABLE, key.orphan(), profile, status);
         }
-        umtx_unlock(&usprepMutex);
+        umtx_unlock(usprepMutex());
     }
 
     return profile;
 }
 
@@ -418,16 +423,16 @@
 usprep_close(UStringPrepProfile* profile){
     if(profile==NULL){
         return;
     }
 
-    umtx_lock(&usprepMutex);
+    umtx_lock(usprepMutex());
     /* decrement the ref count*/
     if(profile->refCount > 0){
         profile->refCount--;
     }
-    umtx_unlock(&usprepMutex);
+    umtx_unlock(usprepMutex());
 
 }
 
 U_CFUNC void
 uprv_syntaxError(const UChar* rules,
@@ -724,11 +729,11 @@
 
         if( type == USPREP_PROHIBITED ||
             ((result < _SPREP_TYPE_THRESHOLD) && (result & 0x01) /* first bit says it the code point is prohibited*/)
            ){
             *status = U_STRINGPREP_PROHIBITED_ERROR;
-            uprv_syntaxError(b1, b2Index-U16_LENGTH(ch), b2Len, parseError);
+            uprv_syntaxError(b2, b2Index-U16_LENGTH(ch), b2Len, parseError);
             return 0;
         }
 
         if(profile->checkBiDi) {
             direction = ubidi_getClass(ch);
