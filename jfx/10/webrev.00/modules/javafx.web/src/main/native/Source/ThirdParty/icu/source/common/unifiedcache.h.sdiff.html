<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unifiedcache.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="unifiedcache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uniset.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unifiedcache.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
120        return buffer;
121    }
122 
123    /**
124     * Two objects are equal if they are of the same type.
125     */
126    virtual UBool operator == (const CacheKeyBase &amp;other) const {
127        return typeid(*this) == typeid(other);
128    }
129 };
130 
131 /**
132  * Cache key based on locale.
133  * A key of type LocaleCacheKey&lt;T&gt; maps to a value of type T.
134  */
135 template&lt;typename T&gt;
136 class LocaleCacheKey : public CacheKey&lt;T&gt; {
137  protected:
138    Locale   fLoc;
139  public:
<span class="line-modified">140    LocaleCacheKey(const Locale &amp;loc) : fLoc(loc) {};</span>
141    LocaleCacheKey(const LocaleCacheKey&lt;T&gt; &amp;other)
142            : CacheKey&lt;T&gt;(other), fLoc(other.fLoc) { }
143    virtual ~LocaleCacheKey() { }
144    virtual int32_t hashCode() const {
145        return (int32_t)(37u * (uint32_t)CacheKey&lt;T&gt;::hashCode() + (uint32_t)fLoc.hashCode());
146    }
147    virtual UBool operator == (const CacheKeyBase &amp;other) const {
148        // reflexive
149        if (this == &amp;other) {
150            return TRUE;
151        }
152        if (!CacheKey&lt;T&gt;::operator == (other)) {
153            return FALSE;
154        }
155        // We know this and other are of same class because operator== on
156        // CacheKey returned true.
157        const LocaleCacheKey&lt;T&gt; *fOther =
158                static_cast&lt;const LocaleCacheKey&lt;T&gt; *&gt;(&amp;other);
159        return fLoc == fOther-&gt;fLoc;
160    }
</pre>
</td>
<td>
<hr />
<pre>
120        return buffer;
121    }
122 
123    /**
124     * Two objects are equal if they are of the same type.
125     */
126    virtual UBool operator == (const CacheKeyBase &amp;other) const {
127        return typeid(*this) == typeid(other);
128    }
129 };
130 
131 /**
132  * Cache key based on locale.
133  * A key of type LocaleCacheKey&lt;T&gt; maps to a value of type T.
134  */
135 template&lt;typename T&gt;
136 class LocaleCacheKey : public CacheKey&lt;T&gt; {
137  protected:
138    Locale   fLoc;
139  public:
<span class="line-modified">140    LocaleCacheKey(const Locale &amp;loc) : fLoc(loc) {}</span>
141    LocaleCacheKey(const LocaleCacheKey&lt;T&gt; &amp;other)
142            : CacheKey&lt;T&gt;(other), fLoc(other.fLoc) { }
143    virtual ~LocaleCacheKey() { }
144    virtual int32_t hashCode() const {
145        return (int32_t)(37u * (uint32_t)CacheKey&lt;T&gt;::hashCode() + (uint32_t)fLoc.hashCode());
146    }
147    virtual UBool operator == (const CacheKeyBase &amp;other) const {
148        // reflexive
149        if (this == &amp;other) {
150            return TRUE;
151        }
152        if (!CacheKey&lt;T&gt;::operator == (other)) {
153            return FALSE;
154        }
155        // We know this and other are of same class because operator== on
156        // CacheKey returned true.
157        const LocaleCacheKey&lt;T&gt; *fOther =
158                static_cast&lt;const LocaleCacheKey&lt;T&gt; *&gt;(&amp;other);
159        return fLoc == fOther-&gt;fLoc;
160    }
</pre>
</td>
</tr>
</table>
<center><a href="unifiedcache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="uniset.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>