<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/numparse_impl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="numparse_currency.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="numparse_impl.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/numparse_impl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 70,11 ***</span>
      parser-&gt;addMatcher(parser-&gt;fLocalMatchers.nan = {symbols});
      parser-&gt;addMatcher(parser-&gt;fLocalMatchers.infinity = {symbols});
      parser-&gt;addMatcher(parser-&gt;fLocalMatchers.padding = {u&quot;@&quot;});
      parser-&gt;addMatcher(parser-&gt;fLocalMatchers.scientific = {symbols, grouper});
      parser-&gt;addMatcher(parser-&gt;fLocalMatchers.currency = {currencySymbols, symbols, parseFlags, status});
<span class="line-modified">! //    parser.addMatcher(new RequireNumberMatcher());</span>
  
      parser-&gt;freeze();
      return parser.orphan();
  }
  
<span class="line-new-header">--- 70,11 ---</span>
      parser-&gt;addMatcher(parser-&gt;fLocalMatchers.nan = {symbols});
      parser-&gt;addMatcher(parser-&gt;fLocalMatchers.infinity = {symbols});
      parser-&gt;addMatcher(parser-&gt;fLocalMatchers.padding = {u&quot;@&quot;});
      parser-&gt;addMatcher(parser-&gt;fLocalMatchers.scientific = {symbols, grouper});
      parser-&gt;addMatcher(parser-&gt;fLocalMatchers.currency = {currencySymbols, symbols, parseFlags, status});
<span class="line-modified">!     parser-&gt;addMatcher(parser-&gt;fLocalValidators.number = {});</span>
  
      parser-&gt;freeze();
      return parser.orphan();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,14 ***</span>
      /// PERCENT ///
      ///////////////
  
      // ICU-TC meeting, April 11, 2018: accept percent/permille only if it is in the pattern,
      // and to maintain regressive behavior, divide by 100 even if no percent sign is present.
<span class="line-modified">!     if (affixProvider-&gt;containsSymbolType(AffixPatternType::TYPE_PERCENT, status)) {</span>
          parser-&gt;addMatcher(parser-&gt;fLocalMatchers.percent = {symbols});
      }
<span class="line-modified">!     if (affixProvider-&gt;containsSymbolType(AffixPatternType::TYPE_PERMILLE, status)) {</span>
          parser-&gt;addMatcher(parser-&gt;fLocalMatchers.permille = {symbols});
      }
  
      ///////////////////////////////
      /// OTHER STANDARD MATCHERS ///
<span class="line-new-header">--- 157,14 ---</span>
      /// PERCENT ///
      ///////////////
  
      // ICU-TC meeting, April 11, 2018: accept percent/permille only if it is in the pattern,
      // and to maintain regressive behavior, divide by 100 even if no percent sign is present.
<span class="line-modified">!     if (!isStrict &amp;&amp; affixProvider-&gt;containsSymbolType(AffixPatternType::TYPE_PERCENT, status)) {</span>
          parser-&gt;addMatcher(parser-&gt;fLocalMatchers.percent = {symbols});
      }
<span class="line-modified">!     if (!isStrict &amp;&amp; affixProvider-&gt;containsSymbolType(AffixPatternType::TYPE_PERMILLE, status)) {</span>
          parser-&gt;addMatcher(parser-&gt;fLocalMatchers.permille = {symbols});
      }
  
      ///////////////////////////////
      /// OTHER STANDARD MATCHERS ///
</pre>
<hr />
<pre>
<span class="line-old-header">*** 250,58 ***</span>
      U_ASSERT(fFrozen);
      // TODO: Check start &gt;= 0 and start &lt; input.length()
      StringSegment segment(input, 0 != (fParseFlags &amp; PARSE_FLAG_IGNORE_CASE));
      segment.adjustOffset(start);
      if (greedy) {
<span class="line-modified">!         parseGreedyRecursive(segment, result, status);</span>
      } else {
<span class="line-modified">!         parseLongestRecursive(segment, result, status);</span>
      }
      for (int32_t i = 0; i &lt; fNumMatchers; i++) {
          fMatchers[i]-&gt;postProcess(result);
      }
      result.postProcess();
  }
  
<span class="line-modified">! void NumberParserImpl::parseGreedyRecursive(StringSegment&amp; segment, ParsedNumber&amp; result,</span>
                                              UErrorCode&amp; status) const {
<span class="line-modified">!     // Base Case</span>
<span class="line-modified">!     if (segment.length() == 0) {</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     int initialOffset = segment.getOffset();</span>
<span class="line-removed">-     for (int32_t i = 0; i &lt; fNumMatchers; i++) {</span>
          const NumberParseMatcher* matcher = fMatchers[i];
          if (!matcher-&gt;smokeTest(segment)) {
              continue;
          }
          matcher-&gt;match(segment, result, status);
          if (U_FAILURE(status)) {
              return;
          }
          if (segment.getOffset() != initialOffset) {
<span class="line-modified">!             // In a greedy parse, recurse on only the first match.</span>
<span class="line-modified">!             parseGreedyRecursive(segment, result, status);</span>
<span class="line-modified">!             // The following line resets the offset so that the StringSegment says the same across</span>
<span class="line-modified">!             // the function</span>
<span class="line-modified">!             // call boundary. Since we recurse only once, this line is not strictly necessary.</span>
<span class="line-modified">!             segment.setOffset(initialOffset);</span>
<span class="line-modified">!             return;</span>
          }
      }
  
      // NOTE: If we get here, the greedy parse completed without consuming the entire string.
  }
  
                                               UErrorCode&amp; status) const {
      // Base Case
      if (segment.length() == 0) {
          return;
      }
      // TODO: Give a nice way for the matcher to reset the ParsedNumber?
      ParsedNumber initial(result);
      ParsedNumber candidate;
  
      int initialOffset = segment.getOffset();
<span class="line-new-header">--- 250,71 ---</span>
      U_ASSERT(fFrozen);
      // TODO: Check start &gt;= 0 and start &lt; input.length()
      StringSegment segment(input, 0 != (fParseFlags &amp; PARSE_FLAG_IGNORE_CASE));
      segment.adjustOffset(start);
      if (greedy) {
<span class="line-modified">!         parseGreedy(segment, result, status);</span>
<span class="line-added">+     } else if (0 != (fParseFlags &amp; PARSE_FLAG_ALLOW_INFINITE_RECURSION)) {</span>
<span class="line-added">+         // Start at 1 so that recursionLevels never gets to 0</span>
<span class="line-added">+         parseLongestRecursive(segment, result, 1, status);</span>
      } else {
<span class="line-modified">!         // Arbitrary recursion safety limit: 100 levels.</span>
<span class="line-added">+         parseLongestRecursive(segment, result, -100, status);</span>
      }
      for (int32_t i = 0; i &lt; fNumMatchers; i++) {
          fMatchers[i]-&gt;postProcess(result);
      }
      result.postProcess();
  }
  
<span class="line-modified">! void NumberParserImpl::parseGreedy(StringSegment&amp; segment, ParsedNumber&amp; result,</span>
                                              UErrorCode&amp; status) const {
<span class="line-modified">!     // Note: this method is not recursive in order to avoid stack overflow.</span>
<span class="line-modified">!     for (int i = 0; i &lt;fNumMatchers;) {</span>
<span class="line-modified">!         // Base Case</span>
<span class="line-modified">!         if (segment.length() == 0) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
          const NumberParseMatcher* matcher = fMatchers[i];
          if (!matcher-&gt;smokeTest(segment)) {
<span class="line-added">+             // Matcher failed smoke test: try the next one</span>
<span class="line-added">+             i++;</span>
              continue;
          }
<span class="line-added">+         int32_t initialOffset = segment.getOffset();</span>
          matcher-&gt;match(segment, result, status);
          if (U_FAILURE(status)) {
              return;
          }
          if (segment.getOffset() != initialOffset) {
<span class="line-modified">!             // Greedy heuristic: accept the match and loop back</span>
<span class="line-modified">!             i = 0;</span>
<span class="line-modified">!             continue;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             // Matcher did not match: try the next one</span>
<span class="line-modified">!             i++;</span>
<span class="line-modified">!             continue;</span>
          }
<span class="line-added">+         UPRV_UNREACHABLE;</span>
      }
  
      // NOTE: If we get here, the greedy parse completed without consuming the entire string.
  }
  
<span class="line-added">+                                              int32_t recursionLevels,</span>
                                               UErrorCode&amp; status) const {
      // Base Case
      if (segment.length() == 0) {
          return;
      }
<span class="line-added">+     // Safety against stack overflow</span>
<span class="line-added">+     if (recursionLevels == 0) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // TODO: Give a nice way for the matcher to reset the ParsedNumber?
      ParsedNumber initial(result);
      ParsedNumber candidate;
  
      int initialOffset = segment.getOffset();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 324,11 ***</span>
                  return;
              }
  
              // If the entire segment was consumed, recurse.
              if (segment.getOffset() - initialOffset == charsToConsume) {
<span class="line-modified">!                 parseLongestRecursive(segment, candidate, status);</span>
                  if (U_FAILURE(status)) {
                      return;
                  }
                  if (candidate.isBetterThan(result)) {
                      result = candidate;
<span class="line-new-header">--- 337,11 ---</span>
                  return;
              }
  
              // If the entire segment was consumed, recurse.
              if (segment.getOffset() - initialOffset == charsToConsume) {
<span class="line-modified">!                 parseLongestRecursive(segment, candidate, recursionLevels + 1, status);</span>
                  if (U_FAILURE(status)) {
                      return;
                  }
                  if (candidate.isBetterThan(result)) {
                      result = candidate;
</pre>
<center><a href="numparse_currency.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="numparse_impl.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>