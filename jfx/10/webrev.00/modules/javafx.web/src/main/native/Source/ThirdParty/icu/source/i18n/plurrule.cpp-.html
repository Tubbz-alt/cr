<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/plurrule.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 * Copyright (C) 2007-2016, International Business Machines Corporation and
   6 * others. All Rights Reserved.
   7 *******************************************************************************
   8 *
   9 * File plurrule.cpp
  10 */
  11 
  12 #include &lt;math.h&gt;
  13 #include &lt;stdio.h&gt;
  14 
  15 #include &quot;unicode/utypes.h&quot;
  16 #include &quot;unicode/localpointer.h&quot;
  17 #include &quot;unicode/plurrule.h&quot;
  18 #include &quot;unicode/upluralrules.h&quot;
  19 #include &quot;unicode/ures.h&quot;
  20 #include &quot;unicode/numfmt.h&quot;
  21 #include &quot;unicode/decimfmt.h&quot;
  22 #include &quot;charstr.h&quot;
  23 #include &quot;cmemory.h&quot;
  24 #include &quot;cstring.h&quot;
  25 #include &quot;hash.h&quot;
  26 #include &quot;locutil.h&quot;
  27 #include &quot;mutex.h&quot;
  28 #include &quot;patternprops.h&quot;
  29 #include &quot;plurrule_impl.h&quot;
  30 #include &quot;putilimp.h&quot;
  31 #include &quot;ucln_in.h&quot;
  32 #include &quot;ustrfmt.h&quot;
  33 #include &quot;uassert.h&quot;
  34 #include &quot;uvectr32.h&quot;
  35 #include &quot;sharedpluralrules.h&quot;
  36 #include &quot;unifiedcache.h&quot;
  37 #include &quot;number_decimalquantity.h&quot;
  38 
  39 #if !UCONFIG_NO_FORMATTING
  40 
  41 U_NAMESPACE_BEGIN
  42 
  43 using namespace icu::pluralimpl;
  44 using icu::number::impl::DecimalQuantity;
  45 
  46 static const UChar PLURAL_KEYWORD_OTHER[]={LOW_O,LOW_T,LOW_H,LOW_E,LOW_R,0};
  47 static const UChar PLURAL_DEFAULT_RULE[]={LOW_O,LOW_T,LOW_H,LOW_E,LOW_R,COLON,SPACE,LOW_N,0};
  48 static const UChar PK_IN[]={LOW_I,LOW_N,0};
  49 static const UChar PK_NOT[]={LOW_N,LOW_O,LOW_T,0};
  50 static const UChar PK_IS[]={LOW_I,LOW_S,0};
  51 static const UChar PK_MOD[]={LOW_M,LOW_O,LOW_D,0};
  52 static const UChar PK_AND[]={LOW_A,LOW_N,LOW_D,0};
  53 static const UChar PK_OR[]={LOW_O,LOW_R,0};
  54 static const UChar PK_VAR_N[]={LOW_N,0};
  55 static const UChar PK_VAR_I[]={LOW_I,0};
  56 static const UChar PK_VAR_F[]={LOW_F,0};
  57 static const UChar PK_VAR_T[]={LOW_T,0};
  58 static const UChar PK_VAR_V[]={LOW_V,0};
  59 static const UChar PK_WITHIN[]={LOW_W,LOW_I,LOW_T,LOW_H,LOW_I,LOW_N,0};
  60 static const UChar PK_DECIMAL[]={LOW_D,LOW_E,LOW_C,LOW_I,LOW_M,LOW_A,LOW_L,0};
  61 static const UChar PK_INTEGER[]={LOW_I,LOW_N,LOW_T,LOW_E,LOW_G,LOW_E,LOW_R,0};
  62 
  63 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(PluralRules)
  64 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(PluralKeywordEnumeration)
  65 
  66 PluralRules::PluralRules(UErrorCode&amp; /*status*/)
  67 :   UObject(),
  68     mRules(NULL)
  69 {
  70 }
  71 
  72 PluralRules::PluralRules(const PluralRules&amp; other)
  73 : UObject(other),
  74     mRules(NULL)
  75 {
  76     *this=other;
  77 }
  78 
  79 PluralRules::~PluralRules() {
  80     delete mRules;
  81 }
  82 
  83 SharedPluralRules::~SharedPluralRules() {
  84     delete ptr;
  85 }
  86 
  87 PluralRules*
  88 PluralRules::clone() const {
  89     return new PluralRules(*this);
  90 }
  91 
  92 PluralRules&amp;
  93 PluralRules::operator=(const PluralRules&amp; other) {
  94     if (this != &amp;other) {
  95         delete mRules;
  96         if (other.mRules==NULL) {
  97             mRules = NULL;
  98         }
  99         else {
 100             mRules = new RuleChain(*other.mRules);
 101         }
 102     }
 103 
 104     return *this;
 105 }
 106 
 107 StringEnumeration* PluralRules::getAvailableLocales(UErrorCode &amp;status) {
 108     StringEnumeration *result = new PluralAvailableLocalesEnumeration(status);
 109     if (result == NULL &amp;&amp; U_SUCCESS(status)) {
 110         status = U_MEMORY_ALLOCATION_ERROR;
 111     }
 112     if (U_FAILURE(status)) {
 113         delete result;
 114         result = NULL;
 115     }
 116     return result;
 117 }
 118 
 119 
 120 PluralRules* U_EXPORT2
 121 PluralRules::createRules(const UnicodeString&amp; description, UErrorCode&amp; status) {
 122     if (U_FAILURE(status)) {
 123         return NULL;
 124     }
 125 
 126     PluralRuleParser parser;
 127     PluralRules *newRules = new PluralRules(status);
 128     if (U_SUCCESS(status) &amp;&amp; newRules == NULL) {
 129         status = U_MEMORY_ALLOCATION_ERROR;
 130     }
 131     parser.parse(description, newRules, status);
 132     if (U_FAILURE(status)) {
 133         delete newRules;
 134         newRules = NULL;
 135     }
 136     return newRules;
 137 }
 138 
 139 
 140 PluralRules* U_EXPORT2
 141 PluralRules::createDefaultRules(UErrorCode&amp; status) {
 142     return createRules(UnicodeString(TRUE, PLURAL_DEFAULT_RULE, -1), status);
 143 }
 144 
 145 /******************************************************************************/
 146 /* Create PluralRules cache */
 147 
 148 template&lt;&gt; U_I18N_API
 149 const SharedPluralRules *LocaleCacheKey&lt;SharedPluralRules&gt;::createObject(
 150         const void * /*unused*/, UErrorCode &amp;status) const {
 151     const char *localeId = fLoc.getName();
 152     PluralRules *pr = PluralRules::internalForLocale(
 153             localeId, UPLURAL_TYPE_CARDINAL, status);
 154     if (U_FAILURE(status)) {
 155         return NULL;
 156     }
 157     SharedPluralRules *result = new SharedPluralRules(pr);
 158     if (result == NULL) {
 159         status = U_MEMORY_ALLOCATION_ERROR;
 160         delete pr;
 161         return NULL;
 162     }
 163     result-&gt;addRef();
 164     return result;
 165 }
 166 
 167 /* end plural rules cache */
 168 /******************************************************************************/
 169 
 170 const SharedPluralRules* U_EXPORT2
 171 PluralRules::createSharedInstance(
 172         const Locale&amp; locale, UPluralType type, UErrorCode&amp; status) {
 173     if (U_FAILURE(status)) {
 174         return NULL;
 175     }
 176     if (type != UPLURAL_TYPE_CARDINAL) {
 177         status = U_UNSUPPORTED_ERROR;
 178         return NULL;
 179     }
 180     const SharedPluralRules *result = NULL;
 181     UnifiedCache::getByLocale(locale, result, status);
 182     return result;
 183 }
 184 
 185 PluralRules* U_EXPORT2
 186 PluralRules::forLocale(const Locale&amp; locale, UErrorCode&amp; status) {
 187     return forLocale(locale, UPLURAL_TYPE_CARDINAL, status);
 188 }
 189 
 190 PluralRules* U_EXPORT2
 191 PluralRules::forLocale(const Locale&amp; locale, UPluralType type, UErrorCode&amp; status) {
 192     if (type != UPLURAL_TYPE_CARDINAL) {
 193         return internalForLocale(locale, type, status);
 194     }
 195     const SharedPluralRules *shared = createSharedInstance(
 196             locale, type, status);
 197     if (U_FAILURE(status)) {
 198         return NULL;
 199     }
 200     PluralRules *result = (*shared)-&gt;clone();
 201     shared-&gt;removeRef();
 202     if (result == NULL) {
 203         status = U_MEMORY_ALLOCATION_ERROR;
 204     }
 205     return result;
 206 }
 207 
 208 PluralRules* U_EXPORT2
 209 PluralRules::internalForLocale(const Locale&amp; locale, UPluralType type, UErrorCode&amp; status) {
 210     if (U_FAILURE(status)) {
 211         return NULL;
 212     }
 213     if (type &gt;= UPLURAL_TYPE_COUNT) {
 214         status = U_ILLEGAL_ARGUMENT_ERROR;
 215         return NULL;
 216     }
 217     PluralRules *newObj = new PluralRules(status);
 218     if (newObj==NULL || U_FAILURE(status)) {
 219         delete newObj;
 220         return NULL;
 221     }
 222     UnicodeString locRule = newObj-&gt;getRuleFromResource(locale, type, status);
 223     // TODO: which errors, if any, should be returned?
 224     if (locRule.length() == 0) {
 225         // Locales with no specific rules (all numbers have the &quot;other&quot; category
 226         //   will return a U_MISSING_RESOURCE_ERROR at this point. This is not
 227         //   an error.
 228         locRule =  UnicodeString(PLURAL_DEFAULT_RULE);
 229         status = U_ZERO_ERROR;
 230     }
 231     PluralRuleParser parser;
 232     parser.parse(locRule, newObj, status);
 233         //  TODO: should rule parse errors be returned, or
 234         //        should we silently use default rules?
 235         //        Original impl used default rules.
 236         //        Ask the question to ICU Core.
 237 
 238     return newObj;
 239 }
 240 
 241 UnicodeString
 242 PluralRules::select(int32_t number) const {
 243     return select(FixedDecimal(number));
 244 }
 245 
 246 UnicodeString
 247 PluralRules::select(double number) const {
 248     return select(FixedDecimal(number));
 249 }
 250 
 251 UnicodeString
 252 PluralRules::select(const IFixedDecimal &amp;number) const {
 253     if (mRules == NULL) {
 254         return UnicodeString(TRUE, PLURAL_DEFAULT_RULE, -1);
 255     }
 256     else {
 257         return mRules-&gt;select(number);
 258     }
 259 }
 260 
 261 
 262 
 263 StringEnumeration*
 264 PluralRules::getKeywords(UErrorCode&amp; status) const {
 265     if (U_FAILURE(status))  return NULL;
 266     StringEnumeration* nameEnumerator = new PluralKeywordEnumeration(mRules, status);
 267     if (U_FAILURE(status)) {
 268       delete nameEnumerator;
 269       return NULL;
 270     }
 271 
 272     return nameEnumerator;
 273 }
 274 
 275 double
 276 PluralRules::getUniqueKeywordValue(const UnicodeString&amp; /* keyword */) {
 277   // Not Implemented.
 278   return UPLRULES_NO_UNIQUE_VALUE;
 279 }
 280 
 281 int32_t
 282 PluralRules::getAllKeywordValues(const UnicodeString &amp; /* keyword */, double * /* dest */,
 283                                  int32_t /* destCapacity */, UErrorCode&amp; error) {
 284     error = U_UNSUPPORTED_ERROR;
 285     return 0;
 286 }
 287 
 288 
 289 static double scaleForInt(double d) {
 290     double scale = 1.0;
 291     while (d != floor(d)) {
 292         d = d * 10.0;
 293         scale = scale * 10.0;
 294     }
 295     return scale;
 296 }
 297 
 298 static int32_t
 299 getSamplesFromString(const UnicodeString &amp;samples, double *dest,
 300                         int32_t destCapacity, UErrorCode&amp; status) {
 301     int32_t sampleCount = 0;
 302     int32_t sampleStartIdx = 0;
 303     int32_t sampleEndIdx = 0;
 304 
 305     //std::string ss;  // TODO: debugging.
 306     // std::cout &lt;&lt; &quot;PluralRules::getSamples(), samples = \&quot;&quot; &lt;&lt; samples.toUTF8String(ss) &lt;&lt; &quot;\&quot;\n&quot;;
 307     for (sampleCount = 0; sampleCount &lt; destCapacity &amp;&amp; sampleStartIdx &lt; samples.length(); ) {
 308         sampleEndIdx = samples.indexOf(COMMA, sampleStartIdx);
 309         if (sampleEndIdx == -1) {
 310             sampleEndIdx = samples.length();
 311         }
 312         const UnicodeString &amp;sampleRange = samples.tempSubStringBetween(sampleStartIdx, sampleEndIdx);
 313         // ss.erase();
 314         // std::cout &lt;&lt; &quot;PluralRules::getSamples(), samplesRange = \&quot;&quot; &lt;&lt; sampleRange.toUTF8String(ss) &lt;&lt; &quot;\&quot;\n&quot;;
 315         int32_t tildeIndex = sampleRange.indexOf(TILDE);
 316         if (tildeIndex &lt; 0) {
 317             FixedDecimal fixed(sampleRange, status);
 318             double sampleValue = fixed.source;
 319             if (fixed.visibleDecimalDigitCount == 0 || sampleValue != floor(sampleValue)) {
 320                 dest[sampleCount++] = sampleValue;
 321             }
 322         } else {
 323 
 324             FixedDecimal fixedLo(sampleRange.tempSubStringBetween(0, tildeIndex), status);
 325             FixedDecimal fixedHi(sampleRange.tempSubStringBetween(tildeIndex+1), status);
 326             double rangeLo = fixedLo.source;
 327             double rangeHi = fixedHi.source;
 328             if (U_FAILURE(status)) {
 329                 break;
 330             }
 331             if (rangeHi &lt; rangeLo) {
 332                 status = U_INVALID_FORMAT_ERROR;
 333                 break;
 334             }
 335 
 336             // For ranges of samples with fraction decimal digits, scale the number up so that we
 337             //   are adding one in the units place. Avoids roundoffs from repetitive adds of tenths.
 338 
 339             double scale = scaleForInt(rangeLo);
 340             double t = scaleForInt(rangeHi);
 341             if (t &gt; scale) {
 342                 scale = t;
 343             }
 344             rangeLo *= scale;
 345             rangeHi *= scale;
 346             for (double n=rangeLo; n&lt;=rangeHi; n+=1) {
 347                 // Hack Alert: don&#39;t return any decimal samples with integer values that
 348                 //    originated from a format with trailing decimals.
 349                 //    This API is returning doubles, which can&#39;t distinguish having displayed
 350                 //    zeros to the right of the decimal.
 351                 //    This results in test failures with values mapping back to a different keyword.
 352                 double sampleValue = n/scale;
 353                 if (!(sampleValue == floor(sampleValue) &amp;&amp; fixedLo.visibleDecimalDigitCount &gt; 0)) {
 354                     dest[sampleCount++] = sampleValue;
 355                 }
 356                 if (sampleCount &gt;= destCapacity) {
 357                     break;
 358                 }
 359             }
 360         }
 361         sampleStartIdx = sampleEndIdx + 1;
 362     }
 363     return sampleCount;
 364 }
 365 
 366 
 367 int32_t
 368 PluralRules::getSamples(const UnicodeString &amp;keyword, double *dest,
 369                         int32_t destCapacity, UErrorCode&amp; status) {
 370     RuleChain *rc = rulesForKeyword(keyword);
 371     if (rc == NULL || destCapacity == 0 || U_FAILURE(status)) {
 372         return 0;
 373     }
 374     int32_t numSamples = getSamplesFromString(rc-&gt;fIntegerSamples, dest, destCapacity, status);
 375     if (numSamples == 0) {
 376         numSamples = getSamplesFromString(rc-&gt;fDecimalSamples, dest, destCapacity, status);
 377     }
 378     return numSamples;
 379 }
 380 
 381 
 382 RuleChain *PluralRules::rulesForKeyword(const UnicodeString &amp;keyword) const {
 383     RuleChain *rc;
 384     for (rc = mRules; rc != NULL; rc = rc-&gt;fNext) {
 385         if (rc-&gt;fKeyword == keyword) {
 386             break;
 387         }
 388     }
 389     return rc;
 390 }
 391 
 392 
 393 UBool
 394 PluralRules::isKeyword(const UnicodeString&amp; keyword) const {
 395     if (0 == keyword.compare(PLURAL_KEYWORD_OTHER, 5)) {
 396         return true;
 397     }
 398     return rulesForKeyword(keyword) != NULL;
 399 }
 400 
 401 UnicodeString
 402 PluralRules::getKeywordOther() const {
 403     return UnicodeString(TRUE, PLURAL_KEYWORD_OTHER, 5);
 404 }
 405 
 406 UBool
 407 PluralRules::operator==(const PluralRules&amp; other) const  {
 408     const UnicodeString *ptrKeyword;
 409     UErrorCode status= U_ZERO_ERROR;
 410 
 411     if ( this == &amp;other ) {
 412         return TRUE;
 413     }
 414     LocalPointer&lt;StringEnumeration&gt; myKeywordList(getKeywords(status));
 415     LocalPointer&lt;StringEnumeration&gt; otherKeywordList(other.getKeywords(status));
 416     if (U_FAILURE(status)) {
 417         return FALSE;
 418     }
 419 
 420     if (myKeywordList-&gt;count(status)!=otherKeywordList-&gt;count(status)) {
 421         return FALSE;
 422     }
 423     myKeywordList-&gt;reset(status);
 424     while ((ptrKeyword=myKeywordList-&gt;snext(status))!=NULL) {
 425         if (!other.isKeyword(*ptrKeyword)) {
 426             return FALSE;
 427         }
 428     }
 429     otherKeywordList-&gt;reset(status);
 430     while ((ptrKeyword=otherKeywordList-&gt;snext(status))!=NULL) {
 431         if (!this-&gt;isKeyword(*ptrKeyword)) {
 432             return FALSE;
 433         }
 434     }
 435     if (U_FAILURE(status)) {
 436         return FALSE;
 437     }
 438 
 439     return TRUE;
 440 }
 441 
 442 
 443 void
 444 PluralRuleParser::parse(const UnicodeString&amp; ruleData, PluralRules *prules, UErrorCode &amp;status)
 445 {
 446     if (U_FAILURE(status)) {
 447         return;
 448     }
 449     U_ASSERT(ruleIndex == 0);    // Parsers are good for a single use only!
 450     ruleSrc = &amp;ruleData;
 451 
 452     while (ruleIndex&lt; ruleSrc-&gt;length()) {
 453         getNextToken(status);
 454         if (U_FAILURE(status)) {
 455             return;
 456         }
 457         checkSyntax(status);
 458         if (U_FAILURE(status)) {
 459             return;
 460         }
 461         switch (type) {
 462         case tAnd:
 463             U_ASSERT(curAndConstraint != NULL);
 464             curAndConstraint = curAndConstraint-&gt;add();
 465             break;
 466         case tOr:
 467             {
 468                 U_ASSERT(currentChain != NULL);
 469                 OrConstraint *orNode=currentChain-&gt;ruleHeader;
 470                 while (orNode-&gt;next != NULL) {
 471                     orNode = orNode-&gt;next;
 472                 }
 473                 orNode-&gt;next= new OrConstraint();
 474                 orNode=orNode-&gt;next;
 475                 orNode-&gt;next=NULL;
 476                 curAndConstraint = orNode-&gt;add();
 477             }
 478             break;
 479         case tIs:
 480             U_ASSERT(curAndConstraint != NULL);
 481             U_ASSERT(curAndConstraint-&gt;value == -1);
 482             U_ASSERT(curAndConstraint-&gt;rangeList == NULL);
 483             break;
 484         case tNot:
 485             U_ASSERT(curAndConstraint != NULL);
 486             curAndConstraint-&gt;negated=TRUE;
 487             break;
 488 
 489         case tNotEqual:
 490             curAndConstraint-&gt;negated=TRUE;
 491             U_FALLTHROUGH;
 492         case tIn:
 493         case tWithin:
 494         case tEqual:
 495             U_ASSERT(curAndConstraint != NULL);
 496             curAndConstraint-&gt;rangeList = new UVector32(status);
 497             curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Low
 498             curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Hi
 499             rangeLowIdx = 0;
 500             rangeHiIdx  = 1;
 501             curAndConstraint-&gt;value=PLURAL_RANGE_HIGH;
 502             curAndConstraint-&gt;integerOnly = (type != tWithin);
 503             break;
 504         case tNumber:
 505             U_ASSERT(curAndConstraint != NULL);
 506             if ( (curAndConstraint-&gt;op==AndConstraint::MOD)&amp;&amp;
 507                  (curAndConstraint-&gt;opNum == -1 ) ) {
 508                 curAndConstraint-&gt;opNum=getNumberValue(token);
 509             }
 510             else {
 511                 if (curAndConstraint-&gt;rangeList == NULL) {
 512                     // this is for an &#39;is&#39; rule
 513                     curAndConstraint-&gt;value = getNumberValue(token);
 514                 } else {
 515                     // this is for an &#39;in&#39; or &#39;within&#39; rule
 516                     if (curAndConstraint-&gt;rangeList-&gt;elementAti(rangeLowIdx) == -1) {
 517                         curAndConstraint-&gt;rangeList-&gt;setElementAt(getNumberValue(token), rangeLowIdx);
 518                         curAndConstraint-&gt;rangeList-&gt;setElementAt(getNumberValue(token), rangeHiIdx);
 519                     }
 520                     else {
 521                         curAndConstraint-&gt;rangeList-&gt;setElementAt(getNumberValue(token), rangeHiIdx);
 522                         if (curAndConstraint-&gt;rangeList-&gt;elementAti(rangeLowIdx) &gt;
 523                                 curAndConstraint-&gt;rangeList-&gt;elementAti(rangeHiIdx)) {
 524                             // Range Lower bound &gt; Range Upper bound.
 525                             // U_UNEXPECTED_TOKEN seems a little funny, but it is consistently
 526                             // used for all plural rule parse errors.
 527                             status = U_UNEXPECTED_TOKEN;
 528                             break;
 529                         }
 530                     }
 531                 }
 532             }
 533             break;
 534         case tComma:
 535             // TODO: rule syntax checking is inadequate, can happen with badly formed rules.
 536             //       Catch cases like &quot;n mod 10, is 1&quot; here instead.
 537             if (curAndConstraint == NULL || curAndConstraint-&gt;rangeList == NULL) {
 538                 status = U_UNEXPECTED_TOKEN;
 539                 break;
 540             }
 541             U_ASSERT(curAndConstraint-&gt;rangeList-&gt;size() &gt;= 2);
 542             rangeLowIdx = curAndConstraint-&gt;rangeList-&gt;size();
 543             curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Low
 544             rangeHiIdx = curAndConstraint-&gt;rangeList-&gt;size();
 545             curAndConstraint-&gt;rangeList-&gt;addElement(-1, status);  // range Hi
 546             break;
 547         case tMod:
 548             U_ASSERT(curAndConstraint != NULL);
 549             curAndConstraint-&gt;op=AndConstraint::MOD;
 550             break;
 551         case tVariableN:
 552         case tVariableI:
 553         case tVariableF:
 554         case tVariableT:
 555         case tVariableV:
 556             U_ASSERT(curAndConstraint != NULL);
 557             curAndConstraint-&gt;digitsType = type;
 558             break;
 559         case tKeyword:
 560             {
 561             RuleChain *newChain = new RuleChain;
 562             if (newChain == NULL) {
 563                 status = U_MEMORY_ALLOCATION_ERROR;
 564                 break;
 565             }
 566             newChain-&gt;fKeyword = token;
 567             if (prules-&gt;mRules == NULL) {
 568                 prules-&gt;mRules = newChain;
 569             } else {
 570                 // The new rule chain goes at the end of the linked list of rule chains,
 571                 //   unless there is an &quot;other&quot; keyword &amp; chain. &quot;other&quot; must remain last.
 572                 RuleChain *insertAfter = prules-&gt;mRules;
 573                 while (insertAfter-&gt;fNext!=NULL &amp;&amp;
 574                        insertAfter-&gt;fNext-&gt;fKeyword.compare(PLURAL_KEYWORD_OTHER, 5) != 0 ){
 575                     insertAfter=insertAfter-&gt;fNext;
 576                 }
 577                 newChain-&gt;fNext = insertAfter-&gt;fNext;
 578                 insertAfter-&gt;fNext = newChain;
 579             }
 580             OrConstraint *orNode = new OrConstraint();
 581             newChain-&gt;ruleHeader = orNode;
 582             curAndConstraint = orNode-&gt;add();
 583             currentChain = newChain;
 584             }
 585             break;
 586 
 587         case tInteger:
 588             for (;;) {
 589                 getNextToken(status);
 590                 if (U_FAILURE(status) || type == tSemiColon || type == tEOF || type == tAt) {
 591                     break;
 592                 }
 593                 if (type == tEllipsis) {
 594                     currentChain-&gt;fIntegerSamplesUnbounded = TRUE;
 595                     continue;
 596                 }
 597                 currentChain-&gt;fIntegerSamples.append(token);
 598             }
 599             break;
 600 
 601         case tDecimal:
 602             for (;;) {
 603                 getNextToken(status);
 604                 if (U_FAILURE(status) || type == tSemiColon || type == tEOF || type == tAt) {
 605                     break;
 606                 }
 607                 if (type == tEllipsis) {
 608                     currentChain-&gt;fDecimalSamplesUnbounded = TRUE;
 609                     continue;
 610                 }
 611                 currentChain-&gt;fDecimalSamples.append(token);
 612             }
 613             break;
 614 
 615         default:
 616             break;
 617         }
 618         prevType=type;
 619         if (U_FAILURE(status)) {
 620             break;
 621         }
 622     }
 623 }
 624 
 625 UnicodeString
 626 PluralRules::getRuleFromResource(const Locale&amp; locale, UPluralType type, UErrorCode&amp; errCode) {
 627     UnicodeString emptyStr;
 628 
 629     if (U_FAILURE(errCode)) {
 630         return emptyStr;
 631     }
 632     LocalUResourceBundlePointer rb(ures_openDirect(NULL, &quot;plurals&quot;, &amp;errCode));
 633     if(U_FAILURE(errCode)) {
 634         return emptyStr;
 635     }
 636     const char *typeKey;
 637     switch (type) {
 638     case UPLURAL_TYPE_CARDINAL:
 639         typeKey = &quot;locales&quot;;
 640         break;
 641     case UPLURAL_TYPE_ORDINAL:
 642         typeKey = &quot;locales_ordinals&quot;;
 643         break;
 644     default:
 645         // Must not occur: The caller should have checked for valid types.
 646         errCode = U_ILLEGAL_ARGUMENT_ERROR;
 647         return emptyStr;
 648     }
 649     LocalUResourceBundlePointer locRes(ures_getByKey(rb.getAlias(), typeKey, NULL, &amp;errCode));
 650     if(U_FAILURE(errCode)) {
 651         return emptyStr;
 652     }
 653     int32_t resLen=0;
 654     const char *curLocaleName=locale.getName();
 655     const UChar* s = ures_getStringByKey(locRes.getAlias(), curLocaleName, &amp;resLen, &amp;errCode);
 656 
 657     if (s == NULL) {
 658         // Check parent locales.
 659         UErrorCode status = U_ZERO_ERROR;
 660         char parentLocaleName[ULOC_FULLNAME_CAPACITY];
 661         const char *curLocaleName=locale.getName();
 662         uprv_strcpy(parentLocaleName, curLocaleName);
 663 
 664         while (uloc_getParent(parentLocaleName, parentLocaleName,
 665                                        ULOC_FULLNAME_CAPACITY, &amp;status) &gt; 0) {
 666             resLen=0;
 667             s = ures_getStringByKey(locRes.getAlias(), parentLocaleName, &amp;resLen, &amp;status);
 668             if (s != NULL) {
 669                 errCode = U_ZERO_ERROR;
 670                 break;
 671             }
 672             status = U_ZERO_ERROR;
 673         }
 674     }
 675     if (s==NULL) {
 676         return emptyStr;
 677     }
 678 
 679     char setKey[256];
 680     u_UCharsToChars(s, setKey, resLen + 1);
 681     // printf(&quot;\n PluralRule: %s\n&quot;, setKey);
 682 
 683     LocalUResourceBundlePointer ruleRes(ures_getByKey(rb.getAlias(), &quot;rules&quot;, NULL, &amp;errCode));
 684     if(U_FAILURE(errCode)) {
 685         return emptyStr;
 686     }
 687     LocalUResourceBundlePointer setRes(ures_getByKey(ruleRes.getAlias(), setKey, NULL, &amp;errCode));
 688     if (U_FAILURE(errCode)) {
 689         return emptyStr;
 690     }
 691 
 692     int32_t numberKeys = ures_getSize(setRes.getAlias());
 693     UnicodeString result;
 694     const char *key=NULL;
 695     for(int32_t i=0; i&lt;numberKeys; ++i) {   // Keys are zero, one, few, ...
 696         UnicodeString rules = ures_getNextUnicodeString(setRes.getAlias(), &amp;key, &amp;errCode);
 697         UnicodeString uKey(key, -1, US_INV);
 698         result.append(uKey);
 699         result.append(COLON);
 700         result.append(rules);
 701         result.append(SEMI_COLON);
 702     }
 703     return result;
 704 }
 705 
 706 
 707 UnicodeString
 708 PluralRules::getRules() const {
 709     UnicodeString rules;
 710     if (mRules != NULL) {
 711         mRules-&gt;dumpRules(rules);
 712     }
 713     return rules;
 714 }
 715 
 716 
 717 AndConstraint::AndConstraint() {
 718     op = AndConstraint::NONE;
 719     opNum=-1;
 720     value = -1;
 721     rangeList = NULL;
 722     negated = FALSE;
 723     integerOnly = FALSE;
 724     digitsType = none;
 725     next=NULL;
 726 }
 727 
 728 
 729 AndConstraint::AndConstraint(const AndConstraint&amp; other) {
 730     this-&gt;op = other.op;
 731     this-&gt;opNum=other.opNum;
 732     this-&gt;value=other.value;
 733     this-&gt;rangeList=NULL;
 734     if (other.rangeList != NULL) {
 735         UErrorCode status = U_ZERO_ERROR;
 736         this-&gt;rangeList = new UVector32(status);
 737         this-&gt;rangeList-&gt;assign(*other.rangeList, status);
 738     }
 739     this-&gt;integerOnly=other.integerOnly;
 740     this-&gt;negated=other.negated;
 741     this-&gt;digitsType = other.digitsType;
 742     if (other.next==NULL) {
 743         this-&gt;next=NULL;
 744     }
 745     else {
 746         this-&gt;next = new AndConstraint(*other.next);
 747     }
 748 }
 749 
 750 AndConstraint::~AndConstraint() {
 751     delete rangeList;
 752     if (next!=NULL) {
 753         delete next;
 754     }
 755 }
 756 
 757 
 758 UBool
 759 AndConstraint::isFulfilled(const IFixedDecimal &amp;number) {
 760     UBool result = TRUE;
 761     if (digitsType == none) {
 762         // An empty AndConstraint, created by a rule with a keyword but no following expression.
 763         return TRUE;
 764     }
 765 
 766     PluralOperand operand = tokenTypeToPluralOperand(digitsType);
 767     double n = number.getPluralOperand(operand);     // pulls n | i | v | f value for the number.
 768                                                      // Will always be positive.
 769                                                      // May be non-integer (n option only)
 770     do {
 771         if (integerOnly &amp;&amp; n != uprv_floor(n)) {
 772             result = FALSE;
 773             break;
 774         }
 775 
 776         if (op == MOD) {
 777             n = fmod(n, opNum);
 778         }
 779         if (rangeList == NULL) {
 780             result = value == -1 ||    // empty rule
 781                      n == value;       //  &#39;is&#39; rule
 782             break;
 783         }
 784         result = FALSE;                // &#39;in&#39; or &#39;within&#39; rule
 785         for (int32_t r=0; r&lt;rangeList-&gt;size(); r+=2) {
 786             if (rangeList-&gt;elementAti(r) &lt;= n &amp;&amp; n &lt;= rangeList-&gt;elementAti(r+1)) {
 787                 result = TRUE;
 788                 break;
 789             }
 790         }
 791     } while (FALSE);
 792 
 793     if (negated) {
 794         result = !result;
 795     }
 796     return result;
 797 }
 798 
 799 
 800 AndConstraint*
 801 AndConstraint::add()
 802 {
 803     this-&gt;next = new AndConstraint();
 804     return this-&gt;next;
 805 }
 806 
 807 OrConstraint::OrConstraint() {
 808     childNode=NULL;
 809     next=NULL;
 810 }
 811 
 812 OrConstraint::OrConstraint(const OrConstraint&amp; other) {
 813     if ( other.childNode == NULL ) {
 814         this-&gt;childNode = NULL;
 815     }
 816     else {
 817         this-&gt;childNode = new AndConstraint(*(other.childNode));
 818     }
 819     if (other.next == NULL ) {
 820         this-&gt;next = NULL;
 821     }
 822     else {
 823         this-&gt;next = new OrConstraint(*(other.next));
 824     }
 825 }
 826 
 827 OrConstraint::~OrConstraint() {
 828     if (childNode!=NULL) {
 829         delete childNode;
 830     }
 831     if (next!=NULL) {
 832         delete next;
 833     }
 834 }
 835 
 836 AndConstraint*
 837 OrConstraint::add()
 838 {
 839     OrConstraint *curOrConstraint=this;
 840     {
 841         while (curOrConstraint-&gt;next!=NULL) {
 842             curOrConstraint = curOrConstraint-&gt;next;
 843         }
 844         U_ASSERT(curOrConstraint-&gt;childNode == NULL);
 845         curOrConstraint-&gt;childNode = new AndConstraint();
 846     }
 847     return curOrConstraint-&gt;childNode;
 848 }
 849 
 850 UBool
 851 OrConstraint::isFulfilled(const IFixedDecimal &amp;number) {
 852     OrConstraint* orRule=this;
 853     UBool result=FALSE;
 854 
 855     while (orRule!=NULL &amp;&amp; !result) {
 856         result=TRUE;
 857         AndConstraint* andRule = orRule-&gt;childNode;
 858         while (andRule!=NULL &amp;&amp; result) {
 859             result = andRule-&gt;isFulfilled(number);
 860             andRule=andRule-&gt;next;
 861         }
 862         orRule = orRule-&gt;next;
 863     }
 864 
 865     return result;
 866 }
 867 
 868 
 869 RuleChain::RuleChain(): fKeyword(), fNext(NULL), ruleHeader(NULL), fDecimalSamples(), fIntegerSamples(),
 870                         fDecimalSamplesUnbounded(FALSE), fIntegerSamplesUnbounded(FALSE) {
 871 }
 872 
 873 RuleChain::RuleChain(const RuleChain&amp; other) :
 874         fKeyword(other.fKeyword), fNext(NULL), ruleHeader(NULL), fDecimalSamples(other.fDecimalSamples),
 875         fIntegerSamples(other.fIntegerSamples), fDecimalSamplesUnbounded(other.fDecimalSamplesUnbounded),
 876         fIntegerSamplesUnbounded(other.fIntegerSamplesUnbounded) {
 877     if (other.ruleHeader != NULL) {
 878         this-&gt;ruleHeader = new OrConstraint(*(other.ruleHeader));
 879     }
 880     if (other.fNext != NULL ) {
 881         this-&gt;fNext = new RuleChain(*other.fNext);
 882     }
 883 }
 884 
 885 RuleChain::~RuleChain() {
 886     delete fNext;
 887     delete ruleHeader;
 888 }
 889 
 890 
 891 UnicodeString
 892 RuleChain::select(const IFixedDecimal &amp;number) const {
 893     if (!number.isNaN() &amp;&amp; !number.isInfinite()) {
 894         for (const RuleChain *rules = this; rules != NULL; rules = rules-&gt;fNext) {
 895              if (rules-&gt;ruleHeader-&gt;isFulfilled(number)) {
 896                  return rules-&gt;fKeyword;
 897              }
 898         }
 899     }
 900     return UnicodeString(TRUE, PLURAL_KEYWORD_OTHER, 5);
 901 }
 902 
 903 static UnicodeString tokenString(tokenType tok) {
 904     UnicodeString s;
 905     switch (tok) {
 906       case tVariableN:
 907         s.append(LOW_N); break;
 908       case tVariableI:
 909         s.append(LOW_I); break;
 910       case tVariableF:
 911         s.append(LOW_F); break;
 912       case tVariableV:
 913         s.append(LOW_V); break;
 914       case tVariableT:
 915         s.append(LOW_T); break;
 916       default:
 917         s.append(TILDE);
 918     }
 919     return s;
 920 }
 921 
 922 void
 923 RuleChain::dumpRules(UnicodeString&amp; result) {
 924     UChar digitString[16];
 925 
 926     if ( ruleHeader != NULL ) {
 927         result +=  fKeyword;
 928         result += COLON;
 929         result += SPACE;
 930         OrConstraint* orRule=ruleHeader;
 931         while ( orRule != NULL ) {
 932             AndConstraint* andRule=orRule-&gt;childNode;
 933             while ( andRule != NULL ) {
 934                 if ((andRule-&gt;op==AndConstraint::NONE) &amp;&amp;  (andRule-&gt;rangeList==NULL) &amp;&amp; (andRule-&gt;value == -1)) {
 935                     // Empty Rules.
 936                 } else if ( (andRule-&gt;op==AndConstraint::NONE) &amp;&amp; (andRule-&gt;rangeList==NULL) ) {
 937                     result += tokenString(andRule-&gt;digitsType);
 938                     result += UNICODE_STRING_SIMPLE(&quot; is &quot;);
 939                     if (andRule-&gt;negated) {
 940                         result += UNICODE_STRING_SIMPLE(&quot;not &quot;);
 941                     }
 942                     uprv_itou(digitString,16, andRule-&gt;value,10,0);
 943                     result += UnicodeString(digitString);
 944                 }
 945                 else {
 946                     result += tokenString(andRule-&gt;digitsType);
 947                     result += SPACE;
 948                     if (andRule-&gt;op==AndConstraint::MOD) {
 949                         result += UNICODE_STRING_SIMPLE(&quot;mod &quot;);
 950                         uprv_itou(digitString,16, andRule-&gt;opNum,10,0);
 951                         result += UnicodeString(digitString);
 952                     }
 953                     if (andRule-&gt;rangeList==NULL) {
 954                         if (andRule-&gt;negated) {
 955                             result += UNICODE_STRING_SIMPLE(&quot; is not &quot;);
 956                             uprv_itou(digitString,16, andRule-&gt;value,10,0);
 957                             result += UnicodeString(digitString);
 958                         }
 959                         else {
 960                             result += UNICODE_STRING_SIMPLE(&quot; is &quot;);
 961                             uprv_itou(digitString,16, andRule-&gt;value,10,0);
 962                             result += UnicodeString(digitString);
 963                         }
 964                     }
 965                     else {
 966                         if (andRule-&gt;negated) {
 967                             if ( andRule-&gt;integerOnly ) {
 968                                 result += UNICODE_STRING_SIMPLE(&quot; not in &quot;);
 969                             }
 970                             else {
 971                                 result += UNICODE_STRING_SIMPLE(&quot; not within &quot;);
 972                             }
 973                         }
 974                         else {
 975                             if ( andRule-&gt;integerOnly ) {
 976                                 result += UNICODE_STRING_SIMPLE(&quot; in &quot;);
 977                             }
 978                             else {
 979                                 result += UNICODE_STRING_SIMPLE(&quot; within &quot;);
 980                             }
 981                         }
 982                         for (int32_t r=0; r&lt;andRule-&gt;rangeList-&gt;size(); r+=2) {
 983                             int32_t rangeLo = andRule-&gt;rangeList-&gt;elementAti(r);
 984                             int32_t rangeHi = andRule-&gt;rangeList-&gt;elementAti(r+1);
 985                             uprv_itou(digitString,16, rangeLo, 10, 0);
 986                             result += UnicodeString(digitString);
 987                             result += UNICODE_STRING_SIMPLE(&quot;..&quot;);
 988                             uprv_itou(digitString,16, rangeHi, 10,0);
 989                             result += UnicodeString(digitString);
 990                             if (r+2 &lt; andRule-&gt;rangeList-&gt;size()) {
 991                                 result += UNICODE_STRING_SIMPLE(&quot;, &quot;);
 992                             }
 993                         }
 994                     }
 995                 }
 996                 if ( (andRule=andRule-&gt;next) != NULL) {
 997                     result += UNICODE_STRING_SIMPLE(&quot; and &quot;);
 998                 }
 999             }
1000             if ( (orRule = orRule-&gt;next) != NULL ) {
1001                 result += UNICODE_STRING_SIMPLE(&quot; or &quot;);
1002             }
1003         }
1004     }
1005     if ( fNext != NULL ) {
1006         result += UNICODE_STRING_SIMPLE(&quot;; &quot;);
1007         fNext-&gt;dumpRules(result);
1008     }
1009 }
1010 
1011 
1012 UErrorCode
1013 RuleChain::getKeywords(int32_t capacityOfKeywords, UnicodeString* keywords, int32_t&amp; arraySize) const {
1014     if ( arraySize &lt; capacityOfKeywords-1 ) {
1015         keywords[arraySize++]=fKeyword;
1016     }
1017     else {
1018         return U_BUFFER_OVERFLOW_ERROR;
1019     }
1020 
1021     if ( fNext != NULL ) {
1022         return fNext-&gt;getKeywords(capacityOfKeywords, keywords, arraySize);
1023     }
1024     else {
1025         return U_ZERO_ERROR;
1026     }
1027 }
1028 
1029 UBool
1030 RuleChain::isKeyword(const UnicodeString&amp; keywordParam) const {
1031     if ( fKeyword == keywordParam ) {
1032         return TRUE;
1033     }
1034 
1035     if ( fNext != NULL ) {
1036         return fNext-&gt;isKeyword(keywordParam);
1037     }
1038     else {
1039         return FALSE;
1040     }
1041 }
1042 
1043 
1044 PluralRuleParser::PluralRuleParser() :
1045         ruleIndex(0), token(), type(none), prevType(none),
1046         curAndConstraint(NULL), currentChain(NULL), rangeLowIdx(-1), rangeHiIdx(-1)
1047 {
1048 }
1049 
1050 PluralRuleParser::~PluralRuleParser() {
1051 }
1052 
1053 
1054 int32_t
1055 PluralRuleParser::getNumberValue(const UnicodeString&amp; token) {
1056     int32_t i;
1057     char digits[128];
1058 
1059     i = token.extract(0, token.length(), digits, UPRV_LENGTHOF(digits), US_INV);
1060     digits[i]=&#39;\0&#39;;
1061 
1062     return((int32_t)atoi(digits));
1063 }
1064 
1065 
1066 void
1067 PluralRuleParser::checkSyntax(UErrorCode &amp;status)
1068 {
1069     if (U_FAILURE(status)) {
1070         return;
1071     }
1072     if (!(prevType==none || prevType==tSemiColon)) {
1073         type = getKeyType(token, type);  // Switch token type from tKeyword if we scanned a reserved word,
1074                                                //   and we are not at the start of a rule, where a
1075                                                //   keyword is expected.
1076     }
1077 
1078     switch(prevType) {
1079     case none:
1080     case tSemiColon:
1081         if (type!=tKeyword &amp;&amp; type != tEOF) {
1082             status = U_UNEXPECTED_TOKEN;
1083         }
1084         break;
1085     case tVariableN:
1086     case tVariableI:
1087     case tVariableF:
1088     case tVariableT:
1089     case tVariableV:
1090         if (type != tIs &amp;&amp; type != tMod &amp;&amp; type != tIn &amp;&amp;
1091             type != tNot &amp;&amp; type != tWithin &amp;&amp; type != tEqual &amp;&amp; type != tNotEqual) {
1092             status = U_UNEXPECTED_TOKEN;
1093         }
1094         break;
1095     case tKeyword:
1096         if (type != tColon) {
1097             status = U_UNEXPECTED_TOKEN;
1098         }
1099         break;
1100     case tColon:
1101         if (!(type == tVariableN ||
1102               type == tVariableI ||
1103               type == tVariableF ||
1104               type == tVariableT ||
1105               type == tVariableV ||
1106               type == tAt)) {
1107             status = U_UNEXPECTED_TOKEN;
1108         }
1109         break;
1110     case tIs:
1111         if ( type != tNumber &amp;&amp; type != tNot) {
1112             status = U_UNEXPECTED_TOKEN;
1113         }
1114         break;
1115     case tNot:
1116         if (type != tNumber &amp;&amp; type != tIn &amp;&amp; type != tWithin) {
1117             status = U_UNEXPECTED_TOKEN;
1118         }
1119         break;
1120     case tMod:
1121     case tDot2:
1122     case tIn:
1123     case tWithin:
1124     case tEqual:
1125     case tNotEqual:
1126         if (type != tNumber) {
1127             status = U_UNEXPECTED_TOKEN;
1128         }
1129         break;
1130     case tAnd:
1131     case tOr:
1132         if ( type != tVariableN &amp;&amp;
1133              type != tVariableI &amp;&amp;
1134              type != tVariableF &amp;&amp;
1135              type != tVariableT &amp;&amp;
1136              type != tVariableV) {
1137             status = U_UNEXPECTED_TOKEN;
1138         }
1139         break;
1140     case tComma:
1141         if (type != tNumber) {
1142             status = U_UNEXPECTED_TOKEN;
1143         }
1144         break;
1145     case tNumber:
1146         if (type != tDot2  &amp;&amp; type != tSemiColon &amp;&amp; type != tIs       &amp;&amp; type != tNot    &amp;&amp;
1147             type != tIn    &amp;&amp; type != tEqual     &amp;&amp; type != tNotEqual &amp;&amp; type != tWithin &amp;&amp;
1148             type != tAnd   &amp;&amp; type != tOr        &amp;&amp; type != tComma    &amp;&amp; type != tAt     &amp;&amp;
1149             type != tEOF)
1150         {
1151             status = U_UNEXPECTED_TOKEN;
1152         }
1153         // TODO: a comma following a number that is not part of a range will be allowed.
1154         //       It&#39;s not the only case of this sort of thing. Parser needs a re-write.
1155         break;
1156     case tAt:
1157         if (type != tDecimal &amp;&amp; type != tInteger) {
1158             status = U_UNEXPECTED_TOKEN;
1159         }
1160         break;
1161     default:
1162         status = U_UNEXPECTED_TOKEN;
1163         break;
1164     }
1165 }
1166 
1167 
1168 /*
1169  *  Scan the next token from the input rules.
1170  *     rules and returned token type are in the parser state variables.
1171  */
1172 void
1173 PluralRuleParser::getNextToken(UErrorCode &amp;status)
1174 {
1175     if (U_FAILURE(status)) {
1176         return;
1177     }
1178 
1179     UChar ch;
1180     while (ruleIndex &lt; ruleSrc-&gt;length()) {
1181         ch = ruleSrc-&gt;charAt(ruleIndex);
1182         type = charType(ch);
1183         if (type != tSpace) {
1184             break;
1185         }
1186         ++(ruleIndex);
1187     }
1188     if (ruleIndex &gt;= ruleSrc-&gt;length()) {
1189         type = tEOF;
1190         return;
1191     }
1192     int32_t curIndex= ruleIndex;
1193 
1194     switch (type) {
1195       case tColon:
1196       case tSemiColon:
1197       case tComma:
1198       case tEllipsis:
1199       case tTilde:   // scanned &#39;~&#39;
1200       case tAt:      // scanned &#39;@&#39;
1201       case tEqual:   // scanned &#39;=&#39;
1202       case tMod:     // scanned &#39;%&#39;
1203         // Single character tokens.
1204         ++curIndex;
1205         break;
1206 
1207       case tNotEqual:  // scanned &#39;!&#39;
1208         if (ruleSrc-&gt;charAt(curIndex+1) == EQUALS) {
1209             curIndex += 2;
1210         } else {
1211             type = none;
1212             curIndex += 1;
1213         }
1214         break;
1215 
1216       case tKeyword:
1217          while (type == tKeyword &amp;&amp; ++curIndex &lt; ruleSrc-&gt;length()) {
1218              ch = ruleSrc-&gt;charAt(curIndex);
1219              type = charType(ch);
1220          }
1221          type = tKeyword;
1222          break;
1223 
1224       case tNumber:
1225          while (type == tNumber &amp;&amp; ++curIndex &lt; ruleSrc-&gt;length()) {
1226              ch = ruleSrc-&gt;charAt(curIndex);
1227              type = charType(ch);
1228          }
1229          type = tNumber;
1230          break;
1231 
1232        case tDot:
1233          // We could be looking at either &quot;..&quot; in a range, or &quot;...&quot; at the end of a sample.
1234          if (curIndex+1 &gt;= ruleSrc-&gt;length() || ruleSrc-&gt;charAt(curIndex+1) != DOT) {
1235              ++curIndex;
1236              break; // Single dot
1237          }
1238          if (curIndex+2 &gt;= ruleSrc-&gt;length() || ruleSrc-&gt;charAt(curIndex+2) != DOT) {
1239              curIndex += 2;
1240              type = tDot2;
1241              break; // double dot
1242          }
1243          type = tEllipsis;
1244          curIndex += 3;
1245          break;     // triple dot
1246 
1247        default:
1248          status = U_UNEXPECTED_TOKEN;
1249          ++curIndex;
1250          break;
1251     }
1252 
1253     U_ASSERT(ruleIndex &lt;= ruleSrc-&gt;length());
1254     U_ASSERT(curIndex &lt;= ruleSrc-&gt;length());
1255     token=UnicodeString(*ruleSrc, ruleIndex, curIndex-ruleIndex);
1256     ruleIndex = curIndex;
1257 }
1258 
1259 tokenType
1260 PluralRuleParser::charType(UChar ch) {
1261     if ((ch&gt;=U_ZERO) &amp;&amp; (ch&lt;=U_NINE)) {
1262         return tNumber;
1263     }
1264     if (ch&gt;=LOW_A &amp;&amp; ch&lt;=LOW_Z) {
1265         return tKeyword;
1266     }
1267     switch (ch) {
1268     case COLON:
1269         return tColon;
1270     case SPACE:
1271         return tSpace;
1272     case SEMI_COLON:
1273         return tSemiColon;
1274     case DOT:
1275         return tDot;
1276     case COMMA:
1277         return tComma;
1278     case EXCLAMATION:
1279         return tNotEqual;
1280     case EQUALS:
1281         return tEqual;
1282     case PERCENT_SIGN:
1283         return tMod;
1284     case AT:
1285         return tAt;
1286     case ELLIPSIS:
1287         return tEllipsis;
1288     case TILDE:
1289         return tTilde;
1290     default :
1291         return none;
1292     }
1293 }
1294 
1295 
1296 //  Set token type for reserved words in the Plural Rule syntax.
1297 
1298 tokenType
1299 PluralRuleParser::getKeyType(const UnicodeString &amp;token, tokenType keyType)
1300 {
1301     if (keyType != tKeyword) {
1302         return keyType;
1303     }
1304 
1305     if (0 == token.compare(PK_VAR_N, 1)) {
1306         keyType = tVariableN;
1307     } else if (0 == token.compare(PK_VAR_I, 1)) {
1308         keyType = tVariableI;
1309     } else if (0 == token.compare(PK_VAR_F, 1)) {
1310         keyType = tVariableF;
1311     } else if (0 == token.compare(PK_VAR_T, 1)) {
1312         keyType = tVariableT;
1313     } else if (0 == token.compare(PK_VAR_V, 1)) {
1314         keyType = tVariableV;
1315     } else if (0 == token.compare(PK_IS, 2)) {
1316         keyType = tIs;
1317     } else if (0 == token.compare(PK_AND, 3)) {
1318         keyType = tAnd;
1319     } else if (0 == token.compare(PK_IN, 2)) {
1320         keyType = tIn;
1321     } else if (0 == token.compare(PK_WITHIN, 6)) {
1322         keyType = tWithin;
1323     } else if (0 == token.compare(PK_NOT, 3)) {
1324         keyType = tNot;
1325     } else if (0 == token.compare(PK_MOD, 3)) {
1326         keyType = tMod;
1327     } else if (0 == token.compare(PK_OR, 2)) {
1328         keyType = tOr;
1329     } else if (0 == token.compare(PK_DECIMAL, 7)) {
1330         keyType = tDecimal;
1331     } else if (0 == token.compare(PK_INTEGER, 7)) {
1332         keyType = tInteger;
1333     }
1334     return keyType;
1335 }
1336 
1337 
1338 PluralKeywordEnumeration::PluralKeywordEnumeration(RuleChain *header, UErrorCode&amp; status)
1339         : pos(0), fKeywordNames(status) {
1340     if (U_FAILURE(status)) {
1341         return;
1342     }
1343     fKeywordNames.setDeleter(uprv_deleteUObject);
1344     UBool  addKeywordOther=TRUE;
1345     RuleChain *node=header;
1346     while(node!=NULL) {
1347         fKeywordNames.addElement(new UnicodeString(node-&gt;fKeyword), status);
1348         if (U_FAILURE(status)) {
1349             return;
1350         }
1351         if (0 == node-&gt;fKeyword.compare(PLURAL_KEYWORD_OTHER, 5)) {
1352             addKeywordOther= FALSE;
1353         }
1354         node=node-&gt;fNext;
1355     }
1356 
1357     if (addKeywordOther) {
1358         fKeywordNames.addElement(new UnicodeString(PLURAL_KEYWORD_OTHER), status);
1359     }
1360 }
1361 
1362 const UnicodeString*
1363 PluralKeywordEnumeration::snext(UErrorCode&amp; status) {
1364     if (U_SUCCESS(status) &amp;&amp; pos &lt; fKeywordNames.size()) {
1365         return (const UnicodeString*)fKeywordNames.elementAt(pos++);
1366     }
1367     return NULL;
1368 }
1369 
1370 void
1371 PluralKeywordEnumeration::reset(UErrorCode&amp; /*status*/) {
1372     pos=0;
1373 }
1374 
1375 int32_t
1376 PluralKeywordEnumeration::count(UErrorCode&amp; /*status*/) const {
1377        return fKeywordNames.size();
1378 }
1379 
1380 PluralKeywordEnumeration::~PluralKeywordEnumeration() {
1381 }
1382 
1383 PluralOperand tokenTypeToPluralOperand(tokenType tt) {
1384     switch(tt) {
1385     case tVariableN:
1386         return PLURAL_OPERAND_N;
1387     case tVariableI:
1388         return PLURAL_OPERAND_I;
1389     case tVariableF:
1390         return PLURAL_OPERAND_F;
1391     case tVariableV:
1392         return PLURAL_OPERAND_V;
1393     case tVariableT:
1394         return PLURAL_OPERAND_T;
1395     default:
1396         U_ASSERT(FALSE);  // unexpected.
1397         return PLURAL_OPERAND_N;
1398     }
1399 }
1400 
1401 FixedDecimal::FixedDecimal(double n, int32_t v, int64_t f) {
1402     init(n, v, f);
1403     // check values. TODO make into unit test.
1404     //
1405     //            long visiblePower = (int) Math.pow(10, v);
1406     //            if (decimalDigits &gt; visiblePower) {
1407     //                throw new IllegalArgumentException();
1408     //            }
1409     //            double fraction = intValue + (decimalDigits / (double) visiblePower);
1410     //            if (fraction != source) {
1411     //                double diff = Math.abs(fraction - source)/(Math.abs(fraction) + Math.abs(source));
1412     //                if (diff &gt; 0.00000001d) {
1413     //                    throw new IllegalArgumentException();
1414     //                }
1415     //            }
1416 }
1417 
1418 FixedDecimal::FixedDecimal(double n, int32_t v) {
1419     // Ugly, but for samples we don&#39;t care.
1420     init(n, v, getFractionalDigits(n, v));
1421 }
1422 
1423 FixedDecimal::FixedDecimal(double n) {
1424     init(n);
1425 }
1426 
1427 FixedDecimal::FixedDecimal() {
1428     init(0, 0, 0);
1429 }
1430 
1431 
1432 // Create a FixedDecimal from a UnicodeString containing a number.
1433 //    Inefficient, but only used for samples, so simplicity trumps efficiency.
1434 
1435 FixedDecimal::FixedDecimal(const UnicodeString &amp;num, UErrorCode &amp;status) {
1436     CharString cs;
1437     cs.appendInvariantChars(num, status);
1438     DecimalQuantity dl;
1439     dl.setToDecNumber(cs.toStringPiece(), status);
1440     if (U_FAILURE(status)) {
1441         init(0, 0, 0);
1442         return;
1443     }
1444     int32_t decimalPoint = num.indexOf(DOT);
1445     double n = dl.toDouble();
1446     if (decimalPoint == -1) {
1447         init(n, 0, 0);
1448     } else {
1449         int32_t v = num.length() - decimalPoint - 1;
1450         init(n, v, getFractionalDigits(n, v));
1451     }
1452 }
1453 
1454 
1455 FixedDecimal::FixedDecimal(const FixedDecimal &amp;other) {
1456     source = other.source;
1457     visibleDecimalDigitCount = other.visibleDecimalDigitCount;
1458     decimalDigits = other.decimalDigits;
1459     decimalDigitsWithoutTrailingZeros = other.decimalDigitsWithoutTrailingZeros;
1460     intValue = other.intValue;
1461     _hasIntegerValue = other._hasIntegerValue;
1462     isNegative = other.isNegative;
1463     _isNaN = other._isNaN;
1464     _isInfinite = other._isInfinite;
1465 }
1466 
1467 FixedDecimal::~FixedDecimal() = default;
1468 
1469 
1470 void FixedDecimal::init(double n) {
1471     int32_t numFractionDigits = decimals(n);
1472     init(n, numFractionDigits, getFractionalDigits(n, numFractionDigits));
1473 }
1474 
1475 
1476 void FixedDecimal::init(double n, int32_t v, int64_t f) {
1477     isNegative = n &lt; 0.0;
1478     source = fabs(n);
1479     _isNaN = uprv_isNaN(source);
1480     _isInfinite = uprv_isInfinite(source);
1481     if (_isNaN || _isInfinite) {
1482         v = 0;
1483         f = 0;
1484         intValue = 0;
1485         _hasIntegerValue = FALSE;
1486     } else {
1487         intValue = (int64_t)source;
1488         _hasIntegerValue = (source == intValue);
1489     }
1490 
1491     visibleDecimalDigitCount = v;
1492     decimalDigits = f;
1493     if (f == 0) {
1494          decimalDigitsWithoutTrailingZeros = 0;
1495     } else {
1496         int64_t fdwtz = f;
1497         while ((fdwtz%10) == 0) {
1498             fdwtz /= 10;
1499         }
1500         decimalDigitsWithoutTrailingZeros = fdwtz;
1501     }
1502 }
1503 
1504 
1505 //  Fast path only exact initialization. Return true if successful.
1506 //     Note: Do not multiply by 10 each time through loop, rounding cruft can build
1507 //           up that makes the check for an integer result fail.
1508 //           A single multiply of the original number works more reliably.
1509 static int32_t p10[] = {1, 10, 100, 1000, 10000};
1510 UBool FixedDecimal::quickInit(double n) {
1511     UBool success = FALSE;
1512     n = fabs(n);
1513     int32_t numFractionDigits;
1514     for (numFractionDigits = 0; numFractionDigits &lt;= 3; numFractionDigits++) {
1515         double scaledN = n * p10[numFractionDigits];
1516         if (scaledN == floor(scaledN)) {
1517             success = TRUE;
1518             break;
1519         }
1520     }
1521     if (success) {
1522         init(n, numFractionDigits, getFractionalDigits(n, numFractionDigits));
1523     }
1524     return success;
1525 }
1526 
1527 
1528 
1529 int32_t FixedDecimal::decimals(double n) {
1530     // Count the number of decimal digits in the fraction part of the number, excluding trailing zeros.
1531     // fastpath the common cases, integers or fractions with 3 or fewer digits
1532     n = fabs(n);
1533     for (int ndigits=0; ndigits&lt;=3; ndigits++) {
1534         double scaledN = n * p10[ndigits];
1535         if (scaledN == floor(scaledN)) {
1536             return ndigits;
1537         }
1538     }
1539 
1540     // Slow path, convert with sprintf, parse converted output.
1541     char  buf[30] = {0};
1542     sprintf(buf, &quot;%1.15e&quot;, n);
1543     // formatted number looks like this: 1.234567890123457e-01
1544     int exponent = atoi(buf+18);
1545     int numFractionDigits = 15;
1546     for (int i=16; ; --i) {
1547         if (buf[i] != &#39;0&#39;) {
1548             break;
1549         }
1550         --numFractionDigits;
1551     }
1552     numFractionDigits -= exponent;   // Fraction part of fixed point representation.
1553     return numFractionDigits;
1554 }
1555 
1556 
1557 // Get the fraction digits of a double, represented as an integer.
1558 //    v is the number of visible fraction digits in the displayed form of the number.
1559 //       Example: n = 1001.234, v = 6, result = 234000
1560 //    TODO: need to think through how this is used in the plural rule context.
1561 //          This function can easily encounter integer overflow,
1562 //          and can easily return noise digits when the precision of a double is exceeded.
1563 
1564 int64_t FixedDecimal::getFractionalDigits(double n, int32_t v) {
1565     if (v == 0 || n == floor(n) || uprv_isNaN(n) || uprv_isPositiveInfinity(n)) {
1566         return 0;
1567     }
1568     n = fabs(n);
1569     double fract = n - floor(n);
1570     switch (v) {
1571       case 1: return (int64_t)(fract*10.0 + 0.5);
1572       case 2: return (int64_t)(fract*100.0 + 0.5);
1573       case 3: return (int64_t)(fract*1000.0 + 0.5);
1574       default:
1575           double scaled = floor(fract * pow(10.0, (double)v) + 0.5);
1576           if (scaled &gt; U_INT64_MAX) {
1577               return U_INT64_MAX;
1578           } else {
1579               return (int64_t)scaled;
1580           }
1581       }
1582 }
1583 
1584 
1585 void FixedDecimal::adjustForMinFractionDigits(int32_t minFractionDigits) {
1586     int32_t numTrailingFractionZeros = minFractionDigits - visibleDecimalDigitCount;
1587     if (numTrailingFractionZeros &gt; 0) {
1588         for (int32_t i=0; i&lt;numTrailingFractionZeros; i++) {
1589             // Do not let the decimalDigits value overflow if there are many trailing zeros.
1590             // Limit the value to 18 digits, the most that a 64 bit int can fully represent.
1591             if (decimalDigits &gt;= 100000000000000000LL) {
1592                 break;
1593             }
1594             decimalDigits *= 10;
1595         }
1596         visibleDecimalDigitCount += numTrailingFractionZeros;
1597     }
1598 }
1599 
1600 
1601 double FixedDecimal::getPluralOperand(PluralOperand operand) const {
1602     switch(operand) {
1603         case PLURAL_OPERAND_N: return source;
1604         case PLURAL_OPERAND_I: return static_cast&lt;double&gt;(intValue);
1605         case PLURAL_OPERAND_F: return static_cast&lt;double&gt;(decimalDigits);
1606         case PLURAL_OPERAND_T: return static_cast&lt;double&gt;(decimalDigitsWithoutTrailingZeros);
1607         case PLURAL_OPERAND_V: return visibleDecimalDigitCount;
1608         default:
1609              U_ASSERT(FALSE);  // unexpected.
1610              return source;
1611     }
1612 }
1613 
1614 bool FixedDecimal::isNaN() const {
1615     return _isNaN;
1616 }
1617 
1618 bool FixedDecimal::isInfinite() const {
1619     return _isInfinite;
1620 }
1621 
1622 bool FixedDecimal::hasIntegerValue() const {
1623     return _hasIntegerValue;
1624 }
1625 
1626 bool FixedDecimal::isNanOrInfinity() const {
1627     return _isNaN || _isInfinite;
1628 }
1629 
1630 int32_t FixedDecimal::getVisibleFractionDigitCount() const {
1631     return visibleDecimalDigitCount;
1632 }
1633 
1634 
1635 
1636 PluralAvailableLocalesEnumeration::PluralAvailableLocalesEnumeration(UErrorCode &amp;status) {
1637     fLocales = NULL;
1638     fRes = NULL;
1639     fOpenStatus = status;
1640     if (U_FAILURE(status)) {
1641         return;
1642     }
1643     fOpenStatus = U_ZERO_ERROR;
1644     LocalUResourceBundlePointer rb(ures_openDirect(NULL, &quot;plurals&quot;, &amp;fOpenStatus));
1645     fLocales = ures_getByKey(rb.getAlias(), &quot;locales&quot;, NULL, &amp;fOpenStatus);
1646 }
1647 
1648 PluralAvailableLocalesEnumeration::~PluralAvailableLocalesEnumeration() {
1649     ures_close(fLocales);
1650     ures_close(fRes);
1651     fLocales = NULL;
1652     fRes = NULL;
1653 }
1654 
1655 const char *PluralAvailableLocalesEnumeration::next(int32_t *resultLength, UErrorCode &amp;status) {
1656     if (U_FAILURE(status)) {
1657         return NULL;
1658     }
1659     if (U_FAILURE(fOpenStatus)) {
1660         status = fOpenStatus;
1661         return NULL;
1662     }
1663     fRes = ures_getNextResource(fLocales, fRes, &amp;status);
1664     if (fRes == NULL || U_FAILURE(status)) {
1665         if (status == U_INDEX_OUTOFBOUNDS_ERROR) {
1666             status = U_ZERO_ERROR;
1667         }
1668         return NULL;
1669     }
1670     const char *result = ures_getKey(fRes);
1671     if (resultLength != NULL) {
1672         *resultLength = static_cast&lt;int32_t&gt;(uprv_strlen(result));
1673     }
1674     return result;
1675 }
1676 
1677 
1678 void PluralAvailableLocalesEnumeration::reset(UErrorCode &amp;status) {
1679     if (U_FAILURE(status)) {
1680        return;
1681     }
1682     if (U_FAILURE(fOpenStatus)) {
1683         status = fOpenStatus;
1684         return;
1685     }
1686     ures_resetIterator(fLocales);
1687 }
1688 
1689 int32_t PluralAvailableLocalesEnumeration::count(UErrorCode &amp;status) const {
1690     if (U_FAILURE(status)) {
1691         return 0;
1692     }
1693     if (U_FAILURE(fOpenStatus)) {
1694         status = fOpenStatus;
1695         return 0;
1696     }
1697     return ures_getSize(fLocales);
1698 }
1699 
1700 U_NAMESPACE_END
1701 
1702 
1703 #endif /* #if !UCONFIG_NO_FORMATTING */
1704 
1705 //eof
    </pre>
  </body>
</html>