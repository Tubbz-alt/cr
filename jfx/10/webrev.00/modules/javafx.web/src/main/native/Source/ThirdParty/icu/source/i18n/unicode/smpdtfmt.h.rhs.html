<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/smpdtfmt.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 * Copyright (C) 1997-2016, International Business Machines Corporation and
   5 * others. All Rights Reserved.
   6 *******************************************************************************
   7 *
   8 * File SMPDTFMT.H
   9 *
  10 * Modification History:
  11 *
  12 *   Date        Name        Description
  13 *   02/19/97    aliu        Converted from java.
  14 *   07/09/97    helena      Make ParsePosition into a class.
  15 *   07/21/98    stephen     Added GMT_PLUS, GMT_MINUS
  16 *                            Changed setTwoDigitStartDate to set2DigitYearStart
  17 *                            Changed getTwoDigitStartDate to get2DigitYearStart
  18 *                            Removed subParseLong
  19 *                            Removed getZoneIndex (added in DateFormatSymbols)
  20 *   06/14/99    stephen     Removed fgTimeZoneDataSuffix
  21 *   10/14/99    aliu        Updated class doc to describe 2-digit year parsing
  22 *                           {j28 4182066}.
  23 *******************************************************************************
  24 */
  25 
  26 #ifndef SMPDTFMT_H
  27 #define SMPDTFMT_H
  28 
  29 #include &quot;unicode/utypes.h&quot;
  30 
  31 /**
  32  * \file
  33  * \brief C++ API: Format and parse dates in a language-independent manner.
  34  */
  35 
  36 #if !UCONFIG_NO_FORMATTING
  37 
  38 #include &quot;unicode/datefmt.h&quot;
  39 #include &quot;unicode/udisplaycontext.h&quot;
  40 #include &quot;unicode/tzfmt.h&quot;  /* for UTimeZoneFormatTimeType */
  41 #include &quot;unicode/brkiter.h&quot;
  42 
  43 U_NAMESPACE_BEGIN
  44 
  45 class DateFormatSymbols;
  46 class DateFormat;
  47 class MessageFormat;
  48 class FieldPositionHandler;
  49 class TimeZoneFormat;
  50 class SharedNumberFormat;
  51 class SimpleDateFormatMutableNFs;
<a name="1" id="anc1"></a><span class="line-added">  52 class DateIntervalFormat;</span>
  53 
  54 namespace number {
  55 class LocalizedNumberFormatter;
  56 }
  57 
  58 /**
  59  *
  60  * SimpleDateFormat is a concrete class for formatting and parsing dates in a
  61  * language-independent manner. It allows for formatting (millis -&gt; text),
  62  * parsing (text -&gt; millis), and normalization. Formats/Parses a date or time,
  63  * which is the standard milliseconds since 24:00 GMT, Jan 1, 1970.
  64  * &lt;P&gt;
  65  * Clients are encouraged to create a date-time formatter using DateFormat::getInstance(),
  66  * getDateInstance(), getDateInstance(), or getDateTimeInstance() rather than
  67  * explicitly constructing an instance of SimpleDateFormat.  This way, the client
  68  * is guaranteed to get an appropriate formatting pattern for whatever locale the
  69  * program is running in.  However, if the client needs something more unusual than
  70  * the default patterns in the locales, he can construct a SimpleDateFormat directly
  71  * and give it an appropriate pattern (or use one of the factory methods on DateFormat
  72  * and modify the pattern after the fact with toPattern() and applyPattern().
  73  *
  74  * &lt;p&gt;&lt;strong&gt;Date and Time Patterns:&lt;/strong&gt;&lt;/p&gt;
  75  *
  76  * &lt;p&gt;Date and time formats are specified by &lt;em&gt;date and time pattern&lt;/em&gt; strings.
  77  * Within date and time pattern strings, all unquoted ASCII letters [A-Za-z] are reserved
  78  * as pattern letters representing calendar fields. &lt;code&gt;SimpleDateFormat&lt;/code&gt; supports
  79  * the date and time formatting algorithm and pattern letters defined by
  80  * &lt;a href=&quot;http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table&quot;&gt;UTS#35
  81  * Unicode Locale Data Markup Language (LDML)&lt;/a&gt; and further documented for ICU in the
  82  * &lt;a href=&quot;https://sites.google.com/site/icuprojectuserguide/formatparse/datetime?pli=1#TOC-Date-Field-Symbol-Table&quot;&gt;ICU
  83  * User Guide&lt;/a&gt;. The following pattern letters are currently available (note that the actual
  84  * values depend on CLDR and may change from the examples shown here):&lt;/p&gt;
  85  *
  86  * &lt;table border=&quot;1&quot;&gt;
  87  *     &lt;tr&gt;
  88  *         &lt;th&gt;Field&lt;/th&gt;
  89  *         &lt;th style=&quot;text-align: center&quot;&gt;Sym.&lt;/th&gt;
  90  *         &lt;th style=&quot;text-align: center&quot;&gt;No.&lt;/th&gt;
  91  *         &lt;th&gt;Example&lt;/th&gt;
  92  *         &lt;th&gt;Description&lt;/th&gt;
  93  *     &lt;/tr&gt;
  94  *     &lt;tr&gt;
  95  *         &lt;th rowspan=&quot;3&quot;&gt;era&lt;/th&gt;
  96  *         &lt;td style=&quot;text-align: center&quot; rowspan=&quot;3&quot;&gt;G&lt;/td&gt;
  97  *         &lt;td style=&quot;text-align: center&quot;&gt;1..3&lt;/td&gt;
  98  *         &lt;td&gt;AD&lt;/td&gt;
  99  *         &lt;td rowspan=&quot;3&quot;&gt;Era - Replaced with the Era string for the current date. One to three letters for the
 100  *         abbreviated form, four letters for the long (wide) form, five for the narrow form.&lt;/td&gt;
 101  *     &lt;/tr&gt;
 102  *     &lt;tr&gt;
 103  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 104  *         &lt;td&gt;Anno Domini&lt;/td&gt;
 105  *     &lt;/tr&gt;
 106  *     &lt;tr&gt;
 107  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 108  *         &lt;td&gt;A&lt;/td&gt;
 109  *     &lt;/tr&gt;
 110  *     &lt;tr&gt;
 111  *         &lt;th rowspan=&quot;6&quot;&gt;year&lt;/th&gt;
 112  *         &lt;td style=&quot;text-align: center&quot;&gt;y&lt;/td&gt;
 113  *         &lt;td style=&quot;text-align: center&quot;&gt;1..n&lt;/td&gt;
 114  *         &lt;td&gt;1996&lt;/td&gt;
 115  *         &lt;td&gt;Year. Normally the length specifies the padding, but for two letters it also specifies the maximum
 116  *         length. Example:&lt;div align=&quot;center&quot;&gt;
 117  *             &lt;center&gt;
 118  *             &lt;table border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;0&quot;&gt;
 119  *                 &lt;tr&gt;
 120  *                     &lt;th&gt;Year&lt;/th&gt;
 121  *                     &lt;th style=&quot;text-align: right&quot;&gt;y&lt;/th&gt;
 122  *                     &lt;th style=&quot;text-align: right&quot;&gt;yy&lt;/th&gt;
 123  *                     &lt;th style=&quot;text-align: right&quot;&gt;yyy&lt;/th&gt;
 124  *                     &lt;th style=&quot;text-align: right&quot;&gt;yyyy&lt;/th&gt;
 125  *                     &lt;th style=&quot;text-align: right&quot;&gt;yyyyy&lt;/th&gt;
 126  *                 &lt;/tr&gt;
 127  *                 &lt;tr&gt;
 128  *                     &lt;td&gt;AD 1&lt;/td&gt;
 129  *                     &lt;td style=&quot;text-align: right&quot;&gt;1&lt;/td&gt;
 130  *                     &lt;td style=&quot;text-align: right&quot;&gt;01&lt;/td&gt;
 131  *                     &lt;td style=&quot;text-align: right&quot;&gt;001&lt;/td&gt;
 132  *                     &lt;td style=&quot;text-align: right&quot;&gt;0001&lt;/td&gt;
 133  *                     &lt;td style=&quot;text-align: right&quot;&gt;00001&lt;/td&gt;
 134  *                 &lt;/tr&gt;
 135  *                 &lt;tr&gt;
 136  *                     &lt;td&gt;AD 12&lt;/td&gt;
 137  *                     &lt;td style=&quot;text-align: right&quot;&gt;12&lt;/td&gt;
 138  *                     &lt;td style=&quot;text-align: right&quot;&gt;12&lt;/td&gt;
 139  *                     &lt;td style=&quot;text-align: right&quot;&gt;012&lt;/td&gt;
 140  *                     &lt;td style=&quot;text-align: right&quot;&gt;0012&lt;/td&gt;
 141  *                     &lt;td style=&quot;text-align: right&quot;&gt;00012&lt;/td&gt;
 142  *                 &lt;/tr&gt;
 143  *                 &lt;tr&gt;
 144  *                     &lt;td&gt;AD 123&lt;/td&gt;
 145  *                     &lt;td style=&quot;text-align: right&quot;&gt;123&lt;/td&gt;
 146  *                     &lt;td style=&quot;text-align: right&quot;&gt;23&lt;/td&gt;
 147  *                     &lt;td style=&quot;text-align: right&quot;&gt;123&lt;/td&gt;
 148  *                     &lt;td style=&quot;text-align: right&quot;&gt;0123&lt;/td&gt;
 149  *                     &lt;td style=&quot;text-align: right&quot;&gt;00123&lt;/td&gt;
 150  *                 &lt;/tr&gt;
 151  *                 &lt;tr&gt;
 152  *                     &lt;td&gt;AD 1234&lt;/td&gt;
 153  *                     &lt;td style=&quot;text-align: right&quot;&gt;1234&lt;/td&gt;
 154  *                     &lt;td style=&quot;text-align: right&quot;&gt;34&lt;/td&gt;
 155  *                     &lt;td style=&quot;text-align: right&quot;&gt;1234&lt;/td&gt;
 156  *                     &lt;td style=&quot;text-align: right&quot;&gt;1234&lt;/td&gt;
 157  *                     &lt;td style=&quot;text-align: right&quot;&gt;01234&lt;/td&gt;
 158  *                 &lt;/tr&gt;
 159  *                 &lt;tr&gt;
 160  *                     &lt;td&gt;AD 12345&lt;/td&gt;
 161  *                     &lt;td style=&quot;text-align: right&quot;&gt;12345&lt;/td&gt;
 162  *                     &lt;td style=&quot;text-align: right&quot;&gt;45&lt;/td&gt;
 163  *                     &lt;td style=&quot;text-align: right&quot;&gt;12345&lt;/td&gt;
 164  *                     &lt;td style=&quot;text-align: right&quot;&gt;12345&lt;/td&gt;
 165  *                     &lt;td style=&quot;text-align: right&quot;&gt;12345&lt;/td&gt;
 166  *                 &lt;/tr&gt;
 167  *             &lt;/table&gt;
 168  *             &lt;/center&gt;&lt;/div&gt;
 169  *         &lt;/td&gt;
 170  *     &lt;/tr&gt;
 171  *     &lt;tr&gt;
 172  *         &lt;td style=&quot;text-align: center&quot;&gt;Y&lt;/td&gt;
 173  *         &lt;td style=&quot;text-align: center&quot;&gt;1..n&lt;/td&gt;
 174  *         &lt;td&gt;1997&lt;/td&gt;
 175  *         &lt;td&gt;Year (in &quot;Week of Year&quot; based calendars). Normally the length specifies the padding,
 176  *         but for two letters it also specifies the maximum length. This year designation is used in ISO
 177  *         year-week calendar as defined by ISO 8601, but can be used in non-Gregorian based calendar systems
 178  *         where week date processing is desired. May not always be the same value as calendar year.&lt;/td&gt;
 179  *     &lt;/tr&gt;
 180  *     &lt;tr&gt;
 181  *         &lt;td style=&quot;text-align: center&quot;&gt;u&lt;/td&gt;
 182  *         &lt;td style=&quot;text-align: center&quot;&gt;1..n&lt;/td&gt;
 183  *         &lt;td&gt;4601&lt;/td&gt;
 184  *         &lt;td&gt;Extended year. This is a single number designating the year of this calendar system, encompassing
 185  *         all supra-year fields. For example, for the Julian calendar system, year numbers are positive, with an
 186  *         era of BCE or CE. An extended year value for the Julian calendar system assigns positive values to CE
 187  *         years and negative values to BCE years, with 1 BCE being year 0.&lt;/td&gt;
 188  *     &lt;/tr&gt;
 189  *     &lt;tr&gt;
 190  *         &lt;td style=&quot;text-align: center&quot; rowspan=&quot;3&quot;&gt;U&lt;/td&gt;
 191  *         &lt;td style=&quot;text-align: center&quot;&gt;1..3&lt;/td&gt;
 192  *         &lt;td&gt;&amp;#30002;&amp;#23376;&lt;/td&gt;
 193  *         &lt;td rowspan=&quot;3&quot;&gt;Cyclic year name. Calendars such as the Chinese lunar calendar (and related calendars)
 194  *         and the Hindu calendars use 60-year cycles of year names. Use one through three letters for the abbreviated
 195  *         name, four for the full (wide) name, or five for the narrow name (currently the data only provides abbreviated names,
 196  *         which will be used for all requested name widths). If the calendar does not provide cyclic year name data,
 197  *         or if the year value to be formatted is out of the range of years for which cyclic name data is provided,
 198  *         then numeric formatting is used (behaves like &#39;y&#39;).&lt;/td&gt;
 199  *     &lt;/tr&gt;
 200  *     &lt;tr&gt;
 201  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 202  *         &lt;td&gt;(currently also &amp;#30002;&amp;#23376;)&lt;/td&gt;
 203  *     &lt;/tr&gt;
 204  *     &lt;tr&gt;
 205  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 206  *         &lt;td&gt;(currently also &amp;#30002;&amp;#23376;)&lt;/td&gt;
 207  *     &lt;/tr&gt;
 208  *     &lt;tr&gt;
 209  *         &lt;th rowspan=&quot;6&quot;&gt;quarter&lt;/th&gt;
 210  *         &lt;td rowspan=&quot;3&quot; style=&quot;text-align: center&quot;&gt;Q&lt;/td&gt;
 211  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 212  *         &lt;td&gt;02&lt;/td&gt;
 213  *         &lt;td rowspan=&quot;3&quot;&gt;Quarter - Use one or two for the numerical quarter, three for the abbreviation, or four for the
 214  *         full (wide) name (five for the narrow name is not yet supported).&lt;/td&gt;
 215  *     &lt;/tr&gt;
 216  *     &lt;tr&gt;
 217  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 218  *         &lt;td&gt;Q2&lt;/td&gt;
 219  *     &lt;/tr&gt;
 220  *     &lt;tr&gt;
 221  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 222  *         &lt;td&gt;2nd quarter&lt;/td&gt;
 223  *     &lt;/tr&gt;
 224  *     &lt;tr&gt;
 225  *         &lt;td rowspan=&quot;3&quot; style=&quot;text-align: center&quot;&gt;q&lt;/td&gt;
 226  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 227  *         &lt;td&gt;02&lt;/td&gt;
 228  *         &lt;td rowspan=&quot;3&quot;&gt;&lt;b&gt;Stand-Alone&lt;/b&gt; Quarter - Use one or two for the numerical quarter, three for the abbreviation,
 229  *         or four for the full name (five for the narrow name is not yet supported).&lt;/td&gt;
 230  *     &lt;/tr&gt;
 231  *     &lt;tr&gt;
 232  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 233  *         &lt;td&gt;Q2&lt;/td&gt;
 234  *     &lt;/tr&gt;
 235  *     &lt;tr&gt;
 236  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 237  *         &lt;td&gt;2nd quarter&lt;/td&gt;
 238  *     &lt;/tr&gt;
 239  *     &lt;tr&gt;
 240  *         &lt;th rowspan=&quot;8&quot;&gt;month&lt;/th&gt;
 241  *         &lt;td rowspan=&quot;4&quot; style=&quot;text-align: center&quot;&gt;M&lt;/td&gt;
 242  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 243  *         &lt;td&gt;09&lt;/td&gt;
 244  *         &lt;td rowspan=&quot;4&quot;&gt;Month - Use one or two for the numerical month, three for the abbreviation, four for
 245  *         the full (wide) name, or five for the narrow name. With two (&quot;MM&quot;), the month number is zero-padded
 246  *         if necessary (e.g. &quot;08&quot;)&lt;/td&gt;
 247  *     &lt;/tr&gt;
 248  *     &lt;tr&gt;
 249  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 250  *         &lt;td&gt;Sep&lt;/td&gt;
 251  *     &lt;/tr&gt;
 252  *     &lt;tr&gt;
 253  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 254  *         &lt;td&gt;September&lt;/td&gt;
 255  *     &lt;/tr&gt;
 256  *     &lt;tr&gt;
 257  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 258  *         &lt;td&gt;S&lt;/td&gt;
 259  *     &lt;/tr&gt;
 260  *     &lt;tr&gt;
 261  *         &lt;td rowspan=&quot;4&quot; style=&quot;text-align: center&quot;&gt;L&lt;/td&gt;
 262  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 263  *         &lt;td&gt;09&lt;/td&gt;
 264  *         &lt;td rowspan=&quot;4&quot;&gt;&lt;b&gt;Stand-Alone&lt;/b&gt; Month - Use one or two for the numerical month, three for the abbreviation,
 265  *         four for the full (wide) name, or 5 for the narrow name. With two (&quot;LL&quot;), the month number is zero-padded if
 266  *         necessary (e.g. &quot;08&quot;)&lt;/td&gt;
 267  *     &lt;/tr&gt;
 268  *     &lt;tr&gt;
 269  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 270  *         &lt;td&gt;Sep&lt;/td&gt;
 271  *     &lt;/tr&gt;
 272  *     &lt;tr&gt;
 273  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 274  *         &lt;td&gt;September&lt;/td&gt;
 275  *     &lt;/tr&gt;
 276  *     &lt;tr&gt;
 277  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 278  *         &lt;td&gt;S&lt;/td&gt;
 279  *     &lt;/tr&gt;
 280  *     &lt;tr&gt;
 281  *         &lt;th rowspan=&quot;2&quot;&gt;week&lt;/th&gt;
 282  *         &lt;td style=&quot;text-align: center&quot;&gt;w&lt;/td&gt;
 283  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 284  *         &lt;td&gt;27&lt;/td&gt;
 285  *         &lt;td&gt;Week of Year. Use &quot;w&quot; to show the minimum number of digits, or &quot;ww&quot; to always show two digits
 286  *         (zero-padding if necessary, e.g. &quot;08&quot;).&lt;/td&gt;
 287  *     &lt;/tr&gt;
 288  *     &lt;tr&gt;
 289  *         &lt;td style=&quot;text-align: center&quot;&gt;W&lt;/td&gt;
 290  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 291  *         &lt;td&gt;3&lt;/td&gt;
 292  *         &lt;td&gt;Week of Month&lt;/td&gt;
 293  *     &lt;/tr&gt;
 294  *     &lt;tr&gt;
 295  *         &lt;th rowspan=&quot;4&quot;&gt;day&lt;/th&gt;
 296  *         &lt;td style=&quot;text-align: center&quot;&gt;d&lt;/td&gt;
 297  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 298  *         &lt;td&gt;1&lt;/td&gt;
 299  *         &lt;td&gt;Date - Day of the month. Use &quot;d&quot; to show the minimum number of digits, or &quot;dd&quot; to always show
 300  *         two digits (zero-padding if necessary, e.g. &quot;08&quot;).&lt;/td&gt;
 301  *     &lt;/tr&gt;
 302  *     &lt;tr&gt;
 303  *         &lt;td style=&quot;text-align: center&quot;&gt;D&lt;/td&gt;
 304  *         &lt;td style=&quot;text-align: center&quot;&gt;1..3&lt;/td&gt;
 305  *         &lt;td&gt;345&lt;/td&gt;
 306  *         &lt;td&gt;Day of year&lt;/td&gt;
 307  *     &lt;/tr&gt;
 308  *     &lt;tr&gt;
 309  *         &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
 310  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 311  *         &lt;td&gt;2&lt;/td&gt;
 312  *         &lt;td&gt;Day of Week in Month. The example is for the 2nd Wed in July&lt;/td&gt;
 313  *     &lt;/tr&gt;
 314  *     &lt;tr&gt;
 315  *         &lt;td style=&quot;text-align: center&quot;&gt;g&lt;/td&gt;
 316  *         &lt;td style=&quot;text-align: center&quot;&gt;1..n&lt;/td&gt;
 317  *         &lt;td&gt;2451334&lt;/td&gt;
 318  *         &lt;td&gt;Modified Julian day. This is different from the conventional Julian day number in two regards.
 319  *         First, it demarcates days at local zone midnight, rather than noon GMT. Second, it is a local number;
 320  *         that is, it depends on the local time zone. It can be thought of as a single number that encompasses
 321  *         all the date-related fields.&lt;/td&gt;
 322  *     &lt;/tr&gt;
 323  *     &lt;tr&gt;
 324  *         &lt;th rowspan=&quot;14&quot;&gt;week&lt;br&gt;
 325  *         day&lt;/th&gt;
 326  *         &lt;td rowspan=&quot;4&quot; style=&quot;text-align: center&quot;&gt;E&lt;/td&gt;
 327  *         &lt;td style=&quot;text-align: center&quot;&gt;1..3&lt;/td&gt;
 328  *         &lt;td&gt;Tue&lt;/td&gt;
 329  *         &lt;td rowspan=&quot;4&quot;&gt;Day of week - Use one through three letters for the short day, four for the full (wide) name,
 330  *         five for the narrow name, or six for the short name.&lt;/td&gt;
 331  *     &lt;/tr&gt;
 332  *     &lt;tr&gt;
 333  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 334  *         &lt;td&gt;Tuesday&lt;/td&gt;
 335  *     &lt;/tr&gt;
 336  *     &lt;tr&gt;
 337  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 338  *         &lt;td&gt;T&lt;/td&gt;
 339  *     &lt;/tr&gt;
 340  *     &lt;tr&gt;
 341  *         &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
 342  *         &lt;td&gt;Tu&lt;/td&gt;
 343  *     &lt;/tr&gt;
 344  *     &lt;tr&gt;
 345  *         &lt;td rowspan=&quot;5&quot; style=&quot;text-align: center&quot;&gt;e&lt;/td&gt;
 346  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 347  *         &lt;td&gt;2&lt;/td&gt;
 348  *         &lt;td rowspan=&quot;5&quot;&gt;Local day of week. Same as E except adds a numeric value that will depend on the local
 349  *         starting day of the week, using one or two letters. For this example, Monday is the first day of the week.&lt;/td&gt;
 350  *     &lt;/tr&gt;
 351  *     &lt;tr&gt;
 352  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 353  *         &lt;td&gt;Tue&lt;/td&gt;
 354  *     &lt;/tr&gt;
 355  *     &lt;tr&gt;
 356  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 357  *         &lt;td&gt;Tuesday&lt;/td&gt;
 358  *     &lt;/tr&gt;
 359  *     &lt;tr&gt;
 360  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 361  *         &lt;td&gt;T&lt;/td&gt;
 362  *     &lt;/tr&gt;
 363  *     &lt;tr&gt;
 364  *         &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
 365  *         &lt;td&gt;Tu&lt;/td&gt;
 366  *     &lt;/tr&gt;
 367  *     &lt;tr&gt;
 368  *         &lt;td rowspan=&quot;5&quot; style=&quot;text-align: center&quot;&gt;c&lt;/td&gt;
 369  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 370  *         &lt;td&gt;2&lt;/td&gt;
 371  *         &lt;td rowspan=&quot;5&quot;&gt;&lt;b&gt;Stand-Alone&lt;/b&gt; local day of week - Use one letter for the local numeric value (same
 372  *         as &#39;e&#39;), three for the short day, four for the full (wide) name, five for the narrow name, or six for
 373  *         the short name.&lt;/td&gt;
 374  *     &lt;/tr&gt;
 375  *     &lt;tr&gt;
 376  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 377  *         &lt;td&gt;Tue&lt;/td&gt;
 378  *     &lt;/tr&gt;
 379  *     &lt;tr&gt;
 380  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 381  *         &lt;td&gt;Tuesday&lt;/td&gt;
 382  *     &lt;/tr&gt;
 383  *     &lt;tr&gt;
 384  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 385  *         &lt;td&gt;T&lt;/td&gt;
 386  *     &lt;/tr&gt;
 387  *     &lt;tr&gt;
 388  *         &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
 389  *         &lt;td&gt;Tu&lt;/td&gt;
 390  *     &lt;/tr&gt;
 391  *     &lt;tr&gt;
 392  *         &lt;th&gt;period&lt;/th&gt;
 393  *         &lt;td style=&quot;text-align: center&quot;&gt;a&lt;/td&gt;
 394  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 395  *         &lt;td&gt;AM&lt;/td&gt;
 396  *         &lt;td&gt;AM or PM&lt;/td&gt;
 397  *     &lt;/tr&gt;
 398  *     &lt;tr&gt;
 399  *         &lt;th rowspan=&quot;4&quot;&gt;hour&lt;/th&gt;
 400  *         &lt;td style=&quot;text-align: center&quot;&gt;h&lt;/td&gt;
 401  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 402  *         &lt;td&gt;11&lt;/td&gt;
 403  *         &lt;td&gt;Hour [1-12]. When used in skeleton data or in a skeleton passed in an API for flexible data pattern
 404  *         generation, it should match the 12-hour-cycle format preferred by the locale (h or K); it should not match
 405  *         a 24-hour-cycle format (H or k). Use hh for zero padding.&lt;/td&gt;
 406  *     &lt;/tr&gt;
 407  *     &lt;tr&gt;
 408  *         &lt;td style=&quot;text-align: center&quot;&gt;H&lt;/td&gt;
 409  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 410  *         &lt;td&gt;13&lt;/td&gt;
 411  *         &lt;td&gt;Hour [0-23]. When used in skeleton data or in a skeleton passed in an API for flexible data pattern
 412  *         generation, it should match the 24-hour-cycle format preferred by the locale (H or k); it should not match a
 413  *         12-hour-cycle format (h or K). Use HH for zero padding.&lt;/td&gt;
 414  *     &lt;/tr&gt;
 415  *     &lt;tr&gt;
 416  *         &lt;td style=&quot;text-align: center&quot;&gt;K&lt;/td&gt;
 417  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 418  *         &lt;td&gt;0&lt;/td&gt;
 419  *         &lt;td&gt;Hour [0-11]. When used in a skeleton, only matches K or h, see above. Use KK for zero padding.&lt;/td&gt;
 420  *     &lt;/tr&gt;
 421  *     &lt;tr&gt;
 422  *         &lt;td style=&quot;text-align: center&quot;&gt;k&lt;/td&gt;
 423  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 424  *         &lt;td&gt;24&lt;/td&gt;
 425  *         &lt;td&gt;Hour [1-24]. When used in a skeleton, only matches k or H, see above. Use kk for zero padding.&lt;/td&gt;
 426  *     &lt;/tr&gt;
 427  *     &lt;tr&gt;
 428  *         &lt;th&gt;minute&lt;/th&gt;
 429  *         &lt;td style=&quot;text-align: center&quot;&gt;m&lt;/td&gt;
 430  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 431  *         &lt;td&gt;59&lt;/td&gt;
 432  *         &lt;td&gt;Minute. Use &quot;m&quot; to show the minimum number of digits, or &quot;mm&quot; to always show two digits
 433  *         (zero-padding if necessary, e.g. &quot;08&quot;).&lt;/td&gt;
 434  *     &lt;/tr&gt;
 435  *     &lt;tr&gt;
 436  *         &lt;th rowspan=&quot;3&quot;&gt;second&lt;/th&gt;
 437  *         &lt;td style=&quot;text-align: center&quot;&gt;s&lt;/td&gt;
 438  *         &lt;td style=&quot;text-align: center&quot;&gt;1..2&lt;/td&gt;
 439  *         &lt;td&gt;12&lt;/td&gt;
 440  *         &lt;td&gt;Second. Use &quot;s&quot; to show the minimum number of digits, or &quot;ss&quot; to always show two digits
 441  *         (zero-padding if necessary, e.g. &quot;08&quot;).&lt;/td&gt;
 442  *     &lt;/tr&gt;
 443  *     &lt;tr&gt;
 444  *         &lt;td style=&quot;text-align: center&quot;&gt;S&lt;/td&gt;
 445  *         &lt;td style=&quot;text-align: center&quot;&gt;1..n&lt;/td&gt;
 446  *         &lt;td&gt;3450&lt;/td&gt;
 447  *         &lt;td&gt;Fractional Second - truncates (like other time fields) to the count of letters when formatting.
 448  *         Appends zeros if more than 3 letters specified. Truncates at three significant digits when parsing.
 449  *         (example shows display using pattern SSSS for seconds value 12.34567)&lt;/td&gt;
 450  *     &lt;/tr&gt;
 451  *     &lt;tr&gt;
 452  *         &lt;td style=&quot;text-align: center&quot;&gt;A&lt;/td&gt;
 453  *         &lt;td style=&quot;text-align: center&quot;&gt;1..n&lt;/td&gt;
 454  *         &lt;td&gt;69540000&lt;/td&gt;
 455  *         &lt;td&gt;Milliseconds in day. This field behaves &lt;i&gt;exactly&lt;/i&gt; like a composite of all time-related fields,
 456  *         not including the zone fields. As such, it also reflects discontinuities of those fields on DST transition
 457  *         days. On a day of DST onset, it will jump forward. On a day of DST cessation, it will jump backward. This
 458  *         reflects the fact that is must be combined with the offset field to obtain a unique local time value.&lt;/td&gt;
 459  *     &lt;/tr&gt;
 460  *     &lt;tr&gt;
 461  *         &lt;th rowspan=&quot;23&quot;&gt;zone&lt;/th&gt;
 462  *         &lt;td rowspan=&quot;2&quot; style=&quot;text-align: center&quot;&gt;z&lt;/td&gt;
 463  *         &lt;td style=&quot;text-align: center&quot;&gt;1..3&lt;/td&gt;
 464  *         &lt;td&gt;PDT&lt;/td&gt;
 465  *         &lt;td&gt;The &lt;i&gt;short specific non-location format&lt;/i&gt;.
 466  *         Where that is unavailable, falls back to the &lt;i&gt;short localized GMT format&lt;/i&gt; (&quot;O&quot;).&lt;/td&gt;
 467  *     &lt;/tr&gt;
 468  *     &lt;tr&gt;
 469  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 470  *         &lt;td&gt;Pacific Daylight Time&lt;/td&gt;
 471  *         &lt;td&gt;The &lt;i&gt;long specific non-location format&lt;/i&gt;.
 472  *         Where that is unavailable, falls back to the &lt;i&gt;long localized GMT format&lt;/i&gt; (&quot;OOOO&quot;).&lt;/td&gt;
 473  *     &lt;/tr&gt;
 474  *     &lt;tr&gt;
 475  *         &lt;td rowspan=&quot;3&quot; style=&quot;text-align: center&quot;&gt;Z&lt;/td&gt;
 476  *         &lt;td style=&quot;text-align: center&quot;&gt;1..3&lt;/td&gt;
 477  *         &lt;td&gt;-0800&lt;/td&gt;
 478  *         &lt;td&gt;The &lt;i&gt;ISO8601 basic format&lt;/i&gt; with hours, minutes and optional seconds fields.
 479  *         The format is equivalent to RFC 822 zone format (when optional seconds field is absent).
 480  *         This is equivalent to the &quot;xxxx&quot; specifier.&lt;/td&gt;
 481  *     &lt;/tr&gt;
 482  *     &lt;tr&gt;
 483  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 484  *         &lt;td&gt;GMT-8:00&lt;/td&gt;
 485  *         &lt;td&gt;The &lt;i&gt;long localized GMT format&lt;/i&gt;.
 486  *         This is equivalent to the &quot;OOOO&quot; specifier.&lt;/td&gt;
 487  *     &lt;/tr&gt;
 488  *     &lt;tr&gt;
 489  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 490  *         &lt;td&gt;-08:00&lt;br&gt;
 491  *         -07:52:58&lt;/td&gt;
 492  *         &lt;td&gt;The &lt;i&gt;ISO8601 extended format&lt;/i&gt; with hours, minutes and optional seconds fields.
 493  *         The ISO8601 UTC indicator &quot;Z&quot; is used when local time offset is 0.
 494  *         This is equivalent to the &quot;XXXXX&quot; specifier.&lt;/td&gt;
 495  *     &lt;/tr&gt;
 496  *     &lt;tr&gt;
 497  *         &lt;td rowspan=&quot;2&quot; style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
 498  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 499  *         &lt;td&gt;GMT-8&lt;/td&gt;
 500  *         &lt;td&gt;The &lt;i&gt;short localized GMT format&lt;/i&gt;.&lt;/td&gt;
 501  *     &lt;/tr&gt;
 502  *     &lt;tr&gt;
 503  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 504  *         &lt;td&gt;GMT-08:00&lt;/td&gt;
 505  *         &lt;td&gt;The &lt;i&gt;long localized GMT format&lt;/i&gt;.&lt;/td&gt;
 506  *     &lt;/tr&gt;
 507  *     &lt;tr&gt;
 508  *         &lt;td rowspan=&quot;2&quot; style=&quot;text-align: center&quot;&gt;v&lt;/td&gt;
 509  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 510  *         &lt;td&gt;PT&lt;/td&gt;
 511  *         &lt;td&gt;The &lt;i&gt;short generic non-location format&lt;/i&gt;.
 512  *         Where that is unavailable, falls back to the &lt;i&gt;generic location format&lt;/i&gt; (&quot;VVVV&quot;),
 513  *         then the &lt;i&gt;short localized GMT format&lt;/i&gt; as the final fallback.&lt;/td&gt;
 514  *     &lt;/tr&gt;
 515  *     &lt;tr&gt;
 516  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 517  *         &lt;td&gt;Pacific Time&lt;/td&gt;
 518  *         &lt;td&gt;The &lt;i&gt;long generic non-location format&lt;/i&gt;.
 519  *         Where that is unavailable, falls back to &lt;i&gt;generic location format&lt;/i&gt; (&quot;VVVV&quot;).
 520  *     &lt;/tr&gt;
 521  *     &lt;tr&gt;
 522  *         &lt;td rowspan=&quot;4&quot; style=&quot;text-align: center&quot;&gt;V&lt;/td&gt;
 523  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 524  *         &lt;td&gt;uslax&lt;/td&gt;
 525  *         &lt;td&gt;The short time zone ID.
 526  *         Where that is unavailable, the special short time zone ID &lt;i&gt;unk&lt;/i&gt; (Unknown Zone) is used.&lt;br&gt;
 527  *         &lt;i&gt;&lt;b&gt;Note&lt;/b&gt;: This specifier was originally used for a variant of the short specific non-location format,
 528  *         but it was deprecated in the later version of the LDML specification. In CLDR 23/ICU 51, the definition of
 529  *         the specifier was changed to designate a short time zone ID.&lt;/i&gt;&lt;/td&gt;
 530  *     &lt;/tr&gt;
 531  *     &lt;tr&gt;
 532  *         &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
 533  *         &lt;td&gt;America/Los_Angeles&lt;/td&gt;
 534  *         &lt;td&gt;The long time zone ID.&lt;/td&gt;
 535  *     &lt;/tr&gt;
 536  *     &lt;tr&gt;
 537  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 538  *         &lt;td&gt;Los Angeles&lt;/td&gt;
 539  *         &lt;td&gt;The exemplar city (location) for the time zone.
 540  *         Where that is unavailable, the localized exemplar city name for the special zone &lt;i&gt;Etc/Unknown&lt;/i&gt; is used
 541  *         as the fallback (for example, &quot;Unknown City&quot;). &lt;/td&gt;
 542  *     &lt;/tr&gt;
 543  *     &lt;tr&gt;
 544  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 545  *         &lt;td&gt;Los Angeles Time&lt;/td&gt;
 546  *         &lt;td&gt;The &lt;i&gt;generic location format&lt;/i&gt;.
 547  *         Where that is unavailable, falls back to the &lt;i&gt;long localized GMT format&lt;/i&gt; (&quot;OOOO&quot;;
 548  *         Note: Fallback is only necessary with a GMT-style Time Zone ID, like Etc/GMT-830.)&lt;br&gt;
 549  *         This is especially useful when presenting possible timezone choices for user selection,
 550  *         since the naming is more uniform than the &quot;v&quot; format.&lt;/td&gt;
 551  *     &lt;/tr&gt;
 552  *     &lt;tr&gt;
 553  *         &lt;td rowspan=&quot;5&quot; style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
 554  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 555  *         &lt;td&gt;-08&lt;br&gt;
 556  *         +0530&lt;br&gt;
 557  *         Z&lt;/td&gt;
 558  *         &lt;td&gt;The &lt;i&gt;ISO8601 basic format&lt;/i&gt; with hours field and optional minutes field.
 559  *         The ISO8601 UTC indicator &quot;Z&quot; is used when local time offset is 0.&lt;/td&gt;
 560  *     &lt;/tr&gt;
 561  *     &lt;tr&gt;
 562  *         &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
 563  *         &lt;td&gt;-0800&lt;br&gt;
 564  *         Z&lt;/td&gt;
 565  *         &lt;td&gt;The &lt;i&gt;ISO8601 basic format&lt;/i&gt; with hours and minutes fields.
 566  *         The ISO8601 UTC indicator &quot;Z&quot; is used when local time offset is 0.&lt;/td&gt;
 567  *     &lt;/tr&gt;
 568  *     &lt;tr&gt;
 569  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 570  *         &lt;td&gt;-08:00&lt;br&gt;
 571  *         Z&lt;/td&gt;
 572  *         &lt;td&gt;The &lt;i&gt;ISO8601 extended format&lt;/i&gt; with hours and minutes fields.
 573  *         The ISO8601 UTC indicator &quot;Z&quot; is used when local time offset is 0.&lt;/td&gt;
 574  *     &lt;/tr&gt;
 575  *     &lt;tr&gt;
 576  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 577  *         &lt;td&gt;-0800&lt;br&gt;
 578  *         -075258&lt;br&gt;
 579  *         Z&lt;/td&gt;
 580  *         &lt;td&gt;The &lt;i&gt;ISO8601 basic format&lt;/i&gt; with hours, minutes and optional seconds fields.
 581  *         (Note: The seconds field is not supported by the ISO8601 specification.)
 582  *         The ISO8601 UTC indicator &quot;Z&quot; is used when local time offset is 0.&lt;/td&gt;
 583  *     &lt;/tr&gt;
 584  *     &lt;tr&gt;
 585  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 586  *         &lt;td&gt;-08:00&lt;br&gt;
 587  *         -07:52:58&lt;br&gt;
 588  *         Z&lt;/td&gt;
 589  *         &lt;td&gt;The &lt;i&gt;ISO8601 extended format&lt;/i&gt; with hours, minutes and optional seconds fields.
 590  *         (Note: The seconds field is not supported by the ISO8601 specification.)
 591  *         The ISO8601 UTC indicator &quot;Z&quot; is used when local time offset is 0.&lt;/td&gt;
 592  *     &lt;/tr&gt;
 593  *     &lt;tr&gt;
 594  *         &lt;td rowspan=&quot;5&quot; style=&quot;text-align: center&quot;&gt;x&lt;/td&gt;
 595  *         &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
 596  *         &lt;td&gt;-08&lt;br&gt;
 597  *         +0530&lt;/td&gt;
 598  *         &lt;td&gt;The &lt;i&gt;ISO8601 basic format&lt;/i&gt; with hours field and optional minutes field.&lt;/td&gt;
 599  *     &lt;/tr&gt;
 600  *     &lt;tr&gt;
 601  *         &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
 602  *         &lt;td&gt;-0800&lt;/td&gt;
 603  *         &lt;td&gt;The &lt;i&gt;ISO8601 basic format&lt;/i&gt; with hours and minutes fields.&lt;/td&gt;
 604  *     &lt;/tr&gt;
 605  *     &lt;tr&gt;
 606  *         &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
 607  *         &lt;td&gt;-08:00&lt;/td&gt;
 608  *         &lt;td&gt;The &lt;i&gt;ISO8601 extended format&lt;/i&gt; with hours and minutes fields.&lt;/td&gt;
 609  *     &lt;/tr&gt;
 610  *     &lt;tr&gt;
 611  *         &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
 612  *         &lt;td&gt;-0800&lt;br&gt;
 613  *         -075258&lt;/td&gt;
 614  *         &lt;td&gt;The &lt;i&gt;ISO8601 basic format&lt;/i&gt; with hours, minutes and optional seconds fields.
 615  *         (Note: The seconds field is not supported by the ISO8601 specification.)&lt;/td&gt;
 616  *     &lt;/tr&gt;
 617  *     &lt;tr&gt;
 618  *         &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
 619  *         &lt;td&gt;-08:00&lt;br&gt;
 620  *         -07:52:58&lt;/td&gt;
 621  *         &lt;td&gt;The &lt;i&gt;ISO8601 extended format&lt;/i&gt; with hours, minutes and optional seconds fields.
 622  *         (Note: The seconds field is not supported by the ISO8601 specification.)&lt;/td&gt;
 623  *     &lt;/tr&gt;
 624  * &lt;/table&gt;
 625  *
 626  * &lt;P&gt;
 627  * Any characters in the pattern that are not in the ranges of [&#39;a&#39;..&#39;z&#39;] and
 628  * [&#39;A&#39;..&#39;Z&#39;] will be treated as quoted text. For instance, characters
 629  * like &#39;:&#39;, &#39;.&#39;, &#39; &#39;, &#39;#&#39; and &#39;@&#39; will appear in the resulting time text
 630  * even they are not embraced within single quotes.
 631  * &lt;P&gt;
 632  * A pattern containing any invalid pattern letter will result in a failing
 633  * UErrorCode result during formatting or parsing.
 634  * &lt;P&gt;
 635  * Examples using the US locale:
 636  * &lt;pre&gt;
 637  * \code
 638  *    Format Pattern                         Result
 639  *    --------------                         -------
 640  *    &quot;yyyy.MM.dd G &#39;at&#39; HH:mm:ss vvvv&quot; -&gt;&gt;  1996.07.10 AD at 15:08:56 Pacific Time
 641  *    &quot;EEE, MMM d, &#39;&#39;yy&quot;                -&gt;&gt;  Wed, July 10, &#39;96
 642  *    &quot;h:mm a&quot;                          -&gt;&gt;  12:08 PM
 643  *    &quot;hh &#39;o&#39;&#39;clock&#39; a, zzzz&quot;           -&gt;&gt;  12 o&#39;clock PM, Pacific Daylight Time
 644  *    &quot;K:mm a, vvv&quot;                     -&gt;&gt;  0:00 PM, PT
 645  *    &quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;    -&gt;&gt;  1996.July.10 AD 12:08 PM
 646  * \endcode
 647  * &lt;/pre&gt;
 648  * Code Sample:
 649  * &lt;pre&gt;
 650  * \code
 651  *     UErrorCode success = U_ZERO_ERROR;
 652  *     SimpleTimeZone* pdt = new SimpleTimeZone(-8 * 60 * 60 * 1000, &quot;PST&quot;);
 653  *     pdt-&gt;setStartRule( Calendar::APRIL, 1, Calendar::SUNDAY, 2*60*60*1000);
 654  *     pdt-&gt;setEndRule( Calendar::OCTOBER, -1, Calendar::SUNDAY, 2*60*60*1000);
 655  *
 656  *     // Format the current time.
 657  *     SimpleDateFormat* formatter
 658  *         = new SimpleDateFormat (&quot;yyyy.MM.dd G &#39;at&#39; hh:mm:ss a zzz&quot;, success );
 659  *     GregorianCalendar cal(success);
 660  *     UDate currentTime_1 = cal.getTime(success);
 661  *     FieldPosition fp(FieldPosition::DONT_CARE);
 662  *     UnicodeString dateString;
 663  *     formatter-&gt;format( currentTime_1, dateString, fp );
 664  *     cout &lt;&lt; &quot;result: &quot; &lt;&lt; dateString &lt;&lt; endl;
 665  *
 666  *     // Parse the previous string back into a Date.
 667  *     ParsePosition pp(0);
 668  *     UDate currentTime_2 = formatter-&gt;parse(dateString, pp );
 669  * \endcode
 670  * &lt;/pre&gt;
 671  * In the above example, the time value &quot;currentTime_2&quot; obtained from parsing
 672  * will be equal to currentTime_1. However, they may not be equal if the am/pm
 673  * marker &#39;a&#39; is left out from the format pattern while the &quot;hour in am/pm&quot;
 674  * pattern symbol is used. This information loss can happen when formatting the
 675  * time in PM.
 676  *
 677  * &lt;p&gt;
 678  * When parsing a date string using the abbreviated year pattern (&quot;y&quot; or &quot;yy&quot;),
 679  * SimpleDateFormat must interpret the abbreviated year
 680  * relative to some century.  It does this by adjusting dates to be
 681  * within 80 years before and 20 years after the time the SimpleDateFormat
 682  * instance is created. For example, using a pattern of &quot;MM/dd/yy&quot; and a
 683  * SimpleDateFormat instance created on Jan 1, 1997,  the string
 684  * &quot;01/11/12&quot; would be interpreted as Jan 11, 2012 while the string &quot;05/04/64&quot;
 685  * would be interpreted as May 4, 1964.
 686  * During parsing, only strings consisting of exactly two digits, as defined by
 687  * &lt;code&gt;Unicode::isDigit()&lt;/code&gt;, will be parsed into the default century.
 688  * Any other numeric string, such as a one digit string, a three or more digit
 689  * string, or a two digit string that isn&#39;t all digits (for example, &quot;-1&quot;), is
 690  * interpreted literally.  So &quot;01/02/3&quot; or &quot;01/02/003&quot; are parsed (for the
 691  * Gregorian calendar), using the same pattern, as Jan 2, 3 AD.  Likewise (but
 692  * only in lenient parse mode, the default) &quot;01/02/-3&quot; is parsed as Jan 2, 4 BC.
 693  *
 694  * &lt;p&gt;
 695  * If the year pattern has more than two &#39;y&#39; characters, the year is
 696  * interpreted literally, regardless of the number of digits.  So using the
 697  * pattern &quot;MM/dd/yyyy&quot;, &quot;01/11/12&quot; parses to Jan 11, 12 A.D.
 698  *
 699  * &lt;p&gt;
 700  * When numeric fields abut one another directly, with no intervening delimiter
 701  * characters, they constitute a run of abutting numeric fields.  Such runs are
 702  * parsed specially.  For example, the format &quot;HHmmss&quot; parses the input text
 703  * &quot;123456&quot; to 12:34:56, parses the input text &quot;12345&quot; to 1:23:45, and fails to
 704  * parse &quot;1234&quot;.  In other words, the leftmost field of the run is flexible,
 705  * while the others keep a fixed width.  If the parse fails anywhere in the run,
 706  * then the leftmost field is shortened by one character, and the entire run is
 707  * parsed again. This is repeated until either the parse succeeds or the
 708  * leftmost field is one character in length.  If the parse still fails at that
 709  * point, the parse of the run fails.
 710  *
 711  * &lt;P&gt;
 712  * For time zones that have no names, SimpleDateFormat uses strings GMT+hours:minutes or
 713  * GMT-hours:minutes.
 714  * &lt;P&gt;
 715  * The calendar defines what is the first day of the week, the first week of the
 716  * year, whether hours are zero based or not (0 vs 12 or 24), and the timezone.
 717  * There is one common number format to handle all the numbers; the digit count
 718  * is handled programmatically according to the pattern.
 719  *
 720  * &lt;p&gt;&lt;em&gt;User subclasses are not supported.&lt;/em&gt; While clients may write
 721  * subclasses, such code will not necessarily work and will not be
 722  * guaranteed to work stably from release to release.
 723  */
 724 class U_I18N_API SimpleDateFormat: public DateFormat {
 725 public:
 726     /**
 727      * Construct a SimpleDateFormat using the default pattern for the default
 728      * locale.
 729      * &lt;P&gt;
 730      * [Note:] Not all locales support SimpleDateFormat; for full generality,
 731      * use the factory methods in the DateFormat class.
 732      * @param status    Output param set to success/failure code.
 733      * @stable ICU 2.0
 734      */
 735     SimpleDateFormat(UErrorCode&amp; status);
 736 
 737     /**
 738      * Construct a SimpleDateFormat using the given pattern and the default locale.
 739      * The locale is used to obtain the symbols used in formatting (e.g., the
 740      * names of the months), but not to provide the pattern.
 741      * &lt;P&gt;
 742      * [Note:] Not all locales support SimpleDateFormat; for full generality,
 743      * use the factory methods in the DateFormat class.
 744      * @param pattern    the pattern for the format.
 745      * @param status     Output param set to success/failure code.
 746      * @stable ICU 2.0
 747      */
 748     SimpleDateFormat(const UnicodeString&amp; pattern,
 749                      UErrorCode&amp; status);
 750 
 751     /**
 752      * Construct a SimpleDateFormat using the given pattern, numbering system override, and the default locale.
 753      * The locale is used to obtain the symbols used in formatting (e.g., the
 754      * names of the months), but not to provide the pattern.
 755      * &lt;P&gt;
 756      * A numbering system override is a string containing either the name of a known numbering system,
 757      * or a set of field and numbering system pairs that specify which fields are to be formattied with
 758      * the alternate numbering system.  For example, to specify that all numeric fields in the specified
 759      * date or time pattern are to be rendered using Thai digits, simply specify the numbering system override
 760      * as &quot;thai&quot;.  To specify that just the year portion of the date be formatted using Hebrew numbering,
 761      * use the override string &quot;y=hebrew&quot;.  Numbering system overrides can be combined using a semi-colon
 762      * character in the override string, such as &quot;d=decimal;M=arabic;y=hebrew&quot;, etc.
 763      *
 764      * &lt;P&gt;
 765      * [Note:] Not all locales support SimpleDateFormat; for full generality,
 766      * use the factory methods in the DateFormat class.
 767      * @param pattern    the pattern for the format.
 768      * @param override   the override string.
 769      * @param status     Output param set to success/failure code.
 770      * @stable ICU 4.2
 771      */
 772     SimpleDateFormat(const UnicodeString&amp; pattern,
 773                      const UnicodeString&amp; override,
 774                      UErrorCode&amp; status);
 775 
 776     /**
 777      * Construct a SimpleDateFormat using the given pattern and locale.
 778      * The locale is used to obtain the symbols used in formatting (e.g., the
 779      * names of the months), but not to provide the pattern.
 780      * &lt;P&gt;
 781      * [Note:] Not all locales support SimpleDateFormat; for full generality,
 782      * use the factory methods in the DateFormat class.
 783      * @param pattern    the pattern for the format.
 784      * @param locale     the given locale.
 785      * @param status     Output param set to success/failure code.
 786      * @stable ICU 2.0
 787      */
 788     SimpleDateFormat(const UnicodeString&amp; pattern,
 789                      const Locale&amp; locale,
 790                      UErrorCode&amp; status);
 791 
 792     /**
 793      * Construct a SimpleDateFormat using the given pattern, numbering system override, and locale.
 794      * The locale is used to obtain the symbols used in formatting (e.g., the
 795      * names of the months), but not to provide the pattern.
 796      * &lt;P&gt;
 797      * A numbering system override is a string containing either the name of a known numbering system,
 798      * or a set of field and numbering system pairs that specify which fields are to be formattied with
 799      * the alternate numbering system.  For example, to specify that all numeric fields in the specified
 800      * date or time pattern are to be rendered using Thai digits, simply specify the numbering system override
 801      * as &quot;thai&quot;.  To specify that just the year portion of the date be formatted using Hebrew numbering,
 802      * use the override string &quot;y=hebrew&quot;.  Numbering system overrides can be combined using a semi-colon
 803      * character in the override string, such as &quot;d=decimal;M=arabic;y=hebrew&quot;, etc.
 804      * &lt;P&gt;
 805      * [Note:] Not all locales support SimpleDateFormat; for full generality,
 806      * use the factory methods in the DateFormat class.
 807      * @param pattern    the pattern for the format.
 808      * @param override   the numbering system override.
 809      * @param locale     the given locale.
 810      * @param status     Output param set to success/failure code.
 811      * @stable ICU 4.2
 812      */
 813     SimpleDateFormat(const UnicodeString&amp; pattern,
 814                      const UnicodeString&amp; override,
 815                      const Locale&amp; locale,
 816                      UErrorCode&amp; status);
 817 
 818     /**
 819      * Construct a SimpleDateFormat using the given pattern and locale-specific
 820      * symbol data.  The formatter takes ownership of the DateFormatSymbols object;
 821      * the caller is no longer responsible for deleting it.
 822      * @param pattern           the given pattern for the format.
 823      * @param formatDataToAdopt the symbols to be adopted.
 824      * @param status            Output param set to success/faulure code.
 825      * @stable ICU 2.0
 826      */
 827     SimpleDateFormat(const UnicodeString&amp; pattern,
 828                      DateFormatSymbols* formatDataToAdopt,
 829                      UErrorCode&amp; status);
 830 
 831     /**
 832      * Construct a SimpleDateFormat using the given pattern and locale-specific
 833      * symbol data.  The DateFormatSymbols object is NOT adopted; the caller
 834      * remains responsible for deleting it.
 835      * @param pattern           the given pattern for the format.
 836      * @param formatData        the formatting symbols to be use.
 837      * @param status            Output param set to success/faulure code.
 838      * @stable ICU 2.0
 839      */
 840     SimpleDateFormat(const UnicodeString&amp; pattern,
 841                      const DateFormatSymbols&amp; formatData,
 842                      UErrorCode&amp; status);
 843 
 844     /**
 845      * Copy constructor.
 846      * @stable ICU 2.0
 847      */
 848     SimpleDateFormat(const SimpleDateFormat&amp;);
 849 
 850     /**
 851      * Assignment operator.
 852      * @stable ICU 2.0
 853      */
 854     SimpleDateFormat&amp; operator=(const SimpleDateFormat&amp;);
 855 
 856     /**
 857      * Destructor.
 858      * @stable ICU 2.0
 859      */
 860     virtual ~SimpleDateFormat();
 861 
 862     /**
 863      * Clone this Format object polymorphically. The caller owns the result and
 864      * should delete it when done.
 865      * @return    A copy of the object.
 866      * @stable ICU 2.0
 867      */
 868     virtual Format* clone(void) const;
 869 
 870     /**
 871      * Return true if the given Format objects are semantically equal. Objects
 872      * of different subclasses are considered unequal.
 873      * @param other    the object to be compared with.
 874      * @return         true if the given Format objects are semantically equal.
 875      * @stable ICU 2.0
 876      */
 877     virtual UBool operator==(const Format&amp; other) const;
 878 
 879 
 880     using DateFormat::format;
 881 
 882     /**
 883      * Format a date or time, which is the standard millis since 24:00 GMT, Jan
 884      * 1, 1970. Overrides DateFormat pure virtual method.
 885      * &lt;P&gt;
 886      * Example: using the US locale: &quot;yyyy.MM.dd e &#39;at&#39; HH:mm:ss zzz&quot; -&gt;&gt;
 887      * 1996.07.10 AD at 15:08:56 PDT
 888      *
 889      * @param cal       Calendar set to the date and time to be formatted
 890      *                  into a date/time string.
 891      * @param appendTo  Output parameter to receive result.
 892      *                  Result is appended to existing contents.
 893      * @param pos       The formatting position. On input: an alignment field,
 894      *                  if desired. On output: the offsets of the alignment field.
 895      * @return          Reference to &#39;appendTo&#39; parameter.
 896      * @stable ICU 2.1
 897      */
 898     virtual UnicodeString&amp; format(  Calendar&amp; cal,
 899                                     UnicodeString&amp; appendTo,
 900                                     FieldPosition&amp; pos) const;
 901 
 902     /**
 903      * Format a date or time, which is the standard millis since 24:00 GMT, Jan
 904      * 1, 1970. Overrides DateFormat pure virtual method.
 905      * &lt;P&gt;
 906      * Example: using the US locale: &quot;yyyy.MM.dd e &#39;at&#39; HH:mm:ss zzz&quot; -&gt;&gt;
 907      * 1996.07.10 AD at 15:08:56 PDT
 908      *
 909      * @param cal       Calendar set to the date and time to be formatted
 910      *                  into a date/time string.
 911      * @param appendTo  Output parameter to receive result.
 912      *                  Result is appended to existing contents.
 913      * @param posIter   On return, can be used to iterate over positions
 914      *                  of fields generated by this format call.  Field values
 915      *                  are defined in UDateFormatField.
 916      * @param status    Input/output param set to success/failure code.
 917      * @return          Reference to &#39;appendTo&#39; parameter.
 918      * @stable ICU 4.4
 919      */
 920     virtual UnicodeString&amp; format(  Calendar&amp; cal,
 921                                     UnicodeString&amp; appendTo,
 922                                     FieldPositionIterator* posIter,
 923                                     UErrorCode&amp; status) const;
 924 
 925     using DateFormat::parse;
 926 
 927     /**
 928      * Parse a date/time string beginning at the given parse position. For
 929      * example, a time text &quot;07/10/96 4:5 PM, PDT&quot; will be parsed into a Date
 930      * that is equivalent to Date(837039928046).
 931      * &lt;P&gt;
 932      * By default, parsing is lenient: If the input is not in the form used by
 933      * this object&#39;s format method but can still be parsed as a date, then the
 934      * parse succeeds. Clients may insist on strict adherence to the format by
 935      * calling setLenient(false).
 936      * @see DateFormat::setLenient(boolean)
 937      *
 938      * @param text  The date/time string to be parsed
 939      * @param cal   A Calendar set on input to the date and time to be used for
 940      *              missing values in the date/time string being parsed, and set
 941      *              on output to the parsed date/time. When the calendar type is
 942      *              different from the internal calendar held by this SimpleDateFormat
 943      *              instance, the internal calendar will be cloned to a work
 944      *              calendar set to the same milliseconds and time zone as the
 945      *              cal parameter, field values will be parsed based on the work
 946      *              calendar, then the result (milliseconds and time zone) will
 947      *              be set in this calendar.
 948      * @param pos   On input, the position at which to start parsing; on
 949      *              output, the position at which parsing terminated, or the
 950      *              start position if the parse failed.
 951      * @stable ICU 2.1
 952      */
 953     virtual void parse( const UnicodeString&amp; text,
 954                         Calendar&amp; cal,
 955                         ParsePosition&amp; pos) const;
 956 
 957 
 958     /**
 959      * Set the start UDate used to interpret two-digit year strings.
 960      * When dates are parsed having 2-digit year strings, they are placed within
 961      * a assumed range of 100 years starting on the two digit start date.  For
 962      * example, the string &quot;24-Jan-17&quot; may be in the year 1817, 1917, 2017, or
 963      * some other year.  SimpleDateFormat chooses a year so that the resultant
 964      * date is on or after the two digit start date and within 100 years of the
 965      * two digit start date.
 966      * &lt;P&gt;
 967      * By default, the two digit start date is set to 80 years before the current
 968      * time at which a SimpleDateFormat object is created.
 969      * @param d      start UDate used to interpret two-digit year strings.
 970      * @param status Filled in with U_ZERO_ERROR if the parse was successful, and with
 971      *               an error value if there was a parse error.
 972      * @stable ICU 2.0
 973      */
 974     virtual void set2DigitYearStart(UDate d, UErrorCode&amp; status);
 975 
 976     /**
 977      * Get the start UDate used to interpret two-digit year strings.
 978      * When dates are parsed having 2-digit year strings, they are placed within
 979      * a assumed range of 100 years starting on the two digit start date.  For
 980      * example, the string &quot;24-Jan-17&quot; may be in the year 1817, 1917, 2017, or
 981      * some other year.  SimpleDateFormat chooses a year so that the resultant
 982      * date is on or after the two digit start date and within 100 years of the
 983      * two digit start date.
 984      * &lt;P&gt;
 985      * By default, the two digit start date is set to 80 years before the current
 986      * time at which a SimpleDateFormat object is created.
 987      * @param status Filled in with U_ZERO_ERROR if the parse was successful, and with
 988      *               an error value if there was a parse error.
 989      * @stable ICU 2.0
 990      */
 991     UDate get2DigitYearStart(UErrorCode&amp; status) const;
 992 
 993     /**
 994      * Return a pattern string describing this date format.
 995      * @param result Output param to receive the pattern.
 996      * @return       A reference to &#39;result&#39;.
 997      * @stable ICU 2.0
 998      */
 999     virtual UnicodeString&amp; toPattern(UnicodeString&amp; result) const;
1000 
1001     /**
1002      * Return a localized pattern string describing this date format.
1003      * In most cases, this will return the same thing as toPattern(),
1004      * but a locale can specify characters to use in pattern descriptions
1005      * in place of the ones described in this class&#39;s class documentation.
1006      * (Presumably, letters that would be more mnemonic in that locale&#39;s
1007      * language.)  This function would produce a pattern using those
1008      * letters.
1009      * &lt;p&gt;
1010      * &lt;b&gt;Note:&lt;/b&gt; This implementation depends on DateFormatSymbols::getLocalPatternChars()
1011      * to get localized format pattern characters. ICU does not include
1012      * localized pattern character data, therefore, unless user sets localized
1013      * pattern characters manually, this method returns the same result as
1014      * toPattern().
1015      *
1016      * @param result    Receives the localized pattern.
1017      * @param status    Output param set to success/failure code on
1018      *                  exit. If the pattern is invalid, this will be
1019      *                  set to a failure result.
1020      * @return          A reference to &#39;result&#39;.
1021      * @stable ICU 2.0
1022      */
1023     virtual UnicodeString&amp; toLocalizedPattern(UnicodeString&amp; result,
1024                                               UErrorCode&amp; status) const;
1025 
1026     /**
1027      * Apply the given unlocalized pattern string to this date format.
1028      * (i.e., after this call, this formatter will format dates according to
1029      * the new pattern)
1030      *
1031      * @param pattern   The pattern to be applied.
1032      * @stable ICU 2.0
1033      */
1034     virtual void applyPattern(const UnicodeString&amp; pattern);
1035 
1036     /**
1037      * Apply the given localized pattern string to this date format.
1038      * (see toLocalizedPattern() for more information on localized patterns.)
1039      *
1040      * @param pattern   The localized pattern to be applied.
1041      * @param status    Output param set to success/failure code on
1042      *                  exit. If the pattern is invalid, this will be
1043      *                  set to a failure result.
1044      * @stable ICU 2.0
1045      */
1046     virtual void applyLocalizedPattern(const UnicodeString&amp; pattern,
1047                                        UErrorCode&amp; status);
1048 
1049     /**
1050      * Gets the date/time formatting symbols (this is an object carrying
1051      * the various strings and other symbols used in formatting: e.g., month
1052      * names and abbreviations, time zone names, AM/PM strings, etc.)
1053      * @return a copy of the date-time formatting data associated
1054      * with this date-time formatter.
1055      * @stable ICU 2.0
1056      */
1057     virtual const DateFormatSymbols* getDateFormatSymbols(void) const;
1058 
1059     /**
1060      * Set the date/time formatting symbols.  The caller no longer owns the
1061      * DateFormatSymbols object and should not delete it after making this call.
1062      * @param newFormatSymbols the given date-time formatting symbols to copy.
1063      * @stable ICU 2.0
1064      */
1065     virtual void adoptDateFormatSymbols(DateFormatSymbols* newFormatSymbols);
1066 
1067     /**
1068      * Set the date/time formatting data.
1069      * @param newFormatSymbols the given date-time formatting symbols to copy.
1070      * @stable ICU 2.0
1071      */
1072     virtual void setDateFormatSymbols(const DateFormatSymbols&amp; newFormatSymbols);
1073 
1074     /**
1075      * Return the class ID for this class. This is useful only for comparing to
1076      * a return value from getDynamicClassID(). For example:
1077      * &lt;pre&gt;
1078      * .   Base* polymorphic_pointer = createPolymorphicObject();
1079      * .   if (polymorphic_pointer-&gt;getDynamicClassID() ==
1080      * .       erived::getStaticClassID()) ...
1081      * &lt;/pre&gt;
1082      * @return          The class ID for all objects of this class.
1083      * @stable ICU 2.0
1084      */
1085     static UClassID U_EXPORT2 getStaticClassID(void);
1086 
1087     /**
1088      * Returns a unique class ID POLYMORPHICALLY. Pure virtual override. This
1089      * method is to implement a simple version of RTTI, since not all C++
1090      * compilers support genuine RTTI. Polymorphic operator==() and clone()
1091      * methods call this method.
1092      *
1093      * @return          The class ID for this object. All objects of a
1094      *                  given class have the same class ID.  Objects of
1095      *                  other classes have different class IDs.
1096      * @stable ICU 2.0
1097      */
1098     virtual UClassID getDynamicClassID(void) const;
1099 
1100     /**
1101      * Set the calendar to be used by this date format. Initially, the default
1102      * calendar for the specified or default locale is used.  The caller should
1103      * not delete the Calendar object after it is adopted by this call.
1104      * Adopting a new calendar will change to the default symbols.
1105      *
1106      * @param calendarToAdopt    Calendar object to be adopted.
1107      * @stable ICU 2.0
1108      */
1109     virtual void adoptCalendar(Calendar* calendarToAdopt);
1110 
1111     /* Cannot use #ifndef U_HIDE_INTERNAL_API for the following methods since they are virtual */
1112     /**
1113      * Sets the TimeZoneFormat to be used by this date/time formatter.
1114      * The caller should not delete the TimeZoneFormat object after
1115      * it is adopted by this call.
1116      * @param timeZoneFormatToAdopt The TimeZoneFormat object to be adopted.
1117      * @internal ICU 49 technology preview
1118      */
1119     virtual void adoptTimeZoneFormat(TimeZoneFormat* timeZoneFormatToAdopt);
1120 
1121     /**
1122      * Sets the TimeZoneFormat to be used by this date/time formatter.
1123      * @param newTimeZoneFormat The TimeZoneFormat object to copy.
1124      * @internal ICU 49 technology preview
1125      */
1126     virtual void setTimeZoneFormat(const TimeZoneFormat&amp; newTimeZoneFormat);
1127 
1128     /**
1129      * Gets the time zone format object associated with this date/time formatter.
1130      * @return the time zone format associated with this date/time formatter.
1131      * @internal ICU 49 technology preview
1132      */
1133     virtual const TimeZoneFormat* getTimeZoneFormat(void) const;
1134 
1135     /**
1136      * Set a particular UDisplayContext value in the formatter, such as
1137      * UDISPCTX_CAPITALIZATION_FOR_STANDALONE. Note: For getContext, see
1138      * DateFormat.
1139      * @param value The UDisplayContext value to set.
1140      * @param status Input/output status. If at entry this indicates a failure
1141      *               status, the function will do nothing; otherwise this will be
1142      *               updated with any new status from the function.
1143      * @stable ICU 53
1144      */
1145     virtual void setContext(UDisplayContext value, UErrorCode&amp; status);
1146 
1147     /**
1148      * Overrides base class method and
1149      * This method clears per field NumberFormat instances
1150      * previously set by {@see adoptNumberFormat(const UnicodeString&amp;, NumberFormat*, UErrorCode)}
<a name="2" id="anc2"></a><span class="line-modified">1151      * @param formatToAdopt the NumbeferFormat used</span>
1152      * @stable ICU 54
1153      */
1154     void adoptNumberFormat(NumberFormat *formatToAdopt);
1155 
1156     /**
1157      * Allow the user to set the NumberFormat for several fields
1158      * It can be a single field like: &quot;y&quot;(year) or &quot;M&quot;(month)
1159      * It can be several field combined together: &quot;yM&quot;(year and month)
1160      * Note:
1161      * 1 symbol field is enough for multiple symbol field (so &quot;y&quot; will override &quot;yy&quot;, &quot;yyy&quot;)
1162      * If the field is not numeric, then override has no effect (like &quot;MMM&quot; will use abbreviation, not numerical field)
1163      * Per field NumberFormat can also be cleared in {@see DateFormat::setNumberFormat(const NumberFormat&amp; newNumberFormat)}
1164      *
1165      * @param fields  the fields to override(like y)
<a name="3" id="anc3"></a><span class="line-modified">1166      * @param formatToAdopt the NumbeferFormat used</span>
1167      * @param status  Receives a status code, which will be U_ZERO_ERROR
1168      *                if the operation succeeds.
1169      * @stable ICU 54
1170      */
1171     void adoptNumberFormat(const UnicodeString&amp; fields, NumberFormat *formatToAdopt, UErrorCode &amp;status);
1172 
1173     /**
1174      * Get the numbering system to be used for a particular field.
1175      * @param field The UDateFormatField to get
1176      * @stable ICU 54
1177      */
1178     const NumberFormat * getNumberFormatForField(char16_t field) const;
1179 
1180 #ifndef U_HIDE_INTERNAL_API
1181     /**
1182      * This is for ICU internal use only. Please do not use.
1183      * Check whether the &#39;field&#39; is smaller than all the fields covered in
1184      * pattern, return TRUE if it is. The sequence of calendar field,
1185      * from large to small is: ERA, YEAR, MONTH, DATE, AM_PM, HOUR, MINUTE,...
1186      * @param field    the calendar field need to check against
1187      * @return         TRUE if the &#39;field&#39; is smaller than all the fields
1188      *                 covered in pattern. FALSE otherwise.
1189      * @internal ICU 4.0
1190      */
1191     UBool isFieldUnitIgnored(UCalendarDateFields field) const;
1192 
1193 
1194     /**
1195      * This is for ICU internal use only. Please do not use.
1196      * Check whether the &#39;field&#39; is smaller than all the fields covered in
1197      * pattern, return TRUE if it is. The sequence of calendar field,
1198      * from large to small is: ERA, YEAR, MONTH, DATE, AM_PM, HOUR, MINUTE,...
1199      * @param pattern  the pattern to check against
1200      * @param field    the calendar field need to check against
1201      * @return         TRUE if the &#39;field&#39; is smaller than all the fields
1202      *                 covered in pattern. FALSE otherwise.
1203      * @internal ICU 4.0
1204      */
1205     static UBool isFieldUnitIgnored(const UnicodeString&amp; pattern,
1206                                     UCalendarDateFields field);
1207 
1208     /**
1209      * This is for ICU internal use only. Please do not use.
1210      * Get the locale of this simple date formatter.
1211      * It is used in DateIntervalFormat.
1212      *
1213      * @return   locale in this simple date formatter
1214      * @internal ICU 4.0
1215      */
1216     const Locale&amp; getSmpFmtLocale(void) const;
1217 #endif  /* U_HIDE_INTERNAL_API */
1218 
1219 private:
1220     friend class DateFormat;
<a name="4" id="anc4"></a><span class="line-added">1221     friend class DateIntervalFormat;</span>
1222 
1223     void initializeDefaultCentury(void);
1224 
1225     void initializeBooleanAttributes(void);
1226 
1227     SimpleDateFormat(); // default constructor not implemented
1228 
1229     /**
1230      * Used by the DateFormat factory methods to construct a SimpleDateFormat.
1231      * @param timeStyle the time style.
1232      * @param dateStyle the date style.
1233      * @param locale    the given locale.
1234      * @param status    Output param set to success/failure code on
1235      *                  exit.
1236      */
1237     SimpleDateFormat(EStyle timeStyle, EStyle dateStyle, const Locale&amp; locale, UErrorCode&amp; status);
1238 
1239     /**
1240      * Construct a SimpleDateFormat for the given locale.  If no resource data
1241      * is available, create an object of last resort, using hard-coded strings.
1242      * This is an internal method, called by DateFormat.  It should never fail.
1243      * @param locale    the given locale.
1244      * @param status    Output param set to success/failure code on
1245      *                  exit.
1246      */
1247     SimpleDateFormat(const Locale&amp; locale, UErrorCode&amp; status); // Use default pattern
1248 
1249     /**
1250      * Hook called by format(... FieldPosition&amp; ...) and format(...FieldPositionIterator&amp;...)
1251      */
1252     UnicodeString&amp; _format(Calendar&amp; cal, UnicodeString&amp; appendTo, FieldPositionHandler&amp; handler, UErrorCode&amp; status) const;
1253 
1254     /**
1255      * Called by format() to format a single field.
1256      *
1257      * @param appendTo  Output parameter to receive result.
1258      *                  Result is appended to existing contents.
1259      * @param ch        The format character we encountered in the pattern.
1260      * @param count     Number of characters in the current pattern symbol (e.g.,
1261      *                  &quot;yyyy&quot; in the pattern would result in a call to this function
1262      *                  with ch equal to &#39;y&#39; and count equal to 4)
1263      * @param capitalizationContext Capitalization context for this date format.
1264      * @param fieldNum  Zero-based numbering of current field within the overall format.
1265      * @param handler   Records information about field positions.
1266      * @param cal       Calendar to use
1267      * @param status    Receives a status code, which will be U_ZERO_ERROR if the operation
1268      *                  succeeds.
1269      */
1270     void subFormat(UnicodeString &amp;appendTo,
1271                    char16_t ch,
1272                    int32_t count,
1273                    UDisplayContext capitalizationContext,
1274                    int32_t fieldNum,
1275                    FieldPositionHandler&amp; handler,
1276                    Calendar&amp; cal,
1277                    UErrorCode&amp; status) const; // in case of illegal argument
1278 
1279     /**
1280      * Used by subFormat() to format a numeric value.
1281      * Appends to toAppendTo a string representation of &quot;value&quot;
1282      * having a number of digits between &quot;minDigits&quot; and
1283      * &quot;maxDigits&quot;.  Uses the DateFormat&#39;s NumberFormat.
1284      *
1285      * @param currentNumberFormat
1286      * @param appendTo  Output parameter to receive result.
1287      *                  Formatted number is appended to existing contents.
1288      * @param value     Value to format.
1289      * @param minDigits Minimum number of digits the result should have
1290      * @param maxDigits Maximum number of digits the result should have
1291      */
1292     void zeroPaddingNumber(const NumberFormat *currentNumberFormat,
1293                            UnicodeString &amp;appendTo,
1294                            int32_t value,
1295                            int32_t minDigits,
1296                            int32_t maxDigits) const;
1297 
1298     /**
1299      * Return true if the given format character, occuring count
1300      * times, represents a numeric field.
1301      */
1302     static UBool isNumeric(char16_t formatChar, int32_t count);
1303 
1304     /**
1305      * Returns TRUE if the patternOffset is at the start of a numeric field.
1306      */
1307     static UBool isAtNumericField(const UnicodeString &amp;pattern, int32_t patternOffset);
1308 
1309     /**
1310      * Returns TRUE if the patternOffset is right after a non-numeric field.
1311      */
1312     static UBool isAfterNonNumericField(const UnicodeString &amp;pattern, int32_t patternOffset);
1313 
1314     /**
1315      * initializes fCalendar from parameters.  Returns fCalendar as a convenience.
1316      * @param adoptZone  Zone to be adopted, or NULL for TimeZone::createDefault().
1317      * @param locale Locale of the calendar
1318      * @param status Error code
1319      * @return the newly constructed fCalendar
1320      */
1321     Calendar *initializeCalendar(TimeZone* adoptZone, const Locale&amp; locale, UErrorCode&amp; status);
1322 
1323     /**
1324      * Called by several of the constructors to load pattern data and formatting symbols
1325      * out of a resource bundle and initialize the locale based on it.
1326      * @param timeStyle     The time style, as passed to DateFormat::createDateInstance().
1327      * @param dateStyle     The date style, as passed to DateFormat::createTimeInstance().
1328      * @param locale        The locale to load the patterns from.
1329      * @param status        Filled in with an error code if loading the data from the
1330      *                      resources fails.
1331      */
1332     void construct(EStyle timeStyle, EStyle dateStyle, const Locale&amp; locale, UErrorCode&amp; status);
1333 
1334     /**
1335      * Called by construct() and the various constructors to set up the SimpleDateFormat&#39;s
1336      * Calendar and NumberFormat objects.
1337      * @param locale    The locale for which we want a Calendar and a NumberFormat.
1338      * @param status    Filled in with an error code if creating either subobject fails.
1339      */
1340     void initialize(const Locale&amp; locale, UErrorCode&amp; status);
1341 
1342     /**
1343      * Private code-size reduction function used by subParse.
1344      * @param text the time text being parsed.
1345      * @param start where to start parsing.
1346      * @param field the date field being parsed.
1347      * @param stringArray the string array to parsed.
1348      * @param stringArrayCount the size of the array.
1349      * @param monthPattern pointer to leap month pattern, or NULL if none.
1350      * @param cal a Calendar set to the date and time to be formatted
1351      *            into a date/time string.
1352      * @return the new start position if matching succeeded; a negative number
1353      * indicating matching failure, otherwise.
1354      */
1355     int32_t matchString(const UnicodeString&amp; text, int32_t start, UCalendarDateFields field,
1356                         const UnicodeString* stringArray, int32_t stringArrayCount,
1357                         const UnicodeString* monthPattern, Calendar&amp; cal) const;
1358 
1359     /**
1360      * Private code-size reduction function used by subParse.
1361      * @param text the time text being parsed.
1362      * @param start where to start parsing.
1363      * @param field the date field being parsed.
1364      * @param stringArray the string array to parsed.
1365      * @param stringArrayCount the size of the array.
1366      * @param cal a Calendar set to the date and time to be formatted
1367      *            into a date/time string.
1368      * @return the new start position if matching succeeded; a negative number
1369      * indicating matching failure, otherwise.
1370      */
1371     int32_t matchQuarterString(const UnicodeString&amp; text, int32_t start, UCalendarDateFields field,
1372                                const UnicodeString* stringArray, int32_t stringArrayCount, Calendar&amp; cal) const;
1373 
1374     /**
1375      * Used by subParse() to match localized day period strings.
1376      */
1377     int32_t matchDayPeriodStrings(const UnicodeString&amp; text, int32_t start,
1378                                   const UnicodeString* stringArray, int32_t stringArrayCount,
1379                                   int32_t &amp;dayPeriod) const;
1380 
1381     /**
1382      * Private function used by subParse to match literal pattern text.
1383      *
1384      * @param pattern the pattern string
1385      * @param patternOffset the starting offset into the pattern text. On
1386      *        outupt will be set the offset of the first non-literal character in the pattern
1387      * @param text the text being parsed
1388      * @param textOffset the starting offset into the text. On output
1389      *                   will be set to the offset of the character after the match
1390      * @param whitespaceLenient &lt;code&gt;TRUE&lt;/code&gt; if whitespace parse is lenient, &lt;code&gt;FALSE&lt;/code&gt; otherwise.
1391      * @param partialMatchLenient &lt;code&gt;TRUE&lt;/code&gt; if partial match parse is lenient, &lt;code&gt;FALSE&lt;/code&gt; otherwise.
1392      * @param oldLeniency &lt;code&gt;TRUE&lt;/code&gt; if old leniency control is lenient, &lt;code&gt;FALSE&lt;/code&gt; otherwise.
1393      *
1394      * @return &lt;code&gt;TRUE&lt;/code&gt; if the literal text could be matched, &lt;code&gt;FALSE&lt;/code&gt; otherwise.
1395      */
1396     static UBool matchLiterals(const UnicodeString &amp;pattern, int32_t &amp;patternOffset,
1397                                const UnicodeString &amp;text, int32_t &amp;textOffset,
1398                                UBool whitespaceLenient, UBool partialMatchLenient, UBool oldLeniency);
1399 
1400     /**
1401      * Private member function that converts the parsed date strings into
1402      * timeFields. Returns -start (for ParsePosition) if failed.
1403      * @param text the time text to be parsed.
1404      * @param start where to start parsing.
1405      * @param ch the pattern character for the date field text to be parsed.
1406      * @param count the count of a pattern character.
1407      * @param obeyCount if true then the count is strictly obeyed.
1408      * @param allowNegative
1409      * @param ambiguousYear If true then the two-digit year == the default start year.
1410      * @param saveHebrewMonth Used to hang onto month until year is known.
1411      * @param cal a Calendar set to the date and time to be formatted
1412      *            into a date/time string.
1413      * @param patLoc
1414      * @param numericLeapMonthFormatter If non-null, used to parse numeric leap months.
1415      * @param tzTimeType the type of parsed time zone - standard, daylight or unknown (output).
1416      *      This parameter can be NULL if caller does not need the information.
1417      * @return the new start position if matching succeeded; a negative number
1418      * indicating matching failure, otherwise.
1419      */
1420     int32_t subParse(const UnicodeString&amp; text, int32_t&amp; start, char16_t ch, int32_t count,
1421                      UBool obeyCount, UBool allowNegative, UBool ambiguousYear[], int32_t&amp; saveHebrewMonth, Calendar&amp; cal,
1422                      int32_t patLoc, MessageFormat * numericLeapMonthFormatter, UTimeZoneFormatTimeType *tzTimeType,
1423                      int32_t *dayPeriod=NULL) const;
1424 
1425     void parseInt(const UnicodeString&amp; text,
1426                   Formattable&amp; number,
1427                   ParsePosition&amp; pos,
1428                   UBool allowNegative,
1429                   const NumberFormat *fmt) const;
1430 
1431     void parseInt(const UnicodeString&amp; text,
1432                   Formattable&amp; number,
1433                   int32_t maxDigits,
1434                   ParsePosition&amp; pos,
1435                   UBool allowNegative,
1436                   const NumberFormat *fmt) const;
1437 
1438     int32_t checkIntSuffix(const UnicodeString&amp; text, int32_t start,
1439                            int32_t patLoc, UBool isNegative) const;
1440 
1441     /**
1442      * Counts number of digit code points in the specified text.
1443      *
1444      * @param text  input text
1445      * @param start start index, inclusive
1446      * @param end   end index, exclusive
1447      * @return  number of digits found in the text in the specified range.
1448     */
1449     int32_t countDigits(const UnicodeString&amp; text, int32_t start, int32_t end) const;
1450 
1451     /**
1452      * Translate a pattern, mapping each character in the from string to the
1453      * corresponding character in the to string. Return an error if the original
1454      * pattern contains an unmapped character, or if a quote is unmatched.
1455      * Quoted (single quotes only) material is not translated.
1456      * @param originalPattern   the original pattern.
1457      * @param translatedPattern Output param to receive the translited pattern.
1458      * @param from              the characters to be translited from.
1459      * @param to                the characters to be translited to.
1460      * @param status            Receives a status code, which will be U_ZERO_ERROR
1461      *                          if the operation succeeds.
1462      */
1463     static void translatePattern(const UnicodeString&amp; originalPattern,
1464                                 UnicodeString&amp; translatedPattern,
1465                                 const UnicodeString&amp; from,
1466                                 const UnicodeString&amp; to,
1467                                 UErrorCode&amp; status);
1468 
1469     /**
1470      * Sets the starting date of the 100-year window that dates with 2-digit years
1471      * are considered to fall within.
1472      * @param startDate the start date
1473      * @param status    Receives a status code, which will be U_ZERO_ERROR
1474      *                  if the operation succeeds.
1475      */
1476     void         parseAmbiguousDatesAsAfter(UDate startDate, UErrorCode&amp; status);
1477 
1478     /**
1479      * Return the length matched by the given affix, or -1 if none.
1480      * Runs of white space in the affix, match runs of white space in
1481      * the input.
1482      * @param affix pattern string, taken as a literal
1483      * @param input input text
1484      * @param pos offset into input at which to begin matching
1485      * @return length of input that matches, or -1 if match failure
1486      */
1487     int32_t compareSimpleAffix(const UnicodeString&amp; affix,
1488                    const UnicodeString&amp; input,
1489                    int32_t pos) const;
1490 
1491     /**
1492      * Skip over a run of zero or more Pattern_White_Space characters at
1493      * pos in text.
1494      */
1495     int32_t skipPatternWhiteSpace(const UnicodeString&amp; text, int32_t pos) const;
1496 
1497     /**
1498      * Skip over a run of zero or more isUWhiteSpace() characters at pos
1499      * in text.
1500      */
1501     int32_t skipUWhiteSpace(const UnicodeString&amp; text, int32_t pos) const;
1502 
1503     /**
1504      * Initialize LocalizedNumberFormatter instances used for speedup.
1505      */
1506     void initFastNumberFormatters(UErrorCode&amp; status);
1507 
1508     /**
1509      * Delete the LocalizedNumberFormatter instances used for speedup.
1510      */
1511     void freeFastNumberFormatters();
1512 
1513     /**
1514      * Initialize NumberFormat instances used for numbering system overrides.
1515      */
1516     void initNumberFormatters(const Locale &amp;locale,UErrorCode &amp;status);
1517 
1518     /**
1519      * Parse the given override string and set up structures for number formats
1520      */
1521     void processOverrideString(const Locale &amp;locale, const UnicodeString &amp;str, int8_t type, UErrorCode &amp;status);
1522 
1523     /**
1524      * Used to map pattern characters to Calendar field identifiers.
1525      */
1526     static const UCalendarDateFields fgPatternIndexToCalendarField[];
1527 
1528     /**
1529      * Map index into pattern character string to DateFormat field number
1530      */
1531     static const UDateFormatField fgPatternIndexToDateFormatField[];
1532 
1533     /**
1534      * Lazy TimeZoneFormat instantiation, semantically const
1535      */
1536     TimeZoneFormat *tzFormat(UErrorCode &amp;status) const;
1537 
1538     const NumberFormat* getNumberFormatByIndex(UDateFormatField index) const;
1539 
1540     /**
1541      * Used to map Calendar field to field level.
1542      * The larger the level, the smaller the field unit.
1543      * For example, UCAL_ERA level is 0, UCAL_YEAR level is 10,
1544      * UCAL_MONTH level is 20.
1545      */
1546     static const int32_t fgCalendarFieldToLevel[];
1547 
1548     /**
1549      * Map calendar field letter into calendar field level.
1550      */
1551     static int32_t getLevelFromChar(char16_t ch);
1552 
1553     /**
1554      * Tell if a character can be used to define a field in a format string.
1555      */
1556     static UBool isSyntaxChar(char16_t ch);
1557 
1558     /**
1559      * The formatting pattern for this formatter.
1560      */
1561     UnicodeString       fPattern;
1562 
1563     /**
1564      * The numbering system override for dates.
1565      */
1566     UnicodeString       fDateOverride;
1567 
1568     /**
1569      * The numbering system override for times.
1570      */
1571     UnicodeString       fTimeOverride;
1572 
1573 
1574     /**
1575      * The original locale used (for reloading symbols)
1576      */
1577     Locale              fLocale;
1578 
1579     /**
1580      * A pointer to an object containing the strings to use in formatting (e.g.,
1581      * month and day names, AM and PM strings, time zone names, etc.)
1582      */
1583     DateFormatSymbols*  fSymbols;   // Owned
1584 
1585     /**
1586      * The time zone formatter
1587      */
1588     TimeZoneFormat* fTimeZoneFormat;
1589 
1590     /**
1591      * If dates have ambiguous years, we map them into the century starting
1592      * at defaultCenturyStart, which may be any date.  If defaultCenturyStart is
1593      * set to SYSTEM_DEFAULT_CENTURY, which it is by default, then the system
1594      * values are used.  The instance values defaultCenturyStart and
1595      * defaultCenturyStartYear are only used if explicitly set by the user
1596      * through the API method parseAmbiguousDatesAsAfter().
1597      */
1598     UDate                fDefaultCenturyStart;
1599 
1600     UBool                fHasMinute;
1601     UBool                fHasSecond;
<a name="5" id="anc5"></a><span class="line-added">1602     UBool                fHasHanYearChar; // pattern contains the Han year character \u5E74</span>
1603 
1604     /**
1605      * Sets fHasMinutes and fHasSeconds.
1606      */
1607     void                 parsePattern();
1608 
1609     /**
1610      * See documentation for defaultCenturyStart.
1611      */
1612     /*transient*/ int32_t   fDefaultCenturyStartYear;
1613 
1614     struct NSOverride : public UMemory {
1615         const SharedNumberFormat *snf;
1616         int32_t hash;
1617         NSOverride *next;
1618         void free();
1619         NSOverride() : snf(NULL), hash(0), next(NULL) {
1620         }
1621         ~NSOverride();
1622     };
1623 
1624     /**
1625      * The number format in use for each date field. NULL means fall back
1626      * to fNumberFormat in DateFormat.
1627      */
1628     const SharedNumberFormat    **fSharedNumberFormatters;
1629 
1630     enum NumberFormatterKey {
1631         SMPDTFMT_NF_1x10,
1632         SMPDTFMT_NF_2x10,
1633         SMPDTFMT_NF_3x10,
1634         SMPDTFMT_NF_4x10,
1635         SMPDTFMT_NF_2x2,
1636         SMPDTFMT_NF_COUNT
1637     };
1638 
1639     /**
1640      * Number formatters pre-allocated for fast performance on the most common integer lengths.
1641      */
1642     const number::LocalizedNumberFormatter* fFastNumberFormatters[SMPDTFMT_NF_COUNT] = {};
1643 
1644     UBool fHaveDefaultCentury;
1645 
1646     BreakIterator* fCapitalizationBrkIter;
1647 };
1648 
1649 inline UDate
1650 SimpleDateFormat::get2DigitYearStart(UErrorCode&amp; /*status*/) const
1651 {
1652     return fDefaultCenturyStart;
1653 }
1654 
1655 U_NAMESPACE_END
1656 
1657 #endif /* #if !UCONFIG_NO_FORMATTING */
1658 
1659 #endif // _SMPDTFMT
1660 //eof
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>