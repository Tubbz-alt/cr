<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_skeletons.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="number_scientific.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_skeletons.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_skeletons.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 142     } \
 143 }
 144 
 145 
 146 } // anonymous namespace
 147 
 148 
 149 Notation stem_to_object::notation(skeleton::StemEnum stem) {
 150     switch (stem) {
 151         case STEM_COMPACT_SHORT:
 152             return Notation::compactShort();
 153         case STEM_COMPACT_LONG:
 154             return Notation::compactLong();
 155         case STEM_SCIENTIFIC:
 156             return Notation::scientific();
 157         case STEM_ENGINEERING:
 158             return Notation::engineering();
 159         case STEM_NOTATION_SIMPLE:
 160             return Notation::simple();
 161         default:
<span class="line-modified"> 162             U_ASSERT(false);</span>
<span class="line-removed"> 163             return Notation::simple(); // return a value: silence compiler warning</span>
 164     }
 165 }
 166 
 167 MeasureUnit stem_to_object::unit(skeleton::StemEnum stem) {
 168     switch (stem) {
 169         case STEM_BASE_UNIT:
 170             // Slicing is okay
 171             return NoUnit::base(); // NOLINT
 172         case STEM_PERCENT:
 173             // Slicing is okay
 174             return NoUnit::percent(); // NOLINT
 175         case STEM_PERMILLE:
 176             // Slicing is okay
 177             return NoUnit::permille(); // NOLINT
 178         default:
<span class="line-modified"> 179             U_ASSERT(false);</span>
<span class="line-removed"> 180             return {}; // return a value: silence compiler warning</span>
 181     }
 182 }
 183 
 184 Precision stem_to_object::precision(skeleton::StemEnum stem) {
 185     switch (stem) {
 186         case STEM_PRECISION_INTEGER:
 187             return Precision::integer();
 188         case STEM_PRECISION_UNLIMITED:
 189             return Precision::unlimited();
 190         case STEM_PRECISION_CURRENCY_STANDARD:
 191             return Precision::currency(UCURR_USAGE_STANDARD);
 192         case STEM_PRECISION_CURRENCY_CASH:
 193             return Precision::currency(UCURR_USAGE_CASH);
 194         default:
<span class="line-modified"> 195             U_ASSERT(false);</span>
<span class="line-removed"> 196             return Precision::integer(); // return a value: silence compiler warning</span>
 197     }
 198 }
 199 
 200 UNumberFormatRoundingMode stem_to_object::roundingMode(skeleton::StemEnum stem) {
 201     switch (stem) {
 202         case STEM_ROUNDING_MODE_CEILING:
 203             return UNUM_ROUND_CEILING;
 204         case STEM_ROUNDING_MODE_FLOOR:
 205             return UNUM_ROUND_FLOOR;
 206         case STEM_ROUNDING_MODE_DOWN:
 207             return UNUM_ROUND_DOWN;
 208         case STEM_ROUNDING_MODE_UP:
 209             return UNUM_ROUND_UP;
 210         case STEM_ROUNDING_MODE_HALF_EVEN:
 211             return UNUM_ROUND_HALFEVEN;
 212         case STEM_ROUNDING_MODE_HALF_DOWN:
 213             return UNUM_ROUND_HALFDOWN;
 214         case STEM_ROUNDING_MODE_HALF_UP:
 215             return UNUM_ROUND_HALFUP;
 216         case STEM_ROUNDING_MODE_UNNECESSARY:
 217             return UNUM_ROUND_UNNECESSARY;
 218         default:
<span class="line-modified"> 219             U_ASSERT(false);</span>
<span class="line-removed"> 220             return UNUM_ROUND_UNNECESSARY;</span>
 221     }
 222 }
 223 
<span class="line-modified"> 224 UGroupingStrategy stem_to_object::groupingStrategy(skeleton::StemEnum stem) {</span>
 225     switch (stem) {
 226         case STEM_GROUP_OFF:
 227             return UNUM_GROUPING_OFF;
 228         case STEM_GROUP_MIN2:
 229             return UNUM_GROUPING_MIN2;
 230         case STEM_GROUP_AUTO:
 231             return UNUM_GROUPING_AUTO;
 232         case STEM_GROUP_ON_ALIGNED:
 233             return UNUM_GROUPING_ON_ALIGNED;
 234         case STEM_GROUP_THOUSANDS:
 235             return UNUM_GROUPING_THOUSANDS;
 236         default:
 237             return UNUM_GROUPING_COUNT; // for objects, throw; for enums, return COUNT
 238     }
 239 }
 240 
 241 UNumberUnitWidth stem_to_object::unitWidth(skeleton::StemEnum stem) {
 242     switch (stem) {
 243         case STEM_UNIT_WIDTH_NARROW:
 244             return UNUM_UNIT_WIDTH_NARROW;
</pre>
<hr />
<pre>
 298             break;
 299         case UNUM_ROUND_DOWN:
 300             sb.append(u&quot;rounding-mode-down&quot;, -1);
 301             break;
 302         case UNUM_ROUND_UP:
 303             sb.append(u&quot;rounding-mode-up&quot;, -1);
 304             break;
 305         case UNUM_ROUND_HALFEVEN:
 306             sb.append(u&quot;rounding-mode-half-even&quot;, -1);
 307             break;
 308         case UNUM_ROUND_HALFDOWN:
 309             sb.append(u&quot;rounding-mode-half-down&quot;, -1);
 310             break;
 311         case UNUM_ROUND_HALFUP:
 312             sb.append(u&quot;rounding-mode-half-up&quot;, -1);
 313             break;
 314         case UNUM_ROUND_UNNECESSARY:
 315             sb.append(u&quot;rounding-mode-unnecessary&quot;, -1);
 316             break;
 317         default:
<span class="line-modified"> 318             U_ASSERT(false);</span>
 319     }
 320 }
 321 
<span class="line-modified"> 322 void enum_to_stem_string::groupingStrategy(UGroupingStrategy value, UnicodeString&amp; sb) {</span>
 323     switch (value) {
 324         case UNUM_GROUPING_OFF:
 325             sb.append(u&quot;group-off&quot;, -1);
 326             break;
 327         case UNUM_GROUPING_MIN2:
 328             sb.append(u&quot;group-min2&quot;, -1);
 329             break;
 330         case UNUM_GROUPING_AUTO:
 331             sb.append(u&quot;group-auto&quot;, -1);
 332             break;
 333         case UNUM_GROUPING_ON_ALIGNED:
 334             sb.append(u&quot;group-on-aligned&quot;, -1);
 335             break;
 336         case UNUM_GROUPING_THOUSANDS:
 337             sb.append(u&quot;group-thousands&quot;, -1);
 338             break;
 339         default:
<span class="line-modified"> 340             U_ASSERT(false);</span>
 341     }
 342 }
 343 
 344 void enum_to_stem_string::unitWidth(UNumberUnitWidth value, UnicodeString&amp; sb) {
 345     switch (value) {
 346         case UNUM_UNIT_WIDTH_NARROW:
 347             sb.append(u&quot;unit-width-narrow&quot;, -1);
 348             break;
 349         case UNUM_UNIT_WIDTH_SHORT:
 350             sb.append(u&quot;unit-width-short&quot;, -1);
 351             break;
 352         case UNUM_UNIT_WIDTH_FULL_NAME:
 353             sb.append(u&quot;unit-width-full-name&quot;, -1);
 354             break;
 355         case UNUM_UNIT_WIDTH_ISO_CODE:
 356             sb.append(u&quot;unit-width-iso-code&quot;, -1);
 357             break;
 358         case UNUM_UNIT_WIDTH_HIDDEN:
 359             sb.append(u&quot;unit-width-hidden&quot;, -1);
 360             break;
 361         default:
<span class="line-modified"> 362             U_ASSERT(false);</span>
 363     }
 364 }
 365 
 366 void enum_to_stem_string::signDisplay(UNumberSignDisplay value, UnicodeString&amp; sb) {
 367     switch (value) {
 368         case UNUM_SIGN_AUTO:
 369             sb.append(u&quot;sign-auto&quot;, -1);
 370             break;
 371         case UNUM_SIGN_ALWAYS:
 372             sb.append(u&quot;sign-always&quot;, -1);
 373             break;
 374         case UNUM_SIGN_NEVER:
 375             sb.append(u&quot;sign-never&quot;, -1);
 376             break;
 377         case UNUM_SIGN_ACCOUNTING:
 378             sb.append(u&quot;sign-accounting&quot;, -1);
 379             break;
 380         case UNUM_SIGN_ACCOUNTING_ALWAYS:
 381             sb.append(u&quot;sign-accounting-always&quot;, -1);
 382             break;
 383         case UNUM_SIGN_EXCEPT_ZERO:
 384             sb.append(u&quot;sign-except-zero&quot;, -1);
 385             break;
 386         case UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO:
 387             sb.append(u&quot;sign-accounting-except-zero&quot;, -1);
 388             break;
 389         default:
<span class="line-modified"> 390             U_ASSERT(false);</span>
 391     }
 392 }
 393 
 394 void
 395 enum_to_stem_string::decimalSeparatorDisplay(UNumberDecimalSeparatorDisplay value, UnicodeString&amp; sb) {
 396     switch (value) {
 397         case UNUM_DECIMAL_SEPARATOR_AUTO:
 398             sb.append(u&quot;decimal-auto&quot;, -1);
 399             break;
 400         case UNUM_DECIMAL_SEPARATOR_ALWAYS:
 401             sb.append(u&quot;decimal-always&quot;, -1);
 402             break;
 403         default:
<span class="line-modified"> 404             U_ASSERT(false);</span>
 405     }
 406 }
 407 
 408 
<span class="line-modified"> 409 UnlocalizedNumberFormatter skeleton::create(const UnicodeString&amp; skeletonString, UErrorCode&amp; status) {</span>










 410     umtx_initOnce(gNumberSkeletonsInitOnce, &amp;initNumberSkeletons, status);
<span class="line-modified"> 411     MacroProps macros = parseSkeleton(skeletonString, status);</span>
<span class="line-modified"> 412     return NumberFormatter::with().macros(macros);</span>





















 413 }
 414 
 415 UnicodeString skeleton::generate(const MacroProps&amp; macros, UErrorCode&amp; status) {
 416     umtx_initOnce(gNumberSkeletonsInitOnce, &amp;initNumberSkeletons, status);
 417     UnicodeString sb;
 418     GeneratorHelpers::generateSkeleton(macros, sb, status);
 419     return sb;
 420 }
 421 
<span class="line-modified"> 422 MacroProps skeleton::parseSkeleton(const UnicodeString&amp; skeletonString, UErrorCode&amp; status) {</span>
<span class="line-modified"> 423     if (U_FAILURE(status)) { return MacroProps(); }</span>

 424 
 425     // Add a trailing whitespace to the end of the skeleton string to make code cleaner.
 426     UnicodeString tempSkeletonString(skeletonString);
 427     tempSkeletonString.append(u&#39; &#39;);
 428 
 429     SeenMacroProps seen;
 430     MacroProps macros;
 431     StringSegment segment(tempSkeletonString, false);
 432     UCharsTrie stemTrie(kSerializedStemTrie);
 433     ParseState stem = STATE_NULL;
 434     int32_t offset = 0;
 435 
 436     // Primary skeleton parse loop:
 437     while (offset &lt; segment.length()) {
 438         UChar32 cp = segment.codePointAt(offset);
 439         bool isTokenSeparator = PatternProps::isWhiteSpace(cp);
 440         bool isOptionSeparator = (cp == u&#39;/&#39;);
 441 
 442         if (!isTokenSeparator &amp;&amp; !isOptionSeparator) {
 443             // Non-separator token; consume it.
</pre>
<hr />
<pre>
 447                 // Go to the next state in the stem trie.
 448                 stemTrie.nextForCodePoint(cp);
 449             }
 450             continue;
 451         }
 452 
 453         // We are looking at a token or option separator.
 454         // If the segment is nonempty, parse it and reset the segment.
 455         // Otherwise, make sure it is a valid repeating separator.
 456         if (offset != 0) {
 457             segment.setLength(offset);
 458             if (stem == STATE_NULL) {
 459                 // The first separator after the start of a token. Parse it as a stem.
 460                 stem = parseStem(segment, stemTrie, seen, macros, status);
 461                 stemTrie.reset();
 462             } else {
 463                 // A separator after the first separator of a token. Parse it as an option.
 464                 stem = parseOption(stem, segment, macros, status);
 465             }
 466             segment.resetLength();
<span class="line-modified"> 467             if (U_FAILURE(status)) { return macros; }</span>



 468 
 469             // Consume the segment:
 470             segment.adjustOffset(offset);
 471             offset = 0;
 472 
 473         } else if (stem != STATE_NULL) {
 474             // A separator (&#39;/&#39; or whitespace) following an option separator (&#39;/&#39;)
 475             // segment.setLength(U16_LENGTH(cp)); // for error message
 476             // throw new SkeletonSyntaxException(&quot;Unexpected separator character&quot;, segment);
 477             status = U_NUMBER_SKELETON_SYNTAX_ERROR;

 478             return macros;
 479 
 480         } else {
 481             // Two spaces in a row; this is OK.
 482         }
 483 
 484         // Does the current stem forbid options?
 485         if (isOptionSeparator &amp;&amp; stem == STATE_NULL) {
 486             // segment.setLength(U16_LENGTH(cp)); // for error message
 487             // throw new SkeletonSyntaxException(&quot;Unexpected option separator&quot;, segment);
 488             status = U_NUMBER_SKELETON_SYNTAX_ERROR;

 489             return macros;
 490         }
 491 
 492         // Does the current stem require an option?
 493         if (isTokenSeparator &amp;&amp; stem != STATE_NULL) {
 494             switch (stem) {
 495                 case STATE_INCREMENT_PRECISION:
 496                 case STATE_MEASURE_UNIT:
 497                 case STATE_PER_MEASURE_UNIT:
 498                 case STATE_CURRENCY_UNIT:
 499                 case STATE_INTEGER_WIDTH:
 500                 case STATE_NUMBERING_SYSTEM:
 501                 case STATE_SCALE:
 502                     // segment.setLength(U16_LENGTH(cp)); // for error message
 503                     // throw new SkeletonSyntaxException(&quot;Stem requires an option&quot;, segment);
 504                     status = U_NUMBER_SKELETON_SYNTAX_ERROR;

 505                     return macros;
 506                 default:
 507                     break;
 508             }
 509             stem = STATE_NULL;
 510         }
 511 
 512         // Consume the separator:
 513         segment.adjustOffset(U16_LENGTH(cp));
 514     }
 515     U_ASSERT(stem == STATE_NULL);
 516     return macros;
 517 }
 518 
 519 ParseState
 520 skeleton::parseStem(const StringSegment&amp; segment, const UCharsTrie&amp; stemTrie, SeenMacroProps&amp; seen,
 521                     MacroProps&amp; macros, UErrorCode&amp; status) {
 522     // First check for &quot;blueprint&quot; stems, which start with a &quot;signal char&quot;
 523     switch (segment.charAt(0)) {
 524         case u&#39;.&#39;:
</pre>
<hr />
<pre>
 648         CHECK_NULL(seen, perUnit, status);
 649             return STATE_PER_MEASURE_UNIT;
 650 
 651         case STEM_CURRENCY:
 652         CHECK_NULL(seen, unit, status);
 653             return STATE_CURRENCY_UNIT;
 654 
 655         case STEM_INTEGER_WIDTH:
 656         CHECK_NULL(seen, integerWidth, status);
 657             return STATE_INTEGER_WIDTH;
 658 
 659         case STEM_NUMBERING_SYSTEM:
 660         CHECK_NULL(seen, symbols, status);
 661             return STATE_NUMBERING_SYSTEM;
 662 
 663         case STEM_SCALE:
 664         CHECK_NULL(seen, scale, status);
 665             return STATE_SCALE;
 666 
 667         default:
<span class="line-modified"> 668             U_ASSERT(false);</span>
<span class="line-removed"> 669             return STATE_NULL; // return a value: silence compiler warning</span>
 670     }
 671 }
 672 
 673 ParseState skeleton::parseOption(ParseState stem, const StringSegment&amp; segment, MacroProps&amp; macros,
 674                                  UErrorCode&amp; status) {
 675 
 676     ///// Required options: /////
 677 
 678     switch (stem) {
 679         case STATE_CURRENCY_UNIT:
 680             blueprint_helpers::parseCurrencyOption(segment, macros, status);
 681             return STATE_NULL;
 682         case STATE_MEASURE_UNIT:
 683             blueprint_helpers::parseMeasureUnitOption(segment, macros, status);
 684             return STATE_NULL;
 685         case STATE_PER_MEASURE_UNIT:
 686             blueprint_helpers::parseMeasurePerUnitOption(segment, macros, status);
 687             return STATE_NULL;
 688         case STATE_INCREMENT_PRECISION:
 689             blueprint_helpers::parseIncrementOption(segment, macros, status);
</pre>
<hr />
<pre>
1372 }
1373 
1374 bool GeneratorHelpers::precision(const MacroProps&amp; macros, UnicodeString&amp; sb, UErrorCode&amp; status) {
1375     if (macros.precision.fType == Precision::RND_NONE) {
1376         sb.append(u&quot;precision-unlimited&quot;, -1);
1377     } else if (macros.precision.fType == Precision::RND_FRACTION) {
1378         const Precision::FractionSignificantSettings&amp; impl = macros.precision.fUnion.fracSig;
1379         blueprint_helpers::generateFractionStem(impl.fMinFrac, impl.fMaxFrac, sb, status);
1380     } else if (macros.precision.fType == Precision::RND_SIGNIFICANT) {
1381         const Precision::FractionSignificantSettings&amp; impl = macros.precision.fUnion.fracSig;
1382         blueprint_helpers::generateDigitsStem(impl.fMinSig, impl.fMaxSig, sb, status);
1383     } else if (macros.precision.fType == Precision::RND_FRACTION_SIGNIFICANT) {
1384         const Precision::FractionSignificantSettings&amp; impl = macros.precision.fUnion.fracSig;
1385         blueprint_helpers::generateFractionStem(impl.fMinFrac, impl.fMaxFrac, sb, status);
1386         sb.append(u&#39;/&#39;);
1387         if (impl.fMinSig == -1) {
1388             blueprint_helpers::generateDigitsStem(1, impl.fMaxSig, sb, status);
1389         } else {
1390             blueprint_helpers::generateDigitsStem(impl.fMinSig, -1, sb, status);
1391         }
<span class="line-modified">1392     } else if (macros.precision.fType == Precision::RND_INCREMENT) {</span>


1393         const Precision::IncrementSettings&amp; impl = macros.precision.fUnion.increment;
1394         sb.append(u&quot;precision-increment/&quot;, -1);
1395         blueprint_helpers::generateIncrementOption(
1396                 impl.fIncrement,
1397                 impl.fMinFrac - impl.fMaxFrac,
1398                 sb,
1399                 status);
1400     } else if (macros.precision.fType == Precision::RND_CURRENCY) {
1401         UCurrencyUsage usage = macros.precision.fUnion.currencyUsage;
1402         if (usage == UCURR_USAGE_STANDARD) {
1403             sb.append(u&quot;precision-currency-standard&quot;, -1);
1404         } else {
1405             sb.append(u&quot;precision-currency-cash&quot;, -1);
1406         }
1407     } else {
1408         // Bogus or Error
1409         return false;
1410     }
1411 
1412     // NOTE: Always return true for rounding because the default value depends on other options.
</pre>
</td>
<td>
<hr />
<pre>
 142     } \
 143 }
 144 
 145 
 146 } // anonymous namespace
 147 
 148 
 149 Notation stem_to_object::notation(skeleton::StemEnum stem) {
 150     switch (stem) {
 151         case STEM_COMPACT_SHORT:
 152             return Notation::compactShort();
 153         case STEM_COMPACT_LONG:
 154             return Notation::compactLong();
 155         case STEM_SCIENTIFIC:
 156             return Notation::scientific();
 157         case STEM_ENGINEERING:
 158             return Notation::engineering();
 159         case STEM_NOTATION_SIMPLE:
 160             return Notation::simple();
 161         default:
<span class="line-modified"> 162             UPRV_UNREACHABLE;</span>

 163     }
 164 }
 165 
 166 MeasureUnit stem_to_object::unit(skeleton::StemEnum stem) {
 167     switch (stem) {
 168         case STEM_BASE_UNIT:
 169             // Slicing is okay
 170             return NoUnit::base(); // NOLINT
 171         case STEM_PERCENT:
 172             // Slicing is okay
 173             return NoUnit::percent(); // NOLINT
 174         case STEM_PERMILLE:
 175             // Slicing is okay
 176             return NoUnit::permille(); // NOLINT
 177         default:
<span class="line-modified"> 178             UPRV_UNREACHABLE;</span>

 179     }
 180 }
 181 
 182 Precision stem_to_object::precision(skeleton::StemEnum stem) {
 183     switch (stem) {
 184         case STEM_PRECISION_INTEGER:
 185             return Precision::integer();
 186         case STEM_PRECISION_UNLIMITED:
 187             return Precision::unlimited();
 188         case STEM_PRECISION_CURRENCY_STANDARD:
 189             return Precision::currency(UCURR_USAGE_STANDARD);
 190         case STEM_PRECISION_CURRENCY_CASH:
 191             return Precision::currency(UCURR_USAGE_CASH);
 192         default:
<span class="line-modified"> 193             UPRV_UNREACHABLE;</span>

 194     }
 195 }
 196 
 197 UNumberFormatRoundingMode stem_to_object::roundingMode(skeleton::StemEnum stem) {
 198     switch (stem) {
 199         case STEM_ROUNDING_MODE_CEILING:
 200             return UNUM_ROUND_CEILING;
 201         case STEM_ROUNDING_MODE_FLOOR:
 202             return UNUM_ROUND_FLOOR;
 203         case STEM_ROUNDING_MODE_DOWN:
 204             return UNUM_ROUND_DOWN;
 205         case STEM_ROUNDING_MODE_UP:
 206             return UNUM_ROUND_UP;
 207         case STEM_ROUNDING_MODE_HALF_EVEN:
 208             return UNUM_ROUND_HALFEVEN;
 209         case STEM_ROUNDING_MODE_HALF_DOWN:
 210             return UNUM_ROUND_HALFDOWN;
 211         case STEM_ROUNDING_MODE_HALF_UP:
 212             return UNUM_ROUND_HALFUP;
 213         case STEM_ROUNDING_MODE_UNNECESSARY:
 214             return UNUM_ROUND_UNNECESSARY;
 215         default:
<span class="line-modified"> 216             UPRV_UNREACHABLE;</span>

 217     }
 218 }
 219 
<span class="line-modified"> 220 UNumberGroupingStrategy stem_to_object::groupingStrategy(skeleton::StemEnum stem) {</span>
 221     switch (stem) {
 222         case STEM_GROUP_OFF:
 223             return UNUM_GROUPING_OFF;
 224         case STEM_GROUP_MIN2:
 225             return UNUM_GROUPING_MIN2;
 226         case STEM_GROUP_AUTO:
 227             return UNUM_GROUPING_AUTO;
 228         case STEM_GROUP_ON_ALIGNED:
 229             return UNUM_GROUPING_ON_ALIGNED;
 230         case STEM_GROUP_THOUSANDS:
 231             return UNUM_GROUPING_THOUSANDS;
 232         default:
 233             return UNUM_GROUPING_COUNT; // for objects, throw; for enums, return COUNT
 234     }
 235 }
 236 
 237 UNumberUnitWidth stem_to_object::unitWidth(skeleton::StemEnum stem) {
 238     switch (stem) {
 239         case STEM_UNIT_WIDTH_NARROW:
 240             return UNUM_UNIT_WIDTH_NARROW;
</pre>
<hr />
<pre>
 294             break;
 295         case UNUM_ROUND_DOWN:
 296             sb.append(u&quot;rounding-mode-down&quot;, -1);
 297             break;
 298         case UNUM_ROUND_UP:
 299             sb.append(u&quot;rounding-mode-up&quot;, -1);
 300             break;
 301         case UNUM_ROUND_HALFEVEN:
 302             sb.append(u&quot;rounding-mode-half-even&quot;, -1);
 303             break;
 304         case UNUM_ROUND_HALFDOWN:
 305             sb.append(u&quot;rounding-mode-half-down&quot;, -1);
 306             break;
 307         case UNUM_ROUND_HALFUP:
 308             sb.append(u&quot;rounding-mode-half-up&quot;, -1);
 309             break;
 310         case UNUM_ROUND_UNNECESSARY:
 311             sb.append(u&quot;rounding-mode-unnecessary&quot;, -1);
 312             break;
 313         default:
<span class="line-modified"> 314             UPRV_UNREACHABLE;</span>
 315     }
 316 }
 317 
<span class="line-modified"> 318 void enum_to_stem_string::groupingStrategy(UNumberGroupingStrategy value, UnicodeString&amp; sb) {</span>
 319     switch (value) {
 320         case UNUM_GROUPING_OFF:
 321             sb.append(u&quot;group-off&quot;, -1);
 322             break;
 323         case UNUM_GROUPING_MIN2:
 324             sb.append(u&quot;group-min2&quot;, -1);
 325             break;
 326         case UNUM_GROUPING_AUTO:
 327             sb.append(u&quot;group-auto&quot;, -1);
 328             break;
 329         case UNUM_GROUPING_ON_ALIGNED:
 330             sb.append(u&quot;group-on-aligned&quot;, -1);
 331             break;
 332         case UNUM_GROUPING_THOUSANDS:
 333             sb.append(u&quot;group-thousands&quot;, -1);
 334             break;
 335         default:
<span class="line-modified"> 336             UPRV_UNREACHABLE;</span>
 337     }
 338 }
 339 
 340 void enum_to_stem_string::unitWidth(UNumberUnitWidth value, UnicodeString&amp; sb) {
 341     switch (value) {
 342         case UNUM_UNIT_WIDTH_NARROW:
 343             sb.append(u&quot;unit-width-narrow&quot;, -1);
 344             break;
 345         case UNUM_UNIT_WIDTH_SHORT:
 346             sb.append(u&quot;unit-width-short&quot;, -1);
 347             break;
 348         case UNUM_UNIT_WIDTH_FULL_NAME:
 349             sb.append(u&quot;unit-width-full-name&quot;, -1);
 350             break;
 351         case UNUM_UNIT_WIDTH_ISO_CODE:
 352             sb.append(u&quot;unit-width-iso-code&quot;, -1);
 353             break;
 354         case UNUM_UNIT_WIDTH_HIDDEN:
 355             sb.append(u&quot;unit-width-hidden&quot;, -1);
 356             break;
 357         default:
<span class="line-modified"> 358             UPRV_UNREACHABLE;</span>
 359     }
 360 }
 361 
 362 void enum_to_stem_string::signDisplay(UNumberSignDisplay value, UnicodeString&amp; sb) {
 363     switch (value) {
 364         case UNUM_SIGN_AUTO:
 365             sb.append(u&quot;sign-auto&quot;, -1);
 366             break;
 367         case UNUM_SIGN_ALWAYS:
 368             sb.append(u&quot;sign-always&quot;, -1);
 369             break;
 370         case UNUM_SIGN_NEVER:
 371             sb.append(u&quot;sign-never&quot;, -1);
 372             break;
 373         case UNUM_SIGN_ACCOUNTING:
 374             sb.append(u&quot;sign-accounting&quot;, -1);
 375             break;
 376         case UNUM_SIGN_ACCOUNTING_ALWAYS:
 377             sb.append(u&quot;sign-accounting-always&quot;, -1);
 378             break;
 379         case UNUM_SIGN_EXCEPT_ZERO:
 380             sb.append(u&quot;sign-except-zero&quot;, -1);
 381             break;
 382         case UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO:
 383             sb.append(u&quot;sign-accounting-except-zero&quot;, -1);
 384             break;
 385         default:
<span class="line-modified"> 386             UPRV_UNREACHABLE;</span>
 387     }
 388 }
 389 
 390 void
 391 enum_to_stem_string::decimalSeparatorDisplay(UNumberDecimalSeparatorDisplay value, UnicodeString&amp; sb) {
 392     switch (value) {
 393         case UNUM_DECIMAL_SEPARATOR_AUTO:
 394             sb.append(u&quot;decimal-auto&quot;, -1);
 395             break;
 396         case UNUM_DECIMAL_SEPARATOR_ALWAYS:
 397             sb.append(u&quot;decimal-always&quot;, -1);
 398             break;
 399         default:
<span class="line-modified"> 400             UPRV_UNREACHABLE;</span>
 401     }
 402 }
 403 
 404 
<span class="line-modified"> 405 UnlocalizedNumberFormatter skeleton::create(</span>
<span class="line-added"> 406         const UnicodeString&amp; skeletonString, UParseError* perror, UErrorCode&amp; status) {</span>
<span class="line-added"> 407 </span>
<span class="line-added"> 408     // Initialize perror</span>
<span class="line-added"> 409     if (perror != nullptr) {</span>
<span class="line-added"> 410         perror-&gt;line = 0;</span>
<span class="line-added"> 411         perror-&gt;offset = -1;</span>
<span class="line-added"> 412         perror-&gt;preContext[0] = 0;</span>
<span class="line-added"> 413         perror-&gt;postContext[0] = 0;</span>
<span class="line-added"> 414     }</span>
<span class="line-added"> 415 </span>
 416     umtx_initOnce(gNumberSkeletonsInitOnce, &amp;initNumberSkeletons, status);
<span class="line-modified"> 417     if (U_FAILURE(status)) {</span>
<span class="line-modified"> 418         return {};</span>
<span class="line-added"> 419     }</span>
<span class="line-added"> 420 </span>
<span class="line-added"> 421     int32_t errOffset;</span>
<span class="line-added"> 422     MacroProps macros = parseSkeleton(skeletonString, errOffset, status);</span>
<span class="line-added"> 423     if (U_SUCCESS(status)) {</span>
<span class="line-added"> 424         return NumberFormatter::with().macros(macros);</span>
<span class="line-added"> 425     }</span>
<span class="line-added"> 426 </span>
<span class="line-added"> 427     if (perror == nullptr) {</span>
<span class="line-added"> 428         return {};</span>
<span class="line-added"> 429     }</span>
<span class="line-added"> 430 </span>
<span class="line-added"> 431     // Populate the UParseError with the error location</span>
<span class="line-added"> 432     perror-&gt;offset = errOffset;</span>
<span class="line-added"> 433     int32_t contextStart = uprv_max(0, errOffset - U_PARSE_CONTEXT_LEN + 1);</span>
<span class="line-added"> 434     int32_t contextEnd = uprv_min(skeletonString.length(), errOffset + U_PARSE_CONTEXT_LEN - 1);</span>
<span class="line-added"> 435     skeletonString.extract(contextStart, errOffset - contextStart, perror-&gt;preContext, 0);</span>
<span class="line-added"> 436     perror-&gt;preContext[errOffset - contextStart] = 0;</span>
<span class="line-added"> 437     skeletonString.extract(errOffset, contextEnd - errOffset, perror-&gt;postContext, 0);</span>
<span class="line-added"> 438     perror-&gt;postContext[contextEnd - errOffset] = 0;</span>
<span class="line-added"> 439     return {};</span>
 440 }
 441 
 442 UnicodeString skeleton::generate(const MacroProps&amp; macros, UErrorCode&amp; status) {
 443     umtx_initOnce(gNumberSkeletonsInitOnce, &amp;initNumberSkeletons, status);
 444     UnicodeString sb;
 445     GeneratorHelpers::generateSkeleton(macros, sb, status);
 446     return sb;
 447 }
 448 
<span class="line-modified"> 449 MacroProps skeleton::parseSkeleton(</span>
<span class="line-modified"> 450         const UnicodeString&amp; skeletonString, int32_t&amp; errOffset, UErrorCode&amp; status) {</span>
<span class="line-added"> 451     U_ASSERT(U_SUCCESS(status));</span>
 452 
 453     // Add a trailing whitespace to the end of the skeleton string to make code cleaner.
 454     UnicodeString tempSkeletonString(skeletonString);
 455     tempSkeletonString.append(u&#39; &#39;);
 456 
 457     SeenMacroProps seen;
 458     MacroProps macros;
 459     StringSegment segment(tempSkeletonString, false);
 460     UCharsTrie stemTrie(kSerializedStemTrie);
 461     ParseState stem = STATE_NULL;
 462     int32_t offset = 0;
 463 
 464     // Primary skeleton parse loop:
 465     while (offset &lt; segment.length()) {
 466         UChar32 cp = segment.codePointAt(offset);
 467         bool isTokenSeparator = PatternProps::isWhiteSpace(cp);
 468         bool isOptionSeparator = (cp == u&#39;/&#39;);
 469 
 470         if (!isTokenSeparator &amp;&amp; !isOptionSeparator) {
 471             // Non-separator token; consume it.
</pre>
<hr />
<pre>
 475                 // Go to the next state in the stem trie.
 476                 stemTrie.nextForCodePoint(cp);
 477             }
 478             continue;
 479         }
 480 
 481         // We are looking at a token or option separator.
 482         // If the segment is nonempty, parse it and reset the segment.
 483         // Otherwise, make sure it is a valid repeating separator.
 484         if (offset != 0) {
 485             segment.setLength(offset);
 486             if (stem == STATE_NULL) {
 487                 // The first separator after the start of a token. Parse it as a stem.
 488                 stem = parseStem(segment, stemTrie, seen, macros, status);
 489                 stemTrie.reset();
 490             } else {
 491                 // A separator after the first separator of a token. Parse it as an option.
 492                 stem = parseOption(stem, segment, macros, status);
 493             }
 494             segment.resetLength();
<span class="line-modified"> 495             if (U_FAILURE(status)) {</span>
<span class="line-added"> 496                 errOffset = segment.getOffset();</span>
<span class="line-added"> 497                 return macros;</span>
<span class="line-added"> 498             }</span>
 499 
 500             // Consume the segment:
 501             segment.adjustOffset(offset);
 502             offset = 0;
 503 
 504         } else if (stem != STATE_NULL) {
 505             // A separator (&#39;/&#39; or whitespace) following an option separator (&#39;/&#39;)
 506             // segment.setLength(U16_LENGTH(cp)); // for error message
 507             // throw new SkeletonSyntaxException(&quot;Unexpected separator character&quot;, segment);
 508             status = U_NUMBER_SKELETON_SYNTAX_ERROR;
<span class="line-added"> 509             errOffset = segment.getOffset();</span>
 510             return macros;
 511 
 512         } else {
 513             // Two spaces in a row; this is OK.
 514         }
 515 
 516         // Does the current stem forbid options?
 517         if (isOptionSeparator &amp;&amp; stem == STATE_NULL) {
 518             // segment.setLength(U16_LENGTH(cp)); // for error message
 519             // throw new SkeletonSyntaxException(&quot;Unexpected option separator&quot;, segment);
 520             status = U_NUMBER_SKELETON_SYNTAX_ERROR;
<span class="line-added"> 521             errOffset = segment.getOffset();</span>
 522             return macros;
 523         }
 524 
 525         // Does the current stem require an option?
 526         if (isTokenSeparator &amp;&amp; stem != STATE_NULL) {
 527             switch (stem) {
 528                 case STATE_INCREMENT_PRECISION:
 529                 case STATE_MEASURE_UNIT:
 530                 case STATE_PER_MEASURE_UNIT:
 531                 case STATE_CURRENCY_UNIT:
 532                 case STATE_INTEGER_WIDTH:
 533                 case STATE_NUMBERING_SYSTEM:
 534                 case STATE_SCALE:
 535                     // segment.setLength(U16_LENGTH(cp)); // for error message
 536                     // throw new SkeletonSyntaxException(&quot;Stem requires an option&quot;, segment);
 537                     status = U_NUMBER_SKELETON_SYNTAX_ERROR;
<span class="line-added"> 538                     errOffset = segment.getOffset();</span>
 539                     return macros;
 540                 default:
 541                     break;
 542             }
 543             stem = STATE_NULL;
 544         }
 545 
 546         // Consume the separator:
 547         segment.adjustOffset(U16_LENGTH(cp));
 548     }
 549     U_ASSERT(stem == STATE_NULL);
 550     return macros;
 551 }
 552 
 553 ParseState
 554 skeleton::parseStem(const StringSegment&amp; segment, const UCharsTrie&amp; stemTrie, SeenMacroProps&amp; seen,
 555                     MacroProps&amp; macros, UErrorCode&amp; status) {
 556     // First check for &quot;blueprint&quot; stems, which start with a &quot;signal char&quot;
 557     switch (segment.charAt(0)) {
 558         case u&#39;.&#39;:
</pre>
<hr />
<pre>
 682         CHECK_NULL(seen, perUnit, status);
 683             return STATE_PER_MEASURE_UNIT;
 684 
 685         case STEM_CURRENCY:
 686         CHECK_NULL(seen, unit, status);
 687             return STATE_CURRENCY_UNIT;
 688 
 689         case STEM_INTEGER_WIDTH:
 690         CHECK_NULL(seen, integerWidth, status);
 691             return STATE_INTEGER_WIDTH;
 692 
 693         case STEM_NUMBERING_SYSTEM:
 694         CHECK_NULL(seen, symbols, status);
 695             return STATE_NUMBERING_SYSTEM;
 696 
 697         case STEM_SCALE:
 698         CHECK_NULL(seen, scale, status);
 699             return STATE_SCALE;
 700 
 701         default:
<span class="line-modified"> 702             UPRV_UNREACHABLE;</span>

 703     }
 704 }
 705 
 706 ParseState skeleton::parseOption(ParseState stem, const StringSegment&amp; segment, MacroProps&amp; macros,
 707                                  UErrorCode&amp; status) {
 708 
 709     ///// Required options: /////
 710 
 711     switch (stem) {
 712         case STATE_CURRENCY_UNIT:
 713             blueprint_helpers::parseCurrencyOption(segment, macros, status);
 714             return STATE_NULL;
 715         case STATE_MEASURE_UNIT:
 716             blueprint_helpers::parseMeasureUnitOption(segment, macros, status);
 717             return STATE_NULL;
 718         case STATE_PER_MEASURE_UNIT:
 719             blueprint_helpers::parseMeasurePerUnitOption(segment, macros, status);
 720             return STATE_NULL;
 721         case STATE_INCREMENT_PRECISION:
 722             blueprint_helpers::parseIncrementOption(segment, macros, status);
</pre>
<hr />
<pre>
1405 }
1406 
1407 bool GeneratorHelpers::precision(const MacroProps&amp; macros, UnicodeString&amp; sb, UErrorCode&amp; status) {
1408     if (macros.precision.fType == Precision::RND_NONE) {
1409         sb.append(u&quot;precision-unlimited&quot;, -1);
1410     } else if (macros.precision.fType == Precision::RND_FRACTION) {
1411         const Precision::FractionSignificantSettings&amp; impl = macros.precision.fUnion.fracSig;
1412         blueprint_helpers::generateFractionStem(impl.fMinFrac, impl.fMaxFrac, sb, status);
1413     } else if (macros.precision.fType == Precision::RND_SIGNIFICANT) {
1414         const Precision::FractionSignificantSettings&amp; impl = macros.precision.fUnion.fracSig;
1415         blueprint_helpers::generateDigitsStem(impl.fMinSig, impl.fMaxSig, sb, status);
1416     } else if (macros.precision.fType == Precision::RND_FRACTION_SIGNIFICANT) {
1417         const Precision::FractionSignificantSettings&amp; impl = macros.precision.fUnion.fracSig;
1418         blueprint_helpers::generateFractionStem(impl.fMinFrac, impl.fMaxFrac, sb, status);
1419         sb.append(u&#39;/&#39;);
1420         if (impl.fMinSig == -1) {
1421             blueprint_helpers::generateDigitsStem(1, impl.fMaxSig, sb, status);
1422         } else {
1423             blueprint_helpers::generateDigitsStem(impl.fMinSig, -1, sb, status);
1424         }
<span class="line-modified">1425     } else if (macros.precision.fType == Precision::RND_INCREMENT</span>
<span class="line-added">1426             || macros.precision.fType == Precision::RND_INCREMENT_ONE</span>
<span class="line-added">1427             || macros.precision.fType == Precision::RND_INCREMENT_FIVE) {</span>
1428         const Precision::IncrementSettings&amp; impl = macros.precision.fUnion.increment;
1429         sb.append(u&quot;precision-increment/&quot;, -1);
1430         blueprint_helpers::generateIncrementOption(
1431                 impl.fIncrement,
1432                 impl.fMinFrac - impl.fMaxFrac,
1433                 sb,
1434                 status);
1435     } else if (macros.precision.fType == Precision::RND_CURRENCY) {
1436         UCurrencyUsage usage = macros.precision.fUnion.currencyUsage;
1437         if (usage == UCURR_USAGE_STANDARD) {
1438             sb.append(u&quot;precision-currency-standard&quot;, -1);
1439         } else {
1440             sb.append(u&quot;precision-currency-cash&quot;, -1);
1441         }
1442     } else {
1443         // Bogus or Error
1444         return false;
1445     }
1446 
1447     // NOTE: Always return true for rounding because the default value depends on other options.
</pre>
</td>
</tr>
</table>
<center><a href="number_scientific.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_skeletons.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>