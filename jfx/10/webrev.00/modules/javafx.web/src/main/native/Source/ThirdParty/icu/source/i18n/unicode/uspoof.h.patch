diff a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/uspoof.h b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/uspoof.h
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/uspoof.h
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/uspoof.h
@@ -92,11 +92,10 @@
  * LocalUSpoofCheckerPointer sc(uspoof_open(&status));
  * uspoof_setChecks(sc.getAlias(), USPOOF_CONFUSABLE, &status);
  * // ...
  * \endcode
  *
- * <p>
  * UTS 39 defines two strings to be <em>confusable</em> if they map to the same <em>skeleton string</em>. A skeleton can
  * be thought of as a "hash code". {@link uspoof_getSkeleton} computes the skeleton for a particular string, so
  * the following snippet is equivalent to the example above:
  *
  * \code{.c}
@@ -126,11 +125,10 @@
  * uspoof_close(sc);
  * free(skel1);
  * free(skel2);
  * \endcode
  *
- * <p>
  * If you need to check if a string is confusable with any string in a dictionary of many strings, rather than calling
  * {@link uspoof_areConfusable} many times in a loop, {@link uspoof_getSkeleton} can be used instead, as shown below:
  *
  * \code{.c}
  * UErrorCode status = U_ZERO_ERROR;
@@ -170,18 +168,16 @@
  *     free(skeletons[i]);
  * }
  * uspoof_close(sc);
  * \endcode
  *
- * <p>
  * <b>Note:</b> Since the Unicode confusables mapping table is frequently updated, confusable skeletons are <em>not</em>
  * guaranteed to be the same between ICU releases. We therefore recommend that you always compute confusable skeletons
  * at runtime and do not rely on creating a permanent, or difficult to update, database of skeletons.
  *
  * <h2>Spoof Detection</h2>
- * <p>
  * The following snippet shows a minimal example of using <code>USpoofChecker</code> to perform spoof detection on a
  * string:
  *
  * \code{.c}
  * UErrorCode status = U_ZERO_ERROR;
@@ -202,20 +198,17 @@
  * printf("fails checks: %d (status: %s)\n", result, u_errorName(status));
  * uspoof_close(sc);
  * uset_close(allowed);
  * \endcode
  *
- * <p>
  * As in the case for confusability checking, it is good practice to create one <code>USpoofChecker</code> instance at
  * startup, and call the cheaper {@link uspoof_check} online. We specify the set of
  * allowed characters to be those with type RECOMMENDED or INCLUSION, according to the recommendation in UTS 39.
  *
- * <p>
  * In addition to {@link uspoof_check}, the function {@link uspoof_checkUTF8} is exposed for UTF8-encoded char* strings,
  * and {@link uspoof_checkUnicodeString} is exposed for C++ programmers.
  *
- * <p>
  * If the {@link USPOOF_AUX_INFO} check is enabled, a limited amount of information on why a string failed the checks
  * is available in the returned bitmask.  For complete information, use the {@link uspoof_check2} class of functions
  * with a {@link USpoofCheckResult} parameter:
  *
  * \code{.c}
@@ -272,11 +265,10 @@
  * printf("checks that failed: %#010x (status: %s)\n", failures1, u_errorName(status));
  *
  * // Explicit cleanup not necessary.
  * \endcode
  *
- * <p>
  * The return value is a bitmask of the checks that failed. In this case, there was one check that failed:
  * {@link USPOOF_RESTRICTION_LEVEL}, corresponding to the fifth bit (16). The possible checks are:
  *
  * <ul>
  * <li><code>RESTRICTION_LEVEL</code>: flags strings that violate the
@@ -305,11 +297,10 @@
  * // fails checks: 1 (status: U_ZERO_ERROR)
  * printf("fails checks: %d (status: %s)\n", result, u_errorName(status));
  * uspoof_close(sc);
  * \endcode
  *
- * <p>
  * Here is an example in C++ showing how to compute the restriction level of a string:
  *
  * \code{.cpp}
  * UErrorCode status = U_ZERO_ERROR;
  * UnicodeString str((UChar*) u"p\u0430ypal");  // with U+0430 CYRILLIC SMALL LETTER A
@@ -332,15 +323,13 @@
  * assert((restrictionLevel & bitmask) == restrictionLevel);
  * // Restriction level: 0x50000000 (status: U_ZERO_ERROR)
  * printf("Restriction level: %#010x (status: %s)\n", restrictionLevel, u_errorName(status));
  * \endcode
  *
- * <p>
  * The code '0x50000000' corresponds to the restriction level USPOOF_MINIMALLY_RESTRICTIVE.  Since
  * USPOOF_MINIMALLY_RESTRICTIVE is weaker than USPOOF_MODERATELY_RESTRICTIVE, the string fails the check.
  *
- * <p>
  * <b>Note:</b> The Restriction Level is the most powerful of the checks. The full logic is documented in
  * <a href="http://unicode.org/reports/tr39/#Restriction_Level_Detection">UTS 39</a>, but the basic idea is that strings
  * are restricted to contain characters from only a single script, <em>except</em> that most scripts are allowed to have
  * Latin characters interspersed. Although the default restriction level is <code>HIGHLY_RESTRICTIVE</code>, it is
  * recommended that users set their restriction level to <code>MODERATELY_RESTRICTIVE</code>, which allows Latin mixed
@@ -350,19 +339,16 @@
  * COMMON or INHERITED, such as numbers and punctuation, are ignored when computing whether a string has multiple
  * scripts.
  *
  * <h2>Additional Information</h2>
  *
- * <p>
  * A <code>USpoofChecker</code> instance may be used repeatedly to perform checks on any number of identifiers.
  *
- * <p>
  * <b>Thread Safety:</b> The test functions for checking a single identifier, or for testing whether
  * two identifiers are possible confusable, are thread safe. They may called concurrently, from multiple threads,
  * using the same USpoofChecker instance.
  *
- * <p>
  * More generally, the standard ICU thread safety rules apply: functions that take a const USpoofChecker parameter are
  * thread safe. Those that take a non-const USpoofChecker are not thread safe..
  *
  * @stable ICU 4.6
  */
@@ -1217,18 +1203,25 @@
 
 U_NAMESPACE_BEGIN
 
 /**
  * \class LocalUSpoofCheckResultPointer
- * "Smart pointer" class, closes a USpoofCheckResult via {@link uspoof_closeCheckResult}.
+ * "Smart pointer" class, closes a USpoofCheckResult via `uspoof_closeCheckResult()`.
  * For most methods see the LocalPointerBase base class.
  *
  * @see LocalPointerBase
  * @see LocalPointer
  * @stable ICU 58
+
+/**
+ * \cond
+ * Note: Doxygen is giving a bogus warning on this U_DEFINE_LOCAL_OPEN_POINTER.
+ *       For now, suppress with a Doxygen cond
+ */
 U_DEFINE_LOCAL_OPEN_POINTER(LocalUSpoofCheckResultPointer, USpoofCheckResult, uspoof_closeCheckResult);
+/** \endcond */
 
 U_NAMESPACE_END
 
 #endif
 
