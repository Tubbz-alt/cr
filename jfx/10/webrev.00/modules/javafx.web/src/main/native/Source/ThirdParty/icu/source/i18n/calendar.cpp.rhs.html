<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/calendar.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 * Copyright (C) 1997-2016, International Business Machines Corporation and    *
   6 * others. All Rights Reserved.                                                *
   7 *******************************************************************************
   8 *
   9 * File CALENDAR.CPP
  10 *
  11 * Modification History:
  12 *
  13 *   Date        Name        Description
  14 *   02/03/97    clhuang     Creation.
  15 *   04/22/97    aliu        Cleaned up, fixed memory leak, made
  16 *                           setWeekCountData() more robust.
  17 *                           Moved platform code to TPlatformUtilities.
  18 *   05/01/97    aliu        Made equals(), before(), after() arguments const.
  19 *   05/20/97    aliu        Changed logic of when to compute fields and time
  20 *                           to fix bugs.
  21 *   08/12/97    aliu        Added equivalentTo.  Misc other fixes.
  22 *   07/28/98    stephen     Sync up with JDK 1.2
  23 *   09/02/98    stephen     Sync with JDK 1.2 8/31 build (getActualMin/Max)
  24 *   03/17/99    stephen     Changed adoptTimeZone() - now fAreFieldsSet is
  25 *                           set to FALSE to force update of time.
  26 *******************************************************************************
  27 */
  28 
  29 #include &quot;utypeinfo.h&quot;  // for &#39;typeid&#39; to work
  30 
  31 #include &quot;unicode/utypes.h&quot;
  32 
  33 #if !UCONFIG_NO_FORMATTING
  34 
  35 #include &quot;unicode/gregocal.h&quot;
  36 #include &quot;unicode/basictz.h&quot;
  37 #include &quot;unicode/simpletz.h&quot;
  38 #include &quot;unicode/rbtz.h&quot;
  39 #include &quot;unicode/vtzone.h&quot;
  40 #include &quot;gregoimp.h&quot;
  41 #include &quot;buddhcal.h&quot;
  42 #include &quot;taiwncal.h&quot;
  43 #include &quot;japancal.h&quot;
  44 #include &quot;islamcal.h&quot;
  45 #include &quot;hebrwcal.h&quot;
  46 #include &quot;persncal.h&quot;
  47 #include &quot;indiancal.h&quot;
  48 #include &quot;chnsecal.h&quot;
  49 #include &quot;coptccal.h&quot;
  50 #include &quot;dangical.h&quot;
  51 #include &quot;ethpccal.h&quot;
  52 #include &quot;unicode/calendar.h&quot;
  53 #include &quot;cpputils.h&quot;
  54 #include &quot;servloc.h&quot;
  55 #include &quot;ucln_in.h&quot;
  56 #include &quot;cstring.h&quot;
  57 #include &quot;locbased.h&quot;
  58 #include &quot;uresimp.h&quot;
  59 #include &quot;ustrenum.h&quot;
  60 #include &quot;uassert.h&quot;
  61 #include &quot;olsontz.h&quot;
  62 #include &quot;sharedcalendar.h&quot;
  63 #include &quot;unifiedcache.h&quot;
  64 #include &quot;ulocimp.h&quot;
  65 
  66 #if !UCONFIG_NO_SERVICE
  67 static icu::ICULocaleService* gService = NULL;
  68 static icu::UInitOnce gServiceInitOnce = U_INITONCE_INITIALIZER;
  69 
  70 // INTERNAL - for cleanup
  71 U_CDECL_BEGIN
  72 static UBool calendar_cleanup(void) {
  73 #if !UCONFIG_NO_SERVICE
  74     if (gService) {
  75         delete gService;
  76         gService = NULL;
  77     }
  78     gServiceInitOnce.reset();
  79 #endif
  80     return TRUE;
  81 }
  82 U_CDECL_END
  83 #endif
  84 
  85 // ------------------------------------------
  86 //
  87 // Registration
  88 //
  89 //-------------------------------------------
  90 //#define U_DEBUG_CALSVC 1
  91 //
  92 
  93 #if defined( U_DEBUG_CALSVC ) || defined (U_DEBUG_CAL)
  94 
  95 /**
  96  * fldName was removed as a duplicate implementation.
  97  * use  udbg_ services instead,
  98  * which depend on include files and library from ../tools/toolutil, the following circular link:
  99  *   CPPFLAGS+=-I$(top_srcdir)/tools/toolutil
 100  *   LIBS+=$(LIBICUTOOLUTIL)
 101  */
 102 #include &quot;udbgutil.h&quot;
 103 #include &lt;stdio.h&gt;
 104 
 105 /**
 106 * convert a UCalendarDateFields into a string - for debugging
 107 * @param f field enum
 108 * @return static string to the field name
 109 * @internal
 110 */
 111 
 112 const char* fldName(UCalendarDateFields f) {
 113     return udbg_enumName(UDBG_UCalendarDateFields, (int32_t)f);
 114 }
 115 
 116 #if UCAL_DEBUG_DUMP
 117 // from CalendarTest::calToStr - but doesn&#39;t modify contents.
 118 void ucal_dump(const Calendar &amp;cal) {
 119     cal.dump();
 120 }
 121 
 122 void Calendar::dump() const {
 123     int i;
 124     fprintf(stderr, &quot;@calendar=%s, timeset=%c, fieldset=%c, allfields=%c, virtualset=%c, t=%.2f&quot;,
 125         getType(), fIsTimeSet?&#39;y&#39;:&#39;n&#39;,  fAreFieldsSet?&#39;y&#39;:&#39;n&#39;,  fAreAllFieldsSet?&#39;y&#39;:&#39;n&#39;,
 126         fAreFieldsVirtuallySet?&#39;y&#39;:&#39;n&#39;,
 127         fTime);
 128 
 129     // can add more things here: DST, zone, etc.
 130     fprintf(stderr, &quot;\n&quot;);
 131     for(i = 0;i&lt;UCAL_FIELD_COUNT;i++) {
 132         int n;
 133         const char *f = fldName((UCalendarDateFields)i);
 134         fprintf(stderr, &quot;  %25s: %-11ld&quot;, f, fFields[i]);
 135         if(fStamp[i] == kUnset) {
 136             fprintf(stderr, &quot; (unset) &quot;);
 137         } else if(fStamp[i] == kInternallySet) {
 138             fprintf(stderr, &quot; (internally set) &quot;);
 139             //} else if(fStamp[i] == kInternalDefault) {
 140             //    fprintf(stderr, &quot; (internal default) &quot;);
 141         } else {
 142             fprintf(stderr, &quot; %%%d &quot;, fStamp[i]);
 143         }
 144         fprintf(stderr, &quot;\n&quot;);
 145 
 146     }
 147 }
 148 
 149 U_CFUNC void ucal_dump(UCalendar* cal) {
 150     ucal_dump( *((Calendar*)cal)  );
 151 }
 152 #endif
 153 
 154 #endif
 155 
 156 /* Max value for stamp allowable before recalculation */
 157 #define STAMP_MAX 10000
 158 
 159 static const char * const gCalTypes[] = {
 160     &quot;gregorian&quot;,
 161     &quot;japanese&quot;,
 162     &quot;buddhist&quot;,
 163     &quot;roc&quot;,
 164     &quot;persian&quot;,
 165     &quot;islamic-civil&quot;,
 166     &quot;islamic&quot;,
 167     &quot;hebrew&quot;,
 168     &quot;chinese&quot;,
 169     &quot;indian&quot;,
 170     &quot;coptic&quot;,
 171     &quot;ethiopic&quot;,
 172     &quot;ethiopic-amete-alem&quot;,
 173     &quot;iso8601&quot;,
 174     &quot;dangi&quot;,
 175     &quot;islamic-umalqura&quot;,
 176     &quot;islamic-tbla&quot;,
 177     &quot;islamic-rgsa&quot;,
 178     NULL
 179 };
 180 
 181 // Must be in the order of gCalTypes above
 182 typedef enum ECalType {
 183     CALTYPE_UNKNOWN = -1,
 184     CALTYPE_GREGORIAN = 0,
 185     CALTYPE_JAPANESE,
 186     CALTYPE_BUDDHIST,
 187     CALTYPE_ROC,
 188     CALTYPE_PERSIAN,
 189     CALTYPE_ISLAMIC_CIVIL,
 190     CALTYPE_ISLAMIC,
 191     CALTYPE_HEBREW,
 192     CALTYPE_CHINESE,
 193     CALTYPE_INDIAN,
 194     CALTYPE_COPTIC,
 195     CALTYPE_ETHIOPIC,
 196     CALTYPE_ETHIOPIC_AMETE_ALEM,
 197     CALTYPE_ISO8601,
 198     CALTYPE_DANGI,
 199     CALTYPE_ISLAMIC_UMALQURA,
 200     CALTYPE_ISLAMIC_TBLA,
 201     CALTYPE_ISLAMIC_RGSA
 202 } ECalType;
 203 
 204 U_NAMESPACE_BEGIN
 205 
 206 SharedCalendar::~SharedCalendar() {
 207     delete ptr;
 208 }
 209 
 210 template&lt;&gt; U_I18N_API
 211 const SharedCalendar *LocaleCacheKey&lt;SharedCalendar&gt;::createObject(
 212         const void * /*unusedCreationContext*/, UErrorCode &amp;status) const {
 213     Calendar *calendar = Calendar::makeInstance(fLoc, status);
 214     if (U_FAILURE(status)) {
 215         return NULL;
 216     }
 217     SharedCalendar *shared = new SharedCalendar(calendar);
 218     if (shared == NULL) {
 219         delete calendar;
 220         status = U_MEMORY_ALLOCATION_ERROR;
 221         return NULL;
 222     }
 223     shared-&gt;addRef();
 224     return shared;
 225 }
 226 
 227 static ECalType getCalendarType(const char *s) {
 228     for (int i = 0; gCalTypes[i] != NULL; i++) {
 229         if (uprv_stricmp(s, gCalTypes[i]) == 0) {
 230             return (ECalType)i;
 231         }
 232     }
 233     return CALTYPE_UNKNOWN;
 234 }
 235 
 236 #if !UCONFIG_NO_SERVICE
 237 // Only used with service registration.
 238 static UBool isStandardSupportedKeyword(const char *keyword, UErrorCode&amp; status) {
 239     if(U_FAILURE(status)) {
 240         return FALSE;
 241     }
 242     ECalType calType = getCalendarType(keyword);
 243     return (calType != CALTYPE_UNKNOWN);
 244 }
 245 
 246 // only used with service registration.
 247 static void getCalendarKeyword(const UnicodeString &amp;id, char *targetBuffer, int32_t targetBufferSize) {
 248     UnicodeString calendarKeyword = UNICODE_STRING_SIMPLE(&quot;calendar=&quot;);
 249     int32_t calKeyLen = calendarKeyword.length();
 250     int32_t keyLen = 0;
 251 
 252     int32_t keywordIdx = id.indexOf((UChar)0x003D); /* &#39;=&#39; */
 253     if (id[0] == 0x40/*&#39;@&#39;*/
 254         &amp;&amp; id.compareBetween(1, keywordIdx+1, calendarKeyword, 0, calKeyLen) == 0)
 255     {
 256         keyLen = id.extract(keywordIdx+1, id.length(), targetBuffer, targetBufferSize, US_INV);
 257     }
 258     targetBuffer[keyLen] = 0;
 259 }
 260 #endif
 261 
 262 static ECalType getCalendarTypeForLocale(const char *locid) {
 263     UErrorCode status = U_ZERO_ERROR;
 264     ECalType calType = CALTYPE_UNKNOWN;
 265 
 266     //TODO: ULOC_FULL_NAME is out of date and too small..
 267     char canonicalName[256];
 268 
 269     // canonicalize, so grandfathered variant will be transformed to keywords
 270     // e.g ja_JP_TRADITIONAL -&gt; ja_JP@calendar=japanese
 271     int32_t canonicalLen = uloc_canonicalize(locid, canonicalName, sizeof(canonicalName) - 1, &amp;status);
 272     if (U_FAILURE(status)) {
 273         return CALTYPE_GREGORIAN;
 274     }
 275     canonicalName[canonicalLen] = 0;    // terminate
 276 
 277     char calTypeBuf[32];
 278     int32_t calTypeBufLen;
 279 
 280     calTypeBufLen = uloc_getKeywordValue(canonicalName, &quot;calendar&quot;, calTypeBuf, sizeof(calTypeBuf) - 1, &amp;status);
 281     if (U_SUCCESS(status)) {
 282         calTypeBuf[calTypeBufLen] = 0;
 283         calType = getCalendarType(calTypeBuf);
 284         if (calType != CALTYPE_UNKNOWN) {
 285             return calType;
 286         }
 287     }
 288     status = U_ZERO_ERROR;
 289 
 290     // when calendar keyword is not available or not supported, read supplementalData
 291     // to get the default calendar type for the locale&#39;s region
 292     char region[ULOC_COUNTRY_CAPACITY];
 293     (void)ulocimp_getRegionForSupplementalData(canonicalName, TRUE, region, sizeof(region), &amp;status);
 294     if (U_FAILURE(status)) {
 295         return CALTYPE_GREGORIAN;
 296     }
 297 
 298     // Read preferred calendar values from supplementalData calendarPreference
 299     UResourceBundle *rb = ures_openDirect(NULL, &quot;supplementalData&quot;, &amp;status);
 300     ures_getByKey(rb, &quot;calendarPreferenceData&quot;, rb, &amp;status);
 301     UResourceBundle *order = ures_getByKey(rb, region, NULL, &amp;status);
 302     if (status == U_MISSING_RESOURCE_ERROR &amp;&amp; rb != NULL) {
 303         status = U_ZERO_ERROR;
 304         order = ures_getByKey(rb, &quot;001&quot;, NULL, &amp;status);
 305     }
 306 
 307     calTypeBuf[0] = 0;
 308     if (U_SUCCESS(status) &amp;&amp; order != NULL) {
 309         // the first calender type is the default for the region
 310         int32_t len = 0;
 311         const UChar *uCalType = ures_getStringByIndex(order, 0, &amp;len, &amp;status);
 312         if (len &lt; (int32_t)sizeof(calTypeBuf)) {
 313             u_UCharsToChars(uCalType, calTypeBuf, len);
 314             *(calTypeBuf + len) = 0; // terminate;
 315             calType = getCalendarType(calTypeBuf);
 316         }
 317     }
 318 
 319     ures_close(order);
 320     ures_close(rb);
 321 
 322     if (calType == CALTYPE_UNKNOWN) {
 323         // final fallback
 324         calType = CALTYPE_GREGORIAN;
 325     }
 326     return calType;
 327 }
 328 
 329 static Calendar *createStandardCalendar(ECalType calType, const Locale &amp;loc, UErrorCode&amp; status) {
<a name="1" id="anc1"></a><span class="line-modified"> 330     if (U_FAILURE(status)) {</span>
<span class="line-added"> 331         return nullptr;</span>
<span class="line-added"> 332     }</span>
<span class="line-added"> 333     LocalPointer&lt;Calendar&gt; cal;</span>
 334 
 335     switch (calType) {
 336         case CALTYPE_GREGORIAN:
<a name="2" id="anc2"></a><span class="line-modified"> 337             cal.adoptInsteadAndCheckErrorCode(new GregorianCalendar(loc, status), status);</span>
 338             break;
 339         case CALTYPE_JAPANESE:
<a name="3" id="anc3"></a><span class="line-modified"> 340             cal.adoptInsteadAndCheckErrorCode(new JapaneseCalendar(loc, status), status);</span>
 341             break;
 342         case CALTYPE_BUDDHIST:
<a name="4" id="anc4"></a><span class="line-modified"> 343             cal.adoptInsteadAndCheckErrorCode(new BuddhistCalendar(loc, status), status);</span>
 344             break;
 345         case CALTYPE_ROC:
<a name="5" id="anc5"></a><span class="line-modified"> 346             cal.adoptInsteadAndCheckErrorCode(new TaiwanCalendar(loc, status), status);</span>
 347             break;
 348         case CALTYPE_PERSIAN:
<a name="6" id="anc6"></a><span class="line-modified"> 349             cal.adoptInsteadAndCheckErrorCode(new PersianCalendar(loc, status), status);</span>
 350             break;
 351         case CALTYPE_ISLAMIC_TBLA:
<a name="7" id="anc7"></a><span class="line-modified"> 352             cal.adoptInsteadAndCheckErrorCode(new IslamicCalendar(loc, status, IslamicCalendar::TBLA), status);</span>
 353             break;
 354         case CALTYPE_ISLAMIC_CIVIL:
<a name="8" id="anc8"></a><span class="line-modified"> 355             cal.adoptInsteadAndCheckErrorCode(new IslamicCalendar(loc, status, IslamicCalendar::CIVIL), status);</span>
 356             break;
 357         case CALTYPE_ISLAMIC_RGSA:
 358             // default any region specific not handled individually to islamic
 359         case CALTYPE_ISLAMIC:
<a name="9" id="anc9"></a><span class="line-modified"> 360             cal.adoptInsteadAndCheckErrorCode(new IslamicCalendar(loc, status, IslamicCalendar::ASTRONOMICAL), status);</span>
 361             break;
 362         case CALTYPE_ISLAMIC_UMALQURA:
<a name="10" id="anc10"></a><span class="line-modified"> 363             cal.adoptInsteadAndCheckErrorCode(new IslamicCalendar(loc, status, IslamicCalendar::UMALQURA), status);</span>
 364             break;
 365         case CALTYPE_HEBREW:
<a name="11" id="anc11"></a><span class="line-modified"> 366             cal.adoptInsteadAndCheckErrorCode(new HebrewCalendar(loc, status), status);</span>
 367             break;
 368         case CALTYPE_CHINESE:
<a name="12" id="anc12"></a><span class="line-modified"> 369             cal.adoptInsteadAndCheckErrorCode(new ChineseCalendar(loc, status), status);</span>
 370             break;
 371         case CALTYPE_INDIAN:
<a name="13" id="anc13"></a><span class="line-modified"> 372             cal.adoptInsteadAndCheckErrorCode(new IndianCalendar(loc, status), status);</span>
 373             break;
 374         case CALTYPE_COPTIC:
<a name="14" id="anc14"></a><span class="line-modified"> 375             cal.adoptInsteadAndCheckErrorCode(new CopticCalendar(loc, status), status);</span>
 376             break;
 377         case CALTYPE_ETHIOPIC:
<a name="15" id="anc15"></a><span class="line-modified"> 378             cal.adoptInsteadAndCheckErrorCode(new EthiopicCalendar(loc, status, EthiopicCalendar::AMETE_MIHRET_ERA), status);</span>
 379             break;
 380         case CALTYPE_ETHIOPIC_AMETE_ALEM:
<a name="16" id="anc16"></a><span class="line-modified"> 381             cal.adoptInsteadAndCheckErrorCode(new EthiopicCalendar(loc, status, EthiopicCalendar::AMETE_ALEM_ERA), status);</span>
 382             break;
 383         case CALTYPE_ISO8601:
<a name="17" id="anc17"></a><span class="line-modified"> 384             cal.adoptInsteadAndCheckErrorCode(new GregorianCalendar(loc, status), status);</span>
<span class="line-modified"> 385             if (cal.isValid()) {</span>
<span class="line-modified"> 386                 cal-&gt;setFirstDayOfWeek(UCAL_MONDAY);</span>
<span class="line-added"> 387                 cal-&gt;setMinimalDaysInFirstWeek(4);</span>
<span class="line-added"> 388             }</span>
 389             break;
 390         case CALTYPE_DANGI:
<a name="18" id="anc18"></a><span class="line-modified"> 391             cal.adoptInsteadAndCheckErrorCode(new DangiCalendar(loc, status), status);</span>
 392             break;
 393         default:
 394             status = U_UNSUPPORTED_ERROR;
 395     }
<a name="19" id="anc19"></a><span class="line-modified"> 396     return cal.orphan();</span>
 397 }
 398 
 399 
 400 #if !UCONFIG_NO_SERVICE
 401 
 402 // -------------------------------------
 403 
 404 /**
 405 * a Calendar Factory which creates the &quot;basic&quot; calendar types, that is, those
 406 * shipped with ICU.
 407 */
 408 class BasicCalendarFactory : public LocaleKeyFactory {
 409 public:
 410     /**
 411     * @param calendarType static const string (caller owns storage - will be aliased) to calendar type
 412     */
 413     BasicCalendarFactory()
 414         : LocaleKeyFactory(LocaleKeyFactory::INVISIBLE) { }
 415 
 416     virtual ~BasicCalendarFactory();
 417 
 418 protected:
 419     //virtual UBool isSupportedID( const UnicodeString&amp; id, UErrorCode&amp; status) const {
 420     //  if(U_FAILURE(status)) {
 421     //    return FALSE;
 422     //  }
 423     //  char keyword[ULOC_FULLNAME_CAPACITY];
 424     //  getCalendarKeyword(id, keyword, (int32_t)sizeof(keyword));
 425     //  return isStandardSupportedKeyword(keyword, status);
 426     //}
 427 
 428     virtual void updateVisibleIDs(Hashtable&amp; result, UErrorCode&amp; status) const
 429     {
 430         if (U_SUCCESS(status)) {
 431             for(int32_t i=0;gCalTypes[i] != NULL;i++) {
 432                 UnicodeString id((UChar)0x40); /* &#39;@&#39; a variant character */
 433                 id.append(UNICODE_STRING_SIMPLE(&quot;calendar=&quot;));
 434                 id.append(UnicodeString(gCalTypes[i], -1, US_INV));
 435                 result.put(id, (void*)this, status);
 436             }
 437         }
 438     }
 439 
 440     virtual UObject* create(const ICUServiceKey&amp; key, const ICUService* /*service*/, UErrorCode&amp; status) const {
 441 #ifdef U_DEBUG_CALSVC
 442         if(dynamic_cast&lt;const LocaleKey*&gt;(&amp;key) == NULL) {
 443             fprintf(stderr, &quot;::create - not a LocaleKey!\n&quot;);
 444         }
 445 #endif
 446         const LocaleKey&amp; lkey = (LocaleKey&amp;)key;
 447         Locale curLoc;  // current locale
 448         Locale canLoc;  // Canonical locale
 449 
 450         lkey.currentLocale(curLoc);
 451         lkey.canonicalLocale(canLoc);
 452 
 453         char keyword[ULOC_FULLNAME_CAPACITY];
 454         UnicodeString str;
 455 
 456         key.currentID(str);
 457         getCalendarKeyword(str, keyword, (int32_t) sizeof(keyword));
 458 
 459 #ifdef U_DEBUG_CALSVC
 460         fprintf(stderr, &quot;BasicCalendarFactory::create() - cur %s, can %s\n&quot;, (const char*)curLoc.getName(), (const char*)canLoc.getName());
 461 #endif
 462 
 463         if(!isStandardSupportedKeyword(keyword,status)) {  // Do we handle this type?
 464 #ifdef U_DEBUG_CALSVC
 465 
 466             fprintf(stderr, &quot;BasicCalendarFactory - not handling %s.[%s]\n&quot;, (const char*) curLoc.getName(), tmp );
 467 #endif
 468             return NULL;
 469         }
 470 
 471         return createStandardCalendar(getCalendarType(keyword), canLoc, status);
 472     }
 473 };
 474 
 475 BasicCalendarFactory::~BasicCalendarFactory() {}
 476 
 477 /**
 478 * A factory which looks up the DefaultCalendar resource to determine which class of calendar to use
 479 */
 480 
 481 class DefaultCalendarFactory : public ICUResourceBundleFactory {
 482 public:
 483     DefaultCalendarFactory() : ICUResourceBundleFactory() { }
 484     virtual ~DefaultCalendarFactory();
 485 protected:
 486     virtual UObject* create(const ICUServiceKey&amp; key, const ICUService* /*service*/, UErrorCode&amp; status) const  {
 487 
 488         LocaleKey &amp;lkey = (LocaleKey&amp;)key;
 489         Locale loc;
 490         lkey.currentLocale(loc);
 491 
 492         UnicodeString *ret = new UnicodeString();
 493         if (ret == NULL) {
 494             status = U_MEMORY_ALLOCATION_ERROR;
 495         } else {
 496             ret-&gt;append((UChar)0x40); // &#39;@&#39; is a variant character
 497             ret-&gt;append(UNICODE_STRING(&quot;calendar=&quot;, 9));
 498             ret-&gt;append(UnicodeString(gCalTypes[getCalendarTypeForLocale(loc.getName())], -1, US_INV));
 499         }
 500         return ret;
 501     }
 502 };
 503 
 504 DefaultCalendarFactory::~DefaultCalendarFactory() {}
 505 
 506 // -------------------------------------
 507 class CalendarService : public ICULocaleService {
 508 public:
 509     CalendarService()
 510         : ICULocaleService(UNICODE_STRING_SIMPLE(&quot;Calendar&quot;))
 511     {
 512         UErrorCode status = U_ZERO_ERROR;
 513         registerFactory(new DefaultCalendarFactory(), status);
 514     }
 515 
 516     virtual ~CalendarService();
 517 
 518     virtual UObject* cloneInstance(UObject* instance) const {
 519         UnicodeString *s = dynamic_cast&lt;UnicodeString *&gt;(instance);
 520         if(s != NULL) {
 521             return s-&gt;clone();
 522         } else {
 523 #ifdef U_DEBUG_CALSVC_F
 524             UErrorCode status2 = U_ZERO_ERROR;
 525             fprintf(stderr, &quot;Cloning a %s calendar with tz=%ld\n&quot;, ((Calendar*)instance)-&gt;getType(), ((Calendar*)instance)-&gt;get(UCAL_ZONE_OFFSET, status2));
 526 #endif
 527             return ((Calendar*)instance)-&gt;clone();
 528         }
 529     }
 530 
 531     virtual UObject* handleDefault(const ICUServiceKey&amp; key, UnicodeString* /*actualID*/, UErrorCode&amp; status) const {
 532         LocaleKey&amp; lkey = (LocaleKey&amp;)key;
 533         //int32_t kind = lkey.kind();
 534 
 535         Locale loc;
 536         lkey.canonicalLocale(loc);
 537 
 538 #ifdef U_DEBUG_CALSVC
 539         Locale loc2;
 540         lkey.currentLocale(loc2);
 541         fprintf(stderr, &quot;CalSvc:handleDefault for currentLoc %s, canloc %s\n&quot;, (const char*)loc.getName(),  (const char*)loc2.getName());
 542 #endif
 543         Calendar *nc =  new GregorianCalendar(loc, status);
<a name="20" id="anc20"></a><span class="line-added"> 544         if (nc == nullptr) {</span>
<span class="line-added"> 545             status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added"> 546             return nc;</span>
<span class="line-added"> 547         }</span>
 548 
 549 #ifdef U_DEBUG_CALSVC
 550         UErrorCode status2 = U_ZERO_ERROR;
 551         fprintf(stderr, &quot;New default calendar has tz=%d\n&quot;, ((Calendar*)nc)-&gt;get(UCAL_ZONE_OFFSET, status2));
 552 #endif
 553         return nc;
 554     }
 555 
 556     virtual UBool isDefault() const {
 557         return countFactories() == 1;
 558     }
 559 };
 560 
 561 CalendarService::~CalendarService() {}
 562 
 563 // -------------------------------------
 564 
 565 static inline UBool
 566 isCalendarServiceUsed() {
 567     return !gServiceInitOnce.isReset();
 568 }
 569 
 570 // -------------------------------------
 571 
 572 static void U_CALLCONV
 573 initCalendarService(UErrorCode &amp;status)
 574 {
 575 #ifdef U_DEBUG_CALSVC
 576         fprintf(stderr, &quot;Spinning up Calendar Service\n&quot;);
 577 #endif
 578     ucln_i18n_registerCleanup(UCLN_I18N_CALENDAR, calendar_cleanup);
 579     gService = new CalendarService();
 580     if (gService == NULL) {
 581             status = U_MEMORY_ALLOCATION_ERROR;
 582         return;
 583         }
 584 #ifdef U_DEBUG_CALSVC
 585         fprintf(stderr, &quot;Registering classes..\n&quot;);
 586 #endif
 587 
 588         // Register all basic instances.
 589     gService-&gt;registerFactory(new BasicCalendarFactory(),status);
 590 
 591 #ifdef U_DEBUG_CALSVC
 592         fprintf(stderr, &quot;Done..\n&quot;);
 593 #endif
 594 
 595         if(U_FAILURE(status)) {
 596 #ifdef U_DEBUG_CALSVC
 597             fprintf(stderr, &quot;err (%s) registering classes, deleting service.....\n&quot;, u_errorName(status));
 598 #endif
 599         delete gService;
 600         gService = NULL;
 601     }
 602         }
 603 
 604 static ICULocaleService*
 605 getCalendarService(UErrorCode &amp;status)
 606 {
 607     umtx_initOnce(gServiceInitOnce, &amp;initCalendarService, status);
 608     return gService;
 609 }
 610 
 611 URegistryKey Calendar::registerFactory(ICUServiceFactory* toAdopt, UErrorCode&amp; status)
 612 {
 613     return getCalendarService(status)-&gt;registerFactory(toAdopt, status);
 614 }
 615 
 616 UBool Calendar::unregister(URegistryKey key, UErrorCode&amp; status) {
 617     return getCalendarService(status)-&gt;unregister(key, status);
 618 }
 619 #endif /* UCONFIG_NO_SERVICE */
 620 
 621 // -------------------------------------
 622 
 623 static const int32_t kCalendarLimits[UCAL_FIELD_COUNT][4] = {
 624     //    Minimum  Greatest min      Least max   Greatest max
 625     {/*N/A*/-1,       /*N/A*/-1,     /*N/A*/-1,       /*N/A*/-1}, // ERA
 626     {/*N/A*/-1,       /*N/A*/-1,     /*N/A*/-1,       /*N/A*/-1}, // YEAR
 627     {/*N/A*/-1,       /*N/A*/-1,     /*N/A*/-1,       /*N/A*/-1}, // MONTH
 628     {/*N/A*/-1,       /*N/A*/-1,     /*N/A*/-1,       /*N/A*/-1}, // WEEK_OF_YEAR
 629     {/*N/A*/-1,       /*N/A*/-1,     /*N/A*/-1,       /*N/A*/-1}, // WEEK_OF_MONTH
 630     {/*N/A*/-1,       /*N/A*/-1,     /*N/A*/-1,       /*N/A*/-1}, // DAY_OF_MONTH
 631     {/*N/A*/-1,       /*N/A*/-1,     /*N/A*/-1,       /*N/A*/-1}, // DAY_OF_YEAR
 632     {           1,            1,             7,             7  }, // DAY_OF_WEEK
 633     {/*N/A*/-1,       /*N/A*/-1,     /*N/A*/-1,       /*N/A*/-1}, // DAY_OF_WEEK_IN_MONTH
 634     {           0,            0,             1,             1  }, // AM_PM
 635     {           0,            0,            11,            11  }, // HOUR
 636     {           0,            0,            23,            23  }, // HOUR_OF_DAY
 637     {           0,            0,            59,            59  }, // MINUTE
 638     {           0,            0,            59,            59  }, // SECOND
 639     {           0,            0,           999,           999  }, // MILLISECOND
 640     {-12*kOneHour, -12*kOneHour,   12*kOneHour,   15*kOneHour  }, // ZONE_OFFSET
 641     {           0,            0,    1*kOneHour,    1*kOneHour  }, // DST_OFFSET
 642     {/*N/A*/-1,       /*N/A*/-1,     /*N/A*/-1,       /*N/A*/-1}, // YEAR_WOY
 643     {           1,            1,             7,             7  }, // DOW_LOCAL
 644     {/*N/A*/-1,       /*N/A*/-1,     /*N/A*/-1,       /*N/A*/-1}, // EXTENDED_YEAR
 645     { -0x7F000000,  -0x7F000000,    0x7F000000,    0x7F000000  }, // JULIAN_DAY
 646     {           0,            0, 24*kOneHour-1, 24*kOneHour-1  }, // MILLISECONDS_IN_DAY
 647     {           0,            0,             1,             1  }, // IS_LEAP_MONTH
 648 };
 649 
 650 // Resource bundle tags read by this class
 651 static const char gCalendar[] = &quot;calendar&quot;;
 652 static const char gMonthNames[] = &quot;monthNames&quot;;
 653 static const char gGregorian[] = &quot;gregorian&quot;;
 654 
 655 // Data flow in Calendar
 656 // ---------------------
 657 
 658 // The current time is represented in two ways by Calendar: as UTC
 659 // milliseconds from the epoch start (1 January 1970 0:00 UTC), and as local
 660 // fields such as MONTH, HOUR, AM_PM, etc.  It is possible to compute the
 661 // millis from the fields, and vice versa.  The data needed to do this
 662 // conversion is encapsulated by a TimeZone object owned by the Calendar.
 663 // The data provided by the TimeZone object may also be overridden if the
 664 // user sets the ZONE_OFFSET and/or DST_OFFSET fields directly. The class
 665 // keeps track of what information was most recently set by the caller, and
 666 // uses that to compute any other information as needed.
 667 
 668 // If the user sets the fields using set(), the data flow is as follows.
 669 // This is implemented by the Calendar subclass&#39;s computeTime() method.
 670 // During this process, certain fields may be ignored.  The disambiguation
 671 // algorithm for resolving which fields to pay attention to is described
 672 // above.
 673 
 674 //   local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)
 675 //           |
 676 //           | Using Calendar-specific algorithm
 677 //           V
 678 //   local standard millis
 679 //           |
 680 //           | Using TimeZone or user-set ZONE_OFFSET / DST_OFFSET
 681 //           V
 682 //   UTC millis (in time data member)
 683 
 684 // If the user sets the UTC millis using setTime(), the data flow is as
 685 // follows.  This is implemented by the Calendar subclass&#39;s computeFields()
 686 // method.
 687 
 688 //   UTC millis (in time data member)
 689 //           |
 690 //           | Using TimeZone getOffset()
 691 //           V
 692 //   local standard millis
 693 //           |
 694 //           | Using Calendar-specific algorithm
 695 //           V
 696 //   local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)
 697 
 698 // In general, a round trip from fields, through local and UTC millis, and
 699 // back out to fields is made when necessary.  This is implemented by the
 700 // complete() method.  Resolving a partial set of fields into a UTC millis
 701 // value allows all remaining fields to be generated from that value.  If
 702 // the Calendar is lenient, the fields are also renormalized to standard
 703 // ranges when they are regenerated.
 704 
 705 // -------------------------------------
 706 
 707 Calendar::Calendar(UErrorCode&amp; success)
 708 :   UObject(),
 709 fIsTimeSet(FALSE),
 710 fAreFieldsSet(FALSE),
 711 fAreAllFieldsSet(FALSE),
 712 fAreFieldsVirtuallySet(FALSE),
 713 fNextStamp((int32_t)kMinimumUserStamp),
 714 fTime(0),
 715 fLenient(TRUE),
 716 fZone(NULL),
 717 fRepeatedWallTime(UCAL_WALLTIME_LAST),
 718 fSkippedWallTime(UCAL_WALLTIME_LAST)
 719 {
 720     validLocale[0] = 0;
 721     actualLocale[0] = 0;
 722     clear();
 723     if (U_FAILURE(success)) {
 724         return;
 725     }
 726     fZone = TimeZone::createDefault();
 727     if (fZone == NULL) {
 728         success = U_MEMORY_ALLOCATION_ERROR;
 729     }
 730     setWeekData(Locale::getDefault(), NULL, success);
 731 }
 732 
 733 // -------------------------------------
 734 
 735 Calendar::Calendar(TimeZone* zone, const Locale&amp; aLocale, UErrorCode&amp; success)
 736 :   UObject(),
 737 fIsTimeSet(FALSE),
 738 fAreFieldsSet(FALSE),
 739 fAreAllFieldsSet(FALSE),
 740 fAreFieldsVirtuallySet(FALSE),
 741 fNextStamp((int32_t)kMinimumUserStamp),
 742 fTime(0),
 743 fLenient(TRUE),
 744 fZone(NULL),
 745 fRepeatedWallTime(UCAL_WALLTIME_LAST),
 746 fSkippedWallTime(UCAL_WALLTIME_LAST)
 747 {
 748     validLocale[0] = 0;
 749     actualLocale[0] = 0;
 750     if (U_FAILURE(success)) {
 751         return;
 752     }
 753     if(zone == 0) {
 754 #if defined (U_DEBUG_CAL)
 755         fprintf(stderr, &quot;%s:%d: ILLEGAL ARG because timezone cannot be 0\n&quot;,
 756             __FILE__, __LINE__);
 757 #endif
 758         success = U_ILLEGAL_ARGUMENT_ERROR;
 759         return;
 760     }
 761 
 762     clear();
 763     fZone = zone;
 764     setWeekData(aLocale, NULL, success);
 765 }
 766 
 767 // -------------------------------------
 768 
 769 Calendar::Calendar(const TimeZone&amp; zone, const Locale&amp; aLocale, UErrorCode&amp; success)
 770 :   UObject(),
 771 fIsTimeSet(FALSE),
 772 fAreFieldsSet(FALSE),
 773 fAreAllFieldsSet(FALSE),
 774 fAreFieldsVirtuallySet(FALSE),
 775 fNextStamp((int32_t)kMinimumUserStamp),
 776 fTime(0),
 777 fLenient(TRUE),
 778 fZone(NULL),
 779 fRepeatedWallTime(UCAL_WALLTIME_LAST),
 780 fSkippedWallTime(UCAL_WALLTIME_LAST)
 781 {
 782     validLocale[0] = 0;
 783     actualLocale[0] = 0;
 784     if (U_FAILURE(success)) {
 785         return;
 786     }
 787     clear();
 788     fZone = zone.clone();
 789     if (fZone == NULL) {
 790         success = U_MEMORY_ALLOCATION_ERROR;
 791     }
 792     setWeekData(aLocale, NULL, success);
 793 }
 794 
 795 // -------------------------------------
 796 
 797 Calendar::~Calendar()
 798 {
 799     delete fZone;
 800 }
 801 
 802 // -------------------------------------
 803 
 804 Calendar::Calendar(const Calendar &amp;source)
 805 :   UObject(source)
 806 {
 807     fZone = NULL;
 808     *this = source;
 809 }
 810 
 811 // -------------------------------------
 812 
 813 Calendar &amp;
 814 Calendar::operator=(const Calendar &amp;right)
 815 {
 816     if (this != &amp;right) {
 817         uprv_arrayCopy(right.fFields, fFields, UCAL_FIELD_COUNT);
 818         uprv_arrayCopy(right.fIsSet, fIsSet, UCAL_FIELD_COUNT);
 819         uprv_arrayCopy(right.fStamp, fStamp, UCAL_FIELD_COUNT);
 820         fTime                    = right.fTime;
 821         fIsTimeSet               = right.fIsTimeSet;
 822         fAreAllFieldsSet         = right.fAreAllFieldsSet;
 823         fAreFieldsSet            = right.fAreFieldsSet;
 824         fAreFieldsVirtuallySet   = right.fAreFieldsVirtuallySet;
 825         fLenient                 = right.fLenient;
 826         fRepeatedWallTime        = right.fRepeatedWallTime;
 827         fSkippedWallTime         = right.fSkippedWallTime;
 828         delete fZone;
 829         fZone = NULL;
 830         if (right.fZone != NULL) {
 831             fZone                = right.fZone-&gt;clone();
 832         }
 833         fFirstDayOfWeek          = right.fFirstDayOfWeek;
 834         fMinimalDaysInFirstWeek  = right.fMinimalDaysInFirstWeek;
 835         fWeekendOnset            = right.fWeekendOnset;
 836         fWeekendOnsetMillis      = right.fWeekendOnsetMillis;
 837         fWeekendCease            = right.fWeekendCease;
 838         fWeekendCeaseMillis      = right.fWeekendCeaseMillis;
 839         fNextStamp               = right.fNextStamp;
 840         uprv_strncpy(validLocale, right.validLocale, sizeof(validLocale));
 841         uprv_strncpy(actualLocale, right.actualLocale, sizeof(actualLocale));
 842         validLocale[sizeof(validLocale)-1] = 0;
 843         actualLocale[sizeof(validLocale)-1] = 0;
 844     }
 845 
 846     return *this;
 847 }
 848 
 849 // -------------------------------------
 850 
 851 Calendar* U_EXPORT2
 852 Calendar::createInstance(UErrorCode&amp; success)
 853 {
 854     return createInstance(TimeZone::createDefault(), Locale::getDefault(), success);
 855 }
 856 
 857 // -------------------------------------
 858 
 859 Calendar* U_EXPORT2
 860 Calendar::createInstance(const TimeZone&amp; zone, UErrorCode&amp; success)
 861 {
 862     return createInstance(zone, Locale::getDefault(), success);
 863 }
 864 
 865 // -------------------------------------
 866 
 867 Calendar* U_EXPORT2
 868 Calendar::createInstance(const Locale&amp; aLocale, UErrorCode&amp; success)
 869 {
 870     return createInstance(TimeZone::createDefault(), aLocale, success);
 871 }
 872 
 873 // ------------------------------------- Adopting
 874 
 875 // Note: this is the bottleneck that actually calls the service routines.
 876 
 877 Calendar * U_EXPORT2
 878 Calendar::makeInstance(const Locale&amp; aLocale, UErrorCode&amp; success) {
 879     if (U_FAILURE(success)) {
 880         return NULL;
 881     }
 882 
 883     Locale actualLoc;
 884     UObject* u = NULL;
 885 
 886 #if !UCONFIG_NO_SERVICE
 887     if (isCalendarServiceUsed()) {
 888         u = getCalendarService(success)-&gt;get(aLocale, LocaleKey::KIND_ANY, &amp;actualLoc, success);
 889     }
 890     else
 891 #endif
 892     {
 893         u = createStandardCalendar(getCalendarTypeForLocale(aLocale.getName()), aLocale, success);
 894     }
 895     Calendar* c = NULL;
 896 
 897     if(U_FAILURE(success) || !u) {
 898         if(U_SUCCESS(success)) { // Propagate some kind of err
 899             success = U_INTERNAL_PROGRAM_ERROR;
 900         }
 901         return NULL;
 902     }
 903 
 904 #if !UCONFIG_NO_SERVICE
 905     const UnicodeString* str = dynamic_cast&lt;const UnicodeString*&gt;(u);
 906     if(str != NULL) {
 907         // It&#39;s a unicode string telling us what type of calendar to load (&quot;gregorian&quot;, etc)
 908         // Create a Locale over this string
 909         Locale l(&quot;&quot;);
 910         LocaleUtility::initLocaleFromName(*str, l);
 911 
 912 #ifdef U_DEBUG_CALSVC
 913         fprintf(stderr, &quot;Calendar::createInstance(%s), looking up [%s]\n&quot;, aLocale.getName(), l.getName());
 914 #endif
 915 
 916         Locale actualLoc2;
 917         delete u;
 918         u = NULL;
 919 
 920         // Don&#39;t overwrite actualLoc, since the actual loc from this call
 921         // may be something like &quot;@calendar=gregorian&quot; -- TODO investigate
 922         // further...
 923         c = (Calendar*)getCalendarService(success)-&gt;get(l, LocaleKey::KIND_ANY, &amp;actualLoc2, success);
 924 
 925         if(U_FAILURE(success) || !c) {
 926             if(U_SUCCESS(success)) {
 927                 success = U_INTERNAL_PROGRAM_ERROR; // Propagate some err
 928             }
 929             return NULL;
 930         }
 931 
 932         str = dynamic_cast&lt;const UnicodeString*&gt;(c);
 933         if(str != NULL) {
 934             // recursed! Second lookup returned a UnicodeString.
 935             // Perhaps DefaultCalendar{} was set to another locale.
 936 #ifdef U_DEBUG_CALSVC
 937             char tmp[200];
 938             // Extract a char* out of it..
 939             int32_t len = str-&gt;length();
 940             int32_t actLen = sizeof(tmp)-1;
 941             if(len &gt; actLen) {
 942                 len = actLen;
 943             }
 944             str-&gt;extract(0,len,tmp);
 945             tmp[len]=0;
 946 
 947             fprintf(stderr, &quot;err - recursed, 2nd lookup was unistring %s\n&quot;, tmp);
 948 #endif
 949             success = U_MISSING_RESOURCE_ERROR;  // requested a calendar type which could NOT be found.
 950             delete c;
 951             return NULL;
 952         }
 953 #ifdef U_DEBUG_CALSVC
 954         fprintf(stderr, &quot;%p: setting week count data to locale %s, actual locale %s\n&quot;, c, (const char*)aLocale.getName(), (const char *)actualLoc.getName());
 955 #endif
 956         c-&gt;setWeekData(aLocale, c-&gt;getType(), success);  // set the correct locale (this was an indirected calendar)
 957 
 958         char keyword[ULOC_FULLNAME_CAPACITY];
 959         UErrorCode tmpStatus = U_ZERO_ERROR;
 960         l.getKeywordValue(&quot;calendar&quot;, keyword, ULOC_FULLNAME_CAPACITY, tmpStatus);
 961         if (U_SUCCESS(tmpStatus) &amp;&amp; uprv_strcmp(keyword, &quot;iso8601&quot;) == 0) {
 962             c-&gt;setFirstDayOfWeek(UCAL_MONDAY);
 963             c-&gt;setMinimalDaysInFirstWeek(4);
 964         }
 965     }
 966     else
 967 #endif /* UCONFIG_NO_SERVICE */
 968     {
 969         // a calendar was returned - we assume the factory did the right thing.
 970         c = (Calendar*)u;
 971     }
 972 
 973     return c;
 974 }
 975 
 976 Calendar* U_EXPORT2
 977 Calendar::createInstance(TimeZone* zone, const Locale&amp; aLocale, UErrorCode&amp; success)
 978 {
 979     LocalPointer&lt;TimeZone&gt; zonePtr(zone);
 980     const SharedCalendar *shared = NULL;
 981     UnifiedCache::getByLocale(aLocale, shared, success);
 982     if (U_FAILURE(success)) {
 983         return NULL;
 984     }
 985     Calendar *c = (*shared)-&gt;clone();
 986     shared-&gt;removeRef();
 987     if (c == NULL) {
 988         success = U_MEMORY_ALLOCATION_ERROR;
 989         return NULL;
 990     }
 991 
 992     // Now, reset calendar to default state:
 993     c-&gt;adoptTimeZone(zonePtr.orphan()); //  Set the correct time zone
 994     c-&gt;setTimeInMillis(getNow(), success); // let the new calendar have the current time.
 995 
 996     return c;
 997 }
 998 
 999 // -------------------------------------
1000 
1001 Calendar* U_EXPORT2
1002 Calendar::createInstance(const TimeZone&amp; zone, const Locale&amp; aLocale, UErrorCode&amp; success)
1003 {
1004     Calendar* c = createInstance(aLocale, success);
1005     if(U_SUCCESS(success) &amp;&amp; c) {
1006         c-&gt;setTimeZone(zone);
1007     }
1008     return c;
1009 }
1010 
1011 // -------------------------------------
1012 
1013 void U_EXPORT2
1014 Calendar::getCalendarTypeFromLocale(
1015         const Locale &amp;aLocale,
1016         char *typeBuffer,
1017         int32_t typeBufferSize,
1018         UErrorCode &amp;success) {
1019     const SharedCalendar *shared = NULL;
1020     UnifiedCache::getByLocale(aLocale, shared, success);
1021     if (U_FAILURE(success)) {
1022         return;
1023     }
1024     uprv_strncpy(typeBuffer, (*shared)-&gt;getType(), typeBufferSize);
1025     shared-&gt;removeRef();
1026     if (typeBuffer[typeBufferSize - 1]) {
1027         success = U_BUFFER_OVERFLOW_ERROR;
1028     }
1029 }
1030 
1031 UBool
1032 Calendar::operator==(const Calendar&amp; that) const
1033 {
1034     UErrorCode status = U_ZERO_ERROR;
1035     return isEquivalentTo(that) &amp;&amp;
1036         getTimeInMillis(status) == that.getTimeInMillis(status) &amp;&amp;
1037         U_SUCCESS(status);
1038 }
1039 
1040 UBool
1041 Calendar::isEquivalentTo(const Calendar&amp; other) const
1042 {
1043     return typeid(*this) == typeid(other) &amp;&amp;
1044         fLenient                == other.fLenient &amp;&amp;
1045         fRepeatedWallTime       == other.fRepeatedWallTime &amp;&amp;
1046         fSkippedWallTime        == other.fSkippedWallTime &amp;&amp;
1047         fFirstDayOfWeek         == other.fFirstDayOfWeek &amp;&amp;
1048         fMinimalDaysInFirstWeek == other.fMinimalDaysInFirstWeek &amp;&amp;
1049         fWeekendOnset           == other.fWeekendOnset &amp;&amp;
1050         fWeekendOnsetMillis     == other.fWeekendOnsetMillis &amp;&amp;
1051         fWeekendCease           == other.fWeekendCease &amp;&amp;
1052         fWeekendCeaseMillis     == other.fWeekendCeaseMillis &amp;&amp;
1053         *fZone                  == *other.fZone;
1054 }
1055 
1056 // -------------------------------------
1057 
1058 UBool
1059 Calendar::equals(const Calendar&amp; when, UErrorCode&amp; status) const
1060 {
1061     return (this == &amp;when ||
1062         getTime(status) == when.getTime(status));
1063 }
1064 
1065 // -------------------------------------
1066 
1067 UBool
1068 Calendar::before(const Calendar&amp; when, UErrorCode&amp; status) const
1069 {
1070     return (this != &amp;when &amp;&amp;
1071         getTimeInMillis(status) &lt; when.getTimeInMillis(status));
1072 }
1073 
1074 // -------------------------------------
1075 
1076 UBool
1077 Calendar::after(const Calendar&amp; when, UErrorCode&amp; status) const
1078 {
1079     return (this != &amp;when &amp;&amp;
1080         getTimeInMillis(status) &gt; when.getTimeInMillis(status));
1081 }
1082 
1083 // -------------------------------------
1084 
1085 
1086 const Locale* U_EXPORT2
1087 Calendar::getAvailableLocales(int32_t&amp; count)
1088 {
1089     return Locale::getAvailableLocales(count);
1090 }
1091 
1092 // -------------------------------------
1093 
1094 StringEnumeration* U_EXPORT2
1095 Calendar::getKeywordValuesForLocale(const char* key,
1096                     const Locale&amp; locale, UBool commonlyUsed, UErrorCode&amp; status)
1097 {
1098     // This is a wrapper over ucal_getKeywordValuesForLocale
1099     UEnumeration *uenum = ucal_getKeywordValuesForLocale(key, locale.getName(),
1100                                                         commonlyUsed, &amp;status);
1101     if (U_FAILURE(status)) {
1102         uenum_close(uenum);
1103         return NULL;
1104     }
<a name="21" id="anc21"></a><span class="line-modified">1105     UStringEnumeration* ustringenum = new UStringEnumeration(uenum);</span>
<span class="line-added">1106     if (ustringenum == nullptr) {</span>
<span class="line-added">1107         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1108     }</span>
<span class="line-added">1109     return ustringenum;</span>
1110 }
1111 
1112 // -------------------------------------
1113 
1114 UDate U_EXPORT2
1115 Calendar::getNow()
1116 {
1117     return uprv_getUTCtime(); // return as milliseconds
1118 }
1119 
1120 // -------------------------------------
1121 
1122 /**
1123 * Gets this Calendar&#39;s current time as a long.
1124 * @return the current time as UTC milliseconds from the epoch.
1125 */
1126 double
1127 Calendar::getTimeInMillis(UErrorCode&amp; status) const
1128 {
1129     if(U_FAILURE(status))
1130         return 0.0;
1131 
1132     if ( ! fIsTimeSet)
1133         ((Calendar*)this)-&gt;updateTime(status);
1134 
1135     /* Test for buffer overflows */
1136     if(U_FAILURE(status)) {
1137         return 0.0;
1138     }
1139     return fTime;
1140 }
1141 
1142 // -------------------------------------
1143 
1144 /**
1145 * Sets this Calendar&#39;s current time from the given long value.
1146 * A status of U_ILLEGAL_ARGUMENT_ERROR is set when millis is
1147 * outside the range permitted by a Calendar object when not in lenient mode.
1148 * when in lenient mode the out of range values are pinned to their respective min/max.
1149 * @param date the new time in UTC milliseconds from the epoch.
1150 */
1151 void
1152 Calendar::setTimeInMillis( double millis, UErrorCode&amp; status ) {
1153     if(U_FAILURE(status))
1154         return;
1155 
1156     if (millis &gt; MAX_MILLIS) {
1157         if(isLenient()) {
1158             millis = MAX_MILLIS;
1159         } else {
1160             status = U_ILLEGAL_ARGUMENT_ERROR;
1161             return;
1162         }
1163     } else if (millis &lt; MIN_MILLIS) {
1164         if(isLenient()) {
1165             millis = MIN_MILLIS;
1166         } else {
1167             status = U_ILLEGAL_ARGUMENT_ERROR;
1168             return;
1169         }
1170     }
1171 
1172     fTime = millis;
1173     fAreFieldsSet = fAreAllFieldsSet = FALSE;
1174     fIsTimeSet = fAreFieldsVirtuallySet = TRUE;
1175 
1176     for (int32_t i=0; i&lt;UCAL_FIELD_COUNT; ++i) {
1177         fFields[i]     = 0;
1178         fStamp[i]     = kUnset;
1179         fIsSet[i]     = FALSE;
1180     }
1181 
1182 
1183 }
1184 
1185 // -------------------------------------
1186 
1187 int32_t
1188 Calendar::get(UCalendarDateFields field, UErrorCode&amp; status) const
1189 {
1190     // field values are only computed when actually requested; for more on when computation
1191     // of various things happens, see the &quot;data flow in Calendar&quot; description at the top
1192     // of this file
1193     if (U_SUCCESS(status)) ((Calendar*)this)-&gt;complete(status); // Cast away const
1194     return U_SUCCESS(status) ? fFields[field] : 0;
1195 }
1196 
1197 // -------------------------------------
1198 
1199 void
1200 Calendar::set(UCalendarDateFields field, int32_t value)
1201 {
1202     if (fAreFieldsVirtuallySet) {
1203         UErrorCode ec = U_ZERO_ERROR;
1204         computeFields(ec);
1205     }
1206     fFields[field]     = value;
1207     /* Ensure that the fNextStamp value doesn&#39;t go pass max value for int32_t */
1208     if (fNextStamp == STAMP_MAX) {
1209         recalculateStamp();
1210     }
1211     fStamp[field]     = fNextStamp++;
1212     fIsSet[field]     = TRUE; // Remove later
1213     fIsTimeSet = fAreFieldsSet = fAreFieldsVirtuallySet = FALSE;
1214 }
1215 
1216 // -------------------------------------
1217 
1218 void
1219 Calendar::set(int32_t year, int32_t month, int32_t date)
1220 {
1221     set(UCAL_YEAR, year);
1222     set(UCAL_MONTH, month);
1223     set(UCAL_DATE, date);
1224 }
1225 
1226 // -------------------------------------
1227 
1228 void
1229 Calendar::set(int32_t year, int32_t month, int32_t date, int32_t hour, int32_t minute)
1230 {
1231     set(UCAL_YEAR, year);
1232     set(UCAL_MONTH, month);
1233     set(UCAL_DATE, date);
1234     set(UCAL_HOUR_OF_DAY, hour);
1235     set(UCAL_MINUTE, minute);
1236 }
1237 
1238 // -------------------------------------
1239 
1240 void
1241 Calendar::set(int32_t year, int32_t month, int32_t date, int32_t hour, int32_t minute, int32_t second)
1242 {
1243     set(UCAL_YEAR, year);
1244     set(UCAL_MONTH, month);
1245     set(UCAL_DATE, date);
1246     set(UCAL_HOUR_OF_DAY, hour);
1247     set(UCAL_MINUTE, minute);
1248     set(UCAL_SECOND, second);
1249 }
1250 
1251 // -------------------------------------
1252 // For now the full getRelatedYear implementation is here;
1253 // per #10752 move the non-default implementation to subclasses
1254 // (default implementation will do no year adjustment)
1255 
1256 static int32_t gregoYearFromIslamicStart(int32_t year) {
1257     // ad hoc conversion, improve under #10752
1258     // rough est for now, ok for grego 1846-2138,
1259     // otherwise occasionally wrong (for 3% of years)
1260     int cycle, offset, shift = 0;
1261     if (year &gt;= 1397) {
1262         cycle = (year - 1397) / 67;
1263         offset = (year - 1397) % 67;
1264         shift = 2*cycle + ((offset &gt;= 33)? 1: 0);
1265     } else {
1266         cycle = (year - 1396) / 67 - 1;
1267         offset = -(year - 1396) % 67;
1268         shift = 2*cycle + ((offset &lt;= 33)? 1: 0);
1269     }
1270     return year + 579 - shift;
1271 }
1272 
1273 int32_t Calendar::getRelatedYear(UErrorCode &amp;status) const
1274 {
1275     if (U_FAILURE(status)) {
1276         return 0;
1277     }
1278     int32_t year = get(UCAL_EXTENDED_YEAR, status);
1279     if (U_FAILURE(status)) {
1280         return 0;
1281     }
1282     // modify for calendar type
1283     ECalType type = getCalendarType(getType());
1284     switch (type) {
1285         case CALTYPE_PERSIAN:
1286             year += 622; break;
1287         case CALTYPE_HEBREW:
1288             year -= 3760; break;
1289         case CALTYPE_CHINESE:
1290             year -= 2637; break;
1291         case CALTYPE_INDIAN:
1292             year += 79; break;
1293         case CALTYPE_COPTIC:
1294             year += 284; break;
1295         case CALTYPE_ETHIOPIC:
1296             year += 8; break;
1297         case CALTYPE_ETHIOPIC_AMETE_ALEM:
1298             year -=5492; break;
1299         case CALTYPE_DANGI:
1300             year -= 2333; break;
1301         case CALTYPE_ISLAMIC_CIVIL:
1302         case CALTYPE_ISLAMIC:
1303         case CALTYPE_ISLAMIC_UMALQURA:
1304         case CALTYPE_ISLAMIC_TBLA:
1305         case CALTYPE_ISLAMIC_RGSA:
1306             year = gregoYearFromIslamicStart(year); break;
1307         default:
1308             // CALTYPE_GREGORIAN
1309             // CALTYPE_JAPANESE
1310             // CALTYPE_BUDDHIST
1311             // CALTYPE_ROC
1312             // CALTYPE_ISO8601
1313             // do nothing, EXTENDED_YEAR same as Gregorian
1314             break;
1315     }
1316     return year;
1317 }
1318 
1319 // -------------------------------------
1320 // For now the full setRelatedYear implementation is here;
1321 // per #10752 move the non-default implementation to subclasses
1322 // (default implementation will do no year adjustment)
1323 
1324 static int32_t firstIslamicStartYearFromGrego(int32_t year) {
1325     // ad hoc conversion, improve under #10752
1326     // rough est for now, ok for grego 1846-2138,
1327     // otherwise occasionally wrong (for 3% of years)
1328     int cycle, offset, shift = 0;
1329     if (year &gt;= 1977) {
1330         cycle = (year - 1977) / 65;
1331         offset = (year - 1977) % 65;
1332         shift = 2*cycle + ((offset &gt;= 32)? 1: 0);
1333     } else {
1334         cycle = (year - 1976) / 65 - 1;
1335         offset = -(year - 1976) % 65;
1336         shift = 2*cycle + ((offset &lt;= 32)? 1: 0);
1337     }
1338     return year - 579 + shift;
1339 }
1340 void Calendar::setRelatedYear(int32_t year)
1341 {
1342     // modify for calendar type
1343     ECalType type = getCalendarType(getType());
1344     switch (type) {
1345         case CALTYPE_PERSIAN:
1346             year -= 622; break;
1347         case CALTYPE_HEBREW:
1348             year += 3760; break;
1349         case CALTYPE_CHINESE:
1350             year += 2637; break;
1351         case CALTYPE_INDIAN:
1352             year -= 79; break;
1353         case CALTYPE_COPTIC:
1354             year -= 284; break;
1355         case CALTYPE_ETHIOPIC:
1356             year -= 8; break;
1357         case CALTYPE_ETHIOPIC_AMETE_ALEM:
1358             year +=5492; break;
1359         case CALTYPE_DANGI:
1360             year += 2333; break;
1361         case CALTYPE_ISLAMIC_CIVIL:
1362         case CALTYPE_ISLAMIC:
1363         case CALTYPE_ISLAMIC_UMALQURA:
1364         case CALTYPE_ISLAMIC_TBLA:
1365         case CALTYPE_ISLAMIC_RGSA:
1366             year = firstIslamicStartYearFromGrego(year); break;
1367         default:
1368             // CALTYPE_GREGORIAN
1369             // CALTYPE_JAPANESE
1370             // CALTYPE_BUDDHIST
1371             // CALTYPE_ROC
1372             // CALTYPE_ISO8601
1373             // do nothing, EXTENDED_YEAR same as Gregorian
1374             break;
1375     }
1376     // set extended year
1377     set(UCAL_EXTENDED_YEAR, year);
1378 }
1379 
1380 // -------------------------------------
1381 
1382 void
1383 Calendar::clear()
1384 {
1385     for (int32_t i=0; i&lt;UCAL_FIELD_COUNT; ++i) {
1386         fFields[i]     = 0; // Must do this; other code depends on it
1387         fStamp[i]     = kUnset;
1388         fIsSet[i]     = FALSE; // Remove later
1389     }
1390     fIsTimeSet = fAreFieldsSet = fAreAllFieldsSet = fAreFieldsVirtuallySet = FALSE;
1391     // fTime is not &#39;cleared&#39; - may be used if no fields are set.
1392 }
1393 
1394 // -------------------------------------
1395 
1396 void
1397 Calendar::clear(UCalendarDateFields field)
1398 {
1399     if (fAreFieldsVirtuallySet) {
1400         UErrorCode ec = U_ZERO_ERROR;
1401         computeFields(ec);
1402     }
1403     fFields[field]         = 0;
1404     fStamp[field]         = kUnset;
1405     fIsSet[field]         = FALSE; // Remove later
1406     fIsTimeSet = fAreFieldsSet = fAreAllFieldsSet = fAreFieldsVirtuallySet = FALSE;
1407 }
1408 
1409 // -------------------------------------
1410 
1411 UBool
1412 Calendar::isSet(UCalendarDateFields field) const
1413 {
1414     return fAreFieldsVirtuallySet || (fStamp[field] != kUnset);
1415 }
1416 
1417 
1418 int32_t Calendar::newestStamp(UCalendarDateFields first, UCalendarDateFields last, int32_t bestStampSoFar) const
1419 {
1420     int32_t bestStamp = bestStampSoFar;
1421     for (int32_t i=(int32_t)first; i&lt;=(int32_t)last; ++i) {
1422         if (fStamp[i] &gt; bestStamp) {
1423             bestStamp = fStamp[i];
1424         }
1425     }
1426     return bestStamp;
1427 }
1428 
1429 
1430 // -------------------------------------
1431 
1432 void
1433 Calendar::complete(UErrorCode&amp; status)
1434 {
1435     if (!fIsTimeSet) {
1436         updateTime(status);
1437         /* Test for buffer overflows */
1438         if(U_FAILURE(status)) {
1439             return;
1440         }
1441     }
1442     if (!fAreFieldsSet) {
1443         computeFields(status); // fills in unset fields
1444         /* Test for buffer overflows */
1445         if(U_FAILURE(status)) {
1446             return;
1447         }
1448         fAreFieldsSet         = TRUE;
1449         fAreAllFieldsSet     = TRUE;
1450     }
1451 }
1452 
1453 //-------------------------------------------------------------------------
1454 // Protected utility methods for use by subclasses.  These are very handy
1455 // for implementing add, roll, and computeFields.
1456 //-------------------------------------------------------------------------
1457 
1458 /**
1459 * Adjust the specified field so that it is within
1460 * the allowable range for the date to which this calendar is set.
1461 * For example, in a Gregorian calendar pinning the {@link #DAY_OF_MONTH DAY_OF_MONTH}
1462 * field for a calendar set to April 31 would cause it to be set
1463 * to April 30.
1464 * &lt;p&gt;
1465 * &lt;b&gt;Subclassing:&lt;/b&gt;
1466 * &lt;br&gt;
1467 * This utility method is intended for use by subclasses that need to implement
1468 * their own overrides of {@link #roll roll} and {@link #add add}.
1469 * &lt;p&gt;
1470 * &lt;b&gt;Note:&lt;/b&gt;
1471 * &lt;code&gt;pinField&lt;/code&gt; is implemented in terms of
1472 * {@link #getActualMinimum getActualMinimum}
1473 * and {@link #getActualMaximum getActualMaximum}.  If either of those methods uses
1474 * a slow, iterative algorithm for a particular field, it would be
1475 * unwise to attempt to call &lt;code&gt;pinField&lt;/code&gt; for that field.  If you
1476 * really do need to do so, you should override this method to do
1477 * something more efficient for that field.
1478 * &lt;p&gt;
1479 * @param field The calendar field whose value should be pinned.
1480 *
1481 * @see #getActualMinimum
1482 * @see #getActualMaximum
1483 * @stable ICU 2.0
1484 */
1485 void Calendar::pinField(UCalendarDateFields field, UErrorCode&amp; status) {
1486     int32_t max = getActualMaximum(field, status);
1487     int32_t min = getActualMinimum(field, status);
1488 
1489     if (fFields[field] &gt; max) {
1490         set(field, max);
1491     } else if (fFields[field] &lt; min) {
1492         set(field, min);
1493     }
1494 }
1495 
1496 
1497 void Calendar::computeFields(UErrorCode &amp;ec)
1498 {
1499   if (U_FAILURE(ec)) {
1500         return;
1501     }
1502     // Compute local wall millis
1503     double localMillis = internalGetTime();
1504     int32_t rawOffset, dstOffset;
1505     getTimeZone().getOffset(localMillis, FALSE, rawOffset, dstOffset, ec);
1506     localMillis += (rawOffset + dstOffset);
1507 
1508     // Mark fields as set.  Do this before calling handleComputeFields().
1509     uint32_t mask =   //fInternalSetMask;
1510         (1 &lt;&lt; UCAL_ERA) |
1511         (1 &lt;&lt; UCAL_YEAR) |
1512         (1 &lt;&lt; UCAL_MONTH) |
1513         (1 &lt;&lt; UCAL_DAY_OF_MONTH) | // = UCAL_DATE
1514         (1 &lt;&lt; UCAL_DAY_OF_YEAR) |
1515         (1 &lt;&lt; UCAL_EXTENDED_YEAR);
1516 
1517     for (int32_t i=0; i&lt;UCAL_FIELD_COUNT; ++i) {
1518         if ((mask &amp; 1) == 0) {
1519             fStamp[i] = kInternallySet;
1520             fIsSet[i] = TRUE; // Remove later
1521         } else {
1522             fStamp[i] = kUnset;
1523             fIsSet[i] = FALSE; // Remove later
1524         }
1525         mask &gt;&gt;= 1;
1526     }
1527 
1528     // We used to check for and correct extreme millis values (near
1529     // Long.MIN_VALUE or Long.MAX_VALUE) here.  Such values would cause
1530     // overflows from positive to negative (or vice versa) and had to
1531     // be manually tweaked.  We no longer need to do this because we
1532     // have limited the range of supported dates to those that have a
1533     // Julian day that fits into an int.  This allows us to implement a
1534     // JULIAN_DAY field and also removes some inelegant code. - Liu
1535     // 11/6/00
1536 
1537     int32_t days =  (int32_t)ClockMath::floorDivide(localMillis, (double)kOneDay);
1538 
1539     internalSet(UCAL_JULIAN_DAY,days + kEpochStartAsJulianDay);
1540 
1541 #if defined (U_DEBUG_CAL)
1542     //fprintf(stderr, &quot;%s:%d- Hmm! Jules @ %d, as per %.0lf millis\n&quot;,
1543     //__FILE__, __LINE__, fFields[UCAL_JULIAN_DAY], localMillis);
1544 #endif
1545 
1546     computeGregorianAndDOWFields(fFields[UCAL_JULIAN_DAY], ec);
1547 
1548     // Call framework method to have subclass compute its fields.
1549     // These must include, at a minimum, MONTH, DAY_OF_MONTH,
1550     // EXTENDED_YEAR, YEAR, DAY_OF_YEAR.  This method will call internalSet(),
1551     // which will update stamp[].
1552     handleComputeFields(fFields[UCAL_JULIAN_DAY], ec);
1553 
1554     // Compute week-related fields, based on the subclass-computed
1555     // fields computed by handleComputeFields().
1556     computeWeekFields(ec);
1557 
1558     // Compute time-related fields.  These are indepent of the date and
1559     // of the subclass algorithm.  They depend only on the local zone
1560     // wall milliseconds in day.
1561     int32_t millisInDay =  (int32_t) (localMillis - (days * kOneDay));
1562     fFields[UCAL_MILLISECONDS_IN_DAY] = millisInDay;
1563     fFields[UCAL_MILLISECOND] = millisInDay % 1000;
1564     millisInDay /= 1000;
1565     fFields[UCAL_SECOND] = millisInDay % 60;
1566     millisInDay /= 60;
1567     fFields[UCAL_MINUTE] = millisInDay % 60;
1568     millisInDay /= 60;
1569     fFields[UCAL_HOUR_OF_DAY] = millisInDay;
1570     fFields[UCAL_AM_PM] = millisInDay / 12; // Assume AM == 0
1571     fFields[UCAL_HOUR] = millisInDay % 12;
1572     fFields[UCAL_ZONE_OFFSET] = rawOffset;
1573     fFields[UCAL_DST_OFFSET] = dstOffset;
1574 }
1575 
1576 uint8_t Calendar::julianDayToDayOfWeek(double julian)
1577 {
1578     // If julian is negative, then julian%7 will be negative, so we adjust
1579     // accordingly.  We add 1 because Julian day 0 is Monday.
1580     int8_t dayOfWeek = (int8_t) uprv_fmod(julian + 1, 7);
1581 
1582     uint8_t result = (uint8_t)(dayOfWeek + ((dayOfWeek &lt; 0) ? (7+UCAL_SUNDAY ) : UCAL_SUNDAY));
1583     return result;
1584 }
1585 
1586 /**
1587 * Compute the Gregorian calendar year, month, and day of month from
1588 * the given Julian day.  These values are not stored in fields, but in
1589 * member variables gregorianXxx.  Also compute the DAY_OF_WEEK and
1590 * DOW_LOCAL fields.
1591 */
1592 void Calendar::computeGregorianAndDOWFields(int32_t julianDay, UErrorCode &amp;ec)
1593 {
1594     computeGregorianFields(julianDay, ec);
1595 
1596     // Compute day of week: JD 0 = Monday
1597     int32_t dow = julianDayToDayOfWeek(julianDay);
1598     internalSet(UCAL_DAY_OF_WEEK,dow);
1599 
1600     // Calculate 1-based localized day of week
1601     int32_t dowLocal = dow - getFirstDayOfWeek() + 1;
1602     if (dowLocal &lt; 1) {
1603         dowLocal += 7;
1604     }
1605     internalSet(UCAL_DOW_LOCAL,dowLocal);
1606     fFields[UCAL_DOW_LOCAL] = dowLocal;
1607 }
1608 
1609 /**
1610 * Compute the Gregorian calendar year, month, and day of month from the
1611 * Julian day.  These values are not stored in fields, but in member
1612 * variables gregorianXxx.  They are used for time zone computations and by
1613 * subclasses that are Gregorian derivatives.  Subclasses may call this
1614 * method to perform a Gregorian calendar millis-&gt;fields computation.
1615 */
1616 void Calendar::computeGregorianFields(int32_t julianDay, UErrorCode &amp; /* ec */) {
1617     int32_t gregorianDayOfWeekUnused;
1618     Grego::dayToFields(julianDay - kEpochStartAsJulianDay, fGregorianYear, fGregorianMonth, fGregorianDayOfMonth, gregorianDayOfWeekUnused, fGregorianDayOfYear);
1619 }
1620 
1621 /**
1622 * Compute the fields WEEK_OF_YEAR, YEAR_WOY, WEEK_OF_MONTH,
1623 * DAY_OF_WEEK_IN_MONTH, and DOW_LOCAL from EXTENDED_YEAR, YEAR,
1624 * DAY_OF_WEEK, and DAY_OF_YEAR.  The latter fields are computed by the
1625 * subclass based on the calendar system.
1626 *
1627 * &lt;p&gt;The YEAR_WOY field is computed simplistically.  It is equal to YEAR
1628 * most of the time, but at the year boundary it may be adjusted to YEAR-1
1629 * or YEAR+1 to reflect the overlap of a week into an adjacent year.  In
1630 * this case, a simple increment or decrement is performed on YEAR, even
1631 * though this may yield an invalid YEAR value.  For instance, if the YEAR
1632 * is part of a calendar system with an N-year cycle field CYCLE, then
1633 * incrementing the YEAR may involve incrementing CYCLE and setting YEAR
1634 * back to 0 or 1.  This is not handled by this code, and in fact cannot be
1635 * simply handled without having subclasses define an entire parallel set of
1636 * fields for fields larger than or equal to a year.  This additional
1637 * complexity is not warranted, since the intention of the YEAR_WOY field is
1638 * to support ISO 8601 notation, so it will typically be used with a
1639 * proleptic Gregorian calendar, which has no field larger than a year.
1640 */
1641 void Calendar::computeWeekFields(UErrorCode &amp;ec) {
1642     if(U_FAILURE(ec)) {
1643         return;
1644     }
1645     int32_t eyear = fFields[UCAL_EXTENDED_YEAR];
1646     int32_t dayOfWeek = fFields[UCAL_DAY_OF_WEEK];
1647     int32_t dayOfYear = fFields[UCAL_DAY_OF_YEAR];
1648 
1649     // WEEK_OF_YEAR start
1650     // Compute the week of the year.  For the Gregorian calendar, valid week
1651     // numbers run from 1 to 52 or 53, depending on the year, the first day
1652     // of the week, and the minimal days in the first week.  For other
1653     // calendars, the valid range may be different -- it depends on the year
1654     // length.  Days at the start of the year may fall into the last week of
1655     // the previous year; days at the end of the year may fall into the
1656     // first week of the next year.  ASSUME that the year length is less than
1657     // 7000 days.
1658     int32_t yearOfWeekOfYear = eyear;
1659     int32_t relDow = (dayOfWeek + 7 - getFirstDayOfWeek()) % 7; // 0..6
1660     int32_t relDowJan1 = (dayOfWeek - dayOfYear + 7001 - getFirstDayOfWeek()) % 7; // 0..6
1661     int32_t woy = (dayOfYear - 1 + relDowJan1) / 7; // 0..53
1662     if ((7 - relDowJan1) &gt;= getMinimalDaysInFirstWeek()) {
1663         ++woy;
1664     }
1665 
1666     // Adjust for weeks at the year end that overlap into the previous or
1667     // next calendar year.
1668     if (woy == 0) {
1669         // We are the last week of the previous year.
1670         // Check to see if we are in the last week; if so, we need
1671         // to handle the case in which we are the first week of the
1672         // next year.
1673 
1674         int32_t prevDoy = dayOfYear + handleGetYearLength(eyear - 1);
1675         woy = weekNumber(prevDoy, dayOfWeek);
1676         yearOfWeekOfYear--;
1677     } else {
1678         int32_t lastDoy = handleGetYearLength(eyear);
1679         // Fast check: For it to be week 1 of the next year, the DOY
1680         // must be on or after L-5, where L is yearLength(), then it
1681         // cannot possibly be week 1 of the next year:
1682         //          L-5                  L
1683         // doy: 359 360 361 362 363 364 365 001
1684         // dow:      1   2   3   4   5   6   7
1685         if (dayOfYear &gt;= (lastDoy - 5)) {
1686             int32_t lastRelDow = (relDow + lastDoy - dayOfYear) % 7;
1687             if (lastRelDow &lt; 0) {
1688                 lastRelDow += 7;
1689             }
1690             if (((6 - lastRelDow) &gt;= getMinimalDaysInFirstWeek()) &amp;&amp;
1691                 ((dayOfYear + 7 - relDow) &gt; lastDoy)) {
1692                     woy = 1;
1693                     yearOfWeekOfYear++;
1694                 }
1695         }
1696     }
1697     fFields[UCAL_WEEK_OF_YEAR] = woy;
1698     fFields[UCAL_YEAR_WOY] = yearOfWeekOfYear;
1699     // WEEK_OF_YEAR end
1700 
1701     int32_t dayOfMonth = fFields[UCAL_DAY_OF_MONTH];
1702     fFields[UCAL_WEEK_OF_MONTH] = weekNumber(dayOfMonth, dayOfWeek);
1703     fFields[UCAL_DAY_OF_WEEK_IN_MONTH] = (dayOfMonth-1) / 7 + 1;
1704 #if defined (U_DEBUG_CAL)
1705     if(fFields[UCAL_DAY_OF_WEEK_IN_MONTH]==0) fprintf(stderr, &quot;%s:%d: DOWIM %d on %g\n&quot;,
1706         __FILE__, __LINE__,fFields[UCAL_DAY_OF_WEEK_IN_MONTH], fTime);
1707 #endif
1708 }
1709 
1710 
1711 int32_t Calendar::weekNumber(int32_t desiredDay, int32_t dayOfPeriod, int32_t dayOfWeek)
1712 {
1713     // Determine the day of the week of the first day of the period
1714     // in question (either a year or a month).  Zero represents the
1715     // first day of the week on this calendar.
1716     int32_t periodStartDayOfWeek = (dayOfWeek - getFirstDayOfWeek() - dayOfPeriod + 1) % 7;
1717     if (periodStartDayOfWeek &lt; 0) periodStartDayOfWeek += 7;
1718 
1719     // Compute the week number.  Initially, ignore the first week, which
1720     // may be fractional (or may not be).  We add periodStartDayOfWeek in
1721     // order to fill out the first week, if it is fractional.
1722     int32_t weekNo = (desiredDay + periodStartDayOfWeek - 1)/7;
1723 
1724     // If the first week is long enough, then count it.  If
1725     // the minimal days in the first week is one, or if the period start
1726     // is zero, we always increment weekNo.
1727     if ((7 - periodStartDayOfWeek) &gt;= getMinimalDaysInFirstWeek()) ++weekNo;
1728 
1729     return weekNo;
1730 }
1731 
1732 void Calendar::handleComputeFields(int32_t /* julianDay */, UErrorCode &amp;/* status */)
1733 {
1734     internalSet(UCAL_MONTH, getGregorianMonth());
1735     internalSet(UCAL_DAY_OF_MONTH, getGregorianDayOfMonth());
1736     internalSet(UCAL_DAY_OF_YEAR, getGregorianDayOfYear());
1737     int32_t eyear = getGregorianYear();
1738     internalSet(UCAL_EXTENDED_YEAR, eyear);
1739     int32_t era = GregorianCalendar::AD;
1740     if (eyear &lt; 1) {
1741         era = GregorianCalendar::BC;
1742         eyear = 1 - eyear;
1743     }
1744     internalSet(UCAL_ERA, era);
1745     internalSet(UCAL_YEAR, eyear);
1746 }
1747 // -------------------------------------
1748 
1749 
1750 void Calendar::roll(EDateFields field, int32_t amount, UErrorCode&amp; status)
1751 {
1752     roll((UCalendarDateFields)field, amount, status);
1753 }
1754 
1755 void Calendar::roll(UCalendarDateFields field, int32_t amount, UErrorCode&amp; status)
1756 {
1757     if (amount == 0) {
1758         return; // Nothing to do
1759     }
1760 
1761     complete(status);
1762 
1763     if(U_FAILURE(status)) {
1764         return;
1765     }
1766     switch (field) {
1767     case UCAL_DAY_OF_MONTH:
1768     case UCAL_AM_PM:
1769     case UCAL_MINUTE:
1770     case UCAL_SECOND:
1771     case UCAL_MILLISECOND:
1772     case UCAL_MILLISECONDS_IN_DAY:
1773     case UCAL_ERA:
1774         // These are the standard roll instructions.  These work for all
1775         // simple cases, that is, cases in which the limits are fixed, such
1776         // as the hour, the day of the month, and the era.
1777         {
1778             int32_t min = getActualMinimum(field,status);
1779             int32_t max = getActualMaximum(field,status);
1780             int32_t gap = max - min + 1;
1781 
1782             int32_t value = internalGet(field) + amount;
1783             value = (value - min) % gap;
1784             if (value &lt; 0) {
1785                 value += gap;
1786             }
1787             value += min;
1788 
1789             set(field, value);
1790             return;
1791         }
1792 
1793     case UCAL_HOUR:
1794     case UCAL_HOUR_OF_DAY:
1795         // Rolling the hour is difficult on the ONSET and CEASE days of
1796         // daylight savings.  For example, if the change occurs at
1797         // 2 AM, we have the following progression:
1798         // ONSET: 12 Std -&gt; 1 Std -&gt; 3 Dst -&gt; 4 Dst
1799         // CEASE: 12 Dst -&gt; 1 Dst -&gt; 1 Std -&gt; 2 Std
1800         // To get around this problem we don&#39;t use fields; we manipulate
1801         // the time in millis directly.
1802         {
1803             // Assume min == 0 in calculations below
1804             double start = getTimeInMillis(status);
1805             int32_t oldHour = internalGet(field);
1806             int32_t max = getMaximum(field);
1807             int32_t newHour = (oldHour + amount) % (max + 1);
1808             if (newHour &lt; 0) {
1809                 newHour += max + 1;
1810             }
1811             setTimeInMillis(start + kOneHour * (newHour - oldHour),status);
1812             return;
1813         }
1814 
1815     case UCAL_MONTH:
1816         // Rolling the month involves both pinning the final value
1817         // and adjusting the DAY_OF_MONTH if necessary.  We only adjust the
1818         // DAY_OF_MONTH if, after updating the MONTH field, it is illegal.
1819         // E.g., &lt;jan31&gt;.roll(MONTH, 1) -&gt; &lt;feb28&gt; or &lt;feb29&gt;.
1820         {
1821             int32_t max = getActualMaximum(UCAL_MONTH, status);
1822             int32_t mon = (internalGet(UCAL_MONTH) + amount) % (max+1);
1823 
1824             if (mon &lt; 0) {
1825                 mon += (max + 1);
1826             }
1827             set(UCAL_MONTH, mon);
1828 
1829             // Keep the day of month in range.  We don&#39;t want to spill over
1830             // into the next month; e.g., we don&#39;t want jan31 + 1 mo -&gt; feb31 -&gt;
1831             // mar3.
1832             pinField(UCAL_DAY_OF_MONTH,status);
1833             return;
1834         }
1835 
1836     case UCAL_YEAR:
1837     case UCAL_YEAR_WOY:
1838         {
1839             // * If era==0 and years go backwards in time, change sign of amount.
1840             // * Until we have new API per #9393, we temporarily hardcode knowledge of
1841             //   which calendars have era 0 years that go backwards.
1842             UBool era0WithYearsThatGoBackwards = FALSE;
1843             int32_t era = get(UCAL_ERA, status);
1844             if (era == 0) {
1845                 const char * calType = getType();
1846                 if ( uprv_strcmp(calType,&quot;gregorian&quot;)==0 || uprv_strcmp(calType,&quot;roc&quot;)==0 || uprv_strcmp(calType,&quot;coptic&quot;)==0 ) {
1847                     amount = -amount;
1848                     era0WithYearsThatGoBackwards = TRUE;
1849                 }
1850             }
1851             int32_t newYear = internalGet(field) + amount;
1852             if (era &gt; 0 || newYear &gt;= 1) {
1853                 int32_t maxYear = getActualMaximum(field, status);
1854                 if (maxYear &lt; 32768) {
1855                     // this era has real bounds, roll should wrap years
1856                     if (newYear &lt; 1) {
1857                         newYear = maxYear - ((-newYear) % maxYear);
1858                     } else if (newYear &gt; maxYear) {
1859                         newYear = ((newYear - 1) % maxYear) + 1;
1860                     }
1861                 // else era is unbounded, just pin low year instead of wrapping
1862                 } else if (newYear &lt; 1) {
1863                     newYear = 1;
1864                 }
1865             // else we are in era 0 with newYear &lt; 1;
1866             // calendars with years that go backwards must pin the year value at 0,
1867             // other calendars can have years &lt; 0 in era 0
1868             } else if (era0WithYearsThatGoBackwards) {
1869                 newYear = 1;
1870             }
1871             set(field, newYear);
1872             pinField(UCAL_MONTH,status);
1873             pinField(UCAL_DAY_OF_MONTH,status);
1874             return;
1875         }
1876 
1877     case UCAL_EXTENDED_YEAR:
1878         // Rolling the year can involve pinning the DAY_OF_MONTH.
1879         set(field, internalGet(field) + amount);
1880         pinField(UCAL_MONTH,status);
1881         pinField(UCAL_DAY_OF_MONTH,status);
1882         return;
1883 
1884     case UCAL_WEEK_OF_MONTH:
1885         {
1886             // This is tricky, because during the roll we may have to shift
1887             // to a different day of the week.  For example:
1888 
1889             //    s  m  t  w  r  f  s
1890             //          1  2  3  4  5
1891             //    6  7  8  9 10 11 12
1892 
1893             // When rolling from the 6th or 7th back one week, we go to the
1894             // 1st (assuming that the first partial week counts).  The same
1895             // thing happens at the end of the month.
1896 
1897             // The other tricky thing is that we have to figure out whether
1898             // the first partial week actually counts or not, based on the
1899             // minimal first days in the week.  And we have to use the
1900             // correct first day of the week to delineate the week
1901             // boundaries.
1902 
1903             // Here&#39;s our algorithm.  First, we find the real boundaries of
1904             // the month.  Then we discard the first partial week if it
1905             // doesn&#39;t count in this locale.  Then we fill in the ends with
1906             // phantom days, so that the first partial week and the last
1907             // partial week are full weeks.  We then have a nice square
1908             // block of weeks.  We do the usual rolling within this block,
1909             // as is done elsewhere in this method.  If we wind up on one of
1910             // the phantom days that we added, we recognize this and pin to
1911             // the first or the last day of the month.  Easy, eh?
1912 
1913             // Normalize the DAY_OF_WEEK so that 0 is the first day of the week
1914             // in this locale.  We have dow in 0..6.
1915             int32_t dow = internalGet(UCAL_DAY_OF_WEEK) - getFirstDayOfWeek();
1916             if (dow &lt; 0) dow += 7;
1917 
1918             // Find the day of the week (normalized for locale) for the first
1919             // of the month.
1920             int32_t fdm = (dow - internalGet(UCAL_DAY_OF_MONTH) + 1) % 7;
1921             if (fdm &lt; 0) fdm += 7;
1922 
1923             // Get the first day of the first full week of the month,
1924             // including phantom days, if any.  Figure out if the first week
1925             // counts or not; if it counts, then fill in phantom days.  If
1926             // not, advance to the first real full week (skip the partial week).
1927             int32_t start;
1928             if ((7 - fdm) &lt; getMinimalDaysInFirstWeek())
1929                 start = 8 - fdm; // Skip the first partial week
1930             else
1931                 start = 1 - fdm; // This may be zero or negative
1932 
1933             // Get the day of the week (normalized for locale) for the last
1934             // day of the month.
1935             int32_t monthLen = getActualMaximum(UCAL_DAY_OF_MONTH, status);
1936             int32_t ldm = (monthLen - internalGet(UCAL_DAY_OF_MONTH) + dow) % 7;
1937             // We know monthLen &gt;= DAY_OF_MONTH so we skip the += 7 step here.
1938 
1939             // Get the limit day for the blocked-off rectangular month; that
1940             // is, the day which is one past the last day of the month,
1941             // after the month has already been filled in with phantom days
1942             // to fill out the last week.  This day has a normalized DOW of 0.
1943             int32_t limit = monthLen + 7 - ldm;
1944 
1945             // Now roll between start and (limit - 1).
1946             int32_t gap = limit - start;
1947             int32_t day_of_month = (internalGet(UCAL_DAY_OF_MONTH) + amount*7 -
1948                 start) % gap;
1949             if (day_of_month &lt; 0) day_of_month += gap;
1950             day_of_month += start;
1951 
1952             // Finally, pin to the real start and end of the month.
1953             if (day_of_month &lt; 1) day_of_month = 1;
1954             if (day_of_month &gt; monthLen) day_of_month = monthLen;
1955 
1956             // Set the DAY_OF_MONTH.  We rely on the fact that this field
1957             // takes precedence over everything else (since all other fields
1958             // are also set at this point).  If this fact changes (if the
1959             // disambiguation algorithm changes) then we will have to unset
1960             // the appropriate fields here so that DAY_OF_MONTH is attended
1961             // to.
1962             set(UCAL_DAY_OF_MONTH, day_of_month);
1963             return;
1964         }
1965     case UCAL_WEEK_OF_YEAR:
1966         {
1967             // This follows the outline of WEEK_OF_MONTH, except it applies
1968             // to the whole year.  Please see the comment for WEEK_OF_MONTH
1969             // for general notes.
1970 
1971             // Normalize the DAY_OF_WEEK so that 0 is the first day of the week
1972             // in this locale.  We have dow in 0..6.
1973             int32_t dow = internalGet(UCAL_DAY_OF_WEEK) - getFirstDayOfWeek();
1974             if (dow &lt; 0) dow += 7;
1975 
1976             // Find the day of the week (normalized for locale) for the first
1977             // of the year.
1978             int32_t fdy = (dow - internalGet(UCAL_DAY_OF_YEAR) + 1) % 7;
1979             if (fdy &lt; 0) fdy += 7;
1980 
1981             // Get the first day of the first full week of the year,
1982             // including phantom days, if any.  Figure out if the first week
1983             // counts or not; if it counts, then fill in phantom days.  If
1984             // not, advance to the first real full week (skip the partial week).
1985             int32_t start;
1986             if ((7 - fdy) &lt; getMinimalDaysInFirstWeek())
1987                 start = 8 - fdy; // Skip the first partial week
1988             else
1989                 start = 1 - fdy; // This may be zero or negative
1990 
1991             // Get the day of the week (normalized for locale) for the last
1992             // day of the year.
1993             int32_t yearLen = getActualMaximum(UCAL_DAY_OF_YEAR,status);
1994             int32_t ldy = (yearLen - internalGet(UCAL_DAY_OF_YEAR) + dow) % 7;
1995             // We know yearLen &gt;= DAY_OF_YEAR so we skip the += 7 step here.
1996 
1997             // Get the limit day for the blocked-off rectangular year; that
1998             // is, the day which is one past the last day of the year,
1999             // after the year has already been filled in with phantom days
2000             // to fill out the last week.  This day has a normalized DOW of 0.
2001             int32_t limit = yearLen + 7 - ldy;
2002 
2003             // Now roll between start and (limit - 1).
2004             int32_t gap = limit - start;
2005             int32_t day_of_year = (internalGet(UCAL_DAY_OF_YEAR) + amount*7 -
2006                 start) % gap;
2007             if (day_of_year &lt; 0) day_of_year += gap;
2008             day_of_year += start;
2009 
2010             // Finally, pin to the real start and end of the month.
2011             if (day_of_year &lt; 1) day_of_year = 1;
2012             if (day_of_year &gt; yearLen) day_of_year = yearLen;
2013 
2014             // Make sure that the year and day of year are attended to by
2015             // clearing other fields which would normally take precedence.
2016             // If the disambiguation algorithm is changed, this section will
2017             // have to be updated as well.
2018             set(UCAL_DAY_OF_YEAR, day_of_year);
2019             clear(UCAL_MONTH);
2020             return;
2021         }
2022     case UCAL_DAY_OF_YEAR:
2023         {
2024             // Roll the day of year using millis.  Compute the millis for
2025             // the start of the year, and get the length of the year.
2026             double delta = amount * kOneDay; // Scale up from days to millis
2027             double min2 = internalGet(UCAL_DAY_OF_YEAR)-1;
2028             min2 *= kOneDay;
2029             min2 = internalGetTime() - min2;
2030 
2031             //      double min2 = internalGetTime() - (internalGet(UCAL_DAY_OF_YEAR) - 1.0) * kOneDay;
2032             double newtime;
2033 
2034             double yearLength = getActualMaximum(UCAL_DAY_OF_YEAR,status);
2035             double oneYear = yearLength;
2036             oneYear *= kOneDay;
2037             newtime = uprv_fmod((internalGetTime() + delta - min2), oneYear);
2038             if (newtime &lt; 0) newtime += oneYear;
2039             setTimeInMillis(newtime + min2, status);
2040             return;
2041         }
2042     case UCAL_DAY_OF_WEEK:
2043     case UCAL_DOW_LOCAL:
2044         {
2045             // Roll the day of week using millis.  Compute the millis for
2046             // the start of the week, using the first day of week setting.
2047             // Restrict the millis to [start, start+7days).
2048             double delta = amount * kOneDay; // Scale up from days to millis
2049             // Compute the number of days before the current day in this
2050             // week.  This will be a value 0..6.
2051             int32_t leadDays = internalGet(field);
2052             leadDays -= (field == UCAL_DAY_OF_WEEK) ? getFirstDayOfWeek() : 1;
2053             if (leadDays &lt; 0) leadDays += 7;
2054             double min2 = internalGetTime() - leadDays * kOneDay;
2055             double newtime = uprv_fmod((internalGetTime() + delta - min2), kOneWeek);
2056             if (newtime &lt; 0) newtime += kOneWeek;
2057             setTimeInMillis(newtime + min2, status);
2058             return;
2059         }
2060     case UCAL_DAY_OF_WEEK_IN_MONTH:
2061         {
2062             // Roll the day of week in the month using millis.  Determine
2063             // the first day of the week in the month, and then the last,
2064             // and then roll within that range.
2065             double delta = amount * kOneWeek; // Scale up from weeks to millis
2066             // Find the number of same days of the week before this one
2067             // in this month.
2068             int32_t preWeeks = (internalGet(UCAL_DAY_OF_MONTH) - 1) / 7;
2069             // Find the number of same days of the week after this one
2070             // in this month.
2071             int32_t postWeeks = (getActualMaximum(UCAL_DAY_OF_MONTH,status) -
2072                 internalGet(UCAL_DAY_OF_MONTH)) / 7;
2073             // From these compute the min and gap millis for rolling.
2074             double min2 = internalGetTime() - preWeeks * kOneWeek;
2075             double gap2 = kOneWeek * (preWeeks + postWeeks + 1); // Must add 1!
2076             // Roll within this range
2077             double newtime = uprv_fmod((internalGetTime() + delta - min2), gap2);
2078             if (newtime &lt; 0) newtime += gap2;
2079             setTimeInMillis(newtime + min2, status);
2080             return;
2081         }
2082     case UCAL_JULIAN_DAY:
2083         set(field, internalGet(field) + amount);
2084         return;
2085     default:
2086         // Other fields cannot be rolled by this method
2087 #if defined (U_DEBUG_CAL)
2088         fprintf(stderr, &quot;%s:%d: ILLEGAL ARG because of roll on non-rollable field %s\n&quot;,
2089             __FILE__, __LINE__,fldName(field));
2090 #endif
2091         status = U_ILLEGAL_ARGUMENT_ERROR;
2092     }
2093 }
2094 
2095 void Calendar::add(EDateFields field, int32_t amount, UErrorCode&amp; status)
2096 {
2097     Calendar::add((UCalendarDateFields)field, amount, status);
2098 }
2099 
2100 // -------------------------------------
2101 void Calendar::add(UCalendarDateFields field, int32_t amount, UErrorCode&amp; status)
2102 {
2103     if (amount == 0) {
2104         return;   // Do nothing!
2105     }
2106 
2107     // We handle most fields in the same way.  The algorithm is to add
2108     // a computed amount of millis to the current millis.  The only
2109     // wrinkle is with DST (and/or a change to the zone&#39;s UTC offset, which
2110     // we&#39;ll include with DST) -- for some fields, like the DAY_OF_MONTH,
2111     // we don&#39;t want the wall time to shift due to changes in DST.  If the
2112     // result of the add operation is to move from DST to Standard, or
2113     // vice versa, we need to adjust by an hour forward or back,
2114     // respectively.  For such fields we set keepWallTimeInvariant to TRUE.
2115 
2116     // We only adjust the DST for fields larger than an hour.  For
2117     // fields smaller than an hour, we cannot adjust for DST without
2118     // causing problems.  for instance, if you add one hour to April 5,
2119     // 1998, 1:00 AM, in PST, the time becomes &quot;2:00 AM PDT&quot; (an
2120     // illegal value), but then the adjustment sees the change and
2121     // compensates by subtracting an hour.  As a result the time
2122     // doesn&#39;t advance at all.
2123 
2124     // For some fields larger than a day, such as a UCAL_MONTH, we pin the
2125     // UCAL_DAY_OF_MONTH.  This allows &lt;March 31&gt;.add(UCAL_MONTH, 1) to be
2126     // &lt;April 30&gt;, rather than &lt;April 31&gt; =&gt; &lt;May 1&gt;.
2127 
2128     double delta = amount; // delta in ms
2129     UBool keepWallTimeInvariant = TRUE;
2130 
2131     switch (field) {
2132     case UCAL_ERA:
2133         set(field, get(field, status) + amount);
2134         pinField(UCAL_ERA, status);
2135         return;
2136 
2137     case UCAL_YEAR:
2138     case UCAL_YEAR_WOY:
2139       {
2140         // * If era=0 and years go backwards in time, change sign of amount.
2141         // * Until we have new API per #9393, we temporarily hardcode knowledge of
2142         //   which calendars have era 0 years that go backwards.
2143         // * Note that for UCAL_YEAR (but not UCAL_YEAR_WOY) we could instead handle
2144         //   this by applying the amount to the UCAL_EXTENDED_YEAR field; but since
2145         //   we would still need to handle UCAL_YEAR_WOY as below, might as well
2146         //   also handle UCAL_YEAR the same way.
2147         int32_t era = get(UCAL_ERA, status);
2148         if (era == 0) {
2149           const char * calType = getType();
2150           if ( uprv_strcmp(calType,&quot;gregorian&quot;)==0 || uprv_strcmp(calType,&quot;roc&quot;)==0 || uprv_strcmp(calType,&quot;coptic&quot;)==0 ) {
2151             amount = -amount;
2152           }
2153         }
2154       }
2155       // Fall through into normal handling
2156       U_FALLTHROUGH;
2157     case UCAL_EXTENDED_YEAR:
2158     case UCAL_MONTH:
2159       {
2160         UBool oldLenient = isLenient();
2161         setLenient(TRUE);
2162         set(field, get(field, status) + amount);
2163         pinField(UCAL_DAY_OF_MONTH, status);
2164         if(oldLenient==FALSE) {
2165           complete(status); /* force recalculate */
2166           setLenient(oldLenient);
2167         }
2168       }
2169       return;
2170 
2171     case UCAL_WEEK_OF_YEAR:
2172     case UCAL_WEEK_OF_MONTH:
2173     case UCAL_DAY_OF_WEEK_IN_MONTH:
2174         delta *= kOneWeek;
2175         break;
2176 
2177     case UCAL_AM_PM:
2178         delta *= 12 * kOneHour;
2179         break;
2180 
2181     case UCAL_DAY_OF_MONTH:
2182     case UCAL_DAY_OF_YEAR:
2183     case UCAL_DAY_OF_WEEK:
2184     case UCAL_DOW_LOCAL:
2185     case UCAL_JULIAN_DAY:
2186         delta *= kOneDay;
2187         break;
2188 
2189     case UCAL_HOUR_OF_DAY:
2190     case UCAL_HOUR:
2191         delta *= kOneHour;
2192         keepWallTimeInvariant = FALSE;
2193         break;
2194 
2195     case UCAL_MINUTE:
2196         delta *= kOneMinute;
2197         keepWallTimeInvariant = FALSE;
2198         break;
2199 
2200     case UCAL_SECOND:
2201         delta *= kOneSecond;
2202         keepWallTimeInvariant = FALSE;
2203         break;
2204 
2205     case UCAL_MILLISECOND:
2206     case UCAL_MILLISECONDS_IN_DAY:
2207         keepWallTimeInvariant = FALSE;
2208         break;
2209 
2210     default:
2211 #if defined (U_DEBUG_CAL)
2212         fprintf(stderr, &quot;%s:%d: ILLEGAL ARG because field %s not addable&quot;,
2213             __FILE__, __LINE__, fldName(field));
2214 #endif
2215         status = U_ILLEGAL_ARGUMENT_ERROR;
2216         return;
2217         //  throw new IllegalArgumentException(&quot;Calendar.add(&quot; + fieldName(field) +
2218         //                                     &quot;) not supported&quot;);
2219     }
2220 
2221     // In order to keep the wall time invariant (for fields where this is
2222     // appropriate), check the combined DST &amp; ZONE offset before and
2223     // after the add() operation. If it changes, then adjust the millis
2224     // to compensate.
2225     int32_t prevOffset = 0;
2226     int32_t prevWallTime = 0;
2227     if (keepWallTimeInvariant) {
2228         prevOffset = get(UCAL_DST_OFFSET, status) + get(UCAL_ZONE_OFFSET, status);
2229         prevWallTime = get(UCAL_MILLISECONDS_IN_DAY, status);
2230     }
2231 
2232     setTimeInMillis(getTimeInMillis(status) + delta, status);
2233 
2234     if (keepWallTimeInvariant) {
2235         int32_t newWallTime = get(UCAL_MILLISECONDS_IN_DAY, status);
2236         if (newWallTime != prevWallTime) {
2237             // There is at least one zone transition between the base
2238             // time and the result time. As the result, wall time has
2239             // changed.
2240             UDate t = internalGetTime();
2241             int32_t newOffset = get(UCAL_DST_OFFSET, status) + get(UCAL_ZONE_OFFSET, status);
2242             if (newOffset != prevOffset) {
2243                 // When the difference of the previous UTC offset and
2244                 // the new UTC offset exceeds 1 full day, we do not want
2245                 // to roll over/back the date. For now, this only happens
2246                 // in Samoa (Pacific/Apia) on Dec 30, 2011. See ticket:9452.
2247                 int32_t adjAmount = prevOffset - newOffset;
2248                 adjAmount = adjAmount &gt;= 0 ? adjAmount % (int32_t)kOneDay : -(-adjAmount % (int32_t)kOneDay);
2249                 if (adjAmount != 0) {
2250                     setTimeInMillis(t + adjAmount, status);
2251                     newWallTime = get(UCAL_MILLISECONDS_IN_DAY, status);
2252                 }
2253                 if (newWallTime != prevWallTime) {
2254                     // The result wall time or adjusted wall time was shifted because
2255                     // the target wall time does not exist on the result date.
2256                     switch (fSkippedWallTime) {
2257                     case UCAL_WALLTIME_FIRST:
2258                         if (adjAmount &gt; 0) {
2259                             setTimeInMillis(t, status);
2260                         }
2261                         break;
2262                     case UCAL_WALLTIME_LAST:
2263                         if (adjAmount &lt; 0) {
2264                             setTimeInMillis(t, status);
2265                         }
2266                         break;
2267                     case UCAL_WALLTIME_NEXT_VALID:
2268                         UDate tmpT = adjAmount &gt; 0 ? internalGetTime() : t;
2269                         UDate immediatePrevTrans;
2270                         UBool hasTransition = getImmediatePreviousZoneTransition(tmpT, &amp;immediatePrevTrans, status);
2271                         if (U_SUCCESS(status) &amp;&amp; hasTransition) {
2272                             setTimeInMillis(immediatePrevTrans, status);
2273                         }
2274                         break;
2275                     }
2276                 }
2277             }
2278         }
2279     }
2280 }
2281 
2282 // -------------------------------------
2283 int32_t Calendar::fieldDifference(UDate when, EDateFields field, UErrorCode&amp; status) {
2284     return fieldDifference(when, (UCalendarDateFields) field, status);
2285 }
2286 
2287 int32_t Calendar::fieldDifference(UDate targetMs, UCalendarDateFields field, UErrorCode&amp; ec) {
2288     if (U_FAILURE(ec)) return 0;
2289     int32_t min = 0;
2290     double startMs = getTimeInMillis(ec);
2291     // Always add from the start millis.  This accomodates
2292     // operations like adding years from February 29, 2000 up to
2293     // February 29, 2004.  If 1, 1, 1, 1 is added to the year
2294     // field, the DOM gets pinned to 28 and stays there, giving an
2295     // incorrect DOM difference of 1.  We have to add 1, reset, 2,
2296     // reset, 3, reset, 4.
2297     if (startMs &lt; targetMs) {
2298         int32_t max = 1;
2299         // Find a value that is too large
2300         while (U_SUCCESS(ec)) {
2301             setTimeInMillis(startMs, ec);
2302             add(field, max, ec);
2303             double ms = getTimeInMillis(ec);
2304             if (ms == targetMs) {
2305                 return max;
2306             } else if (ms &gt; targetMs) {
2307                 break;
2308             } else if (max &lt; INT32_MAX) {
2309                 min = max;
2310                 max &lt;&lt;= 1;
2311                 if (max &lt; 0) {
2312                     max = INT32_MAX;
2313                 }
2314             } else {
2315                 // Field difference too large to fit into int32_t
2316 #if defined (U_DEBUG_CAL)
2317                 fprintf(stderr, &quot;%s:%d: ILLEGAL ARG because field %s&#39;s max too large for int32_t\n&quot;,
2318                     __FILE__, __LINE__, fldName(field));
2319 #endif
2320                 ec = U_ILLEGAL_ARGUMENT_ERROR;
2321             }
2322         }
2323         // Do a binary search
2324         while ((max - min) &gt; 1 &amp;&amp; U_SUCCESS(ec)) {
2325             int32_t t = min + (max - min)/2; // make sure intermediate values don&#39;t exceed INT32_MAX
2326             setTimeInMillis(startMs, ec);
2327             add(field, t, ec);
2328             double ms = getTimeInMillis(ec);
2329             if (ms == targetMs) {
2330                 return t;
2331             } else if (ms &gt; targetMs) {
2332                 max = t;
2333             } else {
2334                 min = t;
2335             }
2336         }
2337     } else if (startMs &gt; targetMs) {
2338         int32_t max = -1;
2339         // Find a value that is too small
2340         while (U_SUCCESS(ec)) {
2341             setTimeInMillis(startMs, ec);
2342             add(field, max, ec);
2343             double ms = getTimeInMillis(ec);
2344             if (ms == targetMs) {
2345                 return max;
2346             } else if (ms &lt; targetMs) {
2347                 break;
2348             } else {
2349                 min = max;
2350                 max &lt;&lt;= 1;
2351                 if (max == 0) {
2352                     // Field difference too large to fit into int32_t
2353 #if defined (U_DEBUG_CAL)
2354                     fprintf(stderr, &quot;%s:%d: ILLEGAL ARG because field %s&#39;s max too large for int32_t\n&quot;,
2355                         __FILE__, __LINE__, fldName(field));
2356 #endif
2357                     ec = U_ILLEGAL_ARGUMENT_ERROR;
2358                 }
2359             }
2360         }
2361         // Do a binary search
2362         while ((min - max) &gt; 1 &amp;&amp; U_SUCCESS(ec)) {
2363             int32_t t = min + (max - min)/2; // make sure intermediate values don&#39;t exceed INT32_MAX
2364             setTimeInMillis(startMs, ec);
2365             add(field, t, ec);
2366             double ms = getTimeInMillis(ec);
2367             if (ms == targetMs) {
2368                 return t;
2369             } else if (ms &lt; targetMs) {
2370                 max = t;
2371             } else {
2372                 min = t;
2373             }
2374         }
2375     }
2376     // Set calendar to end point
2377     setTimeInMillis(startMs, ec);
2378     add(field, min, ec);
2379 
2380     /* Test for buffer overflows */
2381     if(U_FAILURE(ec)) {
2382         return 0;
2383     }
2384     return min;
2385 }
2386 
2387 // -------------------------------------
2388 
2389 void
2390 Calendar::adoptTimeZone(TimeZone* zone)
2391 {
2392     // Do nothing if passed-in zone is NULL
2393     if (zone == NULL) return;
2394 
2395     // fZone should always be non-null
2396     delete fZone;
2397     fZone = zone;
2398 
2399     // if the zone changes, we need to recompute the time fields
2400     fAreFieldsSet = FALSE;
2401 }
2402 
2403 // -------------------------------------
2404 void
2405 Calendar::setTimeZone(const TimeZone&amp; zone)
2406 {
2407     adoptTimeZone(zone.clone());
2408 }
2409 
2410 // -------------------------------------
2411 
2412 const TimeZone&amp;
2413 Calendar::getTimeZone() const
2414 {
2415     U_ASSERT(fZone != NULL);
2416     return *fZone;
2417 }
2418 
2419 // -------------------------------------
2420 
2421 TimeZone*
2422 Calendar::orphanTimeZone()
2423 {
2424     // we let go of the time zone; the new time zone is the system default time zone
2425     TimeZone *defaultZone = TimeZone::createDefault();
2426     if (defaultZone == NULL) {
2427         // No error handling available. Must keep fZone non-NULL, there are many unchecked uses.
2428         return NULL;
2429     }
2430     TimeZone *z = fZone;
2431     fZone = defaultZone;
2432     return z;
2433 }
2434 
2435 // -------------------------------------
2436 
2437 void
2438 Calendar::setLenient(UBool lenient)
2439 {
2440     fLenient = lenient;
2441 }
2442 
2443 // -------------------------------------
2444 
2445 UBool
2446 Calendar::isLenient() const
2447 {
2448     return fLenient;
2449 }
2450 
2451 // -------------------------------------
2452 
2453 void
2454 Calendar::setRepeatedWallTimeOption(UCalendarWallTimeOption option)
2455 {
2456     if (option == UCAL_WALLTIME_LAST || option == UCAL_WALLTIME_FIRST) {
2457         fRepeatedWallTime = option;
2458     }
2459 }
2460 
2461 // -------------------------------------
2462 
2463 UCalendarWallTimeOption
2464 Calendar::getRepeatedWallTimeOption(void) const
2465 {
2466     return fRepeatedWallTime;
2467 }
2468 
2469 // -------------------------------------
2470 
2471 void
2472 Calendar::setSkippedWallTimeOption(UCalendarWallTimeOption option)
2473 {
2474     fSkippedWallTime = option;
2475 }
2476 
2477 // -------------------------------------
2478 
2479 UCalendarWallTimeOption
2480 Calendar::getSkippedWallTimeOption(void) const
2481 {
2482     return fSkippedWallTime;
2483 }
2484 
2485 // -------------------------------------
2486 
2487 void
2488 Calendar::setFirstDayOfWeek(UCalendarDaysOfWeek value)
2489 {
2490     if (fFirstDayOfWeek != value &amp;&amp;
2491         value &gt;= UCAL_SUNDAY &amp;&amp; value &lt;= UCAL_SATURDAY) {
2492             fFirstDayOfWeek = value;
2493             fAreFieldsSet = FALSE;
2494         }
2495 }
2496 
2497 // -------------------------------------
2498 
2499 Calendar::EDaysOfWeek
2500 Calendar::getFirstDayOfWeek() const
2501 {
2502     return (Calendar::EDaysOfWeek)fFirstDayOfWeek;
2503 }
2504 
2505 UCalendarDaysOfWeek
2506 Calendar::getFirstDayOfWeek(UErrorCode &amp; /*status*/) const
2507 {
2508     return fFirstDayOfWeek;
2509 }
2510 // -------------------------------------
2511 
2512 void
2513 Calendar::setMinimalDaysInFirstWeek(uint8_t value)
2514 {
2515     // Values less than 1 have the same effect as 1; values greater
2516     // than 7 have the same effect as 7. However, we normalize values
2517     // so operator== and so forth work.
2518     if (value &lt; 1) {
2519         value = 1;
2520     } else if (value &gt; 7) {
2521         value = 7;
2522     }
2523     if (fMinimalDaysInFirstWeek != value) {
2524         fMinimalDaysInFirstWeek = value;
2525         fAreFieldsSet = FALSE;
2526     }
2527 }
2528 
2529 // -------------------------------------
2530 
2531 uint8_t
2532 Calendar::getMinimalDaysInFirstWeek() const
2533 {
2534     return fMinimalDaysInFirstWeek;
2535 }
2536 
2537 // -------------------------------------
2538 // weekend functions, just dummy implementations for now (for API freeze)
2539 
2540 UCalendarWeekdayType
2541 Calendar::getDayOfWeekType(UCalendarDaysOfWeek dayOfWeek, UErrorCode &amp;status) const
2542 {
2543     if (U_FAILURE(status)) {
2544         return UCAL_WEEKDAY;
2545     }
2546     if (dayOfWeek &lt; UCAL_SUNDAY || dayOfWeek &gt; UCAL_SATURDAY) {
2547         status = U_ILLEGAL_ARGUMENT_ERROR;
2548         return UCAL_WEEKDAY;
2549     }
2550     if (fWeekendOnset == fWeekendCease) {
2551         if (dayOfWeek != fWeekendOnset)
2552             return UCAL_WEEKDAY;
2553         return (fWeekendOnsetMillis == 0) ? UCAL_WEEKEND : UCAL_WEEKEND_ONSET;
2554     }
2555     if (fWeekendOnset &lt; fWeekendCease) {
2556         if (dayOfWeek &lt; fWeekendOnset || dayOfWeek &gt; fWeekendCease) {
2557             return UCAL_WEEKDAY;
2558         }
2559     } else {
2560         if (dayOfWeek &gt; fWeekendCease &amp;&amp; dayOfWeek &lt; fWeekendOnset) {
2561             return UCAL_WEEKDAY;
2562         }
2563     }
2564     if (dayOfWeek == fWeekendOnset) {
2565         return (fWeekendOnsetMillis == 0) ? UCAL_WEEKEND : UCAL_WEEKEND_ONSET;
2566     }
2567     if (dayOfWeek == fWeekendCease) {
2568         return (fWeekendCeaseMillis &gt;= 86400000) ? UCAL_WEEKEND : UCAL_WEEKEND_CEASE;
2569     }
2570     return UCAL_WEEKEND;
2571 }
2572 
2573 int32_t
2574 Calendar::getWeekendTransition(UCalendarDaysOfWeek dayOfWeek, UErrorCode &amp;status) const
2575 {
2576     if (U_FAILURE(status)) {
2577         return 0;
2578     }
2579     if (dayOfWeek == fWeekendOnset) {
2580         return fWeekendOnsetMillis;
2581     } else if (dayOfWeek == fWeekendCease) {
2582         return fWeekendCeaseMillis;
2583     }
2584     status = U_ILLEGAL_ARGUMENT_ERROR;
2585     return 0;
2586 }
2587 
2588 UBool
2589 Calendar::isWeekend(UDate date, UErrorCode &amp;status) const
2590 {
2591     if (U_FAILURE(status)) {
2592         return FALSE;
2593     }
2594     // clone the calendar so we don&#39;t mess with the real one.
2595     Calendar *work = (Calendar*)this-&gt;clone();
2596     if (work == NULL) {
2597         status = U_MEMORY_ALLOCATION_ERROR;
2598         return FALSE;
2599     }
2600     UBool result = FALSE;
2601     work-&gt;setTime(date, status);
2602     if (U_SUCCESS(status)) {
2603         result = work-&gt;isWeekend();
2604     }
2605     delete work;
2606     return result;
2607 }
2608 
2609 UBool
2610 Calendar::isWeekend(void) const
2611 {
2612     UErrorCode status = U_ZERO_ERROR;
2613     UCalendarDaysOfWeek dayOfWeek = (UCalendarDaysOfWeek)get(UCAL_DAY_OF_WEEK, status);
2614     UCalendarWeekdayType dayType = getDayOfWeekType(dayOfWeek, status);
2615     if (U_SUCCESS(status)) {
2616         switch (dayType) {
2617             case UCAL_WEEKDAY:
2618                 return FALSE;
2619             case UCAL_WEEKEND:
2620                 return TRUE;
2621             case UCAL_WEEKEND_ONSET:
2622             case UCAL_WEEKEND_CEASE:
2623                 // Use internalGet() because the above call to get() populated all fields.
2624                 {
2625                     int32_t millisInDay = internalGet(UCAL_MILLISECONDS_IN_DAY);
2626                     int32_t transitionMillis = getWeekendTransition(dayOfWeek, status);
2627                     if (U_SUCCESS(status)) {
2628                         return (dayType == UCAL_WEEKEND_ONSET)?
2629                             (millisInDay &gt;= transitionMillis):
2630                             (millisInDay &lt;  transitionMillis);
2631                     }
2632                     // else fall through, return FALSE
2633                     U_FALLTHROUGH;
2634                 }
2635             default:
2636                 break;
2637         }
2638     }
2639     return FALSE;
2640 }
2641 
2642 // ------------------------------------- limits
2643 
2644 int32_t
2645 Calendar::getMinimum(EDateFields field) const {
2646     return getLimit((UCalendarDateFields) field,UCAL_LIMIT_MINIMUM);
2647 }
2648 
2649 int32_t
2650 Calendar::getMinimum(UCalendarDateFields field) const
2651 {
2652     return getLimit(field,UCAL_LIMIT_MINIMUM);
2653 }
2654 
2655 // -------------------------------------
2656 int32_t
2657 Calendar::getMaximum(EDateFields field) const
2658 {
2659     return getLimit((UCalendarDateFields) field,UCAL_LIMIT_MAXIMUM);
2660 }
2661 
2662 int32_t
2663 Calendar::getMaximum(UCalendarDateFields field) const
2664 {
2665     return getLimit(field,UCAL_LIMIT_MAXIMUM);
2666 }
2667 
2668 // -------------------------------------
2669 int32_t
2670 Calendar::getGreatestMinimum(EDateFields field) const
2671 {
2672     return getLimit((UCalendarDateFields)field,UCAL_LIMIT_GREATEST_MINIMUM);
2673 }
2674 
2675 int32_t
2676 Calendar::getGreatestMinimum(UCalendarDateFields field) const
2677 {
2678     return getLimit(field,UCAL_LIMIT_GREATEST_MINIMUM);
2679 }
2680 
2681 // -------------------------------------
2682 int32_t
2683 Calendar::getLeastMaximum(EDateFields field) const
2684 {
2685     return getLimit((UCalendarDateFields) field,UCAL_LIMIT_LEAST_MAXIMUM);
2686 }
2687 
2688 int32_t
2689 Calendar::getLeastMaximum(UCalendarDateFields field) const
2690 {
2691     return getLimit( field,UCAL_LIMIT_LEAST_MAXIMUM);
2692 }
2693 
2694 // -------------------------------------
2695 int32_t
2696 Calendar::getActualMinimum(EDateFields field, UErrorCode&amp; status) const
2697 {
2698     return getActualMinimum((UCalendarDateFields) field, status);
2699 }
2700 
2701 int32_t Calendar::getLimit(UCalendarDateFields field, ELimitType limitType) const {
2702     switch (field) {
2703     case UCAL_DAY_OF_WEEK:
2704     case UCAL_AM_PM:
2705     case UCAL_HOUR:
2706     case UCAL_HOUR_OF_DAY:
2707     case UCAL_MINUTE:
2708     case UCAL_SECOND:
2709     case UCAL_MILLISECOND:
2710     case UCAL_ZONE_OFFSET:
2711     case UCAL_DST_OFFSET:
2712     case UCAL_DOW_LOCAL:
2713     case UCAL_JULIAN_DAY:
2714     case UCAL_MILLISECONDS_IN_DAY:
2715     case UCAL_IS_LEAP_MONTH:
2716         return kCalendarLimits[field][limitType];
2717 
2718     case UCAL_WEEK_OF_MONTH:
2719         {
2720             int32_t limit;
2721             if (limitType == UCAL_LIMIT_MINIMUM) {
2722                 limit = getMinimalDaysInFirstWeek() == 1 ? 1 : 0;
2723             } else if (limitType == UCAL_LIMIT_GREATEST_MINIMUM) {
2724                 limit = 1;
2725             } else {
2726                 int32_t minDaysInFirst = getMinimalDaysInFirstWeek();
2727                 int32_t daysInMonth = handleGetLimit(UCAL_DAY_OF_MONTH, limitType);
2728                 if (limitType == UCAL_LIMIT_LEAST_MAXIMUM) {
2729                     limit = (daysInMonth + (7 - minDaysInFirst)) / 7;
2730                 } else { // limitType == UCAL_LIMIT_MAXIMUM
2731                     limit = (daysInMonth + 6 + (7 - minDaysInFirst)) / 7;
2732                 }
2733             }
2734             return limit;
2735         }
2736     default:
2737         return handleGetLimit(field, limitType);
2738     }
2739 }
2740 
2741 
2742 int32_t
2743 Calendar::getActualMinimum(UCalendarDateFields field, UErrorCode&amp; status) const
2744 {
2745     int32_t fieldValue = getGreatestMinimum(field);
2746     int32_t endValue = getMinimum(field);
2747 
2748     // if we know that the minimum value is always the same, just return it
2749     if (fieldValue == endValue) {
2750         return fieldValue;
2751     }
2752 
2753     // clone the calendar so we don&#39;t mess with the real one, and set it to
2754     // accept anything for the field values
2755     Calendar *work = (Calendar*)this-&gt;clone();
2756     if (work == NULL) {
2757         status = U_MEMORY_ALLOCATION_ERROR;
2758         return 0;
2759     }
2760     work-&gt;setLenient(TRUE);
2761 
2762     // now try each value from getLeastMaximum() to getMaximum() one by one until
2763     // we get a value that normalizes to another value.  The last value that
2764     // normalizes to itself is the actual minimum for the current date
2765     int32_t result = fieldValue;
2766 
2767     do {
2768         work-&gt;set(field, fieldValue);
2769         if (work-&gt;get(field, status) != fieldValue) {
2770             break;
2771         }
2772         else {
2773             result = fieldValue;
2774             fieldValue--;
2775         }
2776     } while (fieldValue &gt;= endValue);
2777 
2778     delete work;
2779 
2780     /* Test for buffer overflows */
2781     if(U_FAILURE(status)) {
2782         return 0;
2783     }
2784     return result;
2785 }
2786 
2787 // -------------------------------------
2788 
2789 
2790 
2791 /**
2792 * Ensure that each field is within its valid range by calling {@link
2793 * #validateField(int)} on each field that has been set.  This method
2794 * should only be called if this calendar is not lenient.
2795 * @see #isLenient
2796 * @see #validateField(int)
2797 */
2798 void Calendar::validateFields(UErrorCode &amp;status) {
2799     for (int32_t field = 0; U_SUCCESS(status) &amp;&amp; (field &lt; UCAL_FIELD_COUNT); field++) {
2800         if (fStamp[field] &gt;= kMinimumUserStamp) {
2801             validateField((UCalendarDateFields)field, status);
2802         }
2803     }
2804 }
2805 
2806 /**
2807 * Validate a single field of this calendar.  Subclasses should
2808 * override this method to validate any calendar-specific fields.
2809 * Generic fields can be handled by
2810 * &lt;code&gt;Calendar.validateField()&lt;/code&gt;.
2811 * @see #validateField(int, int, int)
2812 */
2813 void Calendar::validateField(UCalendarDateFields field, UErrorCode &amp;status) {
2814     int32_t y;
2815     switch (field) {
2816     case UCAL_DAY_OF_MONTH:
2817         y = handleGetExtendedYear();
2818         validateField(field, 1, handleGetMonthLength(y, internalGet(UCAL_MONTH)), status);
2819         break;
2820     case UCAL_DAY_OF_YEAR:
2821         y = handleGetExtendedYear();
2822         validateField(field, 1, handleGetYearLength(y), status);
2823         break;
2824     case UCAL_DAY_OF_WEEK_IN_MONTH:
2825         if (internalGet(field) == 0) {
2826 #if defined (U_DEBUG_CAL)
2827             fprintf(stderr, &quot;%s:%d: ILLEGAL ARG because DOW in month cannot be 0\n&quot;,
2828                 __FILE__, __LINE__);
2829 #endif
2830             status = U_ILLEGAL_ARGUMENT_ERROR; // &quot;DAY_OF_WEEK_IN_MONTH cannot be zero&quot;
2831             return;
2832         }
2833         validateField(field, getMinimum(field), getMaximum(field), status);
2834         break;
2835     default:
2836         validateField(field, getMinimum(field), getMaximum(field), status);
2837         break;
2838     }
2839 }
2840 
2841 /**
2842 * Validate a single field of this calendar given its minimum and
2843 * maximum allowed value.  If the field is out of range, throw a
2844 * descriptive &lt;code&gt;IllegalArgumentException&lt;/code&gt;.  Subclasses may
2845 * use this method in their implementation of {@link
2846 * #validateField(int)}.
2847 */
2848 void Calendar::validateField(UCalendarDateFields field, int32_t min, int32_t max, UErrorCode&amp; status)
2849 {
2850     int32_t value = fFields[field];
2851     if (value &lt; min || value &gt; max) {
2852 #if defined (U_DEBUG_CAL)
2853         fprintf(stderr, &quot;%s:%d: ILLEGAL ARG because of field %s out of range %d..%d  at %d\n&quot;,
2854             __FILE__, __LINE__,fldName(field),min,max,value);
2855 #endif
2856         status = U_ILLEGAL_ARGUMENT_ERROR;
2857         return;
2858     }
2859 }
2860 
2861 // -------------------------
2862 
2863 const UFieldResolutionTable* Calendar::getFieldResolutionTable() const {
2864     return kDatePrecedence;
2865 }
2866 
2867 
2868 UCalendarDateFields Calendar::newerField(UCalendarDateFields defaultField, UCalendarDateFields alternateField) const
2869 {
2870     if (fStamp[alternateField] &gt; fStamp[defaultField]) {
2871         return alternateField;
2872     }
2873     return defaultField;
2874 }
2875 
2876 UCalendarDateFields Calendar::resolveFields(const UFieldResolutionTable* precedenceTable) {
2877     int32_t bestField = UCAL_FIELD_COUNT;
2878     int32_t tempBestField;
2879     for (int32_t g=0; precedenceTable[g][0][0] != -1 &amp;&amp; (bestField == UCAL_FIELD_COUNT); ++g) {
2880         int32_t bestStamp = kUnset;
2881         for (int32_t l=0; precedenceTable[g][l][0] != -1; ++l) {
2882             int32_t lineStamp = kUnset;
2883             // Skip over first entry if it is negative
2884             for (int32_t i=((precedenceTable[g][l][0]&gt;=kResolveRemap)?1:0); precedenceTable[g][l][i]!=-1; ++i) {
2885                 U_ASSERT(precedenceTable[g][l][i] &lt; UCAL_FIELD_COUNT);
2886                 int32_t s = fStamp[precedenceTable[g][l][i]];
2887                 // If any field is unset then don&#39;t use this line
2888                 if (s == kUnset) {
2889                     goto linesInGroup;
2890                 } else if(s &gt; lineStamp) {
2891                     lineStamp = s;
2892                 }
2893             }
2894             // Record new maximum stamp &amp; field no.
2895             if (lineStamp &gt; bestStamp) {
2896                 tempBestField = precedenceTable[g][l][0]; // First field refers to entire line
2897                 if (tempBestField &gt;= kResolveRemap) {
2898                     tempBestField &amp;= (kResolveRemap-1);
2899                     // This check is needed to resolve some issues with UCAL_YEAR precedence mapping
2900                     if (tempBestField != UCAL_DATE || (fStamp[UCAL_WEEK_OF_MONTH] &lt; fStamp[tempBestField])) {
2901                         bestField = tempBestField;
2902                     }
2903                 } else {
2904                     bestField = tempBestField;
2905                 }
2906 
2907                 if (bestField == tempBestField) {
2908                     bestStamp = lineStamp;
2909                 }
2910             }
2911 linesInGroup:
2912             ;
2913         }
2914     }
2915     return (UCalendarDateFields)bestField;
2916 }
2917 
2918 const UFieldResolutionTable Calendar::kDatePrecedence[] =
2919 {
2920     {
2921         { UCAL_DAY_OF_MONTH, kResolveSTOP },
2922         { UCAL_WEEK_OF_YEAR, UCAL_DAY_OF_WEEK, kResolveSTOP },
2923         { UCAL_WEEK_OF_MONTH, UCAL_DAY_OF_WEEK, kResolveSTOP },
2924         { UCAL_DAY_OF_WEEK_IN_MONTH, UCAL_DAY_OF_WEEK, kResolveSTOP },
2925         { UCAL_WEEK_OF_YEAR, UCAL_DOW_LOCAL, kResolveSTOP },
2926         { UCAL_WEEK_OF_MONTH, UCAL_DOW_LOCAL, kResolveSTOP },
2927         { UCAL_DAY_OF_WEEK_IN_MONTH, UCAL_DOW_LOCAL, kResolveSTOP },
2928         { UCAL_DAY_OF_YEAR, kResolveSTOP },
2929         { kResolveRemap | UCAL_DAY_OF_MONTH, UCAL_YEAR, kResolveSTOP },  // if YEAR is set over YEAR_WOY use DAY_OF_MONTH
2930         { kResolveRemap | UCAL_WEEK_OF_YEAR, UCAL_YEAR_WOY, kResolveSTOP },  // if YEAR_WOY is set,  calc based on WEEK_OF_YEAR
2931         { kResolveSTOP }
2932     },
2933     {
2934         { UCAL_WEEK_OF_YEAR, kResolveSTOP },
2935         { UCAL_WEEK_OF_MONTH, kResolveSTOP },
2936         { UCAL_DAY_OF_WEEK_IN_MONTH, kResolveSTOP },
2937         { kResolveRemap | UCAL_DAY_OF_WEEK_IN_MONTH, UCAL_DAY_OF_WEEK, kResolveSTOP },
2938         { kResolveRemap | UCAL_DAY_OF_WEEK_IN_MONTH, UCAL_DOW_LOCAL, kResolveSTOP },
2939         { kResolveSTOP }
2940     },
2941     {{kResolveSTOP}}
2942 };
2943 
2944 
2945 const UFieldResolutionTable Calendar::kDOWPrecedence[] =
2946 {
2947     {
2948         { UCAL_DAY_OF_WEEK,kResolveSTOP, kResolveSTOP },
2949         { UCAL_DOW_LOCAL,kResolveSTOP, kResolveSTOP },
2950         {kResolveSTOP}
2951     },
2952     {{kResolveSTOP}}
2953 };
2954 
2955 // precedence for calculating a year
2956 const UFieldResolutionTable Calendar::kYearPrecedence[] =
2957 {
2958     {
2959         { UCAL_YEAR, kResolveSTOP },
2960         { UCAL_EXTENDED_YEAR, kResolveSTOP },
2961         { UCAL_YEAR_WOY, UCAL_WEEK_OF_YEAR, kResolveSTOP },  // YEAR_WOY is useless without WEEK_OF_YEAR
2962         { kResolveSTOP }
2963     },
2964     {{kResolveSTOP}}
2965 };
2966 
2967 
2968 // -------------------------
2969 
2970 
2971 void Calendar::computeTime(UErrorCode&amp; status) {
2972     if (!isLenient()) {
2973         validateFields(status);
2974         if (U_FAILURE(status)) {
2975             return;
2976         }
2977     }
2978 
2979     // Compute the Julian day
2980     int32_t julianDay = computeJulianDay();
2981 
2982     double millis = Grego::julianDayToMillis(julianDay);
2983 
2984 #if defined (U_DEBUG_CAL)
2985     //  int32_t julianInsanityCheck =  (int32_t)ClockMath::floorDivide(millis, kOneDay);
2986     //  julianInsanityCheck += kEpochStartAsJulianDay;
2987     //  if(1 || julianInsanityCheck != julianDay) {
2988     //    fprintf(stderr, &quot;%s:%d- D&#39;oh- computed jules %d, to mills (%s)%.lf, recomputed %d\n&quot;,
2989     //            __FILE__, __LINE__, julianDay, millis&lt;0.0?&quot;NEG&quot;:&quot;&quot;, millis, julianInsanityCheck);
2990     //  }
2991 #endif
2992 
2993     double millisInDay;
2994 
2995     // We only use MILLISECONDS_IN_DAY if it has been set by the user.
2996     // This makes it possible for the caller to set the calendar to a
2997     // time and call clear(MONTH) to reset the MONTH to January.  This
2998     // is legacy behavior.  Without this, clear(MONTH) has no effect,
2999     // since the internally set JULIAN_DAY is used.
3000     if (fStamp[UCAL_MILLISECONDS_IN_DAY] &gt;= ((int32_t)kMinimumUserStamp) &amp;&amp;
3001             newestStamp(UCAL_AM_PM, UCAL_MILLISECOND, kUnset) &lt;= fStamp[UCAL_MILLISECONDS_IN_DAY]) {
3002         millisInDay = internalGet(UCAL_MILLISECONDS_IN_DAY);
3003     } else {
3004         millisInDay = computeMillisInDay();
3005     }
3006 
3007     UDate t = 0;
3008     if (fStamp[UCAL_ZONE_OFFSET] &gt;= ((int32_t)kMinimumUserStamp) || fStamp[UCAL_DST_OFFSET] &gt;= ((int32_t)kMinimumUserStamp)) {
3009         t = millis + millisInDay - (internalGet(UCAL_ZONE_OFFSET) + internalGet(UCAL_DST_OFFSET));
3010     } else {
3011         // Compute the time zone offset and DST offset.  There are two potential
3012         // ambiguities here.  We&#39;ll assume a 2:00 am (wall time) switchover time
3013         // for discussion purposes here.
3014         //
3015         // 1. The positive offset change such as transition into DST.
3016         //    Here, a designated time of 2:00 am - 2:59 am does not actually exist.
3017         //    For this case, skippedWallTime option specifies the behavior.
3018         //    For example, 2:30 am is interpreted as;
3019         //      - WALLTIME_LAST(default): 3:30 am (DST) (interpreting 2:30 am as 31 minutes after 1:59 am (STD))
3020         //      - WALLTIME_FIRST: 1:30 am (STD) (interpreting 2:30 am as 30 minutes before 3:00 am (DST))
3021         //      - WALLTIME_NEXT_VALID: 3:00 am (DST) (next valid time after 2:30 am on a wall clock)
3022         // 2. The negative offset change such as transition out of DST.
3023         //    Here, a designated time of 1:00 am - 1:59 am can be in standard or DST.  Both are valid
3024         //    representations (the rep jumps from 1:59:59 DST to 1:00:00 Std).
3025         //    For this case, repeatedWallTime option specifies the behavior.
3026         //    For example, 1:30 am is interpreted as;
3027         //      - WALLTIME_LAST(default): 1:30 am (STD) - latter occurrence
3028         //      - WALLTIME_FIRST: 1:30 am (DST) - former occurrence
3029         //
3030         // In addition to above, when calendar is strict (not default), wall time falls into
3031         // the skipped time range will be processed as an error case.
3032         //
3033         // These special cases are mostly handled in #computeZoneOffset(long), except WALLTIME_NEXT_VALID
3034         // at positive offset change. The protected method computeZoneOffset(long) is exposed to Calendar
3035         // subclass implementations and marked as @stable. Strictly speaking, WALLTIME_NEXT_VALID
3036         // should be also handled in the same place, but we cannot change the code flow without deprecating
3037         // the protected method.
3038         //
3039         // We use the TimeZone object, unless the user has explicitly set the ZONE_OFFSET
3040         // or DST_OFFSET fields; then we use those fields.
3041 
3042         if (!isLenient() || fSkippedWallTime == UCAL_WALLTIME_NEXT_VALID) {
3043             // When strict, invalidate a wall time falls into a skipped wall time range.
3044             // When lenient and skipped wall time option is WALLTIME_NEXT_VALID,
3045             // the result time will be adjusted to the next valid time (on wall clock).
3046             int32_t zoneOffset = computeZoneOffset(millis, millisInDay, status);
3047             UDate tmpTime = millis + millisInDay - zoneOffset;
3048 
3049             int32_t raw, dst;
3050             fZone-&gt;getOffset(tmpTime, FALSE, raw, dst, status);
3051 
3052             if (U_SUCCESS(status)) {
3053                 // zoneOffset != (raw + dst) only when the given wall time fall into
3054                 // a skipped wall time range caused by positive zone offset transition.
3055                 if (zoneOffset != (raw + dst)) {
3056                     if (!isLenient()) {
3057                         status = U_ILLEGAL_ARGUMENT_ERROR;
3058                     } else {
3059                         U_ASSERT(fSkippedWallTime == UCAL_WALLTIME_NEXT_VALID);
3060                         // Adjust time to the next valid wall clock time.
3061                         // At this point, tmpTime is on or after the zone offset transition causing
3062                         // the skipped time range.
3063                         UDate immediatePrevTransition;
3064                         UBool hasTransition = getImmediatePreviousZoneTransition(tmpTime, &amp;immediatePrevTransition, status);
3065                         if (U_SUCCESS(status) &amp;&amp; hasTransition) {
3066                             t = immediatePrevTransition;
3067                         }
3068                     }
3069                 } else {
3070                     t = tmpTime;
3071                 }
3072             }
3073         } else {
3074             t = millis + millisInDay - computeZoneOffset(millis, millisInDay, status);
3075         }
3076     }
3077     if (U_SUCCESS(status)) {
3078         internalSetTime(t);
3079     }
3080 }
3081 
3082 /**
3083  * Find the previous zone transtion near the given time.
3084  */
3085 UBool Calendar::getImmediatePreviousZoneTransition(UDate base, UDate *transitionTime, UErrorCode&amp; status) const {
3086     BasicTimeZone *btz = getBasicTimeZone();
3087     if (btz) {
3088         TimeZoneTransition trans;
3089         UBool hasTransition = btz-&gt;getPreviousTransition(base, TRUE, trans);
3090         if (hasTransition) {
3091             *transitionTime = trans.getTime();
3092             return TRUE;
3093         } else {
3094             // Could not find any transitions.
3095             // Note: This should never happen.
3096             status = U_INTERNAL_PROGRAM_ERROR;
3097         }
3098     } else {
3099         // If not BasicTimeZone, return unsupported error for now.
3100         // TODO: We may support non-BasicTimeZone in future.
3101         status = U_UNSUPPORTED_ERROR;
3102     }
3103     return FALSE;
3104 }
3105 
3106 /**
3107 * Compute the milliseconds in the day from the fields.  This is a
3108 * value from 0 to 23:59:59.999 inclusive, unless fields are out of
3109 * range, in which case it can be an arbitrary value.  This value
3110 * reflects local zone wall time.
3111 * @stable ICU 2.0
3112 */
3113 double Calendar::computeMillisInDay() {
3114   // Do the time portion of the conversion.
3115 
3116     double millisInDay = 0;
3117 
3118     // Find the best set of fields specifying the time of day.  There
3119     // are only two possibilities here; the HOUR_OF_DAY or the
3120     // AM_PM and the HOUR.
3121     int32_t hourOfDayStamp = fStamp[UCAL_HOUR_OF_DAY];
3122     int32_t hourStamp = (fStamp[UCAL_HOUR] &gt; fStamp[UCAL_AM_PM])?fStamp[UCAL_HOUR]:fStamp[UCAL_AM_PM];
3123     int32_t bestStamp = (hourStamp &gt; hourOfDayStamp) ? hourStamp : hourOfDayStamp;
3124 
3125     // Hours
3126     if (bestStamp != kUnset) {
3127         if (bestStamp == hourOfDayStamp) {
3128             // Don&#39;t normalize here; let overflow bump into the next period.
3129             // This is consistent with how we handle other fields.
3130             millisInDay += internalGet(UCAL_HOUR_OF_DAY);
3131         } else {
3132             // Don&#39;t normalize here; let overflow bump into the next period.
3133             // This is consistent with how we handle other fields.
3134             millisInDay += internalGet(UCAL_HOUR);
3135             millisInDay += 12 * internalGet(UCAL_AM_PM); // Default works for unset AM_PM
3136         }
3137     }
3138 
3139     // We use the fact that unset == 0; we start with millisInDay
3140     // == HOUR_OF_DAY.
3141     millisInDay *= 60;
3142     millisInDay += internalGet(UCAL_MINUTE); // now have minutes
3143     millisInDay *= 60;
3144     millisInDay += internalGet(UCAL_SECOND); // now have seconds
3145     millisInDay *= 1000;
3146     millisInDay += internalGet(UCAL_MILLISECOND); // now have millis
3147 
3148     return millisInDay;
3149 }
3150 
3151 /**
3152 * This method can assume EXTENDED_YEAR has been set.
3153 * @param millis milliseconds of the date fields
3154 * @param millisInDay milliseconds of the time fields; may be out
3155 * or range.
3156 * @stable ICU 2.0
3157 */
3158 int32_t Calendar::computeZoneOffset(double millis, double millisInDay, UErrorCode &amp;ec) {
3159     int32_t rawOffset, dstOffset;
3160     UDate wall = millis + millisInDay;
3161     BasicTimeZone* btz = getBasicTimeZone();
3162     if (btz) {
3163         int duplicatedTimeOpt = (fRepeatedWallTime == UCAL_WALLTIME_FIRST) ? BasicTimeZone::kFormer : BasicTimeZone::kLatter;
3164         int nonExistingTimeOpt = (fSkippedWallTime == UCAL_WALLTIME_FIRST) ? BasicTimeZone::kLatter : BasicTimeZone::kFormer;
3165         btz-&gt;getOffsetFromLocal(wall, nonExistingTimeOpt, duplicatedTimeOpt, rawOffset, dstOffset, ec);
3166     } else {
3167         const TimeZone&amp; tz = getTimeZone();
3168         // By default, TimeZone::getOffset behaves UCAL_WALLTIME_LAST for both.
3169         tz.getOffset(wall, TRUE, rawOffset, dstOffset, ec);
3170 
3171         UBool sawRecentNegativeShift = FALSE;
3172         if (fRepeatedWallTime == UCAL_WALLTIME_FIRST) {
3173             // Check if the given wall time falls into repeated time range
3174             UDate tgmt = wall - (rawOffset + dstOffset);
3175 
3176             // Any negative zone transition within last 6 hours?
3177             // Note: The maximum historic negative zone transition is -3 hours in the tz database.
3178             // 6 hour window would be sufficient for this purpose.
3179             int32_t tmpRaw, tmpDst;
3180             tz.getOffset(tgmt - 6*60*60*1000, FALSE, tmpRaw, tmpDst, ec);
3181             int32_t offsetDelta = (rawOffset + dstOffset) - (tmpRaw + tmpDst);
3182 
3183             U_ASSERT(offsetDelta &lt; -6*60*60*1000);
3184             if (offsetDelta &lt; 0) {
3185                 sawRecentNegativeShift = TRUE;
3186                 // Negative shift within last 6 hours. When UCAL_WALLTIME_FIRST is used and the given wall time falls
3187                 // into the repeated time range, use offsets before the transition.
3188                 // Note: If it does not fall into the repeated time range, offsets remain unchanged below.
3189                 tz.getOffset(wall + offsetDelta, TRUE, rawOffset, dstOffset, ec);
3190             }
3191         }
3192         if (!sawRecentNegativeShift &amp;&amp; fSkippedWallTime == UCAL_WALLTIME_FIRST) {
3193             // When skipped wall time option is WALLTIME_FIRST,
3194             // recalculate offsets from the resolved time (non-wall).
3195             // When the given wall time falls into skipped wall time,
3196             // the offsets will be based on the zone offsets AFTER
3197             // the transition (which means, earliest possibe interpretation).
3198             UDate tgmt = wall - (rawOffset + dstOffset);
3199             tz.getOffset(tgmt, FALSE, rawOffset, dstOffset, ec);
3200         }
3201     }
3202     return rawOffset + dstOffset;
3203 }
3204 
3205 int32_t Calendar::computeJulianDay()
3206 {
3207     // We want to see if any of the date fields is newer than the
3208     // JULIAN_DAY.  If not, then we use JULIAN_DAY.  If so, then we do
3209     // the normal resolution.  We only use JULIAN_DAY if it has been
3210     // set by the user.  This makes it possible for the caller to set
3211     // the calendar to a time and call clear(MONTH) to reset the MONTH
3212     // to January.  This is legacy behavior.  Without this,
3213     // clear(MONTH) has no effect, since the internally set JULIAN_DAY
3214     // is used.
3215     if (fStamp[UCAL_JULIAN_DAY] &gt;= (int32_t)kMinimumUserStamp) {
3216         int32_t bestStamp = newestStamp(UCAL_ERA, UCAL_DAY_OF_WEEK_IN_MONTH, kUnset);
3217         bestStamp = newestStamp(UCAL_YEAR_WOY, UCAL_EXTENDED_YEAR, bestStamp);
3218         if (bestStamp &lt;= fStamp[UCAL_JULIAN_DAY]) {
3219             return internalGet(UCAL_JULIAN_DAY);
3220         }
3221     }
3222 
3223     UCalendarDateFields bestField = resolveFields(getFieldResolutionTable());
3224     if (bestField == UCAL_FIELD_COUNT) {
3225         bestField = UCAL_DAY_OF_MONTH;
3226     }
3227 
3228     return handleComputeJulianDay(bestField);
3229 }
3230 
3231 // -------------------------------------------
3232 
3233 int32_t Calendar::handleComputeJulianDay(UCalendarDateFields bestField)  {
3234     UBool useMonth = (bestField == UCAL_DAY_OF_MONTH ||
3235         bestField == UCAL_WEEK_OF_MONTH ||
3236         bestField == UCAL_DAY_OF_WEEK_IN_MONTH);
3237     int32_t year;
3238 
3239     if (bestField == UCAL_WEEK_OF_YEAR &amp;&amp; newerField(UCAL_YEAR_WOY, UCAL_YEAR) == UCAL_YEAR_WOY) {
3240         year = internalGet(UCAL_YEAR_WOY);
3241     } else {
3242         year = handleGetExtendedYear();
3243     }
3244 
3245     internalSet(UCAL_EXTENDED_YEAR, year);
3246 
3247 #if defined (U_DEBUG_CAL)
3248     fprintf(stderr, &quot;%s:%d: bestField= %s - y=%d\n&quot;, __FILE__, __LINE__, fldName(bestField), year);
3249 #endif
3250 
3251     // Get the Julian day of the day BEFORE the start of this year.
3252     // If useMonth is true, get the day before the start of the month.
3253 
3254     // give calendar subclass a chance to have a default &#39;first&#39; month
3255     int32_t month;
3256 
3257     if(isSet(UCAL_MONTH)) {
3258         month = internalGet(UCAL_MONTH);
3259     } else {
3260         month = getDefaultMonthInYear(year);
3261     }
3262 
3263     int32_t julianDay = handleComputeMonthStart(year, useMonth ? month : 0, useMonth);
3264 
3265     if (bestField == UCAL_DAY_OF_MONTH) {
3266 
3267         // give calendar subclass a chance to have a default &#39;first&#39; dom
3268         int32_t dayOfMonth;
3269         if(isSet(UCAL_DAY_OF_MONTH)) {
3270             dayOfMonth = internalGet(UCAL_DAY_OF_MONTH,1);
3271         } else {
3272             dayOfMonth = getDefaultDayInMonth(year, month);
3273         }
3274         return julianDay + dayOfMonth;
3275     }
3276 
3277     if (bestField == UCAL_DAY_OF_YEAR) {
3278         return julianDay + internalGet(UCAL_DAY_OF_YEAR);
3279     }
3280 
3281     int32_t firstDayOfWeek = getFirstDayOfWeek(); // Localized fdw
3282 
3283     // At this point julianDay is the 0-based day BEFORE the first day of
3284     // January 1, year 1 of the given calendar.  If julianDay == 0, it
3285     // specifies (Jan. 1, 1) - 1, in whatever calendar we are using (Julian
3286     // or Gregorian). (or it is before the month we are in, if useMonth is True)
3287 
3288     // At this point we need to process the WEEK_OF_MONTH or
3289     // WEEK_OF_YEAR, which are similar, or the DAY_OF_WEEK_IN_MONTH.
3290     // First, perform initial shared computations.  These locate the
3291     // first week of the period.
3292 
3293     // Get the 0-based localized DOW of day one of the month or year.
3294     // Valid range 0..6.
3295     int32_t first = julianDayToDayOfWeek(julianDay + 1) - firstDayOfWeek;
3296     if (first &lt; 0) {
3297         first += 7;
3298     }
3299 
3300     int32_t dowLocal = getLocalDOW();
3301 
3302     // Find the first target DOW (dowLocal) in the month or year.
3303     // Actually, it may be just before the first of the month or year.
3304     // It will be an integer from -5..7.
3305     int32_t date = 1 - first + dowLocal;
3306 
3307     if (bestField == UCAL_DAY_OF_WEEK_IN_MONTH) {
3308         // Adjust the target DOW to be in the month or year.
3309         if (date &lt; 1) {
3310             date += 7;
3311         }
3312 
3313         // The only trickiness occurs if the day-of-week-in-month is
3314         // negative.
3315         int32_t dim = internalGet(UCAL_DAY_OF_WEEK_IN_MONTH, 1);
3316         if (dim &gt;= 0) {
3317             date += 7*(dim - 1);
3318 
3319         } else {
3320             // Move date to the last of this day-of-week in this month,
3321             // then back up as needed.  If dim==-1, we don&#39;t back up at
3322             // all.  If dim==-2, we back up once, etc.  Don&#39;t back up
3323             // past the first of the given day-of-week in this month.
3324             // Note that we handle -2, -3, etc. correctly, even though
3325             // values &lt; -1 are technically disallowed.
3326             int32_t m = internalGet(UCAL_MONTH, UCAL_JANUARY);
3327             int32_t monthLength = handleGetMonthLength(year, m);
3328             date += ((monthLength - date) / 7 + dim + 1) * 7;
3329         }
3330     } else {
3331 #if defined (U_DEBUG_CAL)
3332         fprintf(stderr, &quot;%s:%d - bf= %s\n&quot;, __FILE__, __LINE__, fldName(bestField));
3333 #endif
3334 
3335         if(bestField == UCAL_WEEK_OF_YEAR) {  // ------------------------------------- WOY -------------
3336             if(!isSet(UCAL_YEAR_WOY) ||  // YWOY not set at all or
3337                 ( (resolveFields(kYearPrecedence) != UCAL_YEAR_WOY) // YWOY doesn&#39;t have precedence
3338                 &amp;&amp; (fStamp[UCAL_YEAR_WOY]!=kInternallySet) ) ) // (excluding where all fields are internally set - then YWOY is used)
3339             {
3340                 // need to be sure to stay in &#39;real&#39; year.
3341                 int32_t woy = internalGet(bestField);
3342 
3343                 int32_t nextJulianDay = handleComputeMonthStart(year+1, 0, FALSE); // jd of day before jan 1
3344                 int32_t nextFirst = julianDayToDayOfWeek(nextJulianDay + 1) - firstDayOfWeek;
3345 
3346                 if (nextFirst &lt; 0) { // 0..6 ldow of Jan 1
3347                     nextFirst += 7;
3348                 }
3349 
3350                 if(woy==1) {  // FIRST WEEK ---------------------------------
3351 #if defined (U_DEBUG_CAL)
3352                     fprintf(stderr, &quot;%s:%d - woy=%d, yp=%d, nj(%d)=%d, nf=%d&quot;, __FILE__, __LINE__,
3353                         internalGet(bestField), resolveFields(kYearPrecedence), year+1,
3354                         nextJulianDay, nextFirst);
3355 
3356                     fprintf(stderr, &quot; next: %d DFW,  min=%d   \n&quot;, (7-nextFirst), getMinimalDaysInFirstWeek() );
3357 #endif
3358 
3359                     // nextFirst is now the localized DOW of Jan 1  of y-woy+1
3360                     if((nextFirst &gt; 0) &amp;&amp;   // Jan 1 starts on FDOW
3361                         (7-nextFirst) &gt;= getMinimalDaysInFirstWeek()) // or enough days in the week
3362                     {
3363                         // Jan 1 of (yearWoy+1) is in yearWoy+1 - recalculate JD to next year
3364 #if defined (U_DEBUG_CAL)
3365                         fprintf(stderr, &quot;%s:%d - was going to move JD from %d to %d [d%d]\n&quot;, __FILE__, __LINE__,
3366                             julianDay, nextJulianDay, (nextJulianDay-julianDay));
3367 #endif
3368                         julianDay = nextJulianDay;
3369 
3370                         // recalculate &#39;first&#39; [0-based local dow of jan 1]
3371                         first = julianDayToDayOfWeek(julianDay + 1) - firstDayOfWeek;
3372                         if (first &lt; 0) {
3373                             first += 7;
3374                         }
3375                         // recalculate date.
3376                         date = 1 - first + dowLocal;
3377                     }
3378                 } else if(woy&gt;=getLeastMaximum(bestField)) {
3379                     // could be in the last week- find out if this JD would overstep
3380                     int32_t testDate = date;
3381                     if ((7 - first) &lt; getMinimalDaysInFirstWeek()) {
3382                         testDate += 7;
3383                     }
3384 
3385                     // Now adjust for the week number.
3386                     testDate += 7 * (woy - 1);
3387 
3388 #if defined (U_DEBUG_CAL)
3389                     fprintf(stderr, &quot;%s:%d - y=%d, y-1=%d doy%d, njd%d (C.F. %d)\n&quot;,
3390                         __FILE__, __LINE__, year, year-1, testDate, julianDay+testDate, nextJulianDay);
3391 #endif
3392                     if(julianDay+testDate &gt; nextJulianDay) { // is it past Dec 31?  (nextJulianDay is day BEFORE year+1&#39;s  Jan 1)
3393                         // Fire up the calculating engines.. retry YWOY = (year-1)
3394                         julianDay = handleComputeMonthStart(year-1, 0, FALSE); // jd before Jan 1 of previous year
3395                         first = julianDayToDayOfWeek(julianDay + 1) - firstDayOfWeek; // 0 based local dow   of first week
3396 
3397                         if(first &lt; 0) { // 0..6
3398                             first += 7;
3399                         }
3400                         date = 1 - first + dowLocal;
3401 
3402 #if defined (U_DEBUG_CAL)
3403                         fprintf(stderr, &quot;%s:%d - date now %d, jd%d, ywoy%d\n&quot;,
3404                             __FILE__, __LINE__, date, julianDay, year-1);
3405 #endif
3406 
3407 
3408                     } /* correction needed */
3409                 } /* leastmaximum */
3410             } /* resolvefields(year) != year_woy */
3411         } /* bestfield != week_of_year */
3412 
3413         // assert(bestField == WEEK_OF_MONTH || bestField == WEEK_OF_YEAR)
3414         // Adjust for minimal days in first week
3415         if ((7 - first) &lt; getMinimalDaysInFirstWeek()) {
3416             date += 7;
3417         }
3418 
3419         // Now adjust for the week number.
3420         date += 7 * (internalGet(bestField) - 1);
3421     }
3422 
3423     return julianDay + date;
3424 }
3425 
3426 int32_t
3427 Calendar::getDefaultMonthInYear(int32_t /*eyear*/)
3428 {
3429     return 0;
3430 }
3431 
3432 int32_t
3433 Calendar::getDefaultDayInMonth(int32_t /*eyear*/, int32_t /*month*/)
3434 {
3435     return 1;
3436 }
3437 
3438 
3439 int32_t Calendar::getLocalDOW()
3440 {
3441   // Get zero-based localized DOW, valid range 0..6.  This is the DOW
3442     // we are looking for.
3443     int32_t dowLocal = 0;
3444     switch (resolveFields(kDOWPrecedence)) {
3445     case UCAL_DAY_OF_WEEK:
3446         dowLocal = internalGet(UCAL_DAY_OF_WEEK) - fFirstDayOfWeek;
3447         break;
3448     case UCAL_DOW_LOCAL:
3449         dowLocal = internalGet(UCAL_DOW_LOCAL) - 1;
3450         break;
3451     default:
3452         break;
3453     }
3454     dowLocal = dowLocal % 7;
3455     if (dowLocal &lt; 0) {
3456         dowLocal += 7;
3457     }
3458     return dowLocal;
3459 }
3460 
3461 int32_t Calendar::handleGetExtendedYearFromWeekFields(int32_t yearWoy, int32_t woy)
3462 {
3463     // We have UCAL_YEAR_WOY and UCAL_WEEK_OF_YEAR - from those, determine
3464     // what year we fall in, so that other code can set it properly.
3465     // (code borrowed from computeWeekFields and handleComputeJulianDay)
3466     //return yearWoy;
3467 
3468     // First, we need a reliable DOW.
3469     UCalendarDateFields bestField = resolveFields(kDatePrecedence); // !! Note: if subclasses have a different table, they should override handleGetExtendedYearFromWeekFields
3470 
3471     // Now, a local DOW
3472     int32_t dowLocal = getLocalDOW(); // 0..6
3473     int32_t firstDayOfWeek = getFirstDayOfWeek(); // Localized fdw
3474     int32_t jan1Start = handleComputeMonthStart(yearWoy, 0, FALSE);
3475     int32_t nextJan1Start = handleComputeMonthStart(yearWoy+1, 0, FALSE); // next year&#39;s Jan1 start
3476 
3477     // At this point julianDay is the 0-based day BEFORE the first day of
3478     // January 1, year 1 of the given calendar.  If julianDay == 0, it
3479     // specifies (Jan. 1, 1) - 1, in whatever calendar we are using (Julian
3480     // or Gregorian). (or it is before the month we are in, if useMonth is True)
3481 
3482     // At this point we need to process the WEEK_OF_MONTH or
3483     // WEEK_OF_YEAR, which are similar, or the DAY_OF_WEEK_IN_MONTH.
3484     // First, perform initial shared computations.  These locate the
3485     // first week of the period.
3486 
3487     // Get the 0-based localized DOW of day one of the month or year.
3488     // Valid range 0..6.
3489     int32_t first = julianDayToDayOfWeek(jan1Start + 1) - firstDayOfWeek;
3490     if (first &lt; 0) {
3491         first += 7;
3492     }
3493 
3494     //// (nextFirst was not used below)
3495     // int32_t nextFirst = julianDayToDayOfWeek(nextJan1Start + 1) - firstDayOfWeek;
3496     // if (nextFirst &lt; 0) {
3497     //     nextFirst += 7;
3498     //}
3499 
3500     int32_t minDays = getMinimalDaysInFirstWeek();
3501     UBool jan1InPrevYear = FALSE;  // January 1st in the year of WOY is the 1st week?  (i.e. first week is &lt; minimal )
3502     //UBool nextJan1InPrevYear = FALSE; // January 1st of Year of WOY + 1 is in the first week?
3503 
3504     if((7 - first) &lt; minDays) {
3505         jan1InPrevYear = TRUE;
3506     }
3507 
3508     //   if((7 - nextFirst) &lt; minDays) {
3509     //     nextJan1InPrevYear = TRUE;
3510     //   }
3511 
3512     switch(bestField) {
3513     case UCAL_WEEK_OF_YEAR:
3514         if(woy == 1) {
3515             if(jan1InPrevYear == TRUE) {
3516                 // the first week of January is in the previous year
3517                 // therefore WOY1 is always solidly within yearWoy
3518                 return yearWoy;
3519             } else {
3520                 // First WOY is split between two years
3521                 if( dowLocal &lt; first) { // we are prior to Jan 1
3522                     return yearWoy-1; // previous year
3523                 } else {
3524                     return yearWoy; // in this year
3525                 }
3526             }
3527         } else if(woy &gt;= getLeastMaximum(bestField)) {
3528             // we _might_ be in the last week..
3529             int32_t jd =  // Calculate JD of our target day:
3530                 jan1Start +  // JD of Jan 1
3531                 (7-first) + //  days in the first week (Jan 1.. )
3532                 (woy-1)*7 + // add the weeks of the year
3533                 dowLocal;   // the local dow (0..6) of last week
3534             if(jan1InPrevYear==FALSE) {
3535                 jd -= 7; // woy already includes Jan 1&#39;s week.
3536             }
3537 
3538             if( (jd+1) &gt;= nextJan1Start ) {
3539                 // we are in week 52 or 53 etc. - actual year is yearWoy+1
3540                 return yearWoy+1;
3541             } else {
3542                 // still in yearWoy;
3543                 return yearWoy;
3544             }
3545         } else {
3546             // we&#39;re not possibly in the last week -must be ywoy
3547             return yearWoy;
3548         }
3549 
3550     case UCAL_DATE:
3551         if((internalGet(UCAL_MONTH)==0) &amp;&amp;
3552             (woy &gt;= getLeastMaximum(UCAL_WEEK_OF_YEAR))) {
3553                 return yearWoy+1; // month 0, late woy = in the next year
3554             } else if(woy==1) {
3555                 //if(nextJan1InPrevYear) {
3556                 if(internalGet(UCAL_MONTH)==0) {
3557                     return yearWoy;
3558                 } else {
3559                     return yearWoy-1;
3560                 }
3561                 //}
3562             }
3563 
3564             //(internalGet(UCAL_DATE) &lt;= (7-first)) /* &amp;&amp; in minDow  */ ) {
3565             //within 1st week and in this month..
3566             //return yearWoy+1;
3567             return yearWoy;
3568 
3569     default: // assume the year is appropriate
3570         return yearWoy;
3571     }
3572 }
3573 
3574 int32_t Calendar::handleGetMonthLength(int32_t extendedYear, int32_t month) const
3575 {
3576     return handleComputeMonthStart(extendedYear, month+1, TRUE) -
3577         handleComputeMonthStart(extendedYear, month, TRUE);
3578 }
3579 
3580 int32_t Calendar::handleGetYearLength(int32_t eyear) const  {
3581     return handleComputeMonthStart(eyear+1, 0, FALSE) -
3582         handleComputeMonthStart(eyear, 0, FALSE);
3583 }
3584 
3585 int32_t
3586 Calendar::getActualMaximum(UCalendarDateFields field, UErrorCode&amp; status) const
3587 {
3588     int32_t result;
3589     switch (field) {
3590     case UCAL_DATE:
3591         {
3592             if(U_FAILURE(status)) return 0;
3593             Calendar *cal = clone();
3594             if(!cal) { status = U_MEMORY_ALLOCATION_ERROR; return 0; }
3595             cal-&gt;setLenient(TRUE);
3596             cal-&gt;prepareGetActual(field,FALSE,status);
3597             result = handleGetMonthLength(cal-&gt;get(UCAL_EXTENDED_YEAR, status), cal-&gt;get(UCAL_MONTH, status));
3598             delete cal;
3599         }
3600         break;
3601 
3602     case UCAL_DAY_OF_YEAR:
3603         {
3604             if(U_FAILURE(status)) return 0;
3605             Calendar *cal = clone();
3606             if(!cal) { status = U_MEMORY_ALLOCATION_ERROR; return 0; }
3607             cal-&gt;setLenient(TRUE);
3608             cal-&gt;prepareGetActual(field,FALSE,status);
3609             result = handleGetYearLength(cal-&gt;get(UCAL_EXTENDED_YEAR, status));
3610             delete cal;
3611         }
3612         break;
3613 
3614     case UCAL_DAY_OF_WEEK:
3615     case UCAL_AM_PM:
3616     case UCAL_HOUR:
3617     case UCAL_HOUR_OF_DAY:
3618     case UCAL_MINUTE:
3619     case UCAL_SECOND:
3620     case UCAL_MILLISECOND:
3621     case UCAL_ZONE_OFFSET:
3622     case UCAL_DST_OFFSET:
3623     case UCAL_DOW_LOCAL:
3624     case UCAL_JULIAN_DAY:
3625     case UCAL_MILLISECONDS_IN_DAY:
3626         // These fields all have fixed minima/maxima
3627         result = getMaximum(field);
3628         break;
3629 
3630     default:
3631         // For all other fields, do it the hard way....
3632         result = getActualHelper(field, getLeastMaximum(field), getMaximum(field),status);
3633         break;
3634     }
3635     return result;
3636 }
3637 
3638 
3639 /**
3640 * Prepare this calendar for computing the actual minimum or maximum.
3641 * This method modifies this calendar&#39;s fields; it is called on a
3642 * temporary calendar.
3643 *
3644 * &lt;p&gt;Rationale: The semantics of getActualXxx() is to return the
3645 * maximum or minimum value that the given field can take, taking into
3646 * account other relevant fields.  In general these other fields are
3647 * larger fields.  For example, when computing the actual maximum
3648 * DATE, the current value of DATE itself is ignored,
3649 * as is the value of any field smaller.
3650 *
3651 * &lt;p&gt;The time fields all have fixed minima and maxima, so we don&#39;t
3652 * need to worry about them.  This also lets us set the
3653 * MILLISECONDS_IN_DAY to zero to erase any effects the time fields
3654 * might have when computing date fields.
3655 *
3656 * &lt;p&gt;DAY_OF_WEEK is adjusted specially for the WEEK_OF_MONTH and
3657 * WEEK_OF_YEAR fields to ensure that they are computed correctly.
3658 * @internal
3659 */
3660 void Calendar::prepareGetActual(UCalendarDateFields field, UBool isMinimum, UErrorCode &amp;status)
3661 {
3662     set(UCAL_MILLISECONDS_IN_DAY, 0);
3663 
3664     switch (field) {
3665     case UCAL_YEAR:
3666     case UCAL_EXTENDED_YEAR:
3667         set(UCAL_DAY_OF_YEAR, getGreatestMinimum(UCAL_DAY_OF_YEAR));
3668         break;
3669 
3670     case UCAL_YEAR_WOY:
3671         set(UCAL_WEEK_OF_YEAR, getGreatestMinimum(UCAL_WEEK_OF_YEAR));
3672         U_FALLTHROUGH;
3673     case UCAL_MONTH:
3674         set(UCAL_DATE, getGreatestMinimum(UCAL_DATE));
3675         break;
3676 
3677     case UCAL_DAY_OF_WEEK_IN_MONTH:
3678         // For dowim, the maximum occurs for the DOW of the first of the
3679         // month.
3680         set(UCAL_DATE, 1);
3681         set(UCAL_DAY_OF_WEEK, get(UCAL_DAY_OF_WEEK, status)); // Make this user set
3682         break;
3683 
3684     case UCAL_WEEK_OF_MONTH:
3685     case UCAL_WEEK_OF_YEAR:
3686         // If we&#39;re counting weeks, set the day of the week to either the
3687         // first or last localized DOW.  We know the last week of a month
3688         // or year will contain the first day of the week, and that the
3689         // first week will contain the last DOW.
3690         {
3691             int32_t dow = fFirstDayOfWeek;
3692             if (isMinimum) {
3693                 dow = (dow + 6) % 7; // set to last DOW
3694                 if (dow &lt; UCAL_SUNDAY) {
3695                     dow += 7;
3696                 }
3697             }
3698 #if defined (U_DEBUG_CAL)
3699             fprintf(stderr, &quot;prepareGetActualHelper(WOM/WOY) - dow=%d\n&quot;, dow);
3700 #endif
3701             set(UCAL_DAY_OF_WEEK, dow);
3702         }
3703         break;
3704     default:
3705         break;
3706     }
3707 
3708     // Do this last to give it the newest time stamp
3709     set(field, getGreatestMinimum(field));
3710 }
3711 
3712 int32_t Calendar::getActualHelper(UCalendarDateFields field, int32_t startValue, int32_t endValue, UErrorCode &amp;status) const
3713 {
3714 #if defined (U_DEBUG_CAL)
3715     fprintf(stderr, &quot;getActualHelper(%d,%d .. %d, %s)\n&quot;, field, startValue, endValue, u_errorName(status));
3716 #endif
3717     if (startValue == endValue) {
3718         // if we know that the maximum value is always the same, just return it
3719         return startValue;
3720     }
3721 
3722     int32_t delta = (endValue &gt; startValue) ? 1 : -1;
3723 
3724     // clone the calendar so we don&#39;t mess with the real one, and set it to
3725     // accept anything for the field values
3726     if(U_FAILURE(status)) return startValue;
3727     Calendar *work = clone();
3728     if(!work) { status = U_MEMORY_ALLOCATION_ERROR; return startValue; }
3729 
3730     // need to resolve time here, otherwise, fields set for actual limit
3731     // may cause conflict with fields previously set (but not yet resolved).
3732     work-&gt;complete(status);
3733 
3734     work-&gt;setLenient(TRUE);
3735     work-&gt;prepareGetActual(field, delta &lt; 0, status);
3736 
3737     // now try each value from the start to the end one by one until
3738     // we get a value that normalizes to another value.  The last value that
3739     // normalizes to itself is the actual maximum for the current date
3740     work-&gt;set(field, startValue);
3741 
3742     // prepareGetActual sets the first day of week in the same week with
3743     // the first day of a month.  Unlike WEEK_OF_YEAR, week number for the
3744     // week which contains days from both previous and current month is
3745     // not unique.  For example, last several days in the previous month
3746     // is week 5, and the rest of week is week 1.
3747     int32_t result = startValue;
3748     if ((work-&gt;get(field, status) != startValue
3749          &amp;&amp; field != UCAL_WEEK_OF_MONTH &amp;&amp; delta &gt; 0 ) || U_FAILURE(status)) {
3750 #if defined (U_DEBUG_CAL)
3751         fprintf(stderr, &quot;getActualHelper(fld %d) - got  %d (not %d) - %s\n&quot;, field, work-&gt;get(field,status), startValue, u_errorName(status));
3752 #endif
3753     } else {
3754         do {
3755             startValue += delta;
3756             work-&gt;add(field, delta, status);
3757             if (work-&gt;get(field, status) != startValue || U_FAILURE(status)) {
3758 #if defined (U_DEBUG_CAL)
3759                 fprintf(stderr, &quot;getActualHelper(fld %d) - got  %d (not %d), BREAK - %s\n&quot;, field, work-&gt;get(field,status), startValue, u_errorName(status));
3760 #endif
3761                 break;
3762             }
3763             result = startValue;
3764         } while (startValue != endValue);
3765     }
3766     delete work;
3767 #if defined (U_DEBUG_CAL)
3768     fprintf(stderr, &quot;getActualHelper(%d) = %d\n&quot;, field, result);
3769 #endif
3770     return result;
3771 }
3772 
3773 
3774 
3775 
3776 // -------------------------------------
3777 
3778 void
3779 Calendar::setWeekData(const Locale&amp; desiredLocale, const char *type, UErrorCode&amp; status)
3780 {
3781 
3782     if (U_FAILURE(status)) return;
3783 
3784     fFirstDayOfWeek = UCAL_SUNDAY;
3785     fMinimalDaysInFirstWeek = 1;
3786     fWeekendOnset = UCAL_SATURDAY;
3787     fWeekendOnsetMillis = 0;
3788     fWeekendCease = UCAL_SUNDAY;
3789     fWeekendCeaseMillis = 86400000; // 24*60*60*1000
3790 
3791     // Since week and weekend data is territory based instead of language based,
3792     // we may need to tweak the locale that we are using to try to get the appropriate
3793     // values, using the following logic:
3794     // 1). If the locale has a language but no territory, use the territory as defined by
3795     //     the likely subtags.
3796     // 2). If the locale has a script designation then we ignore it,
3797     //     then remove it ( i.e. &quot;en_Latn_US&quot; becomes &quot;en_US&quot; )
3798 
<a name="22" id="anc22"></a>
3799     UErrorCode myStatus = U_ZERO_ERROR;
3800 
<a name="23" id="anc23"></a><span class="line-modified">3801     Locale min(desiredLocale);</span>
<span class="line-modified">3802     min.minimizeSubtags(myStatus);</span>
3803     Locale useLocale;
3804     if ( uprv_strlen(desiredLocale.getCountry()) == 0 ||
3805          (uprv_strlen(desiredLocale.getScript()) &gt; 0 &amp;&amp; uprv_strlen(min.getScript()) == 0) ) {
<a name="24" id="anc24"></a>
3806         myStatus = U_ZERO_ERROR;
<a name="25" id="anc25"></a><span class="line-modified">3807         Locale max(desiredLocale);</span>
<span class="line-modified">3808         max.addLikelySubtags(myStatus);</span>
3809         useLocale = Locale(max.getLanguage(),max.getCountry());
3810     } else {
<a name="26" id="anc26"></a><span class="line-modified">3811         useLocale = desiredLocale;</span>
3812     }
3813 
3814     /* The code here is somewhat of a hack, since week data and weekend data aren&#39;t really tied to
3815        a specific calendar, they aren&#39;t truly locale data.  But this is the only place where valid and
3816        actual locale can be set, so we take a shot at it here by loading a representative resource
3817        from the calendar data.  The code used to use the dateTimeElements resource to get first day
3818        of week data, but this was moved to supplemental data under ticket 7755. (JCE) */
3819 
3820     // Get the monthNames resource bundle for the calendar &#39;type&#39;. Fallback to gregorian if the resource is not
3821     // found.
3822     LocalUResourceBundlePointer calData(ures_open(NULL, useLocale.getBaseName(), &amp;status));
3823     ures_getByKey(calData.getAlias(), gCalendar, calData.getAlias(), &amp;status);
3824 
3825     LocalUResourceBundlePointer monthNames;
3826     if (type != NULL &amp;&amp; *type != &#39;\0&#39; &amp;&amp; uprv_strcmp(type, gGregorian) != 0) {
3827         monthNames.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), type, NULL, &amp;status));
3828         ures_getByKeyWithFallback(monthNames.getAlias(), gMonthNames,
3829                                   monthNames.getAlias(), &amp;status);
3830     }
3831 
3832     if (monthNames.isNull() || status == U_MISSING_RESOURCE_ERROR) {
3833         status = U_ZERO_ERROR;
3834         monthNames.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), gGregorian,
3835                                                           monthNames.orphan(), &amp;status));
3836         ures_getByKeyWithFallback(monthNames.getAlias(), gMonthNames,
3837                                   monthNames.getAlias(), &amp;status);
3838     }
3839 
3840     if (U_SUCCESS(status)) {
3841         U_LOCALE_BASED(locBased,*this);
3842         locBased.setLocaleIDs(ures_getLocaleByType(monthNames.getAlias(), ULOC_VALID_LOCALE, &amp;status),
3843                               ures_getLocaleByType(monthNames.getAlias(), ULOC_ACTUAL_LOCALE, &amp;status));
3844     } else {
3845         status = U_USING_FALLBACK_WARNING;
3846         return;
3847     }
3848 
3849     char region[ULOC_COUNTRY_CAPACITY];
3850     (void)ulocimp_getRegionForSupplementalData(desiredLocale.getName(), TRUE, region, sizeof(region), &amp;status);
3851 
3852     // Read week data values from supplementalData week data
3853     UResourceBundle *rb = ures_openDirect(NULL, &quot;supplementalData&quot;, &amp;status);
3854     ures_getByKey(rb, &quot;weekData&quot;, rb, &amp;status);
3855     UResourceBundle *weekData = ures_getByKey(rb, region, NULL, &amp;status);
3856     if (status == U_MISSING_RESOURCE_ERROR &amp;&amp; rb != NULL) {
3857         status = U_ZERO_ERROR;
3858         weekData = ures_getByKey(rb, &quot;001&quot;, NULL, &amp;status);
3859     }
3860 
3861     if (U_FAILURE(status)) {
3862         status = U_USING_FALLBACK_WARNING;
3863     } else {
3864         int32_t arrLen;
3865         const int32_t *weekDataArr = ures_getIntVector(weekData,&amp;arrLen,&amp;status);
3866         if( U_SUCCESS(status) &amp;&amp; arrLen == 6
3867                 &amp;&amp; 1 &lt;= weekDataArr[0] &amp;&amp; weekDataArr[0] &lt;= 7
3868                 &amp;&amp; 1 &lt;= weekDataArr[1] &amp;&amp; weekDataArr[1] &lt;= 7
3869                 &amp;&amp; 1 &lt;= weekDataArr[2] &amp;&amp; weekDataArr[2] &lt;= 7
3870                 &amp;&amp; 1 &lt;= weekDataArr[4] &amp;&amp; weekDataArr[4] &lt;= 7) {
3871             fFirstDayOfWeek = (UCalendarDaysOfWeek)weekDataArr[0];
3872             fMinimalDaysInFirstWeek = (uint8_t)weekDataArr[1];
3873             fWeekendOnset = (UCalendarDaysOfWeek)weekDataArr[2];
3874             fWeekendOnsetMillis = weekDataArr[3];
3875             fWeekendCease = (UCalendarDaysOfWeek)weekDataArr[4];
3876             fWeekendCeaseMillis = weekDataArr[5];
3877         } else {
3878             status = U_INVALID_FORMAT_ERROR;
3879         }
3880     }
3881     ures_close(weekData);
3882     ures_close(rb);
3883 }
3884 
3885 /**
3886 * Recompute the time and update the status fields isTimeSet
3887 * and areFieldsSet.  Callers should check isTimeSet and only
3888 * call this method if isTimeSet is false.
3889 */
3890 void
3891 Calendar::updateTime(UErrorCode&amp; status)
3892 {
3893     computeTime(status);
3894     if(U_FAILURE(status))
3895         return;
3896 
3897     // If we are lenient, we need to recompute the fields to normalize
3898     // the values.  Also, if we haven&#39;t set all the fields yet (i.e.,
3899     // in a newly-created object), we need to fill in the fields. [LIU]
3900     if (isLenient() || ! fAreAllFieldsSet)
3901         fAreFieldsSet = FALSE;
3902 
3903     fIsTimeSet = TRUE;
3904     fAreFieldsVirtuallySet = FALSE;
3905 }
3906 
3907 Locale
3908 Calendar::getLocale(ULocDataLocaleType type, UErrorCode&amp; status) const {
3909     U_LOCALE_BASED(locBased, *this);
3910     return locBased.getLocale(type, status);
3911 }
3912 
3913 const char *
3914 Calendar::getLocaleID(ULocDataLocaleType type, UErrorCode&amp; status) const {
3915     U_LOCALE_BASED(locBased, *this);
3916     return locBased.getLocaleID(type, status);
3917 }
3918 
3919 void
3920 Calendar::recalculateStamp() {
3921     int32_t index;
3922     int32_t currentValue;
3923     int32_t j, i;
3924 
3925     fNextStamp = 1;
3926 
3927     for (j = 0; j &lt; UCAL_FIELD_COUNT; j++) {
3928         currentValue = STAMP_MAX;
3929         index = -1;
3930         for (i = 0; i &lt; UCAL_FIELD_COUNT; i++) {
3931             if (fStamp[i] &gt; fNextStamp &amp;&amp; fStamp[i] &lt; currentValue) {
3932                 currentValue = fStamp[i];
3933                 index = i;
3934             }
3935         }
3936 
3937         if (index &gt;= 0) {
3938             fStamp[index] = ++fNextStamp;
3939         } else {
3940             break;
3941         }
3942     }
3943     fNextStamp++;
3944 }
3945 
3946 // Deprecated function. This doesn&#39;t need to be inline.
3947 void
3948 Calendar::internalSet(EDateFields field, int32_t value)
3949 {
3950     internalSet((UCalendarDateFields) field, value);
3951 }
3952 
3953 BasicTimeZone*
3954 Calendar::getBasicTimeZone(void) const {
3955     if (dynamic_cast&lt;const OlsonTimeZone *&gt;(fZone) != NULL
3956         || dynamic_cast&lt;const SimpleTimeZone *&gt;(fZone) != NULL
3957         || dynamic_cast&lt;const RuleBasedTimeZone *&gt;(fZone) != NULL
3958         || dynamic_cast&lt;const VTimeZone *&gt;(fZone) != NULL) {
3959         return (BasicTimeZone*)fZone;
3960     }
3961     return NULL;
3962 }
3963 
3964 U_NAMESPACE_END
3965 
3966 #endif /* #if !UCONFIG_NO_FORMATTING */
3967 
3968 
3969 //eof
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>