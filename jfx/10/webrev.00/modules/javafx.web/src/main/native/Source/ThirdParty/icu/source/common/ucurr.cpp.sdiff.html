<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/ucurr.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ucol_swp.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="udata.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/ucurr.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  68                                  1000000, 10000000, 100000000, 1000000000 };
  69 
  70 static const int32_t MAX_POW10 = UPRV_LENGTHOF(POW10) - 1;
  71 
  72 #define ISO_CURRENCY_CODE_LENGTH 3
  73 
  74 //------------------------------------------------------------
  75 // Resource tags
  76 //
  77 
  78 static const char CURRENCY_DATA[] = &quot;supplementalData&quot;;
  79 // Tag for meta-data, in root.
  80 static const char CURRENCY_META[] = &quot;CurrencyMeta&quot;;
  81 
  82 // Tag for map from countries to currencies, in root.
  83 static const char CURRENCY_MAP[] = &quot;CurrencyMap&quot;;
  84 
  85 // Tag for default meta-data, in CURRENCY_META
  86 static const char DEFAULT_META[] = &quot;DEFAULT&quot;;
  87 
<span class="line-removed">  88 // Variant for legacy pre-euro mapping in CurrencyMap</span>
<span class="line-removed">  89 static const char VAR_PRE_EURO[] = &quot;PREEURO&quot;;</span>
<span class="line-removed">  90 </span>
<span class="line-removed">  91 // Variant for legacy euro mapping in CurrencyMap</span>
<span class="line-removed">  92 static const char VAR_EURO[] = &quot;EURO&quot;;</span>
<span class="line-removed">  93 </span>
  94 // Variant delimiter
  95 static const char VAR_DELIM = &#39;_&#39;;
<span class="line-removed">  96 static const char VAR_DELIM_STR[] = &quot;_&quot;;</span>
<span class="line-removed">  97 </span>
<span class="line-removed">  98 // Variant for legacy euro mapping in CurrencyMap</span>
<span class="line-removed">  99 //static const char VAR_DELIM_EURO[] = &quot;_EURO&quot;;</span>
<span class="line-removed"> 100 </span>
<span class="line-removed"> 101 #define VARIANT_IS_EMPTY    0</span>
<span class="line-removed"> 102 #define VARIANT_IS_EURO     0x1</span>
<span class="line-removed"> 103 #define VARIANT_IS_PREEURO  0x2</span>
 104 
 105 // Tag for localized display names (symbols) of currencies
 106 static const char CURRENCIES[] = &quot;Currencies&quot;;
 107 static const char CURRENCIES_NARROW[] = &quot;Currencies%narrow&quot;;
 108 static const char CURRENCYPLURALS[] = &quot;CurrencyPlurals&quot;;
 109 
<span class="line-removed"> 110 static const UChar EUR_STR[] = {0x0045,0x0055,0x0052,0};</span>
<span class="line-removed"> 111 </span>
 112 // ISO codes mapping table
 113 static const UHashtable* gIsoCodes = NULL;
 114 static icu::UInitOnce gIsoCodesInitOnce = U_INITONCE_INITIALIZER;
 115 
 116 // Currency symbol equivalances
 117 static const icu::Hashtable* gCurrSymbolsEquiv = NULL;
 118 static icu::UInitOnce gCurrSymbolsEquivInitOnce = U_INITONCE_INITIALIZER;
 119 
 120 U_NAMESPACE_BEGIN
 121 
 122 // EquivIterator iterates over all strings that are equivalent to a given
 123 // string, s. Note that EquivIterator will never yield s itself.
 124 class EquivIterator : public icu::UMemory {
 125 public:
 126     // Constructor. hash stores the equivalence relationships; s is the string
 127     // for which we find equivalent strings.
 128     inline EquivIterator(const icu::Hashtable&amp; hash, const icu::UnicodeString&amp; s)
 129         : _hash(hash) {
 130         _start = _current = &amp;s;
 131     }
</pre>
<hr />
<pre>
 343 
 344     int32_t len;
 345     const int32_t *data = ures_getIntVector(rb, &amp;len, &amp;ec);
 346     if (U_FAILURE(ec) || len != 4) {
 347         // Config/build error; return hard-coded defaults
 348         if (U_SUCCESS(ec)) {
 349             ec = U_INVALID_FORMAT_ERROR;
 350         }
 351         ures_close(currencyMeta);
 352         ures_close(rb);
 353         return LAST_RESORT_DATA;
 354     }
 355 
 356     ures_close(currencyMeta);
 357     ures_close(rb);
 358     return data;
 359 }
 360 
 361 // -------------------------------------
 362 
<span class="line-modified"> 363 /**</span>
<span class="line-removed"> 364  * @see VARIANT_IS_EURO</span>
<span class="line-removed"> 365  * @see VARIANT_IS_PREEURO</span>
<span class="line-removed"> 366  */</span>
<span class="line-removed"> 367 static uint32_t</span>
 368 idForLocale(const char* locale, char* countryAndVariant, int capacity, UErrorCode* ec)
 369 {
<span class="line-removed"> 370     uint32_t variantType = 0;</span>
<span class="line-removed"> 371     // !!! this is internal only, assumes buffer is not null and capacity is sufficient</span>
<span class="line-removed"> 372     // Extract the country name and variant name.  We only</span>
<span class="line-removed"> 373     // recognize two variant names, EURO and PREEURO.</span>
<span class="line-removed"> 374     char variant[ULOC_FULLNAME_CAPACITY];</span>
 375     ulocimp_getRegionForSupplementalData(locale, FALSE, countryAndVariant, capacity, ec);
<span class="line-removed"> 376     uloc_getVariant(locale, variant, sizeof(variant), ec);</span>
<span class="line-removed"> 377     if (variant[0] != 0) {</span>
<span class="line-removed"> 378         variantType = (uint32_t)(0 == uprv_strcmp(variant, VAR_EURO))</span>
<span class="line-removed"> 379                    | ((uint32_t)(0 == uprv_strcmp(variant, VAR_PRE_EURO)) &lt;&lt; 1);</span>
<span class="line-removed"> 380         if (variantType)</span>
<span class="line-removed"> 381         {</span>
<span class="line-removed"> 382             uprv_strcat(countryAndVariant, VAR_DELIM_STR);</span>
<span class="line-removed"> 383             uprv_strcat(countryAndVariant, variant);</span>
<span class="line-removed"> 384         }</span>
<span class="line-removed"> 385     }</span>
<span class="line-removed"> 386     return variantType;</span>
 387 }
 388 
 389 // ------------------------------------------
 390 //
 391 // Registration
 392 //
 393 //-------------------------------------------
 394 
 395 // don&#39;t use ICUService since we don&#39;t need fallback
 396 
 397 U_CDECL_BEGIN
 398 static UBool U_CALLCONV currency_cleanup(void);
 399 U_CDECL_END
 400 
 401 #if !UCONFIG_NO_SERVICE
 402 struct CReg;
 403 
<span class="line-modified"> 404 static UMutex gCRegLock = U_MUTEX_INITIALIZER;</span>



 405 static CReg* gCRegHead = 0;
 406 
 407 struct CReg : public icu::UMemory {
 408     CReg *next;
 409     UChar iso[ISO_CURRENCY_CODE_LENGTH+1];
 410     char  id[ULOC_FULLNAME_CAPACITY];
 411 
 412     CReg(const UChar* _iso, const char* _id)
 413         : next(0)
 414     {
 415         int32_t len = (int32_t)uprv_strlen(_id);
 416         if (len &gt; (int32_t)(sizeof(id)-1)) {
 417             len = (sizeof(id)-1);
 418         }
 419         uprv_strncpy(id, _id, len);
 420         id[len] = 0;
 421         u_memcpy(iso, _iso, ISO_CURRENCY_CODE_LENGTH);
 422         iso[ISO_CURRENCY_CODE_LENGTH] = 0;
 423     }
 424 
 425     static UCurrRegistryKey reg(const UChar* _iso, const char* _id, UErrorCode* status)
 426     {
 427         if (status &amp;&amp; U_SUCCESS(*status) &amp;&amp; _iso &amp;&amp; _id) {
 428             CReg* n = new CReg(_iso, _id);
 429             if (n) {
<span class="line-modified"> 430                 umtx_lock(&amp;gCRegLock);</span>
 431                 if (!gCRegHead) {
 432                     /* register for the first time */
 433                     ucln_common_registerCleanup(UCLN_COMMON_CURRENCY, currency_cleanup);
 434                 }
 435                 n-&gt;next = gCRegHead;
 436                 gCRegHead = n;
<span class="line-modified"> 437                 umtx_unlock(&amp;gCRegLock);</span>
 438                 return n;
 439             }
 440             *status = U_MEMORY_ALLOCATION_ERROR;
 441         }
 442         return 0;
 443     }
 444 
 445     static UBool unreg(UCurrRegistryKey key) {
 446         UBool found = FALSE;
<span class="line-modified"> 447         umtx_lock(&amp;gCRegLock);</span>
 448 
 449         CReg** p = &amp;gCRegHead;
 450         while (*p) {
 451             if (*p == key) {
 452                 *p = ((CReg*)key)-&gt;next;
 453                 delete (CReg*)key;
 454                 found = TRUE;
 455                 break;
 456             }
 457             p = &amp;((*p)-&gt;next);
 458         }
 459 
<span class="line-modified"> 460         umtx_unlock(&amp;gCRegLock);</span>
 461         return found;
 462     }
 463 
 464     static const UChar* get(const char* id) {
 465         const UChar* result = NULL;
<span class="line-modified"> 466         umtx_lock(&amp;gCRegLock);</span>
 467         CReg* p = gCRegHead;
 468 
 469         /* register cleanup of the mutex */
 470         ucln_common_registerCleanup(UCLN_COMMON_CURRENCY, currency_cleanup);
 471         while (p) {
 472             if (uprv_strcmp(id, p-&gt;id) == 0) {
 473                 result = p-&gt;iso;
 474                 break;
 475             }
 476             p = p-&gt;next;
 477         }
<span class="line-modified"> 478         umtx_unlock(&amp;gCRegLock);</span>
 479         return result;
 480     }
 481 
 482     /* This doesn&#39;t need to be thread safe. It&#39;s for u_cleanup only. */
 483     static void cleanup(void) {
 484         while (gCRegHead) {
 485             CReg* n = gCRegHead;
 486             gCRegHead = gCRegHead-&gt;next;
 487             delete n;
 488         }
 489     }
 490 };
 491 
 492 // -------------------------------------
 493 
 494 U_CAPI UCurrRegistryKey U_EXPORT2
 495 ucurr_register(const UChar* isoCode, const char* locale, UErrorCode *status)
 496 {
 497     if (status &amp;&amp; U_SUCCESS(*status)) {
 498         char id[ULOC_FULLNAME_CAPACITY];
</pre>
<hr />
<pre>
 551     if (U_FAILURE(*ec)) { return 0; }
 552     if (buffCapacity &lt; 0 || (buff == nullptr &amp;&amp; buffCapacity &gt; 0)) {
 553         *ec = U_ILLEGAL_ARGUMENT_ERROR;
 554         return 0;
 555     }
 556 
 557     char currency[4];  // ISO currency codes are alpha3 codes.
 558     UErrorCode localStatus = U_ZERO_ERROR;
 559     int32_t resLen = uloc_getKeywordValue(locale, &quot;currency&quot;,
 560                                           currency, UPRV_LENGTHOF(currency), &amp;localStatus);
 561     if (U_SUCCESS(localStatus) &amp;&amp; resLen == 3 &amp;&amp; uprv_isInvariantString(currency, resLen)) {
 562         if (resLen &lt; buffCapacity) {
 563             T_CString_toUpperCase(currency);
 564             u_charsToUChars(currency, buff, resLen);
 565         }
 566         return u_terminateUChars(buff, buffCapacity, resLen, ec);
 567     }
 568 
 569     // get country or country_variant in `id&#39;
 570     char id[ULOC_FULLNAME_CAPACITY];
<span class="line-modified"> 571     uint32_t variantType = idForLocale(locale, id, UPRV_LENGTHOF(id), ec);</span>
 572     if (U_FAILURE(*ec)) {
 573         return 0;
 574     }
 575 
 576 #if !UCONFIG_NO_SERVICE
 577     const UChar* result = CReg::get(id);
 578     if (result) {
 579         if(buffCapacity &gt; u_strlen(result)) {
 580             u_strcpy(buff, result);
 581         }
 582         resLen = u_strlen(result);
 583         return u_terminateUChars(buff, buffCapacity, resLen, ec);
 584     }
 585 #endif
 586     // Remove variants, which is only needed for registration.
 587     char *idDelim = uprv_strchr(id, VAR_DELIM);
 588     if (idDelim) {
 589         idDelim[0] = 0;
 590     }
 591 
<span class="line-removed"> 605 </span>
<span class="line-removed"> 606         // Get the second item when PREEURO is requested, and this is a known Euro country.</span>
<span class="line-removed"> 607         // If the requested variant is PREEURO, and this isn&#39;t a Euro country,</span>
<span class="line-removed"> 608         // assume that the country changed over to the Euro in the future.</span>
<span class="line-removed"> 609         // This is probably an old version of ICU that hasn&#39;t been updated yet.</span>
<span class="line-removed"> 610         // The latest currency is probably correct.</span>
<span class="line-removed"> 611         if (U_SUCCESS(localStatus)) {</span>
<span class="line-removed"> 612             if ((variantType &amp; VARIANT_IS_PREEURO) &amp;&amp; u_strcmp(s, EUR_STR) == 0) {</span>
<span class="line-removed"> 613                 currencyReq = ures_getByIndex(countryArray, 1, currencyReq, &amp;localStatus);</span>
<span class="line-removed"> 614                 s = ures_getStringByKey(currencyReq, &quot;id&quot;, &amp;resLen, &amp;localStatus);</span>
<span class="line-removed"> 615             } else if ((variantType &amp; VARIANT_IS_EURO)) {</span>
<span class="line-removed"> 616                 s = EUR_STR;</span>
<span class="line-removed"> 617             }</span>
<span class="line-removed"> 618         }</span>
 619         ures_close(currencyReq);
 620         ures_close(countryArray);
 621     }
 622 
 623     if ((U_FAILURE(localStatus)) &amp;&amp; strchr(id, &#39;_&#39;) != 0) {
 624         // We don&#39;t know about it.  Check to see if we support the variant.
 625         uloc_getParent(locale, id, UPRV_LENGTHOF(id), ec);
 626         *ec = U_USING_FALLBACK_WARNING;
 627         // TODO: Loop over the shortened id rather than recursing and
 628         // looking again for a currency keyword.
 629         return ucurr_forLocale(id, buff, buffCapacity, ec);
 630     }
 631     if (*ec == U_ZERO_ERROR || localStatus != U_ZERO_ERROR) {
 632         // There is nothing to fallback to. Report the failure/warning if possible.
 633         *ec = localStatus;
 634     }
 635     if (U_SUCCESS(*ec)) {
 636         if(buffCapacity &gt; resLen) {
 637             u_strcpy(buff, s);
 638         }
</pre>
<hr />
<pre>
 723         *ec = U_ILLEGAL_ARGUMENT_ERROR;
 724         return 0;
 725     }
 726 
 727     char buf[ISO_CURRENCY_CODE_LENGTH+1];
 728     myUCharsToChars(buf, currency);
 729 
 730     /* Normalize the keyword value to uppercase */
 731     T_CString_toUpperCase(buf);
 732 
 733     const UChar* s = NULL;
 734     ec2 = U_ZERO_ERROR;
 735     LocalUResourceBundlePointer rb(ures_open(U_ICUDATA_CURR, loc, &amp;ec2));
 736 
 737     if (nameStyle == UCURR_NARROW_SYMBOL_NAME) {
 738         CharString key;
 739         key.append(CURRENCIES_NARROW, ec2);
 740         key.append(&quot;/&quot;, ec2);
 741         key.append(buf, ec2);
 742         s = ures_getStringByKeyWithFallback(rb.getAlias(), key.data(), len, &amp;ec2);
<span class="line-modified"> 743     } else {</span>






 744         ures_getByKey(rb.getAlias(), CURRENCIES, rb.getAlias(), &amp;ec2);
 745         ures_getByKeyWithFallback(rb.getAlias(), buf, rb.getAlias(), &amp;ec2);
 746         s = ures_getStringByIndex(rb.getAlias(), choice, len, &amp;ec2);
 747     }
 748 
 749     // If we&#39;ve succeeded we&#39;re done.  Otherwise, try to fallback.
 750     // If that fails (because we are already at root) then exit.
 751     if (U_SUCCESS(ec2)) {
 752         if (ec2 == U_USING_DEFAULT_WARNING
 753             || (ec2 == U_USING_FALLBACK_WARNING &amp;&amp; *ec != U_USING_DEFAULT_WARNING)) {
 754             *ec = ec2;
 755         }
 756     }
 757 
 758     // We no longer support choice format data in names.  Data should not contain
 759     // choice patterns.
 760     *isChoiceFormat = FALSE;
 761     if (U_SUCCESS(ec2)) {
 762         U_ASSERT(s != NULL);
 763         return s;
</pre>
<hr />
<pre>
1060             s = ures_getStringByIndex(names, UCURR_LONG_NAME, &amp;len, &amp;ec2);
1061             (*currencyNames)[*total_currency_name_count].IsoCode = iso;
1062             UChar* upperName = toUpperCase(s, len, locale);
1063             (*currencyNames)[*total_currency_name_count].currencyName = upperName;
1064             (*currencyNames)[*total_currency_name_count].flag = NEED_TO_BE_DELETED;
1065             (*currencyNames)[(*total_currency_name_count)++].currencyNameLen = len;
1066 
1067             // put (iso, 3, and iso) in to array
1068             // Add currency ISO code.
1069             (*currencySymbols)[*total_currency_symbol_count].IsoCode = iso;
1070             (*currencySymbols)[*total_currency_symbol_count].currencyName = (UChar*)uprv_malloc(sizeof(UChar)*3);
1071             // Must convert iso[] into Unicode
1072             u_charsToUChars(iso, (*currencySymbols)[*total_currency_symbol_count].currencyName, 3);
1073             (*currencySymbols)[*total_currency_symbol_count].flag = NEED_TO_BE_DELETED;
1074             (*currencySymbols)[(*total_currency_symbol_count)++].currencyNameLen = 3;
1075 
1076             ures_close(names);
1077         }
1078 
1079         // currency plurals
<span class="line-modified">1080         UErrorCode ec3 = U_ZERO_ERROR;</span>
<span class="line-modified">1081         UResourceBundle* curr_p = ures_getByKey(rb, CURRENCYPLURALS, NULL, &amp;ec3);</span>
1082         n = ures_getSize(curr_p);
1083         for (int32_t i=0; i&lt;n; ++i) {
<span class="line-modified">1084             UResourceBundle* names = ures_getByIndex(curr_p, i, NULL, &amp;ec3);</span>
1085             iso = (char*)ures_getKey(names);
1086             // Using hash to remove duplicated ISO codes in fallback chain.
1087             if (localeLevel == 0) {
1088                 uhash_put(currencyPluralIsoCodes, iso, iso, &amp;ec4);
1089             } else {
1090                 if (uhash_get(currencyPluralIsoCodes, iso) != NULL) {
1091                     ures_close(names);
1092                     continue;
1093                 } else {
1094                     uhash_put(currencyPluralIsoCodes, iso, iso, &amp;ec4);
1095                 }
1096             }
1097             int32_t num = ures_getSize(names);
1098             int32_t len;
1099             for (int32_t j = 0; j &lt; num; ++j) {
1100                 // TODO: remove duplicates between singular name and
1101                 // currency long name?
<span class="line-modified">1102                 s = ures_getStringByIndex(names, j, &amp;len, &amp;ec3);</span>
1103                 (*currencyNames)[*total_currency_name_count].IsoCode = iso;
1104                 UChar* upperName = toUpperCase(s, len, locale);
1105                 (*currencyNames)[*total_currency_name_count].currencyName = upperName;
1106                 (*currencyNames)[*total_currency_name_count].flag = NEED_TO_BE_DELETED;
1107                 (*currencyNames)[(*total_currency_name_count)++].currencyNameLen = len;
1108             }
1109             ures_close(names);
1110         }
1111         ures_close(curr_p);
1112         ures_close(curr);
1113         ures_close(rb);
1114 
1115         if (!fallback(loc)) {
1116             break;
1117         }
1118     }
1119 
1120     uhash_close(currencyIsoCodes);
1121     uhash_close(currencyPluralIsoCodes);
1122 
</pre>
<hr />
<pre>
1380     // currency symbols and ISO code, case sensitive
1381     CurrencyNameStruct* currencySymbols; // value
1382     int32_t totalCurrencySymbolCount;  // count
1383     // reference count.
1384     // reference count is set to 1 when an entry is put to cache.
1385     // it increases by 1 before accessing, and decreased by 1 after accessing.
1386     // The entry is deleted when ref count is zero, which means
1387     // the entry is replaced out of cache and no process is accessing it.
1388     int32_t refCount;
1389 } CurrencyNameCacheEntry;
1390 
1391 
1392 #define CURRENCY_NAME_CACHE_NUM 10
1393 
1394 // Reserve 10 cache entries.
1395 static CurrencyNameCacheEntry* currCache[CURRENCY_NAME_CACHE_NUM] = {NULL};
1396 // Using an index to indicate which entry to be replaced when cache is full.
1397 // It is a simple round-robin replacement strategy.
1398 static int8_t currentCacheEntryIndex = 0;
1399 
<span class="line-modified">1400 static UMutex gCurrencyCacheMutex = U_MUTEX_INITIALIZER;</span>



1401 
1402 // Cache deletion
1403 static void
1404 deleteCurrencyNames(CurrencyNameStruct* currencyNames, int32_t count) {
1405     for (int32_t index = 0; index &lt; count; ++index) {
1406         if ( (currencyNames[index].flag &amp; NEED_TO_BE_DELETED) ) {
1407             uprv_free(currencyNames[index].currencyName);
1408         }
1409     }
1410     uprv_free(currencyNames);
1411 }
1412 
1413 
1414 static void
1415 deleteCacheEntry(CurrencyNameCacheEntry* entry) {
1416     deleteCurrencyNames(entry-&gt;currencyNames, entry-&gt;totalCurrencyNameCount);
1417     deleteCurrencyNames(entry-&gt;currencySymbols, entry-&gt;totalCurrencySymbolCount);
1418     uprv_free(entry);
1419 }
1420 
</pre>
<hr />
<pre>
1429         }
1430     }
1431     return TRUE;
1432 }
1433 
1434 
1435 /**
1436  * Loads the currency name data from the cache, or from resource bundles if necessary.
1437  * The refCount is automatically incremented.  It is the caller&#39;s responsibility
1438  * to decrement it when done!
1439  */
1440 static CurrencyNameCacheEntry*
1441 getCacheEntry(const char* locale, UErrorCode&amp; ec) {
1442 
1443     int32_t total_currency_name_count = 0;
1444     CurrencyNameStruct* currencyNames = NULL;
1445     int32_t total_currency_symbol_count = 0;
1446     CurrencyNameStruct* currencySymbols = NULL;
1447     CurrencyNameCacheEntry* cacheEntry = NULL;
1448 
<span class="line-modified">1449     umtx_lock(&amp;gCurrencyCacheMutex);</span>
1450     // in order to handle racing correctly,
1451     // not putting &#39;search&#39; in a separate function.
<span class="line-modified">1452     int8_t  found = -1;</span>
1453     for (int8_t i = 0; i &lt; CURRENCY_NAME_CACHE_NUM; ++i) {
1454         if (currCache[i]!= NULL &amp;&amp;
1455             uprv_strcmp(locale, currCache[i]-&gt;locale) == 0) {
1456             found = i;
1457             break;
1458         }
1459     }
1460     if (found != -1) {
1461         cacheEntry = currCache[found];
1462         ++(cacheEntry-&gt;refCount);
1463     }
<span class="line-modified">1464     umtx_unlock(&amp;gCurrencyCacheMutex);</span>
1465     if (found == -1) {
1466         collectCurrencyNames(locale, &amp;currencyNames, &amp;total_currency_name_count, &amp;currencySymbols, &amp;total_currency_symbol_count, ec);
1467         if (U_FAILURE(ec)) {
1468             return NULL;
1469         }
<span class="line-modified">1470         umtx_lock(&amp;gCurrencyCacheMutex);</span>
1471         // check again.
<span class="line-removed">1472         int8_t  found = -1;</span>
1473         for (int8_t i = 0; i &lt; CURRENCY_NAME_CACHE_NUM; ++i) {
1474             if (currCache[i]!= NULL &amp;&amp;
1475                 uprv_strcmp(locale, currCache[i]-&gt;locale) == 0) {
1476                 found = i;
1477                 break;
1478             }
1479         }
1480         if (found == -1) {
1481             // insert new entry to
1482             // currentCacheEntryIndex % CURRENCY_NAME_CACHE_NUM
1483             // and remove the existing entry
1484             // currentCacheEntryIndex % CURRENCY_NAME_CACHE_NUM
1485             // from cache.
1486             cacheEntry = currCache[currentCacheEntryIndex];
1487             if (cacheEntry) {
1488                 --(cacheEntry-&gt;refCount);
1489                 // delete if the ref count is zero
1490                 if (cacheEntry-&gt;refCount == 0) {
1491                     deleteCacheEntry(cacheEntry);
1492                 }
1493             }
1494             cacheEntry = (CurrencyNameCacheEntry*)uprv_malloc(sizeof(CurrencyNameCacheEntry));
1495             currCache[currentCacheEntryIndex] = cacheEntry;
1496             uprv_strcpy(cacheEntry-&gt;locale, locale);
1497             cacheEntry-&gt;currencyNames = currencyNames;
1498             cacheEntry-&gt;totalCurrencyNameCount = total_currency_name_count;
1499             cacheEntry-&gt;currencySymbols = currencySymbols;
1500             cacheEntry-&gt;totalCurrencySymbolCount = total_currency_symbol_count;
1501             cacheEntry-&gt;refCount = 2; // one for cache, one for reference
1502             currentCacheEntryIndex = (currentCacheEntryIndex + 1) % CURRENCY_NAME_CACHE_NUM;
1503             ucln_common_registerCleanup(UCLN_COMMON_CURRENCY, currency_cleanup);
1504         } else {
1505             deleteCurrencyNames(currencyNames, total_currency_name_count);
1506             deleteCurrencyNames(currencySymbols, total_currency_symbol_count);
1507             cacheEntry = currCache[found];
1508             ++(cacheEntry-&gt;refCount);
1509         }
<span class="line-modified">1510         umtx_unlock(&amp;gCurrencyCacheMutex);</span>
1511     }
1512 
1513     return cacheEntry;
1514 }
1515 
1516 static void releaseCacheEntry(CurrencyNameCacheEntry* cacheEntry) {
<span class="line-modified">1517     umtx_lock(&amp;gCurrencyCacheMutex);</span>
1518     --(cacheEntry-&gt;refCount);
1519     if (cacheEntry-&gt;refCount == 0) {  // remove
1520         deleteCacheEntry(cacheEntry);
1521     }
<span class="line-modified">1522     umtx_unlock(&amp;gCurrencyCacheMutex);</span>
1523 }
1524 
1525 U_CAPI void
1526 uprv_parseCurrency(const char* locale,
1527                    const icu::UnicodeString&amp; text,
1528                    icu::ParsePosition&amp; pos,
1529                    int8_t type,
1530                    int32_t* partialMatchLen,
1531                    UChar* result,
1532                    UErrorCode&amp; ec) {
1533     U_NAMESPACE_USE
1534     if (U_FAILURE(ec)) {
1535         return;
1536     }
1537     CurrencyNameCacheEntry* cacheEntry = getCacheEntry(locale, ec);
1538     if (U_FAILURE(ec)) {
1539         return;
1540     }
1541 
1542     int32_t total_currency_name_count = cacheEntry-&gt;totalCurrencyNameCount;
</pre>
<hr />
<pre>
2289     myContext-&gt;listIdx = 0;
2290     myEnum-&gt;context = myContext;
2291     return myEnum;
2292 }
2293 
2294 U_CAPI int32_t U_EXPORT2
2295 ucurr_countCurrencies(const char* locale,
2296                  UDate date,
2297                  UErrorCode* ec)
2298 {
2299     int32_t currCount = 0;
2300 
2301     if (ec != NULL &amp;&amp; U_SUCCESS(*ec))
2302     {
2303         // local variables
2304         UErrorCode localStatus = U_ZERO_ERROR;
2305         char id[ULOC_FULLNAME_CAPACITY];
2306         uloc_getKeywordValue(locale, &quot;currency&quot;, id, ULOC_FULLNAME_CAPACITY, &amp;localStatus);
2307 
2308         // get country or country_variant in `id&#39;
<span class="line-modified">2309         /*uint32_t variantType =*/ idForLocale(locale, id, sizeof(id), ec);</span>
2310 
2311         if (U_FAILURE(*ec))
2312         {
2313             return 0;
2314         }
2315 
2316         // Remove variants, which is only needed for registration.
2317         char *idDelim = strchr(id, VAR_DELIM);
2318         if (idDelim)
2319         {
2320             idDelim[0] = 0;
2321         }
2322 
2323         // Look up the CurrencyMap element in the root bundle.
2324         UResourceBundle *rb = ures_openDirect(U_ICUDATA_CURR, CURRENCY_DATA, &amp;localStatus);
2325         UResourceBundle *cm = ures_getByKey(rb, CURRENCY_MAP, rb, &amp;localStatus);
2326 
2327         // Using the id derived from the local, get the currency data
2328         UResourceBundle *countryArray = ures_getByKey(rb, id, cm, &amp;localStatus);
2329 
</pre>
<hr />
<pre>
2405                 int32_t index,
2406                 UChar* buff,
2407                 int32_t buffCapacity,
2408                 UErrorCode* ec)
2409 {
2410     int32_t resLen = 0;
2411     int32_t currIndex = 0;
2412     const UChar* s = NULL;
2413 
2414     if (ec != NULL &amp;&amp; U_SUCCESS(*ec))
2415     {
2416         // check the arguments passed
2417         if ((buff &amp;&amp; buffCapacity) || !buffCapacity )
2418         {
2419             // local variables
2420             UErrorCode localStatus = U_ZERO_ERROR;
2421             char id[ULOC_FULLNAME_CAPACITY];
2422             resLen = uloc_getKeywordValue(locale, &quot;currency&quot;, id, ULOC_FULLNAME_CAPACITY, &amp;localStatus);
2423 
2424             // get country or country_variant in `id&#39;
<span class="line-modified">2425             /*uint32_t variantType =*/ idForLocale(locale, id, sizeof(id), ec);</span>
2426             if (U_FAILURE(*ec))
2427             {
2428                 return 0;
2429             }
2430 
2431             // Remove variants, which is only needed for registration.
2432             char *idDelim = strchr(id, VAR_DELIM);
2433             if (idDelim)
2434             {
2435                 idDelim[0] = 0;
2436             }
2437 
2438             // Look up the CurrencyMap element in the root bundle.
2439             UResourceBundle *rb = ures_openDirect(U_ICUDATA_CURR, CURRENCY_DATA, &amp;localStatus);
2440             UResourceBundle *cm = ures_getByKey(rb, CURRENCY_MAP, rb, &amp;localStatus);
2441 
2442             // Using the id derived from the local, get the currency data
2443             UResourceBundle *countryArray = ures_getByKey(rb, id, cm, &amp;localStatus);
2444 
2445             // process each currency to see which one is valid for the given date
</pre>
<hr />
<pre>
2617                 // Currently, an empty ARRAY is mixed in.
2618                 continue;
2619             }
2620             char *curID = (char *)uprv_malloc(sizeof(char) * ULOC_KEYWORDS_CAPACITY);
2621             int32_t curIDLength = ULOC_KEYWORDS_CAPACITY;
2622             if (curID == NULL) {
2623                 *status = U_MEMORY_ALLOCATION_ERROR;
2624                 break;
2625             }
2626 
2627 #if U_CHARSET_FAMILY==U_ASCII_FAMILY
2628             ures_getUTF8StringByKey(&amp;curbndl, &quot;id&quot;, curID, &amp;curIDLength, TRUE, status);
2629             /* optimize - use the utf-8 string */
2630 #else
2631             {
2632                        const UChar* defString = ures_getStringByKey(&amp;curbndl, &quot;id&quot;, &amp;curIDLength, status);
2633                        if(U_SUCCESS(*status)) {
2634                if(curIDLength+1 &gt; ULOC_KEYWORDS_CAPACITY) {
2635                 *status = U_BUFFER_OVERFLOW_ERROR;
2636                } else {
<span class="line-modified">2637                             u_UCharsToChars(defString, curID, curIDLength+1);</span>
2638                }
2639                        }
2640             }
2641 #endif
2642 
2643             if (U_FAILURE(*status)) {
2644                 break;
2645             }
2646             UBool hasTo = FALSE;
2647             ures_getByKey(&amp;curbndl, &quot;to&quot;, &amp;to, status);
2648             if (U_FAILURE(*status)) {
2649                 // Do nothing here...
2650                 *status = U_ZERO_ERROR;
2651             } else {
2652                 hasTo = TRUE;
2653             }
2654             if (isPrefRegion &amp;&amp; !hasTo &amp;&amp; !ulist_containsString(values, curID, (int32_t)uprv_strlen(curID))) {
2655                 // Currently active currency for the target country
2656                 ulist_addItemEndList(values, curID, TRUE, status);
2657             } else if (!ulist_containsString(otherValues, curID, (int32_t)uprv_strlen(curID)) &amp;&amp; !commonlyUsed) {
</pre>
</td>
<td>
<hr />
<pre>
  68                                  1000000, 10000000, 100000000, 1000000000 };
  69 
  70 static const int32_t MAX_POW10 = UPRV_LENGTHOF(POW10) - 1;
  71 
  72 #define ISO_CURRENCY_CODE_LENGTH 3
  73 
  74 //------------------------------------------------------------
  75 // Resource tags
  76 //
  77 
  78 static const char CURRENCY_DATA[] = &quot;supplementalData&quot;;
  79 // Tag for meta-data, in root.
  80 static const char CURRENCY_META[] = &quot;CurrencyMeta&quot;;
  81 
  82 // Tag for map from countries to currencies, in root.
  83 static const char CURRENCY_MAP[] = &quot;CurrencyMap&quot;;
  84 
  85 // Tag for default meta-data, in CURRENCY_META
  86 static const char DEFAULT_META[] = &quot;DEFAULT&quot;;
  87 






  88 // Variant delimiter
  89 static const char VAR_DELIM = &#39;_&#39;;








  90 
  91 // Tag for localized display names (symbols) of currencies
  92 static const char CURRENCIES[] = &quot;Currencies&quot;;
  93 static const char CURRENCIES_NARROW[] = &quot;Currencies%narrow&quot;;
  94 static const char CURRENCYPLURALS[] = &quot;CurrencyPlurals&quot;;
  95 


  96 // ISO codes mapping table
  97 static const UHashtable* gIsoCodes = NULL;
  98 static icu::UInitOnce gIsoCodesInitOnce = U_INITONCE_INITIALIZER;
  99 
 100 // Currency symbol equivalances
 101 static const icu::Hashtable* gCurrSymbolsEquiv = NULL;
 102 static icu::UInitOnce gCurrSymbolsEquivInitOnce = U_INITONCE_INITIALIZER;
 103 
 104 U_NAMESPACE_BEGIN
 105 
 106 // EquivIterator iterates over all strings that are equivalent to a given
 107 // string, s. Note that EquivIterator will never yield s itself.
 108 class EquivIterator : public icu::UMemory {
 109 public:
 110     // Constructor. hash stores the equivalence relationships; s is the string
 111     // for which we find equivalent strings.
 112     inline EquivIterator(const icu::Hashtable&amp; hash, const icu::UnicodeString&amp; s)
 113         : _hash(hash) {
 114         _start = _current = &amp;s;
 115     }
</pre>
<hr />
<pre>
 327 
 328     int32_t len;
 329     const int32_t *data = ures_getIntVector(rb, &amp;len, &amp;ec);
 330     if (U_FAILURE(ec) || len != 4) {
 331         // Config/build error; return hard-coded defaults
 332         if (U_SUCCESS(ec)) {
 333             ec = U_INVALID_FORMAT_ERROR;
 334         }
 335         ures_close(currencyMeta);
 336         ures_close(rb);
 337         return LAST_RESORT_DATA;
 338     }
 339 
 340     ures_close(currencyMeta);
 341     ures_close(rb);
 342     return data;
 343 }
 344 
 345 // -------------------------------------
 346 
<span class="line-modified"> 347 static void</span>




 348 idForLocale(const char* locale, char* countryAndVariant, int capacity, UErrorCode* ec)
 349 {





 350     ulocimp_getRegionForSupplementalData(locale, FALSE, countryAndVariant, capacity, ec);











 351 }
 352 
 353 // ------------------------------------------
 354 //
 355 // Registration
 356 //
 357 //-------------------------------------------
 358 
 359 // don&#39;t use ICUService since we don&#39;t need fallback
 360 
 361 U_CDECL_BEGIN
 362 static UBool U_CALLCONV currency_cleanup(void);
 363 U_CDECL_END
 364 
 365 #if !UCONFIG_NO_SERVICE
 366 struct CReg;
 367 
<span class="line-modified"> 368 static UMutex *gCRegLock() {</span>
<span class="line-added"> 369     static UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added"> 370     return &amp;m;</span>
<span class="line-added"> 371 }</span>
 372 static CReg* gCRegHead = 0;
 373 
 374 struct CReg : public icu::UMemory {
 375     CReg *next;
 376     UChar iso[ISO_CURRENCY_CODE_LENGTH+1];
 377     char  id[ULOC_FULLNAME_CAPACITY];
 378 
 379     CReg(const UChar* _iso, const char* _id)
 380         : next(0)
 381     {
 382         int32_t len = (int32_t)uprv_strlen(_id);
 383         if (len &gt; (int32_t)(sizeof(id)-1)) {
 384             len = (sizeof(id)-1);
 385         }
 386         uprv_strncpy(id, _id, len);
 387         id[len] = 0;
 388         u_memcpy(iso, _iso, ISO_CURRENCY_CODE_LENGTH);
 389         iso[ISO_CURRENCY_CODE_LENGTH] = 0;
 390     }
 391 
 392     static UCurrRegistryKey reg(const UChar* _iso, const char* _id, UErrorCode* status)
 393     {
 394         if (status &amp;&amp; U_SUCCESS(*status) &amp;&amp; _iso &amp;&amp; _id) {
 395             CReg* n = new CReg(_iso, _id);
 396             if (n) {
<span class="line-modified"> 397                 umtx_lock(gCRegLock());</span>
 398                 if (!gCRegHead) {
 399                     /* register for the first time */
 400                     ucln_common_registerCleanup(UCLN_COMMON_CURRENCY, currency_cleanup);
 401                 }
 402                 n-&gt;next = gCRegHead;
 403                 gCRegHead = n;
<span class="line-modified"> 404                 umtx_unlock(gCRegLock());</span>
 405                 return n;
 406             }
 407             *status = U_MEMORY_ALLOCATION_ERROR;
 408         }
 409         return 0;
 410     }
 411 
 412     static UBool unreg(UCurrRegistryKey key) {
 413         UBool found = FALSE;
<span class="line-modified"> 414         umtx_lock(gCRegLock());</span>
 415 
 416         CReg** p = &amp;gCRegHead;
 417         while (*p) {
 418             if (*p == key) {
 419                 *p = ((CReg*)key)-&gt;next;
 420                 delete (CReg*)key;
 421                 found = TRUE;
 422                 break;
 423             }
 424             p = &amp;((*p)-&gt;next);
 425         }
 426 
<span class="line-modified"> 427         umtx_unlock(gCRegLock());</span>
 428         return found;
 429     }
 430 
 431     static const UChar* get(const char* id) {
 432         const UChar* result = NULL;
<span class="line-modified"> 433         umtx_lock(gCRegLock());</span>
 434         CReg* p = gCRegHead;
 435 
 436         /* register cleanup of the mutex */
 437         ucln_common_registerCleanup(UCLN_COMMON_CURRENCY, currency_cleanup);
 438         while (p) {
 439             if (uprv_strcmp(id, p-&gt;id) == 0) {
 440                 result = p-&gt;iso;
 441                 break;
 442             }
 443             p = p-&gt;next;
 444         }
<span class="line-modified"> 445         umtx_unlock(gCRegLock());</span>
 446         return result;
 447     }
 448 
 449     /* This doesn&#39;t need to be thread safe. It&#39;s for u_cleanup only. */
 450     static void cleanup(void) {
 451         while (gCRegHead) {
 452             CReg* n = gCRegHead;
 453             gCRegHead = gCRegHead-&gt;next;
 454             delete n;
 455         }
 456     }
 457 };
 458 
 459 // -------------------------------------
 460 
 461 U_CAPI UCurrRegistryKey U_EXPORT2
 462 ucurr_register(const UChar* isoCode, const char* locale, UErrorCode *status)
 463 {
 464     if (status &amp;&amp; U_SUCCESS(*status)) {
 465         char id[ULOC_FULLNAME_CAPACITY];
</pre>
<hr />
<pre>
 518     if (U_FAILURE(*ec)) { return 0; }
 519     if (buffCapacity &lt; 0 || (buff == nullptr &amp;&amp; buffCapacity &gt; 0)) {
 520         *ec = U_ILLEGAL_ARGUMENT_ERROR;
 521         return 0;
 522     }
 523 
 524     char currency[4];  // ISO currency codes are alpha3 codes.
 525     UErrorCode localStatus = U_ZERO_ERROR;
 526     int32_t resLen = uloc_getKeywordValue(locale, &quot;currency&quot;,
 527                                           currency, UPRV_LENGTHOF(currency), &amp;localStatus);
 528     if (U_SUCCESS(localStatus) &amp;&amp; resLen == 3 &amp;&amp; uprv_isInvariantString(currency, resLen)) {
 529         if (resLen &lt; buffCapacity) {
 530             T_CString_toUpperCase(currency);
 531             u_charsToUChars(currency, buff, resLen);
 532         }
 533         return u_terminateUChars(buff, buffCapacity, resLen, ec);
 534     }
 535 
 536     // get country or country_variant in `id&#39;
 537     char id[ULOC_FULLNAME_CAPACITY];
<span class="line-modified"> 538     idForLocale(locale, id, UPRV_LENGTHOF(id), ec);</span>
 539     if (U_FAILURE(*ec)) {
 540         return 0;
 541     }
 542 
 543 #if !UCONFIG_NO_SERVICE
 544     const UChar* result = CReg::get(id);
 545     if (result) {
 546         if(buffCapacity &gt; u_strlen(result)) {
 547             u_strcpy(buff, result);
 548         }
 549         resLen = u_strlen(result);
 550         return u_terminateUChars(buff, buffCapacity, resLen, ec);
 551     }
 552 #endif
 553     // Remove variants, which is only needed for registration.
 554     char *idDelim = uprv_strchr(id, VAR_DELIM);
 555     if (idDelim) {
 556         idDelim[0] = 0;
 557     }
 558 














 572         ures_close(currencyReq);
 573         ures_close(countryArray);
 574     }
 575 
 576     if ((U_FAILURE(localStatus)) &amp;&amp; strchr(id, &#39;_&#39;) != 0) {
 577         // We don&#39;t know about it.  Check to see if we support the variant.
 578         uloc_getParent(locale, id, UPRV_LENGTHOF(id), ec);
 579         *ec = U_USING_FALLBACK_WARNING;
 580         // TODO: Loop over the shortened id rather than recursing and
 581         // looking again for a currency keyword.
 582         return ucurr_forLocale(id, buff, buffCapacity, ec);
 583     }
 584     if (*ec == U_ZERO_ERROR || localStatus != U_ZERO_ERROR) {
 585         // There is nothing to fallback to. Report the failure/warning if possible.
 586         *ec = localStatus;
 587     }
 588     if (U_SUCCESS(*ec)) {
 589         if(buffCapacity &gt; resLen) {
 590             u_strcpy(buff, s);
 591         }
</pre>
<hr />
<pre>
 676         *ec = U_ILLEGAL_ARGUMENT_ERROR;
 677         return 0;
 678     }
 679 
 680     char buf[ISO_CURRENCY_CODE_LENGTH+1];
 681     myUCharsToChars(buf, currency);
 682 
 683     /* Normalize the keyword value to uppercase */
 684     T_CString_toUpperCase(buf);
 685 
 686     const UChar* s = NULL;
 687     ec2 = U_ZERO_ERROR;
 688     LocalUResourceBundlePointer rb(ures_open(U_ICUDATA_CURR, loc, &amp;ec2));
 689 
 690     if (nameStyle == UCURR_NARROW_SYMBOL_NAME) {
 691         CharString key;
 692         key.append(CURRENCIES_NARROW, ec2);
 693         key.append(&quot;/&quot;, ec2);
 694         key.append(buf, ec2);
 695         s = ures_getStringByKeyWithFallback(rb.getAlias(), key.data(), len, &amp;ec2);
<span class="line-modified"> 696         if (ec2 == U_MISSING_RESOURCE_ERROR) {</span>
<span class="line-added"> 697             *ec = U_USING_FALLBACK_WARNING;</span>
<span class="line-added"> 698             ec2 = U_ZERO_ERROR;</span>
<span class="line-added"> 699             choice = UCURR_SYMBOL_NAME;</span>
<span class="line-added"> 700         }</span>
<span class="line-added"> 701     }</span>
<span class="line-added"> 702     if (s == NULL) {</span>
 703         ures_getByKey(rb.getAlias(), CURRENCIES, rb.getAlias(), &amp;ec2);
 704         ures_getByKeyWithFallback(rb.getAlias(), buf, rb.getAlias(), &amp;ec2);
 705         s = ures_getStringByIndex(rb.getAlias(), choice, len, &amp;ec2);
 706     }
 707 
 708     // If we&#39;ve succeeded we&#39;re done.  Otherwise, try to fallback.
 709     // If that fails (because we are already at root) then exit.
 710     if (U_SUCCESS(ec2)) {
 711         if (ec2 == U_USING_DEFAULT_WARNING
 712             || (ec2 == U_USING_FALLBACK_WARNING &amp;&amp; *ec != U_USING_DEFAULT_WARNING)) {
 713             *ec = ec2;
 714         }
 715     }
 716 
 717     // We no longer support choice format data in names.  Data should not contain
 718     // choice patterns.
 719     *isChoiceFormat = FALSE;
 720     if (U_SUCCESS(ec2)) {
 721         U_ASSERT(s != NULL);
 722         return s;
</pre>
<hr />
<pre>
1019             s = ures_getStringByIndex(names, UCURR_LONG_NAME, &amp;len, &amp;ec2);
1020             (*currencyNames)[*total_currency_name_count].IsoCode = iso;
1021             UChar* upperName = toUpperCase(s, len, locale);
1022             (*currencyNames)[*total_currency_name_count].currencyName = upperName;
1023             (*currencyNames)[*total_currency_name_count].flag = NEED_TO_BE_DELETED;
1024             (*currencyNames)[(*total_currency_name_count)++].currencyNameLen = len;
1025 
1026             // put (iso, 3, and iso) in to array
1027             // Add currency ISO code.
1028             (*currencySymbols)[*total_currency_symbol_count].IsoCode = iso;
1029             (*currencySymbols)[*total_currency_symbol_count].currencyName = (UChar*)uprv_malloc(sizeof(UChar)*3);
1030             // Must convert iso[] into Unicode
1031             u_charsToUChars(iso, (*currencySymbols)[*total_currency_symbol_count].currencyName, 3);
1032             (*currencySymbols)[*total_currency_symbol_count].flag = NEED_TO_BE_DELETED;
1033             (*currencySymbols)[(*total_currency_symbol_count)++].currencyNameLen = 3;
1034 
1035             ures_close(names);
1036         }
1037 
1038         // currency plurals
<span class="line-modified">1039         UErrorCode ec5 = U_ZERO_ERROR;</span>
<span class="line-modified">1040         UResourceBundle* curr_p = ures_getByKey(rb, CURRENCYPLURALS, NULL, &amp;ec5);</span>
1041         n = ures_getSize(curr_p);
1042         for (int32_t i=0; i&lt;n; ++i) {
<span class="line-modified">1043             UResourceBundle* names = ures_getByIndex(curr_p, i, NULL, &amp;ec5);</span>
1044             iso = (char*)ures_getKey(names);
1045             // Using hash to remove duplicated ISO codes in fallback chain.
1046             if (localeLevel == 0) {
1047                 uhash_put(currencyPluralIsoCodes, iso, iso, &amp;ec4);
1048             } else {
1049                 if (uhash_get(currencyPluralIsoCodes, iso) != NULL) {
1050                     ures_close(names);
1051                     continue;
1052                 } else {
1053                     uhash_put(currencyPluralIsoCodes, iso, iso, &amp;ec4);
1054                 }
1055             }
1056             int32_t num = ures_getSize(names);
1057             int32_t len;
1058             for (int32_t j = 0; j &lt; num; ++j) {
1059                 // TODO: remove duplicates between singular name and
1060                 // currency long name?
<span class="line-modified">1061                 s = ures_getStringByIndex(names, j, &amp;len, &amp;ec5);</span>
1062                 (*currencyNames)[*total_currency_name_count].IsoCode = iso;
1063                 UChar* upperName = toUpperCase(s, len, locale);
1064                 (*currencyNames)[*total_currency_name_count].currencyName = upperName;
1065                 (*currencyNames)[*total_currency_name_count].flag = NEED_TO_BE_DELETED;
1066                 (*currencyNames)[(*total_currency_name_count)++].currencyNameLen = len;
1067             }
1068             ures_close(names);
1069         }
1070         ures_close(curr_p);
1071         ures_close(curr);
1072         ures_close(rb);
1073 
1074         if (!fallback(loc)) {
1075             break;
1076         }
1077     }
1078 
1079     uhash_close(currencyIsoCodes);
1080     uhash_close(currencyPluralIsoCodes);
1081 
</pre>
<hr />
<pre>
1339     // currency symbols and ISO code, case sensitive
1340     CurrencyNameStruct* currencySymbols; // value
1341     int32_t totalCurrencySymbolCount;  // count
1342     // reference count.
1343     // reference count is set to 1 when an entry is put to cache.
1344     // it increases by 1 before accessing, and decreased by 1 after accessing.
1345     // The entry is deleted when ref count is zero, which means
1346     // the entry is replaced out of cache and no process is accessing it.
1347     int32_t refCount;
1348 } CurrencyNameCacheEntry;
1349 
1350 
1351 #define CURRENCY_NAME_CACHE_NUM 10
1352 
1353 // Reserve 10 cache entries.
1354 static CurrencyNameCacheEntry* currCache[CURRENCY_NAME_CACHE_NUM] = {NULL};
1355 // Using an index to indicate which entry to be replaced when cache is full.
1356 // It is a simple round-robin replacement strategy.
1357 static int8_t currentCacheEntryIndex = 0;
1358 
<span class="line-modified">1359 static UMutex *gCurrencyCacheMutex() {</span>
<span class="line-added">1360     static UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added">1361     return &amp;m;</span>
<span class="line-added">1362 }</span>
1363 
1364 // Cache deletion
1365 static void
1366 deleteCurrencyNames(CurrencyNameStruct* currencyNames, int32_t count) {
1367     for (int32_t index = 0; index &lt; count; ++index) {
1368         if ( (currencyNames[index].flag &amp; NEED_TO_BE_DELETED) ) {
1369             uprv_free(currencyNames[index].currencyName);
1370         }
1371     }
1372     uprv_free(currencyNames);
1373 }
1374 
1375 
1376 static void
1377 deleteCacheEntry(CurrencyNameCacheEntry* entry) {
1378     deleteCurrencyNames(entry-&gt;currencyNames, entry-&gt;totalCurrencyNameCount);
1379     deleteCurrencyNames(entry-&gt;currencySymbols, entry-&gt;totalCurrencySymbolCount);
1380     uprv_free(entry);
1381 }
1382 
</pre>
<hr />
<pre>
1391         }
1392     }
1393     return TRUE;
1394 }
1395 
1396 
1397 /**
1398  * Loads the currency name data from the cache, or from resource bundles if necessary.
1399  * The refCount is automatically incremented.  It is the caller&#39;s responsibility
1400  * to decrement it when done!
1401  */
1402 static CurrencyNameCacheEntry*
1403 getCacheEntry(const char* locale, UErrorCode&amp; ec) {
1404 
1405     int32_t total_currency_name_count = 0;
1406     CurrencyNameStruct* currencyNames = NULL;
1407     int32_t total_currency_symbol_count = 0;
1408     CurrencyNameStruct* currencySymbols = NULL;
1409     CurrencyNameCacheEntry* cacheEntry = NULL;
1410 
<span class="line-modified">1411     umtx_lock(gCurrencyCacheMutex());</span>
1412     // in order to handle racing correctly,
1413     // not putting &#39;search&#39; in a separate function.
<span class="line-modified">1414     int8_t found = -1;</span>
1415     for (int8_t i = 0; i &lt; CURRENCY_NAME_CACHE_NUM; ++i) {
1416         if (currCache[i]!= NULL &amp;&amp;
1417             uprv_strcmp(locale, currCache[i]-&gt;locale) == 0) {
1418             found = i;
1419             break;
1420         }
1421     }
1422     if (found != -1) {
1423         cacheEntry = currCache[found];
1424         ++(cacheEntry-&gt;refCount);
1425     }
<span class="line-modified">1426     umtx_unlock(gCurrencyCacheMutex());</span>
1427     if (found == -1) {
1428         collectCurrencyNames(locale, &amp;currencyNames, &amp;total_currency_name_count, &amp;currencySymbols, &amp;total_currency_symbol_count, ec);
1429         if (U_FAILURE(ec)) {
1430             return NULL;
1431         }
<span class="line-modified">1432         umtx_lock(gCurrencyCacheMutex());</span>
1433         // check again.

1434         for (int8_t i = 0; i &lt; CURRENCY_NAME_CACHE_NUM; ++i) {
1435             if (currCache[i]!= NULL &amp;&amp;
1436                 uprv_strcmp(locale, currCache[i]-&gt;locale) == 0) {
1437                 found = i;
1438                 break;
1439             }
1440         }
1441         if (found == -1) {
1442             // insert new entry to
1443             // currentCacheEntryIndex % CURRENCY_NAME_CACHE_NUM
1444             // and remove the existing entry
1445             // currentCacheEntryIndex % CURRENCY_NAME_CACHE_NUM
1446             // from cache.
1447             cacheEntry = currCache[currentCacheEntryIndex];
1448             if (cacheEntry) {
1449                 --(cacheEntry-&gt;refCount);
1450                 // delete if the ref count is zero
1451                 if (cacheEntry-&gt;refCount == 0) {
1452                     deleteCacheEntry(cacheEntry);
1453                 }
1454             }
1455             cacheEntry = (CurrencyNameCacheEntry*)uprv_malloc(sizeof(CurrencyNameCacheEntry));
1456             currCache[currentCacheEntryIndex] = cacheEntry;
1457             uprv_strcpy(cacheEntry-&gt;locale, locale);
1458             cacheEntry-&gt;currencyNames = currencyNames;
1459             cacheEntry-&gt;totalCurrencyNameCount = total_currency_name_count;
1460             cacheEntry-&gt;currencySymbols = currencySymbols;
1461             cacheEntry-&gt;totalCurrencySymbolCount = total_currency_symbol_count;
1462             cacheEntry-&gt;refCount = 2; // one for cache, one for reference
1463             currentCacheEntryIndex = (currentCacheEntryIndex + 1) % CURRENCY_NAME_CACHE_NUM;
1464             ucln_common_registerCleanup(UCLN_COMMON_CURRENCY, currency_cleanup);
1465         } else {
1466             deleteCurrencyNames(currencyNames, total_currency_name_count);
1467             deleteCurrencyNames(currencySymbols, total_currency_symbol_count);
1468             cacheEntry = currCache[found];
1469             ++(cacheEntry-&gt;refCount);
1470         }
<span class="line-modified">1471         umtx_unlock(gCurrencyCacheMutex());</span>
1472     }
1473 
1474     return cacheEntry;
1475 }
1476 
1477 static void releaseCacheEntry(CurrencyNameCacheEntry* cacheEntry) {
<span class="line-modified">1478     umtx_lock(gCurrencyCacheMutex());</span>
1479     --(cacheEntry-&gt;refCount);
1480     if (cacheEntry-&gt;refCount == 0) {  // remove
1481         deleteCacheEntry(cacheEntry);
1482     }
<span class="line-modified">1483     umtx_unlock(gCurrencyCacheMutex());</span>
1484 }
1485 
1486 U_CAPI void
1487 uprv_parseCurrency(const char* locale,
1488                    const icu::UnicodeString&amp; text,
1489                    icu::ParsePosition&amp; pos,
1490                    int8_t type,
1491                    int32_t* partialMatchLen,
1492                    UChar* result,
1493                    UErrorCode&amp; ec) {
1494     U_NAMESPACE_USE
1495     if (U_FAILURE(ec)) {
1496         return;
1497     }
1498     CurrencyNameCacheEntry* cacheEntry = getCacheEntry(locale, ec);
1499     if (U_FAILURE(ec)) {
1500         return;
1501     }
1502 
1503     int32_t total_currency_name_count = cacheEntry-&gt;totalCurrencyNameCount;
</pre>
<hr />
<pre>
2250     myContext-&gt;listIdx = 0;
2251     myEnum-&gt;context = myContext;
2252     return myEnum;
2253 }
2254 
2255 U_CAPI int32_t U_EXPORT2
2256 ucurr_countCurrencies(const char* locale,
2257                  UDate date,
2258                  UErrorCode* ec)
2259 {
2260     int32_t currCount = 0;
2261 
2262     if (ec != NULL &amp;&amp; U_SUCCESS(*ec))
2263     {
2264         // local variables
2265         UErrorCode localStatus = U_ZERO_ERROR;
2266         char id[ULOC_FULLNAME_CAPACITY];
2267         uloc_getKeywordValue(locale, &quot;currency&quot;, id, ULOC_FULLNAME_CAPACITY, &amp;localStatus);
2268 
2269         // get country or country_variant in `id&#39;
<span class="line-modified">2270         idForLocale(locale, id, sizeof(id), ec);</span>
2271 
2272         if (U_FAILURE(*ec))
2273         {
2274             return 0;
2275         }
2276 
2277         // Remove variants, which is only needed for registration.
2278         char *idDelim = strchr(id, VAR_DELIM);
2279         if (idDelim)
2280         {
2281             idDelim[0] = 0;
2282         }
2283 
2284         // Look up the CurrencyMap element in the root bundle.
2285         UResourceBundle *rb = ures_openDirect(U_ICUDATA_CURR, CURRENCY_DATA, &amp;localStatus);
2286         UResourceBundle *cm = ures_getByKey(rb, CURRENCY_MAP, rb, &amp;localStatus);
2287 
2288         // Using the id derived from the local, get the currency data
2289         UResourceBundle *countryArray = ures_getByKey(rb, id, cm, &amp;localStatus);
2290 
</pre>
<hr />
<pre>
2366                 int32_t index,
2367                 UChar* buff,
2368                 int32_t buffCapacity,
2369                 UErrorCode* ec)
2370 {
2371     int32_t resLen = 0;
2372     int32_t currIndex = 0;
2373     const UChar* s = NULL;
2374 
2375     if (ec != NULL &amp;&amp; U_SUCCESS(*ec))
2376     {
2377         // check the arguments passed
2378         if ((buff &amp;&amp; buffCapacity) || !buffCapacity )
2379         {
2380             // local variables
2381             UErrorCode localStatus = U_ZERO_ERROR;
2382             char id[ULOC_FULLNAME_CAPACITY];
2383             resLen = uloc_getKeywordValue(locale, &quot;currency&quot;, id, ULOC_FULLNAME_CAPACITY, &amp;localStatus);
2384 
2385             // get country or country_variant in `id&#39;
<span class="line-modified">2386             idForLocale(locale, id, sizeof(id), ec);</span>
2387             if (U_FAILURE(*ec))
2388             {
2389                 return 0;
2390             }
2391 
2392             // Remove variants, which is only needed for registration.
2393             char *idDelim = strchr(id, VAR_DELIM);
2394             if (idDelim)
2395             {
2396                 idDelim[0] = 0;
2397             }
2398 
2399             // Look up the CurrencyMap element in the root bundle.
2400             UResourceBundle *rb = ures_openDirect(U_ICUDATA_CURR, CURRENCY_DATA, &amp;localStatus);
2401             UResourceBundle *cm = ures_getByKey(rb, CURRENCY_MAP, rb, &amp;localStatus);
2402 
2403             // Using the id derived from the local, get the currency data
2404             UResourceBundle *countryArray = ures_getByKey(rb, id, cm, &amp;localStatus);
2405 
2406             // process each currency to see which one is valid for the given date
</pre>
<hr />
<pre>
2578                 // Currently, an empty ARRAY is mixed in.
2579                 continue;
2580             }
2581             char *curID = (char *)uprv_malloc(sizeof(char) * ULOC_KEYWORDS_CAPACITY);
2582             int32_t curIDLength = ULOC_KEYWORDS_CAPACITY;
2583             if (curID == NULL) {
2584                 *status = U_MEMORY_ALLOCATION_ERROR;
2585                 break;
2586             }
2587 
2588 #if U_CHARSET_FAMILY==U_ASCII_FAMILY
2589             ures_getUTF8StringByKey(&amp;curbndl, &quot;id&quot;, curID, &amp;curIDLength, TRUE, status);
2590             /* optimize - use the utf-8 string */
2591 #else
2592             {
2593                        const UChar* defString = ures_getStringByKey(&amp;curbndl, &quot;id&quot;, &amp;curIDLength, status);
2594                        if(U_SUCCESS(*status)) {
2595                if(curIDLength+1 &gt; ULOC_KEYWORDS_CAPACITY) {
2596                 *status = U_BUFFER_OVERFLOW_ERROR;
2597                } else {
<span class="line-modified">2598                                u_UCharsToChars(defString, curID, curIDLength+1);</span>
2599                }
2600                        }
2601             }
2602 #endif
2603 
2604             if (U_FAILURE(*status)) {
2605                 break;
2606             }
2607             UBool hasTo = FALSE;
2608             ures_getByKey(&amp;curbndl, &quot;to&quot;, &amp;to, status);
2609             if (U_FAILURE(*status)) {
2610                 // Do nothing here...
2611                 *status = U_ZERO_ERROR;
2612             } else {
2613                 hasTo = TRUE;
2614             }
2615             if (isPrefRegion &amp;&amp; !hasTo &amp;&amp; !ulist_containsString(values, curID, (int32_t)uprv_strlen(curID))) {
2616                 // Currently active currency for the target country
2617                 ulist_addItemEndList(values, curID, TRUE, status);
2618             } else if (!ulist_containsString(otherValues, curID, (int32_t)uprv_strlen(curID)) &amp;&amp; !commonlyUsed) {
</pre>
</td>
</tr>
</table>
<center><a href="ucol_swp.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="udata.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>