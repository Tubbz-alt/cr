<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/localpointer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="icuplug.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="locdspnm.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/localpointer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25  *
 26  * These classes are inspired by
 27  * - std::auto_ptr
 28  * - boost::scoped_ptr &amp; boost::scoped_array
 29  * - Taligent Safe Pointers (TOnlyPointerTo)
 30  *
 31  * but none of those provide for all of the goals for ICU smart pointers:
 32  * - Smart pointer owns the object and releases it when it goes out of scope.
 33  * - No transfer of ownership via copy/assignment to reduce misuse. Simpler &amp; more robust.
 34  * - ICU-compatible: No exceptions.
 35  * - Need to be able to orphan/release the pointer and its ownership.
 36  * - Need variants for normal C++ object pointers, C++ arrays, and ICU C service objects.
 37  *
 38  * For details see http://site.icu-project.org/design/cpp/scoped_ptr
 39  */
 40 
 41 #include &quot;unicode/utypes.h&quot;
 42 
 43 #if U_SHOW_CPLUSPLUS_API
 44 


 45 U_NAMESPACE_BEGIN
 46 
 47 /**
 48  * &quot;Smart pointer&quot; base class; do not use directly: use LocalPointer etc.
 49  *
 50  * Base class for smart pointer classes that do not throw exceptions.
 51  *
 52  * Do not use this base class directly, since it does not delete its pointer.
 53  * A subclass must implement methods that delete the pointer:
 54  * Destructor and adoptInstead().
 55  *
 56  * There is no operator T *() provided because the programmer must decide
 57  * whether to use getAlias() (without transfer of ownership) or orphan()
 58  * (with transfer of ownership and NULLing of the pointer).
 59  *
 60  * @see LocalPointer
 61  * @see LocalArray
 62  * @see U_DEFINE_LOCAL_OPEN_POINTER
 63  * @stable ICU 4.4
 64  */







 68     /**
 69      * Constructor takes ownership.
 70      * @param p simple pointer to an object that is adopted
 71      * @stable ICU 4.4
 72      */
 73     explicit LocalPointerBase(T *p=NULL) : ptr(p) {}
 74     /**
 75      * Destructor deletes the object it owns.
 76      * Subclass must override: Base class does nothing.
 77      * @stable ICU 4.4
 78      */
 79     ~LocalPointerBase() { /* delete ptr; */ }
 80     /**
 81      * NULL check.
 82      * @return TRUE if ==NULL
 83      * @stable ICU 4.4
 84      */
 85     UBool isNull() const { return ptr==NULL; }
 86     /**
 87      * NULL check.
</pre>
<hr />
<pre>
141      * @param p simple pointer to an object that is adopted
142      * @stable ICU 4.4
143      */
144     void adoptInstead(T *p) {
145         // delete ptr;
146         ptr=p;
147     }
148 protected:
149     /**
150      * Actual pointer.
151      * @internal
152      */
153     T *ptr;
154 private:
155     // No comparison operators with other LocalPointerBases.
156     bool operator==(const LocalPointerBase&lt;T&gt; &amp;other);
157     bool operator!=(const LocalPointerBase&lt;T&gt; &amp;other);
158     // No ownership sharing: No copy constructor, no assignment operator.
159     LocalPointerBase(const LocalPointerBase&lt;T&gt; &amp;other);
160     void operator=(const LocalPointerBase&lt;T&gt; &amp;other);
<span class="line-removed">161     // No heap allocation. Use only on the stack.</span>
<span class="line-removed">162     static void * U_EXPORT2 operator new(size_t size);</span>
<span class="line-removed">163     static void * U_EXPORT2 operator new[](size_t size);</span>
<span class="line-removed">164 #if U_HAVE_PLACEMENT_NEW</span>
<span class="line-removed">165     static void * U_EXPORT2 operator new(size_t, void *ptr);</span>
<span class="line-removed">166 #endif</span>
167 };
168 
169 /**
170  * &quot;Smart pointer&quot; class, deletes objects via the standard C++ delete operator.
171  * For most methods see the LocalPointerBase base class.
172  *
173  * Usage example:
174  * \code
175  * LocalPointer&lt;UnicodeString&gt; s(new UnicodeString((UChar32)0x50005));
176  * int32_t length=s-&gt;length();  // 2
177  * char16_t lead=s-&gt;charAt(0);  // 0xd900
178  * if(some condition) { return; }  // no need to explicitly delete the pointer
179  * s.adoptInstead(new UnicodeString((char16_t)0xfffc));
180  * length=s-&gt;length();  // 1
181  * // no need to explicitly delete the pointer
182  * \endcode
183  *
184  * @see LocalPointerBase
185  * @stable ICU 4.4
186  */
</pre>
<hr />
<pre>
204      * and not also separately for isNull().
205      *
206      * @param p simple pointer to an object that is adopted
207      * @param errorCode in/out UErrorCode, set to U_MEMORY_ALLOCATION_ERROR
208      *     if p==NULL and no other failure code had been set
209      * @stable ICU 55
210      */
211     LocalPointer(T *p, UErrorCode &amp;errorCode) : LocalPointerBase&lt;T&gt;(p) {
212         if(p==NULL &amp;&amp; U_SUCCESS(errorCode)) {
213             errorCode=U_MEMORY_ALLOCATION_ERROR;
214         }
215     }
216     /**
217      * Move constructor, leaves src with isNull().
218      * @param src source smart pointer
219      * @stable ICU 56
220      */
221     LocalPointer(LocalPointer&lt;T&gt; &amp;&amp;src) U_NOEXCEPT : LocalPointerBase&lt;T&gt;(src.ptr) {
222         src.ptr=NULL;
223     }
















224     /**
225      * Destructor deletes the object it owns.
226      * @stable ICU 4.4
227      */
228     ~LocalPointer() {
229         delete LocalPointerBase&lt;T&gt;::ptr;
230     }
231     /**
232      * Move assignment operator, leaves src with isNull().
233      * The behavior is undefined if *this and src are the same object.
234      * @param src source smart pointer
235      * @return *this
236      * @stable ICU 56
237      */
238     LocalPointer&lt;T&gt; &amp;operator=(LocalPointer&lt;T&gt; &amp;&amp;src) U_NOEXCEPT {
<span class="line-modified">239         return moveFrom(src);</span>



240     }
<span class="line-modified">241     // do not use #ifndef U_HIDE_DRAFT_API for moveFrom, needed by non-draft API</span>

242     /**
<span class="line-modified">243      * Move assignment, leaves src with isNull().</span>
<span class="line-modified">244      * The behavior is undefined if *this and src are the same object.</span>
245      *
<span class="line-modified">246      * Can be called explicitly, does not need C++11 support.</span>
<span class="line-removed">247      * @param src source smart pointer</span>
248      * @return *this
<span class="line-modified">249      * @draft ICU 56</span>
250      */
<span class="line-modified">251     LocalPointer&lt;T&gt; &amp;moveFrom(LocalPointer&lt;T&gt; &amp;src) U_NOEXCEPT {</span>
<span class="line-modified">252         delete LocalPointerBase&lt;T&gt;::ptr;</span>
<span class="line-removed">253         LocalPointerBase&lt;T&gt;::ptr=src.ptr;</span>
<span class="line-removed">254         src.ptr=NULL;</span>
255         return *this;
256     }


257     /**
258      * Swap pointers.
259      * @param other other smart pointer
260      * @stable ICU 56
261      */
262     void swap(LocalPointer&lt;T&gt; &amp;other) U_NOEXCEPT {
263         T *temp=LocalPointerBase&lt;T&gt;::ptr;
264         LocalPointerBase&lt;T&gt;::ptr=other.ptr;
265         other.ptr=temp;
266     }
267     /**
268      * Non-member LocalPointer swap function.
269      * @param p1 will get p2&#39;s pointer
270      * @param p2 will get p1&#39;s pointer
271      * @stable ICU 56
272      */
273     friend inline void swap(LocalPointer&lt;T&gt; &amp;p1, LocalPointer&lt;T&gt; &amp;p2) U_NOEXCEPT {
274         p1.swap(p2);
275     }
276     /**
</pre>
<hr />
<pre>
292      * If U_SUCCESS(errorCode) but the input pointer is NULL,
293      * then U_MEMORY_ALLOCATION_ERROR is set,
294      * the current object is deleted, and NULL is set.
295      *
296      * @param p simple pointer to an object that is adopted
297      * @param errorCode in/out UErrorCode, set to U_MEMORY_ALLOCATION_ERROR
298      *     if p==NULL and no other failure code had been set
299      * @stable ICU 55
300      */
301     void adoptInsteadAndCheckErrorCode(T *p, UErrorCode &amp;errorCode) {
302         if(U_SUCCESS(errorCode)) {
303             delete LocalPointerBase&lt;T&gt;::ptr;
304             LocalPointerBase&lt;T&gt;::ptr=p;
305             if(p==NULL) {
306                 errorCode=U_MEMORY_ALLOCATION_ERROR;
307             }
308         } else {
309             delete p;
310         }
311     }

















312 };
313 
314 /**
315  * &quot;Smart pointer&quot; class, deletes objects via the C++ array delete[] operator.
316  * For most methods see the LocalPointerBase base class.
317  * Adds operator[] for array item access.
318  *
319  * Usage example:
320  * \code
321  * LocalArray&lt;UnicodeString&gt; a(new UnicodeString[2]);
322  * a[0].append((char16_t)0x61);
323  * if(some condition) { return; }  // no need to explicitly delete the array
324  * a.adoptInstead(new UnicodeString[4]);
325  * a[3].append((char16_t)0x62).append((char16_t)0x63).reverse();
326  * // no need to explicitly delete the array
327  * \endcode
328  *
329  * @see LocalPointerBase
330  * @stable ICU 4.4
331  */
</pre>
<hr />
<pre>
349      * and not also separately for isNull().
350      *
351      * @param p simple pointer to an array of T objects that is adopted
352      * @param errorCode in/out UErrorCode, set to U_MEMORY_ALLOCATION_ERROR
353      *     if p==NULL and no other failure code had been set
354      * @stable ICU 56
355      */
356     LocalArray(T *p, UErrorCode &amp;errorCode) : LocalPointerBase&lt;T&gt;(p) {
357         if(p==NULL &amp;&amp; U_SUCCESS(errorCode)) {
358             errorCode=U_MEMORY_ALLOCATION_ERROR;
359         }
360     }
361     /**
362      * Move constructor, leaves src with isNull().
363      * @param src source smart pointer
364      * @stable ICU 56
365      */
366     LocalArray(LocalArray&lt;T&gt; &amp;&amp;src) U_NOEXCEPT : LocalPointerBase&lt;T&gt;(src.ptr) {
367         src.ptr=NULL;
368     }
















369     /**
370      * Destructor deletes the array it owns.
371      * @stable ICU 4.4
372      */
373     ~LocalArray() {
374         delete[] LocalPointerBase&lt;T&gt;::ptr;
375     }
376     /**
377      * Move assignment operator, leaves src with isNull().
378      * The behavior is undefined if *this and src are the same object.
379      * @param src source smart pointer
380      * @return *this
381      * @stable ICU 56
382      */
383     LocalArray&lt;T&gt; &amp;operator=(LocalArray&lt;T&gt; &amp;&amp;src) U_NOEXCEPT {
<span class="line-modified">384         return moveFrom(src);</span>



385     }
<span class="line-modified">386     // do not use #ifndef U_HIDE_DRAFT_API for moveFrom, needed by non-draft API</span>

387     /**
<span class="line-modified">388      * Move assignment, leaves src with isNull().</span>
<span class="line-modified">389      * The behavior is undefined if *this and src are the same object.</span>
390      *
<span class="line-modified">391      * Can be called explicitly, does not need C++11 support.</span>
<span class="line-removed">392      * @param src source smart pointer</span>
393      * @return *this
<span class="line-modified">394      * @draft ICU 56</span>
395      */
<span class="line-modified">396     LocalArray&lt;T&gt; &amp;moveFrom(LocalArray&lt;T&gt; &amp;src) U_NOEXCEPT {</span>
<span class="line-modified">397         delete[] LocalPointerBase&lt;T&gt;::ptr;</span>
<span class="line-removed">398         LocalPointerBase&lt;T&gt;::ptr=src.ptr;</span>
<span class="line-removed">399         src.ptr=NULL;</span>
400         return *this;
401     }


402     /**
403      * Swap pointers.
404      * @param other other smart pointer
405      * @stable ICU 56
406      */
407     void swap(LocalArray&lt;T&gt; &amp;other) U_NOEXCEPT {
408         T *temp=LocalPointerBase&lt;T&gt;::ptr;
409         LocalPointerBase&lt;T&gt;::ptr=other.ptr;
410         other.ptr=temp;
411     }
412     /**
413      * Non-member LocalArray swap function.
414      * @param p1 will get p2&#39;s pointer
415      * @param p2 will get p1&#39;s pointer
416      * @stable ICU 56
417      */
418     friend inline void swap(LocalArray&lt;T&gt; &amp;p1, LocalArray&lt;T&gt; &amp;p2) U_NOEXCEPT {
419         p1.swap(p2);
420     }
421     /**
</pre>
<hr />
<pre>
445      */
446     void adoptInsteadAndCheckErrorCode(T *p, UErrorCode &amp;errorCode) {
447         if(U_SUCCESS(errorCode)) {
448             delete[] LocalPointerBase&lt;T&gt;::ptr;
449             LocalPointerBase&lt;T&gt;::ptr=p;
450             if(p==NULL) {
451                 errorCode=U_MEMORY_ALLOCATION_ERROR;
452             }
453         } else {
454             delete[] p;
455         }
456     }
457     /**
458      * Array item access (writable).
459      * No index bounds check.
460      * @param i array index
461      * @return reference to the array item
462      * @stable ICU 4.4
463      */
464     T &amp;operator[](ptrdiff_t i) const { return LocalPointerBase&lt;T&gt;::ptr[i]; }

















465 };
466 
467 /**
468  * \def U_DEFINE_LOCAL_OPEN_POINTER
469  * &quot;Smart pointer&quot; definition macro, deletes objects via the closeFunction.
470  * Defines a subclass of LocalPointerBase which works just
471  * like LocalPointer&lt;Type&gt; except that this subclass will use the closeFunction
472  * rather than the C++ delete operator.
473  *
474  * Usage example:
475  * \code
476  * LocalUCaseMapPointer csm(ucasemap_open(localeID, options, &amp;errorCode));
477  * utf8OutLength=ucasemap_utf8ToLower(csm.getAlias(),
478  *     utf8Out, (int32_t)sizeof(utf8Out),
479  *     utf8In, utf8InLength, &amp;errorCode);
480  * if(U_FAILURE(errorCode)) { return; }  // no need to explicitly delete the UCaseMap
481  * \endcode
482  *
483  * @see LocalPointerBase
484  * @see LocalPointer
485  * @stable ICU 4.4
486  */
487 #define U_DEFINE_LOCAL_OPEN_POINTER(LocalPointerClassName, Type, closeFunction) \
488     class LocalPointerClassName : public LocalPointerBase&lt;Type&gt; { \
489     public: \
490         using LocalPointerBase&lt;Type&gt;::operator*; \
491         using LocalPointerBase&lt;Type&gt;::operator-&gt;; \
492         explicit LocalPointerClassName(Type *p=NULL) : LocalPointerBase&lt;Type&gt;(p) {} \
493         LocalPointerClassName(LocalPointerClassName &amp;&amp;src) U_NOEXCEPT \
494                 : LocalPointerBase&lt;Type&gt;(src.ptr) { \
495             src.ptr=NULL; \
496         } \



497         ~LocalPointerClassName() { if (ptr != NULL) { closeFunction(ptr); } } \
498         LocalPointerClassName &amp;operator=(LocalPointerClassName &amp;&amp;src) U_NOEXCEPT { \
<span class="line-removed">499             return moveFrom(src); \</span>
<span class="line-removed">500         } \</span>
<span class="line-removed">501         LocalPointerClassName &amp;moveFrom(LocalPointerClassName &amp;src) U_NOEXCEPT { \</span>
502             if (ptr != NULL) { closeFunction(ptr); } \
503             LocalPointerBase&lt;Type&gt;::ptr=src.ptr; \
504             src.ptr=NULL; \
505             return *this; \
506         } \





507         void swap(LocalPointerClassName &amp;other) U_NOEXCEPT { \
508             Type *temp=LocalPointerBase&lt;Type&gt;::ptr; \
509             LocalPointerBase&lt;Type&gt;::ptr=other.ptr; \
510             other.ptr=temp; \
511         } \
512         friend inline void swap(LocalPointerClassName &amp;p1, LocalPointerClassName &amp;p2) U_NOEXCEPT { \
513             p1.swap(p2); \
514         } \
515         void adoptInstead(Type *p) { \
516             if (ptr != NULL) { closeFunction(ptr); } \
517             ptr=p; \
518         } \



519     }
520 
521 U_NAMESPACE_END
522 
523 #endif  /* U_SHOW_CPLUSPLUS_API */
524 #endif  /* __LOCALPOINTER_H__ */
</pre>
</td>
<td>
<hr />
<pre>
 25  *
 26  * These classes are inspired by
 27  * - std::auto_ptr
 28  * - boost::scoped_ptr &amp; boost::scoped_array
 29  * - Taligent Safe Pointers (TOnlyPointerTo)
 30  *
 31  * but none of those provide for all of the goals for ICU smart pointers:
 32  * - Smart pointer owns the object and releases it when it goes out of scope.
 33  * - No transfer of ownership via copy/assignment to reduce misuse. Simpler &amp; more robust.
 34  * - ICU-compatible: No exceptions.
 35  * - Need to be able to orphan/release the pointer and its ownership.
 36  * - Need variants for normal C++ object pointers, C++ arrays, and ICU C service objects.
 37  *
 38  * For details see http://site.icu-project.org/design/cpp/scoped_ptr
 39  */
 40 
 41 #include &quot;unicode/utypes.h&quot;
 42 
 43 #if U_SHOW_CPLUSPLUS_API
 44 
<span class="line-added"> 45 #include &lt;memory&gt;</span>
<span class="line-added"> 46 </span>
 47 U_NAMESPACE_BEGIN
 48 
 49 /**
 50  * &quot;Smart pointer&quot; base class; do not use directly: use LocalPointer etc.
 51  *
 52  * Base class for smart pointer classes that do not throw exceptions.
 53  *
 54  * Do not use this base class directly, since it does not delete its pointer.
 55  * A subclass must implement methods that delete the pointer:
 56  * Destructor and adoptInstead().
 57  *
 58  * There is no operator T *() provided because the programmer must decide
 59  * whether to use getAlias() (without transfer of ownership) or orphan()
 60  * (with transfer of ownership and NULLing of the pointer).
 61  *
 62  * @see LocalPointer
 63  * @see LocalArray
 64  * @see U_DEFINE_LOCAL_OPEN_POINTER
 65  * @stable ICU 4.4
 66  */
<span class="line-added"> 70     // No heap allocation. Use only on the stack.</span>
<span class="line-added"> 71     static void* U_EXPORT2 operator new(size_t) = delete;</span>
<span class="line-added"> 72     static void* U_EXPORT2 operator new[](size_t) = delete;</span>
<span class="line-added"> 73 #if U_HAVE_PLACEMENT_NEW</span>
<span class="line-added"> 74     static void* U_EXPORT2 operator new(size_t, void*) = delete;</span>
<span class="line-added"> 75 #endif</span>
<span class="line-added"> 76 </span>
 77     /**
 78      * Constructor takes ownership.
 79      * @param p simple pointer to an object that is adopted
 80      * @stable ICU 4.4
 81      */
 82     explicit LocalPointerBase(T *p=NULL) : ptr(p) {}
 83     /**
 84      * Destructor deletes the object it owns.
 85      * Subclass must override: Base class does nothing.
 86      * @stable ICU 4.4
 87      */
 88     ~LocalPointerBase() { /* delete ptr; */ }
 89     /**
 90      * NULL check.
 91      * @return TRUE if ==NULL
 92      * @stable ICU 4.4
 93      */
 94     UBool isNull() const { return ptr==NULL; }
 95     /**
 96      * NULL check.
</pre>
<hr />
<pre>
150      * @param p simple pointer to an object that is adopted
151      * @stable ICU 4.4
152      */
153     void adoptInstead(T *p) {
154         // delete ptr;
155         ptr=p;
156     }
157 protected:
158     /**
159      * Actual pointer.
160      * @internal
161      */
162     T *ptr;
163 private:
164     // No comparison operators with other LocalPointerBases.
165     bool operator==(const LocalPointerBase&lt;T&gt; &amp;other);
166     bool operator!=(const LocalPointerBase&lt;T&gt; &amp;other);
167     // No ownership sharing: No copy constructor, no assignment operator.
168     LocalPointerBase(const LocalPointerBase&lt;T&gt; &amp;other);
169     void operator=(const LocalPointerBase&lt;T&gt; &amp;other);






170 };
171 
172 /**
173  * &quot;Smart pointer&quot; class, deletes objects via the standard C++ delete operator.
174  * For most methods see the LocalPointerBase base class.
175  *
176  * Usage example:
177  * \code
178  * LocalPointer&lt;UnicodeString&gt; s(new UnicodeString((UChar32)0x50005));
179  * int32_t length=s-&gt;length();  // 2
180  * char16_t lead=s-&gt;charAt(0);  // 0xd900
181  * if(some condition) { return; }  // no need to explicitly delete the pointer
182  * s.adoptInstead(new UnicodeString((char16_t)0xfffc));
183  * length=s-&gt;length();  // 1
184  * // no need to explicitly delete the pointer
185  * \endcode
186  *
187  * @see LocalPointerBase
188  * @stable ICU 4.4
189  */
</pre>
<hr />
<pre>
207      * and not also separately for isNull().
208      *
209      * @param p simple pointer to an object that is adopted
210      * @param errorCode in/out UErrorCode, set to U_MEMORY_ALLOCATION_ERROR
211      *     if p==NULL and no other failure code had been set
212      * @stable ICU 55
213      */
214     LocalPointer(T *p, UErrorCode &amp;errorCode) : LocalPointerBase&lt;T&gt;(p) {
215         if(p==NULL &amp;&amp; U_SUCCESS(errorCode)) {
216             errorCode=U_MEMORY_ALLOCATION_ERROR;
217         }
218     }
219     /**
220      * Move constructor, leaves src with isNull().
221      * @param src source smart pointer
222      * @stable ICU 56
223      */
224     LocalPointer(LocalPointer&lt;T&gt; &amp;&amp;src) U_NOEXCEPT : LocalPointerBase&lt;T&gt;(src.ptr) {
225         src.ptr=NULL;
226     }
<span class="line-added">227 </span>
<span class="line-added">228 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added">229     /**</span>
<span class="line-added">230      * Constructs a LocalPointer from a C++11 std::unique_ptr.</span>
<span class="line-added">231      * The LocalPointer steals the object owned by the std::unique_ptr.</span>
<span class="line-added">232      *</span>
<span class="line-added">233      * This constructor works via move semantics. If your std::unique_ptr is</span>
<span class="line-added">234      * in a local variable, you must use std::move.</span>
<span class="line-added">235      *</span>
<span class="line-added">236      * @param p The std::unique_ptr from which the pointer will be stolen.</span>
<span class="line-added">237      * @draft ICU 64</span>
<span class="line-added">238      */</span>
<span class="line-added">239     explicit LocalPointer(std::unique_ptr&lt;T&gt; &amp;&amp;p)</span>
<span class="line-added">240         : LocalPointerBase&lt;T&gt;(p.release()) {}</span>
<span class="line-added">241 #endif  /* U_HIDE_DRAFT_API */</span>
<span class="line-added">242 </span>
243     /**
244      * Destructor deletes the object it owns.
245      * @stable ICU 4.4
246      */
247     ~LocalPointer() {
248         delete LocalPointerBase&lt;T&gt;::ptr;
249     }
250     /**
251      * Move assignment operator, leaves src with isNull().
252      * The behavior is undefined if *this and src are the same object.
253      * @param src source smart pointer
254      * @return *this
255      * @stable ICU 56
256      */
257     LocalPointer&lt;T&gt; &amp;operator=(LocalPointer&lt;T&gt; &amp;&amp;src) U_NOEXCEPT {
<span class="line-modified">258         delete LocalPointerBase&lt;T&gt;::ptr;</span>
<span class="line-added">259         LocalPointerBase&lt;T&gt;::ptr=src.ptr;</span>
<span class="line-added">260         src.ptr=NULL;</span>
<span class="line-added">261         return *this;</span>
262     }
<span class="line-modified">263 </span>
<span class="line-added">264 #ifndef U_HIDE_DRAFT_API</span>
265     /**
<span class="line-modified">266      * Move-assign from an std::unique_ptr to this LocalPointer.</span>
<span class="line-modified">267      * Steals the pointer from the std::unique_ptr.</span>
268      *
<span class="line-modified">269      * @param p The std::unique_ptr from which the pointer will be stolen.</span>

270      * @return *this
<span class="line-modified">271      * @draft ICU 64</span>
272      */
<span class="line-modified">273     LocalPointer&lt;T&gt; &amp;operator=(std::unique_ptr&lt;T&gt; &amp;&amp;p) U_NOEXCEPT {</span>
<span class="line-modified">274         adoptInstead(p.release());</span>


275         return *this;
276     }
<span class="line-added">277 #endif  /* U_HIDE_DRAFT_API */</span>
<span class="line-added">278 </span>
279     /**
280      * Swap pointers.
281      * @param other other smart pointer
282      * @stable ICU 56
283      */
284     void swap(LocalPointer&lt;T&gt; &amp;other) U_NOEXCEPT {
285         T *temp=LocalPointerBase&lt;T&gt;::ptr;
286         LocalPointerBase&lt;T&gt;::ptr=other.ptr;
287         other.ptr=temp;
288     }
289     /**
290      * Non-member LocalPointer swap function.
291      * @param p1 will get p2&#39;s pointer
292      * @param p2 will get p1&#39;s pointer
293      * @stable ICU 56
294      */
295     friend inline void swap(LocalPointer&lt;T&gt; &amp;p1, LocalPointer&lt;T&gt; &amp;p2) U_NOEXCEPT {
296         p1.swap(p2);
297     }
298     /**
</pre>
<hr />
<pre>
314      * If U_SUCCESS(errorCode) but the input pointer is NULL,
315      * then U_MEMORY_ALLOCATION_ERROR is set,
316      * the current object is deleted, and NULL is set.
317      *
318      * @param p simple pointer to an object that is adopted
319      * @param errorCode in/out UErrorCode, set to U_MEMORY_ALLOCATION_ERROR
320      *     if p==NULL and no other failure code had been set
321      * @stable ICU 55
322      */
323     void adoptInsteadAndCheckErrorCode(T *p, UErrorCode &amp;errorCode) {
324         if(U_SUCCESS(errorCode)) {
325             delete LocalPointerBase&lt;T&gt;::ptr;
326             LocalPointerBase&lt;T&gt;::ptr=p;
327             if(p==NULL) {
328                 errorCode=U_MEMORY_ALLOCATION_ERROR;
329             }
330         } else {
331             delete p;
332         }
333     }
<span class="line-added">334 </span>
<span class="line-added">335 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added">336     /**</span>
<span class="line-added">337      * Conversion operator to a C++11 std::unique_ptr.</span>
<span class="line-added">338      * Disowns the object and gives it to the returned std::unique_ptr.</span>
<span class="line-added">339      *</span>
<span class="line-added">340      * This operator works via move semantics. If your LocalPointer is</span>
<span class="line-added">341      * in a local variable, you must use std::move.</span>
<span class="line-added">342      *</span>
<span class="line-added">343      * @return An std::unique_ptr owning the pointer previously owned by this</span>
<span class="line-added">344      *         icu::LocalPointer.</span>
<span class="line-added">345      * @draft ICU 64</span>
<span class="line-added">346      */</span>
<span class="line-added">347     operator std::unique_ptr&lt;T&gt; () &amp;&amp; {</span>
<span class="line-added">348         return std::unique_ptr&lt;T&gt;(LocalPointerBase&lt;T&gt;::orphan());</span>
<span class="line-added">349     }</span>
<span class="line-added">350 #endif  /* U_HIDE_DRAFT_API */</span>
351 };
352 
353 /**
354  * &quot;Smart pointer&quot; class, deletes objects via the C++ array delete[] operator.
355  * For most methods see the LocalPointerBase base class.
356  * Adds operator[] for array item access.
357  *
358  * Usage example:
359  * \code
360  * LocalArray&lt;UnicodeString&gt; a(new UnicodeString[2]);
361  * a[0].append((char16_t)0x61);
362  * if(some condition) { return; }  // no need to explicitly delete the array
363  * a.adoptInstead(new UnicodeString[4]);
364  * a[3].append((char16_t)0x62).append((char16_t)0x63).reverse();
365  * // no need to explicitly delete the array
366  * \endcode
367  *
368  * @see LocalPointerBase
369  * @stable ICU 4.4
370  */
</pre>
<hr />
<pre>
388      * and not also separately for isNull().
389      *
390      * @param p simple pointer to an array of T objects that is adopted
391      * @param errorCode in/out UErrorCode, set to U_MEMORY_ALLOCATION_ERROR
392      *     if p==NULL and no other failure code had been set
393      * @stable ICU 56
394      */
395     LocalArray(T *p, UErrorCode &amp;errorCode) : LocalPointerBase&lt;T&gt;(p) {
396         if(p==NULL &amp;&amp; U_SUCCESS(errorCode)) {
397             errorCode=U_MEMORY_ALLOCATION_ERROR;
398         }
399     }
400     /**
401      * Move constructor, leaves src with isNull().
402      * @param src source smart pointer
403      * @stable ICU 56
404      */
405     LocalArray(LocalArray&lt;T&gt; &amp;&amp;src) U_NOEXCEPT : LocalPointerBase&lt;T&gt;(src.ptr) {
406         src.ptr=NULL;
407     }
<span class="line-added">408 </span>
<span class="line-added">409 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added">410     /**</span>
<span class="line-added">411      * Constructs a LocalArray from a C++11 std::unique_ptr of an array type.</span>
<span class="line-added">412      * The LocalPointer steals the array owned by the std::unique_ptr.</span>
<span class="line-added">413      *</span>
<span class="line-added">414      * This constructor works via move semantics. If your std::unique_ptr is</span>
<span class="line-added">415      * in a local variable, you must use std::move.</span>
<span class="line-added">416      *</span>
<span class="line-added">417      * @param p The std::unique_ptr from which the array will be stolen.</span>
<span class="line-added">418      * @draft ICU 64</span>
<span class="line-added">419      */</span>
<span class="line-added">420     explicit LocalArray(std::unique_ptr&lt;T[]&gt; &amp;&amp;p)</span>
<span class="line-added">421         : LocalPointerBase&lt;T&gt;(p.release()) {}</span>
<span class="line-added">422 #endif  /* U_HIDE_DRAFT_API */</span>
<span class="line-added">423 </span>
424     /**
425      * Destructor deletes the array it owns.
426      * @stable ICU 4.4
427      */
428     ~LocalArray() {
429         delete[] LocalPointerBase&lt;T&gt;::ptr;
430     }
431     /**
432      * Move assignment operator, leaves src with isNull().
433      * The behavior is undefined if *this and src are the same object.
434      * @param src source smart pointer
435      * @return *this
436      * @stable ICU 56
437      */
438     LocalArray&lt;T&gt; &amp;operator=(LocalArray&lt;T&gt; &amp;&amp;src) U_NOEXCEPT {
<span class="line-modified">439         delete[] LocalPointerBase&lt;T&gt;::ptr;</span>
<span class="line-added">440         LocalPointerBase&lt;T&gt;::ptr=src.ptr;</span>
<span class="line-added">441         src.ptr=NULL;</span>
<span class="line-added">442         return *this;</span>
443     }
<span class="line-modified">444 </span>
<span class="line-added">445 #ifndef U_HIDE_DRAFT_API</span>
446     /**
<span class="line-modified">447      * Move-assign from an std::unique_ptr to this LocalPointer.</span>
<span class="line-modified">448      * Steals the array from the std::unique_ptr.</span>
449      *
<span class="line-modified">450      * @param p The std::unique_ptr from which the array will be stolen.</span>

451      * @return *this
<span class="line-modified">452      * @draft ICU 64</span>
453      */
<span class="line-modified">454     LocalArray&lt;T&gt; &amp;operator=(std::unique_ptr&lt;T[]&gt; &amp;&amp;p) U_NOEXCEPT {</span>
<span class="line-modified">455         adoptInstead(p.release());</span>


456         return *this;
457     }
<span class="line-added">458 #endif  /* U_HIDE_DRAFT_API */</span>
<span class="line-added">459 </span>
460     /**
461      * Swap pointers.
462      * @param other other smart pointer
463      * @stable ICU 56
464      */
465     void swap(LocalArray&lt;T&gt; &amp;other) U_NOEXCEPT {
466         T *temp=LocalPointerBase&lt;T&gt;::ptr;
467         LocalPointerBase&lt;T&gt;::ptr=other.ptr;
468         other.ptr=temp;
469     }
470     /**
471      * Non-member LocalArray swap function.
472      * @param p1 will get p2&#39;s pointer
473      * @param p2 will get p1&#39;s pointer
474      * @stable ICU 56
475      */
476     friend inline void swap(LocalArray&lt;T&gt; &amp;p1, LocalArray&lt;T&gt; &amp;p2) U_NOEXCEPT {
477         p1.swap(p2);
478     }
479     /**
</pre>
<hr />
<pre>
503      */
504     void adoptInsteadAndCheckErrorCode(T *p, UErrorCode &amp;errorCode) {
505         if(U_SUCCESS(errorCode)) {
506             delete[] LocalPointerBase&lt;T&gt;::ptr;
507             LocalPointerBase&lt;T&gt;::ptr=p;
508             if(p==NULL) {
509                 errorCode=U_MEMORY_ALLOCATION_ERROR;
510             }
511         } else {
512             delete[] p;
513         }
514     }
515     /**
516      * Array item access (writable).
517      * No index bounds check.
518      * @param i array index
519      * @return reference to the array item
520      * @stable ICU 4.4
521      */
522     T &amp;operator[](ptrdiff_t i) const { return LocalPointerBase&lt;T&gt;::ptr[i]; }
<span class="line-added">523 </span>
<span class="line-added">524 #ifndef U_HIDE_DRAFT_API</span>
<span class="line-added">525     /**</span>
<span class="line-added">526      * Conversion operator to a C++11 std::unique_ptr.</span>
<span class="line-added">527      * Disowns the object and gives it to the returned std::unique_ptr.</span>
<span class="line-added">528      *</span>
<span class="line-added">529      * This operator works via move semantics. If your LocalPointer is</span>
<span class="line-added">530      * in a local variable, you must use std::move.</span>
<span class="line-added">531      *</span>
<span class="line-added">532      * @return An std::unique_ptr owning the pointer previously owned by this</span>
<span class="line-added">533      *         icu::LocalPointer.</span>
<span class="line-added">534      * @draft ICU 64</span>
<span class="line-added">535      */</span>
<span class="line-added">536     operator std::unique_ptr&lt;T[]&gt; () &amp;&amp; {</span>
<span class="line-added">537         return std::unique_ptr&lt;T[]&gt;(LocalPointerBase&lt;T&gt;::orphan());</span>
<span class="line-added">538     }</span>
<span class="line-added">539 #endif  /* U_HIDE_DRAFT_API */</span>
540 };
541 
542 /**
543  * \def U_DEFINE_LOCAL_OPEN_POINTER
544  * &quot;Smart pointer&quot; definition macro, deletes objects via the closeFunction.
545  * Defines a subclass of LocalPointerBase which works just
546  * like LocalPointer&lt;Type&gt; except that this subclass will use the closeFunction
547  * rather than the C++ delete operator.
548  *
549  * Usage example:
550  * \code
551  * LocalUCaseMapPointer csm(ucasemap_open(localeID, options, &amp;errorCode));
552  * utf8OutLength=ucasemap_utf8ToLower(csm.getAlias(),
553  *     utf8Out, (int32_t)sizeof(utf8Out),
554  *     utf8In, utf8InLength, &amp;errorCode);
555  * if(U_FAILURE(errorCode)) { return; }  // no need to explicitly delete the UCaseMap
556  * \endcode
557  *
558  * @see LocalPointerBase
559  * @see LocalPointer
560  * @stable ICU 4.4
561  */
562 #define U_DEFINE_LOCAL_OPEN_POINTER(LocalPointerClassName, Type, closeFunction) \
563     class LocalPointerClassName : public LocalPointerBase&lt;Type&gt; { \
564     public: \
565         using LocalPointerBase&lt;Type&gt;::operator*; \
566         using LocalPointerBase&lt;Type&gt;::operator-&gt;; \
567         explicit LocalPointerClassName(Type *p=NULL) : LocalPointerBase&lt;Type&gt;(p) {} \
568         LocalPointerClassName(LocalPointerClassName &amp;&amp;src) U_NOEXCEPT \
569                 : LocalPointerBase&lt;Type&gt;(src.ptr) { \
570             src.ptr=NULL; \
571         } \
<span class="line-added">572         /* TODO: Be agnostic of the deleter function signature from the user-provided std::unique_ptr? */ \</span>
<span class="line-added">573         explicit LocalPointerClassName(std::unique_ptr&lt;Type, decltype(&amp;closeFunction)&gt; &amp;&amp;p) \</span>
<span class="line-added">574                 : LocalPointerBase&lt;Type&gt;(p.release()) {} \</span>
575         ~LocalPointerClassName() { if (ptr != NULL) { closeFunction(ptr); } } \
576         LocalPointerClassName &amp;operator=(LocalPointerClassName &amp;&amp;src) U_NOEXCEPT { \



577             if (ptr != NULL) { closeFunction(ptr); } \
578             LocalPointerBase&lt;Type&gt;::ptr=src.ptr; \
579             src.ptr=NULL; \
580             return *this; \
581         } \
<span class="line-added">582         /* TODO: Be agnostic of the deleter function signature from the user-provided std::unique_ptr? */ \</span>
<span class="line-added">583         LocalPointerClassName &amp;operator=(std::unique_ptr&lt;Type, decltype(&amp;closeFunction)&gt; &amp;&amp;p) { \</span>
<span class="line-added">584             adoptInstead(p.release()); \</span>
<span class="line-added">585             return *this; \</span>
<span class="line-added">586         } \</span>
587         void swap(LocalPointerClassName &amp;other) U_NOEXCEPT { \
588             Type *temp=LocalPointerBase&lt;Type&gt;::ptr; \
589             LocalPointerBase&lt;Type&gt;::ptr=other.ptr; \
590             other.ptr=temp; \
591         } \
592         friend inline void swap(LocalPointerClassName &amp;p1, LocalPointerClassName &amp;p2) U_NOEXCEPT { \
593             p1.swap(p2); \
594         } \
595         void adoptInstead(Type *p) { \
596             if (ptr != NULL) { closeFunction(ptr); } \
597             ptr=p; \
598         } \
<span class="line-added">599         operator std::unique_ptr&lt;Type, decltype(&amp;closeFunction)&gt; () &amp;&amp; { \</span>
<span class="line-added">600             return std::unique_ptr&lt;Type, decltype(&amp;closeFunction)&gt;(LocalPointerBase&lt;Type&gt;::orphan(), closeFunction); \</span>
<span class="line-added">601         } \</span>
602     }
603 
604 U_NAMESPACE_END
605 
606 #endif  /* U_SHOW_CPLUSPLUS_API */
607 #endif  /* __LOCALPOINTER_H__ */
</pre>
</td>
</tr>
</table>
<center><a href="icuplug.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="locdspnm.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>