<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/rulebasedcollator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="rematch.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="scriptset.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/rulebasedcollator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 747     const uint8_t *rightBytes = reinterpret_cast&lt;const uint8_t *&gt;(right.data());
 748     if((leftBytes == NULL &amp;&amp; !left.empty()) || (rightBytes == NULL &amp;&amp; !right.empty())) {
 749         errorCode = U_ILLEGAL_ARGUMENT_ERROR;
 750         return UCOL_EQUAL;
 751     }
 752     return doCompare(leftBytes, left.length(), rightBytes, right.length(), errorCode);
 753 }
 754 
 755 UCollationResult
 756 RuleBasedCollator::internalCompareUTF8(const char *left, int32_t leftLength,
 757                                        const char *right, int32_t rightLength,
 758                                        UErrorCode &amp;errorCode) const {
 759     if(U_FAILURE(errorCode)) { return UCOL_EQUAL; }
 760     if((left == NULL &amp;&amp; leftLength != 0) || (right == NULL &amp;&amp; rightLength != 0)) {
 761         errorCode = U_ILLEGAL_ARGUMENT_ERROR;
 762         return UCOL_EQUAL;
 763     }
 764     // Make sure both or neither strings have a known length.
 765     // We do not optimize for mixed length/termination.
 766     if(leftLength &gt;= 0) {
<span class="line-modified"> 767         if(rightLength &lt; 0) { rightLength = uprv_strlen(right); }</span>
 768     } else {
<span class="line-modified"> 769         if(rightLength &gt;= 0) { leftLength = uprv_strlen(left); }</span>
 770     }
 771     return doCompare(reinterpret_cast&lt;const uint8_t *&gt;(left), leftLength,
 772                      reinterpret_cast&lt;const uint8_t *&gt;(right), rightLength, errorCode);
 773 }
 774 
 775 namespace {
 776 
 777 /**
 778  * Abstract iterator for identical-level string comparisons.
 779  * Returns FCD code points and handles temporary switching to NFD.
 780  */
 781 class NFDIterator : public UObject {
 782 public:
 783     NFDIterator() : index(-1), length(0) {}
 784     virtual ~NFDIterator() {}
 785     /**
 786      * Returns the next code point from the internal normalization buffer,
 787      * or else the next text code point.
 788      * Returns -1 at the end of the text.
 789      */
</pre>
<hr />
<pre>
 845         return c;
 846     }
 847 
 848     const UChar *s;
 849     const UChar *limit;
 850 };
 851 
 852 class FCDUTF16NFDIterator : public UTF16NFDIterator {
 853 public:
 854     FCDUTF16NFDIterator(const Normalizer2Impl &amp;nfcImpl, const UChar *text, const UChar *textLimit)
 855             : UTF16NFDIterator(NULL, NULL) {
 856         UErrorCode errorCode = U_ZERO_ERROR;
 857         const UChar *spanLimit = nfcImpl.makeFCD(text, textLimit, NULL, errorCode);
 858         if(U_FAILURE(errorCode)) { return; }
 859         if(spanLimit == textLimit || (textLimit == NULL &amp;&amp; *spanLimit == 0)) {
 860             s = text;
 861             limit = spanLimit;
 862         } else {
 863             str.setTo(text, (int32_t)(spanLimit - text));
 864             {
<span class="line-modified"> 865                 ReorderingBuffer buffer(nfcImpl, str);</span>
<span class="line-modified"> 866                 if(buffer.init(str.length(), errorCode)) {</span>
<span class="line-modified"> 867                     nfcImpl.makeFCD(spanLimit, textLimit, &amp;buffer, errorCode);</span>
 868                 }
 869             }
 870             if(U_SUCCESS(errorCode)) {
 871                 s = str.getBuffer();
 872                 limit = s + str.length();
 873             }
 874         }
 875     }
 876 private:
 877     UnicodeString str;
 878 };
 879 
 880 class UTF8NFDIterator : public NFDIterator {
 881 public:
 882     UTF8NFDIterator(const uint8_t *text, int32_t textLength)
 883         : s(text), pos(0), length(textLength) {}
 884 protected:
 885     virtual UChar32 nextRawCodePoint() {
 886         if(pos == length || (s[pos] == 0 &amp;&amp; length &lt; 0)) { return U_SENTINEL; }
 887         UChar32 c;
</pre>
<hr />
<pre>
1537 }  // namespace
1538 
1539 int32_t
1540 RuleBasedCollator::internalGetShortDefinitionString(const char *locale,
1541                                                     char *buffer, int32_t capacity,
1542                                                     UErrorCode &amp;errorCode) const {
1543     if(U_FAILURE(errorCode)) { return 0; }
1544     if(buffer == NULL ? capacity != 0 : capacity &lt; 0) {
1545         errorCode = U_ILLEGAL_ARGUMENT_ERROR;
1546         return 0;
1547     }
1548     if(locale == NULL) {
1549         locale = internalGetLocaleID(ULOC_VALID_LOCALE, errorCode);
1550     }
1551 
1552     char resultLocale[ULOC_FULLNAME_CAPACITY + 1];
1553     int32_t length = ucol_getFunctionalEquivalent(resultLocale, ULOC_FULLNAME_CAPACITY,
1554                                                   &quot;collation&quot;, locale,
1555                                                   NULL, &amp;errorCode);
1556     if(U_FAILURE(errorCode)) { return 0; }
<span class="line-modified">1557     if(length == 0) {</span>
<span class="line-removed">1558         uprv_strcpy(resultLocale, &quot;root&quot;);</span>
<span class="line-removed">1559     } else {</span>
<span class="line-removed">1560         resultLocale[length] = 0;</span>
<span class="line-removed">1561     }</span>
1562 
1563     // Append items in alphabetic order of their short definition letters.
1564     CharString result;
1565     char subtag[ULOC_KEYWORD_AND_VALUES_CAPACITY];
1566 
1567     if(attributeHasBeenSetExplicitly(UCOL_ALTERNATE_HANDLING)) {
1568         appendAttribute(result, &#39;A&#39;, getAttribute(UCOL_ALTERNATE_HANDLING, errorCode), errorCode);
1569     }
1570     // ATTR_VARIABLE_TOP not supported because &#39;B&#39; was broken.
1571     // See ICU tickets #10372 and #10386.
1572     if(attributeHasBeenSetExplicitly(UCOL_CASE_FIRST)) {
1573         appendAttribute(result, &#39;C&#39;, getAttribute(UCOL_CASE_FIRST, errorCode), errorCode);
1574     }
1575     if(attributeHasBeenSetExplicitly(UCOL_NUMERIC_COLLATION)) {
1576         appendAttribute(result, &#39;D&#39;, getAttribute(UCOL_NUMERIC_COLLATION, errorCode), errorCode);
1577     }
1578     if(attributeHasBeenSetExplicitly(UCOL_CASE_LEVEL)) {
1579         appendAttribute(result, &#39;E&#39;, getAttribute(UCOL_CASE_LEVEL, errorCode), errorCode);
1580     }
1581     if(attributeHasBeenSetExplicitly(UCOL_FRENCH_COLLATION)) {
1582         appendAttribute(result, &#39;F&#39;, getAttribute(UCOL_FRENCH_COLLATION, errorCode), errorCode);
1583     }
1584     // Note: UCOL_HIRAGANA_QUATERNARY_MODE is deprecated and never changes away from default.
1585     length = uloc_getKeywordValue(resultLocale, &quot;collation&quot;, subtag, UPRV_LENGTHOF(subtag), &amp;errorCode);
1586     appendSubtag(result, &#39;K&#39;, subtag, length, errorCode);
1587     length = uloc_getLanguage(resultLocale, subtag, UPRV_LENGTHOF(subtag), &amp;errorCode);
<span class="line-modified">1588     appendSubtag(result, &#39;L&#39;, subtag, length, errorCode);</span>




1589     if(attributeHasBeenSetExplicitly(UCOL_NORMALIZATION_MODE)) {
1590         appendAttribute(result, &#39;N&#39;, getAttribute(UCOL_NORMALIZATION_MODE, errorCode), errorCode);
1591     }
1592     length = uloc_getCountry(resultLocale, subtag, UPRV_LENGTHOF(subtag), &amp;errorCode);
1593     appendSubtag(result, &#39;R&#39;, subtag, length, errorCode);
1594     if(attributeHasBeenSetExplicitly(UCOL_STRENGTH)) {
1595         appendAttribute(result, &#39;S&#39;, getAttribute(UCOL_STRENGTH, errorCode), errorCode);
1596     }
1597     length = uloc_getVariant(resultLocale, subtag, UPRV_LENGTHOF(subtag), &amp;errorCode);
1598     appendSubtag(result, &#39;V&#39;, subtag, length, errorCode);
1599     length = uloc_getScript(resultLocale, subtag, UPRV_LENGTHOF(subtag), &amp;errorCode);
1600     appendSubtag(result, &#39;Z&#39;, subtag, length, errorCode);
1601 
1602     if(U_FAILURE(errorCode)) { return 0; }
1603     if(result.length() &lt;= capacity) {
1604         uprv_memcpy(buffer, result.data(), result.length());
1605     }
1606     return u_terminateChars(buffer, capacity, result.length(), &amp;errorCode);
1607 }
1608 
</pre>
</td>
<td>
<hr />
<pre>
 747     const uint8_t *rightBytes = reinterpret_cast&lt;const uint8_t *&gt;(right.data());
 748     if((leftBytes == NULL &amp;&amp; !left.empty()) || (rightBytes == NULL &amp;&amp; !right.empty())) {
 749         errorCode = U_ILLEGAL_ARGUMENT_ERROR;
 750         return UCOL_EQUAL;
 751     }
 752     return doCompare(leftBytes, left.length(), rightBytes, right.length(), errorCode);
 753 }
 754 
 755 UCollationResult
 756 RuleBasedCollator::internalCompareUTF8(const char *left, int32_t leftLength,
 757                                        const char *right, int32_t rightLength,
 758                                        UErrorCode &amp;errorCode) const {
 759     if(U_FAILURE(errorCode)) { return UCOL_EQUAL; }
 760     if((left == NULL &amp;&amp; leftLength != 0) || (right == NULL &amp;&amp; rightLength != 0)) {
 761         errorCode = U_ILLEGAL_ARGUMENT_ERROR;
 762         return UCOL_EQUAL;
 763     }
 764     // Make sure both or neither strings have a known length.
 765     // We do not optimize for mixed length/termination.
 766     if(leftLength &gt;= 0) {
<span class="line-modified"> 767         if(rightLength &lt; 0) { rightLength = static_cast&lt;int32_t&gt;(uprv_strlen(right)); }</span>
 768     } else {
<span class="line-modified"> 769         if(rightLength &gt;= 0) { leftLength = static_cast&lt;int32_t&gt;(uprv_strlen(left)); }</span>
 770     }
 771     return doCompare(reinterpret_cast&lt;const uint8_t *&gt;(left), leftLength,
 772                      reinterpret_cast&lt;const uint8_t *&gt;(right), rightLength, errorCode);
 773 }
 774 
 775 namespace {
 776 
 777 /**
 778  * Abstract iterator for identical-level string comparisons.
 779  * Returns FCD code points and handles temporary switching to NFD.
 780  */
 781 class NFDIterator : public UObject {
 782 public:
 783     NFDIterator() : index(-1), length(0) {}
 784     virtual ~NFDIterator() {}
 785     /**
 786      * Returns the next code point from the internal normalization buffer,
 787      * or else the next text code point.
 788      * Returns -1 at the end of the text.
 789      */
</pre>
<hr />
<pre>
 845         return c;
 846     }
 847 
 848     const UChar *s;
 849     const UChar *limit;
 850 };
 851 
 852 class FCDUTF16NFDIterator : public UTF16NFDIterator {
 853 public:
 854     FCDUTF16NFDIterator(const Normalizer2Impl &amp;nfcImpl, const UChar *text, const UChar *textLimit)
 855             : UTF16NFDIterator(NULL, NULL) {
 856         UErrorCode errorCode = U_ZERO_ERROR;
 857         const UChar *spanLimit = nfcImpl.makeFCD(text, textLimit, NULL, errorCode);
 858         if(U_FAILURE(errorCode)) { return; }
 859         if(spanLimit == textLimit || (textLimit == NULL &amp;&amp; *spanLimit == 0)) {
 860             s = text;
 861             limit = spanLimit;
 862         } else {
 863             str.setTo(text, (int32_t)(spanLimit - text));
 864             {
<span class="line-modified"> 865                 ReorderingBuffer r_buffer(nfcImpl, str);</span>
<span class="line-modified"> 866                 if(r_buffer.init(str.length(), errorCode)) {</span>
<span class="line-modified"> 867                     nfcImpl.makeFCD(spanLimit, textLimit, &amp;r_buffer, errorCode);</span>
 868                 }
 869             }
 870             if(U_SUCCESS(errorCode)) {
 871                 s = str.getBuffer();
 872                 limit = s + str.length();
 873             }
 874         }
 875     }
 876 private:
 877     UnicodeString str;
 878 };
 879 
 880 class UTF8NFDIterator : public NFDIterator {
 881 public:
 882     UTF8NFDIterator(const uint8_t *text, int32_t textLength)
 883         : s(text), pos(0), length(textLength) {}
 884 protected:
 885     virtual UChar32 nextRawCodePoint() {
 886         if(pos == length || (s[pos] == 0 &amp;&amp; length &lt; 0)) { return U_SENTINEL; }
 887         UChar32 c;
</pre>
<hr />
<pre>
1537 }  // namespace
1538 
1539 int32_t
1540 RuleBasedCollator::internalGetShortDefinitionString(const char *locale,
1541                                                     char *buffer, int32_t capacity,
1542                                                     UErrorCode &amp;errorCode) const {
1543     if(U_FAILURE(errorCode)) { return 0; }
1544     if(buffer == NULL ? capacity != 0 : capacity &lt; 0) {
1545         errorCode = U_ILLEGAL_ARGUMENT_ERROR;
1546         return 0;
1547     }
1548     if(locale == NULL) {
1549         locale = internalGetLocaleID(ULOC_VALID_LOCALE, errorCode);
1550     }
1551 
1552     char resultLocale[ULOC_FULLNAME_CAPACITY + 1];
1553     int32_t length = ucol_getFunctionalEquivalent(resultLocale, ULOC_FULLNAME_CAPACITY,
1554                                                   &quot;collation&quot;, locale,
1555                                                   NULL, &amp;errorCode);
1556     if(U_FAILURE(errorCode)) { return 0; }
<span class="line-modified">1557     resultLocale[length] = 0;</span>




1558 
1559     // Append items in alphabetic order of their short definition letters.
1560     CharString result;
1561     char subtag[ULOC_KEYWORD_AND_VALUES_CAPACITY];
1562 
1563     if(attributeHasBeenSetExplicitly(UCOL_ALTERNATE_HANDLING)) {
1564         appendAttribute(result, &#39;A&#39;, getAttribute(UCOL_ALTERNATE_HANDLING, errorCode), errorCode);
1565     }
1566     // ATTR_VARIABLE_TOP not supported because &#39;B&#39; was broken.
1567     // See ICU tickets #10372 and #10386.
1568     if(attributeHasBeenSetExplicitly(UCOL_CASE_FIRST)) {
1569         appendAttribute(result, &#39;C&#39;, getAttribute(UCOL_CASE_FIRST, errorCode), errorCode);
1570     }
1571     if(attributeHasBeenSetExplicitly(UCOL_NUMERIC_COLLATION)) {
1572         appendAttribute(result, &#39;D&#39;, getAttribute(UCOL_NUMERIC_COLLATION, errorCode), errorCode);
1573     }
1574     if(attributeHasBeenSetExplicitly(UCOL_CASE_LEVEL)) {
1575         appendAttribute(result, &#39;E&#39;, getAttribute(UCOL_CASE_LEVEL, errorCode), errorCode);
1576     }
1577     if(attributeHasBeenSetExplicitly(UCOL_FRENCH_COLLATION)) {
1578         appendAttribute(result, &#39;F&#39;, getAttribute(UCOL_FRENCH_COLLATION, errorCode), errorCode);
1579     }
1580     // Note: UCOL_HIRAGANA_QUATERNARY_MODE is deprecated and never changes away from default.
1581     length = uloc_getKeywordValue(resultLocale, &quot;collation&quot;, subtag, UPRV_LENGTHOF(subtag), &amp;errorCode);
1582     appendSubtag(result, &#39;K&#39;, subtag, length, errorCode);
1583     length = uloc_getLanguage(resultLocale, subtag, UPRV_LENGTHOF(subtag), &amp;errorCode);
<span class="line-modified">1584     if (length == 0) {</span>
<span class="line-added">1585         appendSubtag(result, &#39;L&#39;, &quot;root&quot;, 4, errorCode);</span>
<span class="line-added">1586     } else {</span>
<span class="line-added">1587         appendSubtag(result, &#39;L&#39;, subtag, length, errorCode);</span>
<span class="line-added">1588     }</span>
1589     if(attributeHasBeenSetExplicitly(UCOL_NORMALIZATION_MODE)) {
1590         appendAttribute(result, &#39;N&#39;, getAttribute(UCOL_NORMALIZATION_MODE, errorCode), errorCode);
1591     }
1592     length = uloc_getCountry(resultLocale, subtag, UPRV_LENGTHOF(subtag), &amp;errorCode);
1593     appendSubtag(result, &#39;R&#39;, subtag, length, errorCode);
1594     if(attributeHasBeenSetExplicitly(UCOL_STRENGTH)) {
1595         appendAttribute(result, &#39;S&#39;, getAttribute(UCOL_STRENGTH, errorCode), errorCode);
1596     }
1597     length = uloc_getVariant(resultLocale, subtag, UPRV_LENGTHOF(subtag), &amp;errorCode);
1598     appendSubtag(result, &#39;V&#39;, subtag, length, errorCode);
1599     length = uloc_getScript(resultLocale, subtag, UPRV_LENGTHOF(subtag), &amp;errorCode);
1600     appendSubtag(result, &#39;Z&#39;, subtag, length, errorCode);
1601 
1602     if(U_FAILURE(errorCode)) { return 0; }
1603     if(result.length() &lt;= capacity) {
1604         uprv_memcpy(buffer, result.data(), result.length());
1605     }
1606     return u_terminateChars(buffer, capacity, result.length(), &amp;errorCode);
1607 }
1608 
</pre>
</td>
</tr>
</table>
<center><a href="rematch.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="scriptset.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>