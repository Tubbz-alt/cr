<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_decimfmtprops.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // © 2017 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 
  4 #include &quot;unicode/utypes.h&quot;
  5 
  6 #if !UCONFIG_NO_FORMATTING
  7 #ifndef __NUMBER_DECIMFMTPROPS_H__
  8 #define __NUMBER_DECIMFMTPROPS_H__
  9 
 10 #include &quot;unicode/unistr.h&quot;
 11 #include &lt;cstdint&gt;
 12 #include &quot;unicode/plurrule.h&quot;
 13 #include &quot;unicode/currpinf.h&quot;
 14 #include &quot;unicode/unum.h&quot;
 15 #include &quot;unicode/localpointer.h&quot;
 16 #include &quot;number_types.h&quot;
 17 
 18 U_NAMESPACE_BEGIN
 19 
 20 // Export an explicit template instantiation of the LocalPointer that is used as a
 21 // data member of CurrencyPluralInfoWrapper.
 22 // (When building DLLs for Windows this is required.)
 23 #if U_PF_WINDOWS &lt;= U_PLATFORM &amp;&amp; U_PLATFORM &lt;= U_PF_CYGWIN
 24 // Ignore warning 4661 as LocalPointerBase does not use operator== or operator!=
 25 #pragma warning(suppress: 4661)
 26 template class U_I18N_API LocalPointerBase&lt;CurrencyPluralInfo&gt;;
 27 template class U_I18N_API LocalPointer&lt;CurrencyPluralInfo&gt;;
 28 #endif
 29 
 30 namespace number {
 31 namespace impl {
 32 
 33 // Exported as U_I18N_API because it is a public member field of exported DecimalFormatProperties
 34 // Using this wrapper is rather unfortunate, but is needed on Windows platforms in order to allow
 35 // for DLL-exporting an fully specified template instantiation.
 36 class U_I18N_API CurrencyPluralInfoWrapper {
 37 public:
 38     LocalPointer&lt;CurrencyPluralInfo&gt; fPtr;
 39 
 40     CurrencyPluralInfoWrapper() = default;
 41 
 42     CurrencyPluralInfoWrapper(const CurrencyPluralInfoWrapper&amp; other) {
 43         if (!other.fPtr.isNull()) {
 44             fPtr.adoptInstead(new CurrencyPluralInfo(*other.fPtr));
 45         }
 46     }
 47 
 48     CurrencyPluralInfoWrapper&amp; operator=(const CurrencyPluralInfoWrapper&amp; other) {
 49         if (!other.fPtr.isNull()) {
 50             fPtr.adoptInstead(new CurrencyPluralInfo(*other.fPtr));
 51         }
 52         return *this;
 53     }
 54 };
 55 
 56 /** Controls the set of rules for parsing a string from the old DecimalFormat API. */
 57 enum ParseMode {
 58     /**
 59      * Lenient mode should be used if you want to accept malformed user input. It will use heuristics
 60      * to attempt to parse through typographical errors in the string.
 61      */
 62             PARSE_MODE_LENIENT,
 63 
 64     /**
 65      * Strict mode should be used if you want to require that the input is well-formed. More
 66      * specifically, it differs from lenient mode in the following ways:
 67      *
 68      * &lt;ul&gt;
 69      * &lt;li&gt;Grouping widths must match the grouping settings. For example, &quot;12,3,45&quot; will fail if the
 70      * grouping width is 3, as in the pattern &quot;#,##0&quot;.
 71      * &lt;li&gt;The string must contain a complete prefix and suffix. For example, if the pattern is
 72      * &quot;{#};(#)&quot;, then &quot;{123}&quot; or &quot;(123)&quot; would match, but &quot;{123&quot;, &quot;123}&quot;, and &quot;123&quot; would all fail.
 73      * (The latter strings would be accepted in lenient mode.)
 74      * &lt;li&gt;Whitespace may not appear at arbitrary places in the string. In lenient mode, whitespace
 75      * is allowed to occur arbitrarily before and after prefixes and exponent separators.
 76      * &lt;li&gt;Leading grouping separators are not allowed, as in &quot;,123&quot;.
 77      * &lt;li&gt;Minus and plus signs can only appear if specified in the pattern. In lenient mode, a plus
 78      * or minus sign can always precede a number.
 79      * &lt;li&gt;The set of characters that can be interpreted as a decimal or grouping separator is
 80      * smaller.
 81      * &lt;li&gt;&lt;strong&gt;If currency parsing is enabled,&lt;/strong&gt; currencies must only appear where
 82      * specified in either the current pattern string or in a valid pattern string for the current
 83      * locale. For example, if the pattern is &quot;¤0.00&quot;, then &quot;$1.23&quot; would match, but &quot;1.23$&quot; would
 84      * fail to match.
 85      * &lt;/ul&gt;
 86      */
 87             PARSE_MODE_STRICT,
 88 };
 89 
 90 // Exported as U_I18N_API because it is needed for the unit test PatternStringTest
 91 struct U_I18N_API DecimalFormatProperties : public UMemory {
 92 
 93   public:
 94     NullableValue&lt;UNumberCompactStyle&gt; compactStyle;
 95     NullableValue&lt;CurrencyUnit&gt; currency;
 96     CurrencyPluralInfoWrapper currencyPluralInfo;
 97     NullableValue&lt;UCurrencyUsage&gt; currencyUsage;
 98     bool decimalPatternMatchRequired;
 99     bool decimalSeparatorAlwaysShown;
100     bool exponentSignAlwaysShown;
101     bool formatFailIfMoreThanMaxDigits; // ICU4C-only
102     int32_t formatWidth;
103     int32_t groupingSize;
104     bool groupingUsed;
105     int32_t magnitudeMultiplier; // internal field like multiplierScale but separate to avoid conflict
106     int32_t maximumFractionDigits;
107     int32_t maximumIntegerDigits;
108     int32_t maximumSignificantDigits;
109     int32_t minimumExponentDigits;
110     int32_t minimumFractionDigits;
111     int32_t minimumGroupingDigits;
112     int32_t minimumIntegerDigits;
113     int32_t minimumSignificantDigits;
114     int32_t multiplier;
115     int32_t multiplierScale; // ICU4C-only
116     UnicodeString negativePrefix;
117     UnicodeString negativePrefixPattern;
118     UnicodeString negativeSuffix;
119     UnicodeString negativeSuffixPattern;
120     NullableValue&lt;PadPosition&gt; padPosition;
121     UnicodeString padString;
122     bool parseCaseSensitive;
123     bool parseIntegerOnly;
124     NullableValue&lt;ParseMode&gt; parseMode;
125     bool parseNoExponent;
126     bool parseToBigDecimal; // TODO: Not needed in ICU4C?
127     UNumberFormatAttributeValue parseAllInput; // ICU4C-only
128     //PluralRules pluralRules;
129     UnicodeString positivePrefix;
130     UnicodeString positivePrefixPattern;
131     UnicodeString positiveSuffix;
132     UnicodeString positiveSuffixPattern;
133     double roundingIncrement;
134     NullableValue&lt;RoundingMode&gt; roundingMode;
135     int32_t secondaryGroupingSize;
136     bool signAlwaysShown;
137 
138     DecimalFormatProperties();
139 
140     inline bool operator==(const DecimalFormatProperties&amp; other) const {
141         return _equals(other, false);
142     }
143 
144     void clear();
145 
146     /**
147      * Checks for equality to the default DecimalFormatProperties, but ignores the prescribed set of
148      * options for fast-path formatting.
149      */
150     bool equalsDefaultExceptFastFormat() const;
151 
152   private:
153     bool _equals(const DecimalFormatProperties&amp; other, bool ignoreForFastFormat) const;
154 };
155 
156 } // namespace impl
157 } // namespace number
158 U_NAMESPACE_END
159 
160 
161 #endif //__NUMBER_DECIMFMTPROPS_H__
162 
163 #endif /* #if !UCONFIG_NO_FORMATTING */
    </pre>
  </body>
</html>