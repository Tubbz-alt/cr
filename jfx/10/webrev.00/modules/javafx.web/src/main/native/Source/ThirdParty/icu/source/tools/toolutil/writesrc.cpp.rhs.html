<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/tools/toolutil/writesrc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // © 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 *******************************************************************************
  5 *
  6 *   Copyright (C) 2005-2012, International Business Machines
  7 *   Corporation and others.  All Rights Reserved.
  8 *
  9 *******************************************************************************
 10 *   file name:  writesrc.c
 11 *   encoding:   UTF-8
 12 *   tab size:   8 (not used)
 13 *   indentation:4
 14 *
 15 *   created on: 2005apr23
 16 *   created by: Markus W. Scherer
 17 *
 18 *   Helper functions for writing source code for data.
 19 */
 20 
 21 #include &lt;stdio.h&gt;
 22 #include &lt;time.h&gt;
 23 #include &quot;unicode/utypes.h&quot;
 24 #include &quot;unicode/putil.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 25 #include &quot;unicode/ucptrie.h&quot;</span>
 26 #include &quot;utrie2.h&quot;
 27 #include &quot;cstring.h&quot;
 28 #include &quot;writesrc.h&quot;
 29 
 30 static FILE *
 31 usrc_createWithHeader(const char *path, const char *filename,
<a name="2" id="anc2"></a><span class="line-modified"> 32                       const char *header, const char *generator) {</span>
 33     char buffer[1024];
 34     const char *p;
 35     char *q;
 36     FILE *f;
 37     char c;
 38 
 39     if(path==NULL) {
 40         p=filename;
 41     } else {
 42         /* concatenate path and filename, with U_FILE_SEP_CHAR in between if necessary */
 43         uprv_strcpy(buffer, path);
 44         q=buffer+uprv_strlen(buffer);
 45         if(q&gt;buffer &amp;&amp; (c=*(q-1))!=U_FILE_SEP_CHAR &amp;&amp; c!=U_FILE_ALT_SEP_CHAR) {
 46             *q++=U_FILE_SEP_CHAR;
 47         }
 48         uprv_strcpy(q, filename);
 49         p=buffer;
 50     }
 51 
 52     f=fopen(p, &quot;w&quot;);
 53     if(f!=NULL) {
 54         const struct tm *lt;
 55         time_t t;
 56 
 57         time(&amp;t);
 58         lt=localtime(&amp;t);
 59         if(generator==NULL) {
 60             strftime(buffer, sizeof(buffer), &quot;%Y-%m-%d&quot;, lt);
 61             fprintf(f, header, filename, buffer);
 62         } else {
 63             fprintf(f, header, filename, generator);
 64         }
 65     } else {
 66         fprintf(
 67             stderr,
 68             &quot;usrc_create(%s, %s): unable to create file\n&quot;,
 69             path!=NULL ? path : &quot;&quot;, filename);
 70     }
 71     return f;
 72 }
 73 
 74 U_CAPI FILE * U_EXPORT2
<a name="3" id="anc3"></a><span class="line-modified"> 75 usrc_create(const char *path, const char *filename, int32_t copyrightYear, const char *generator) {</span>
<span class="line-modified"> 76     const char *header;</span>
<span class="line-modified"> 77     char buffer[200];</span>
<span class="line-modified"> 78     if(copyrightYear&lt;=2016) {</span>
<span class="line-modified"> 79         header=</span>
<span class="line-modified"> 80             &quot;// © 2016 and later: Unicode, Inc. and others.\n&quot;</span>
<span class="line-modified"> 81             &quot;// License &amp; terms of use: http://www.unicode.org/copyright.html\n&quot;</span>
<span class="line-modified"> 82             &quot;//\n&quot;</span>
<span class="line-modified"> 83             &quot;// Copyright (C) 1999-2016, International Business Machines\n&quot;</span>
<span class="line-modified"> 84             &quot;// Corporation and others.  All Rights Reserved.\n&quot;</span>
<span class="line-modified"> 85             &quot;//\n&quot;</span>
<span class="line-modified"> 86             &quot;// file name: %s\n&quot;</span>
<span class="line-modified"> 87             &quot;//\n&quot;</span>
<span class="line-modified"> 88             &quot;// machine-generated by: %s\n&quot;</span>
<span class="line-added"> 89             &quot;\n\n&quot;;</span>
<span class="line-added"> 90     } else {</span>
<span class="line-added"> 91         sprintf(buffer,</span>
<span class="line-added"> 92                 &quot;// © %d and later: Unicode, Inc. and others.\n&quot;</span>
<span class="line-added"> 93                 &quot;// License &amp; terms of use: http://www.unicode.org/copyright.html\n&quot;</span>
<span class="line-added"> 94                 &quot;//\n&quot;</span>
<span class="line-added"> 95                 &quot;// file name: %%s\n&quot;</span>
<span class="line-added"> 96                 &quot;//\n&quot;</span>
<span class="line-added"> 97                 &quot;// machine-generated by: %%s\n&quot;</span>
<span class="line-added"> 98                 &quot;\n\n&quot;,</span>
<span class="line-added"> 99                 (int)copyrightYear);</span>
<span class="line-added">100         header=buffer;</span>
<span class="line-added">101     }</span>
<span class="line-added">102     return usrc_createWithHeader(path, filename, header, generator);</span>
103 }
104 
105 U_CAPI FILE * U_EXPORT2
106 usrc_createTextData(const char *path, const char *filename, const char *generator) {
107     // TODO: Add parameter for the first year this file was generated, not before 2016.
108     static const char *header=
109         &quot;# Copyright (C) 2016 and later: Unicode, Inc. and others.\n&quot;
110         &quot;# License &amp; terms of use: http://www.unicode.org/copyright.html\n&quot;
111         &quot;# Copyright (C) 1999-2016, International Business Machines\n&quot;
112         &quot;# Corporation and others.  All Rights Reserved.\n&quot;
113         &quot;#\n&quot;
114         &quot;# file name: %s\n&quot;
115         &quot;#\n&quot;
116         &quot;# machine-generated by: %s\n&quot;
117         &quot;\n\n&quot;;
<a name="4" id="anc4"></a><span class="line-modified">118     return usrc_createWithHeader(path, filename, header, generator);</span>
119 }
120 
121 U_CAPI void U_EXPORT2
122 usrc_writeArray(FILE *f,
123                 const char *prefix,
124                 const void *p, int32_t width, int32_t length,
125                 const char *postfix) {
126     const uint8_t *p8;
127     const uint16_t *p16;
128     const uint32_t *p32;
129     uint32_t value;
130     int32_t i, col;
131 
132     p8=NULL;
133     p16=NULL;
134     p32=NULL;
135     switch(width) {
136     case 8:
137         p8=(const uint8_t *)p;
138         break;
139     case 16:
140         p16=(const uint16_t *)p;
141         break;
142     case 32:
143         p32=(const uint32_t *)p;
144         break;
145     default:
146         fprintf(stderr, &quot;usrc_writeArray(width=%ld) unrecognized width\n&quot;, (long)width);
147         return;
148     }
149     if(prefix!=NULL) {
150         fprintf(f, prefix, (long)length);
151     }
152     for(i=col=0; i&lt;length; ++i, ++col) {
153         if(i&gt;0) {
154             if(col&lt;16) {
155                 fputc(&#39;,&#39;, f);
156             } else {
157                 fputs(&quot;,\n&quot;, f);
158                 col=0;
159             }
160         }
161         switch(width) {
162         case 8:
163             value=p8[i];
164             break;
165         case 16:
166             value=p16[i];
167             break;
168         case 32:
169             value=p32[i];
170             break;
171         default:
172             value=0; /* unreachable */
173             break;
174         }
175         fprintf(f, value&lt;=9 ? &quot;%lu&quot; : &quot;0x%lx&quot;, (unsigned long)value);
176     }
177     if(postfix!=NULL) {
178         fputs(postfix, f);
179     }
180 }
181 
182 U_CAPI void U_EXPORT2
183 usrc_writeUTrie2Arrays(FILE *f,
184                        const char *indexPrefix, const char *data32Prefix,
185                        const UTrie2 *pTrie,
186                        const char *postfix) {
187     if(pTrie-&gt;data32==NULL) {
188         /* 16-bit trie */
189         usrc_writeArray(f, indexPrefix, pTrie-&gt;index, 16, pTrie-&gt;indexLength+pTrie-&gt;dataLength, postfix);
190     } else {
191         /* 32-bit trie */
192         usrc_writeArray(f, indexPrefix, pTrie-&gt;index, 16, pTrie-&gt;indexLength, postfix);
193         usrc_writeArray(f, data32Prefix, pTrie-&gt;data32, 32, pTrie-&gt;dataLength, postfix);
194     }
195 }
196 
197 U_CAPI void U_EXPORT2
198 usrc_writeUTrie2Struct(FILE *f,
199                        const char *prefix,
200                        const UTrie2 *pTrie,
201                        const char *indexName, const char *data32Name,
202                        const char *postfix) {
203     if(prefix!=NULL) {
204         fputs(prefix, f);
205     }
206     if(pTrie-&gt;data32==NULL) {
207         /* 16-bit trie */
208         fprintf(
209             f,
210             &quot;    %s,\n&quot;         /* index */
211             &quot;    %s+%ld,\n&quot;     /* data16 */
212             &quot;    NULL,\n&quot;,      /* data32 */
213             indexName,
214             indexName,
215             (long)pTrie-&gt;indexLength);
216     } else {
217         /* 32-bit trie */
218         fprintf(
219             f,
220             &quot;    %s,\n&quot;         /* index */
221             &quot;    NULL,\n&quot;       /* data16 */
222             &quot;    %s,\n&quot;,        /* data32 */
223             indexName,
224             data32Name);
225     }
226     fprintf(
227         f,
228         &quot;    %ld,\n&quot;            /* indexLength */
229         &quot;    %ld,\n&quot;            /* dataLength */
230         &quot;    0x%hx,\n&quot;          /* index2NullOffset */
231         &quot;    0x%hx,\n&quot;          /* dataNullOffset */
232         &quot;    0x%lx,\n&quot;          /* initialValue */
233         &quot;    0x%lx,\n&quot;          /* errorValue */
234         &quot;    0x%lx,\n&quot;          /* highStart */
235         &quot;    0x%lx,\n&quot;          /* highValueIndex */
236         &quot;    NULL, 0, FALSE, FALSE, 0, NULL\n&quot;,
237         (long)pTrie-&gt;indexLength, (long)pTrie-&gt;dataLength,
238         (short)pTrie-&gt;index2NullOffset, (short)pTrie-&gt;dataNullOffset,
239         (long)pTrie-&gt;initialValue, (long)pTrie-&gt;errorValue,
240         (long)pTrie-&gt;highStart, (long)pTrie-&gt;highValueIndex);
241     if(postfix!=NULL) {
242         fputs(postfix, f);
243     }
244 }
245 
<a name="5" id="anc5"></a><span class="line-added">246 U_CAPI void U_EXPORT2</span>
<span class="line-added">247 usrc_writeUCPTrieArrays(FILE *f,</span>
<span class="line-added">248                         const char *indexPrefix, const char *dataPrefix,</span>
<span class="line-added">249                         const UCPTrie *pTrie,</span>
<span class="line-added">250                         const char *postfix) {</span>
<span class="line-added">251     usrc_writeArray(f, indexPrefix, pTrie-&gt;index, 16, pTrie-&gt;indexLength, postfix);</span>
<span class="line-added">252     int32_t width=</span>
<span class="line-added">253         pTrie-&gt;valueWidth==UCPTRIE_VALUE_BITS_16 ? 16 :</span>
<span class="line-added">254         pTrie-&gt;valueWidth==UCPTRIE_VALUE_BITS_32 ? 32 :</span>
<span class="line-added">255         pTrie-&gt;valueWidth==UCPTRIE_VALUE_BITS_8 ? 8 : 0;</span>
<span class="line-added">256     usrc_writeArray(f, dataPrefix, pTrie-&gt;data.ptr0, width, pTrie-&gt;dataLength, postfix);</span>
<span class="line-added">257 }</span>
<span class="line-added">258 </span>
<span class="line-added">259 U_CAPI void U_EXPORT2</span>
<span class="line-added">260 usrc_writeUCPTrieStruct(FILE *f,</span>
<span class="line-added">261                         const char *prefix,</span>
<span class="line-added">262                         const UCPTrie *pTrie,</span>
<span class="line-added">263                         const char *indexName, const char *dataName,</span>
<span class="line-added">264                         const char *postfix) {</span>
<span class="line-added">265     if(prefix!=NULL) {</span>
<span class="line-added">266         fputs(prefix, f);</span>
<span class="line-added">267     }</span>
<span class="line-added">268     fprintf(</span>
<span class="line-added">269         f,</span>
<span class="line-added">270         &quot;    %s,\n&quot;             // index</span>
<span class="line-added">271         &quot;    { %s },\n&quot;,        // data (union)</span>
<span class="line-added">272         indexName,</span>
<span class="line-added">273         dataName);</span>
<span class="line-added">274     fprintf(</span>
<span class="line-added">275         f,</span>
<span class="line-added">276         &quot;    %ld, %ld,\n&quot;       // indexLength, dataLength</span>
<span class="line-added">277         &quot;    0x%lx, 0x%x,\n&quot;    // highStart, shifted12HighStart</span>
<span class="line-added">278         &quot;    %d, %d,\n&quot;         // type, valueWidth</span>
<span class="line-added">279         &quot;    0, 0,\n&quot;           // reserved32, reserved16</span>
<span class="line-added">280         &quot;    0x%x, 0x%lx,\n&quot;    // index3NullOffset, dataNullOffset</span>
<span class="line-added">281         &quot;    0x%lx,\n&quot;,         // nullValue</span>
<span class="line-added">282         (long)pTrie-&gt;indexLength, (long)pTrie-&gt;dataLength,</span>
<span class="line-added">283         (long)pTrie-&gt;highStart, pTrie-&gt;shifted12HighStart,</span>
<span class="line-added">284         pTrie-&gt;type, pTrie-&gt;valueWidth,</span>
<span class="line-added">285         pTrie-&gt;index3NullOffset, (long)pTrie-&gt;dataNullOffset,</span>
<span class="line-added">286         (long)pTrie-&gt;nullValue);</span>
<span class="line-added">287     if(postfix!=NULL) {</span>
<span class="line-added">288         fputs(postfix, f);</span>
<span class="line-added">289     }</span>
<span class="line-added">290 }</span>
<span class="line-added">291 </span>
<span class="line-added">292 U_CAPI void U_EXPORT2</span>
<span class="line-added">293 usrc_writeUCPTrie(FILE *f, const char *name, const UCPTrie *pTrie) {</span>
<span class="line-added">294     int32_t width=</span>
<span class="line-added">295         pTrie-&gt;valueWidth==UCPTRIE_VALUE_BITS_16 ? 16 :</span>
<span class="line-added">296         pTrie-&gt;valueWidth==UCPTRIE_VALUE_BITS_32 ? 32 :</span>
<span class="line-added">297         pTrie-&gt;valueWidth==UCPTRIE_VALUE_BITS_8 ? 8 : 0;</span>
<span class="line-added">298     char line[100], line2[100], line3[100];</span>
<span class="line-added">299     sprintf(line, &quot;static const uint16_t %s_trieIndex[%%ld]={\n&quot;, name);</span>
<span class="line-added">300     sprintf(line2, &quot;static const uint%d_t %s_trieData[%%ld]={\n&quot;, (int)width, name);</span>
<span class="line-added">301     usrc_writeUCPTrieArrays(f, line, line2, pTrie, &quot;\n};\n\n&quot;);</span>
<span class="line-added">302     sprintf(line, &quot;static const UCPTrie %s_trie={\n&quot;, name);</span>
<span class="line-added">303     sprintf(line2, &quot;%s_trieIndex&quot;, name);</span>
<span class="line-added">304     sprintf(line3, &quot;%s_trieData&quot;, name);</span>
<span class="line-added">305     usrc_writeUCPTrieStruct(f, line, pTrie, line2, line3, &quot;};\n\n&quot;);</span>
<span class="line-added">306 }</span>
<span class="line-added">307 </span>
308 U_CAPI void U_EXPORT2
309 usrc_writeArrayOfMostlyInvChars(FILE *f,
310                                 const char *prefix,
311                                 const char *p, int32_t length,
312                                 const char *postfix) {
313     int32_t i, col;
314     int prev2, prev, c;
315 
316     if(prefix!=NULL) {
317         fprintf(f, prefix, (long)length);
318     }
319     prev2=prev=-1;
320     for(i=col=0; i&lt;length; ++i, ++col) {
321         c=(uint8_t)p[i];
322         if(i&gt;0) {
323             /* Break long lines. Try to break at interesting places, to minimize revision diffs. */
324             if(
325                 /* Very long line. */
326                 col&gt;=32 ||
327                 /* Long line, break after terminating NUL. */
328                 (col&gt;=24 &amp;&amp; prev2&gt;=0x20 &amp;&amp; prev==0) ||
329                 /* Medium-long line, break before non-NUL, non-character byte. */
330                 (col&gt;=16 &amp;&amp; (prev==0 || prev&gt;=0x20) &amp;&amp; 0&lt;c &amp;&amp; c&lt;0x20)
331             ) {
332                 fputs(&quot;,\n&quot;, f);
333                 col=0;
334             } else {
335                 fputc(&#39;,&#39;, f);
336             }
337         }
338         fprintf(f, c&lt;0x20 ? &quot;%u&quot; : &quot;&#39;%c&#39;&quot;, c);
339         prev2=prev;
340         prev=c;
341     }
342     if(postfix!=NULL) {
343         fputs(postfix, f);
344     }
345 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>