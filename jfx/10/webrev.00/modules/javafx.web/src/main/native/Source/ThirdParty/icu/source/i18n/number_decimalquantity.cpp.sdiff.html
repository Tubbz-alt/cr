<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_decimalquantity.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="number_compact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_decimalquantity.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_decimalquantity.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  95 DecimalQuantity &amp;DecimalQuantity::operator=(const DecimalQuantity &amp;other) {
  96     if (this == &amp;other) {
  97         return *this;
  98     }
  99     copyBcdFrom(other);
 100     copyFieldsFrom(other);
 101     return *this;
 102 }
 103 
 104 DecimalQuantity&amp; DecimalQuantity::operator=(DecimalQuantity&amp;&amp; src) U_NOEXCEPT {
 105     if (this == &amp;src) {
 106         return *this;
 107     }
 108     moveBcdFrom(src);
 109     copyFieldsFrom(src);
 110     return *this;
 111 }
 112 
 113 void DecimalQuantity::copyFieldsFrom(const DecimalQuantity&amp; other) {
 114     bogus = other.bogus;
<span class="line-removed"> 115     lOptPos = other.lOptPos;</span>
 116     lReqPos = other.lReqPos;
 117     rReqPos = other.rReqPos;
<span class="line-removed"> 118     rOptPos = other.rOptPos;</span>
 119     scale = other.scale;
 120     precision = other.precision;
 121     flags = other.flags;
 122     origDouble = other.origDouble;
 123     origDelta = other.origDelta;
 124     isApproximate = other.isApproximate;
 125 }
 126 
 127 void DecimalQuantity::clear() {
<span class="line-removed"> 128     lOptPos = INT32_MAX;</span>
 129     lReqPos = 0;
 130     rReqPos = 0;
<span class="line-removed"> 131     rOptPos = INT32_MIN;</span>
 132     flags = 0;
 133     setBcdToZero(); // sets scale, precision, hasDouble, origDouble, origDelta, and BCD data
 134 }
 135 
<span class="line-modified"> 136 void DecimalQuantity::setIntegerLength(int32_t minInt, int32_t maxInt) {</span>
 137     // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.
 138     U_ASSERT(minInt &gt;= 0);
<span class="line-removed"> 139     U_ASSERT(maxInt &gt;= minInt);</span>
 140 
 141     // Special behavior: do not set minInt to be less than what is already set.
 142     // This is so significant digits rounding can set the integer length.
 143     if (minInt &lt; lReqPos) {
 144         minInt = lReqPos;
 145     }
 146 
 147     // Save values into internal state
<span class="line-removed"> 148     // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE &gt; Integer.MIN_VALUE</span>
<span class="line-removed"> 149     lOptPos = maxInt;</span>
 150     lReqPos = minInt;
 151 }
 152 
<span class="line-modified"> 153 void DecimalQuantity::setFractionLength(int32_t minFrac, int32_t maxFrac) {</span>
 154     // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.
 155     U_ASSERT(minFrac &gt;= 0);
<span class="line-removed"> 156     U_ASSERT(maxFrac &gt;= minFrac);</span>
 157 
 158     // Save values into internal state
 159     // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE &gt; Integer.MIN_VALUE
 160     rReqPos = -minFrac;
<span class="line-modified"> 161     rOptPos = -maxFrac;</span>



















 162 }
 163 
 164 uint64_t DecimalQuantity::getPositionFingerprint() const {
 165     uint64_t fingerprint = 0;
<span class="line-removed"> 166     fingerprint ^= lOptPos;</span>
 167     fingerprint ^= (lReqPos &lt;&lt; 16);
 168     fingerprint ^= (static_cast&lt;uint64_t&gt;(rReqPos) &lt;&lt; 32);
<span class="line-removed"> 169     fingerprint ^= (static_cast&lt;uint64_t&gt;(rOptPos) &lt;&lt; 48);</span>
 170     return fingerprint;
 171 }
 172 
 173 void DecimalQuantity::roundToIncrement(double roundingIncrement, RoundingMode roundingMode,
<span class="line-modified"> 174                                        int32_t maxFrac, UErrorCode&amp; status) {</span>
<span class="line-modified"> 175     // TODO(13701): This is innefficient.  Improve?</span>
<span class="line-modified"> 176     // TODO(13701): Should we convert to decNumber instead?</span>
<span class="line-modified"> 177     roundToInfinity();</span>
<span class="line-modified"> 178     double temp = toDouble();</span>
<span class="line-modified"> 179     temp /= roundingIncrement;</span>
<span class="line-modified"> 180     // Use another DecimalQuantity to perform the actual rounding...</span>
<span class="line-modified"> 181     DecimalQuantity dq;</span>
<span class="line-modified"> 182     dq.setToDouble(temp);</span>
<span class="line-modified"> 183     dq.roundToMagnitude(0, roundingMode, status);</span>
<span class="line-modified"> 184     temp = dq.toDouble();</span>
<span class="line-modified"> 185     temp *= roundingIncrement;</span>
<span class="line-modified"> 186     setToDouble(temp);</span>
<span class="line-modified"> 187     // Since we reset the value to a double, we need to specify the rounding boundary</span>
<span class="line-modified"> 188     // in order to get the DecimalQuantity out of approximation mode.</span>
<span class="line-modified"> 189     // NOTE: In Java, we have minMaxFrac, but in C++, the two are differentiated.</span>
<span class="line-modified"> 190     roundToMagnitude(-maxFrac, roundingMode, status);</span>





 191 }
 192 
 193 void DecimalQuantity::multiplyBy(const DecNum&amp; multiplicand, UErrorCode&amp; status) {
 194     if (isInfinite() || isZero() || isNaN()) {
 195         return;
 196     }
 197     // Convert to DecNum, multiply, and convert back.
 198     DecNum decnum;
 199     toDecNum(decnum, status);
 200     if (U_FAILURE(status)) { return; }
 201     decnum.multiplyBy(multiplicand, status);
 202     if (U_FAILURE(status)) { return; }
 203     setToDecNum(decnum, status);
 204 }
 205 
 206 void DecimalQuantity::divideBy(const DecNum&amp; divisor, UErrorCode&amp; status) {
 207     if (isInfinite() || isZero() || isNaN()) {
 208         return;
 209     }
 210     // Convert to DecNum, multiply, and convert back.
</pre>
<hr />
<pre>
 253             return static_cast&lt;double&gt;(toFractionLong(false));
 254         case PLURAL_OPERAND_V:
 255             return fractionCount();
 256         case PLURAL_OPERAND_W:
 257             return fractionCountWithoutTrailingZeros();
 258         default:
 259             return std::abs(toDouble());
 260     }
 261 }
 262 
 263 bool DecimalQuantity::hasIntegerValue() const {
 264     return scale &gt;= 0;
 265 }
 266 
 267 int32_t DecimalQuantity::getUpperDisplayMagnitude() const {
 268     // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
 269     // See the comment in the header file explaining the &quot;isApproximate&quot; field.
 270     U_ASSERT(!isApproximate);
 271 
 272     int32_t magnitude = scale + precision;
<span class="line-modified"> 273     int32_t result = (lReqPos &gt; magnitude) ? lReqPos : (lOptPos &lt; magnitude) ? lOptPos : magnitude;</span>
 274     return result - 1;
 275 }
 276 
 277 int32_t DecimalQuantity::getLowerDisplayMagnitude() const {
 278     // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
 279     // See the comment in the header file explaining the &quot;isApproximate&quot; field.
 280     U_ASSERT(!isApproximate);
 281 
 282     int32_t magnitude = scale;
<span class="line-modified"> 283     int32_t result = (rReqPos &lt; magnitude) ? rReqPos : (rOptPos &gt; magnitude) ? rOptPos : magnitude;</span>
 284     return result;
 285 }
 286 
 287 int8_t DecimalQuantity::getDigit(int32_t magnitude) const {
 288     // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
 289     // See the comment at the top of this file explaining the &quot;isApproximate&quot; field.
 290     U_ASSERT(!isApproximate);
 291 
 292     return getDigitPos(magnitude - scale);
 293 }
 294 
 295 int32_t DecimalQuantity::fractionCount() const {
 296     return -getLowerDisplayMagnitude();
 297 }
 298 
 299 int32_t DecimalQuantity::fractionCountWithoutTrailingZeros() const {
 300     return -scale &gt; 0 ? -scale : 0;  // max(-scale, 0)
 301 }
 302 
 303 bool DecimalQuantity::isNegative() const {
</pre>
<hr />
<pre>
 484     _setToDecNum(decnum, status);
 485     return *this;
 486 }
 487 
 488 void DecimalQuantity::_setToDecNum(const DecNum&amp; decnum, UErrorCode&amp; status) {
 489     if (U_FAILURE(status)) { return; }
 490     if (decnum.isNegative()) {
 491         flags |= NEGATIVE_FLAG;
 492     }
 493     if (!decnum.isZero()) {
 494         readDecNumberToBcd(decnum);
 495         compact();
 496     }
 497 }
 498 
 499 int64_t DecimalQuantity::toLong(bool truncateIfOverflow) const {
 500     // NOTE: Call sites should be guarded by fitsInLong(), like this:
 501     // if (dq.fitsInLong()) { /* use dq.toLong() */ } else { /* use some fallback */ }
 502     // Fallback behavior upon truncateIfOverflow is to truncate at 17 digits.
 503     uint64_t result = 0L;
<span class="line-modified"> 504     int32_t upperMagnitude = std::min(scale + precision, lOptPos) - 1;</span>
 505     if (truncateIfOverflow) {
 506         upperMagnitude = std::min(upperMagnitude, 17);
 507     }
 508     for (int32_t magnitude = upperMagnitude; magnitude &gt;= 0; magnitude--) {
 509         result = result * 10 + getDigitPos(magnitude - scale);
 510     }
 511     if (isNegative()) {
 512         return static_cast&lt;int64_t&gt;(0LL - result); // i.e., -result
 513     }
 514     return static_cast&lt;int64_t&gt;(result);
 515 }
 516 
 517 uint64_t DecimalQuantity::toFractionLong(bool includeTrailingZeros) const {
 518     uint64_t result = 0L;
 519     int32_t magnitude = -1;
<span class="line-modified"> 520     int32_t lowerMagnitude = std::max(scale, rOptPos);</span>
 521     if (includeTrailingZeros) {
 522         lowerMagnitude = std::min(lowerMagnitude, rReqPos);
 523     }
 524     for (; magnitude &gt;= lowerMagnitude &amp;&amp; result &lt;= 1e18L; magnitude--) {
 525         result = result * 10 + getDigitPos(magnitude - scale);
 526     }
 527     // Remove trailing zeros; this can happen during integer overflow cases.
 528     if (!includeTrailingZeros) {
 529         while (result &gt; 0 &amp;&amp; (result % 10) == 0) {
 530             result /= 10;
 531         }
 532     }
 533     return result;
 534 }
 535 
 536 bool DecimalQuantity::fitsInLong(bool ignoreFraction) const {
 537     if (isZero()) {
 538         return true;
 539     }
 540     if (scale &lt; 0 &amp;&amp; !ignoreFraction) {
</pre>
<hr />
<pre>
 589         output.setTo(&quot;0&quot;, status);
 590     }
 591 
 592     // Use the BCD constructor. We need to do a little bit of work to convert, though.
 593     // The decNumber constructor expects most-significant first, but we store least-significant first.
 594     MaybeStackArray&lt;uint8_t, 20&gt; ubcd(precision);
 595     for (int32_t m = 0; m &lt; precision; m++) {
 596         ubcd[precision - m - 1] = static_cast&lt;uint8_t&gt;(getDigitPos(m));
 597     }
 598     output.setTo(ubcd.getAlias(), precision, scale, isNegative(), status);
 599 }
 600 
 601 void DecimalQuantity::truncate() {
 602     if (scale &lt; 0) {
 603         shiftRight(-scale);
 604         scale = 0;
 605         compact();
 606     }
 607 }
 608 




 609 void DecimalQuantity::roundToMagnitude(int32_t magnitude, RoundingMode roundingMode, UErrorCode&amp; status) {




 610     // The position in the BCD at which rounding will be performed; digits to the right of position
 611     // will be rounded away.
<span class="line-removed"> 612     // TODO: Andy: There was a test failure because of integer overflow here. Should I do</span>
<span class="line-removed"> 613     // &quot;safe subtraction&quot; everywhere in the code?  What&#39;s the nicest way to do it?</span>
 614     int position = safeSubtract(magnitude, scale);
 615 
<span class="line-modified"> 616     if (position &lt;= 0 &amp;&amp; !isApproximate) {</span>



 617         // All digits are to the left of the rounding magnitude.
 618     } else if (precision == 0) {
 619         // No rounding for zero.
 620     } else {
 621         // Perform rounding logic.
 622         // &quot;leading&quot; = most significant digit to the right of rounding
<span class="line-removed"> 623         // &quot;trailing&quot; = least significant digit to the left of rounding</span>
 624         int8_t leadingDigit = getDigitPos(safeSubtract(position, 1));
<span class="line-removed"> 625         int8_t trailingDigit = getDigitPos(position);</span>
 626 
 627         // Compute which section of the number we are in.
 628         // EDGE means we are at the bottom or top edge, like 1.000 or 1.999 (used by doubles)
 629         // LOWER means we are between the bottom edge and the midpoint, like 1.391
 630         // MIDPOINT means we are exactly in the middle, like 1.500
 631         // UPPER means we are between the midpoint and the top edge, like 1.916
<span class="line-modified"> 632         roundingutils::Section section = roundingutils::SECTION_MIDPOINT;</span>
 633         if (!isApproximate) {
<span class="line-modified"> 634             if (leadingDigit &lt; 5) {</span>
















 635                 section = roundingutils::SECTION_LOWER;
 636             } else if (leadingDigit &gt; 5) {

 637                 section = roundingutils::SECTION_UPPER;
 638             } else {


 639                 for (int p = safeSubtract(position, 2); p &gt;= 0; p--) {
 640                     if (getDigitPos(p) != 0) {
 641                         section = roundingutils::SECTION_UPPER;
 642                         break;
 643                     }
 644                 }
 645             }
 646         } else {
 647             int32_t p = safeSubtract(position, 2);
 648             int32_t minP = uprv_max(0, precision - 14);
<span class="line-modified"> 649             if (leadingDigit == 0) {</span>
 650                 section = roundingutils::SECTION_LOWER_EDGE;
 651                 for (; p &gt;= minP; p--) {
 652                     if (getDigitPos(p) != 0) {
 653                         section = roundingutils::SECTION_LOWER;
 654                         break;
 655                     }
 656                 }
<span class="line-modified"> 657             } else if (leadingDigit == 4) {</span>

 658                 for (; p &gt;= minP; p--) {
 659                     if (getDigitPos(p) != 9) {
 660                         section = roundingutils::SECTION_LOWER;
 661                         break;
 662                     }
 663                 }
<span class="line-modified"> 664             } else if (leadingDigit == 5) {</span>

 665                 for (; p &gt;= minP; p--) {
 666                     if (getDigitPos(p) != 0) {
 667                         section = roundingutils::SECTION_UPPER;
 668                         break;
 669                     }
 670                 }
<span class="line-modified"> 671             } else if (leadingDigit == 9) {</span>
 672                 section = roundingutils::SECTION_UPPER_EDGE;
 673                 for (; p &gt;= minP; p--) {
 674                     if (getDigitPos(p) != 9) {
 675                         section = roundingutils::SECTION_UPPER;
 676                         break;
 677                     }
 678                 }















 679             } else if (leadingDigit &lt; 5) {

 680                 section = roundingutils::SECTION_LOWER;
 681             } else {

 682                 section = roundingutils::SECTION_UPPER;
 683             }
 684 
 685             bool roundsAtMidpoint = roundingutils::roundsAtMidpoint(roundingMode);
 686             if (safeSubtract(position, 1) &lt; precision - 14 ||
 687                 (roundsAtMidpoint &amp;&amp; section == roundingutils::SECTION_MIDPOINT) ||
 688                 (!roundsAtMidpoint &amp;&amp; section &lt; 0 /* i.e. at upper or lower edge */)) {
<span class="line-modified"> 689                 // Oops! This means that we have to get the exact representation of the double, because</span>
<span class="line-modified"> 690                 // the zone of uncertainty is along the rounding boundary.</span>
 691                 convertToAccurateDouble();
<span class="line-modified"> 692                 roundToMagnitude(magnitude, roundingMode, status); // start over</span>
 693                 return;
 694             }
 695 
 696             // Turn off the approximate double flag, since the value is now confirmed to be exact.
 697             isApproximate = false;
 698             origDouble = 0.0;
 699             origDelta = 0;
 700 
<span class="line-modified"> 701             if (position &lt;= 0) {</span>
 702                 // All digits are to the left of the rounding magnitude.
 703                 return;
 704             }
 705 
 706             // Good to continue rounding.
 707             if (section == -1) { section = roundingutils::SECTION_LOWER; }
 708             if (section == -2) { section = roundingutils::SECTION_UPPER; }
 709         }
 710 
<span class="line-modified"> 711         bool roundDown = roundingutils::getRoundingDirection((trailingDigit % 2) == 0,</span>







 712                 isNegative(),
 713                 section,
 714                 roundingMode,
 715                 status);
 716         if (U_FAILURE(status)) {
 717             return;
 718         }
 719 
 720         // Perform truncation
 721         if (position &gt;= precision) {
 722             setBcdToZero();
 723             scale = magnitude;
 724         } else {
 725             shiftRight(position);
 726         }
 727 
















 728         // Bubble the result to the higher digits
 729         if (!roundDown) {
 730             if (trailingDigit == 9) {
 731                 int bubblePos = 0;
<span class="line-modified"> 732                 // Note: in the long implementation, the most digits BCD can have at this point is 15,</span>
<span class="line-modified"> 733                 // so bubblePos &lt;= 15 and getDigitPos(bubblePos) is safe.</span>
 734                 for (; getDigitPos(bubblePos) == 9; bubblePos++) {}
 735                 shiftRight(bubblePos); // shift off the trailing 9s
 736             }
 737             int8_t digit0 = getDigitPos(0);
 738             U_ASSERT(digit0 != 9);
 739             setDigitPos(0, static_cast&lt;int8_t&gt;(digit0 + 1));
 740             precision += 1; // in case an extra digit got added
 741         }
 742 
 743         compact();
 744     }
 745 }
 746 
 747 void DecimalQuantity::roundToInfinity() {
 748     if (isApproximate) {
 749         convertToAccurateDouble();
 750     }
 751 }
 752 
 753 void DecimalQuantity::appendDigit(int8_t value, int32_t leadingZeros, bool appendAsInteger) {
</pre>
<hr />
<pre>
 789     if (precision == 0 || getMagnitude() &lt; 0) {
 790         sb.append(u&#39;0&#39;);
 791     }
 792     for (int m = getUpperDisplayMagnitude(); m &gt;= getLowerDisplayMagnitude(); m--) {
 793         if (m == -1) { sb.append(u&#39;.&#39;); }
 794         sb.append(getDigit(m) + u&#39;0&#39;);
 795     }
 796     return sb;
 797 }
 798 
 799 UnicodeString DecimalQuantity::toScientificString() const {
 800     U_ASSERT(!isApproximate);
 801     UnicodeString result;
 802     if (isNegative()) {
 803         result.append(u&#39;-&#39;);
 804     }
 805     if (precision == 0) {
 806         result.append(u&quot;0E+0&quot;, -1);
 807         return result;
 808     }
<span class="line-modified"> 809     // NOTE: It is not safe to add to lOptPos (aka maxInt) or subtract from</span>
<span class="line-modified"> 810     // rOptPos (aka -maxFrac) due to overflow.</span>
<span class="line-removed"> 811     int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;</span>
<span class="line-removed"> 812     int32_t lowerPos = std::max(scale, rOptPos) - scale;</span>
 813     int32_t p = upperPos;
 814     result.append(u&#39;0&#39; + getDigitPos(p));
 815     if ((--p) &gt;= lowerPos) {
 816         result.append(u&#39;.&#39;);
 817         for (; p &gt;= lowerPos; p--) {
 818             result.append(u&#39;0&#39; + getDigitPos(p));
 819         }
 820     }
 821     result.append(u&#39;E&#39;);
 822     int32_t _scale = upperPos + scale;
<span class="line-modified"> 823     if (_scale &lt; 0) {</span>



 824         _scale *= -1;
 825         result.append(u&#39;-&#39;);
 826     } else {
 827         result.append(u&#39;+&#39;);
 828     }
 829     if (_scale == 0) {
 830         result.append(u&#39;0&#39;);
 831     }
 832     int32_t insertIndex = result.length();
 833     while (_scale &gt; 0) {
 834         std::div_t res = std::div(_scale, 10);
 835         result.insert(insertIndex, u&#39;0&#39; + res.rem);
 836         _scale = res.quot;
 837     }
 838     return result;
 839 }
 840 
 841 ////////////////////////////////////////////////////
 842 /// End of DecimalQuantity_AbstractBCD.java      ///
 843 /// Start of DecimalQuantity_DualStorageBCD.java ///
</pre>
<hr />
<pre>
 887     scale -= numDigits;
 888     precision += numDigits;
 889 }
 890 
 891 void DecimalQuantity::shiftRight(int32_t numDigits) {
 892     if (usingBytes) {
 893         int i = 0;
 894         for (; i &lt; precision - numDigits; i++) {
 895             fBCD.bcdBytes.ptr[i] = fBCD.bcdBytes.ptr[i + numDigits];
 896         }
 897         for (; i &lt; precision; i++) {
 898             fBCD.bcdBytes.ptr[i] = 0;
 899         }
 900     } else {
 901         fBCD.bcdLong &gt;&gt;= (numDigits * 4);
 902     }
 903     scale += numDigits;
 904     precision -= numDigits;
 905 }
 906 













 907 void DecimalQuantity::setBcdToZero() {
 908     if (usingBytes) {
 909         uprv_free(fBCD.bcdBytes.ptr);
 910         fBCD.bcdBytes.ptr = nullptr;
 911         usingBytes = false;
 912     }
 913     fBCD.bcdLong = 0L;
 914     scale = 0;
 915     precision = 0;
 916     isApproximate = false;
 917     origDouble = 0;
 918     origDelta = 0;
 919 }
 920 
 921 void DecimalQuantity::readIntToBcd(int32_t n) {
 922     U_ASSERT(n != 0);
 923     // ints always fit inside the long implementation.
 924     uint64_t result = 0L;
 925     int i = 16;
 926     for (; n != 0; n /= 10, i--) {
</pre>
<hr />
<pre>
1137         if (precision != 0 &amp;&amp; getDigitPos(precision - 1) == 0) {
1138             return u&quot;Most significant digit is zero in long mode&quot;;
1139         }
1140         if (precision != 0 &amp;&amp; getDigitPos(0) == 0) {
1141             return u&quot;Least significant digit is zero in long mode&quot;;
1142         }
1143         for (int i = 0; i &lt; precision; i++) {
1144             if (getDigitPos(i) &gt;= 10) { return u&quot;Digit exceeding 10 in long&quot;; }
1145             if (getDigitPos(i) &lt; 0) { return u&quot;Digit below 0 in long (?!)&quot;; }
1146         }
1147         for (int i = precision; i &lt; 16; i++) {
1148             if (getDigitPos(i) != 0) { return u&quot;Nonzero digits outside of range in long&quot;; }
1149         }
1150     }
1151 
1152     // No error
1153     return nullptr;
1154 }
1155 
1156 bool DecimalQuantity::operator==(const DecimalQuantity&amp; other) const {
<span class="line-modified">1157     // FIXME: Make a faster implementation.</span>
<span class="line-modified">1158     return toString() == other.toString();</span>





















1159 }
1160 
1161 UnicodeString DecimalQuantity::toString() const {
1162     MaybeStackArray&lt;char, 30&gt; digits(precision + 1);
1163     for (int32_t i = 0; i &lt; precision; i++) {
1164         digits[i] = getDigitPos(precision - i - 1) + &#39;0&#39;;
1165     }
1166     digits[precision] = 0; // terminate buffer
1167     char buffer8[100];
1168     snprintf(
1169             buffer8,
1170             sizeof(buffer8),
<span class="line-modified">1171             &quot;&lt;DecimalQuantity %d:%d:%d:%d %s %s%s%s%d&gt;&quot;,</span>
<span class="line-removed">1172             (lOptPos &gt; 999 ? 999 : lOptPos),</span>
1173             lReqPos,
1174             rReqPos,
<span class="line-removed">1175             (rOptPos &lt; -999 ? -999 : rOptPos),</span>
1176             (usingBytes ? &quot;bytes&quot; : &quot;long&quot;),
1177             (isNegative() ? &quot;-&quot; : &quot;&quot;),
1178             (precision == 0 ? &quot;0&quot; : digits.getAlias()),
1179             &quot;E&quot;,
1180             scale);
1181     return UnicodeString(buffer8, -1, US_INV);
1182 }
1183 
1184 #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
</td>
<td>
<hr />
<pre>
  95 DecimalQuantity &amp;DecimalQuantity::operator=(const DecimalQuantity &amp;other) {
  96     if (this == &amp;other) {
  97         return *this;
  98     }
  99     copyBcdFrom(other);
 100     copyFieldsFrom(other);
 101     return *this;
 102 }
 103 
 104 DecimalQuantity&amp; DecimalQuantity::operator=(DecimalQuantity&amp;&amp; src) U_NOEXCEPT {
 105     if (this == &amp;src) {
 106         return *this;
 107     }
 108     moveBcdFrom(src);
 109     copyFieldsFrom(src);
 110     return *this;
 111 }
 112 
 113 void DecimalQuantity::copyFieldsFrom(const DecimalQuantity&amp; other) {
 114     bogus = other.bogus;

 115     lReqPos = other.lReqPos;
 116     rReqPos = other.rReqPos;

 117     scale = other.scale;
 118     precision = other.precision;
 119     flags = other.flags;
 120     origDouble = other.origDouble;
 121     origDelta = other.origDelta;
 122     isApproximate = other.isApproximate;
 123 }
 124 
 125 void DecimalQuantity::clear() {

 126     lReqPos = 0;
 127     rReqPos = 0;

 128     flags = 0;
 129     setBcdToZero(); // sets scale, precision, hasDouble, origDouble, origDelta, and BCD data
 130 }
 131 
<span class="line-modified"> 132 void DecimalQuantity::setMinInteger(int32_t minInt) {</span>
 133     // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.
 134     U_ASSERT(minInt &gt;= 0);

 135 
 136     // Special behavior: do not set minInt to be less than what is already set.
 137     // This is so significant digits rounding can set the integer length.
 138     if (minInt &lt; lReqPos) {
 139         minInt = lReqPos;
 140     }
 141 
 142     // Save values into internal state


 143     lReqPos = minInt;
 144 }
 145 
<span class="line-modified"> 146 void DecimalQuantity::setMinFraction(int32_t minFrac) {</span>
 147     // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.
 148     U_ASSERT(minFrac &gt;= 0);

 149 
 150     // Save values into internal state
 151     // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE &gt; Integer.MIN_VALUE
 152     rReqPos = -minFrac;
<span class="line-modified"> 153 }</span>
<span class="line-added"> 154 </span>
<span class="line-added"> 155 void DecimalQuantity::applyMaxInteger(int32_t maxInt) {</span>
<span class="line-added"> 156     // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.</span>
<span class="line-added"> 157     U_ASSERT(maxInt &gt;= 0);</span>
<span class="line-added"> 158 </span>
<span class="line-added"> 159     if (precision == 0) {</span>
<span class="line-added"> 160         return;</span>
<span class="line-added"> 161     }</span>
<span class="line-added"> 162 </span>
<span class="line-added"> 163     if (maxInt &lt;= scale) {</span>
<span class="line-added"> 164         setBcdToZero();</span>
<span class="line-added"> 165         return;</span>
<span class="line-added"> 166     }</span>
<span class="line-added"> 167 </span>
<span class="line-added"> 168     int32_t magnitude = getMagnitude();</span>
<span class="line-added"> 169     if (maxInt &lt;= magnitude) {</span>
<span class="line-added"> 170         popFromLeft(magnitude - maxInt + 1);</span>
<span class="line-added"> 171         compact();</span>
<span class="line-added"> 172     }</span>
 173 }
 174 
 175 uint64_t DecimalQuantity::getPositionFingerprint() const {
 176     uint64_t fingerprint = 0;

 177     fingerprint ^= (lReqPos &lt;&lt; 16);
 178     fingerprint ^= (static_cast&lt;uint64_t&gt;(rReqPos) &lt;&lt; 32);

 179     return fingerprint;
 180 }
 181 
 182 void DecimalQuantity::roundToIncrement(double roundingIncrement, RoundingMode roundingMode,
<span class="line-modified"> 183                                        UErrorCode&amp; status) {</span>
<span class="line-modified"> 184     // Do not call this method with an increment having only a 1 or a 5 digit!</span>
<span class="line-modified"> 185     // Use a more efficient call to either roundToMagnitude() or roundToNickel().</span>
<span class="line-modified"> 186     // Check a few popular rounding increments; a more thorough check is in Java.</span>
<span class="line-modified"> 187     U_ASSERT(roundingIncrement != 0.01);</span>
<span class="line-modified"> 188     U_ASSERT(roundingIncrement != 0.05);</span>
<span class="line-modified"> 189     U_ASSERT(roundingIncrement != 0.1);</span>
<span class="line-modified"> 190     U_ASSERT(roundingIncrement != 0.5);</span>
<span class="line-modified"> 191     U_ASSERT(roundingIncrement != 1);</span>
<span class="line-modified"> 192     U_ASSERT(roundingIncrement != 5);</span>
<span class="line-modified"> 193 </span>
<span class="line-modified"> 194     DecNum incrementDN;</span>
<span class="line-modified"> 195     incrementDN.setTo(roundingIncrement, status);</span>
<span class="line-modified"> 196     if (U_FAILURE(status)) { return; }</span>
<span class="line-modified"> 197 </span>
<span class="line-modified"> 198     // Divide this DecimalQuantity by the increment, round, then multiply back.</span>
<span class="line-modified"> 199     divideBy(incrementDN, status);</span>
<span class="line-added"> 200     if (U_FAILURE(status)) { return; }</span>
<span class="line-added"> 201     roundToMagnitude(0, roundingMode, status);</span>
<span class="line-added"> 202     if (U_FAILURE(status)) { return; }</span>
<span class="line-added"> 203     multiplyBy(incrementDN, status);</span>
<span class="line-added"> 204     if (U_FAILURE(status)) { return; }</span>
 205 }
 206 
 207 void DecimalQuantity::multiplyBy(const DecNum&amp; multiplicand, UErrorCode&amp; status) {
 208     if (isInfinite() || isZero() || isNaN()) {
 209         return;
 210     }
 211     // Convert to DecNum, multiply, and convert back.
 212     DecNum decnum;
 213     toDecNum(decnum, status);
 214     if (U_FAILURE(status)) { return; }
 215     decnum.multiplyBy(multiplicand, status);
 216     if (U_FAILURE(status)) { return; }
 217     setToDecNum(decnum, status);
 218 }
 219 
 220 void DecimalQuantity::divideBy(const DecNum&amp; divisor, UErrorCode&amp; status) {
 221     if (isInfinite() || isZero() || isNaN()) {
 222         return;
 223     }
 224     // Convert to DecNum, multiply, and convert back.
</pre>
<hr />
<pre>
 267             return static_cast&lt;double&gt;(toFractionLong(false));
 268         case PLURAL_OPERAND_V:
 269             return fractionCount();
 270         case PLURAL_OPERAND_W:
 271             return fractionCountWithoutTrailingZeros();
 272         default:
 273             return std::abs(toDouble());
 274     }
 275 }
 276 
 277 bool DecimalQuantity::hasIntegerValue() const {
 278     return scale &gt;= 0;
 279 }
 280 
 281 int32_t DecimalQuantity::getUpperDisplayMagnitude() const {
 282     // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
 283     // See the comment in the header file explaining the &quot;isApproximate&quot; field.
 284     U_ASSERT(!isApproximate);
 285 
 286     int32_t magnitude = scale + precision;
<span class="line-modified"> 287     int32_t result = (lReqPos &gt; magnitude) ? lReqPos : magnitude;</span>
 288     return result - 1;
 289 }
 290 
 291 int32_t DecimalQuantity::getLowerDisplayMagnitude() const {
 292     // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
 293     // See the comment in the header file explaining the &quot;isApproximate&quot; field.
 294     U_ASSERT(!isApproximate);
 295 
 296     int32_t magnitude = scale;
<span class="line-modified"> 297     int32_t result = (rReqPos &lt; magnitude) ? rReqPos : magnitude;</span>
 298     return result;
 299 }
 300 
 301 int8_t DecimalQuantity::getDigit(int32_t magnitude) const {
 302     // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
 303     // See the comment at the top of this file explaining the &quot;isApproximate&quot; field.
 304     U_ASSERT(!isApproximate);
 305 
 306     return getDigitPos(magnitude - scale);
 307 }
 308 
 309 int32_t DecimalQuantity::fractionCount() const {
 310     return -getLowerDisplayMagnitude();
 311 }
 312 
 313 int32_t DecimalQuantity::fractionCountWithoutTrailingZeros() const {
 314     return -scale &gt; 0 ? -scale : 0;  // max(-scale, 0)
 315 }
 316 
 317 bool DecimalQuantity::isNegative() const {
</pre>
<hr />
<pre>
 498     _setToDecNum(decnum, status);
 499     return *this;
 500 }
 501 
 502 void DecimalQuantity::_setToDecNum(const DecNum&amp; decnum, UErrorCode&amp; status) {
 503     if (U_FAILURE(status)) { return; }
 504     if (decnum.isNegative()) {
 505         flags |= NEGATIVE_FLAG;
 506     }
 507     if (!decnum.isZero()) {
 508         readDecNumberToBcd(decnum);
 509         compact();
 510     }
 511 }
 512 
 513 int64_t DecimalQuantity::toLong(bool truncateIfOverflow) const {
 514     // NOTE: Call sites should be guarded by fitsInLong(), like this:
 515     // if (dq.fitsInLong()) { /* use dq.toLong() */ } else { /* use some fallback */ }
 516     // Fallback behavior upon truncateIfOverflow is to truncate at 17 digits.
 517     uint64_t result = 0L;
<span class="line-modified"> 518     int32_t upperMagnitude = scale + precision - 1;</span>
 519     if (truncateIfOverflow) {
 520         upperMagnitude = std::min(upperMagnitude, 17);
 521     }
 522     for (int32_t magnitude = upperMagnitude; magnitude &gt;= 0; magnitude--) {
 523         result = result * 10 + getDigitPos(magnitude - scale);
 524     }
 525     if (isNegative()) {
 526         return static_cast&lt;int64_t&gt;(0LL - result); // i.e., -result
 527     }
 528     return static_cast&lt;int64_t&gt;(result);
 529 }
 530 
 531 uint64_t DecimalQuantity::toFractionLong(bool includeTrailingZeros) const {
 532     uint64_t result = 0L;
 533     int32_t magnitude = -1;
<span class="line-modified"> 534     int32_t lowerMagnitude = scale;</span>
 535     if (includeTrailingZeros) {
 536         lowerMagnitude = std::min(lowerMagnitude, rReqPos);
 537     }
 538     for (; magnitude &gt;= lowerMagnitude &amp;&amp; result &lt;= 1e18L; magnitude--) {
 539         result = result * 10 + getDigitPos(magnitude - scale);
 540     }
 541     // Remove trailing zeros; this can happen during integer overflow cases.
 542     if (!includeTrailingZeros) {
 543         while (result &gt; 0 &amp;&amp; (result % 10) == 0) {
 544             result /= 10;
 545         }
 546     }
 547     return result;
 548 }
 549 
 550 bool DecimalQuantity::fitsInLong(bool ignoreFraction) const {
 551     if (isZero()) {
 552         return true;
 553     }
 554     if (scale &lt; 0 &amp;&amp; !ignoreFraction) {
</pre>
<hr />
<pre>
 603         output.setTo(&quot;0&quot;, status);
 604     }
 605 
 606     // Use the BCD constructor. We need to do a little bit of work to convert, though.
 607     // The decNumber constructor expects most-significant first, but we store least-significant first.
 608     MaybeStackArray&lt;uint8_t, 20&gt; ubcd(precision);
 609     for (int32_t m = 0; m &lt; precision; m++) {
 610         ubcd[precision - m - 1] = static_cast&lt;uint8_t&gt;(getDigitPos(m));
 611     }
 612     output.setTo(ubcd.getAlias(), precision, scale, isNegative(), status);
 613 }
 614 
 615 void DecimalQuantity::truncate() {
 616     if (scale &lt; 0) {
 617         shiftRight(-scale);
 618         scale = 0;
 619         compact();
 620     }
 621 }
 622 
<span class="line-added"> 623 void DecimalQuantity::roundToNickel(int32_t magnitude, RoundingMode roundingMode, UErrorCode&amp; status) {</span>
<span class="line-added"> 624     roundToMagnitude(magnitude, roundingMode, true, status);</span>
<span class="line-added"> 625 }</span>
<span class="line-added"> 626 </span>
 627 void DecimalQuantity::roundToMagnitude(int32_t magnitude, RoundingMode roundingMode, UErrorCode&amp; status) {
<span class="line-added"> 628     roundToMagnitude(magnitude, roundingMode, false, status);</span>
<span class="line-added"> 629 }</span>
<span class="line-added"> 630 </span>
<span class="line-added"> 631 void DecimalQuantity::roundToMagnitude(int32_t magnitude, RoundingMode roundingMode, bool nickel, UErrorCode&amp; status) {</span>
 632     // The position in the BCD at which rounding will be performed; digits to the right of position
 633     // will be rounded away.


 634     int position = safeSubtract(magnitude, scale);
 635 
<span class="line-modified"> 636     // &quot;trailing&quot; = least significant digit to the left of rounding</span>
<span class="line-added"> 637     int8_t trailingDigit = getDigitPos(position);</span>
<span class="line-added"> 638 </span>
<span class="line-added"> 639     if (position &lt;= 0 &amp;&amp; !isApproximate &amp;&amp; (!nickel || trailingDigit == 0 || trailingDigit == 5)) {</span>
 640         // All digits are to the left of the rounding magnitude.
 641     } else if (precision == 0) {
 642         // No rounding for zero.
 643     } else {
 644         // Perform rounding logic.
 645         // &quot;leading&quot; = most significant digit to the right of rounding

 646         int8_t leadingDigit = getDigitPos(safeSubtract(position, 1));

 647 
 648         // Compute which section of the number we are in.
 649         // EDGE means we are at the bottom or top edge, like 1.000 or 1.999 (used by doubles)
 650         // LOWER means we are between the bottom edge and the midpoint, like 1.391
 651         // MIDPOINT means we are exactly in the middle, like 1.500
 652         // UPPER means we are between the midpoint and the top edge, like 1.916
<span class="line-modified"> 653         roundingutils::Section section;</span>
 654         if (!isApproximate) {
<span class="line-modified"> 655             if (nickel &amp;&amp; trailingDigit != 2 &amp;&amp; trailingDigit != 7) {</span>
<span class="line-added"> 656                 // Nickel rounding, and not at .02x or .07x</span>
<span class="line-added"> 657                 if (trailingDigit &lt; 2) {</span>
<span class="line-added"> 658                     // .00, .01 =&gt; down to .00</span>
<span class="line-added"> 659                     section = roundingutils::SECTION_LOWER;</span>
<span class="line-added"> 660                 } else if (trailingDigit &lt; 5) {</span>
<span class="line-added"> 661                     // .03, .04 =&gt; up to .05</span>
<span class="line-added"> 662                     section = roundingutils::SECTION_UPPER;</span>
<span class="line-added"> 663                 } else if (trailingDigit &lt; 7) {</span>
<span class="line-added"> 664                     // .05, .06 =&gt; down to .05</span>
<span class="line-added"> 665                     section = roundingutils::SECTION_LOWER;</span>
<span class="line-added"> 666                 } else {</span>
<span class="line-added"> 667                     // .08, .09 =&gt; up to .10</span>
<span class="line-added"> 668                     section = roundingutils::SECTION_UPPER;</span>
<span class="line-added"> 669                 }</span>
<span class="line-added"> 670             } else if (leadingDigit &lt; 5) {</span>
<span class="line-added"> 671                 // Includes nickel rounding .020-.024 and .070-.074</span>
 672                 section = roundingutils::SECTION_LOWER;
 673             } else if (leadingDigit &gt; 5) {
<span class="line-added"> 674                 // Includes nickel rounding .026-.029 and .076-.079</span>
 675                 section = roundingutils::SECTION_UPPER;
 676             } else {
<span class="line-added"> 677                 // Includes nickel rounding .025 and .075</span>
<span class="line-added"> 678                 section = roundingutils::SECTION_MIDPOINT;</span>
 679                 for (int p = safeSubtract(position, 2); p &gt;= 0; p--) {
 680                     if (getDigitPos(p) != 0) {
 681                         section = roundingutils::SECTION_UPPER;
 682                         break;
 683                     }
 684                 }
 685             }
 686         } else {
 687             int32_t p = safeSubtract(position, 2);
 688             int32_t minP = uprv_max(0, precision - 14);
<span class="line-modified"> 689             if (leadingDigit == 0 &amp;&amp; (!nickel || trailingDigit == 0 || trailingDigit == 5)) {</span>
 690                 section = roundingutils::SECTION_LOWER_EDGE;
 691                 for (; p &gt;= minP; p--) {
 692                     if (getDigitPos(p) != 0) {
 693                         section = roundingutils::SECTION_LOWER;
 694                         break;
 695                     }
 696                 }
<span class="line-modified"> 697             } else if (leadingDigit == 4 &amp;&amp; (!nickel || trailingDigit == 2 || trailingDigit == 7)) {</span>
<span class="line-added"> 698                 section = roundingutils::SECTION_MIDPOINT;</span>
 699                 for (; p &gt;= minP; p--) {
 700                     if (getDigitPos(p) != 9) {
 701                         section = roundingutils::SECTION_LOWER;
 702                         break;
 703                     }
 704                 }
<span class="line-modified"> 705             } else if (leadingDigit == 5 &amp;&amp; (!nickel || trailingDigit == 2 || trailingDigit == 7)) {</span>
<span class="line-added"> 706                 section = roundingutils::SECTION_MIDPOINT;</span>
 707                 for (; p &gt;= minP; p--) {
 708                     if (getDigitPos(p) != 0) {
 709                         section = roundingutils::SECTION_UPPER;
 710                         break;
 711                     }
 712                 }
<span class="line-modified"> 713             } else if (leadingDigit == 9 &amp;&amp; (!nickel || trailingDigit == 4 || trailingDigit == 9)) {</span>
 714                 section = roundingutils::SECTION_UPPER_EDGE;
 715                 for (; p &gt;= minP; p--) {
 716                     if (getDigitPos(p) != 9) {
 717                         section = roundingutils::SECTION_UPPER;
 718                         break;
 719                     }
 720                 }
<span class="line-added"> 721             } else if (nickel &amp;&amp; trailingDigit != 2 &amp;&amp; trailingDigit != 7) {</span>
<span class="line-added"> 722                 // Nickel rounding, and not at .02x or .07x</span>
<span class="line-added"> 723                 if (trailingDigit &lt; 2) {</span>
<span class="line-added"> 724                     // .00, .01 =&gt; down to .00</span>
<span class="line-added"> 725                     section = roundingutils::SECTION_LOWER;</span>
<span class="line-added"> 726                 } else if (trailingDigit &lt; 5) {</span>
<span class="line-added"> 727                     // .03, .04 =&gt; up to .05</span>
<span class="line-added"> 728                     section = roundingutils::SECTION_UPPER;</span>
<span class="line-added"> 729                 } else if (trailingDigit &lt; 7) {</span>
<span class="line-added"> 730                     // .05, .06 =&gt; down to .05</span>
<span class="line-added"> 731                     section = roundingutils::SECTION_LOWER;</span>
<span class="line-added"> 732                 } else {</span>
<span class="line-added"> 733                     // .08, .09 =&gt; up to .10</span>
<span class="line-added"> 734                     section = roundingutils::SECTION_UPPER;</span>
<span class="line-added"> 735                 }</span>
 736             } else if (leadingDigit &lt; 5) {
<span class="line-added"> 737                 // Includes nickel rounding .020-.024 and .070-.074</span>
 738                 section = roundingutils::SECTION_LOWER;
 739             } else {
<span class="line-added"> 740                 // Includes nickel rounding .026-.029 and .076-.079</span>
 741                 section = roundingutils::SECTION_UPPER;
 742             }
 743 
 744             bool roundsAtMidpoint = roundingutils::roundsAtMidpoint(roundingMode);
 745             if (safeSubtract(position, 1) &lt; precision - 14 ||
 746                 (roundsAtMidpoint &amp;&amp; section == roundingutils::SECTION_MIDPOINT) ||
 747                 (!roundsAtMidpoint &amp;&amp; section &lt; 0 /* i.e. at upper or lower edge */)) {
<span class="line-modified"> 748                 // Oops! This means that we have to get the exact representation of the double,</span>
<span class="line-modified"> 749                 // because the zone of uncertainty is along the rounding boundary.</span>
 750                 convertToAccurateDouble();
<span class="line-modified"> 751                 roundToMagnitude(magnitude, roundingMode, nickel, status); // start over</span>
 752                 return;
 753             }
 754 
 755             // Turn off the approximate double flag, since the value is now confirmed to be exact.
 756             isApproximate = false;
 757             origDouble = 0.0;
 758             origDelta = 0;
 759 
<span class="line-modified"> 760             if (position &lt;= 0 &amp;&amp; (!nickel || trailingDigit == 0 || trailingDigit == 5)) {</span>
 761                 // All digits are to the left of the rounding magnitude.
 762                 return;
 763             }
 764 
 765             // Good to continue rounding.
 766             if (section == -1) { section = roundingutils::SECTION_LOWER; }
 767             if (section == -2) { section = roundingutils::SECTION_UPPER; }
 768         }
 769 
<span class="line-modified"> 770         // Nickel rounding &quot;half even&quot; goes to the nearest whole (away from the 5).</span>
<span class="line-added"> 771         bool isEven = nickel</span>
<span class="line-added"> 772                 ? (trailingDigit &lt; 2 || trailingDigit &gt; 7</span>
<span class="line-added"> 773                         || (trailingDigit == 2 &amp;&amp; section != roundingutils::SECTION_UPPER)</span>
<span class="line-added"> 774                         || (trailingDigit == 7 &amp;&amp; section == roundingutils::SECTION_UPPER))</span>
<span class="line-added"> 775                 : (trailingDigit % 2) == 0;</span>
<span class="line-added"> 776 </span>
<span class="line-added"> 777         bool roundDown = roundingutils::getRoundingDirection(isEven,</span>
 778                 isNegative(),
 779                 section,
 780                 roundingMode,
 781                 status);
 782         if (U_FAILURE(status)) {
 783             return;
 784         }
 785 
 786         // Perform truncation
 787         if (position &gt;= precision) {
 788             setBcdToZero();
 789             scale = magnitude;
 790         } else {
 791             shiftRight(position);
 792         }
 793 
<span class="line-added"> 794         if (nickel) {</span>
<span class="line-added"> 795             if (trailingDigit &lt; 5 &amp;&amp; roundDown) {</span>
<span class="line-added"> 796                 setDigitPos(0, 0);</span>
<span class="line-added"> 797                 compact();</span>
<span class="line-added"> 798                 return;</span>
<span class="line-added"> 799             } else if (trailingDigit &gt;= 5 &amp;&amp; !roundDown) {</span>
<span class="line-added"> 800                 setDigitPos(0, 9);</span>
<span class="line-added"> 801                 trailingDigit = 9;</span>
<span class="line-added"> 802                 // do not return: use the bubbling logic below</span>
<span class="line-added"> 803             } else {</span>
<span class="line-added"> 804                 setDigitPos(0, 5);</span>
<span class="line-added"> 805                 // compact not necessary: digit at position 0 is nonzero</span>
<span class="line-added"> 806                 return;</span>
<span class="line-added"> 807             }</span>
<span class="line-added"> 808         }</span>
<span class="line-added"> 809 </span>
 810         // Bubble the result to the higher digits
 811         if (!roundDown) {
 812             if (trailingDigit == 9) {
 813                 int bubblePos = 0;
<span class="line-modified"> 814                 // Note: in the long implementation, the most digits BCD can have at this point is</span>
<span class="line-modified"> 815                 // 15, so bubblePos &lt;= 15 and getDigitPos(bubblePos) is safe.</span>
 816                 for (; getDigitPos(bubblePos) == 9; bubblePos++) {}
 817                 shiftRight(bubblePos); // shift off the trailing 9s
 818             }
 819             int8_t digit0 = getDigitPos(0);
 820             U_ASSERT(digit0 != 9);
 821             setDigitPos(0, static_cast&lt;int8_t&gt;(digit0 + 1));
 822             precision += 1; // in case an extra digit got added
 823         }
 824 
 825         compact();
 826     }
 827 }
 828 
 829 void DecimalQuantity::roundToInfinity() {
 830     if (isApproximate) {
 831         convertToAccurateDouble();
 832     }
 833 }
 834 
 835 void DecimalQuantity::appendDigit(int8_t value, int32_t leadingZeros, bool appendAsInteger) {
</pre>
<hr />
<pre>
 871     if (precision == 0 || getMagnitude() &lt; 0) {
 872         sb.append(u&#39;0&#39;);
 873     }
 874     for (int m = getUpperDisplayMagnitude(); m &gt;= getLowerDisplayMagnitude(); m--) {
 875         if (m == -1) { sb.append(u&#39;.&#39;); }
 876         sb.append(getDigit(m) + u&#39;0&#39;);
 877     }
 878     return sb;
 879 }
 880 
 881 UnicodeString DecimalQuantity::toScientificString() const {
 882     U_ASSERT(!isApproximate);
 883     UnicodeString result;
 884     if (isNegative()) {
 885         result.append(u&#39;-&#39;);
 886     }
 887     if (precision == 0) {
 888         result.append(u&quot;0E+0&quot;, -1);
 889         return result;
 890     }
<span class="line-modified"> 891     int32_t upperPos = precision - 1;</span>
<span class="line-modified"> 892     int32_t lowerPos = 0;</span>


 893     int32_t p = upperPos;
 894     result.append(u&#39;0&#39; + getDigitPos(p));
 895     if ((--p) &gt;= lowerPos) {
 896         result.append(u&#39;.&#39;);
 897         for (; p &gt;= lowerPos; p--) {
 898             result.append(u&#39;0&#39; + getDigitPos(p));
 899         }
 900     }
 901     result.append(u&#39;E&#39;);
 902     int32_t _scale = upperPos + scale;
<span class="line-modified"> 903     if (_scale == INT32_MIN) {</span>
<span class="line-added"> 904         result.append({u&quot;-2147483648&quot;, -1});</span>
<span class="line-added"> 905         return result;</span>
<span class="line-added"> 906     } else if (_scale &lt; 0) {</span>
 907         _scale *= -1;
 908         result.append(u&#39;-&#39;);
 909     } else {
 910         result.append(u&#39;+&#39;);
 911     }
 912     if (_scale == 0) {
 913         result.append(u&#39;0&#39;);
 914     }
 915     int32_t insertIndex = result.length();
 916     while (_scale &gt; 0) {
 917         std::div_t res = std::div(_scale, 10);
 918         result.insert(insertIndex, u&#39;0&#39; + res.rem);
 919         _scale = res.quot;
 920     }
 921     return result;
 922 }
 923 
 924 ////////////////////////////////////////////////////
 925 /// End of DecimalQuantity_AbstractBCD.java      ///
 926 /// Start of DecimalQuantity_DualStorageBCD.java ///
</pre>
<hr />
<pre>
 970     scale -= numDigits;
 971     precision += numDigits;
 972 }
 973 
 974 void DecimalQuantity::shiftRight(int32_t numDigits) {
 975     if (usingBytes) {
 976         int i = 0;
 977         for (; i &lt; precision - numDigits; i++) {
 978             fBCD.bcdBytes.ptr[i] = fBCD.bcdBytes.ptr[i + numDigits];
 979         }
 980         for (; i &lt; precision; i++) {
 981             fBCD.bcdBytes.ptr[i] = 0;
 982         }
 983     } else {
 984         fBCD.bcdLong &gt;&gt;= (numDigits * 4);
 985     }
 986     scale += numDigits;
 987     precision -= numDigits;
 988 }
 989 
<span class="line-added"> 990 void DecimalQuantity::popFromLeft(int32_t numDigits) {</span>
<span class="line-added"> 991     U_ASSERT(numDigits &lt;= precision);</span>
<span class="line-added"> 992     if (usingBytes) {</span>
<span class="line-added"> 993         int i = precision - 1;</span>
<span class="line-added"> 994         for (; i &gt;= precision - numDigits; i--) {</span>
<span class="line-added"> 995             fBCD.bcdBytes.ptr[i] = 0;</span>
<span class="line-added"> 996         }</span>
<span class="line-added"> 997     } else {</span>
<span class="line-added"> 998         fBCD.bcdLong &amp;= (static_cast&lt;uint64_t&gt;(1) &lt;&lt; ((precision - numDigits) * 4)) - 1;</span>
<span class="line-added"> 999     }</span>
<span class="line-added">1000     precision -= numDigits;</span>
<span class="line-added">1001 }</span>
<span class="line-added">1002 </span>
1003 void DecimalQuantity::setBcdToZero() {
1004     if (usingBytes) {
1005         uprv_free(fBCD.bcdBytes.ptr);
1006         fBCD.bcdBytes.ptr = nullptr;
1007         usingBytes = false;
1008     }
1009     fBCD.bcdLong = 0L;
1010     scale = 0;
1011     precision = 0;
1012     isApproximate = false;
1013     origDouble = 0;
1014     origDelta = 0;
1015 }
1016 
1017 void DecimalQuantity::readIntToBcd(int32_t n) {
1018     U_ASSERT(n != 0);
1019     // ints always fit inside the long implementation.
1020     uint64_t result = 0L;
1021     int i = 16;
1022     for (; n != 0; n /= 10, i--) {
</pre>
<hr />
<pre>
1233         if (precision != 0 &amp;&amp; getDigitPos(precision - 1) == 0) {
1234             return u&quot;Most significant digit is zero in long mode&quot;;
1235         }
1236         if (precision != 0 &amp;&amp; getDigitPos(0) == 0) {
1237             return u&quot;Least significant digit is zero in long mode&quot;;
1238         }
1239         for (int i = 0; i &lt; precision; i++) {
1240             if (getDigitPos(i) &gt;= 10) { return u&quot;Digit exceeding 10 in long&quot;; }
1241             if (getDigitPos(i) &lt; 0) { return u&quot;Digit below 0 in long (?!)&quot;; }
1242         }
1243         for (int i = precision; i &lt; 16; i++) {
1244             if (getDigitPos(i) != 0) { return u&quot;Nonzero digits outside of range in long&quot;; }
1245         }
1246     }
1247 
1248     // No error
1249     return nullptr;
1250 }
1251 
1252 bool DecimalQuantity::operator==(const DecimalQuantity&amp; other) const {
<span class="line-modified">1253     bool basicEquals =</span>
<span class="line-modified">1254             scale == other.scale</span>
<span class="line-added">1255             &amp;&amp; precision == other.precision</span>
<span class="line-added">1256             &amp;&amp; flags == other.flags</span>
<span class="line-added">1257             &amp;&amp; lReqPos == other.lReqPos</span>
<span class="line-added">1258             &amp;&amp; rReqPos == other.rReqPos</span>
<span class="line-added">1259             &amp;&amp; isApproximate == other.isApproximate;</span>
<span class="line-added">1260     if (!basicEquals) {</span>
<span class="line-added">1261         return false;</span>
<span class="line-added">1262     }</span>
<span class="line-added">1263 </span>
<span class="line-added">1264     if (precision == 0) {</span>
<span class="line-added">1265         return true;</span>
<span class="line-added">1266     } else if (isApproximate) {</span>
<span class="line-added">1267         return origDouble == other.origDouble &amp;&amp; origDelta == other.origDelta;</span>
<span class="line-added">1268     } else {</span>
<span class="line-added">1269         for (int m = getUpperDisplayMagnitude(); m &gt;= getLowerDisplayMagnitude(); m--) {</span>
<span class="line-added">1270             if (getDigit(m) != other.getDigit(m)) {</span>
<span class="line-added">1271                 return false;</span>
<span class="line-added">1272             }</span>
<span class="line-added">1273         }</span>
<span class="line-added">1274         return true;</span>
<span class="line-added">1275     }</span>
1276 }
1277 
1278 UnicodeString DecimalQuantity::toString() const {
1279     MaybeStackArray&lt;char, 30&gt; digits(precision + 1);
1280     for (int32_t i = 0; i &lt; precision; i++) {
1281         digits[i] = getDigitPos(precision - i - 1) + &#39;0&#39;;
1282     }
1283     digits[precision] = 0; // terminate buffer
1284     char buffer8[100];
1285     snprintf(
1286             buffer8,
1287             sizeof(buffer8),
<span class="line-modified">1288             &quot;&lt;DecimalQuantity %d:%d %s %s%s%s%d&gt;&quot;,</span>

1289             lReqPos,
1290             rReqPos,

1291             (usingBytes ? &quot;bytes&quot; : &quot;long&quot;),
1292             (isNegative() ? &quot;-&quot; : &quot;&quot;),
1293             (precision == 0 ? &quot;0&quot; : digits.getAlias()),
1294             &quot;E&quot;,
1295             scale);
1296     return UnicodeString(buffer8, -1, US_INV);
1297 }
1298 
1299 #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
</td>
</tr>
</table>
<center><a href="number_compact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_decimalquantity.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>