<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/rbnf.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 * Copyright (C) 1997-2015, International Business Machines Corporation and others.
   6 * All Rights Reserved.
   7 *******************************************************************************
   8 */
   9 
  10 #ifndef RBNF_H
  11 #define RBNF_H
  12 
  13 #include &quot;unicode/utypes.h&quot;
  14 
  15 /**
  16  * \file
  17  * \brief C++ API: Rule Based Number Format
  18  */
  19 
  20 /**
  21  * \def U_HAVE_RBNF
  22  * This will be 0 if RBNF support is not included in ICU
  23  * and 1 if it is.
  24  *
  25  * @stable ICU 2.4
  26  */
  27 #if UCONFIG_NO_FORMATTING
  28 #define U_HAVE_RBNF 0
  29 #else
  30 #define U_HAVE_RBNF 1
  31 
  32 #include &quot;unicode/dcfmtsym.h&quot;
  33 #include &quot;unicode/fmtable.h&quot;
  34 #include &quot;unicode/locid.h&quot;
  35 #include &quot;unicode/numfmt.h&quot;
  36 #include &quot;unicode/unistr.h&quot;
  37 #include &quot;unicode/strenum.h&quot;
  38 #include &quot;unicode/brkiter.h&quot;
  39 #include &quot;unicode/upluralrules.h&quot;
  40 
  41 U_NAMESPACE_BEGIN
  42 
  43 class NFRule;
  44 class NFRuleSet;
  45 class LocalizationInfo;
  46 class PluralFormat;
  47 class RuleBasedCollator;
  48 
  49 /**
  50  * Tags for the predefined rulesets.
  51  *
  52  * @stable ICU 2.2
  53  */
  54 enum URBNFRuleSetTag {
  55     URBNF_SPELLOUT,
  56     URBNF_ORDINAL,
  57     URBNF_DURATION,
  58     URBNF_NUMBERING_SYSTEM,
  59 #ifndef U_HIDE_DEPRECATED_API
  60     /**
  61      * One more than the highest normal URBNFRuleSetTag value.
  62      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
  63      */
  64     URBNF_COUNT
  65 #endif  // U_HIDE_DEPRECATED_API
  66 };
  67 
  68 /**
  69  * The RuleBasedNumberFormat class formats numbers according to a set of rules. This number formatter is
  70  * typically used for spelling out numeric values in words (e.g., 25,3476 as
  71  * &amp;quot;twenty-five thousand three hundred seventy-six&amp;quot; or &amp;quot;vingt-cinq mille trois
  72  * cents soixante-seize&amp;quot; or
  73  * &amp;quot;f&amp;uuml;nfundzwanzigtausenddreihundertsechsundsiebzig&amp;quot;), but can also be used for
  74  * other complicated formatting tasks, such as formatting a number of seconds as hours,
  75  * minutes and seconds (e.g., 3,730 as &amp;quot;1:02:10&amp;quot;).
  76  *
  77  * &lt;p&gt;The resources contain three predefined formatters for each locale: spellout, which
  78  * spells out a value in words (123 is &amp;quot;one hundred twenty-three&amp;quot;); ordinal, which
  79  * appends an ordinal suffix to the end of a numeral (123 is &amp;quot;123rd&amp;quot;); and
  80  * duration, which shows a duration in seconds as hours, minutes, and seconds (123 is
  81  * &amp;quot;2:03&amp;quot;).&amp;nbsp; The client can also define more specialized &lt;tt&gt;RuleBasedNumberFormat&lt;/tt&gt;s
  82  * by supplying programmer-defined rule sets.&lt;/p&gt;
  83  *
  84  * &lt;p&gt;The behavior of a &lt;tt&gt;RuleBasedNumberFormat&lt;/tt&gt; is specified by a textual description
  85  * that is either passed to the constructor as a &lt;tt&gt;String&lt;/tt&gt; or loaded from a resource
  86  * bundle. In its simplest form, the description consists of a semicolon-delimited list of &lt;em&gt;rules.&lt;/em&gt;
  87  * Each rule has a string of output text and a value or range of values it is applicable to.
  88  * In a typical spellout rule set, the first twenty rules are the words for the numbers from
  89  * 0 to 19:&lt;/p&gt;
  90  *
  91  * &lt;pre&gt;zero; one; two; three; four; five; six; seven; eight; nine;
  92  * ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen; seventeen; eighteen; nineteen;&lt;/pre&gt;
  93  *
  94  * &lt;p&gt;For larger numbers, we can use the preceding set of rules to format the ones place, and
  95  * we only have to supply the words for the multiples of 10:&lt;/p&gt;
  96  *
  97  * &lt;pre&gt; 20: twenty[-&amp;gt;&amp;gt;];
  98  * 30: thirty[-&amp;gt;&amp;gt;];
  99  * 40: forty[-&amp;gt;&amp;gt;];
 100  * 50: fifty[-&amp;gt;&amp;gt;];
 101  * 60: sixty[-&amp;gt;&amp;gt;];
 102  * 70: seventy[-&amp;gt;&amp;gt;];
 103  * 80: eighty[-&amp;gt;&amp;gt;];
 104  * 90: ninety[-&amp;gt;&amp;gt;];&lt;/pre&gt;
 105  *
 106  * &lt;p&gt;In these rules, the &lt;em&gt;base value&lt;/em&gt; is spelled out explicitly and set off from the
 107  * rule&#39;s output text with a colon. The rules are in a sorted list, and a rule is applicable
 108  * to all numbers from its own base value to one less than the next rule&#39;s base value. The
 109  * &amp;quot;&amp;gt;&amp;gt;&amp;quot; token is called a &lt;em&gt;substitution&lt;/em&gt; and tells the fomatter to
 110  * isolate the number&#39;s ones digit, format it using this same set of rules, and place the
 111  * result at the position of the &amp;quot;&amp;gt;&amp;gt;&amp;quot; token. Text in brackets is omitted if
 112  * the number being formatted is an even multiple of 10 (the hyphen is a literal hyphen; 24
 113  * is &amp;quot;twenty-four,&amp;quot; not &amp;quot;twenty four&amp;quot;).&lt;/p&gt;
 114  *
 115  * &lt;p&gt;For even larger numbers, we can actually look up several parts of the number in the
 116  * list:&lt;/p&gt;
 117  *
 118  * &lt;pre&gt;100: &amp;lt;&amp;lt; hundred[ &amp;gt;&amp;gt;];&lt;/pre&gt;
 119  *
 120  * &lt;p&gt;The &amp;quot;&amp;lt;&amp;lt;&amp;quot; represents a new kind of substitution. The &amp;lt;&amp;lt; isolates
 121  * the hundreds digit (and any digits to its left), formats it using this same rule set, and
 122  * places the result where the &amp;quot;&amp;lt;&amp;lt;&amp;quot; was. Notice also that the meaning of
 123  * &amp;gt;&amp;gt; has changed: it now refers to both the tens and the ones digits. The meaning of
 124  * both substitutions depends on the rule&#39;s base value. The base value determines the rule&#39;s &lt;em&gt;divisor,&lt;/em&gt;
 125  * which is the highest power of 10 that is less than or equal to the base value (the user
 126  * can change this). To fill in the substitutions, the formatter divides the number being
 127  * formatted by the divisor. The integral quotient is used to fill in the &amp;lt;&amp;lt;
 128  * substitution, and the remainder is used to fill in the &amp;gt;&amp;gt; substitution. The meaning
 129  * of the brackets changes similarly: text in brackets is omitted if the value being
 130  * formatted is an even multiple of the rule&#39;s divisor. The rules are applied recursively, so
 131  * if a substitution is filled in with text that includes another substitution, that
 132  * substitution is also filled in.&lt;/p&gt;
 133  *
 134  * &lt;p&gt;This rule covers values up to 999, at which point we add another rule:&lt;/p&gt;
 135  *
 136  * &lt;pre&gt;1000: &amp;lt;&amp;lt; thousand[ &amp;gt;&amp;gt;];&lt;/pre&gt;
 137  *
 138  * &lt;p&gt;Again, the meanings of the brackets and substitution tokens shift because the rule&#39;s
 139  * base value is a higher power of 10, changing the rule&#39;s divisor. This rule can actually be
 140  * used all the way up to 999,999. This allows us to finish out the rules as follows:&lt;/p&gt;
 141  *
 142  * &lt;pre&gt; 1,000,000: &amp;lt;&amp;lt; million[ &amp;gt;&amp;gt;];
 143  * 1,000,000,000: &amp;lt;&amp;lt; billion[ &amp;gt;&amp;gt;];
 144  * 1,000,000,000,000: &amp;lt;&amp;lt; trillion[ &amp;gt;&amp;gt;];
 145  * 1,000,000,000,000,000: OUT OF RANGE!;&lt;/pre&gt;
 146  *
 147  * &lt;p&gt;Commas, periods, and spaces can be used in the base values to improve legibility and
 148  * are ignored by the rule parser. The last rule in the list is customarily treated as an
 149  * &amp;quot;overflow rule,&amp;quot; applying to everything from its base value on up, and often (as
 150  * in this example) being used to print out an error message or default representation.
 151  * Notice also that the size of the major groupings in large numbers is controlled by the
 152  * spacing of the rules: because in English we group numbers by thousand, the higher rules
 153  * are separated from each other by a factor of 1,000.&lt;/p&gt;
 154  *
 155  * &lt;p&gt;To see how these rules actually work in practice, consider the following example:
 156  * Formatting 25,430 with this rule set would work like this:&lt;/p&gt;
 157  *
 158  * &lt;table border=&quot;0&quot; width=&quot;100%&quot;&gt;
 159  *   &lt;tr&gt;
 160  *     &lt;td&gt;&lt;strong&gt;&amp;lt;&amp;lt; thousand &amp;gt;&amp;gt;&lt;/strong&gt;&lt;/td&gt;
 161  *     &lt;td&gt;[the rule whose base value is 1,000 is applicable to 25,340]&lt;/td&gt;
 162  *   &lt;/tr&gt;
 163  *   &lt;tr&gt;
 164  *     &lt;td&gt;&lt;strong&gt;twenty-&amp;gt;&amp;gt;&lt;/strong&gt; thousand &amp;gt;&amp;gt;&lt;/td&gt;
 165  *     &lt;td&gt;[25,340 over 1,000 is 25. The rule for 20 applies.]&lt;/td&gt;
 166  *   &lt;/tr&gt;
 167  *   &lt;tr&gt;
 168  *     &lt;td&gt;twenty-&lt;strong&gt;five&lt;/strong&gt; thousand &amp;gt;&amp;gt;&lt;/td&gt;
 169  *     &lt;td&gt;[25 mod 10 is 5. The rule for 5 is &amp;quot;five.&amp;quot;&lt;/td&gt;
 170  *   &lt;/tr&gt;
 171  *   &lt;tr&gt;
 172  *     &lt;td&gt;twenty-five thousand &lt;strong&gt;&amp;lt;&amp;lt; hundred &amp;gt;&amp;gt;&lt;/strong&gt;&lt;/td&gt;
 173  *     &lt;td&gt;[25,340 mod 1,000 is 340. The rule for 100 applies.]&lt;/td&gt;
 174  *   &lt;/tr&gt;
 175  *   &lt;tr&gt;
 176  *     &lt;td&gt;twenty-five thousand &lt;strong&gt;three&lt;/strong&gt; hundred &amp;gt;&amp;gt;&lt;/td&gt;
 177  *     &lt;td&gt;[340 over 100 is 3. The rule for 3 is &amp;quot;three.&amp;quot;]&lt;/td&gt;
 178  *   &lt;/tr&gt;
 179  *   &lt;tr&gt;
 180  *     &lt;td&gt;twenty-five thousand three hundred &lt;strong&gt;forty&lt;/strong&gt;&lt;/td&gt;
 181  *     &lt;td&gt;[340 mod 100 is 40. The rule for 40 applies. Since 40 divides
 182  *     evenly by 10, the hyphen and substitution in the brackets are omitted.]&lt;/td&gt;
 183  *   &lt;/tr&gt;
 184  * &lt;/table&gt;
 185  *
 186  * &lt;p&gt;The above syntax suffices only to format positive integers. To format negative numbers,
 187  * we add a special rule:&lt;/p&gt;
 188  *
 189  * &lt;pre&gt;-x: minus &amp;gt;&amp;gt;;&lt;/pre&gt;
 190  *
 191  * &lt;p&gt;This is called a &lt;em&gt;negative-number rule,&lt;/em&gt; and is identified by &amp;quot;-x&amp;quot;
 192  * where the base value would be. This rule is used to format all negative numbers. the
 193  * &amp;gt;&amp;gt; token here means &amp;quot;find the number&#39;s absolute value, format it with these
 194  * rules, and put the result here.&amp;quot;&lt;/p&gt;
 195  *
 196  * &lt;p&gt;We also add a special rule called a &lt;em&gt;fraction rule &lt;/em&gt;for numbers with fractional
 197  * parts:&lt;/p&gt;
 198  *
 199  * &lt;pre&gt;x.x: &amp;lt;&amp;lt; point &amp;gt;&amp;gt;;&lt;/pre&gt;
 200  *
 201  * &lt;p&gt;This rule is used for all positive non-integers (negative non-integers pass through the
 202  * negative-number rule first and then through this rule). Here, the &amp;lt;&amp;lt; token refers to
 203  * the number&#39;s integral part, and the &amp;gt;&amp;gt; to the number&#39;s fractional part. The
 204  * fractional part is formatted as a series of single-digit numbers (e.g., 123.456 would be
 205  * formatted as &amp;quot;one hundred twenty-three point four five six&amp;quot;).&lt;/p&gt;
 206  *
 207  * &lt;p&gt;To see how this rule syntax is applied to various languages, examine the resource data.&lt;/p&gt;
 208  *
 209  * &lt;p&gt;There is actually much more flexibility built into the rule language than the
 210  * description above shows. A formatter may own multiple rule sets, which can be selected by
 211  * the caller, and which can use each other to fill in their substitutions. Substitutions can
 212  * also be filled in with digits, using a DecimalFormat object. There is syntax that can be
 213  * used to alter a rule&#39;s divisor in various ways. And there is provision for much more
 214  * flexible fraction handling. A complete description of the rule syntax follows:&lt;/p&gt;
 215  *
 216  * &lt;hr&gt;
 217  *
 218  * &lt;p&gt;The description of a &lt;tt&gt;RuleBasedNumberFormat&lt;/tt&gt;&#39;s behavior consists of one or more &lt;em&gt;rule
 219  * sets.&lt;/em&gt; Each rule set consists of a name, a colon, and a list of &lt;em&gt;rules.&lt;/em&gt; A rule
 220  * set name must begin with a % sign. Rule sets with names that begin with a single % sign
 221  * are &lt;em&gt;public:&lt;/em&gt; the caller can specify that they be used to format and parse numbers.
 222  * Rule sets with names that begin with %% are &lt;em&gt;private:&lt;/em&gt; they exist only for the use
 223  * of other rule sets. If a formatter only has one rule set, the name may be omitted.&lt;/p&gt;
 224  *
 225  * &lt;p&gt;The user can also specify a special &amp;quot;rule set&amp;quot; named &lt;tt&gt;%%lenient-parse&lt;/tt&gt;.
 226  * The body of &lt;tt&gt;%%lenient-parse&lt;/tt&gt; isn&#39;t a set of number-formatting rules, but a &lt;tt&gt;RuleBasedCollator&lt;/tt&gt;
 227  * description which is used to define equivalences for lenient parsing. For more information
 228  * on the syntax, see &lt;tt&gt;RuleBasedCollator&lt;/tt&gt;. For more information on lenient parsing,
 229  * see &lt;tt&gt;setLenientParse()&lt;/tt&gt;.  &lt;em&gt;Note:&lt;/em&gt; symbols that have syntactic meaning
 230  * in collation rules, such as &#39;&amp;amp;&#39;, have no particular meaning when appearing outside
 231  * of the &lt;tt&gt;lenient-parse&lt;/tt&gt; rule set.&lt;/p&gt;
 232  *
 233  * &lt;p&gt;The body of a rule set consists of an ordered, semicolon-delimited list of &lt;em&gt;rules.&lt;/em&gt;
 234  * Internally, every rule has a base value, a divisor, rule text, and zero, one, or two &lt;em&gt;substitutions.&lt;/em&gt;
 235  * These parameters are controlled by the description syntax, which consists of a &lt;em&gt;rule
 236  * descriptor,&lt;/em&gt; a colon, and a &lt;em&gt;rule body.&lt;/em&gt;&lt;/p&gt;
 237  *
 238  * &lt;p&gt;A rule descriptor can take one of the following forms (text in &lt;em&gt;italics&lt;/em&gt; is the
 239  * name of a token):&lt;/p&gt;
 240  *
 241  * &lt;table border=&quot;0&quot; width=&quot;100%&quot;&gt;
 242  *   &lt;tr&gt;
 243  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt;:&lt;/td&gt;
 244  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt; specifies the rule&#39;s base value. &lt;em&gt;bv&lt;/em&gt; is a decimal
 245  *     number expressed using ASCII digits. &lt;em&gt;bv&lt;/em&gt; may contain spaces, period, and commas,
 246  *     which are ignored. The rule&#39;s divisor is the highest power of 10 less than or equal to
 247  *     the base value.&lt;/td&gt;
 248  *   &lt;/tr&gt;
 249  *   &lt;tr&gt;
 250  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt;/&lt;em&gt;rad&lt;/em&gt;:&lt;/td&gt;
 251  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt; specifies the rule&#39;s base value. The rule&#39;s divisor is the
 252  *     highest power of &lt;em&gt;rad&lt;/em&gt; less than or equal to the base value.&lt;/td&gt;
 253  *   &lt;/tr&gt;
 254  *   &lt;tr&gt;
 255  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt;&amp;gt;:&lt;/td&gt;
 256  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt; specifies the rule&#39;s base value. To calculate the divisor,
 257  *     let the radix be 10, and the exponent be the highest exponent of the radix that yields a
 258  *     result less than or equal to the base value. Every &amp;gt; character after the base value
 259  *     decreases the exponent by 1. If the exponent is positive or 0, the divisor is the radix
 260  *     raised to the power of the exponent; otherwise, the divisor is 1.&lt;/td&gt;
 261  *   &lt;/tr&gt;
 262  *   &lt;tr&gt;
 263  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt;/&lt;em&gt;rad&lt;/em&gt;&amp;gt;:&lt;/td&gt;
 264  *     &lt;td&gt;&lt;em&gt;bv&lt;/em&gt; specifies the rule&#39;s base value. To calculate the divisor,
 265  *     let the radix be &lt;em&gt;rad&lt;/em&gt;, and the exponent be the highest exponent of the radix that
 266  *     yields a result less than or equal to the base value. Every &amp;gt; character after the radix
 267  *     decreases the exponent by 1. If the exponent is positive or 0, the divisor is the radix
 268  *     raised to the power of the exponent; otherwise, the divisor is 1.&lt;/td&gt;
 269  *   &lt;/tr&gt;
 270  *   &lt;tr&gt;
 271  *     &lt;td&gt;-x:&lt;/td&gt;
 272  *     &lt;td&gt;The rule is a negative-number rule.&lt;/td&gt;
 273  *   &lt;/tr&gt;
 274  *   &lt;tr&gt;
 275  *     &lt;td&gt;x.x:&lt;/td&gt;
 276  *     &lt;td&gt;The rule is an &lt;em&gt;improper fraction rule&lt;/em&gt;. If the full stop in
 277  *     the middle of the rule name is replaced with the decimal point
 278  *     that is used in the language or DecimalFormatSymbols, then that rule will
 279  *     have precedence when formatting and parsing this rule. For example, some
 280  *     languages use the comma, and can thus be written as x,x instead. For example,
 281  *     you can use &quot;x.x: &amp;lt;&amp;lt; point &amp;gt;&amp;gt;;x,x: &amp;lt;&amp;lt; comma &amp;gt;&amp;gt;;&quot; to
 282  *     handle the decimal point that matches the language&#39;s natural spelling of
 283  *     the punctuation of either the full stop or comma.&lt;/td&gt;
 284  *   &lt;/tr&gt;
 285  *   &lt;tr&gt;
 286  *     &lt;td&gt;0.x:&lt;/td&gt;
 287  *     &lt;td&gt;The rule is a &lt;em&gt;proper fraction rule&lt;/em&gt;. If the full stop in
 288  *     the middle of the rule name is replaced with the decimal point
 289  *     that is used in the language or DecimalFormatSymbols, then that rule will
 290  *     have precedence when formatting and parsing this rule. For example, some
 291  *     languages use the comma, and can thus be written as 0,x instead. For example,
 292  *     you can use &quot;0.x: point &amp;gt;&amp;gt;;0,x: comma &amp;gt;&amp;gt;;&quot; to
 293  *     handle the decimal point that matches the language&#39;s natural spelling of
 294  *     the punctuation of either the full stop or comma.&lt;/td&gt;
 295  *   &lt;/tr&gt;
 296  *   &lt;tr&gt;
 297  *     &lt;td&gt;x.0:&lt;/td&gt;
 298  *     &lt;td&gt;The rule is a &lt;em&gt;master rule&lt;/em&gt;. If the full stop in
 299  *     the middle of the rule name is replaced with the decimal point
 300  *     that is used in the language or DecimalFormatSymbols, then that rule will
 301  *     have precedence when formatting and parsing this rule. For example, some
 302  *     languages use the comma, and can thus be written as x,0 instead. For example,
 303  *     you can use &quot;x.0: &amp;lt;&amp;lt; point;x,0: &amp;lt;&amp;lt; comma;&quot; to
 304  *     handle the decimal point that matches the language&#39;s natural spelling of
 305  *     the punctuation of either the full stop or comma.&lt;/td&gt;
 306  *   &lt;/tr&gt;
 307  *   &lt;tr&gt;
 308  *     &lt;td&gt;Inf:&lt;/td&gt;
 309  *     &lt;td&gt;The rule for infinity.&lt;/td&gt;
 310  *   &lt;/tr&gt;
 311  *   &lt;tr&gt;
 312  *     &lt;td&gt;NaN:&lt;/td&gt;
 313  *     &lt;td&gt;The rule for an IEEE 754 NaN (not a number).&lt;/td&gt;
 314  *   &lt;/tr&gt;
 315  *   &lt;tr&gt;
 316  *   &lt;tr&gt;
 317  *     &lt;td&gt;&lt;em&gt;nothing&lt;/em&gt;&lt;/td&gt;
 318  *     &lt;td&gt;If the rule&#39;s rule descriptor is left out, the base value is one plus the
 319  *     preceding rule&#39;s base value (or zero if this is the first rule in the list) in a normal
 320  *     rule set.&amp;nbsp; In a fraction rule set, the base value is the same as the preceding rule&#39;s
 321  *     base value.&lt;/td&gt;
 322  *   &lt;/tr&gt;
 323  * &lt;/table&gt;
 324  *
 325  * &lt;p&gt;A rule set may be either a regular rule set or a &lt;em&gt;fraction rule set,&lt;/em&gt; depending
 326  * on whether it is used to format a number&#39;s integral part (or the whole number) or a
 327  * number&#39;s fractional part. Using a rule set to format a rule&#39;s fractional part makes it a
 328  * fraction rule set.&lt;/p&gt;
 329  *
 330  * &lt;p&gt;Which rule is used to format a number is defined according to one of the following
 331  * algorithms: If the rule set is a regular rule set, do the following:
 332  *
 333  * &lt;ul&gt;
 334  *   &lt;li&gt;If the rule set includes a master rule (and the number was passed in as a &lt;tt&gt;double&lt;/tt&gt;),
 335  *     use the master rule.&amp;nbsp; (If the number being formatted was passed in as a &lt;tt&gt;long&lt;/tt&gt;,
 336  *     the master rule is ignored.)&lt;/li&gt;
 337  *   &lt;li&gt;If the number is negative, use the negative-number rule.&lt;/li&gt;
 338  *   &lt;li&gt;If the number has a fractional part and is greater than 1, use the improper fraction
 339  *     rule.&lt;/li&gt;
 340  *   &lt;li&gt;If the number has a fractional part and is between 0 and 1, use the proper fraction
 341  *     rule.&lt;/li&gt;
 342  *   &lt;li&gt;Binary-search the rule list for the rule with the highest base value less than or equal
 343  *     to the number. If that rule has two substitutions, its base value is not an even multiple
 344  *     of its divisor, and the number &lt;em&gt;is&lt;/em&gt; an even multiple of the rule&#39;s divisor, use the
 345  *     rule that precedes it in the rule list. Otherwise, use the rule itself.&lt;/li&gt;
 346  * &lt;/ul&gt;
 347  *
 348  * &lt;p&gt;If the rule set is a fraction rule set, do the following:
 349  *
 350  * &lt;ul&gt;
 351  *   &lt;li&gt;Ignore negative-number and fraction rules.&lt;/li&gt;
 352  *   &lt;li&gt;For each rule in the list, multiply the number being formatted (which will always be
 353  *     between 0 and 1) by the rule&#39;s base value. Keep track of the distance between the result
 354  *     the nearest integer.&lt;/li&gt;
 355  *   &lt;li&gt;Use the rule that produced the result closest to zero in the above calculation. In the
 356  *     event of a tie or a direct hit, use the first matching rule encountered. (The idea here is
 357  *     to try each rule&#39;s base value as a possible denominator of a fraction. Whichever
 358  *     denominator produces the fraction closest in value to the number being formatted wins.) If
 359  *     the rule following the matching rule has the same base value, use it if the numerator of
 360  *     the fraction is anything other than 1; if the numerator is 1, use the original matching
 361  *     rule. (This is to allow singular and plural forms of the rule text without a lot of extra
 362  *     hassle.)&lt;/li&gt;
 363  * &lt;/ul&gt;
 364  *
 365  * &lt;p&gt;A rule&#39;s body consists of a string of characters terminated by a semicolon. The rule
 366  * may include zero, one, or two &lt;em&gt;substitution tokens,&lt;/em&gt; and a range of text in
 367  * brackets. The brackets denote optional text (and may also include one or both
 368  * substitutions). The exact meanings of the substitution tokens, and under what conditions
 369  * optional text is omitted, depend on the syntax of the substitution token and the context.
 370  * The rest of the text in a rule body is literal text that is output when the rule matches
 371  * the number being formatted.&lt;/p&gt;
 372  *
 373  * &lt;p&gt;A substitution token begins and ends with a &lt;em&gt;token character.&lt;/em&gt; The token
 374  * character and the context together specify a mathematical operation to be performed on the
 375  * number being formatted. An optional &lt;em&gt;substitution descriptor &lt;/em&gt;specifies how the
 376  * value resulting from that operation is used to fill in the substitution. The position of
 377  * the substitution token in the rule body specifies the location of the resultant text in
 378  * the original rule text.&lt;/p&gt;
 379  *
 380  * &lt;p&gt;The meanings of the substitution token characters are as follows:&lt;/p&gt;
 381  *
 382  * &lt;table border=&quot;0&quot; width=&quot;100%&quot;&gt;
 383  *   &lt;tr&gt;
 384  *     &lt;td&gt;&amp;gt;&amp;gt;&lt;/td&gt;
 385  *     &lt;td&gt;in normal rule&lt;/td&gt;
 386  *     &lt;td&gt;Divide the number by the rule&#39;s divisor and format the remainder&lt;/td&gt;
 387  *   &lt;/tr&gt;
 388  *   &lt;tr&gt;
 389  *     &lt;td&gt;&lt;/td&gt;
 390  *     &lt;td&gt;in negative-number rule&lt;/td&gt;
 391  *     &lt;td&gt;Find the absolute value of the number and format the result&lt;/td&gt;
 392  *   &lt;/tr&gt;
 393  *   &lt;tr&gt;
 394  *     &lt;td&gt;&lt;/td&gt;
 395  *     &lt;td&gt;in fraction or master rule&lt;/td&gt;
 396  *     &lt;td&gt;Isolate the number&#39;s fractional part and format it.&lt;/td&gt;
 397  *   &lt;/tr&gt;
 398  *   &lt;tr&gt;
 399  *     &lt;td&gt;&lt;/td&gt;
 400  *     &lt;td&gt;in rule in fraction rule set&lt;/td&gt;
 401  *     &lt;td&gt;Not allowed.&lt;/td&gt;
 402  *   &lt;/tr&gt;
 403  *   &lt;tr&gt;
 404  *     &lt;td&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/td&gt;
 405  *     &lt;td&gt;in normal rule&lt;/td&gt;
 406  *     &lt;td&gt;Divide the number by the rule&#39;s divisor and format the remainder,
 407  *       but bypass the normal rule-selection process and just use the
 408  *       rule that precedes this one in this rule list.&lt;/td&gt;
 409  *   &lt;/tr&gt;
 410  *   &lt;tr&gt;
 411  *     &lt;td&gt;&lt;/td&gt;
 412  *     &lt;td&gt;in all other rules&lt;/td&gt;
 413  *     &lt;td&gt;Not allowed.&lt;/td&gt;
 414  *   &lt;/tr&gt;
 415  *   &lt;tr&gt;
 416  *     &lt;td&gt;&amp;lt;&amp;lt;&lt;/td&gt;
 417  *     &lt;td&gt;in normal rule&lt;/td&gt;
 418  *     &lt;td&gt;Divide the number by the rule&#39;s divisor and format the quotient&lt;/td&gt;
 419  *   &lt;/tr&gt;
 420  *   &lt;tr&gt;
 421  *     &lt;td&gt;&lt;/td&gt;
 422  *     &lt;td&gt;in negative-number rule&lt;/td&gt;
 423  *     &lt;td&gt;Not allowed.&lt;/td&gt;
 424  *   &lt;/tr&gt;
 425  *   &lt;tr&gt;
 426  *     &lt;td&gt;&lt;/td&gt;
 427  *     &lt;td&gt;in fraction or master rule&lt;/td&gt;
 428  *     &lt;td&gt;Isolate the number&#39;s integral part and format it.&lt;/td&gt;
 429  *   &lt;/tr&gt;
 430  *   &lt;tr&gt;
 431  *     &lt;td&gt;&lt;/td&gt;
 432  *     &lt;td&gt;in rule in fraction rule set&lt;/td&gt;
 433  *     &lt;td&gt;Multiply the number by the rule&#39;s base value and format the result.&lt;/td&gt;
 434  *   &lt;/tr&gt;
 435  *   &lt;tr&gt;
 436  *     &lt;td&gt;==&lt;/td&gt;
 437  *     &lt;td&gt;in all rule sets&lt;/td&gt;
 438  *     &lt;td&gt;Format the number unchanged&lt;/td&gt;
 439  *   &lt;/tr&gt;
 440  *   &lt;tr&gt;
 441  *     &lt;td&gt;[]&lt;/td&gt;
 442  *     &lt;td&gt;in normal rule&lt;/td&gt;
 443  *     &lt;td&gt;Omit the optional text if the number is an even multiple of the rule&#39;s divisor&lt;/td&gt;
 444  *   &lt;/tr&gt;
 445  *   &lt;tr&gt;
 446  *     &lt;td&gt;&lt;/td&gt;
 447  *     &lt;td&gt;in negative-number rule&lt;/td&gt;
 448  *     &lt;td&gt;Not allowed.&lt;/td&gt;
 449  *   &lt;/tr&gt;
 450  *   &lt;tr&gt;
 451  *     &lt;td&gt;&lt;/td&gt;
 452  *     &lt;td&gt;in improper-fraction rule&lt;/td&gt;
 453  *     &lt;td&gt;Omit the optional text if the number is between 0 and 1 (same as specifying both an
 454  *     x.x rule and a 0.x rule)&lt;/td&gt;
 455  *   &lt;/tr&gt;
 456  *   &lt;tr&gt;
 457  *     &lt;td&gt;&lt;/td&gt;
 458  *     &lt;td&gt;in master rule&lt;/td&gt;
 459  *     &lt;td&gt;Omit the optional text if the number is an integer (same as specifying both an x.x
 460  *     rule and an x.0 rule)&lt;/td&gt;
 461  *   &lt;/tr&gt;
 462  *   &lt;tr&gt;
 463  *     &lt;td&gt;&lt;/td&gt;
 464  *     &lt;td&gt;in proper-fraction rule&lt;/td&gt;
 465  *     &lt;td&gt;Not allowed.&lt;/td&gt;
 466  *   &lt;/tr&gt;
 467  *   &lt;tr&gt;
 468  *     &lt;td&gt;&lt;/td&gt;
 469  *     &lt;td&gt;in rule in fraction rule set&lt;/td&gt;
 470  *     &lt;td&gt;Omit the optional text if multiplying the number by the rule&#39;s base value yields 1.&lt;/td&gt;
 471  *   &lt;/tr&gt;
 472  *   &lt;tr&gt;
 473  *     &lt;td width=&quot;37&quot;&gt;$(cardinal,&lt;i&gt;plural syntax&lt;/i&gt;)$&lt;/td&gt;
 474  *     &lt;td width=&quot;23&quot;&gt;&lt;/td&gt;
 475  *     &lt;td width=&quot;165&quot; valign=&quot;top&quot;&gt;in all rule sets&lt;/td&gt;
 476  *     &lt;td&gt;This provides the ability to choose a word based on the number divided by the radix to the power of the
 477  *     exponent of the base value for the specified locale, which is normally equivalent to the &amp;lt;&amp;lt; value.
 478  *     This uses the cardinal plural rules from PluralFormat. All strings used in the plural format are treated
 479  *     as the same base value for parsing.&lt;/td&gt;
 480  *   &lt;/tr&gt;
 481  *   &lt;tr&gt;
 482  *     &lt;td width=&quot;37&quot;&gt;$(ordinal,&lt;i&gt;plural syntax&lt;/i&gt;)$&lt;/td&gt;
 483  *     &lt;td width=&quot;23&quot;&gt;&lt;/td&gt;
 484  *     &lt;td width=&quot;165&quot; valign=&quot;top&quot;&gt;in all rule sets&lt;/td&gt;
 485  *     &lt;td&gt;This provides the ability to choose a word based on the number divided by the radix to the power of the
 486  *     exponent of the base value for the specified locale, which is normally equivalent to the &amp;lt;&amp;lt; value.
 487  *     This uses the ordinal plural rules from PluralFormat. All strings used in the plural format are treated
 488  *     as the same base value for parsing.&lt;/td&gt;
 489  *   &lt;/tr&gt;
 490  * &lt;/table&gt;
 491  *
 492  * &lt;p&gt;The substitution descriptor (i.e., the text between the token characters) may take one
 493  * of three forms:&lt;/p&gt;
 494  *
 495  * &lt;table border=&quot;0&quot; width=&quot;100%&quot;&gt;
 496  *   &lt;tr&gt;
 497  *     &lt;td&gt;a rule set name&lt;/td&gt;
 498  *     &lt;td&gt;Perform the mathematical operation on the number, and format the result using the
 499  *     named rule set.&lt;/td&gt;
 500  *   &lt;/tr&gt;
 501  *   &lt;tr&gt;
 502  *     &lt;td&gt;a DecimalFormat pattern&lt;/td&gt;
 503  *     &lt;td&gt;Perform the mathematical operation on the number, and format the result using a
 504  *     DecimalFormat with the specified pattern.&amp;nbsp; The pattern must begin with 0 or #.&lt;/td&gt;
 505  *   &lt;/tr&gt;
 506  *   &lt;tr&gt;
 507  *     &lt;td&gt;nothing&lt;/td&gt;
 508  *     &lt;td&gt;Perform the mathematical operation on the number, and format the result using the rule
 509  *     set containing the current rule, except:
 510  *     &lt;ul&gt;
 511  *       &lt;li&gt;You can&#39;t have an empty substitution descriptor with a == substitution.&lt;/li&gt;
 512  *       &lt;li&gt;If you omit the substitution descriptor in a &amp;gt;&amp;gt; substitution in a fraction rule,
 513  *         format the result one digit at a time using the rule set containing the current rule.&lt;/li&gt;
 514  *       &lt;li&gt;If you omit the substitution descriptor in a &amp;lt;&amp;lt; substitution in a rule in a
 515  *         fraction rule set, format the result using the default rule set for this formatter.&lt;/li&gt;
 516  *     &lt;/ul&gt;
 517  *     &lt;/td&gt;
 518  *   &lt;/tr&gt;
 519  * &lt;/table&gt;
 520  *
 521  * &lt;p&gt;Whitespace is ignored between a rule set name and a rule set body, between a rule
 522  * descriptor and a rule body, or between rules. If a rule body begins with an apostrophe,
 523  * the apostrophe is ignored, but all text after it becomes significant (this is how you can
 524  * have a rule&#39;s rule text begin with whitespace). There is no escape function: the semicolon
 525  * is not allowed in rule set names or in rule text, and the colon is not allowed in rule set
 526  * names. The characters beginning a substitution token are always treated as the beginning
 527  * of a substitution token.&lt;/p&gt;
 528  *
 529  * &lt;p&gt;See the resource data and the demo program for annotated examples of real rule sets
 530  * using these features.&lt;/p&gt;
 531  *
 532  * &lt;p&gt;&lt;em&gt;User subclasses are not supported.&lt;/em&gt; While clients may write
 533  * subclasses, such code will not necessarily work and will not be
 534  * guaranteed to work stably from release to release.
 535  *
 536  * &lt;p&gt;&lt;b&gt;Localizations&lt;/b&gt;&lt;/p&gt;
 537  * &lt;p&gt;Constructors are available that allow the specification of localizations for the
 538  * public rule sets (and also allow more control over what public rule sets are available).
 539  * Localization data is represented as a textual description.  The description represents
 540  * an array of arrays of string.  The first element is an array of the public rule set names,
 541  * each of these must be one of the public rule set names that appear in the rules.  Only
 542  * names in this array will be treated as public rule set names by the API.  Each subsequent
 543  * element is an array of localizations of these names.  The first element of one of these
 544  * subarrays is the locale name, and the remaining elements are localizations of the
 545  * public rule set names, in the same order as they were listed in the first arrray.&lt;/p&gt;
 546  * &lt;p&gt;In the syntax, angle brackets &#39;&lt;&#39;, &#39;&gt;&#39; are used to delimit the arrays, and comma &#39;,&#39; is used
 547  * to separate elements of an array.  Whitespace is ignored, unless quoted.&lt;/p&gt;
 548  * &lt;p&gt;For example:&lt;pre&gt;
 549  * &lt; &lt; %foo, %bar, %baz &gt;,
 550  *   &lt; en, Foo, Bar, Baz &gt;,
 551  *   &lt; fr, &#39;le Foo&#39;, &#39;le Bar&#39;, &#39;le Baz&#39; &gt;
 552  *   &lt; zh, \\u7532, \\u4e59, \\u4e19 &gt; &gt;
 553  * &lt;/pre&gt;&lt;/p&gt;
 554  * @author Richard Gillam
 555  * @see NumberFormat
 556  * @see DecimalFormat
 557  * @see PluralFormat
 558  * @see PluralRules
 559  * @stable ICU 2.0
 560  */
 561 class U_I18N_API RuleBasedNumberFormat : public NumberFormat {
 562 public:
 563 
 564   //-----------------------------------------------------------------------
 565   // constructors
 566   //-----------------------------------------------------------------------
 567 
 568     /**
 569      * Creates a RuleBasedNumberFormat that behaves according to the description
 570      * passed in.  The formatter uses the default locale.
 571      * @param rules A description of the formatter&#39;s desired behavior.
 572      * See the class documentation for a complete explanation of the description
 573      * syntax.
 574      * @param perror The parse error if an error was encountered.
 575      * @param status The status indicating whether the constructor succeeded.
 576      * @stable ICU 3.2
 577      */
 578     RuleBasedNumberFormat(const UnicodeString&amp; rules, UParseError&amp; perror, UErrorCode&amp; status);
 579 
 580     /**
 581      * Creates a RuleBasedNumberFormat that behaves according to the description
 582      * passed in.  The formatter uses the default locale.
 583      * &lt;p&gt;
 584      * The localizations data provides information about the public
 585      * rule sets and their localized display names for different
 586      * locales. The first element in the list is an array of the names
 587      * of the public rule sets.  The first element in this array is
 588      * the initial default ruleset.  The remaining elements in the
 589      * list are arrays of localizations of the names of the public
 590      * rule sets.  Each of these is one longer than the initial array,
 591      * with the first String being the ULocale ID, and the remaining
 592      * Strings being the localizations of the rule set names, in the
 593      * same order as the initial array.  Arrays are NULL-terminated.
 594      * @param rules A description of the formatter&#39;s desired behavior.
 595      * See the class documentation for a complete explanation of the description
 596      * syntax.
 597      * @param localizations the localization information.
 598      * names in the description.  These will be copied by the constructor.
 599      * @param perror The parse error if an error was encountered.
 600      * @param status The status indicating whether the constructor succeeded.
 601      * @stable ICU 3.2
 602      */
 603     RuleBasedNumberFormat(const UnicodeString&amp; rules, const UnicodeString&amp; localizations,
 604                         UParseError&amp; perror, UErrorCode&amp; status);
 605 
 606   /**
 607    * Creates a RuleBasedNumberFormat that behaves according to the rules
 608    * passed in.  The formatter uses the specified locale to determine the
 609    * characters to use when formatting numerals, and to define equivalences
 610    * for lenient parsing.
 611    * @param rules The formatter rules.
 612    * See the class documentation for a complete explanation of the rule
 613    * syntax.
 614    * @param locale A locale that governs which characters are used for
 615    * formatting values in numerals and which characters are equivalent in
 616    * lenient parsing.
 617    * @param perror The parse error if an error was encountered.
 618    * @param status The status indicating whether the constructor succeeded.
 619    * @stable ICU 2.0
 620    */
 621   RuleBasedNumberFormat(const UnicodeString&amp; rules, const Locale&amp; locale,
 622                         UParseError&amp; perror, UErrorCode&amp; status);
 623 
 624     /**
 625      * Creates a RuleBasedNumberFormat that behaves according to the description
 626      * passed in.  The formatter uses the default locale.
 627      * &lt;p&gt;
 628      * The localizations data provides information about the public
 629      * rule sets and their localized display names for different
 630      * locales. The first element in the list is an array of the names
 631      * of the public rule sets.  The first element in this array is
 632      * the initial default ruleset.  The remaining elements in the
 633      * list are arrays of localizations of the names of the public
 634      * rule sets.  Each of these is one longer than the initial array,
 635      * with the first String being the ULocale ID, and the remaining
 636      * Strings being the localizations of the rule set names, in the
 637      * same order as the initial array.  Arrays are NULL-terminated.
 638      * @param rules A description of the formatter&#39;s desired behavior.
 639      * See the class documentation for a complete explanation of the description
 640      * syntax.
 641      * @param localizations a list of localizations for the rule set
 642      * names in the description.  These will be copied by the constructor.
 643      * @param locale A locale that governs which characters are used for
 644      * formatting values in numerals and which characters are equivalent in
 645      * lenient parsing.
 646      * @param perror The parse error if an error was encountered.
 647      * @param status The status indicating whether the constructor succeeded.
 648      * @stable ICU 3.2
 649      */
 650     RuleBasedNumberFormat(const UnicodeString&amp; rules, const UnicodeString&amp; localizations,
 651                         const Locale&amp; locale, UParseError&amp; perror, UErrorCode&amp; status);
 652 
 653   /**
 654    * Creates a RuleBasedNumberFormat from a predefined ruleset.  The selector
 655    * code choosed among three possible predefined formats: spellout, ordinal,
 656    * and duration.
 657    * @param tag A selector code specifying which kind of formatter to create for that
 658    * locale.  There are four legal values: URBNF_SPELLOUT, which creates a formatter that
 659    * spells out a value in words in the desired language, URBNF_ORDINAL, which attaches
 660    * an ordinal suffix from the desired language to the end of a number (e.g. &quot;123rd&quot;),
 661    * URBNF_DURATION, which formats a duration in seconds as hours, minutes, and seconds always rounding down,
 662    * and URBNF_NUMBERING_SYSTEM, which is used to invoke rules for alternate numbering
 663    * systems such as the Hebrew numbering system, or for Roman Numerals, etc.
 664    * @param locale The locale for the formatter.
 665    * @param status The status indicating whether the constructor succeeded.
 666    * @stable ICU 2.0
 667    */
 668   RuleBasedNumberFormat(URBNFRuleSetTag tag, const Locale&amp; locale, UErrorCode&amp; status);
 669 
 670   //-----------------------------------------------------------------------
 671   // boilerplate
 672   //-----------------------------------------------------------------------
 673 
 674   /**
 675    * Copy constructor
 676    * @param rhs    the object to be copied from.
 677    * @stable ICU 2.6
 678    */
 679   RuleBasedNumberFormat(const RuleBasedNumberFormat&amp; rhs);
 680 
 681   /**
 682    * Assignment operator
 683    * @param rhs    the object to be copied from.
 684    * @stable ICU 2.6
 685    */
 686   RuleBasedNumberFormat&amp; operator=(const RuleBasedNumberFormat&amp; rhs);
 687 
 688   /**
 689    * Release memory allocated for a RuleBasedNumberFormat when you are finished with it.
 690    * @stable ICU 2.6
 691    */
 692   virtual ~RuleBasedNumberFormat();
 693 
 694   /**
 695    * Clone this object polymorphically.  The caller is responsible
 696    * for deleting the result when done.
 697    * @return  A copy of the object.
 698    * @stable ICU 2.6
 699    */
 700   virtual Format* clone(void) const;
 701 
 702   /**
 703    * Return true if the given Format objects are semantically equal.
 704    * Objects of different subclasses are considered unequal.
 705    * @param other    the object to be compared with.
 706    * @return        true if the given Format objects are semantically equal.
 707    * @stable ICU 2.6
 708    */
 709   virtual UBool operator==(const Format&amp; other) const;
 710 
 711 //-----------------------------------------------------------------------
 712 // public API functions
 713 //-----------------------------------------------------------------------
 714 
 715   /**
 716    * return the rules that were provided to the RuleBasedNumberFormat.
 717    * @return the result String that was passed in
 718    * @stable ICU 2.0
 719    */
 720   virtual UnicodeString getRules() const;
 721 
 722   /**
 723    * Return the number of public rule set names.
 724    * @return the number of public rule set names.
 725    * @stable ICU 2.0
 726    */
 727   virtual int32_t getNumberOfRuleSetNames() const;
 728 
 729   /**
 730    * Return the name of the index&#39;th public ruleSet.  If index is not valid,
 731    * the function returns null.
 732    * @param index the index of the ruleset
 733    * @return the name of the index&#39;th public ruleSet.
 734    * @stable ICU 2.0
 735    */
 736   virtual UnicodeString getRuleSetName(int32_t index) const;
 737 
 738   /**
 739    * Return the number of locales for which we have localized rule set display names.
 740    * @return the number of locales for which we have localized rule set display names.
 741    * @stable ICU 3.2
 742    */
 743   virtual int32_t getNumberOfRuleSetDisplayNameLocales(void) const;
 744 
 745   /**
 746    * Return the index&#39;th display name locale.
 747    * @param index the index of the locale
 748    * @param status set to a failure code when this function fails
 749    * @return the locale
 750    * @see #getNumberOfRuleSetDisplayNameLocales
 751    * @stable ICU 3.2
 752    */
 753   virtual Locale getRuleSetDisplayNameLocale(int32_t index, UErrorCode&amp; status) const;
 754 
 755     /**
 756      * Return the rule set display names for the provided locale.  These are in the same order
 757      * as those returned by getRuleSetName.  The locale is matched against the locales for
 758      * which there is display name data, using normal fallback rules.  If no locale matches,
 759      * the default display names are returned.  (These are the internal rule set names minus
 760      * the leading &#39;%&#39;.)
 761      * @param index the index of the rule set
 762      * @param locale the locale (returned by getRuleSetDisplayNameLocales) for which the localized
 763      * display name is desired
 764      * @return the display name for the given index, which might be bogus if there is an error
 765      * @see #getRuleSetName
 766      * @stable ICU 3.2
 767      */
 768   virtual UnicodeString getRuleSetDisplayName(int32_t index,
 769                           const Locale&amp; locale = Locale::getDefault());
 770 
 771     /**
 772      * Return the rule set display name for the provided rule set and locale.
 773      * The locale is matched against the locales for which there is display name data, using
 774      * normal fallback rules.  If no locale matches, the default display name is returned.
 775      * @return the display name for the rule set
 776      * @stable ICU 3.2
 777      * @see #getRuleSetDisplayName
 778      */
 779   virtual UnicodeString getRuleSetDisplayName(const UnicodeString&amp; ruleSetName,
 780                           const Locale&amp; locale = Locale::getDefault());
 781 
 782 
 783   using NumberFormat::format;
 784 
 785   /**
 786    * Formats the specified 32-bit number using the default ruleset.
 787    * @param number The number to format.
 788    * @param toAppendTo the string that will hold the (appended) result
 789    * @param pos the fieldposition
 790    * @return A textual representation of the number.
 791    * @stable ICU 2.0
 792    */
 793   virtual UnicodeString&amp; format(int32_t number,
 794                                 UnicodeString&amp; toAppendTo,
 795                                 FieldPosition&amp; pos) const;
 796 
 797   /**
 798    * Formats the specified 64-bit number using the default ruleset.
 799    * @param number The number to format.
 800    * @param toAppendTo the string that will hold the (appended) result
 801    * @param pos the fieldposition
 802    * @return A textual representation of the number.
 803    * @stable ICU 2.1
 804    */
 805   virtual UnicodeString&amp; format(int64_t number,
 806                                 UnicodeString&amp; toAppendTo,
 807                                 FieldPosition&amp; pos) const;
 808   /**
 809    * Formats the specified number using the default ruleset.
 810    * @param number The number to format.
 811    * @param toAppendTo the string that will hold the (appended) result
 812    * @param pos the fieldposition
 813    * @return A textual representation of the number.
 814    * @stable ICU 2.0
 815    */
 816   virtual UnicodeString&amp; format(double number,
 817                                 UnicodeString&amp; toAppendTo,
 818                                 FieldPosition&amp; pos) const;
 819 
 820   /**
 821    * Formats the specified number using the named ruleset.
 822    * @param number The number to format.
 823    * @param ruleSetName The name of the rule set to format the number with.
 824    * This must be the name of a valid public rule set for this formatter.
 825    * @param toAppendTo the string that will hold the (appended) result
 826    * @param pos the fieldposition
 827    * @param status the status
 828    * @return A textual representation of the number.
 829    * @stable ICU 2.0
 830    */
 831   virtual UnicodeString&amp; format(int32_t number,
 832                                 const UnicodeString&amp; ruleSetName,
 833                                 UnicodeString&amp; toAppendTo,
 834                                 FieldPosition&amp; pos,
 835                                 UErrorCode&amp; status) const;
 836   /**
 837    * Formats the specified 64-bit number using the named ruleset.
 838    * @param number The number to format.
 839    * @param ruleSetName The name of the rule set to format the number with.
 840    * This must be the name of a valid public rule set for this formatter.
 841    * @param toAppendTo the string that will hold the (appended) result
 842    * @param pos the fieldposition
 843    * @param status the status
 844    * @return A textual representation of the number.
 845    * @stable ICU 2.1
 846    */
 847   virtual UnicodeString&amp; format(int64_t number,
 848                                 const UnicodeString&amp; ruleSetName,
 849                                 UnicodeString&amp; toAppendTo,
 850                                 FieldPosition&amp; pos,
 851                                 UErrorCode&amp; status) const;
 852   /**
 853    * Formats the specified number using the named ruleset.
 854    * @param number The number to format.
 855    * @param ruleSetName The name of the rule set to format the number with.
 856    * This must be the name of a valid public rule set for this formatter.
 857    * @param toAppendTo the string that will hold the (appended) result
 858    * @param pos the fieldposition
 859    * @param status the status
 860    * @return A textual representation of the number.
 861    * @stable ICU 2.0
 862    */
 863   virtual UnicodeString&amp; format(double number,
 864                                 const UnicodeString&amp; ruleSetName,
 865                                 UnicodeString&amp; toAppendTo,
 866                                 FieldPosition&amp; pos,
 867                                 UErrorCode&amp; status) const;
 868 
 869 protected:
 870     /**
 871      * Format a decimal number.
 872      * The number is a DigitList wrapper onto a floating point decimal number.
 873      * The default implementation in NumberFormat converts the decimal number
 874      * to a double and formats that.  Subclasses of NumberFormat that want
 875      * to specifically handle big decimal numbers must override this method.
 876      * class DecimalFormat does so.
 877      *
 878      * @param number    The number, a DigitList format Decimal Floating Point.
 879      * @param appendTo  Output parameter to receive result.
 880      *                  Result is appended to existing contents.
 881      * @param posIter   On return, can be used to iterate over positions
 882      *                  of fields generated by this format call.
 883      * @param status    Output param filled with success/failure status.
 884      * @return          Reference to &#39;appendTo&#39; parameter.
 885      * @internal
 886      */
 887     virtual UnicodeString&amp; format(const number::impl::DecimalQuantity &amp;number,
 888                                   UnicodeString&amp; appendTo,
 889                                   FieldPositionIterator* posIter,
 890                                   UErrorCode&amp; status) const;
 891 
 892     /**
 893      * Format a decimal number.
 894      * The number is a DigitList wrapper onto a floating point decimal number.
 895      * The default implementation in NumberFormat converts the decimal number
 896      * to a double and formats that.  Subclasses of NumberFormat that want
 897      * to specifically handle big decimal numbers must override this method.
 898      * class DecimalFormat does so.
 899      *
 900      * @param number    The number, a DigitList format Decimal Floating Point.
 901      * @param appendTo  Output parameter to receive result.
 902      *                  Result is appended to existing contents.
 903      * @param pos       On input: an alignment field, if desired.
 904      *                  On output: the offsets of the alignment field.
 905      * @param status    Output param filled with success/failure status.
 906      * @return          Reference to &#39;appendTo&#39; parameter.
 907      * @internal
 908      */
 909     virtual UnicodeString&amp; format(const number::impl::DecimalQuantity &amp;number,
 910                                   UnicodeString&amp; appendTo,
 911                                   FieldPosition&amp; pos,
 912                                   UErrorCode&amp; status) const;
 913 public:
 914 
 915   using NumberFormat::parse;
 916 
 917   /**
 918    * Parses the specfied string, beginning at the specified position, according
 919    * to this formatter&#39;s rules.  This will match the string against all of the
 920    * formatter&#39;s public rule sets and return the value corresponding to the longest
 921    * parseable substring.  This function&#39;s behavior is affected by the lenient
 922    * parse mode.
 923    * @param text The string to parse
 924    * @param result the result of the parse, either a double or a long.
 925    * @param parsePosition On entry, contains the position of the first character
 926    * in &quot;text&quot; to examine.  On exit, has been updated to contain the position
 927    * of the first character in &quot;text&quot; that wasn&#39;t consumed by the parse.
 928    * @see #setLenient
 929    * @stable ICU 2.0
 930    */
 931   virtual void parse(const UnicodeString&amp; text,
 932                      Formattable&amp; result,
 933                      ParsePosition&amp; parsePosition) const;
 934 
 935 #if !UCONFIG_NO_COLLATION
 936 
 937   /**
 938    * Turns lenient parse mode on and off.
 939    *
 940    * When in lenient parse mode, the formatter uses a Collator for parsing the text.
 941    * Only primary differences are treated as significant.  This means that case
 942    * differences, accent differences, alternate spellings of the same letter
 943    * (e.g., ae and a-umlaut in German), ignorable characters, etc. are ignored in
 944    * matching the text.  In many cases, numerals will be accepted in place of words
 945    * or phrases as well.
 946    *
 947    * For example, all of the following will correctly parse as 255 in English in
 948    * lenient-parse mode:
 949    * &lt;br&gt;&quot;two hundred fifty-five&quot;
 950    * &lt;br&gt;&quot;two hundred fifty five&quot;
 951    * &lt;br&gt;&quot;TWO HUNDRED FIFTY-FIVE&quot;
 952    * &lt;br&gt;&quot;twohundredfiftyfive&quot;
 953    * &lt;br&gt;&quot;2 hundred fifty-5&quot;
 954    *
 955    * The Collator used is determined by the locale that was
 956    * passed to this object on construction.  The description passed to this object
 957    * on construction may supply additional collation rules that are appended to the
 958    * end of the default collator for the locale, enabling additional equivalences
 959    * (such as adding more ignorable characters or permitting spelled-out version of
 960    * symbols; see the demo program for examples).
 961    *
 962    * It&#39;s important to emphasize that even strict parsing is relatively lenient: it
 963    * will accept some text that it won&#39;t produce as output.  In English, for example,
 964    * it will correctly parse &quot;two hundred zero&quot; and &quot;fifteen hundred&quot;.
 965    *
 966    * @param enabled If true, turns lenient-parse mode on; if false, turns it off.
 967    * @see RuleBasedCollator
 968    * @stable ICU 2.0
 969    */
 970   virtual void setLenient(UBool enabled);
 971 
 972   /**
 973    * Returns true if lenient-parse mode is turned on.  Lenient parsing is off
 974    * by default.
 975    * @return true if lenient-parse mode is turned on.
 976    * @see #setLenient
 977    * @stable ICU 2.0
 978    */
 979   virtual inline UBool isLenient(void) const;
 980 
 981 #endif
 982 
 983   /**
 984    * Override the default rule set to use.  If ruleSetName is null, reset
 985    * to the initial default rule set.  If the rule set is not a public rule set name,
 986    * U_ILLEGAL_ARGUMENT_ERROR is returned in status.
 987    * @param ruleSetName the name of the rule set, or null to reset the initial default.
 988    * @param status set to failure code when a problem occurs.
 989    * @stable ICU 2.6
 990    */
 991   virtual void setDefaultRuleSet(const UnicodeString&amp; ruleSetName, UErrorCode&amp; status);
 992 
 993   /**
 994    * Return the name of the current default rule set.  If the current rule set is
 995    * not public, returns a bogus (and empty) UnicodeString.
 996    * @return the name of the current default rule set
 997    * @stable ICU 3.0
 998    */
 999   virtual UnicodeString getDefaultRuleSetName() const;
1000 
1001   /**
1002    * Set a particular UDisplayContext value in the formatter, such as
1003    * UDISPCTX_CAPITALIZATION_FOR_STANDALONE. Note: For getContext, see
1004    * NumberFormat.
1005    * @param value The UDisplayContext value to set.
1006    * @param status Input/output status. If at entry this indicates a failure
1007    *               status, the function will do nothing; otherwise this will be
1008    *               updated with any new status from the function.
1009    * @stable ICU 53
1010    */
1011   virtual void setContext(UDisplayContext value, UErrorCode&amp; status);
1012 
1013     /**
1014      * Get the rounding mode.
1015      * @return A rounding mode
1016      * @draft ICU 60
1017      */
1018     virtual ERoundingMode getRoundingMode(void) const;
1019 
1020     /**
1021      * Set the rounding mode.
1022      * @param roundingMode A rounding mode
1023      * @draft ICU 60
1024      */
1025     virtual void setRoundingMode(ERoundingMode roundingMode);
1026 
1027 public:
1028     /**
1029      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for this class.
1030      *
1031      * @stable ICU 2.8
1032      */
1033     static UClassID U_EXPORT2 getStaticClassID(void);
1034 
1035     /**
1036      * ICU &quot;poor man&#39;s RTTI&quot;, returns a UClassID for the actual class.
1037      *
1038      * @stable ICU 2.8
1039      */
1040     virtual UClassID getDynamicClassID(void) const;
1041 
1042     /**
1043      * Sets the decimal format symbols, which is generally not changed
1044      * by the programmer or user. The formatter takes ownership of
1045      * symbolsToAdopt; the client must not delete it.
1046      *
1047      * @param symbolsToAdopt DecimalFormatSymbols to be adopted.
1048      * @stable ICU 49
1049      */
1050     virtual void adoptDecimalFormatSymbols(DecimalFormatSymbols* symbolsToAdopt);
1051 
1052     /**
1053      * Sets the decimal format symbols, which is generally not changed
1054      * by the programmer or user. A clone of the symbols is created and
1055      * the symbols is _not_ adopted; the client is still responsible for
1056      * deleting it.
1057      *
1058      * @param symbols DecimalFormatSymbols.
1059      * @stable ICU 49
1060      */
1061     virtual void setDecimalFormatSymbols(const DecimalFormatSymbols&amp; symbols);
1062 
1063 private:
1064     RuleBasedNumberFormat(); // default constructor not implemented
1065 
1066     // this will ref the localizations if they are not NULL
1067     // caller must deref to get adoption
1068     RuleBasedNumberFormat(const UnicodeString&amp; description, LocalizationInfo* localizations,
1069               const Locale&amp; locale, UParseError&amp; perror, UErrorCode&amp; status);
1070 
1071     void init(const UnicodeString&amp; rules, LocalizationInfo* localizations, UParseError&amp; perror, UErrorCode&amp; status);
1072     void initCapitalizationContextInfo(const Locale&amp; thelocale);
1073     void dispose();
1074     void stripWhitespace(UnicodeString&amp; src);
1075     void initDefaultRuleSet();
1076     NFRuleSet* findRuleSet(const UnicodeString&amp; name, UErrorCode&amp; status) const;
1077 
1078     /* friend access */
1079     friend class NFSubstitution;
1080     friend class NFRule;
1081     friend class NFRuleSet;
1082     friend class FractionalPartSubstitution;
1083 
1084     inline NFRuleSet * getDefaultRuleSet() const;
1085     const RuleBasedCollator * getCollator() const;
1086     DecimalFormatSymbols * initializeDecimalFormatSymbols(UErrorCode &amp;status);
1087     const DecimalFormatSymbols * getDecimalFormatSymbols() const;
1088     NFRule * initializeDefaultInfinityRule(UErrorCode &amp;status);
1089     const NFRule * getDefaultInfinityRule() const;
1090     NFRule * initializeDefaultNaNRule(UErrorCode &amp;status);
1091     const NFRule * getDefaultNaNRule() const;
1092     PluralFormat *createPluralFormat(UPluralType pluralType, const UnicodeString &amp;pattern, UErrorCode&amp; status) const;
1093     UnicodeString&amp; adjustForCapitalizationContext(int32_t startPos, UnicodeString&amp; currentResult, UErrorCode&amp; status) const;
1094     UnicodeString&amp; format(int64_t number, NFRuleSet *ruleSet, UnicodeString&amp; toAppendTo, UErrorCode&amp; status) const;
1095     void format(double number, NFRuleSet&amp; rs, UnicodeString&amp; toAppendTo, UErrorCode&amp; status) const;
1096 
1097 private:
1098     NFRuleSet **ruleSets;
1099     UnicodeString* ruleSetDescriptions;
1100     int32_t numRuleSets;
1101     NFRuleSet *defaultRuleSet;
1102     Locale locale;
1103     RuleBasedCollator* collator;
1104     DecimalFormatSymbols* decimalFormatSymbols;
1105     NFRule *defaultInfinityRule;
1106     NFRule *defaultNaNRule;
1107     ERoundingMode roundingMode;
1108     UBool lenient;
1109     UnicodeString* lenientParseRules;
1110     LocalizationInfo* localizations;
1111     UnicodeString originalDescription;
1112     UBool capitalizationInfoSet;
1113     UBool capitalizationForUIListMenu;
1114     UBool capitalizationForStandAlone;
1115     BreakIterator* capitalizationBrkIter;
1116 };
1117 
1118 // ---------------
1119 
1120 #if !UCONFIG_NO_COLLATION
1121 
1122 inline UBool
1123 RuleBasedNumberFormat::isLenient(void) const {
1124     return lenient;
1125 }
1126 
1127 #endif
1128 
1129 inline NFRuleSet*
1130 RuleBasedNumberFormat::getDefaultRuleSet() const {
1131     return defaultRuleSet;
1132 }
1133 
1134 U_NAMESPACE_END
1135 
1136 /* U_HAVE_RBNF */
1137 #endif
1138 
1139 /* RBNF_H */
1140 #endif
    </pre>
  </body>
</html>