<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/calendar.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="alphaindex.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="coll.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/calendar.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  35  */
  36 #if !UCONFIG_NO_FORMATTING
  37 
  38 #include &quot;unicode/uobject.h&quot;
  39 #include &quot;unicode/locid.h&quot;
  40 #include &quot;unicode/timezone.h&quot;
  41 #include &quot;unicode/ucal.h&quot;
  42 #include &quot;unicode/umisc.h&quot;
  43 
  44 U_NAMESPACE_BEGIN
  45 
  46 class ICUServiceFactory;
  47 
  48 /**
  49  * @internal
  50  */
  51 typedef int32_t UFieldResolutionTable[12][8];
  52 
  53 class BasicTimeZone;
  54 /**
<span class="line-modified">  55  * &lt;code&gt;Calendar&lt;/code&gt; is an abstract base class for converting between</span>
<span class="line-modified">  56  * a &lt;code&gt;UDate&lt;/code&gt; object and a set of integer fields such as</span>
<span class="line-modified">  57  * &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH&lt;/code&gt;, &lt;code&gt;DAY&lt;/code&gt;, &lt;code&gt;HOUR&lt;/code&gt;,</span>
<span class="line-modified">  58  * and so on. (A &lt;code&gt;UDate&lt;/code&gt; object represents a specific instant in</span>
  59  * time with millisecond precision. See UDate
<span class="line-modified">  60  * for information about the &lt;code&gt;UDate&lt;/code&gt; class.)</span>
  61  *
<span class="line-modified">  62  * &lt;p&gt;</span>
<span class="line-removed">  63  * Subclasses of &lt;code&gt;Calendar&lt;/code&gt; interpret a &lt;code&gt;UDate&lt;/code&gt;</span>
  64  * according to the rules of a specific calendar system.
<span class="line-modified">  65  * The most commonly used subclass of &lt;code&gt;Calendar&lt;/code&gt; is</span>
<span class="line-modified">  66  * &lt;code&gt;GregorianCalendar&lt;/code&gt;. Other subclasses could represent</span>
  67  * the various types of lunar calendars in use in many parts of the world.
  68  *
<span class="line-modified">  69  * &lt;p&gt;</span>
<span class="line-modified">  70  * &lt;b&gt;NOTE&lt;/b&gt;: (ICU 2.6) The subclass interface should be considered unstable</span>
<span class="line-removed">  71  * - it WILL change.</span>
  72  *
<span class="line-modified">  73  * &lt;p&gt;</span>
<span class="line-modified">  74  * Like other locale-sensitive classes, &lt;code&gt;Calendar&lt;/code&gt; provides a</span>
<span class="line-modified">  75  * static method, &lt;code&gt;createInstance&lt;/code&gt;, for getting a generally useful</span>
<span class="line-modified">  76  * object of this type. &lt;code&gt;Calendar&lt;/code&gt;&#39;s &lt;code&gt;createInstance&lt;/code&gt; method</span>
<span class="line-removed">  77  * returns the appropriate &lt;code&gt;Calendar&lt;/code&gt; subclass whose</span>
  78  * time fields have been initialized with the current date and time:
<span class="line-removed">  79  * \htmlonly&lt;blockquote&gt;\endhtmlonly</span>
<span class="line-removed">  80  * &lt;pre&gt;</span>
<span class="line-removed">  81  * Calendar *rightNow = Calendar::createInstance(errCode);</span>
<span class="line-removed">  82  * &lt;/pre&gt;</span>
<span class="line-removed">  83  * \htmlonly&lt;/blockquote&gt;\endhtmlonly</span>
  84  *
<span class="line-modified">  85  * &lt;p&gt;</span>
<span class="line-modified">  86  * A &lt;code&gt;Calendar&lt;/code&gt; object can produce all the time field values</span>

  87  * needed to implement the date-time formatting for a particular language
  88  * and calendar style (for example, Japanese-Gregorian, Japanese-Traditional).
  89  *
<span class="line-modified">  90  * &lt;p&gt;</span>
<span class="line-removed">  91  * When computing a &lt;code&gt;UDate&lt;/code&gt; from time fields, some special circumstances</span>
  92  * may arise: there may be insufficient information to compute the
<span class="line-modified">  93  * &lt;code&gt;UDate&lt;/code&gt; (such as only year and month but no day in the month),</span>
  94  * there may be inconsistent information (such as &quot;Tuesday, July 15, 1996&quot;
  95  * -- July 15, 1996 is actually a Monday), or the input time might be ambiguous
  96  * because of time zone transition.
  97  *
<span class="line-modified">  98  * &lt;p&gt;</span>
<span class="line-removed">  99  * &lt;strong&gt;Insufficient information.&lt;/strong&gt; The calendar will use default</span>
 100  * information to specify the missing fields. This may vary by calendar; for
 101  * the Gregorian calendar, the default for a field is the same as that of the
 102  * start of the epoch: i.e., YEAR = 1970, MONTH = JANUARY, DATE = 1, etc.
 103  *
<span class="line-modified"> 104  * &lt;p&gt;</span>
<span class="line-removed"> 105  * &lt;strong&gt;Inconsistent information.&lt;/strong&gt; If fields conflict, the calendar</span>
 106  * will give preference to fields set more recently. For example, when
 107  * determining the day, the calendar will look for one of the following
 108  * combinations of fields.  The most recent combination, as determined by the
 109  * most recently set single field, will be used.
 110  *
<span class="line-modified"> 111  * \htmlonly&lt;blockquote&gt;\endhtmlonly</span>
<span class="line-modified"> 112  * &lt;pre&gt;</span>
<span class="line-modified"> 113  * MONTH + DAY_OF_MONTH</span>
<span class="line-modified"> 114  * MONTH + WEEK_OF_MONTH + DAY_OF_WEEK</span>
<span class="line-modified"> 115  * MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK</span>
<span class="line-removed"> 116  * DAY_OF_YEAR</span>
<span class="line-removed"> 117  * DAY_OF_WEEK + WEEK_OF_YEAR</span>
<span class="line-removed"> 118  * &lt;/pre&gt;</span>
<span class="line-removed"> 119  * \htmlonly&lt;/blockquote&gt;\endhtmlonly</span>
 120  *
 121  * For the time of day:
 122  *
<span class="line-modified"> 123  * \htmlonly&lt;blockquote&gt;\endhtmlonly</span>
<span class="line-modified"> 124  * &lt;pre&gt;</span>
<span class="line-removed"> 125  * HOUR_OF_DAY</span>
<span class="line-removed"> 126  * AM_PM + HOUR</span>
<span class="line-removed"> 127  * &lt;/pre&gt;</span>
<span class="line-removed"> 128  * \htmlonly&lt;/blockquote&gt;\endhtmlonly</span>
 129  *
<span class="line-modified"> 130  * &lt;p&gt;</span>
<span class="line-removed"> 131  * &lt;strong&gt;Ambiguous Wall Clock Time.&lt;/strong&gt; When time offset from UTC has</span>
 132  * changed, it produces an ambiguous time slot around the transition. For example,
 133  * many US locations observe daylight saving time. On the date switching to daylight
 134  * saving time in US, wall clock time jumps from 12:59 AM (standard) to 2:00 AM
 135  * (daylight). Therefore, wall clock time from 1:00 AM to 1:59 AM do not exist on
 136  * the date. When the input wall time fall into this missing time slot, the ICU
 137  * Calendar resolves the time using the UTC offset before the transition by default.
 138  * In this example, 1:30 AM is interpreted as 1:30 AM standard time (non-exist),
 139  * so the final result will be 2:30 AM daylight time.
 140  *
<span class="line-modified"> 141  * &lt;p&gt;On the date switching back to standard time, wall clock time is moved back one</span>
 142  * hour at 2:00 AM. So wall clock time from 1:00 AM to 1:59 AM occur twice. In this
 143  * case, the ICU Calendar resolves the time using the UTC offset after the transition
 144  * by default. For example, 1:30 AM on the date is resolved as 1:30 AM standard time.
 145  *
<span class="line-modified"> 146  * &lt;p&gt;Ambiguous wall clock time resolution behaviors can be customized by Calendar APIs</span>
 147  * {@link #setRepeatedWallTimeOption} and {@link #setSkippedWallTimeOption}.
 148  * These methods are available in ICU 49 or later versions.
 149  *
<span class="line-modified"> 150  * &lt;p&gt;</span>
<span class="line-removed"> 151  * &lt;strong&gt;Note:&lt;/strong&gt; for some non-Gregorian calendars, different</span>
 152  * fields may be necessary for complete disambiguation. For example, a full
<span class="line-modified"> 153  * specification of the historial Arabic astronomical calendar requires year,</span>
<span class="line-modified"> 154  * month, day-of-month &lt;em&gt;and&lt;/em&gt; day-of-week in some cases.</span>
 155  *
<span class="line-modified"> 156  * &lt;p&gt;</span>
<span class="line-removed"> 157  * &lt;strong&gt;Note:&lt;/strong&gt; There are certain possible ambiguities in</span>
 158  * interpretation of certain singular times, which are resolved in the
 159  * following ways:
<span class="line-removed"> 160  * &lt;ol&gt;</span>
<span class="line-removed"> 161  *     &lt;li&gt; 24:00:00 &quot;belongs&quot; to the following day. That is,</span>
<span class="line-removed"> 162  *          23:59 on Dec 31, 1969 &amp;lt; 24:00 on Jan 1, 1970 &amp;lt; 24:01:00 on Jan 1, 1970</span>
 163  *
<span class="line-modified"> 164  *     &lt;li&gt; Although historically not precise, midnight also belongs to &quot;am&quot;,</span>
<span class="line-modified"> 165  *          and noon belongs to &quot;pm&quot;, so on the same day,</span>
<span class="line-modified"> 166  *          12:00 am (midnight) &amp;lt; 12:01 am, and 12:00 pm (noon) &amp;lt; 12:01 pm</span>
<span class="line-modified"> 167  * &lt;/ol&gt;</span>

 168  *
<span class="line-removed"> 169  * &lt;p&gt;</span>
 170  * The date or time format strings are not part of the definition of a
 171  * calendar, as those must be modifiable or overridable by the user at
<span class="line-modified"> 172  * runtime. Use {@link DateFormat}</span>
<span class="line-removed"> 173  * to format dates.</span>
 174  *
<span class="line-modified"> 175  * &lt;p&gt;</span>
<span class="line-removed"> 176  * &lt;code&gt;Calendar&lt;/code&gt; provides an API for field &quot;rolling&quot;, where fields</span>
 177  * can be incremented or decremented, but wrap around. For example, rolling the
<span class="line-modified"> 178  * month up in the date &lt;code&gt;December 12, &lt;b&gt;1996&lt;/b&gt;&lt;/code&gt; results in</span>
<span class="line-modified"> 179  * &lt;code&gt;January 12, &lt;b&gt;1996&lt;/b&gt;&lt;/code&gt;.</span>
 180  *
<span class="line-modified"> 181  * &lt;p&gt;</span>
<span class="line-removed"> 182  * &lt;code&gt;Calendar&lt;/code&gt; also provides a date arithmetic function for</span>
 183  * adding the specified (signed) amount of time to a particular time field.
<span class="line-modified"> 184  * For example, subtracting 5 days from the date &lt;code&gt;September 12, 1996&lt;/code&gt;</span>
<span class="line-modified"> 185  * results in &lt;code&gt;September 7, 1996&lt;/code&gt;.</span>
 186  *
<span class="line-modified"> 187  * &lt;p&gt;&lt;big&gt;&lt;b&gt;Supported range&lt;/b&gt;&lt;/big&gt;</span>
 188  *
<span class="line-modified"> 189  * &lt;p&gt;The allowable range of &lt;code&gt;Calendar&lt;/code&gt; has been</span>
<span class="line-modified"> 190  * narrowed. &lt;code&gt;GregorianCalendar&lt;/code&gt; used to attempt to support</span>
<span class="line-modified"> 191  * the range of dates with millisecond values from</span>
<span class="line-removed"> 192  * &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; to &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</span>
<span class="line-removed"> 193  * The new &lt;code&gt;Calendar&lt;/code&gt; protocol specifies the</span>
 194  * maximum range of supportable dates as those having Julian day numbers
<span class="line-modified"> 195  * of &lt;code&gt;-0x7F000000&lt;/code&gt; to &lt;code&gt;+0x7F000000&lt;/code&gt;. This</span>
<span class="line-modified"> 196  * corresponds to years from ~5,800,000 BCE to ~5,800,000 CE. Programmers</span>
<span class="line-modified"> 197  * should use the protected constants in &lt;code&gt;Calendar&lt;/code&gt; to</span>
<span class="line-modified"> 198  * specify an extremely early or extremely late date.&lt;/p&gt;</span>












 199  *
 200  * @stable ICU 2.0
 201  */
 202 class U_I18N_API Calendar : public UObject {
 203 public:
 204 
 205     /**
 206      * Field IDs for date and time. Used to specify date/time fields. ERA is calendar
 207      * specific. Example ranges given are for illustration only; see specific Calendar
 208      * subclasses for actual ranges.
 209      * @deprecated ICU 2.6. Use C enum UCalendarDateFields defined in ucal.h
 210      */
 211     enum EDateFields {
 212 #ifndef U_HIDE_DEPRECATED_API
 213 /*
 214  * ERA may be defined on other platforms. To avoid any potential problems undefined it here.
 215  */
 216 #ifdef ERA
 217 #undef ERA
 218 #endif
</pre>
<hr />
<pre>
 886      * representing the dates.
 887      *
 888      * @param lenient  True specifies date/time interpretation to be lenient.
 889      *
 890      * @see            DateFormat#setLenient
 891      * @stable ICU 2.0
 892      */
 893     void setLenient(UBool lenient);
 894 
 895     /**
 896      * Tells whether date/time interpretation is to be lenient.
 897      *
 898      * @return   True tells that date/time interpretation is to be lenient.
 899      * @stable ICU 2.0
 900      */
 901     UBool isLenient(void) const;
 902 
 903     /**
 904      * Sets the behavior for handling wall time repeating multiple times
 905      * at negative time zone offset transitions. For example, 1:30 AM on
<span class="line-modified"> 906      * November 6, 2011 in US Eastern time (Ameirca/New_York) occurs twice;</span>
 907      * 1:30 AM EDT, then 1:30 AM EST one hour later. When &lt;code&gt;UCAL_WALLTIME_FIRST&lt;/code&gt;
 908      * is used, the wall time 1:30AM in this example will be interpreted as 1:30 AM EDT
 909      * (first occurrence). When &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt; is used, it will be
 910      * interpreted as 1:30 AM EST (last occurrence). The default value is
 911      * &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt;.
 912      * &lt;p&gt;
 913      * &lt;b&gt;Note:&lt;/b&gt;When &lt;code&gt;UCAL_WALLTIME_NEXT_VALID&lt;/code&gt; is not a valid
 914      * option for this. When the argument is neither &lt;code&gt;UCAL_WALLTIME_FIRST&lt;/code&gt;
 915      * nor &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt;, this method has no effect and will keep
 916      * the current setting.
 917      *
 918      * @param option the behavior for handling repeating wall time, either
 919      * &lt;code&gt;UCAL_WALLTIME_FIRST&lt;/code&gt; or &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt;.
 920      * @see #getRepeatedWallTimeOption
 921      * @stable ICU 49
 922      */
 923     void setRepeatedWallTimeOption(UCalendarWallTimeOption option);
 924 
 925     /**
 926      * Gets the behavior for handling wall time repeating multiple times
</pre>
<hr />
<pre>
1701      * length.
1702      * @param bestField which field to use to calculate the date
1703      * @return julian day specified by calendar fields.
1704      * @internal
1705      */
1706     virtual int32_t handleComputeJulianDay(UCalendarDateFields bestField);
1707 
1708     /**
1709      * Subclasses must override this to convert from week fields
1710      * (YEAR_WOY and WEEK_OF_YEAR) to an extended year in the case
1711      * where YEAR, EXTENDED_YEAR are not set.
1712      * The Calendar implementation assumes yearWoy is in extended gregorian form
1713      * @return the extended year, UCAL_EXTENDED_YEAR
1714      * @internal
1715      */
1716     virtual int32_t handleGetExtendedYearFromWeekFields(int32_t yearWoy, int32_t woy);
1717 
1718     /**
1719      * Validate a single field of this calendar.  Subclasses should
1720      * override this method to validate any calendar-specific fields.
<span class="line-modified">1721      * Generic fields can be handled by</span>
<span class="line-removed">1722      * &lt;code&gt;Calendar::validateField()&lt;/code&gt;.</span>
<span class="line-removed">1723      * @see #validateField(int, int, int, int&amp;)</span>
1724      * @internal
1725      */
1726     virtual void validateField(UCalendarDateFields field, UErrorCode &amp;status);
1727 
1728 #ifndef U_HIDE_INTERNAL_API
1729     /**
1730      * Compute the Julian day from fields.  Will determine whether to use
1731      * the JULIAN_DAY field directly, or other fields.
1732      * @return the julian day
1733      * @internal
1734      */
1735     int32_t computeJulianDay();
1736 
1737     /**
1738      * Compute the milliseconds in the day from the fields.  This is a
1739      * value from 0 to 23:59:59.999 inclusive, unless fields are out of
1740      * range, in which case it can be an arbitrary value.  This value
1741      * reflects local zone wall time.
1742      * @internal
1743      */
</pre>
<hr />
<pre>
2154      */
2155     void recalculateStamp();
2156 
2157     /**
2158      * The current time set for the calendar.
2159      */
2160     UDate        fTime;
2161 
2162     /**
2163      * @see   #setLenient
2164      */
2165     UBool      fLenient;
2166 
2167     /**
2168      * Time zone affects the time calculation done by Calendar. Calendar subclasses use
2169      * the time zone data to produce the local time. Always set; never NULL.
2170      */
2171     TimeZone*   fZone;
2172 
2173     /**
<span class="line-modified">2174      * Option for rpeated wall time</span>
2175      * @see #setRepeatedWallTimeOption
2176      */
2177     UCalendarWallTimeOption fRepeatedWallTime;
2178 
2179     /**
2180      * Option for skipped wall time
2181      * @see #setSkippedWallTimeOption
2182      */
2183     UCalendarWallTimeOption fSkippedWallTime;
2184 
2185     /**
2186      * Both firstDayOfWeek and minimalDaysInFirstWeek are locale-dependent. They are
2187      * used to figure out the week count for a specific date for a given locale. These
2188      * must be set when a Calendar is constructed. For example, in US locale,
2189      * firstDayOfWeek is SUNDAY; minimalDaysInFirstWeek is 1. They are used to figure
2190      * out the week count for a specific date for a given locale. These must be set when
2191      * a Calendar is constructed.
2192      */
2193     UCalendarDaysOfWeek fFirstDayOfWeek;
2194     uint8_t     fMinimalDaysInFirstWeek;
</pre>
<hr />
<pre>
2439     virtual void setRelatedYear(int32_t year);
2440 
2441 #ifndef U_HIDE_INTERNAL_API
2442     /** Get the locale for this calendar object. You can choose between valid and actual locale.
2443      *  @param type type of the locale we&#39;re looking for (valid or actual)
2444      *  @param status error code for the operation
2445      *  @return the locale
2446      *  @internal
2447      */
2448     const char* getLocaleID(ULocDataLocaleType type, UErrorCode &amp;status) const;
2449 #endif  /* U_HIDE_INTERNAL_API */
2450 
2451 private:
2452     /**
2453      * Cast TimeZone used by this object to BasicTimeZone, or NULL if the TimeZone
2454      * is not an instance of BasicTimeZone.
2455      */
2456     BasicTimeZone* getBasicTimeZone() const;
2457 
2458     /**
<span class="line-modified">2459      * Find the previous zone transtion near the given time.</span>
2460      * @param base The base time, inclusive
2461      * @param transitionTime Receives the result time
2462      * @param status The error status
2463      * @return TRUE if a transition is found.
2464      */
2465     UBool getImmediatePreviousZoneTransition(UDate base, UDate *transitionTime, UErrorCode&amp; status) const;
2466 
2467 public:
2468 #ifndef U_HIDE_INTERNAL_API
2469     /**
2470      * Creates a new Calendar from a Locale for the cache.
2471      * This method does not set the time or timezone in returned calendar.
2472      * @param locale the locale.
2473      * @param status any error returned here.
2474      * @return the new Calendar object with no time or timezone set.
2475      * @internal For ICU use only.
2476      */
2477     static Calendar * U_EXPORT2 makeInstance(
2478             const Locale &amp;locale, UErrorCode &amp;status);
2479 
</pre>
</td>
<td>
<hr />
<pre>
  35  */
  36 #if !UCONFIG_NO_FORMATTING
  37 
  38 #include &quot;unicode/uobject.h&quot;
  39 #include &quot;unicode/locid.h&quot;
  40 #include &quot;unicode/timezone.h&quot;
  41 #include &quot;unicode/ucal.h&quot;
  42 #include &quot;unicode/umisc.h&quot;
  43 
  44 U_NAMESPACE_BEGIN
  45 
  46 class ICUServiceFactory;
  47 
  48 /**
  49  * @internal
  50  */
  51 typedef int32_t UFieldResolutionTable[12][8];
  52 
  53 class BasicTimeZone;
  54 /**
<span class="line-modified">  55  * `Calendar` is an abstract base class for converting between</span>
<span class="line-modified">  56  * a `UDate` object and a set of integer fields such as</span>
<span class="line-modified">  57  * `YEAR`, `MONTH`, `DAY`, `HOUR`, and so on.</span>
<span class="line-modified">  58  * (A `UDate` object represents a specific instant in</span>
  59  * time with millisecond precision. See UDate
<span class="line-modified">  60  * for information about the `UDate` class.)</span>
  61  *
<span class="line-modified">  62  * Subclasses of `Calendar` interpret a `UDate`</span>

  63  * according to the rules of a specific calendar system.
<span class="line-modified">  64  * The most commonly used subclass of `Calendar` is</span>
<span class="line-modified">  65  * `GregorianCalendar`. Other subclasses could represent</span>
  66  * the various types of lunar calendars in use in many parts of the world.
  67  *
<span class="line-modified">  68  * **NOTE**: (ICU 2.6) The subclass interface should be considered unstable -</span>
<span class="line-modified">  69  * it WILL change.</span>

  70  *
<span class="line-modified">  71  * Like other locale-sensitive classes, `Calendar` provides a</span>
<span class="line-modified">  72  * static method, `createInstance`, for getting a generally useful</span>
<span class="line-modified">  73  * object of this type. `Calendar`&#39;s `createInstance` method</span>
<span class="line-modified">  74  * returns the appropriate `Calendar` subclass whose</span>

  75  * time fields have been initialized with the current date and time:





  76  *
<span class="line-modified">  77  *     Calendar *rightNow = Calendar::createInstance(errCode);</span>
<span class="line-modified">  78  *</span>
<span class="line-added">  79  * A `Calendar` object can produce all the time field values</span>
  80  * needed to implement the date-time formatting for a particular language
  81  * and calendar style (for example, Japanese-Gregorian, Japanese-Traditional).
  82  *
<span class="line-modified">  83  * When computing a `UDate` from time fields, some special circumstances</span>

  84  * may arise: there may be insufficient information to compute the
<span class="line-modified">  85  * `UDate` (such as only year and month but no day in the month),</span>
  86  * there may be inconsistent information (such as &quot;Tuesday, July 15, 1996&quot;
  87  * -- July 15, 1996 is actually a Monday), or the input time might be ambiguous
  88  * because of time zone transition.
  89  *
<span class="line-modified">  90  * **Insufficient information.** The calendar will use default</span>

  91  * information to specify the missing fields. This may vary by calendar; for
  92  * the Gregorian calendar, the default for a field is the same as that of the
  93  * start of the epoch: i.e., YEAR = 1970, MONTH = JANUARY, DATE = 1, etc.
  94  *
<span class="line-modified">  95  * **Inconsistent information.** If fields conflict, the calendar</span>

  96  * will give preference to fields set more recently. For example, when
  97  * determining the day, the calendar will look for one of the following
  98  * combinations of fields.  The most recent combination, as determined by the
  99  * most recently set single field, will be used.
 100  *
<span class="line-modified"> 101  *     MONTH + DAY_OF_MONTH</span>
<span class="line-modified"> 102  *     MONTH + WEEK_OF_MONTH + DAY_OF_WEEK</span>
<span class="line-modified"> 103  *     MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK</span>
<span class="line-modified"> 104  *     DAY_OF_YEAR</span>
<span class="line-modified"> 105  *     DAY_OF_WEEK + WEEK_OF_YEAR</span>




 106  *
 107  * For the time of day:
 108  *
<span class="line-modified"> 109  *     HOUR_OF_DAY</span>
<span class="line-modified"> 110  *     AM_PM + HOUR</span>




 111  *
<span class="line-modified"> 112  * **Ambiguous Wall Clock Time.** When time offset from UTC has</span>

 113  * changed, it produces an ambiguous time slot around the transition. For example,
 114  * many US locations observe daylight saving time. On the date switching to daylight
 115  * saving time in US, wall clock time jumps from 12:59 AM (standard) to 2:00 AM
 116  * (daylight). Therefore, wall clock time from 1:00 AM to 1:59 AM do not exist on
 117  * the date. When the input wall time fall into this missing time slot, the ICU
 118  * Calendar resolves the time using the UTC offset before the transition by default.
 119  * In this example, 1:30 AM is interpreted as 1:30 AM standard time (non-exist),
 120  * so the final result will be 2:30 AM daylight time.
 121  *
<span class="line-modified"> 122  * On the date switching back to standard time, wall clock time is moved back one</span>
 123  * hour at 2:00 AM. So wall clock time from 1:00 AM to 1:59 AM occur twice. In this
 124  * case, the ICU Calendar resolves the time using the UTC offset after the transition
 125  * by default. For example, 1:30 AM on the date is resolved as 1:30 AM standard time.
 126  *
<span class="line-modified"> 127  * Ambiguous wall clock time resolution behaviors can be customized by Calendar APIs</span>
 128  * {@link #setRepeatedWallTimeOption} and {@link #setSkippedWallTimeOption}.
 129  * These methods are available in ICU 49 or later versions.
 130  *
<span class="line-modified"> 131  * **Note:** for some non-Gregorian calendars, different</span>

 132  * fields may be necessary for complete disambiguation. For example, a full
<span class="line-modified"> 133  * specification of the historical Arabic astronomical calendar requires year,</span>
<span class="line-modified"> 134  * month, day-of-month *and* day-of-week in some cases.</span>
 135  *
<span class="line-modified"> 136  * **Note:** There are certain possible ambiguities in</span>

 137  * interpretation of certain singular times, which are resolved in the
 138  * following ways:



 139  *
<span class="line-modified"> 140  *   1. 24:00:00 &quot;belongs&quot; to the following day. That is,</span>
<span class="line-modified"> 141  *      23:59 on Dec 31, 1969 &lt; 24:00 on Jan 1, 1970 &lt; 24:01:00 on Jan 1, 1970</span>
<span class="line-modified"> 142  *   2. Although historically not precise, midnight also belongs to &quot;am&quot;,</span>
<span class="line-modified"> 143  *      and noon belongs to &quot;pm&quot;, so on the same day,</span>
<span class="line-added"> 144  *      12:00 am (midnight) &lt; 12:01 am, and 12:00 pm (noon) &lt; 12:01 pm</span>
 145  *

 146  * The date or time format strings are not part of the definition of a
 147  * calendar, as those must be modifiable or overridable by the user at
<span class="line-modified"> 148  * runtime. Use `DateFormat` to format dates.</span>

 149  *
<span class="line-modified"> 150  * `Calendar` provides an API for field &quot;rolling&quot;, where fields</span>

 151  * can be incremented or decremented, but wrap around. For example, rolling the
<span class="line-modified"> 152  * month up in the date December 12, **1996** results in</span>
<span class="line-modified"> 153  * January 12, **1996**.</span>
 154  *
<span class="line-modified"> 155  * `Calendar` also provides a date arithmetic function for</span>

 156  * adding the specified (signed) amount of time to a particular time field.
<span class="line-modified"> 157  * For example, subtracting 5 days from the date `September 12, 1996`</span>
<span class="line-modified"> 158  * results in `September 7, 1996`.</span>
 159  *
<span class="line-modified"> 160  * ***Supported range***</span>
 161  *
<span class="line-modified"> 162  * The allowable range of `Calendar` has been narrowed. `GregorianCalendar` used</span>
<span class="line-modified"> 163  * to attempt to support the range of dates with millisecond values from</span>
<span class="line-modified"> 164  * `Long.MIN_VALUE` to `Long.MAX_VALUE`. The new `Calendar` protocol specifies the</span>


 165  * maximum range of supportable dates as those having Julian day numbers
<span class="line-modified"> 166  * of `-0x7F000000` to `+0x7F000000`. This corresponds to years from ~5,800,000 BCE</span>
<span class="line-modified"> 167  * to ~5,800,000 CE. Programmers should use the protected constants in `Calendar` to</span>
<span class="line-modified"> 168  * specify an extremely early or extremely late date.</span>
<span class="line-modified"> 169  *</span>
<span class="line-added"> 170  * &lt;p&gt;</span>
<span class="line-added"> 171  * The Japanese calendar uses a combination of era name and year number.</span>
<span class="line-added"> 172  * When an emperor of Japan abdicates and a new emperor ascends the throne,</span>
<span class="line-added"> 173  * a new era is declared and year number is reset to 1. Even if the date of</span>
<span class="line-added"> 174  * abdication is scheduled ahead of time, the new era name might not be</span>
<span class="line-added"> 175  * announced until just before the date. In such case, ICU4C may include</span>
<span class="line-added"> 176  * a start date of future era without actual era name, but not enabled</span>
<span class="line-added"> 177  * by default. ICU4C users who want to test the behavior of the future era</span>
<span class="line-added"> 178  * can enable the tentative era by:</span>
<span class="line-added"> 179  * &lt;ul&gt;</span>
<span class="line-added"> 180  * &lt;li&gt;Environment variable &lt;code&gt;ICU_ENABLE_TENTATIVE_ERA=true&lt;/code&gt;.&lt;/li&gt;</span>
<span class="line-added"> 181  * &lt;/ul&gt;</span>
 182  *
 183  * @stable ICU 2.0
 184  */
 185 class U_I18N_API Calendar : public UObject {
 186 public:
 187 
 188     /**
 189      * Field IDs for date and time. Used to specify date/time fields. ERA is calendar
 190      * specific. Example ranges given are for illustration only; see specific Calendar
 191      * subclasses for actual ranges.
 192      * @deprecated ICU 2.6. Use C enum UCalendarDateFields defined in ucal.h
 193      */
 194     enum EDateFields {
 195 #ifndef U_HIDE_DEPRECATED_API
 196 /*
 197  * ERA may be defined on other platforms. To avoid any potential problems undefined it here.
 198  */
 199 #ifdef ERA
 200 #undef ERA
 201 #endif
</pre>
<hr />
<pre>
 869      * representing the dates.
 870      *
 871      * @param lenient  True specifies date/time interpretation to be lenient.
 872      *
 873      * @see            DateFormat#setLenient
 874      * @stable ICU 2.0
 875      */
 876     void setLenient(UBool lenient);
 877 
 878     /**
 879      * Tells whether date/time interpretation is to be lenient.
 880      *
 881      * @return   True tells that date/time interpretation is to be lenient.
 882      * @stable ICU 2.0
 883      */
 884     UBool isLenient(void) const;
 885 
 886     /**
 887      * Sets the behavior for handling wall time repeating multiple times
 888      * at negative time zone offset transitions. For example, 1:30 AM on
<span class="line-modified"> 889      * November 6, 2011 in US Eastern time (America/New_York) occurs twice;</span>
 890      * 1:30 AM EDT, then 1:30 AM EST one hour later. When &lt;code&gt;UCAL_WALLTIME_FIRST&lt;/code&gt;
 891      * is used, the wall time 1:30AM in this example will be interpreted as 1:30 AM EDT
 892      * (first occurrence). When &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt; is used, it will be
 893      * interpreted as 1:30 AM EST (last occurrence). The default value is
 894      * &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt;.
 895      * &lt;p&gt;
 896      * &lt;b&gt;Note:&lt;/b&gt;When &lt;code&gt;UCAL_WALLTIME_NEXT_VALID&lt;/code&gt; is not a valid
 897      * option for this. When the argument is neither &lt;code&gt;UCAL_WALLTIME_FIRST&lt;/code&gt;
 898      * nor &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt;, this method has no effect and will keep
 899      * the current setting.
 900      *
 901      * @param option the behavior for handling repeating wall time, either
 902      * &lt;code&gt;UCAL_WALLTIME_FIRST&lt;/code&gt; or &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt;.
 903      * @see #getRepeatedWallTimeOption
 904      * @stable ICU 49
 905      */
 906     void setRepeatedWallTimeOption(UCalendarWallTimeOption option);
 907 
 908     /**
 909      * Gets the behavior for handling wall time repeating multiple times
</pre>
<hr />
<pre>
1684      * length.
1685      * @param bestField which field to use to calculate the date
1686      * @return julian day specified by calendar fields.
1687      * @internal
1688      */
1689     virtual int32_t handleComputeJulianDay(UCalendarDateFields bestField);
1690 
1691     /**
1692      * Subclasses must override this to convert from week fields
1693      * (YEAR_WOY and WEEK_OF_YEAR) to an extended year in the case
1694      * where YEAR, EXTENDED_YEAR are not set.
1695      * The Calendar implementation assumes yearWoy is in extended gregorian form
1696      * @return the extended year, UCAL_EXTENDED_YEAR
1697      * @internal
1698      */
1699     virtual int32_t handleGetExtendedYearFromWeekFields(int32_t yearWoy, int32_t woy);
1700 
1701     /**
1702      * Validate a single field of this calendar.  Subclasses should
1703      * override this method to validate any calendar-specific fields.
<span class="line-modified">1704      * Generic fields can be handled by `Calendar::validateField()`.</span>


1705      * @internal
1706      */
1707     virtual void validateField(UCalendarDateFields field, UErrorCode &amp;status);
1708 
1709 #ifndef U_HIDE_INTERNAL_API
1710     /**
1711      * Compute the Julian day from fields.  Will determine whether to use
1712      * the JULIAN_DAY field directly, or other fields.
1713      * @return the julian day
1714      * @internal
1715      */
1716     int32_t computeJulianDay();
1717 
1718     /**
1719      * Compute the milliseconds in the day from the fields.  This is a
1720      * value from 0 to 23:59:59.999 inclusive, unless fields are out of
1721      * range, in which case it can be an arbitrary value.  This value
1722      * reflects local zone wall time.
1723      * @internal
1724      */
</pre>
<hr />
<pre>
2135      */
2136     void recalculateStamp();
2137 
2138     /**
2139      * The current time set for the calendar.
2140      */
2141     UDate        fTime;
2142 
2143     /**
2144      * @see   #setLenient
2145      */
2146     UBool      fLenient;
2147 
2148     /**
2149      * Time zone affects the time calculation done by Calendar. Calendar subclasses use
2150      * the time zone data to produce the local time. Always set; never NULL.
2151      */
2152     TimeZone*   fZone;
2153 
2154     /**
<span class="line-modified">2155      * Option for repeated wall time</span>
2156      * @see #setRepeatedWallTimeOption
2157      */
2158     UCalendarWallTimeOption fRepeatedWallTime;
2159 
2160     /**
2161      * Option for skipped wall time
2162      * @see #setSkippedWallTimeOption
2163      */
2164     UCalendarWallTimeOption fSkippedWallTime;
2165 
2166     /**
2167      * Both firstDayOfWeek and minimalDaysInFirstWeek are locale-dependent. They are
2168      * used to figure out the week count for a specific date for a given locale. These
2169      * must be set when a Calendar is constructed. For example, in US locale,
2170      * firstDayOfWeek is SUNDAY; minimalDaysInFirstWeek is 1. They are used to figure
2171      * out the week count for a specific date for a given locale. These must be set when
2172      * a Calendar is constructed.
2173      */
2174     UCalendarDaysOfWeek fFirstDayOfWeek;
2175     uint8_t     fMinimalDaysInFirstWeek;
</pre>
<hr />
<pre>
2420     virtual void setRelatedYear(int32_t year);
2421 
2422 #ifndef U_HIDE_INTERNAL_API
2423     /** Get the locale for this calendar object. You can choose between valid and actual locale.
2424      *  @param type type of the locale we&#39;re looking for (valid or actual)
2425      *  @param status error code for the operation
2426      *  @return the locale
2427      *  @internal
2428      */
2429     const char* getLocaleID(ULocDataLocaleType type, UErrorCode &amp;status) const;
2430 #endif  /* U_HIDE_INTERNAL_API */
2431 
2432 private:
2433     /**
2434      * Cast TimeZone used by this object to BasicTimeZone, or NULL if the TimeZone
2435      * is not an instance of BasicTimeZone.
2436      */
2437     BasicTimeZone* getBasicTimeZone() const;
2438 
2439     /**
<span class="line-modified">2440      * Find the previous zone transition near the given time.</span>
2441      * @param base The base time, inclusive
2442      * @param transitionTime Receives the result time
2443      * @param status The error status
2444      * @return TRUE if a transition is found.
2445      */
2446     UBool getImmediatePreviousZoneTransition(UDate base, UDate *transitionTime, UErrorCode&amp; status) const;
2447 
2448 public:
2449 #ifndef U_HIDE_INTERNAL_API
2450     /**
2451      * Creates a new Calendar from a Locale for the cache.
2452      * This method does not set the time or timezone in returned calendar.
2453      * @param locale the locale.
2454      * @param status any error returned here.
2455      * @return the new Calendar object with no time or timezone set.
2456      * @internal For ICU use only.
2457      */
2458     static Calendar * U_EXPORT2 makeInstance(
2459             const Locale &amp;locale, UErrorCode &amp;status);
2460 
</pre>
</td>
</tr>
</table>
<center><a href="alphaindex.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="coll.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>