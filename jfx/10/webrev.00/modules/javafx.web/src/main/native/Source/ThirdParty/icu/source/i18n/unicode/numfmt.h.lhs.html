<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/numfmt.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ********************************************************************************
   5 * Copyright (C) 1997-2016, International Business Machines Corporation and others.
   6 * All Rights Reserved.
   7 ********************************************************************************
   8 *
   9 * File NUMFMT.H
  10 *
  11 * Modification History:
  12 *
  13 *   Date        Name        Description
  14 *   02/19/97    aliu        Converted from java.
  15 *   03/18/97    clhuang     Updated per C++ implementation.
  16 *   04/17/97    aliu        Changed DigitCount to int per code review.
  17 *    07/20/98    stephen        JDK 1.2 sync up. Added scientific support.
  18 *                            Changed naming conventions to match C++ guidelines
  19 *                            Derecated Java style constants (eg, INTEGER_FIELD)
  20 ********************************************************************************
  21 */
  22 
  23 #ifndef NUMFMT_H
  24 #define NUMFMT_H
  25 
  26 
  27 #include &quot;unicode/utypes.h&quot;
  28 
  29 /**
  30  * \file
  31  * \brief C++ API: Compatibility APIs for number formatting.
  32  */
  33 
  34 #if !UCONFIG_NO_FORMATTING
  35 
  36 #include &quot;unicode/unistr.h&quot;
  37 #include &quot;unicode/format.h&quot;
  38 #include &quot;unicode/unum.h&quot; // UNumberFormatStyle
  39 #include &quot;unicode/locid.h&quot;
  40 #include &quot;unicode/stringpiece.h&quot;
  41 #include &quot;unicode/curramt.h&quot;
  42 #include &quot;unicode/udisplaycontext.h&quot;
  43 
  44 class NumberFormatTest;
  45 
  46 U_NAMESPACE_BEGIN
  47 
  48 class SharedNumberFormat;
  49 
  50 #if !UCONFIG_NO_SERVICE
  51 class NumberFormatFactory;
  52 class StringEnumeration;
  53 #endif
  54 
  55 /**
  56  * &lt;p&gt;&lt;strong&gt;IMPORTANT:&lt;/strong&gt; New users are strongly encouraged to see if
  57  * numberformatter.h fits their use case.  Although not deprecated, this header
  58  * is provided for backwards compatibility only.
<a name="1" id="anc1"></a><span class="line-removed">  59  * &lt;hr/&gt;</span>
  60  *
  61  * Abstract base class for all number formats.  Provides interface for
  62  * formatting and parsing a number.  Also provides methods for
  63  * determining which locales have number formats, and what their names
  64  * are.
  65  *
  66  * \headerfile unicode/numfmt.h &quot;unicode/numfmt.h&quot;
  67  * &lt;P&gt;
  68  * NumberFormat helps you to format and parse numbers for any locale.
  69  * Your code can be completely independent of the locale conventions
  70  * for decimal points, thousands-separators, or even the particular
  71  * decimal digits used, or whether the number format is even decimal.
  72  * &lt;P&gt;
  73  * To format a number for the current Locale, use one of the static
  74  * factory methods:
  75  * \code
  76  *    #include &lt;iostream&gt;
  77  *    #include &quot;unicode/numfmt.h&quot;
  78  *    #include &quot;unicode/unistr.h&quot;
  79  *    #include &quot;unicode/ustream.h&quot;
  80  *    using namespace std;
  81  *
  82  *    int main() {
  83  *        double myNumber = 7.0;
  84  *        UnicodeString myString;
  85  *        UErrorCode success = U_ZERO_ERROR;
  86  *        NumberFormat* nf = NumberFormat::createInstance(success);
  87  *        nf-&gt;format(myNumber, myString);
  88  *        cout &lt;&lt; &quot; Example 1: &quot; &lt;&lt; myString &lt;&lt; endl;
  89  *    }
  90  * \endcode
  91  * Note that there are additional factory methods within subclasses of
  92  * NumberFormat.
  93  * &lt;P&gt;
  94  * If you are formatting multiple numbers, it is more efficient to get
  95  * the format and use it multiple times so that the system doesn&#39;t
  96  * have to fetch the information about the local language and country
  97  * conventions multiple times.
  98  * \code
  99  *     UnicodeString myString;
 100  *     UErrorCode success = U_ZERO_ERROR;
 101  *     NumberFormat *nf = NumberFormat::createInstance( success );
 102  *     for (int32_t number: {123, 3333, -1234567}) {
 103  *         nf-&gt;format(number, myString);
 104  *         myString += &quot;; &quot;;
 105  *     }
 106  *     cout &lt;&lt; &quot; Example 2: &quot; &lt;&lt; myString &lt;&lt; endl;
 107  * \endcode
 108  * To format a number for a different Locale, specify it in the
 109  * call to \c createInstance().
 110  * \code
 111  *     nf = NumberFormat::createInstance(Locale::getFrench(), success);
 112  * \endcode
 113  * You can use a \c NumberFormat to parse also.
 114  * \code
 115  *    UErrorCode success;
 116  *    Formattable result(-999);  // initialized with error code
 117  *    nf-&gt;parse(myString, result, success);
 118  * \endcode
 119  * Use \c createInstance() to get the normal number format for a \c Locale.
 120  * There are other static factory methods available.  Use \c createCurrencyInstance()
 121  * to get the currency number format for that country.  Use \c createPercentInstance()
 122  * to get a format for displaying percentages. With this format, a
 123  * fraction from 0.53 is displayed as 53%.
 124  * &lt;P&gt;
 125  * The type of number formatting can be specified by passing a &#39;style&#39; parameter to \c createInstance().
 126  * For example, use\n
 127  * \c createInstance(locale, UNUM_DECIMAL, errorCode) to get the normal number format,\n
 128  * \c createInstance(locale, UNUM_PERCENT, errorCode) to get a format for displaying percentage,\n
 129  * \c createInstance(locale, UNUM_SCIENTIFIC, errorCode) to get a format for displaying scientific number,\n
 130  * \c createInstance(locale, UNUM_CURRENCY, errorCode) to get the currency number format,
 131  * in which the currency is represented by its symbol, for example, &quot;$3.00&quot;.\n
 132  * \c createInstance(locale, UNUM_CURRENCY_ISO, errorCode)  to get the currency number format,
 133  * in which the currency is represented by its ISO code, for example &quot;USD3.00&quot;.\n
 134  * \c createInstance(locale, UNUM_CURRENCY_PLURAL, errorCode) to get the currency number format,
 135  * in which the currency is represented by its full name in plural format,
 136  * for example, &quot;3.00 US dollars&quot; or &quot;1.00 US dollar&quot;.
 137  * &lt;P&gt;
 138  * You can also control the display of numbers with such methods as
 139  * \c getMinimumFractionDigits().  If you want even more control over the
 140  * format or parsing, or want to give your users more control, you can
 141  * try dynamic_casting the \c NumberFormat you get from the factory methods to a
 142  * \c DecimalFormat. This will work for the vast majority of
 143  * countries; just remember to test for NULL in case you
 144  * encounter an unusual one.
 145  * &lt;P&gt;
 146  * You can also use forms of the parse and format methods with
 147  * \c ParsePosition and \c FieldPosition to allow you to:
 148  * &lt;ul type=round&gt;
 149  *   &lt;li&gt;(a) progressively parse through pieces of a string.
 150  *   &lt;li&gt;(b) align the decimal point and other areas.
 151  * &lt;/ul&gt;
 152  * For example, you can align numbers in two ways.
 153  * &lt;P&gt;
 154  * If you are using a monospaced font with spacing for alignment, you
 155  * can pass the \c FieldPosition in your format call, with field =
 156  * \c UNUM_INTEGER_FIELD. On output, \c getEndIndex will be set to the offset
 157  * between the last character of the integer and the decimal. Add
 158  * (desiredSpaceCount - getEndIndex) spaces at the front of the
 159  * string.
 160  * &lt;P&gt;
 161  * If you are using proportional fonts, instead of padding with
 162  * spaces, measure the width of the string in pixels from the start to
 163  * getEndIndex.  Then move the pen by (desiredPixelWidth -
 164  * widthToAlignmentPoint) before drawing the text.  It also works
 165  * where there is no decimal, but possibly additional characters at
 166  * the end, e.g. with parentheses in negative numbers: &quot;(12)&quot; for -12.
 167  * &lt;p&gt;
 168  * &lt;em&gt;User subclasses are not supported.&lt;/em&gt; While clients may write
 169  * subclasses, such code will not necessarily work and will not be
 170  * guaranteed to work stably from release to release.
 171  *
 172  * @stable ICU 2.0
 173  */
 174 class U_I18N_API NumberFormat : public Format {
 175 public:
 176     /**
 177      * Rounding mode.
 178      *
 179      * &lt;p&gt;
 180      * For more detail on rounding modes, see:
 181      * http://userguide.icu-project.org/formatparse/numbers/rounding-modes
 182      *
 183      * @stable ICU 2.4
 184      */
 185     enum ERoundingMode {
 186         kRoundCeiling,  /**&lt; Round towards positive infinity */
 187         kRoundFloor,    /**&lt; Round towards negative infinity */
 188         kRoundDown,     /**&lt; Round towards zero */
 189         kRoundUp,       /**&lt; Round away from zero */
 190         kRoundHalfEven, /**&lt; Round towards the nearest integer, or
 191                              towards the nearest even integer if equidistant */
 192         kRoundHalfDown, /**&lt; Round towards the nearest integer, or
 193                              towards zero if equidistant */
 194         kRoundHalfUp,   /**&lt; Round towards the nearest integer, or
 195                              away from zero if equidistant */
 196         /**
 197           *  Return U_FORMAT_INEXACT_ERROR if number does not format exactly.
 198           *  @stable ICU 4.8
 199           */
 200         kRoundUnnecessary
 201     };
 202 
 203     /**
 204      * Alignment Field constants used to construct a FieldPosition object.
 205      * Signifies that the position of the integer part or fraction part of
 206      * a formatted number should be returned.
 207      *
 208      * Note: as of ICU 4.4, the values in this enum have been extended to
 209      * support identification of all number format fields, not just those
 210      * pertaining to alignment.
 211      *
 212      * These constants are provided for backwards compatibility only.
 213      * Please use the C style constants defined in the header file unum.h.
 214      *
 215      * @see FieldPosition
 216      * @stable ICU 2.0
 217      */
 218     enum EAlignmentFields {
 219         /** @stable ICU 2.0 */
 220         kIntegerField = UNUM_INTEGER_FIELD,
 221         /** @stable ICU 2.0 */
 222         kFractionField = UNUM_FRACTION_FIELD,
 223         /** @stable ICU 2.0 */
 224         kDecimalSeparatorField = UNUM_DECIMAL_SEPARATOR_FIELD,
 225         /** @stable ICU 2.0 */
 226         kExponentSymbolField = UNUM_EXPONENT_SYMBOL_FIELD,
 227         /** @stable ICU 2.0 */
 228         kExponentSignField = UNUM_EXPONENT_SIGN_FIELD,
 229         /** @stable ICU 2.0 */
 230         kExponentField = UNUM_EXPONENT_FIELD,
 231         /** @stable ICU 2.0 */
 232         kGroupingSeparatorField = UNUM_GROUPING_SEPARATOR_FIELD,
 233         /** @stable ICU 2.0 */
 234         kCurrencyField = UNUM_CURRENCY_FIELD,
 235         /** @stable ICU 2.0 */
 236         kPercentField = UNUM_PERCENT_FIELD,
 237         /** @stable ICU 2.0 */
 238         kPermillField = UNUM_PERMILL_FIELD,
 239         /** @stable ICU 2.0 */
 240         kSignField = UNUM_SIGN_FIELD,
<a name="2" id="anc2"></a>





 241 
 242     /**
 243      * These constants are provided for backwards compatibility only.
 244      * Please use the constants defined in the header file unum.h.
 245      */
 246         /** @stable ICU 2.0 */
 247         INTEGER_FIELD        = UNUM_INTEGER_FIELD,
 248         /** @stable ICU 2.0 */
 249         FRACTION_FIELD       = UNUM_FRACTION_FIELD
 250     };
 251 
 252     /**
 253      * Destructor.
 254      * @stable ICU 2.0
 255      */
 256     virtual ~NumberFormat();
 257 
 258     /**
 259      * Return true if the given Format objects are semantically equal.
 260      * Objects of different subclasses are considered unequal.
 261      * @return    true if the given Format objects are semantically equal.
 262      * @stable ICU 2.0
 263      */
 264     virtual UBool operator==(const Format&amp; other) const;
 265 
 266 
 267     using Format::format;
 268 
 269     /**
 270      * Format an object to produce a string.  This method handles
 271      * Formattable objects with numeric types. If the Formattable
 272      * object type is not a numeric type, then it returns a failing
 273      * UErrorCode.
 274      *
 275      * @param obj       The object to format.
 276      * @param appendTo  Output parameter to receive result.
 277      *                  Result is appended to existing contents.
 278      * @param pos       On input: an alignment field, if desired.
 279      *                  On output: the offsets of the alignment field.
 280      * @param status    Output param filled with success/failure status.
 281      * @return          Reference to &#39;appendTo&#39; parameter.
 282      * @stable ICU 2.0
 283      */
 284     virtual UnicodeString&amp; format(const Formattable&amp; obj,
 285                                   UnicodeString&amp; appendTo,
 286                                   FieldPosition&amp; pos,
 287                                   UErrorCode&amp; status) const;
 288 
 289     /**
 290      * Format an object to produce a string.  This method handles
 291      * Formattable objects with numeric types. If the Formattable
 292      * object type is not a numeric type, then it returns a failing
 293      * UErrorCode.
 294      *
 295      * @param obj       The object to format.
 296      * @param appendTo  Output parameter to receive result.
 297      *                  Result is appended to existing contents.
 298      * @param posIter   On return, can be used to iterate over positions
 299      *                  of fields generated by this format call.  Can be
 300      *                  NULL.
 301      * @param status    Output param filled with success/failure status.
 302      * @return          Reference to &#39;appendTo&#39; parameter.
 303      * @stable ICU 4.4
 304      */
 305     virtual UnicodeString&amp; format(const Formattable&amp; obj,
 306                                   UnicodeString&amp; appendTo,
 307                                   FieldPositionIterator* posIter,
 308                                   UErrorCode&amp; status) const;
 309 
 310     /**
 311      * Parse a string to produce an object.  This methods handles
 312      * parsing of numeric strings into Formattable objects with numeric
 313      * types.
 314      * &lt;P&gt;
 315      * Before calling, set parse_pos.index to the offset you want to
 316      * start parsing at in the source. After calling, parse_pos.index
 317      * indicates the position after the successfully parsed text.  If
 318      * an error occurs, parse_pos.index is unchanged.
 319      * &lt;P&gt;
 320      * When parsing, leading whitespace is discarded (with successful
 321      * parse), while trailing whitespace is left as is.
 322      * &lt;P&gt;
 323      * See Format::parseObject() for more.
 324      *
 325      * @param source    The string to be parsed into an object.
 326      * @param result    Formattable to be set to the parse result.
 327      *                  If parse fails, return contents are undefined.
 328      * @param parse_pos The position to start parsing at. Upon return
 329      *                  this param is set to the position after the
 330      *                  last character successfully parsed. If the
 331      *                  source is not parsed successfully, this param
 332      *                  will remain unchanged.
 333      * @return          A newly created Formattable* object, or NULL
 334      *                  on failure.  The caller owns this and should
 335      *                  delete it when done.
 336      * @stable ICU 2.0
 337      */
 338     virtual void parseObject(const UnicodeString&amp; source,
 339                              Formattable&amp; result,
 340                              ParsePosition&amp; parse_pos) const;
 341 
 342     /**
 343      * Format a double number. These methods call the NumberFormat
 344      * pure virtual format() methods with the default FieldPosition.
 345      *
 346      * @param number    The value to be formatted.
 347      * @param appendTo  Output parameter to receive result.
 348      *                  Result is appended to existing contents.
 349      * @return          Reference to &#39;appendTo&#39; parameter.
 350      * @stable ICU 2.0
 351      */
 352     UnicodeString&amp; format(  double number,
 353                             UnicodeString&amp; appendTo) const;
 354 
 355     /**
 356      * Format a long number. These methods call the NumberFormat
 357      * pure virtual format() methods with the default FieldPosition.
 358      *
 359      * @param number    The value to be formatted.
 360      * @param appendTo  Output parameter to receive result.
 361      *                  Result is appended to existing contents.
 362      * @return          Reference to &#39;appendTo&#39; parameter.
 363      * @stable ICU 2.0
 364      */
 365     UnicodeString&amp; format(  int32_t number,
 366                             UnicodeString&amp; appendTo) const;
 367 
 368     /**
 369      * Format an int64 number. These methods call the NumberFormat
 370      * pure virtual format() methods with the default FieldPosition.
 371      *
 372      * @param number    The value to be formatted.
 373      * @param appendTo  Output parameter to receive result.
 374      *                  Result is appended to existing contents.
 375      * @return          Reference to &#39;appendTo&#39; parameter.
 376      * @stable ICU 2.8
 377      */
 378     UnicodeString&amp; format(  int64_t number,
 379                             UnicodeString&amp; appendTo) const;
 380 
 381     /**
 382      * Format a double number. Concrete subclasses must implement
 383      * these pure virtual methods.
 384      *
 385      * @param number    The value to be formatted.
 386      * @param appendTo  Output parameter to receive result.
 387      *                  Result is appended to existing contents.
 388      * @param pos       On input: an alignment field, if desired.
 389      *                  On output: the offsets of the alignment field.
 390      * @return          Reference to &#39;appendTo&#39; parameter.
 391      * @stable ICU 2.0
 392      */
 393     virtual UnicodeString&amp; format(double number,
 394                                   UnicodeString&amp; appendTo,
 395                                   FieldPosition&amp; pos) const = 0;
 396     /**
 397      * Format a double number. By default, the parent function simply
 398      * calls the base class and does not return an error status.
 399      * Therefore, the status may be ignored in some subclasses.
 400      *
 401      * @param number    The value to be formatted.
 402      * @param appendTo  Output parameter to receive result.
 403      *                  Result is appended to existing contents.
 404      * @param pos       On input: an alignment field, if desired.
 405      *                  On output: the offsets of the alignment field.
 406      * @param status    error status
 407      * @return          Reference to &#39;appendTo&#39; parameter.
 408      * @internal
 409      */
 410     virtual UnicodeString&amp; format(double number,
 411                                   UnicodeString&amp; appendTo,
 412                                   FieldPosition&amp; pos,
 413                                   UErrorCode &amp;status) const;
 414     /**
 415      * Format a double number. Subclasses must implement
 416      * this method.
 417      *
 418      * @param number    The value to be formatted.
 419      * @param appendTo  Output parameter to receive result.
 420      *                  Result is appended to existing contents.
 421      * @param posIter   On return, can be used to iterate over positions
 422      *                  of fields generated by this format call.
 423      *                  Can be NULL.
 424      * @param status    Output param filled with success/failure status.
 425      * @return          Reference to &#39;appendTo&#39; parameter.
 426      * @stable ICU 4.4
 427      */
 428     virtual UnicodeString&amp; format(double number,
 429                                   UnicodeString&amp; appendTo,
 430                                   FieldPositionIterator* posIter,
 431                                   UErrorCode&amp; status) const;
 432     /**
 433      * Format a long number. Concrete subclasses must implement
 434      * these pure virtual methods.
 435      *
 436      * @param number    The value to be formatted.
 437      * @param appendTo  Output parameter to receive result.
 438      *                  Result is appended to existing contents.
 439      * @param pos       On input: an alignment field, if desired.
 440      *                  On output: the offsets of the alignment field.
 441      * @return          Reference to &#39;appendTo&#39; parameter.
 442      * @stable ICU 2.0
 443     */
 444     virtual UnicodeString&amp; format(int32_t number,
 445                                   UnicodeString&amp; appendTo,
 446                                   FieldPosition&amp; pos) const = 0;
 447 
 448     /**
 449      * Format a long number. Concrete subclasses may override
 450      * this function to provide status return.
 451      *
 452      * @param number    The value to be formatted.
 453      * @param appendTo  Output parameter to receive result.
 454      *                  Result is appended to existing contents.
 455      * @param pos       On input: an alignment field, if desired.
 456      *                  On output: the offsets of the alignment field.
 457      * @param status the output status.
 458      * @return          Reference to &#39;appendTo&#39; parameter.
 459      * @internal
 460     */
 461     virtual UnicodeString&amp; format(int32_t number,
 462                                   UnicodeString&amp; appendTo,
 463                                   FieldPosition&amp; pos,
 464                                   UErrorCode &amp;status) const;
 465 
 466     /**
 467      * Format an int32 number. Subclasses must implement
 468      * this method.
 469      *
 470      * @param number    The value to be formatted.
 471      * @param appendTo  Output parameter to receive result.
 472      *                  Result is appended to existing contents.
 473      * @param posIter   On return, can be used to iterate over positions
 474      *                  of fields generated by this format call.
 475      *                  Can be NULL.
 476      * @param status    Output param filled with success/failure status.
 477      * @return          Reference to &#39;appendTo&#39; parameter.
 478      * @stable ICU 4.4
 479      */
 480     virtual UnicodeString&amp; format(int32_t number,
 481                                   UnicodeString&amp; appendTo,
 482                                   FieldPositionIterator* posIter,
 483                                   UErrorCode&amp; status) const;
 484     /**
 485      * Format an int64 number. (Not abstract to retain compatibility
 486      * with earlier releases, however subclasses should override this
 487      * method as it just delegates to format(int32_t number...);
 488      *
 489      * @param number    The value to be formatted.
 490      * @param appendTo  Output parameter to receive result.
 491      *                  Result is appended to existing contents.
 492      * @param pos       On input: an alignment field, if desired.
 493      *                  On output: the offsets of the alignment field.
 494      * @return          Reference to &#39;appendTo&#39; parameter.
 495      * @stable ICU 2.8
 496     */
 497     virtual UnicodeString&amp; format(int64_t number,
 498                                   UnicodeString&amp; appendTo,
 499                                   FieldPosition&amp; pos) const;
 500 
 501     /**
 502      * Format an int64 number. (Not abstract to retain compatibility
 503      * with earlier releases, however subclasses should override this
 504      * method as it just delegates to format(int32_t number...);
 505      *
 506      * @param number    The value to be formatted.
 507      * @param appendTo  Output parameter to receive result.
 508      *                  Result is appended to existing contents.
 509      * @param pos       On input: an alignment field, if desired.
 510      *                  On output: the offsets of the alignment field.
 511      * @param status    Output param filled with success/failure status.
 512      * @return          Reference to &#39;appendTo&#39; parameter.
 513      * @internal
 514     */
 515     virtual UnicodeString&amp; format(int64_t number,
 516                                   UnicodeString&amp; appendTo,
 517                                   FieldPosition&amp; pos,
 518                                   UErrorCode&amp; status) const;
 519     /**
 520      * Format an int64 number. Subclasses must implement
 521      * this method.
 522      *
 523      * @param number    The value to be formatted.
 524      * @param appendTo  Output parameter to receive result.
 525      *                  Result is appended to existing contents.
 526      * @param posIter   On return, can be used to iterate over positions
 527      *                  of fields generated by this format call.
 528      *                  Can be NULL.
 529      * @param status    Output param filled with success/failure status.
 530      * @return          Reference to &#39;appendTo&#39; parameter.
 531      * @stable ICU 4.4
 532      */
 533     virtual UnicodeString&amp; format(int64_t number,
 534                                   UnicodeString&amp; appendTo,
 535                                   FieldPositionIterator* posIter,
 536                                   UErrorCode&amp; status) const;
 537 
 538     /**
 539      * Format a decimal number. Subclasses must implement
 540      * this method.  The syntax of the unformatted number is a &quot;numeric string&quot;
 541      * as defined in the Decimal Arithmetic Specification, available at
 542      * http://speleotrove.com/decimal
 543      *
 544      * @param number    The unformatted number, as a string, to be formatted.
 545      * @param appendTo  Output parameter to receive result.
 546      *                  Result is appended to existing contents.
 547      * @param posIter   On return, can be used to iterate over positions
 548      *                  of fields generated by this format call.
 549      *                  Can be NULL.
 550      * @param status    Output param filled with success/failure status.
 551      * @return          Reference to &#39;appendTo&#39; parameter.
 552      * @stable ICU 4.4
 553      */
 554     virtual UnicodeString&amp; format(StringPiece number,
 555                                   UnicodeString&amp; appendTo,
 556                                   FieldPositionIterator* posIter,
 557                                   UErrorCode&amp; status) const;
 558 
 559 // Can&#39;t use #ifndef U_HIDE_INTERNAL_API because these are virtual methods
 560 
 561     /**
 562      * Format a decimal number.
 563      * The number is a DecimalQuantity wrapper onto a floating point decimal number.
 564      * The default implementation in NumberFormat converts the decimal number
 565      * to a double and formats that.  Subclasses of NumberFormat that want
 566      * to specifically handle big decimal numbers must override this method.
 567      * class DecimalFormat does so.
 568      *
 569      * @param number    The number, a DecimalQuantity format Decimal Floating Point.
 570      * @param appendTo  Output parameter to receive result.
 571      *                  Result is appended to existing contents.
 572      * @param posIter   On return, can be used to iterate over positions
 573      *                  of fields generated by this format call.
 574      * @param status    Output param filled with success/failure status.
 575      * @return          Reference to &#39;appendTo&#39; parameter.
 576      * @internal
 577      */
 578     virtual UnicodeString&amp; format(const number::impl::DecimalQuantity &amp;number,
 579                                   UnicodeString&amp; appendTo,
 580                                   FieldPositionIterator* posIter,
 581                                   UErrorCode&amp; status) const;
 582 
 583     /**
 584      * Format a decimal number.
 585      * The number is a DecimalQuantity wrapper onto a floating point decimal number.
 586      * The default implementation in NumberFormat converts the decimal number
 587      * to a double and formats that.  Subclasses of NumberFormat that want
 588      * to specifically handle big decimal numbers must override this method.
 589      * class DecimalFormat does so.
 590      *
 591      * @param number    The number, a DecimalQuantity format Decimal Floating Point.
 592      * @param appendTo  Output parameter to receive result.
 593      *                  Result is appended to existing contents.
 594      * @param pos       On input: an alignment field, if desired.
 595      *                  On output: the offsets of the alignment field.
 596      * @param status    Output param filled with success/failure status.
 597      * @return          Reference to &#39;appendTo&#39; parameter.
 598      * @internal
 599      */
 600     virtual UnicodeString&amp; format(const number::impl::DecimalQuantity &amp;number,
 601                                   UnicodeString&amp; appendTo,
 602                                   FieldPosition&amp; pos,
 603                                   UErrorCode&amp; status) const;
 604 
 605    /**
 606     * Return a long if possible (e.g. within range LONG_MAX,
 607     * LONG_MAX], and with no decimals), otherwise a double.  If
 608     * IntegerOnly is set, will stop at a decimal point (or equivalent;
 609     * e.g. for rational numbers &quot;1 2/3&quot;, will stop after the 1).
 610     * &lt;P&gt;
 611     * If no object can be parsed, index is unchanged, and NULL is
 612     * returned.
 613     * &lt;P&gt;
 614     * This is a pure virtual which concrete subclasses must implement.
 615     *
 616     * @param text           The text to be parsed.
 617     * @param result         Formattable to be set to the parse result.
 618     *                       If parse fails, return contents are undefined.
 619     * @param parsePosition  The position to start parsing at on input.
 620     *                       On output, moved to after the last successfully
 621     *                       parse character. On parse failure, does not change.
 622     * @stable ICU 2.0
 623     */
 624     virtual void parse(const UnicodeString&amp; text,
 625                        Formattable&amp; result,
 626                        ParsePosition&amp; parsePosition) const = 0;
 627 
 628     /**
 629      * Parse a string as a numeric value, and return a Formattable
 630      * numeric object. This method parses integers only if IntegerOnly
 631      * is set.
 632      *
 633      * @param text          The text to be parsed.
 634      * @param result        Formattable to be set to the parse result.
 635      *                      If parse fails, return contents are undefined.
 636      * @param status        Output parameter set to a failure error code
 637      *                      when a failure occurs.
 638      * @see                 NumberFormat::isParseIntegerOnly
 639      * @stable ICU 2.0
 640      */
 641     virtual void parse(const UnicodeString&amp; text,
 642                        Formattable&amp; result,
 643                        UErrorCode&amp; status) const;
 644 
 645     /**
 646      * Parses text from the given string as a currency amount.  Unlike
 647      * the parse() method, this method will attempt to parse a generic
 648      * currency name, searching for a match of this object&#39;s locale&#39;s
 649      * currency display names, or for a 3-letter ISO currency code.
 650      * This method will fail if this format is not a currency format,
 651      * that is, if it does not contain the currency pattern symbol
 652      * (U+00A4) in its prefix or suffix.
 653      *
 654      * @param text the string to parse
 655      * @param pos  input-output position; on input, the position within text
 656      *             to match; must have 0 &lt;= pos.getIndex() &lt; text.length();
 657      *             on output, the position after the last matched character.
 658      *             If the parse fails, the position in unchanged upon output.
 659      * @return     if parse succeeds, a pointer to a newly-created CurrencyAmount
 660      *             object (owned by the caller) containing information about
 661      *             the parsed currency; if parse fails, this is NULL.
 662      * @stable ICU 49
 663      */
 664     virtual CurrencyAmount* parseCurrency(const UnicodeString&amp; text,
 665                                           ParsePosition&amp; pos) const;
 666 
 667     /**
 668      * Return true if this format will parse numbers as integers
 669      * only.  For example in the English locale, with ParseIntegerOnly
 670      * true, the string &quot;1234.&quot; would be parsed as the integer value
 671      * 1234 and parsing would stop at the &quot;.&quot; character.  Of course,
 672      * the exact format accepted by the parse operation is locale
 673      * dependant and determined by sub-classes of NumberFormat.
 674      * @return    true if this format will parse numbers as integers
 675      *            only.
 676      * @stable ICU 2.0
 677      */
 678     UBool isParseIntegerOnly(void) const;
 679 
 680     /**
 681      * Sets whether or not numbers should be parsed as integers only.
 682      * @param value    set True, this format will parse numbers as integers
 683      *                 only.
 684      * @see isParseIntegerOnly
 685      * @stable ICU 2.0
 686      */
 687     virtual void setParseIntegerOnly(UBool value);
 688 
 689     /**
 690      * Sets whether lenient parsing should be enabled (it is off by default).
 691      *
 692      * @param enable \c TRUE if lenient parsing should be used,
 693      *               \c FALSE otherwise.
 694      * @stable ICU 4.8
 695      */
 696     virtual void setLenient(UBool enable);
 697 
 698     /**
 699      * Returns whether lenient parsing is enabled (it is off by default).
 700      *
 701      * @return \c TRUE if lenient parsing is enabled,
 702      *         \c FALSE otherwise.
 703      * @see #setLenient
 704      * @stable ICU 4.8
 705      */
 706     virtual UBool isLenient(void) const;
 707 
 708     /**
 709      * Create a default style NumberFormat for the current default locale.
 710      * The default formatting style is locale dependent.
 711      * &lt;p&gt;
 712      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="3" id="anc3"></a><span class="line-modified"> 713      * {@link NumberFormatter} instead of NumberFormat.</span>
 714      * @stable ICU 2.0
 715      */
 716     static NumberFormat* U_EXPORT2 createInstance(UErrorCode&amp;);
 717 
 718     /**
 719      * Create a default style NumberFormat for the specified locale.
 720      * The default formatting style is locale dependent.
 721      * @param inLocale    the given locale.
 722      * &lt;p&gt;
 723      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="4" id="anc4"></a><span class="line-modified"> 724      * {@link NumberFormatter} instead of NumberFormat.</span>
 725      * @stable ICU 2.0
 726      */
 727     static NumberFormat* U_EXPORT2 createInstance(const Locale&amp; inLocale,
 728                                         UErrorCode&amp;);
 729 
 730     /**
 731      * Create a specific style NumberFormat for the specified locale.
 732      * &lt;p&gt;
 733      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="5" id="anc5"></a><span class="line-modified"> 734      * {@link NumberFormatter} instead of NumberFormat.</span>
 735      * @param desiredLocale    the given locale.
 736      * @param style            the given style.
 737      * @param errorCode        Output param filled with success/failure status.
 738      * @return                 A new NumberFormat instance.
 739      * @stable ICU 4.8
 740      */
 741     static NumberFormat* U_EXPORT2 createInstance(const Locale&amp; desiredLocale,
 742                                                   UNumberFormatStyle style,
 743                                                   UErrorCode&amp; errorCode);
 744 
 745 #ifndef U_HIDE_INTERNAL_API
 746 
 747     /**
 748      * ICU use only.
 749      * Creates NumberFormat instance without using the cache.
 750      * @internal
 751      */
 752     static NumberFormat* internalCreateInstance(
 753             const Locale&amp; desiredLocale,
 754             UNumberFormatStyle style,
 755             UErrorCode&amp; errorCode);
 756 
 757     /**
 758      * ICU use only.
 759      * Returns handle to the shared, cached NumberFormat instance for given
 760      * locale. On success, caller must call removeRef() on returned value
 761      * once it is done with the shared instance.
 762      * @internal
 763      */
 764     static const SharedNumberFormat* U_EXPORT2 createSharedInstance(
 765             const Locale&amp; inLocale, UNumberFormatStyle style, UErrorCode&amp; status);
 766 
 767 #endif  /* U_HIDE_INTERNAL_API */
 768 
 769     /**
 770      * Returns a currency format for the current default locale.
 771      * &lt;p&gt;
 772      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="6" id="anc6"></a><span class="line-modified"> 773      * {@link NumberFormatter} instead of NumberFormat.</span>
 774      * @stable ICU 2.0
 775      */
 776     static NumberFormat* U_EXPORT2 createCurrencyInstance(UErrorCode&amp;);
 777 
 778     /**
 779      * Returns a currency format for the specified locale.
 780      * &lt;p&gt;
 781      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="7" id="anc7"></a><span class="line-modified"> 782      * {@link NumberFormatter} instead of NumberFormat.</span>
 783      * @param inLocale    the given locale.
 784      * @stable ICU 2.0
 785      */
 786     static NumberFormat* U_EXPORT2 createCurrencyInstance(const Locale&amp; inLocale,
 787                                                 UErrorCode&amp;);
 788 
 789     /**
 790      * Returns a percentage format for the current default locale.
 791      * &lt;p&gt;
 792      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="8" id="anc8"></a><span class="line-modified"> 793      * {@link NumberFormatter} instead of NumberFormat.</span>
 794      * @stable ICU 2.0
 795      */
 796     static NumberFormat* U_EXPORT2 createPercentInstance(UErrorCode&amp;);
 797 
 798     /**
 799      * Returns a percentage format for the specified locale.
 800      * &lt;p&gt;
 801      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="9" id="anc9"></a><span class="line-modified"> 802      * {@link NumberFormatter} instead of NumberFormat.</span>
 803      * @param inLocale    the given locale.
 804      * @stable ICU 2.0
 805      */
 806     static NumberFormat* U_EXPORT2 createPercentInstance(const Locale&amp; inLocale,
 807                                                UErrorCode&amp;);
 808 
 809     /**
 810      * Returns a scientific format for the current default locale.
 811      * &lt;p&gt;
 812      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="10" id="anc10"></a><span class="line-modified"> 813      * {@link NumberFormatter} instead of NumberFormat.</span>
 814      * @stable ICU 2.0
 815      */
 816     static NumberFormat* U_EXPORT2 createScientificInstance(UErrorCode&amp;);
 817 
 818     /**
 819      * Returns a scientific format for the specified locale.
 820      * &lt;p&gt;
 821      * &lt;strong&gt;NOTE:&lt;/strong&gt; New users are strongly encouraged to use
<a name="11" id="anc11"></a><span class="line-modified"> 822      * {@link NumberFormatter} instead of NumberFormat.</span>
 823      * @param inLocale    the given locale.
 824      * @stable ICU 2.0
 825      */
 826     static NumberFormat* U_EXPORT2 createScientificInstance(const Locale&amp; inLocale,
 827                                                 UErrorCode&amp;);
 828 
 829     /**
 830      * Get the set of Locales for which NumberFormats are installed.
 831      * @param count    Output param to receive the size of the locales
 832      * @stable ICU 2.0
 833      */
 834     static const Locale* U_EXPORT2 getAvailableLocales(int32_t&amp; count);
 835 
 836 #if !UCONFIG_NO_SERVICE
 837     /**
 838      * Register a new NumberFormatFactory.  The factory will be adopted.
 839      * Because ICU may choose to cache NumberFormat objects internally,
 840      * this must be called at application startup, prior to any calls to
 841      * NumberFormat::createInstance to avoid undefined behavior.
 842      * @param toAdopt the NumberFormatFactory instance to be adopted
 843      * @param status the in/out status code, no special meanings are assigned
 844      * @return a registry key that can be used to unregister this factory
 845      * @stable ICU 2.6
 846      */
 847     static URegistryKey U_EXPORT2 registerFactory(NumberFormatFactory* toAdopt, UErrorCode&amp; status);
 848 
 849     /**
 850      * Unregister a previously-registered NumberFormatFactory using the key returned from the
 851      * register call.  Key becomes invalid after a successful call and should not be used again.
 852      * The NumberFormatFactory corresponding to the key will be deleted.
 853      * Because ICU may choose to cache NumberFormat objects internally,
 854      * this should be called during application shutdown, after all calls to
 855      * NumberFormat::createInstance to avoid undefined behavior.
 856      * @param key the registry key returned by a previous call to registerFactory
 857      * @param status the in/out status code, no special meanings are assigned
 858      * @return TRUE if the factory for the key was successfully unregistered
 859      * @stable ICU 2.6
 860      */
 861     static UBool U_EXPORT2 unregister(URegistryKey key, UErrorCode&amp; status);
 862 
 863     /**
 864      * Return a StringEnumeration over the locales available at the time of the call,
 865      * including registered locales.
 866      * @return a StringEnumeration over the locales available at the time of the call
 867      * @stable ICU 2.6
 868      */
 869     static StringEnumeration* U_EXPORT2 getAvailableLocales(void);
 870 #endif /* UCONFIG_NO_SERVICE */
 871 
 872     /**
 873      * Returns true if grouping is used in this format. For example,
 874      * in the English locale, with grouping on, the number 1234567
 875      * might be formatted as &quot;1,234,567&quot;. The grouping separator as
 876      * well as the size of each group is locale dependent and is
 877      * determined by sub-classes of NumberFormat.
 878      * @see setGroupingUsed
 879      * @stable ICU 2.0
 880      */
 881     UBool isGroupingUsed(void) const;
 882 
 883     /**
 884      * Set whether or not grouping will be used in this format.
 885      * @param newValue    True, grouping will be used in this format.
 886      * @see getGroupingUsed
 887      * @stable ICU 2.0
 888      */
 889     virtual void setGroupingUsed(UBool newValue);
 890 
 891     /**
 892      * Returns the maximum number of digits allowed in the integer portion of a
 893      * number.
 894      * @return     the maximum number of digits allowed in the integer portion of a
 895      *             number.
 896      * @see setMaximumIntegerDigits
 897      * @stable ICU 2.0
 898      */
 899     int32_t getMaximumIntegerDigits(void) const;
 900 
 901     /**
 902      * Sets the maximum number of digits allowed in the integer portion of a
 903      * number. maximumIntegerDigits must be &gt;= minimumIntegerDigits.  If the
 904      * new value for maximumIntegerDigits is less than the current value
 905      * of minimumIntegerDigits, then minimumIntegerDigits will also be set to
 906      * the new value.
 907      *
 908      * @param newValue    the new value for the maximum number of digits
 909      *                    allowed in the integer portion of a number.
 910      * @see getMaximumIntegerDigits
 911      * @stable ICU 2.0
 912      */
 913     virtual void setMaximumIntegerDigits(int32_t newValue);
 914 
 915     /**
 916      * Returns the minimum number of digits allowed in the integer portion of a
 917      * number.
 918      * @return    the minimum number of digits allowed in the integer portion of a
 919      *            number.
 920      * @see setMinimumIntegerDigits
 921      * @stable ICU 2.0
 922      */
 923     int32_t getMinimumIntegerDigits(void) const;
 924 
 925     /**
 926      * Sets the minimum number of digits allowed in the integer portion of a
 927      * number. minimumIntegerDigits must be &amp;lt;= maximumIntegerDigits.  If the
 928      * new value for minimumIntegerDigits exceeds the current value
 929      * of maximumIntegerDigits, then maximumIntegerDigits will also be set to
 930      * the new value.
 931      * @param newValue    the new value to be set.
 932      * @see getMinimumIntegerDigits
 933      * @stable ICU 2.0
 934      */
 935     virtual void setMinimumIntegerDigits(int32_t newValue);
 936 
 937     /**
 938      * Returns the maximum number of digits allowed in the fraction portion of a
 939      * number.
 940      * @return    the maximum number of digits allowed in the fraction portion of a
 941      *            number.
 942      * @see setMaximumFractionDigits
 943      * @stable ICU 2.0
 944      */
 945     int32_t getMaximumFractionDigits(void) const;
 946 
 947     /**
 948      * Sets the maximum number of digits allowed in the fraction portion of a
 949      * number. maximumFractionDigits must be &gt;= minimumFractionDigits.  If the
 950      * new value for maximumFractionDigits is less than the current value
 951      * of minimumFractionDigits, then minimumFractionDigits will also be set to
 952      * the new value.
 953      * @param newValue    the new value to be set.
 954      * @see getMaximumFractionDigits
 955      * @stable ICU 2.0
 956      */
 957     virtual void setMaximumFractionDigits(int32_t newValue);
 958 
 959     /**
 960      * Returns the minimum number of digits allowed in the fraction portion of a
 961      * number.
 962      * @return    the minimum number of digits allowed in the fraction portion of a
 963      *            number.
 964      * @see setMinimumFractionDigits
 965      * @stable ICU 2.0
 966      */
 967     int32_t getMinimumFractionDigits(void) const;
 968 
 969     /**
 970      * Sets the minimum number of digits allowed in the fraction portion of a
 971      * number. minimumFractionDigits must be &amp;lt;= maximumFractionDigits.   If the
 972      * new value for minimumFractionDigits exceeds the current value
 973      * of maximumFractionDigits, then maximumIntegerDigits will also be set to
 974      * the new value
 975      * @param newValue    the new value to be set.
 976      * @see getMinimumFractionDigits
 977      * @stable ICU 2.0
 978      */
 979     virtual void setMinimumFractionDigits(int32_t newValue);
 980 
 981     /**
 982      * Sets the currency used to display currency
 983      * amounts.  This takes effect immediately, if this format is a
 984      * currency format.  If this format is not a currency format, then
 985      * the currency is used if and when this object becomes a
 986      * currency format.
 987      * @param theCurrency a 3-letter ISO code indicating new currency
 988      * to use.  It need not be null-terminated.  May be the empty
 989      * string or NULL to indicate no currency.
 990      * @param ec input-output error code
 991      * @stable ICU 3.0
 992      */
 993     virtual void setCurrency(const char16_t* theCurrency, UErrorCode&amp; ec);
 994 
 995     /**
 996      * Gets the currency used to display currency
 997      * amounts.  This may be an empty string for some subclasses.
 998      * @return a 3-letter null-terminated ISO code indicating
 999      * the currency in use, or a pointer to the empty string.
1000      * @stable ICU 2.6
1001      */
1002     const char16_t* getCurrency() const;
1003 
1004     /**
1005      * Set a particular UDisplayContext value in the formatter, such as
1006      * UDISPCTX_CAPITALIZATION_FOR_STANDALONE.
1007      * @param value The UDisplayContext value to set.
1008      * @param status Input/output status. If at entry this indicates a failure
1009      *               status, the function will do nothing; otherwise this will be
1010      *               updated with any new status from the function.
1011      * @stable ICU 53
1012      */
1013     virtual void setContext(UDisplayContext value, UErrorCode&amp; status);
1014 
1015     /**
1016      * Get the formatter&#39;s UDisplayContext value for the specified UDisplayContextType,
1017      * such as UDISPCTX_TYPE_CAPITALIZATION.
1018      * @param type The UDisplayContextType whose value to return
1019      * @param status Input/output status. If at entry this indicates a failure
1020      *               status, the function will do nothing; otherwise this will be
1021      *               updated with any new status from the function.
1022      * @return The UDisplayContextValue for the specified type.
1023      * @stable ICU 53
1024      */
1025     virtual UDisplayContext getContext(UDisplayContextType type, UErrorCode&amp; status) const;
1026 
1027     /**
1028      * Get the rounding mode. This will always return NumberFormat::ERoundingMode::kRoundUnnecessary
1029      * if the subclass does not support rounding.
1030      * @return A rounding mode
<a name="12" id="anc12"></a><span class="line-modified">1031      * @draft ICU 60</span>
1032      */
1033     virtual ERoundingMode getRoundingMode(void) const;
1034 
1035     /**
1036      * Set the rounding mode. If a subclass does not support rounding, this will do nothing.
1037      * @param roundingMode A rounding mode
<a name="13" id="anc13"></a><span class="line-modified">1038      * @draft ICU 60</span>
1039      */
1040     virtual void setRoundingMode(ERoundingMode roundingMode);
1041 
1042 public:
1043 
1044     /**
1045      * Return the class ID for this class.  This is useful for
1046      * comparing to a return value from getDynamicClassID(). Note that,
1047      * because NumberFormat is an abstract base class, no fully constructed object
1048      * will have the class ID returned by NumberFormat::getStaticClassID().
1049      * @return The class ID for all objects of this class.
1050      * @stable ICU 2.0
1051      */
1052     static UClassID U_EXPORT2 getStaticClassID(void);
1053 
1054     /**
1055      * Returns a unique class ID POLYMORPHICALLY.  Pure virtual override.
1056      * This method is to implement a simple version of RTTI, since not all
1057      * C++ compilers support genuine RTTI.  Polymorphic operator==() and
1058      * clone() methods call this method.
1059      * &lt;P&gt;
1060      * @return The class ID for this object. All objects of a
1061      * given class have the same class ID.  Objects of
1062      * other classes have different class IDs.
1063      * @stable ICU 2.0
1064      */
1065     virtual UClassID getDynamicClassID(void) const = 0;
1066 
1067 protected:
1068 
1069     /**
1070      * Default constructor for subclass use only.
1071      * @stable ICU 2.0
1072      */
1073     NumberFormat();
1074 
1075     /**
1076      * Copy constructor.
1077      * @stable ICU 2.0
1078      */
1079     NumberFormat(const NumberFormat&amp;);
1080 
1081     /**
1082      * Assignment operator.
1083      * @stable ICU 2.0
1084      */
1085     NumberFormat&amp; operator=(const NumberFormat&amp;);
1086 
1087     /**
1088      * Returns the currency in effect for this formatter.  Subclasses
1089      * should override this method as needed.  Unlike getCurrency(),
1090      * this method should never return &quot;&quot;.
1091      * @result output parameter for null-terminated result, which must
1092      * have a capacity of at least 4
1093      * @internal
1094      */
1095     virtual void getEffectiveCurrency(char16_t* result, UErrorCode&amp; ec) const;
1096 
1097 #ifndef U_HIDE_INTERNAL_API
1098     /**
1099      * Creates the specified number format style of the desired locale.
1100      * If mustBeDecimalFormat is TRUE, then the returned pointer is
1101      * either a DecimalFormat or it is NULL.
1102      * @internal
1103      */
1104     static NumberFormat* makeInstance(const Locale&amp; desiredLocale,
1105                                       UNumberFormatStyle style,
1106                                       UBool mustBeDecimalFormat,
1107                                       UErrorCode&amp; errorCode);
1108 #endif  /* U_HIDE_INTERNAL_API */
1109 
1110 private:
1111 
1112     static UBool isStyleSupported(UNumberFormatStyle style);
1113 
1114     /**
1115      * Creates the specified decimal format style of the desired locale.
1116      * @param desiredLocale    the given locale.
1117      * @param style            the given style.
1118      * @param errorCode        Output param filled with success/failure status.
1119      * @return                 A new NumberFormat instance.
1120      */
1121     static NumberFormat* makeInstance(const Locale&amp; desiredLocale,
1122                                       UNumberFormatStyle style,
1123                                       UErrorCode&amp; errorCode);
1124 
1125     UBool       fGroupingUsed;
1126     int32_t     fMaxIntegerDigits;
1127     int32_t     fMinIntegerDigits;
1128     int32_t     fMaxFractionDigits;
1129     int32_t     fMinFractionDigits;
1130 
1131   protected:
1132     /** \internal */
1133     static const int32_t gDefaultMaxIntegerDigits;
1134     /** \internal */
1135     static const int32_t gDefaultMinIntegerDigits;
1136 
1137   private:
1138     UBool      fParseIntegerOnly;
1139     UBool      fLenient; // TRUE =&gt; lenient parse is enabled
1140 
1141     // ISO currency code
1142     char16_t      fCurrency[4];
1143 
1144     UDisplayContext fCapitalizationContext;
1145 
1146     friend class ICUNumberFormatFactory; // access to makeInstance
1147     friend class ICUNumberFormatService;
1148     friend class ::NumberFormatTest;  // access to isStyleSupported()
1149 };
1150 
1151 #if !UCONFIG_NO_SERVICE
1152 /**
1153  * A NumberFormatFactory is used to register new number formats.  The factory
1154  * should be able to create any of the predefined formats for each locale it
1155  * supports.  When registered, the locales it supports extend or override the
1156  * locale already supported by ICU.
1157  *
1158  * @stable ICU 2.6
1159  */
1160 class U_I18N_API NumberFormatFactory : public UObject {
1161 public:
1162 
1163     /**
1164      * Destructor
1165      * @stable ICU 3.0
1166      */
1167     virtual ~NumberFormatFactory();
1168 
1169     /**
1170      * Return true if this factory will be visible.  Default is true.
1171      * If not visible, the locales supported by this factory will not
1172      * be listed by getAvailableLocales.
1173      * @stable ICU 2.6
1174      */
1175     virtual UBool visible(void) const = 0;
1176 
1177     /**
1178      * Return the locale names directly supported by this factory.  The number of names
1179      * is returned in count;
1180      * @stable ICU 2.6
1181      */
1182     virtual const UnicodeString * getSupportedIDs(int32_t &amp;count, UErrorCode&amp; status) const = 0;
1183 
1184     /**
1185      * Return a number format of the appropriate type.  If the locale
1186      * is not supported, return null.  If the locale is supported, but
1187      * the type is not provided by this service, return null.  Otherwise
1188      * return an appropriate instance of NumberFormat.
1189      * @stable ICU 2.6
1190      */
1191     virtual NumberFormat* createFormat(const Locale&amp; loc, UNumberFormatStyle formatType) = 0;
1192 };
1193 
1194 /**
1195  * A NumberFormatFactory that supports a single locale.  It can be visible or invisible.
1196  * @stable ICU 2.6
1197  */
1198 class U_I18N_API SimpleNumberFormatFactory : public NumberFormatFactory {
1199 protected:
1200     /**
1201      * True if the locale supported by this factory is visible.
1202      * @stable ICU 2.6
1203      */
1204     const UBool _visible;
1205 
1206     /**
1207      * The locale supported by this factory, as a UnicodeString.
1208      * @stable ICU 2.6
1209      */
1210     UnicodeString _id;
1211 
1212 public:
1213     /**
1214      * @stable ICU 2.6
1215      */
1216     SimpleNumberFormatFactory(const Locale&amp; locale, UBool visible = TRUE);
1217 
1218     /**
1219      * @stable ICU 3.0
1220      */
1221     virtual ~SimpleNumberFormatFactory();
1222 
1223     /**
1224      * @stable ICU 2.6
1225      */
1226     virtual UBool visible(void) const;
1227 
1228     /**
1229      * @stable ICU 2.6
1230      */
1231     virtual const UnicodeString * getSupportedIDs(int32_t &amp;count, UErrorCode&amp; status) const;
1232 };
1233 #endif /* #if !UCONFIG_NO_SERVICE */
1234 
1235 // -------------------------------------
1236 
1237 inline UBool
1238 NumberFormat::isParseIntegerOnly() const
1239 {
1240     return fParseIntegerOnly;
1241 }
1242 
1243 inline UBool
1244 NumberFormat::isLenient() const
1245 {
1246     return fLenient;
1247 }
1248 
1249 U_NAMESPACE_END
1250 
1251 #endif /* #if !UCONFIG_NO_FORMATTING */
1252 
1253 #endif // _NUMFMT
1254 //eof
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>