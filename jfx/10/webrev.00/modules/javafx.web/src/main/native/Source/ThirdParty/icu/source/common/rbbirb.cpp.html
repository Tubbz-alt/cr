<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/rbbirb.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 //
  4 //  file:  rbbirb.cpp
  5 //
  6 //  Copyright (C) 2002-2011, International Business Machines Corporation and others.
  7 //  All Rights Reserved.
  8 //
  9 //  This file contains the RBBIRuleBuilder class implementation.  This is the main class for
 10 //    building (compiling) break rules into the tables required by the runtime
 11 //    RBBI engine.
 12 //
 13 
 14 #include &quot;unicode/utypes.h&quot;
 15 
 16 #if !UCONFIG_NO_BREAK_ITERATION
 17 
 18 #include &quot;unicode/brkiter.h&quot;
 19 #include &quot;unicode/rbbi.h&quot;
 20 #include &quot;unicode/ubrk.h&quot;
 21 #include &quot;unicode/unistr.h&quot;
 22 #include &quot;unicode/uniset.h&quot;
 23 #include &quot;unicode/uchar.h&quot;
 24 #include &quot;unicode/uchriter.h&quot;
 25 #include &quot;unicode/parsepos.h&quot;
 26 #include &quot;unicode/parseerr.h&quot;
 27 
 28 #include &quot;cmemory.h&quot;
 29 #include &quot;cstring.h&quot;
 30 #include &quot;rbbirb.h&quot;
 31 #include &quot;rbbinode.h&quot;
 32 #include &quot;rbbiscan.h&quot;
 33 #include &quot;rbbisetb.h&quot;
 34 #include &quot;rbbitblb.h&quot;
 35 #include &quot;rbbidata.h&quot;
 36 #include &quot;uassert.h&quot;
 37 
 38 
 39 U_NAMESPACE_BEGIN
 40 
 41 
 42 //----------------------------------------------------------------------------------------
 43 //
 44 //  Constructor.
 45 //
 46 //----------------------------------------------------------------------------------------
 47 RBBIRuleBuilder::RBBIRuleBuilder(const UnicodeString   &amp;rules,
 48                                        UParseError     *parseErr,
 49                                        UErrorCode      &amp;status)
 50  : fRules(rules), fStrippedRules(rules)
 51 {
 52     fStatus = &amp;status; // status is checked below
 53     fParseError = parseErr;
 54     fDebugEnv   = NULL;
 55 #ifdef RBBI_DEBUG
 56     fDebugEnv   = getenv(&quot;U_RBBIDEBUG&quot;);
 57 #endif
 58 
 59 
 60     fForwardTree        = NULL;
 61     fReverseTree        = NULL;
 62     fSafeFwdTree        = NULL;
 63     fSafeRevTree        = NULL;
 64     fDefaultTree        = &amp;fForwardTree;
 65     fForwardTable       = NULL;
 66     fRuleStatusVals     = NULL;
 67     fChainRules         = FALSE;
 68     fLBCMNoChain        = FALSE;
 69     fLookAheadHardBreak = FALSE;
 70     fUSetNodes          = NULL;
 71     fRuleStatusVals     = NULL;
 72     fScanner            = NULL;
 73     fSetBuilder         = NULL;
 74     if (parseErr) {
 75         uprv_memset(parseErr, 0, sizeof(UParseError));
 76     }
 77 
 78     if (U_FAILURE(status)) {
 79         return;
 80     }
 81 
 82     fUSetNodes          = new UVector(status); // bcos status gets overwritten here
 83     fRuleStatusVals     = new UVector(status);
 84     fScanner            = new RBBIRuleScanner(this);
 85     fSetBuilder         = new RBBISetBuilder(this);
 86     if (U_FAILURE(status)) {
 87         return;
 88     }
 89     if(fSetBuilder == 0 || fScanner == 0 || fUSetNodes == 0 || fRuleStatusVals == 0) {
 90         status = U_MEMORY_ALLOCATION_ERROR;
 91     }
 92 }
 93 
 94 
 95 
 96 //----------------------------------------------------------------------------------------
 97 //
 98 //  Destructor
 99 //
100 //----------------------------------------------------------------------------------------
101 RBBIRuleBuilder::~RBBIRuleBuilder() {
102 
103     int        i;
104     for (i=0; ; i++) {
105         RBBINode *n = (RBBINode *)fUSetNodes-&gt;elementAt(i);
106         if (n==NULL) {
107             break;
108         }
109         delete n;
110     }
111 
112     delete fUSetNodes;
113     delete fSetBuilder;
114     delete fForwardTable;
115     delete fForwardTree;
116     delete fReverseTree;
117     delete fSafeFwdTree;
118     delete fSafeRevTree;
119     delete fScanner;
120     delete fRuleStatusVals;
121 }
122 
123 
124 
125 
126 
127 //----------------------------------------------------------------------------------------
128 //
129 //   flattenData() -  Collect up the compiled RBBI rule data and put it into
130 //                    the format for saving in ICU data files,
131 //                    which is also the format needed by the RBBI runtime engine.
132 //
133 //----------------------------------------------------------------------------------------
134 static int32_t align8(int32_t i) {return (i+7) &amp; 0xfffffff8;}
135 
136 RBBIDataHeader *RBBIRuleBuilder::flattenData() {
137     int32_t    i;
138 
139     if (U_FAILURE(*fStatus)) {
140         return NULL;
141     }
142 
143     // Remove whitespace from the rules to make it smaller.
144     // The rule parser has already removed comments.
145     fStrippedRules = fScanner-&gt;stripRules(fStrippedRules);
146 
147     // Calculate the size of each section in the data.
148     //   Sizes here are padded up to a multiple of 8 for better memory alignment.
149     //   Sections sizes actually stored in the header are for the actual data
150     //     without the padding.
151     //
152     int32_t headerSize        = align8(sizeof(RBBIDataHeader));
153     int32_t forwardTableSize  = align8(fForwardTable-&gt;getTableSize());
154     int32_t reverseTableSize  = align8(fForwardTable-&gt;getSafeTableSize());
155     int32_t trieSize          = align8(fSetBuilder-&gt;getTrieSize());
156     int32_t statusTableSize   = align8(fRuleStatusVals-&gt;size() * sizeof(int32_t));
157     int32_t rulesSize         = align8((fStrippedRules.length()+1) * sizeof(UChar));
158 
159     int32_t         totalSize = headerSize
160                                 + forwardTableSize
161                                 + reverseTableSize
162                                 + statusTableSize + trieSize + rulesSize;
163 
164     RBBIDataHeader  *data     = (RBBIDataHeader *)uprv_malloc(totalSize);
165     if (data == NULL) {
166         *fStatus = U_MEMORY_ALLOCATION_ERROR;
167         return NULL;
168     }
169     uprv_memset(data, 0, totalSize);
170 
171 
172     data-&gt;fMagic            = 0xb1a0;
173     data-&gt;fFormatVersion[0] = RBBI_DATA_FORMAT_VERSION[0];
174     data-&gt;fFormatVersion[1] = RBBI_DATA_FORMAT_VERSION[1];
175     data-&gt;fFormatVersion[2] = RBBI_DATA_FORMAT_VERSION[2];
176     data-&gt;fFormatVersion[3] = RBBI_DATA_FORMAT_VERSION[3];
177     data-&gt;fLength           = totalSize;
178     data-&gt;fCatCount         = fSetBuilder-&gt;getNumCharCategories();
179 
180     data-&gt;fFTable        = headerSize;
181     data-&gt;fFTableLen     = forwardTableSize;
182 
183     data-&gt;fRTable        = data-&gt;fFTable  + data-&gt;fFTableLen;
184     data-&gt;fRTableLen     = reverseTableSize;
185 
186     data-&gt;fTrie          = data-&gt;fRTable + data-&gt;fRTableLen;
187     data-&gt;fTrieLen       = fSetBuilder-&gt;getTrieSize();
188     data-&gt;fStatusTable   = data-&gt;fTrie    + trieSize;
189     data-&gt;fStatusTableLen= statusTableSize;
190     data-&gt;fRuleSource    = data-&gt;fStatusTable + statusTableSize;
191     data-&gt;fRuleSourceLen = fStrippedRules.length() * sizeof(UChar);
192 
193     uprv_memset(data-&gt;fReserved, 0, sizeof(data-&gt;fReserved));
194 
195     fForwardTable-&gt;exportTable((uint8_t *)data + data-&gt;fFTable);
196     fForwardTable-&gt;exportSafeTable((uint8_t *)data + data-&gt;fRTable);
197     fSetBuilder-&gt;serializeTrie ((uint8_t *)data + data-&gt;fTrie);
198 
199     int32_t *ruleStatusTable = (int32_t *)((uint8_t *)data + data-&gt;fStatusTable);
200     for (i=0; i&lt;fRuleStatusVals-&gt;size(); i++) {
201         ruleStatusTable[i] = fRuleStatusVals-&gt;elementAti(i);
202     }
203 
204     fStrippedRules.extract((UChar *)((uint8_t *)data+data-&gt;fRuleSource), rulesSize/2+1, *fStatus);
205 
206     return data;
207 }
208 
209 
210 //----------------------------------------------------------------------------------------
211 //
212 //  createRuleBasedBreakIterator    construct from source rules that are passed in
213 //                                  in a UnicodeString
214 //
215 //----------------------------------------------------------------------------------------
216 BreakIterator *
217 RBBIRuleBuilder::createRuleBasedBreakIterator( const UnicodeString    &amp;rules,
218                                     UParseError      *parseError,
219                                     UErrorCode       &amp;status)
220 {
221     //
222     // Read the input rules, generate a parse tree, symbol table,
223     // and list of all Unicode Sets referenced by the rules.
224     //
225     RBBIRuleBuilder  builder(rules, parseError, status);
226     if (U_FAILURE(status)) { // status checked here bcos build below doesn&#39;t
227         return NULL;
228     }
229 
230     RBBIDataHeader *data = builder.build(status);
231 
232     if (U_FAILURE(status)) {
233         return nullptr;
234     }
235 
236     //
237     //  Create a break iterator from the compiled rules.
238     //     (Identical to creation from stored pre-compiled rules)
239     //
240     // status is checked after init in construction.
241     RuleBasedBreakIterator *This = new RuleBasedBreakIterator(data, status);
242     if (U_FAILURE(status)) {
243         delete This;
244         This = NULL;
245     }
246     else if(This == NULL) { // test for NULL
247         status = U_MEMORY_ALLOCATION_ERROR;
248     }
249     return This;
250 }
251 
252 RBBIDataHeader *RBBIRuleBuilder::build(UErrorCode &amp;status) {
253     if (U_FAILURE(status)) {
254         return nullptr;
255     }
256 
257     fScanner-&gt;parse();
258     if (U_FAILURE(status)) {
259         return nullptr;
260     }
261 
262     //
263     // UnicodeSet processing.
264     //    Munge the Unicode Sets to create a set of character categories.
265     //    Generate the mapping tables (TRIE) from input code points to
266     //    the character categories.
267     //
268     fSetBuilder-&gt;buildRanges();
269 
270     //
271     //   Generate the DFA state transition table.
272     //
273     fForwardTable = new RBBITableBuilder(this, &amp;fForwardTree, status);
274     if (fForwardTable == nullptr) {
275         status = U_MEMORY_ALLOCATION_ERROR;
276         return nullptr;
277     }
278 
279     fForwardTable-&gt;buildForwardTable();
280     optimizeTables();
281     fForwardTable-&gt;buildSafeReverseTable(status);
282 
283 
284 #ifdef RBBI_DEBUG
285     if (fDebugEnv &amp;&amp; uprv_strstr(fDebugEnv, &quot;states&quot;)) {
286         fForwardTable-&gt;printStates();
287         fForwardTable-&gt;printRuleStatusTable();
288         fForwardTable-&gt;printReverseTable();
289     }
290 #endif
291 
292     fSetBuilder-&gt;buildTrie();
293 
294     //
295     //   Package up the compiled data into a memory image
296     //      in the run-time format.
297     //
298     RBBIDataHeader *data = flattenData(); // returns NULL if error
299     if (U_FAILURE(status)) {
300         return nullptr;
301     }
302     return data;
303 }
304 
305 void RBBIRuleBuilder::optimizeTables() {
306     bool didSomething;
307     do {
308         didSomething = false;
309 
310         // Begin looking for duplicates with char class 3.
311         // Classes 0, 1 and 2 are special; they are unused, {bof} and {eof} respectively,
312         // and should not have other categories merged into them.
313         IntPair duplPair = {3, 0};
314         while (fForwardTable-&gt;findDuplCharClassFrom(&amp;duplPair)) {
315             fSetBuilder-&gt;mergeCategories(duplPair);
316             fForwardTable-&gt;removeColumn(duplPair.second);
317             didSomething = true;
318         }
319 
320         while (fForwardTable-&gt;removeDuplicateStates() &gt; 0) {
321             didSomething = true;
322         }
323     } while (didSomething);
324 }
325 
326 U_NAMESPACE_END
327 
328 #endif /* #if !UCONFIG_NO_BREAK_ITERATION */
    </pre>
  </body>
</html>