<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_stringbuilder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="number_skeletons.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_stringbuilder.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_stringbuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 // © 2017 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 
  4 #include &quot;unicode/utypes.h&quot;
  5 
  6 #if !UCONFIG_NO_FORMATTING
  7 
  8 #include &quot;number_stringbuilder.h&quot;

  9 #include &quot;unicode/utf16.h&quot;

 10 
 11 using namespace icu;
 12 using namespace icu::number;
 13 using namespace icu::number::impl;
 14 
 15 namespace {
 16 
 17 // A version of uprv_memcpy that checks for length 0.
 18 // By default, uprv_memcpy requires a length of at least 1.
 19 inline void uprv_memcpy2(void* dest, const void* src, size_t len) {
 20     if (len &gt; 0) {
 21         uprv_memcpy(dest, src, len);
 22     }
 23 }
 24 
 25 // A version of uprv_memmove that checks for length 0.
 26 // By default, uprv_memmove requires a length of at least 1.
 27 inline void uprv_memmove2(void* dest, const void* src, size_t len) {
 28     if (len &gt; 0) {
 29         uprv_memmove(dest, src, len);
 30     }
 31 }
 32 
 33 } // namespace
 34 
<span class="line-modified"> 35 NumberStringBuilder::NumberStringBuilder() = default;</span>








 36 
 37 NumberStringBuilder::~NumberStringBuilder() {
 38     if (fUsingHeap) {
 39         uprv_free(fChars.heap.ptr);
 40         uprv_free(fFields.heap.ptr);
 41     }
 42 }
 43 
 44 NumberStringBuilder::NumberStringBuilder(const NumberStringBuilder &amp;other) {
 45     *this = other;
 46 }
 47 
 48 NumberStringBuilder &amp;NumberStringBuilder::operator=(const NumberStringBuilder &amp;other) {
 49     // Check for self-assignment
 50     if (this == &amp;other) {
 51         return *this;
 52     }
 53 
 54     // Continue with deallocation and copying
 55     if (fUsingHeap) {
</pre>
<hr />
<pre>
223     if (this == &amp;other) {
224         status = U_ILLEGAL_ARGUMENT_ERROR;
225         return 0;
226     }
227     int32_t count = other.fLength;
228     if (count == 0) {
229         // Nothing to insert.
230         return 0;
231     }
232     int32_t position = prepareForInsert(index, count, status);
233     if (U_FAILURE(status)) {
234         return count;
235     }
236     for (int32_t i = 0; i &lt; count; i++) {
237         getCharPtr()[position + i] = other.charAt(i);
238         getFieldPtr()[position + i] = other.fieldAt(i);
239     }
240     return count;
241 }
242 










243 int32_t NumberStringBuilder::prepareForInsert(int32_t index, int32_t count, UErrorCode &amp;status) {



244     if (index == 0 &amp;&amp; fZero - count &gt;= 0) {
245         // Append to start
246         fZero -= count;
247         fLength += count;
248         return fZero;
249     } else if (index == fLength &amp;&amp; fZero + fLength + count &lt; getCapacity()) {
250         // Append to end
251         fLength += count;
252         return fZero + fLength - count;
253     } else {
254         // Move chars around and/or allocate more space
255         return prepareForInsertHelper(index, count, status);
256     }
257 }
258 
259 int32_t NumberStringBuilder::prepareForInsertHelper(int32_t index, int32_t count, UErrorCode &amp;status) {
260     int32_t oldCapacity = getCapacity();
261     int32_t oldZero = fZero;
262     char16_t *oldChars = getCharPtr();
263     Field *oldFields = getFieldPtr();
</pre>
<hr />
<pre>
407     for (int32_t i = 0; i &lt; fLength; i++) {
408         if (charAt(i) != other.charAt(i) || fieldAt(i) != other.fieldAt(i)) {
409             return false;
410         }
411     }
412     return true;
413 }
414 
415 bool NumberStringBuilder::nextFieldPosition(FieldPosition&amp; fp, UErrorCode&amp; status) const {
416     int32_t rawField = fp.getField();
417 
418     if (rawField == FieldPosition::DONT_CARE) {
419         return FALSE;
420     }
421 
422     if (rawField &lt; 0 || rawField &gt;= UNUM_FIELD_COUNT) {
423         status = U_ILLEGAL_ARGUMENT_ERROR;
424         return FALSE;
425     }
426 
<span class="line-modified">427     auto field = static_cast&lt;Field&gt;(rawField);</span>







428 
<span class="line-modified">429     bool seenStart = false;</span>
<span class="line-modified">430     int32_t fractionStart = -1;</span>
<span class="line-modified">431     int32_t startIndex = fp.getEndIndex();</span>
<span class="line-modified">432     for (int i = fZero + startIndex; i &lt;= fZero + fLength; i++) {</span>
<span class="line-modified">433         Field _field = UNUM_FIELD_COUNT;</span>
<span class="line-modified">434         if (i &lt; fZero + fLength) {</span>
<span class="line-modified">435             _field = getFieldPtr()[i];</span>
<span class="line-modified">436         }</span>
<span class="line-modified">437         if (seenStart &amp;&amp; field != _field) {</span>
<span class="line-removed">438             // Special case: GROUPING_SEPARATOR counts as an INTEGER.</span>
<span class="line-removed">439             if (field == UNUM_INTEGER_FIELD &amp;&amp; _field == UNUM_GROUPING_SEPARATOR_FIELD) {</span>
<span class="line-removed">440                 continue;</span>
441             }
<span class="line-removed">442             fp.setEndIndex(i - fZero);</span>
<span class="line-removed">443             break;</span>
<span class="line-removed">444         } else if (!seenStart &amp;&amp; field == _field) {</span>
<span class="line-removed">445             fp.setBeginIndex(i - fZero);</span>
<span class="line-removed">446             seenStart = true;</span>
447         }
<span class="line-modified">448         if (_field == UNUM_INTEGER_FIELD || _field == UNUM_DECIMAL_SEPARATOR_FIELD) {</span>
<span class="line-modified">449             fractionStart = i - fZero + 1;</span>
<span class="line-removed">450         }</span>
<span class="line-removed">451     }</span>
<span class="line-removed">452 </span>
<span class="line-removed">453     // Backwards compatibility: FRACTION needs to start after INTEGER if empty.</span>
<span class="line-removed">454     // Do not return that a field was found, though, since there is not actually a fraction part.</span>
<span class="line-removed">455     if (field == UNUM_FRACTION_FIELD &amp;&amp; !seenStart &amp;&amp; fractionStart != -1) {</span>
<span class="line-removed">456         fp.setBeginIndex(fractionStart);</span>
<span class="line-removed">457         fp.setEndIndex(fractionStart);</span>
458     }
459 
<span class="line-modified">460     return seenStart;</span>
461 }
462 
463 void NumberStringBuilder::getAllFieldPositions(FieldPositionIteratorHandler&amp; fpih,
464                                                UErrorCode&amp; status) const {
<span class="line-modified">465     Field current = UNUM_FIELD_COUNT;</span>
<span class="line-modified">466     int32_t currentStart = -1;</span>
<span class="line-modified">467     for (int32_t i = 0; i &lt; fLength; i++) {</span>
<span class="line-modified">468         Field field = fieldAt(i);</span>
<span class="line-modified">469         if (current == UNUM_INTEGER_FIELD &amp;&amp; field == UNUM_GROUPING_SEPARATOR_FIELD) {</span>
<span class="line-modified">470             // Special case: GROUPING_SEPARATOR counts as an INTEGER.</span>
<span class="line-modified">471             fpih.addAttribute(UNUM_GROUPING_SEPARATOR_FIELD, i, i + 1);</span>
<span class="line-modified">472         } else if (current != field) {</span>
<span class="line-modified">473             if (current != UNUM_FIELD_COUNT) {</span>
<span class="line-modified">474                 fpih.addAttribute(current, currentStart, i);</span>




























475             }
<span class="line-modified">476             current = field;</span>
<span class="line-modified">477             currentStart = i;</span>











478         }
<span class="line-modified">479         if (U_FAILURE(status)) {</span>
<span class="line-modified">480             return;</span>


























481         }
482     }
<span class="line-modified">483     if (current != UNUM_FIELD_COUNT) {</span>
<span class="line-modified">484         fpih.addAttribute(current, currentStart, fLength);</span>








485     }
























486 }
487 
488 #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
</td>
<td>
<hr />
<pre>
  1 // © 2017 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 
  4 #include &quot;unicode/utypes.h&quot;
  5 
  6 #if !UCONFIG_NO_FORMATTING
  7 
  8 #include &quot;number_stringbuilder.h&quot;
<span class="line-added">  9 #include &quot;static_unicode_sets.h&quot;</span>
 10 #include &quot;unicode/utf16.h&quot;
<span class="line-added"> 11 #include &quot;number_utils.h&quot;</span>
 12 
 13 using namespace icu;
 14 using namespace icu::number;
 15 using namespace icu::number::impl;
 16 
 17 namespace {
 18 
 19 // A version of uprv_memcpy that checks for length 0.
 20 // By default, uprv_memcpy requires a length of at least 1.
 21 inline void uprv_memcpy2(void* dest, const void* src, size_t len) {
 22     if (len &gt; 0) {
 23         uprv_memcpy(dest, src, len);
 24     }
 25 }
 26 
 27 // A version of uprv_memmove that checks for length 0.
 28 // By default, uprv_memmove requires a length of at least 1.
 29 inline void uprv_memmove2(void* dest, const void* src, size_t len) {
 30     if (len &gt; 0) {
 31         uprv_memmove(dest, src, len);
 32     }
 33 }
 34 
 35 } // namespace
 36 
<span class="line-modified"> 37 NumberStringBuilder::NumberStringBuilder() {</span>
<span class="line-added"> 38 #if U_DEBUG</span>
<span class="line-added"> 39     // Initializing the memory to non-zero helps catch some bugs that involve</span>
<span class="line-added"> 40     // reading from an improperly terminated string.</span>
<span class="line-added"> 41     for (int32_t i=0; i&lt;getCapacity(); i++) {</span>
<span class="line-added"> 42         getCharPtr()[i] = 1;</span>
<span class="line-added"> 43     }</span>
<span class="line-added"> 44 #endif</span>
<span class="line-added"> 45 }</span>
 46 
 47 NumberStringBuilder::~NumberStringBuilder() {
 48     if (fUsingHeap) {
 49         uprv_free(fChars.heap.ptr);
 50         uprv_free(fFields.heap.ptr);
 51     }
 52 }
 53 
 54 NumberStringBuilder::NumberStringBuilder(const NumberStringBuilder &amp;other) {
 55     *this = other;
 56 }
 57 
 58 NumberStringBuilder &amp;NumberStringBuilder::operator=(const NumberStringBuilder &amp;other) {
 59     // Check for self-assignment
 60     if (this == &amp;other) {
 61         return *this;
 62     }
 63 
 64     // Continue with deallocation and copying
 65     if (fUsingHeap) {
</pre>
<hr />
<pre>
233     if (this == &amp;other) {
234         status = U_ILLEGAL_ARGUMENT_ERROR;
235         return 0;
236     }
237     int32_t count = other.fLength;
238     if (count == 0) {
239         // Nothing to insert.
240         return 0;
241     }
242     int32_t position = prepareForInsert(index, count, status);
243     if (U_FAILURE(status)) {
244         return count;
245     }
246     for (int32_t i = 0; i &lt; count; i++) {
247         getCharPtr()[position + i] = other.charAt(i);
248         getFieldPtr()[position + i] = other.fieldAt(i);
249     }
250     return count;
251 }
252 
<span class="line-added">253 void NumberStringBuilder::writeTerminator(UErrorCode&amp; status) {</span>
<span class="line-added">254     int32_t position = prepareForInsert(fLength, 1, status);</span>
<span class="line-added">255     if (U_FAILURE(status)) {</span>
<span class="line-added">256         return;</span>
<span class="line-added">257     }</span>
<span class="line-added">258     getCharPtr()[position] = 0;</span>
<span class="line-added">259     getFieldPtr()[position] = UNUM_FIELD_COUNT;</span>
<span class="line-added">260     fLength--;</span>
<span class="line-added">261 }</span>
<span class="line-added">262 </span>
263 int32_t NumberStringBuilder::prepareForInsert(int32_t index, int32_t count, UErrorCode &amp;status) {
<span class="line-added">264     U_ASSERT(index &gt;= 0);</span>
<span class="line-added">265     U_ASSERT(index &lt;= fLength);</span>
<span class="line-added">266     U_ASSERT(count &gt;= 0);</span>
267     if (index == 0 &amp;&amp; fZero - count &gt;= 0) {
268         // Append to start
269         fZero -= count;
270         fLength += count;
271         return fZero;
272     } else if (index == fLength &amp;&amp; fZero + fLength + count &lt; getCapacity()) {
273         // Append to end
274         fLength += count;
275         return fZero + fLength - count;
276     } else {
277         // Move chars around and/or allocate more space
278         return prepareForInsertHelper(index, count, status);
279     }
280 }
281 
282 int32_t NumberStringBuilder::prepareForInsertHelper(int32_t index, int32_t count, UErrorCode &amp;status) {
283     int32_t oldCapacity = getCapacity();
284     int32_t oldZero = fZero;
285     char16_t *oldChars = getCharPtr();
286     Field *oldFields = getFieldPtr();
</pre>
<hr />
<pre>
430     for (int32_t i = 0; i &lt; fLength; i++) {
431         if (charAt(i) != other.charAt(i) || fieldAt(i) != other.fieldAt(i)) {
432             return false;
433         }
434     }
435     return true;
436 }
437 
438 bool NumberStringBuilder::nextFieldPosition(FieldPosition&amp; fp, UErrorCode&amp; status) const {
439     int32_t rawField = fp.getField();
440 
441     if (rawField == FieldPosition::DONT_CARE) {
442         return FALSE;
443     }
444 
445     if (rawField &lt; 0 || rawField &gt;= UNUM_FIELD_COUNT) {
446         status = U_ILLEGAL_ARGUMENT_ERROR;
447         return FALSE;
448     }
449 
<span class="line-modified">450     ConstrainedFieldPosition cfpos;</span>
<span class="line-added">451     cfpos.constrainField(UFIELD_CATEGORY_NUMBER, rawField);</span>
<span class="line-added">452     cfpos.setState(UFIELD_CATEGORY_NUMBER, rawField, fp.getBeginIndex(), fp.getEndIndex());</span>
<span class="line-added">453     if (nextPosition(cfpos, 0, status)) {</span>
<span class="line-added">454         fp.setBeginIndex(cfpos.getStart());</span>
<span class="line-added">455         fp.setEndIndex(cfpos.getLimit());</span>
<span class="line-added">456         return true;</span>
<span class="line-added">457     }</span>
458 
<span class="line-modified">459     // Special case: fraction should start after integer if fraction is not present</span>
<span class="line-modified">460     if (rawField == UNUM_FRACTION_FIELD &amp;&amp; fp.getEndIndex() == 0) {</span>
<span class="line-modified">461         bool inside = false;</span>
<span class="line-modified">462         int32_t i = fZero;</span>
<span class="line-modified">463         for (; i &lt; fZero + fLength; i++) {</span>
<span class="line-modified">464             if (isIntOrGroup(getFieldPtr()[i]) || getFieldPtr()[i] == UNUM_DECIMAL_SEPARATOR_FIELD) {</span>
<span class="line-modified">465                 inside = true;</span>
<span class="line-modified">466             } else if (inside) {</span>
<span class="line-modified">467                 break;</span>



468             }





469         }
<span class="line-modified">470         fp.setBeginIndex(i - fZero);</span>
<span class="line-modified">471         fp.setEndIndex(i - fZero);</span>








472     }
473 
<span class="line-modified">474     return false;</span>
475 }
476 
477 void NumberStringBuilder::getAllFieldPositions(FieldPositionIteratorHandler&amp; fpih,
478                                                UErrorCode&amp; status) const {
<span class="line-modified">479     ConstrainedFieldPosition cfpos;</span>
<span class="line-modified">480     while (nextPosition(cfpos, 0, status)) {</span>
<span class="line-modified">481         fpih.addAttribute(cfpos.getField(), cfpos.getStart(), cfpos.getLimit());</span>
<span class="line-modified">482     }</span>
<span class="line-modified">483 }</span>
<span class="line-modified">484 </span>
<span class="line-modified">485 // Signal the end of the string using a field that doesn&#39;t exist and that is</span>
<span class="line-modified">486 // different from UNUM_FIELD_COUNT, which is used for &quot;null number field&quot;.</span>
<span class="line-modified">487 static constexpr Field kEndField = 0xff;</span>
<span class="line-modified">488 </span>
<span class="line-added">489 bool NumberStringBuilder::nextPosition(ConstrainedFieldPosition&amp; cfpos, Field numericField, UErrorCode&amp; /*status*/) const {</span>
<span class="line-added">490     auto numericCAF = NumFieldUtils::expand(numericField);</span>
<span class="line-added">491     int32_t fieldStart = -1;</span>
<span class="line-added">492     Field currField = UNUM_FIELD_COUNT;</span>
<span class="line-added">493     for (int32_t i = fZero + cfpos.getLimit(); i &lt;= fZero + fLength; i++) {</span>
<span class="line-added">494         Field _field = (i &lt; fZero + fLength) ? getFieldPtr()[i] : kEndField;</span>
<span class="line-added">495         // Case 1: currently scanning a field.</span>
<span class="line-added">496         if (currField != UNUM_FIELD_COUNT) {</span>
<span class="line-added">497             if (currField != _field) {</span>
<span class="line-added">498                 int32_t end = i - fZero;</span>
<span class="line-added">499                 // Grouping separators can be whitespace; don&#39;t throw them out!</span>
<span class="line-added">500                 if (currField != UNUM_GROUPING_SEPARATOR_FIELD) {</span>
<span class="line-added">501                     end = trimBack(i - fZero);</span>
<span class="line-added">502                 }</span>
<span class="line-added">503                 if (end &lt;= fieldStart) {</span>
<span class="line-added">504                     // Entire field position is ignorable; skip.</span>
<span class="line-added">505                     fieldStart = -1;</span>
<span class="line-added">506                     currField = UNUM_FIELD_COUNT;</span>
<span class="line-added">507                     i--;  // look at this index again</span>
<span class="line-added">508                     continue;</span>
<span class="line-added">509                 }</span>
<span class="line-added">510                 int32_t start = fieldStart;</span>
<span class="line-added">511                 if (currField != UNUM_GROUPING_SEPARATOR_FIELD) {</span>
<span class="line-added">512                     start = trimFront(start);</span>
<span class="line-added">513                 }</span>
<span class="line-added">514                 auto caf = NumFieldUtils::expand(currField);</span>
<span class="line-added">515                 cfpos.setState(caf.category, caf.field, start, end);</span>
<span class="line-added">516                 return true;</span>
517             }
<span class="line-modified">518             continue;</span>
<span class="line-modified">519         }</span>
<span class="line-added">520         // Special case: coalesce the INTEGER if we are pointing at the end of the INTEGER.</span>
<span class="line-added">521         if (cfpos.matchesField(UFIELD_CATEGORY_NUMBER, UNUM_INTEGER_FIELD)</span>
<span class="line-added">522                 &amp;&amp; i &gt; fZero</span>
<span class="line-added">523                 // don&#39;t return the same field twice in a row:</span>
<span class="line-added">524                 &amp;&amp; i - fZero &gt; cfpos.getLimit()</span>
<span class="line-added">525                 &amp;&amp; isIntOrGroup(getFieldPtr()[i - 1])</span>
<span class="line-added">526                 &amp;&amp; !isIntOrGroup(_field)) {</span>
<span class="line-added">527             int j = i - 1;</span>
<span class="line-added">528             for (; j &gt;= fZero &amp;&amp; isIntOrGroup(getFieldPtr()[j]); j--) {}</span>
<span class="line-added">529             cfpos.setState(UFIELD_CATEGORY_NUMBER, UNUM_INTEGER_FIELD, j - fZero + 1, i - fZero);</span>
<span class="line-added">530             return true;</span>
531         }
<span class="line-modified">532         // Special case: coalesce NUMERIC if we are pointing at the end of the NUMERIC.</span>
<span class="line-modified">533         if (numericField != 0</span>
<span class="line-added">534                 &amp;&amp; cfpos.matchesField(numericCAF.category, numericCAF.field)</span>
<span class="line-added">535                 &amp;&amp; i &gt; fZero</span>
<span class="line-added">536                 // don&#39;t return the same field twice in a row:</span>
<span class="line-added">537                 &amp;&amp; (i - fZero &gt; cfpos.getLimit()</span>
<span class="line-added">538                     || cfpos.getCategory() != numericCAF.category</span>
<span class="line-added">539                     || cfpos.getField() != numericCAF.field)</span>
<span class="line-added">540                 &amp;&amp; isNumericField(getFieldPtr()[i - 1])</span>
<span class="line-added">541                 &amp;&amp; !isNumericField(_field)) {</span>
<span class="line-added">542             int j = i - 1;</span>
<span class="line-added">543             for (; j &gt;= fZero &amp;&amp; isNumericField(getFieldPtr()[j]); j--) {}</span>
<span class="line-added">544             cfpos.setState(numericCAF.category, numericCAF.field, j - fZero + 1, i - fZero);</span>
<span class="line-added">545             return true;</span>
<span class="line-added">546         }</span>
<span class="line-added">547         // Special case: skip over INTEGER; will be coalesced later.</span>
<span class="line-added">548         if (_field == UNUM_INTEGER_FIELD) {</span>
<span class="line-added">549             _field = UNUM_FIELD_COUNT;</span>
<span class="line-added">550         }</span>
<span class="line-added">551         // Case 2: no field starting at this position.</span>
<span class="line-added">552         if (_field == UNUM_FIELD_COUNT || _field == kEndField) {</span>
<span class="line-added">553             continue;</span>
<span class="line-added">554         }</span>
<span class="line-added">555         // Case 3: check for field starting at this position</span>
<span class="line-added">556         auto caf = NumFieldUtils::expand(_field);</span>
<span class="line-added">557         if (cfpos.matchesField(caf.category, caf.field)) {</span>
<span class="line-added">558             fieldStart = i - fZero;</span>
<span class="line-added">559             currField = _field;</span>
560         }
561     }
<span class="line-modified">562 </span>
<span class="line-modified">563     U_ASSERT(currField == UNUM_FIELD_COUNT);</span>
<span class="line-added">564     return false;</span>
<span class="line-added">565 }</span>
<span class="line-added">566 </span>
<span class="line-added">567 bool NumberStringBuilder::containsField(Field field) const {</span>
<span class="line-added">568     for (int32_t i = 0; i &lt; fLength; i++) {</span>
<span class="line-added">569         if (field == fieldAt(i)) {</span>
<span class="line-added">570             return true;</span>
<span class="line-added">571         }</span>
572     }
<span class="line-added">573     return false;</span>
<span class="line-added">574 }</span>
<span class="line-added">575 </span>
<span class="line-added">576 bool NumberStringBuilder::isIntOrGroup(Field field) {</span>
<span class="line-added">577     return field == UNUM_INTEGER_FIELD</span>
<span class="line-added">578         || field == UNUM_GROUPING_SEPARATOR_FIELD;</span>
<span class="line-added">579 }</span>
<span class="line-added">580 </span>
<span class="line-added">581 bool NumberStringBuilder::isNumericField(Field field) {</span>
<span class="line-added">582     return NumFieldUtils::isNumericField(field);</span>
<span class="line-added">583 }</span>
<span class="line-added">584 </span>
<span class="line-added">585 int32_t NumberStringBuilder::trimBack(int32_t limit) const {</span>
<span class="line-added">586     return unisets::get(unisets::DEFAULT_IGNORABLES)-&gt;spanBack(</span>
<span class="line-added">587         getCharPtr() + fZero,</span>
<span class="line-added">588         limit,</span>
<span class="line-added">589         USET_SPAN_CONTAINED);</span>
<span class="line-added">590 }</span>
<span class="line-added">591 </span>
<span class="line-added">592 int32_t NumberStringBuilder::trimFront(int32_t start) const {</span>
<span class="line-added">593     return start + unisets::get(unisets::DEFAULT_IGNORABLES)-&gt;span(</span>
<span class="line-added">594         getCharPtr() + fZero + start,</span>
<span class="line-added">595         fLength - start,</span>
<span class="line-added">596         USET_SPAN_CONTAINED);</span>
597 }
598 
599 #endif /* #if !UCONFIG_NO_FORMATTING */
</pre>
</td>
</tr>
</table>
<center><a href="number_skeletons.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="number_stringbuilder.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>