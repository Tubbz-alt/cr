<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc_tag.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="uloc_keytype.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ulocimp.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uloc_tag.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 *   Copyright (C) 2009-2015, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8 */
   9 

  10 #include &quot;unicode/utypes.h&quot;
  11 #include &quot;unicode/ures.h&quot;

  12 #include &quot;unicode/putil.h&quot;

  13 #include &quot;unicode/uloc.h&quot;
  14 #include &quot;ustr_imp.h&quot;

  15 #include &quot;cmemory.h&quot;
  16 #include &quot;cstring.h&quot;
  17 #include &quot;putilimp.h&quot;
  18 #include &quot;uinvchar.h&quot;
  19 #include &quot;ulocimp.h&quot;
  20 #include &quot;uassert.h&quot;
  21 
  22 
  23 /* struct holding a single variant */
  24 typedef struct VariantListEntry {
  25     const char              *variant;
  26     struct VariantListEntry *next;
  27 } VariantListEntry;
  28 
  29 /* struct holding a single attribute value */
<span class="line-modified">  30 typedef struct AttributeListEntry {</span>
  31     const char              *attribute;
  32     struct AttributeListEntry *next;
<span class="line-modified">  33 } AttributeListEntry;</span>
  34 
  35 /* struct holding a single extension */
<span class="line-modified">  36 typedef struct ExtensionListEntry {</span>
  37     const char                  *key;
  38     const char                  *value;
  39     struct ExtensionListEntry   *next;
<span class="line-modified">  40 } ExtensionListEntry;</span>
  41 
  42 #define MAXEXTLANG 3
  43 typedef struct ULanguageTag {
  44     char                *buf;   /* holding parsed subtags */
  45     const char          *language;
  46     const char          *extlang[MAXEXTLANG];
  47     const char          *script;
  48     const char          *region;
  49     VariantListEntry    *variants;
  50     ExtensionListEntry  *extensions;
  51     const char          *privateuse;
  52     const char          *grandfathered;
  53 } ULanguageTag;
  54 
  55 #define MINLEN 2
  56 #define SEP &#39;-&#39;
  57 #define PRIVATEUSE &#39;x&#39;
  58 #define LDMLEXT &#39;u&#39;
  59 
  60 #define LOCALE_SEP &#39;_&#39;
  61 #define LOCALE_EXT_SEP &#39;@&#39;
  62 #define LOCALE_KEYWORD_SEP &#39;;&#39;
  63 #define LOCALE_KEY_TYPE_SEP &#39;=&#39;
  64 
  65 #define ISALPHA(c) uprv_isASCIILetter(c)
  66 #define ISNUMERIC(c) ((c)&gt;=&#39;0&#39; &amp;&amp; (c)&lt;=&#39;9&#39;)
  67 
  68 static const char EMPTY[] = &quot;&quot;;
  69 static const char LANG_UND[] = &quot;und&quot;;
  70 static const char PRIVATEUSE_KEY[] = &quot;x&quot;;
  71 static const char _POSIX[] = &quot;_POSIX&quot;;
  72 static const char POSIX_KEY[] = &quot;va&quot;;
  73 static const char POSIX_VALUE[] = &quot;posix&quot;;
  74 static const char LOCALE_ATTRIBUTE_KEY[] = &quot;attribute&quot;;
  75 static const char PRIVUSE_VARIANT_PREFIX[] = &quot;lvariant&quot;;
  76 static const char LOCALE_TYPE_YES[] = &quot;yes&quot;;
  77 
  78 #define LANG_UND_LEN 3
  79 



















  80 static const char* const GRANDFATHERED[] = {
  81 /*  grandfathered   preferred */
  82     &quot;art-lojban&quot;,   &quot;jbo&quot;,
<span class="line-modified">  83     &quot;cel-gaulish&quot;,  &quot;xtg-x-cel-gaulish&quot;,</span>
<span class="line-removed">  84     &quot;en-GB-oed&quot;,    &quot;en-GB-x-oed&quot;,</span>
  85     &quot;i-ami&quot;,        &quot;ami&quot;,
  86     &quot;i-bnn&quot;,        &quot;bnn&quot;,
<span class="line-removed">  87     &quot;i-default&quot;,    &quot;en-x-i-default&quot;,</span>
<span class="line-removed">  88     &quot;i-enochian&quot;,   &quot;und-x-i-enochian&quot;,</span>
  89     &quot;i-hak&quot;,        &quot;hak&quot;,
  90     &quot;i-klingon&quot;,    &quot;tlh&quot;,
  91     &quot;i-lux&quot;,        &quot;lb&quot;,
<span class="line-removed">  92     &quot;i-mingo&quot;,      &quot;see-x-i-mingo&quot;,</span>
  93     &quot;i-navajo&quot;,     &quot;nv&quot;,
  94     &quot;i-pwn&quot;,        &quot;pwn&quot;,
  95     &quot;i-tao&quot;,        &quot;tao&quot;,
  96     &quot;i-tay&quot;,        &quot;tay&quot;,
  97     &quot;i-tsu&quot;,        &quot;tsu&quot;,
  98     &quot;no-bok&quot;,       &quot;nb&quot;,
  99     &quot;no-nyn&quot;,       &quot;nn&quot;,
 100     &quot;sgn-be-fr&quot;,    &quot;sfb&quot;,
 101     &quot;sgn-be-nl&quot;,    &quot;vgt&quot;,
 102     &quot;sgn-ch-de&quot;,    &quot;sgg&quot;,
 103     &quot;zh-guoyu&quot;,     &quot;cmn&quot;,
 104     &quot;zh-hakka&quot;,     &quot;hak&quot;,
<span class="line-removed"> 105     &quot;zh-min&quot;,       &quot;nan-x-zh-min&quot;,</span>
 106     &quot;zh-min-nan&quot;,   &quot;nan&quot;,
 107     &quot;zh-xiang&quot;,     &quot;hsn&quot;,
<span class="line-modified"> 108     NULL,           NULL</span>
























































 109 };
 110 










 111 static const char DEPRECATEDLANGS[][4] = {
 112 /*  deprecated  new */

 113     &quot;iw&quot;,       &quot;he&quot;,
 114     &quot;ji&quot;,       &quot;yi&quot;,
<span class="line-modified"> 115     &quot;in&quot;,       &quot;id&quot;</span>




























































































 116 };
 117 
 118 /*
 119 * -------------------------------------------------
 120 *
 121 * These ultag_ functions may be exposed as APIs later
 122 *
 123 * -------------------------------------------------
 124 */
 125 
 126 static ULanguageTag*
 127 ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* status);
 128 
 129 static void
 130 ultag_close(ULanguageTag* langtag);
 131 
 132 static const char*
 133 ultag_getLanguage(const ULanguageTag* langtag);
 134 
 135 #if 0
</pre>
<hr />
<pre>
 155 static int32_t
 156 ultag_getVariantsSize(const ULanguageTag* langtag);
 157 
 158 static const char*
 159 ultag_getExtensionKey(const ULanguageTag* langtag, int32_t idx);
 160 
 161 static const char*
 162 ultag_getExtensionValue(const ULanguageTag* langtag, int32_t idx);
 163 
 164 static int32_t
 165 ultag_getExtensionsSize(const ULanguageTag* langtag);
 166 
 167 static const char*
 168 ultag_getPrivateUse(const ULanguageTag* langtag);
 169 
 170 #if 0
 171 static const char*
 172 ultag_getGrandfathered(const ULanguageTag* langtag);
 173 #endif
 174 















 175 /*
 176 * -------------------------------------------------
 177 *
 178 * Language subtag syntax validation functions
 179 *
 180 * -------------------------------------------------
 181 */
 182 
 183 static UBool
 184 _isAlphaString(const char* s, int32_t len) {
 185     int32_t i;
 186     for (i = 0; i &lt; len; i++) {
 187         if (!ISALPHA(*(s + i))) {
 188             return FALSE;
 189         }
 190     }
 191     return TRUE;
 192 }
 193 
 194 static UBool
</pre>
<hr />
<pre>
 197     for (i = 0; i &lt; len; i++) {
 198         if (!ISNUMERIC(*(s + i))) {
 199             return FALSE;
 200         }
 201     }
 202     return TRUE;
 203 }
 204 
 205 static UBool
 206 _isAlphaNumericString(const char* s, int32_t len) {
 207     int32_t i;
 208     for (i = 0; i &lt; len; i++) {
 209         if (!ISALPHA(*(s + i)) &amp;&amp; !ISNUMERIC(*(s + i))) {
 210             return FALSE;
 211         }
 212     }
 213     return TRUE;
 214 }
 215 
 216 static UBool
<span class="line-modified"> 217 _isLanguageSubtag(const char* s, int32_t len) {</span>











 218     /*
<span class="line-modified"> 219      * language      = 2*3ALPHA            ; shortest ISO 639 code</span>
<span class="line-modified"> 220      *                 [&quot;-&quot; extlang]       ; sometimes followed by</span>
<span class="line-modified"> 221      *                                     ;   extended language subtags</span>
<span class="line-removed"> 222      *               / 4ALPHA              ; or reserved for future use</span>
<span class="line-removed"> 223      *               / 5*8ALPHA            ; or registered language subtag</span>
 224      */
 225     if (len &lt; 0) {
 226         len = (int32_t)uprv_strlen(s);
 227     }
 228     if (len &gt;= 2 &amp;&amp; len &lt;= 8 &amp;&amp; _isAlphaString(s, len)) {
 229         return TRUE;
 230     }
 231     return FALSE;
 232 }
 233 
 234 static UBool
 235 _isExtlangSubtag(const char* s, int32_t len) {
 236     /*
 237      * extlang       = 3ALPHA              ; selected ISO 639 codes
 238      *                 *2(&quot;-&quot; 3ALPHA)      ; permanently reserved
 239      */
 240     if (len &lt; 0) {
 241         len = (int32_t)uprv_strlen(s);
 242     }
 243     if (len == 3 &amp;&amp; _isAlphaString(s, len)) {
 244         return TRUE;
 245     }
 246     return FALSE;
 247 }
 248 
<span class="line-modified"> 249 static UBool</span>
<span class="line-modified"> 250 _isScriptSubtag(const char* s, int32_t len) {</span>
 251     /*
 252      * script        = 4ALPHA              ; ISO 15924 code
 253      */
 254     if (len &lt; 0) {
 255         len = (int32_t)uprv_strlen(s);
 256     }
 257     if (len == 4 &amp;&amp; _isAlphaString(s, len)) {
 258         return TRUE;
 259     }
 260     return FALSE;
 261 }
 262 
<span class="line-modified"> 263 static UBool</span>
<span class="line-modified"> 264 _isRegionSubtag(const char* s, int32_t len) {</span>
 265     /*
 266      * region        = 2ALPHA              ; ISO 3166-1 code
 267      *               / 3DIGIT              ; UN M.49 code
 268      */
 269     if (len &lt; 0) {
 270         len = (int32_t)uprv_strlen(s);
 271     }
 272     if (len == 2 &amp;&amp; _isAlphaString(s, len)) {
 273         return TRUE;
 274     }
 275     if (len == 3 &amp;&amp; _isNumericString(s, len)) {
 276         return TRUE;
 277     }
 278     return FALSE;
 279 }
 280 
 281 static UBool
 282 _isVariantSubtag(const char* s, int32_t len) {
 283     /*
 284      * variant       = 5*8alphanum         ; registered variants
 285      *               / (DIGIT 3alphanum)
 286      */
 287     if (len &lt; 0) {
 288         len = (int32_t)uprv_strlen(s);
 289     }
<span class="line-modified"> 290     if (len &gt;= 5 &amp;&amp; len &lt;= 8 &amp;&amp; _isAlphaNumericString(s, len)) {</span>
 291         return TRUE;
 292     }
 293     if (len == 4 &amp;&amp; ISNUMERIC(*s) &amp;&amp; _isAlphaNumericString(s + 1, 3)) {
 294         return TRUE;
 295     }
 296     return FALSE;
 297 }
 298 



































 299 static UBool
 300 _isPrivateuseVariantSubtag(const char* s, int32_t len) {
 301     /*
 302      * variant       = 1*8alphanum         ; registered variants
 303      *               / (DIGIT 3alphanum)
 304      */
<span class="line-modified"> 305     if (len &lt; 0) {</span>
<span class="line-removed"> 306         len = (int32_t)uprv_strlen(s);</span>
<span class="line-removed"> 307     }</span>
<span class="line-removed"> 308     if (len &gt;= 1 &amp;&amp; len &lt;= 8 &amp;&amp; _isAlphaNumericString(s, len)) {</span>
<span class="line-removed"> 309         return TRUE;</span>
<span class="line-removed"> 310     }</span>
<span class="line-removed"> 311     return FALSE;</span>
 312 }
 313 
 314 static UBool
 315 _isExtensionSingleton(const char* s, int32_t len) {
 316     /*
 317      * extension     = singleton 1*(&quot;-&quot; (2*8alphanum))






 318      */
 319     if (len &lt; 0) {
 320         len = (int32_t)uprv_strlen(s);
 321     }
<span class="line-modified"> 322     if (len == 1 &amp;&amp; ISALPHA(*s) &amp;&amp; (uprv_tolower(*s) != PRIVATEUSE)) {</span>
 323         return TRUE;
 324     }
 325     return FALSE;
 326 }
 327 
 328 static UBool
 329 _isExtensionSubtag(const char* s, int32_t len) {
 330     /*
 331      * extension     = singleton 1*(&quot;-&quot; (2*8alphanum))
 332      */







































 333     if (len &lt; 0) {
 334         len = (int32_t)uprv_strlen(s);
 335     }
<span class="line-modified"> 336     if (len &gt;= 2 &amp;&amp; len &lt;= 8 &amp;&amp; _isAlphaNumericString(s, len)) {</span>
 337         return TRUE;
 338     }
 339     return FALSE;
 340 }
 341 
<span class="line-modified"> 342 static UBool</span>
<span class="line-modified"> 343 _isExtensionSubtags(const char* s, int32_t len) {</span>
<span class="line-modified"> 344     const char *p = s;</span>
<span class="line-modified"> 345     const char *pSubtag = NULL;</span>
<span class="line-modified"> 346 </span>
<span class="line-modified"> 347     if (len &lt; 0) {</span>
<span class="line-modified"> 348         len = (int32_t)uprv_strlen(s);</span>
<span class="line-removed"> 349     }</span>
 350 
<span class="line-modified"> 351     while ((p - s) &lt; len) {</span>
<span class="line-modified"> 352         if (*p == SEP) {</span>
<span class="line-modified"> 353             if (pSubtag == NULL) {</span>
<span class="line-modified"> 354                 return FALSE;</span>
<span class="line-modified"> 355             }</span>
<span class="line-modified"> 356             if (!_isExtensionSubtag(pSubtag, (int32_t)(p - pSubtag))) {</span>
<span class="line-removed"> 357                 return FALSE;</span>
<span class="line-removed"> 358             }</span>
<span class="line-removed"> 359             pSubtag = NULL;</span>
<span class="line-removed"> 360         } else if (pSubtag == NULL) {</span>
<span class="line-removed"> 361             pSubtag = p;</span>
<span class="line-removed"> 362         }</span>
<span class="line-removed"> 363         p++;</span>
<span class="line-removed"> 364     }</span>
<span class="line-removed"> 365     if (pSubtag == NULL) {</span>
<span class="line-removed"> 366         return FALSE;</span>
<span class="line-removed"> 367     }</span>
<span class="line-removed"> 368     return _isExtensionSubtag(pSubtag, (int32_t)(p - pSubtag));</span>
 369 }
 370 
 371 static UBool
<span class="line-modified"> 372 _isPrivateuseValueSubtag(const char* s, int32_t len) {</span>

 373     /*
<span class="line-modified"> 374      * privateuse    = &quot;x&quot; 1*(&quot;-&quot; (1*8alphanum))</span>
 375      */
 376     if (len &lt; 0) {
 377         len = (int32_t)uprv_strlen(s);
 378     }
<span class="line-modified"> 379     if (len &gt;= 1 &amp;&amp; len &lt;= 8 &amp;&amp; _isAlphaNumericString(s, len)) {</span>
 380         return TRUE;
 381     }
 382     return FALSE;
 383 }
 384 
 385 static UBool
<span class="line-modified"> 386 _isPrivateuseValueSubtags(const char* s, int32_t len) {</span>
<span class="line-modified"> 387     const char *p = s;</span>
<span class="line-modified"> 388     const char *pSubtag = NULL;</span>
<span class="line-modified"> 389 </span>
<span class="line-modified"> 390     if (len &lt; 0) {</span>
<span class="line-modified"> 391         len = (int32_t)uprv_strlen(s);</span>
<span class="line-modified"> 392     }</span>
 393 
<span class="line-modified"> 394     while ((p - s) &lt; len) {</span>
<span class="line-modified"> 395         if (*p == SEP) {</span>
<span class="line-modified"> 396             if (pSubtag == NULL) {</span>
<span class="line-modified"> 397                 return FALSE;</span>




















 398             }
<span class="line-modified"> 399             if (!_isPrivateuseValueSubtag(pSubtag, (int32_t)(p - pSubtag))) {</span>
<span class="line-modified"> 400                 return FALSE;</span>





















 401             }
<span class="line-modified"> 402             pSubtag = NULL;</span>
<span class="line-modified"> 403         } else if (pSubtag == NULL) {</span>
<span class="line-modified"> 404             pSubtag = p;</span>
<span class="line-modified"> 405         }</span>
<span class="line-modified"> 406         p++;</span>
<span class="line-modified"> 407     }</span>
<span class="line-modified"> 408     if (pSubtag == NULL) {</span>
<span class="line-modified"> 409         return FALSE;</span>








 410     }
<span class="line-modified"> 411     return _isPrivateuseValueSubtag(pSubtag, (int32_t)(p - pSubtag));</span>
 412 }
 413 
<span class="line-modified"> 414 U_CFUNC UBool</span>
<span class="line-modified"> 415 ultag_isUnicodeLocaleKey(const char* s, int32_t len) {</span>
<span class="line-modified"> 416     if (len &lt; 0) {</span>
<span class="line-modified"> 417         len = (int32_t)uprv_strlen(s);</span>
<span class="line-modified"> 418     }</span>
<span class="line-modified"> 419     if (len == 2 &amp;&amp; _isAlphaNumericString(s, len)) {</span>
<span class="line-modified"> 420         return TRUE;</span>




























 421     }
 422     return FALSE;
 423 }
 424 
<span class="line-modified"> 425 U_CFUNC UBool</span>
<span class="line-modified"> 426 ultag_isUnicodeLocaleType(const char*s, int32_t len) {</span>


 427     const char* p;

 428     int32_t subtagLen = 0;
 429 
 430     if (len &lt; 0) {
 431         len = (int32_t)uprv_strlen(s);
 432     }
 433 
 434     for (p = s; len &gt; 0; p++, len--) {
 435         if (*p == SEP) {
<span class="line-modified"> 436             if (subtagLen &lt; 3) {</span>
 437                 return FALSE;
 438             }
 439             subtagLen = 0;
<span class="line-modified"> 440         } else if (ISALPHA(*p) || ISNUMERIC(*p)) {</span>
<span class="line-removed"> 441             subtagLen++;</span>
<span class="line-removed"> 442             if (subtagLen &gt; 8) {</span>
<span class="line-removed"> 443                 return FALSE;</span>
<span class="line-removed"> 444             }</span>
 445         } else {
<span class="line-modified"> 446             return FALSE;</span>
 447         }
 448     }
 449 
<span class="line-modified"> 450     return (subtagLen &gt;= 3);</span>














 451 }


 452 /*
 453 * -------------------------------------------------
 454 *
 455 * Helper functions
 456 *
 457 * -------------------------------------------------
 458 */
 459 
 460 static UBool
 461 _addVariantToList(VariantListEntry **first, VariantListEntry *var) {
 462     UBool bAdded = TRUE;
 463 
 464     if (*first == NULL) {
 465         var-&gt;next = NULL;
 466         *first = var;
 467     } else {
 468         VariantListEntry *prev, *cur;
 469         int32_t cmp;
 470 
 471         /* variants order should be preserved */
</pre>
<hr />
<pre>
 618 _initializeULanguageTag(ULanguageTag* langtag) {
 619     int32_t i;
 620 
 621     langtag-&gt;buf = NULL;
 622 
 623     langtag-&gt;language = EMPTY;
 624     for (i = 0; i &lt; MAXEXTLANG; i++) {
 625         langtag-&gt;extlang[i] = NULL;
 626     }
 627 
 628     langtag-&gt;script = EMPTY;
 629     langtag-&gt;region = EMPTY;
 630 
 631     langtag-&gt;variants = NULL;
 632     langtag-&gt;extensions = NULL;
 633 
 634     langtag-&gt;grandfathered = EMPTY;
 635     langtag-&gt;privateuse = EMPTY;
 636 }
 637 
<span class="line-modified"> 638 static int32_t</span>
<span class="line-modified"> 639 _appendLanguageToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UErrorCode* status) {</span>
 640     char buf[ULOC_LANG_CAPACITY];
 641     UErrorCode tmpStatus = U_ZERO_ERROR;
 642     int32_t len, i;
<span class="line-removed"> 643     int32_t reslen = 0;</span>
 644 
 645     if (U_FAILURE(*status)) {
<span class="line-modified"> 646         return 0;</span>
 647     }
 648 
 649     len = uloc_getLanguage(localeID, buf, sizeof(buf), &amp;tmpStatus);
 650     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
 651         if (strict) {
 652             *status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified"> 653             return 0;</span>
 654         }
 655         len = 0;
 656     }
 657 
 658     /* Note: returned language code is in lower case letters */
 659 
 660     if (len == 0) {
<span class="line-modified"> 661         if (reslen &lt; capacity) {</span>
<span class="line-modified"> 662             uprv_memcpy(appendAt + reslen, LANG_UND, uprv_min(LANG_UND_LEN, capacity - reslen));</span>
<span class="line-removed"> 663         }</span>
<span class="line-removed"> 664         reslen += LANG_UND_LEN;</span>
<span class="line-removed"> 665     } else if (!_isLanguageSubtag(buf, len)) {</span>
 666             /* invalid language code */
 667         if (strict) {
 668             *status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified"> 669             return 0;</span>
<span class="line-removed"> 670         }</span>
<span class="line-removed"> 671         if (reslen &lt; capacity) {</span>
<span class="line-removed"> 672             uprv_memcpy(appendAt + reslen, LANG_UND, uprv_min(LANG_UND_LEN, capacity - reslen));</span>
 673         }
<span class="line-modified"> 674         reslen += LANG_UND_LEN;</span>
 675     } else {
 676         /* resolve deprecated */
 677         for (i = 0; i &lt; UPRV_LENGTHOF(DEPRECATEDLANGS); i += 2) {





 678             if (uprv_compareInvCharsAsAscii(buf, DEPRECATEDLANGS[i]) == 0) {
 679                 uprv_strcpy(buf, DEPRECATEDLANGS[i + 1]);
 680                 len = (int32_t)uprv_strlen(buf);
 681                 break;
 682             }
 683         }
<span class="line-modified"> 684         if (reslen &lt; capacity) {</span>
<span class="line-removed"> 685             uprv_memcpy(appendAt + reslen, buf, uprv_min(len, capacity - reslen));</span>
<span class="line-removed"> 686         }</span>
<span class="line-removed"> 687         reslen += len;</span>
 688     }
<span class="line-removed"> 689     u_terminateChars(appendAt, capacity, reslen, status);</span>
<span class="line-removed"> 690     return reslen;</span>
 691 }
 692 
<span class="line-modified"> 693 static int32_t</span>
<span class="line-modified"> 694 _appendScriptToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UErrorCode* status) {</span>
 695     char buf[ULOC_SCRIPT_CAPACITY];
 696     UErrorCode tmpStatus = U_ZERO_ERROR;
 697     int32_t len;
<span class="line-removed"> 698     int32_t reslen = 0;</span>
 699 
 700     if (U_FAILURE(*status)) {
<span class="line-modified"> 701         return 0;</span>
 702     }
 703 
 704     len = uloc_getScript(localeID, buf, sizeof(buf), &amp;tmpStatus);
 705     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
 706         if (strict) {
 707             *status = U_ILLEGAL_ARGUMENT_ERROR;
 708         }
<span class="line-modified"> 709         return 0;</span>
 710     }
 711 
 712     if (len &gt; 0) {
<span class="line-modified"> 713         if (!_isScriptSubtag(buf, len)) {</span>
 714             /* invalid script code */
 715             if (strict) {
 716                 *status = U_ILLEGAL_ARGUMENT_ERROR;
 717             }
<span class="line-modified"> 718             return 0;</span>
 719         } else {
<span class="line-modified"> 720             if (reslen &lt; capacity) {</span>
<span class="line-modified"> 721                 *(appendAt + reslen) = SEP;</span>
<span class="line-removed"> 722             }</span>
<span class="line-removed"> 723             reslen++;</span>
<span class="line-removed"> 724 </span>
<span class="line-removed"> 725             if (reslen &lt; capacity) {</span>
<span class="line-removed"> 726                 uprv_memcpy(appendAt + reslen, buf, uprv_min(len, capacity - reslen));</span>
<span class="line-removed"> 727             }</span>
<span class="line-removed"> 728             reslen += len;</span>
 729         }
 730     }
<span class="line-removed"> 731     u_terminateChars(appendAt, capacity, reslen, status);</span>
<span class="line-removed"> 732     return reslen;</span>
 733 }
 734 
<span class="line-modified"> 735 static int32_t</span>
<span class="line-modified"> 736 _appendRegionToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UErrorCode* status) {</span>
 737     char buf[ULOC_COUNTRY_CAPACITY];
 738     UErrorCode tmpStatus = U_ZERO_ERROR;
 739     int32_t len;
<span class="line-removed"> 740     int32_t reslen = 0;</span>
 741 
 742     if (U_FAILURE(*status)) {
<span class="line-modified"> 743         return 0;</span>
 744     }
 745 
 746     len = uloc_getCountry(localeID, buf, sizeof(buf), &amp;tmpStatus);
 747     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
 748         if (strict) {
 749             *status = U_ILLEGAL_ARGUMENT_ERROR;
 750         }
<span class="line-modified"> 751         return 0;</span>
 752     }
 753 
 754     if (len &gt; 0) {
<span class="line-modified"> 755         if (!_isRegionSubtag(buf, len)) {</span>
 756             /* invalid region code */
 757             if (strict) {
 758                 *status = U_ILLEGAL_ARGUMENT_ERROR;
 759             }
<span class="line-modified"> 760             return 0;</span>
 761         } else {
<span class="line-modified"> 762             if (reslen &lt; capacity) {</span>
<span class="line-modified"> 763                 *(appendAt + reslen) = SEP;</span>
<span class="line-modified"> 764             }</span>
<span class="line-modified"> 765             reslen++;</span>
<span class="line-modified"> 766 </span>
<span class="line-modified"> 767             if (reslen &lt; capacity) {</span>
<span class="line-modified"> 768                 uprv_memcpy(appendAt + reslen, buf, uprv_min(len, capacity - reslen));</span>

 769             }
<span class="line-modified"> 770             reslen += len;</span>
 771         }
 772     }
<span class="line-removed"> 773     u_terminateChars(appendAt, capacity, reslen, status);</span>
<span class="line-removed"> 774     return reslen;</span>
 775 }
 776 
<span class="line-modified"> 777 static int32_t</span>
<span class="line-modified"> 778 _appendVariantsToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UBool *hadPosix, UErrorCode* status) {</span>
 779     char buf[ULOC_FULLNAME_CAPACITY];
 780     UErrorCode tmpStatus = U_ZERO_ERROR;
 781     int32_t len, i;
<span class="line-removed"> 782     int32_t reslen = 0;</span>
 783 
 784     if (U_FAILURE(*status)) {
<span class="line-modified"> 785         return 0;</span>
 786     }
 787 
 788     len = uloc_getVariant(localeID, buf, sizeof(buf), &amp;tmpStatus);
 789     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
 790         if (strict) {
 791             *status = U_ILLEGAL_ARGUMENT_ERROR;
 792         }
<span class="line-modified"> 793         return 0;</span>
 794     }
 795 
 796     if (len &gt; 0) {
 797         char *p, *pVar;
 798         UBool bNext = TRUE;
 799         VariantListEntry *var;
 800         VariantListEntry *varFirst = NULL;
 801 
 802         pVar = NULL;
 803         p = buf;
 804         while (bNext) {
 805             if (*p == SEP || *p == LOCALE_SEP || *p == 0) {
 806                 if (*p == 0) {
 807                     bNext = FALSE;
 808                 } else {
 809                     *p = 0; /* terminate */
 810                 }
 811                 if (pVar == NULL) {
 812                     if (strict) {
 813                         *status = U_ILLEGAL_ARGUMENT_ERROR;
</pre>
<hr />
<pre>
 850                     } else if (_isPrivateuseValueSubtag(pVar, -1)) {
 851                         /* Handle private use subtags separately */
 852                         break;
 853                     }
 854                 }
 855                 /* reset variant starting position */
 856                 pVar = NULL;
 857             } else if (pVar == NULL) {
 858                 pVar = p;
 859             }
 860             p++;
 861         }
 862 
 863         if (U_SUCCESS(*status)) {
 864             if (varFirst != NULL) {
 865                 int32_t varLen;
 866 
 867                 /* write out validated/normalized variants to the target */
 868                 var = varFirst;
 869                 while (var != NULL) {
<span class="line-modified"> 870                     if (reslen &lt; capacity) {</span>
<span class="line-removed"> 871                         *(appendAt + reslen) = SEP;</span>
<span class="line-removed"> 872                     }</span>
<span class="line-removed"> 873                     reslen++;</span>
 874                     varLen = (int32_t)uprv_strlen(var-&gt;variant);
<span class="line-modified"> 875                     if (reslen &lt; capacity) {</span>
<span class="line-removed"> 876                         uprv_memcpy(appendAt + reslen, var-&gt;variant, uprv_min(varLen, capacity - reslen));</span>
<span class="line-removed"> 877                     }</span>
<span class="line-removed"> 878                     reslen += varLen;</span>
 879                     var = var-&gt;next;
 880                 }
 881             }
 882         }
 883 
 884         /* clean up */
 885         var = varFirst;
 886         while (var != NULL) {
 887             VariantListEntry *tmpVar = var-&gt;next;
 888             uprv_free(var);
 889             var = tmpVar;
 890         }
 891 
 892         if (U_FAILURE(*status)) {
<span class="line-modified"> 893             return 0;</span>
 894         }
 895     }
<span class="line-removed"> 896 </span>
<span class="line-removed"> 897     u_terminateChars(appendAt, capacity, reslen, status);</span>
<span class="line-removed"> 898     return reslen;</span>
 899 }
 900 
<span class="line-modified"> 901 static int32_t</span>
<span class="line-modified"> 902 _appendKeywordsToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UBool hadPosix, UErrorCode* status) {</span>
<span class="line-removed"> 903     char buf[ULOC_KEYWORD_AND_VALUES_CAPACITY];</span>
 904     char attrBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY] = { 0 };
 905     int32_t attrBufLength = 0;
<span class="line-removed"> 906     UEnumeration *keywordEnum = NULL;</span>
<span class="line-removed"> 907     int32_t reslen = 0;</span>
 908 
<span class="line-modified"> 909     keywordEnum = uloc_openKeywords(localeID, status);</span>




 910     if (U_FAILURE(*status) &amp;&amp; !hadPosix) {
<span class="line-modified"> 911         uenum_close(keywordEnum);</span>
<span class="line-removed"> 912         return 0;</span>
 913     }
<span class="line-modified"> 914     if (keywordEnum != NULL || hadPosix) {</span>
 915         /* reorder extensions */
 916         int32_t len;
 917         const char *key;
 918         ExtensionListEntry *firstExt = NULL;
 919         ExtensionListEntry *ext;
 920         AttributeListEntry *firstAttr = NULL;
 921         AttributeListEntry *attr;
<span class="line-modified"> 922         char *attrValue;</span>
<span class="line-removed"> 923         char extBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY];</span>
<span class="line-removed"> 924         char *pExtBuf = extBuf;</span>
<span class="line-removed"> 925         int32_t extBufCapacity = sizeof(extBuf);</span>
 926         const char *bcpKey=nullptr, *bcpValue=nullptr;
 927         UErrorCode tmpStatus = U_ZERO_ERROR;
 928         int32_t keylen;
 929         UBool isBcpUExt;
 930 
 931         while (TRUE) {
<span class="line-modified"> 932             key = uenum_next(keywordEnum, NULL, status);</span>

 933             if (key == NULL) {
 934                 break;
 935             }
<span class="line-modified"> 936             len = uloc_getKeywordValue(localeID, key, buf, sizeof(buf), &amp;tmpStatus);</span>
<span class="line-modified"> 937             /* buf must be null-terminated */</span>
<span class="line-modified"> 938             if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {</span>



























 939                 if (strict) {
 940                     *status = U_ILLEGAL_ARGUMENT_ERROR;
 941                     break;
 942                 }
 943                 /* ignore this keyword */
 944                 tmpStatus = U_ZERO_ERROR;
 945                 continue;
 946             }
 947 





 948             keylen = (int32_t)uprv_strlen(key);
 949             isBcpUExt = (keylen &gt; 1);
 950 
 951             /* special keyword used for representing Unicode locale attributes */
 952             if (uprv_strcmp(key, LOCALE_ATTRIBUTE_KEY) == 0) {
 953                 if (len &gt; 0) {
 954                     int32_t i = 0;
 955                     while (TRUE) {
 956                         attrBufLength = 0;
 957                         for (; i &lt; len; i++) {
 958                             if (buf[i] != &#39;-&#39;) {
 959                                 attrBuf[attrBufLength++] = buf[i];
 960                             } else {
 961                                 i++;
 962                                 break;
 963                             }
 964                         }
 965                         if (attrBufLength &gt; 0) {
 966                             attrBuf[attrBufLength] = 0;
 967 
 968                         } else if (i &gt;= len){
 969                             break;
 970                         }
 971 
 972                         /* create AttributeListEntry */
<span class="line-modified"> 973                         attr = (AttributeListEntry*)uprv_malloc(sizeof(AttributeListEntry));</span>
 974                         if (attr == NULL) {
 975                             *status = U_MEMORY_ALLOCATION_ERROR;
 976                             break;
 977                         }
<span class="line-modified"> 978                         attrValue = (char*)uprv_malloc(attrBufLength + 1);</span>

 979                         if (attrValue == NULL) {
 980                             *status = U_MEMORY_ALLOCATION_ERROR;
 981                             break;
 982                         }
<span class="line-modified"> 983                         uprv_strcpy(attrValue, attrBuf);</span>
<span class="line-modified"> 984                         attr-&gt;attribute = attrValue;</span>


 985 
 986                         if (!_addAttributeToList(&amp;firstAttr, attr)) {
<span class="line-removed"> 987                             uprv_free(attr);</span>
<span class="line-removed"> 988                             uprv_free(attrValue);</span>
 989                             if (strict) {
 990                                 *status = U_ILLEGAL_ARGUMENT_ERROR;
 991                                 break;
 992                             }
 993                         }
 994                     }
 995                     /* for a place holder ExtensionListEntry */
 996                     bcpKey = LOCALE_ATTRIBUTE_KEY;
 997                     bcpValue = NULL;
 998                 }
 999             } else if (isBcpUExt) {
1000                 bcpKey = uloc_toUnicodeLocaleKey(key);
1001                 if (bcpKey == NULL) {
1002                     if (strict) {
1003                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1004                         break;
1005                     }
1006                     continue;
1007                 }
1008 
1009                 /* we&#39;ve checked buf is null-terminated above */
<span class="line-modified">1010                 bcpValue = uloc_toUnicodeLocaleType(key, buf);</span>
1011                 if (bcpValue == NULL) {
1012                     if (strict) {
1013                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1014                         break;
1015                     }
1016                     continue;
1017                 }
<span class="line-modified">1018                 if (bcpValue == buf) {</span>
1019                     /*
1020                     When uloc_toUnicodeLocaleType(key, buf) returns the
1021                     input value as is, the value is well-formed, but has
1022                     no known mapping. This implementation normalizes the
<span class="line-modified">1023                     the value to lower case</span>
1024                     */





1025                     int32_t bcpValueLen = static_cast&lt;int32_t&gt;(uprv_strlen(bcpValue));
<span class="line-modified">1026                     if (bcpValueLen &lt; extBufCapacity) {</span>
<span class="line-modified">1027                         uprv_strcpy(pExtBuf, bcpValue);</span>
<span class="line-modified">1028                         T_CString_toLowerCase(pExtBuf);</span>







1029 
<span class="line-modified">1030                         bcpValue = pExtBuf;</span>

1031 
<span class="line-modified">1032                         pExtBuf += (bcpValueLen + 1);</span>
<span class="line-modified">1033                         extBufCapacity -= (bcpValueLen + 1);</span>
<span class="line-modified">1034                     } else {</span>
<span class="line-modified">1035                         if (strict) {</span>
<span class="line-removed">1036                             *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-removed">1037                             break;</span>
<span class="line-removed">1038                         }</span>
<span class="line-removed">1039                         continue;</span>
1040                     }


1041                 }
1042             } else {
1043                 if (*key == PRIVATEUSE) {
<span class="line-modified">1044                     if (!_isPrivateuseValueSubtags(buf, len)) {</span>
1045                         if (strict) {
1046                             *status = U_ILLEGAL_ARGUMENT_ERROR;
1047                             break;
1048                         }
1049                         continue;
1050                     }
1051                 } else {
<span class="line-modified">1052                     if (!_isExtensionSingleton(key, keylen) || !_isExtensionSubtags(buf, len)) {</span>
1053                         if (strict) {
1054                             *status = U_ILLEGAL_ARGUMENT_ERROR;
1055                             break;
1056                         }
1057                         continue;
1058                     }
1059                 }
1060                 bcpKey = key;
<span class="line-modified">1061                 if ((len + 1) &lt; extBufCapacity) {</span>
<span class="line-modified">1062                     uprv_memcpy(pExtBuf, buf, len);</span>
<span class="line-modified">1063                     bcpValue = pExtBuf;</span>
<span class="line-modified">1064 </span>
<span class="line-modified">1065                     pExtBuf += len;</span>
<span class="line-modified">1066 </span>
<span class="line-modified">1067                     *pExtBuf = 0;</span>
<span class="line-modified">1068                     pExtBuf++;</span>
<span class="line-removed">1069 </span>
<span class="line-removed">1070                     extBufCapacity -= (len + 1);</span>
<span class="line-removed">1071                 } else {</span>
<span class="line-removed">1072                     *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
1073                     break;
1074                 }

1075             }
1076 
1077             /* create ExtensionListEntry */
<span class="line-modified">1078             ext = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));</span>
1079             if (ext == NULL) {
1080                 *status = U_MEMORY_ALLOCATION_ERROR;
1081                 break;
1082             }
1083             ext-&gt;key = bcpKey;
1084             ext-&gt;value = bcpValue;
1085 
1086             if (!_addExtensionToList(&amp;firstExt, ext, TRUE)) {
<span class="line-removed">1087                 uprv_free(ext);</span>
1088                 if (strict) {
1089                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1090                     break;
1091                 }
1092             }
1093         }
1094 
1095         /* Special handling for POSIX variant - add the keywords for POSIX */
1096         if (hadPosix) {
1097             /* create ExtensionListEntry for POSIX */
<span class="line-modified">1098             ext = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));</span>
1099             if (ext == NULL) {
1100                 *status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified">1101                 goto cleanup;</span>
1102             }
1103             ext-&gt;key = POSIX_KEY;
1104             ext-&gt;value = POSIX_VALUE;
1105 
1106             if (!_addExtensionToList(&amp;firstExt, ext, TRUE)) {
<span class="line-modified">1107                 uprv_free(ext);</span>
1108             }
1109         }
1110 
1111         if (U_SUCCESS(*status) &amp;&amp; (firstExt != NULL || firstAttr != NULL)) {
1112             UBool startLDMLExtension = FALSE;
1113             for (ext = firstExt; ext; ext = ext-&gt;next) {
1114                 if (!startLDMLExtension &amp;&amp; uprv_strlen(ext-&gt;key) &gt; 1) {
1115                     /* first LDML u singlton extension */
<span class="line-modified">1116                    if (reslen &lt; capacity) {</span>
<span class="line-removed">1117                        *(appendAt + reslen) = SEP;</span>
<span class="line-removed">1118                    }</span>
<span class="line-removed">1119                    reslen++;</span>
<span class="line-removed">1120                    if (reslen &lt; capacity) {</span>
<span class="line-removed">1121                        *(appendAt + reslen) = LDMLEXT;</span>
<span class="line-removed">1122                    }</span>
<span class="line-removed">1123                    reslen++;</span>
<span class="line-removed">1124 </span>
1125                    startLDMLExtension = TRUE;
1126                 }
1127 
1128                 /* write out the sorted BCP47 attributes, extensions and private use */
1129                 if (uprv_strcmp(ext-&gt;key, LOCALE_ATTRIBUTE_KEY) == 0) {
1130                     /* write the value for the attributes */
1131                     for (attr = firstAttr; attr; attr = attr-&gt;next) {
<span class="line-modified">1132                         if (reslen &lt; capacity) {</span>
<span class="line-modified">1133                             *(appendAt + reslen) = SEP;</span>
<span class="line-modified">1134                         }</span>
<span class="line-removed">1135                         reslen++;</span>
<span class="line-removed">1136                         len = (int32_t)uprv_strlen(attr-&gt;attribute);</span>
<span class="line-removed">1137                         if (reslen &lt; capacity) {</span>
<span class="line-removed">1138                             uprv_memcpy(appendAt + reslen, attr-&gt;attribute, uprv_min(len, capacity - reslen));</span>
<span class="line-removed">1139                         }</span>
<span class="line-removed">1140                         reslen += len;</span>
1141                     }
1142                 } else {
<span class="line-modified">1143                     if (reslen &lt; capacity) {</span>
<span class="line-modified">1144                         *(appendAt + reslen) = SEP;</span>
<span class="line-modified">1145                     }</span>
<span class="line-modified">1146                     reslen++;</span>
<span class="line-removed">1147                     len = (int32_t)uprv_strlen(ext-&gt;key);</span>
<span class="line-removed">1148                     if (reslen &lt; capacity) {</span>
<span class="line-removed">1149                         uprv_memcpy(appendAt + reslen, ext-&gt;key, uprv_min(len, capacity - reslen));</span>
<span class="line-removed">1150                     }</span>
<span class="line-removed">1151                     reslen += len;</span>
<span class="line-removed">1152                     if (reslen &lt; capacity) {</span>
<span class="line-removed">1153                         *(appendAt + reslen) = SEP;</span>
<span class="line-removed">1154                     }</span>
<span class="line-removed">1155                     reslen++;</span>
<span class="line-removed">1156                     len = (int32_t)uprv_strlen(ext-&gt;value);</span>
<span class="line-removed">1157                     if (reslen &lt; capacity) {</span>
<span class="line-removed">1158                         uprv_memcpy(appendAt + reslen, ext-&gt;value, uprv_min(len, capacity - reslen));</span>
<span class="line-removed">1159                     }</span>
<span class="line-removed">1160                     reslen += len;</span>
1161                 }
1162             }
1163         }
<span class="line-removed">1164 cleanup:</span>
<span class="line-removed">1165         /* clean up */</span>
<span class="line-removed">1166         ext = firstExt;</span>
<span class="line-removed">1167         while (ext != NULL) {</span>
<span class="line-removed">1168             ExtensionListEntry *tmpExt = ext-&gt;next;</span>
<span class="line-removed">1169             uprv_free(ext);</span>
<span class="line-removed">1170             ext = tmpExt;</span>
<span class="line-removed">1171         }</span>
<span class="line-removed">1172 </span>
<span class="line-removed">1173         attr = firstAttr;</span>
<span class="line-removed">1174         while (attr != NULL) {</span>
<span class="line-removed">1175             AttributeListEntry *tmpAttr = attr-&gt;next;</span>
<span class="line-removed">1176             char *pValue = (char *)attr-&gt;attribute;</span>
<span class="line-removed">1177             uprv_free(pValue);</span>
<span class="line-removed">1178             uprv_free(attr);</span>
<span class="line-removed">1179             attr = tmpAttr;</span>
<span class="line-removed">1180         }</span>
<span class="line-removed">1181 </span>
<span class="line-removed">1182         uenum_close(keywordEnum);</span>
<span class="line-removed">1183 </span>
<span class="line-removed">1184         if (U_FAILURE(*status)) {</span>
<span class="line-removed">1185             return 0;</span>
<span class="line-removed">1186         }</span>
1187     }
<span class="line-removed">1188 </span>
<span class="line-removed">1189     return u_terminateChars(appendAt, capacity, reslen, status);</span>
1190 }
1191 
1192 /**
1193  * Append keywords parsed from LDML extension value
1194  * e.g. &quot;u-ca-gregory-co-trad&quot; -&gt; {calendar = gregorian} {collation = traditional}
1195  * Note: char* buf is used for storing keywords
1196  */
1197 static void
<span class="line-modified">1198 _appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendTo, char* buf, int32_t bufSize, UBool *posixVariant, UErrorCode *status) {</span>
1199     const char *pTag;   /* beginning of current subtag */
1200     const char *pKwds;  /* beginning of key-type pairs */
1201     UBool variantExists = *posixVariant;
1202 
1203     ExtensionListEntry *kwdFirst = NULL;    /* first LDML keyword */
1204     ExtensionListEntry *kwd, *nextKwd;
1205 
<span class="line-removed">1206     AttributeListEntry *attrFirst = NULL;   /* first attribute */</span>
<span class="line-removed">1207     AttributeListEntry *attr, *nextAttr;</span>
<span class="line-removed">1208 </span>
1209     int32_t len;
<span class="line-removed">1210     int32_t bufIdx = 0;</span>
<span class="line-removed">1211 </span>
<span class="line-removed">1212     char attrBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY];</span>
<span class="line-removed">1213     int32_t attrBufIdx = 0;</span>
1214 
1215     /* Reset the posixVariant value */
1216     *posixVariant = FALSE;
1217 
1218     pTag = ldmlext;
1219     pKwds = NULL;
1220 
<span class="line-modified">1221     /* Iterate through u extension attributes */</span>
<span class="line-modified">1222     while (*pTag) {</span>
<span class="line-modified">1223         /* locate next separator char */</span>
<span class="line-removed">1224         for (len = 0; *(pTag + len) &amp;&amp; *(pTag + len) != SEP; len++);</span>
1225 
<span class="line-modified">1226         if (ultag_isUnicodeLocaleKey(pTag, len)) {</span>
<span class="line-modified">1227             pKwds = pTag;</span>
<span class="line-removed">1228             break;</span>
<span class="line-removed">1229         }</span>
1230 
<span class="line-modified">1231         /* add this attribute to the list */</span>
<span class="line-removed">1232         attr = (AttributeListEntry*)uprv_malloc(sizeof(AttributeListEntry));</span>
<span class="line-removed">1233         if (attr == NULL) {</span>
<span class="line-removed">1234             *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">1235             goto cleanup;</span>
<span class="line-removed">1236         }</span>
1237 
<span class="line-modified">1238         if (len &lt; (int32_t)sizeof(attrBuf) - attrBufIdx) {</span>
<span class="line-modified">1239             uprv_memcpy(&amp;attrBuf[attrBufIdx], pTag, len);</span>
<span class="line-modified">1240             attrBuf[attrBufIdx + len] = 0;</span>
<span class="line-modified">1241             attr-&gt;attribute = &amp;attrBuf[attrBufIdx];</span>
<span class="line-removed">1242             attrBufIdx += (len + 1);</span>
<span class="line-removed">1243         } else {</span>
<span class="line-removed">1244             *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-removed">1245             goto cleanup;</span>
<span class="line-removed">1246         }</span>
1247 
<span class="line-modified">1248         if (!_addAttributeToList(&amp;attrFirst, attr)) {</span>
<span class="line-modified">1249             *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-modified">1250             uprv_free(attr);</span>
<span class="line-modified">1251             goto cleanup;</span>
<span class="line-removed">1252         }</span>
1253 
<span class="line-modified">1254         /* next tag */</span>
<span class="line-modified">1255         pTag += len;</span>
<span class="line-modified">1256         if (*pTag) {</span>
<span class="line-modified">1257             /* next to the separator */</span>
<span class="line-modified">1258             pTag++;</span>
<span class="line-modified">1259         }</span>
<span class="line-removed">1260     }</span>
1261 
<span class="line-modified">1262     if (attrFirst) {</span>
<span class="line-modified">1263         /* emit attributes as an LDML keyword, e.g. attribute=attr1-attr2 */</span>







1264 
<span class="line-modified">1265         if (attrBufIdx &gt; bufSize) {</span>
<span class="line-modified">1266             /* attrBufIdx == &lt;total length of attribute subtag&gt; + 1 */</span>
<span class="line-modified">1267             *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-modified">1268             goto cleanup;</span>
<span class="line-removed">1269         }</span>
1270 
<span class="line-modified">1271         kwd = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));</span>
<span class="line-modified">1272         if (kwd == NULL) {</span>
<span class="line-modified">1273             *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1274             goto cleanup;</span>


1275         }
1276 
<span class="line-modified">1277         kwd-&gt;key = LOCALE_ATTRIBUTE_KEY;</span>
<span class="line-modified">1278         kwd-&gt;value = buf;</span>
1279 
<span class="line-modified">1280         /* attribute subtags sorted in alphabetical order as type */</span>
<span class="line-modified">1281         attr = attrFirst;</span>
<span class="line-modified">1282         while (attr != NULL) {</span>
<span class="line-modified">1283             nextAttr = attr-&gt;next;</span>
<span class="line-removed">1284 </span>
<span class="line-removed">1285             /* buffer size check is done above */</span>
<span class="line-removed">1286             if (attr != attrFirst) {</span>
<span class="line-removed">1287                 *(buf + bufIdx) = SEP;</span>
<span class="line-removed">1288                 bufIdx++;</span>
1289             }
1290 
<span class="line-modified">1291             len = static_cast&lt;int32_t&gt;(uprv_strlen(attr-&gt;attribute));</span>
<span class="line-modified">1292             uprv_memcpy(buf + bufIdx, attr-&gt;attribute, len);</span>
<span class="line-modified">1293             bufIdx += len;</span>


1294 
<span class="line-modified">1295             attr = nextAttr;</span>
<span class="line-modified">1296         }</span>
<span class="line-modified">1297         *(buf + bufIdx) = 0;</span>
<span class="line-modified">1298         bufIdx++;</span>









1299 
<span class="line-modified">1300         if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {</span>
<span class="line-modified">1301             *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-removed">1302             uprv_free(kwd);</span>
<span class="line-removed">1303             goto cleanup;</span>
<span class="line-removed">1304         }</span>
1305 
<span class="line-modified">1306         /* once keyword entry is created, delete the attribute list */</span>
<span class="line-modified">1307         attr = attrFirst;</span>
<span class="line-modified">1308         while (attr != NULL) {</span>
<span class="line-modified">1309             nextAttr = attr-&gt;next;</span>
<span class="line-removed">1310             uprv_free(attr);</span>
<span class="line-removed">1311             attr = nextAttr;</span>
1312         }
<span class="line-removed">1313         attrFirst = NULL;</span>
1314     }
1315 
1316     if (pKwds) {
1317         const char *pBcpKey = NULL;     /* u extenstion key subtag */
1318         const char *pBcpType = NULL;    /* beginning of u extension type subtag(s) */
1319         int32_t bcpKeyLen = 0;
1320         int32_t bcpTypeLen = 0;
1321         UBool isDone = FALSE;
1322 
1323         pTag = pKwds;
1324         /* BCP47 representation of LDML key/type pairs */
1325         while (!isDone) {
1326             const char *pNextBcpKey = NULL;
1327             int32_t nextBcpKeyLen = 0;
1328             UBool emitKeyword = FALSE;
1329 
1330             if (*pTag) {
1331                 /* locate next separator char */
1332                 for (len = 0; *(pTag + len) &amp;&amp; *(pTag + len) != SEP; len++);
1333 
</pre>
<hr />
<pre>
1357                     /* next to the separator */
1358                     pTag++;
1359                 }
1360             } else {
1361                 /* processing last one */
1362                 emitKeyword = TRUE;
1363                 isDone = TRUE;
1364             }
1365 
1366             if (emitKeyword) {
1367                 const char *pKey = NULL;    /* LDML key */
1368                 const char *pType = NULL;   /* LDML type */
1369 
1370                 char bcpKeyBuf[9];          /* BCP key length is always 2 for now */
1371 
1372                 U_ASSERT(pBcpKey != NULL);
1373 
1374                 if (bcpKeyLen &gt;= (int32_t)sizeof(bcpKeyBuf)) {
1375                     /* the BCP key is invalid */
1376                     *status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">1377                     goto cleanup;</span>
1378                 }
1379 
1380                 uprv_strncpy(bcpKeyBuf, pBcpKey, bcpKeyLen);
1381                 bcpKeyBuf[bcpKeyLen] = 0;
1382 
1383                 /* u extension key to LDML key */
1384                 pKey = uloc_toLegacyKey(bcpKeyBuf);
1385                 if (pKey == NULL) {
1386                     *status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">1387                     goto cleanup;</span>
1388                 }
1389                 if (pKey == bcpKeyBuf) {
1390                     /*
1391                     The key returned by toLegacyKey points to the input buffer.
1392                     We normalize the result key to lower case.
1393                     */
1394                     T_CString_toLowerCase(bcpKeyBuf);
<span class="line-modified">1395                     if (bufSize - bufIdx - 1 &gt;= bcpKeyLen) {</span>
<span class="line-modified">1396                         uprv_memcpy(buf + bufIdx, bcpKeyBuf, bcpKeyLen);</span>
<span class="line-modified">1397                         pKey = buf + bufIdx;</span>
<span class="line-modified">1398                         bufIdx += bcpKeyLen;</span>
<span class="line-modified">1399                         *(buf + bufIdx) = 0;</span>
<span class="line-modified">1400                         bufIdx++;</span>
<span class="line-modified">1401                     } else {</span>
<span class="line-removed">1402                         *status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-removed">1403                         goto cleanup;</span>
1404                     }

1405                 }
1406 
1407                 if (pBcpType) {
1408                     char bcpTypeBuf[128];       /* practically long enough even considering multiple subtag type */
1409                     if (bcpTypeLen &gt;= (int32_t)sizeof(bcpTypeBuf)) {
1410                         /* the BCP type is too long */
1411                         *status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">1412                         goto cleanup;</span>
1413                     }
1414 
1415                     uprv_strncpy(bcpTypeBuf, pBcpType, bcpTypeLen);
1416                     bcpTypeBuf[bcpTypeLen] = 0;
1417 
1418                     /* BCP type to locale type */
1419                     pType = uloc_toLegacyType(pKey, bcpTypeBuf);
1420                     if (pType == NULL) {
1421                         *status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">1422                         goto cleanup;</span>
1423                     }
1424                     if (pType == bcpTypeBuf) {
1425                         /*
1426                         The type returned by toLegacyType points to the input buffer.
1427                         We normalize the result type to lower case.
1428                         */
1429                         /* normalize to lower case */
1430                         T_CString_toLowerCase(bcpTypeBuf);
<span class="line-modified">1431                         if (bufSize - bufIdx - 1 &gt;= bcpTypeLen) {</span>
<span class="line-modified">1432                             uprv_memcpy(buf + bufIdx, bcpTypeBuf, bcpTypeLen);</span>
<span class="line-modified">1433                             pType = buf + bufIdx;</span>
<span class="line-modified">1434                             bufIdx += bcpTypeLen;</span>
<span class="line-removed">1435                             *(buf + bufIdx) = 0;</span>
<span class="line-removed">1436                             bufIdx++;</span>
<span class="line-removed">1437                         } else {</span>
<span class="line-removed">1438                             *status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-removed">1439                             goto cleanup;</span>
1440                         }




1441                     }
1442                 } else {
1443                     /* typeless - default type value is &quot;yes&quot; */
1444                     pType = LOCALE_TYPE_YES;
1445                 }
1446 
1447                 /* Special handling for u-va-posix, since we want to treat this as a variant,
1448                    not as a keyword */
1449                 if (!variantExists &amp;&amp; !uprv_strcmp(pKey, POSIX_KEY) &amp;&amp; !uprv_strcmp(pType, POSIX_VALUE) ) {
1450                     *posixVariant = TRUE;
1451                 } else {
1452                     /* create an ExtensionListEntry for this keyword */
<span class="line-modified">1453                     kwd = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));</span>
1454                     if (kwd == NULL) {
1455                         *status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified">1456                         goto cleanup;</span>
1457                     }
1458 
1459                     kwd-&gt;key = pKey;
1460                     kwd-&gt;value = pType;
1461 
1462                     if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {
<span class="line-modified">1463                         *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-modified">1464                         uprv_free(kwd);</span>
<span class="line-removed">1465                         goto cleanup;</span>
1466                     }
1467                 }
1468 
1469                 pBcpKey = pNextBcpKey;
1470                 bcpKeyLen = pNextBcpKey != NULL ? nextBcpKeyLen : 0;
1471                 pBcpType = NULL;
1472                 bcpTypeLen = 0;
1473             }
1474         }
1475     }
1476 
1477     kwd = kwdFirst;
1478     while (kwd != NULL) {
1479         nextKwd = kwd-&gt;next;
1480         _addExtensionToList(appendTo, kwd, FALSE);
1481         kwd = nextKwd;
1482     }
<span class="line-removed">1483 </span>
<span class="line-removed">1484     return;</span>
<span class="line-removed">1485 </span>
<span class="line-removed">1486 cleanup:</span>
<span class="line-removed">1487     attr = attrFirst;</span>
<span class="line-removed">1488     while (attr != NULL) {</span>
<span class="line-removed">1489         nextAttr = attr-&gt;next;</span>
<span class="line-removed">1490         uprv_free(attr);</span>
<span class="line-removed">1491         attr = nextAttr;</span>
<span class="line-removed">1492     }</span>
<span class="line-removed">1493 </span>
<span class="line-removed">1494     kwd = kwdFirst;</span>
<span class="line-removed">1495     while (kwd != NULL) {</span>
<span class="line-removed">1496         nextKwd = kwd-&gt;next;</span>
<span class="line-removed">1497         uprv_free(kwd);</span>
<span class="line-removed">1498         kwd = nextKwd;</span>
<span class="line-removed">1499     }</span>
1500 }
1501 
1502 
<span class="line-modified">1503 static int32_t</span>
<span class="line-modified">1504 _appendKeywords(ULanguageTag* langtag, char* appendAt, int32_t capacity, UErrorCode* status) {</span>
<span class="line-removed">1505     int32_t reslen = 0;</span>
1506     int32_t i, n;
1507     int32_t len;
1508     ExtensionListEntry *kwdFirst = NULL;
1509     ExtensionListEntry *kwd;
1510     const char *key, *type;
<span class="line-modified">1511     char *kwdBuf = NULL;</span>
<span class="line-modified">1512     int32_t kwdBufLength = capacity;</span>
1513     UBool posixVariant = FALSE;
1514 
1515     if (U_FAILURE(*status)) {
<span class="line-modified">1516         return 0;</span>
<span class="line-removed">1517     }</span>
<span class="line-removed">1518 </span>
<span class="line-removed">1519     kwdBuf = (char*)uprv_malloc(kwdBufLength);</span>
<span class="line-removed">1520     if (kwdBuf == NULL) {</span>
<span class="line-removed">1521         *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-removed">1522         return 0;</span>
1523     }
1524 
1525     /* Determine if variants already exists */
1526     if (ultag_getVariantsSize(langtag)) {
1527         posixVariant = TRUE;
1528     }
1529 
1530     n = ultag_getExtensionsSize(langtag);
1531 
1532     /* resolve locale keywords and reordering keys */
1533     for (i = 0; i &lt; n; i++) {
1534         key = ultag_getExtensionKey(langtag, i);
1535         type = ultag_getExtensionValue(langtag, i);
1536         if (*key == LDMLEXT) {
<span class="line-modified">1537             _appendLDMLExtensionAsKeywords(type, &amp;kwdFirst, kwdBuf, kwdBufLength, &amp;posixVariant, status);</span>
1538             if (U_FAILURE(*status)) {
1539                 break;
1540             }
1541         } else {
<span class="line-modified">1542             kwd = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));</span>
1543             if (kwd == NULL) {
1544                 *status = U_MEMORY_ALLOCATION_ERROR;
1545                 break;
1546             }
1547             kwd-&gt;key = key;
1548             kwd-&gt;value = type;
1549             if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {
<span class="line-removed">1550                 uprv_free(kwd);</span>
1551                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1552                 break;
1553             }
1554         }
1555     }
1556 
1557     if (U_SUCCESS(*status)) {
1558         type = ultag_getPrivateUse(langtag);
1559         if ((int32_t)uprv_strlen(type) &gt; 0) {
1560             /* add private use as a keyword */
<span class="line-modified">1561             kwd = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));</span>
1562             if (kwd == NULL) {
1563                 *status = U_MEMORY_ALLOCATION_ERROR;
1564             } else {
1565                 kwd-&gt;key = PRIVATEUSE_KEY;
1566                 kwd-&gt;value = type;
1567                 if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {
<span class="line-removed">1568                     uprv_free(kwd);</span>
1569                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1570                 }
1571             }
1572         }
1573     }
1574 
1575     /* If a POSIX variant was in the extensions, write it out before writing the keywords. */
1576 
1577     if (U_SUCCESS(*status) &amp;&amp; posixVariant) {
1578         len = (int32_t) uprv_strlen(_POSIX);
<span class="line-modified">1579         if (reslen &lt; capacity) {</span>
<span class="line-removed">1580             uprv_memcpy(appendAt + reslen, _POSIX, uprv_min(len, capacity - reslen));</span>
<span class="line-removed">1581         }</span>
<span class="line-removed">1582         reslen += len;</span>
1583     }
1584 
1585     if (U_SUCCESS(*status) &amp;&amp; kwdFirst != NULL) {
1586         /* write out the sorted keywords */
1587         UBool firstValue = TRUE;
1588         kwd = kwdFirst;
1589         do {
<span class="line-modified">1590             if (reslen &lt; capacity) {</span>
<span class="line-modified">1591                 if (firstValue) {</span>
<span class="line-modified">1592                     /* &#39;@&#39; */</span>
<span class="line-modified">1593                     *(appendAt + reslen) = LOCALE_EXT_SEP;</span>
<span class="line-modified">1594                     firstValue = FALSE;</span>
<span class="line-removed">1595                 } else {</span>
<span class="line-removed">1596                     /* &#39;;&#39; */</span>
<span class="line-removed">1597                     *(appendAt + reslen) = LOCALE_KEYWORD_SEP;</span>
<span class="line-removed">1598                 }</span>
1599             }
<span class="line-removed">1600             reslen++;</span>
1601 
1602             /* key */
1603             len = (int32_t)uprv_strlen(kwd-&gt;key);
<span class="line-modified">1604             if (reslen &lt; capacity) {</span>
<span class="line-modified">1605                 uprv_memcpy(appendAt + reslen, kwd-&gt;key, uprv_min(len, capacity - reslen));</span>
<span class="line-removed">1606             }</span>
<span class="line-removed">1607             reslen += len;</span>
<span class="line-removed">1608 </span>
<span class="line-removed">1609             /* &#39;=&#39; */</span>
<span class="line-removed">1610             if (reslen &lt; capacity) {</span>
<span class="line-removed">1611                 *(appendAt + reslen) = LOCALE_KEY_TYPE_SEP;</span>
<span class="line-removed">1612             }</span>
<span class="line-removed">1613             reslen++;</span>
1614 
1615             /* type */
1616             len = (int32_t)uprv_strlen(kwd-&gt;value);
<span class="line-modified">1617             if (reslen &lt; capacity) {</span>
<span class="line-removed">1618                 uprv_memcpy(appendAt + reslen, kwd-&gt;value, uprv_min(len, capacity - reslen));</span>
<span class="line-removed">1619             }</span>
<span class="line-removed">1620             reslen += len;</span>
1621 
1622             kwd = kwd-&gt;next;
1623         } while (kwd);
1624     }
<span class="line-removed">1625 </span>
<span class="line-removed">1626     /* clean up */</span>
<span class="line-removed">1627     kwd = kwdFirst;</span>
<span class="line-removed">1628     while (kwd != NULL) {</span>
<span class="line-removed">1629         ExtensionListEntry *tmpKwd = kwd-&gt;next;</span>
<span class="line-removed">1630         uprv_free(kwd);</span>
<span class="line-removed">1631         kwd = tmpKwd;</span>
<span class="line-removed">1632     }</span>
<span class="line-removed">1633 </span>
<span class="line-removed">1634     uprv_free(kwdBuf);</span>
<span class="line-removed">1635 </span>
<span class="line-removed">1636     if (U_FAILURE(*status)) {</span>
<span class="line-removed">1637         return 0;</span>
<span class="line-removed">1638     }</span>
<span class="line-removed">1639 </span>
<span class="line-removed">1640     return u_terminateChars(appendAt, capacity, reslen, status);</span>
1641 }
1642 
<span class="line-modified">1643 static int32_t</span>
<span class="line-modified">1644 _appendPrivateuseToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UBool hadPosix, UErrorCode* status) {</span>
1645     (void)hadPosix;
1646     char buf[ULOC_FULLNAME_CAPACITY];
1647     char tmpAppend[ULOC_FULLNAME_CAPACITY];
1648     UErrorCode tmpStatus = U_ZERO_ERROR;
1649     int32_t len, i;
1650     int32_t reslen = 0;

1651 
1652     if (U_FAILURE(*status)) {
<span class="line-modified">1653         return 0;</span>
1654     }
1655 
1656     len = uloc_getVariant(localeID, buf, sizeof(buf), &amp;tmpStatus);
1657     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1658         if (strict) {
1659             *status = U_ILLEGAL_ARGUMENT_ERROR;
1660         }
<span class="line-modified">1661         return 0;</span>
1662     }
1663 
1664     if (len &gt; 0) {
1665         char *p, *pPriv;
1666         UBool bNext = TRUE;
1667         UBool firstValue = TRUE;
1668         UBool writeValue;
1669 
1670         pPriv = NULL;
1671         p = buf;
1672         while (bNext) {
1673             writeValue = FALSE;
1674             if (*p == SEP || *p == LOCALE_SEP || *p == 0) {
1675                 if (*p == 0) {
1676                     bNext = FALSE;
1677                 } else {
1678                     *p = 0; /* terminate */
1679                 }
1680                 if (pPriv != NULL) {
1681                     /* Private use in the canonical format is lowercase in BCP47 */
</pre>
<hr />
<pre>
1725 
1726                             firstValue = FALSE;
1727                         }
1728 
1729                         len = (int32_t)uprv_strlen(pPriv);
1730                         if (reslen &lt; capacity) {
1731                             uprv_memcpy(tmpAppend + reslen, pPriv, uprv_min(len, capacity - reslen));
1732                         }
1733                         reslen += len;
1734                     }
1735                 }
1736                 /* reset private use starting position */
1737                 pPriv = NULL;
1738             } else if (pPriv == NULL) {
1739                 pPriv = p;
1740             }
1741             p++;
1742         }
1743 
1744         if (U_FAILURE(*status)) {
<span class="line-modified">1745             return 0;</span>
1746         }
1747     }
1748 
1749     if (U_SUCCESS(*status)) {
1750         len = reslen;
<span class="line-modified">1751         if (reslen &lt; capacity) {</span>
<span class="line-removed">1752             uprv_memcpy(appendAt, tmpAppend, uprv_min(len, capacity - reslen));</span>
<span class="line-removed">1753         }</span>
1754     }
<span class="line-removed">1755 </span>
<span class="line-removed">1756     u_terminateChars(appendAt, capacity, reslen, status);</span>
<span class="line-removed">1757 </span>
<span class="line-removed">1758     return reslen;</span>
1759 }
1760 
1761 /*
1762 * -------------------------------------------------
1763 *
1764 * ultag_ functions
1765 *
1766 * -------------------------------------------------
1767 */
1768 
1769 /* Bit flags used by the parser */
1770 #define LANG 0x0001
1771 #define EXTL 0x0002
1772 #define SCRT 0x0004
1773 #define REGN 0x0008
1774 #define VART 0x0010
1775 #define EXTS 0x0020
1776 #define EXTV 0x0040
1777 #define PRIV 0x0080
1778 
1779 /**
1780  * Ticket #12705 - Visual Studio 2015 Update 3 contains a new code optimizer which has problems optimizing
1781  * this function. (See https://blogs.msdn.microsoft.com/vcblog/2016/05/04/new-code-optimizer/ )
1782  * As a workaround, we will turn off optimization just for this function on VS2015 Update 3 and above.
1783  */
1784 #if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1900) &amp;&amp; defined(_MSC_FULL_VER) &amp;&amp; (_MSC_FULL_VER &gt;= 190024210))
1785 #pragma optimize( &quot;&quot;, off )
1786 #endif
1787 
1788 static ULanguageTag*
1789 ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* status) {
<span class="line-removed">1790     ULanguageTag *t;</span>
1791     char *tagBuf;
1792     int16_t next;
1793     char *pSubtag, *pNext, *pLastGoodPosition;
1794     int32_t subtagLen;
1795     int32_t extlangIdx;
1796     ExtensionListEntry *pExtension;
1797     char *pExtValueSubtag, *pExtValueSubtagEnd;
1798     int32_t i;
1799     UBool privateuseVar = FALSE;
1800     int32_t grandfatheredLen = 0;
1801 
1802     if (parsedLen != NULL) {
1803         *parsedLen = 0;
1804     }
1805 
1806     if (U_FAILURE(*status)) {
1807         return NULL;
1808     }
1809 
1810     if (tagLen &lt; 0) {
1811         tagLen = (int32_t)uprv_strlen(tag);
1812     }
1813 
1814     /* copy the entire string */
1815     tagBuf = (char*)uprv_malloc(tagLen + 1);
1816     if (tagBuf == NULL) {
1817         *status = U_MEMORY_ALLOCATION_ERROR;
1818         return NULL;
1819     }
1820     uprv_memcpy(tagBuf, tag, tagLen);
1821     *(tagBuf + tagLen) = 0;
1822 
1823     /* create a ULanguageTag */
<span class="line-modified">1824     t = (ULanguageTag*)uprv_malloc(sizeof(ULanguageTag));</span>
<span class="line-modified">1825     if (t == NULL) {</span>

1826         uprv_free(tagBuf);
1827         *status = U_MEMORY_ALLOCATION_ERROR;
1828         return NULL;
1829     }
<span class="line-modified">1830     _initializeULanguageTag(t);</span>
1831     t-&gt;buf = tagBuf;
1832 
1833     if (tagLen &lt; MINLEN) {
1834         /* the input tag is too short - return empty ULanguageTag */
<span class="line-modified">1835         return t;</span>
1836     }
1837 




1838     /* check if the tag is grandfathered */
<span class="line-modified">1839     for (i = 0; GRANDFATHERED[i] != NULL; i += 2) {</span>
<span class="line-modified">1840         if (uprv_stricmp(GRANDFATHERED[i], tagBuf) == 0) {</span>








1841             int32_t newTagLength;
1842 
<span class="line-modified">1843             grandfatheredLen = tagLen;  /* back up for output parsedLen */</span>
<span class="line-modified">1844             newTagLength = static_cast&lt;int32_t&gt;(uprv_strlen(GRANDFATHERED[i+1]));</span>

1845             if (tagLen &lt; newTagLength) {
1846                 uprv_free(tagBuf);
1847                 tagBuf = (char*)uprv_malloc(newTagLength + 1);
1848                 if (tagBuf == NULL) {
1849                     *status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-removed">1850                     ultag_close(t);</span>
1851                     return NULL;
1852                 }
1853                 t-&gt;buf = tagBuf;
1854                 tagLen = newTagLength;
1855             }

1856             uprv_strcpy(t-&gt;buf, GRANDFATHERED[i + 1]);



1857             break;
1858         }
1859     }
1860 






























1861     /*
1862      * langtag      =   language
1863      *                  [&quot;-&quot; script]
1864      *                  [&quot;-&quot; region]
1865      *                  *(&quot;-&quot; variant)
1866      *                  *(&quot;-&quot; extension)
1867      *                  [&quot;-&quot; privateuse]
1868      */
1869 
1870     next = LANG | PRIV;
1871     pNext = pLastGoodPosition = tagBuf;
1872     extlangIdx = 0;
1873     pExtension = NULL;
1874     pExtValueSubtag = NULL;
1875     pExtValueSubtagEnd = NULL;
1876 
1877     while (pNext) {
1878         char *pSep;
1879 
1880         pSubtag = pNext;
1881 
1882         /* locate next separator char */
1883         pSep = pSubtag;
1884         while (*pSep) {
1885             if (*pSep == SEP) {
1886                 break;
1887             }
1888             pSep++;
1889         }
1890         if (*pSep == 0) {
1891             /* last subtag */
1892             pNext = NULL;
1893         } else {
1894             pNext = pSep + 1;
1895         }
1896         subtagLen = (int32_t)(pSep - pSubtag);
1897 
1898         if (next &amp; LANG) {
<span class="line-modified">1899             if (_isLanguageSubtag(pSubtag, subtagLen)) {</span>
1900                 *pSep = 0;  /* terminate */

1901                 t-&gt;language = T_CString_toLowerCase(pSubtag);
1902 
1903                 pLastGoodPosition = pSep;
<span class="line-modified">1904                 next = EXTL | SCRT | REGN | VART | EXTS | PRIV;</span>


1905                 continue;
1906             }
1907         }
1908         if (next &amp; EXTL) {
1909             if (_isExtlangSubtag(pSubtag, subtagLen)) {
1910                 *pSep = 0;
1911                 t-&gt;extlang[extlangIdx++] = T_CString_toLowerCase(pSubtag);
1912 
1913                 pLastGoodPosition = pSep;
1914                 if (extlangIdx &lt; 3) {
1915                     next = EXTL | SCRT | REGN | VART | EXTS | PRIV;
1916                 } else {
1917                     next = SCRT | REGN | VART | EXTS | PRIV;
1918                 }
1919                 continue;
1920             }
1921         }
1922         if (next &amp; SCRT) {
<span class="line-modified">1923             if (_isScriptSubtag(pSubtag, subtagLen)) {</span>
1924                 char *p = pSubtag;
1925 
1926                 *pSep = 0;
1927 
1928                 /* to title case */
1929                 *p = uprv_toupper(*p);
1930                 p++;
1931                 for (; *p; p++) {
1932                     *p = uprv_tolower(*p);
1933                 }
1934 
1935                 t-&gt;script = pSubtag;
1936 
1937                 pLastGoodPosition = pSep;
1938                 next = REGN | VART | EXTS | PRIV;
1939                 continue;
1940             }
1941         }
1942         if (next &amp; REGN) {
<span class="line-modified">1943             if (_isRegionSubtag(pSubtag, subtagLen)) {</span>
1944                 *pSep = 0;

1945                 t-&gt;region = T_CString_toUpperCase(pSubtag);
1946 
1947                 pLastGoodPosition = pSep;
1948                 next = VART | EXTS | PRIV;
1949                 continue;
1950             }
1951         }
1952         if (next &amp; VART) {
1953             if (_isVariantSubtag(pSubtag, subtagLen) ||
1954                (privateuseVar &amp;&amp; _isPrivateuseVariantSubtag(pSubtag, subtagLen))) {
1955                 VariantListEntry *var;
1956                 UBool isAdded;
1957 
1958                 var = (VariantListEntry*)uprv_malloc(sizeof(VariantListEntry));
1959                 if (var == NULL) {
1960                     *status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified">1961                     goto error;</span>
1962                 }
1963                 *pSep = 0;
1964                 var-&gt;variant = T_CString_toUpperCase(pSubtag);
1965                 isAdded = _addVariantToList(&amp;(t-&gt;variants), var);
1966                 if (!isAdded) {
1967                     /* duplicated variant entry */
1968                     uprv_free(var);
1969                     break;
1970                 }
1971                 pLastGoodPosition = pSep;
1972                 next = VART | EXTS | PRIV;
1973                 continue;
1974             }
1975         }
1976         if (next &amp; EXTS) {
1977             if (_isExtensionSingleton(pSubtag, subtagLen)) {
1978                 if (pExtension != NULL) {
1979                     if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
1980                         /* the previous extension is incomplete */
1981                         uprv_free(pExtension);
</pre>
<hr />
<pre>
1985 
1986                     /* terminate the previous extension value */
1987                     *pExtValueSubtagEnd = 0;
1988                     pExtension-&gt;value = T_CString_toLowerCase(pExtValueSubtag);
1989 
1990                     /* insert the extension to the list */
1991                     if (_addExtensionToList(&amp;(t-&gt;extensions), pExtension, FALSE)) {
1992                         pLastGoodPosition = pExtValueSubtagEnd;
1993                     } else {
1994                         /* stop parsing here */
1995                         uprv_free(pExtension);
1996                         pExtension = NULL;
1997                         break;
1998                     }
1999                 }
2000 
2001                 /* create a new extension */
2002                 pExtension = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));
2003                 if (pExtension == NULL) {
2004                     *status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified">2005                     goto error;</span>
2006                 }
2007                 *pSep = 0;
2008                 pExtension-&gt;key = T_CString_toLowerCase(pSubtag);
2009                 pExtension-&gt;value = NULL;   /* will be set later */
2010 
2011                 /*
2012                  * reset the start and the end location of extension value
2013                  * subtags for this extension
2014                  */
2015                 pExtValueSubtag = NULL;
2016                 pExtValueSubtagEnd = NULL;
2017 
2018                 next = EXTV;
2019                 continue;
2020             }
2021         }
2022         if (next &amp; EXTV) {
2023             if (_isExtensionSubtag(pSubtag, subtagLen)) {
2024                 if (pExtValueSubtag == NULL) {
2025                     /* if the start postion of this extension&#39;s value is not yet,
2026                         this one is the first value subtag */
2027                     pExtValueSubtag = pSubtag;
2028                 }
2029 
2030                 /* Mark the end of this subtag */
2031                 pExtValueSubtagEnd = pSep;
2032                 next = EXTS | EXTV | PRIV;
2033 
2034                 continue;
2035             }
2036         }
2037         if (next &amp; PRIV) {
<span class="line-modified">2038             if (uprv_tolower(*pSubtag) == PRIVATEUSE) {</span>
2039                 char *pPrivuseVal;
2040 
2041                 if (pExtension != NULL) {
2042                     /* Process the last extension */
2043                     if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
2044                         /* the previous extension is incomplete */
2045                         uprv_free(pExtension);
2046                         pExtension = NULL;
2047                         break;
2048                     } else {
2049                         /* terminate the previous extension value */
2050                         *pExtValueSubtagEnd = 0;
2051                         pExtension-&gt;value = T_CString_toLowerCase(pExtValueSubtag);
2052 
2053                         /* insert the extension to the list */
2054                         if (_addExtensionToList(&amp;(t-&gt;extensions), pExtension, FALSE)) {
2055                             pLastGoodPosition = pExtValueSubtagEnd;
2056                             pExtension = NULL;
2057                         } else {
2058                         /* stop parsing here */
</pre>
<hr />
<pre>
2121 
2122     if (pExtension != NULL) {
2123         /* Process the last extension */
2124         if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
2125             /* the previous extension is incomplete */
2126             uprv_free(pExtension);
2127         } else {
2128             /* terminate the previous extension value */
2129             *pExtValueSubtagEnd = 0;
2130             pExtension-&gt;value = T_CString_toLowerCase(pExtValueSubtag);
2131             /* insert the extension to the list */
2132             if (_addExtensionToList(&amp;(t-&gt;extensions), pExtension, FALSE)) {
2133                 pLastGoodPosition = pExtValueSubtagEnd;
2134             } else {
2135                 uprv_free(pExtension);
2136             }
2137         }
2138     }
2139 
2140     if (parsedLen != NULL) {
<span class="line-modified">2141         *parsedLen = (grandfatheredLen &gt; 0) ? grandfatheredLen : (int32_t)(pLastGoodPosition - t-&gt;buf);</span>
2142     }
2143 
<span class="line-modified">2144     return t;</span>
<span class="line-removed">2145 </span>
<span class="line-removed">2146 error:</span>
<span class="line-removed">2147     ultag_close(t);</span>
<span class="line-removed">2148     return NULL;</span>
2149 }
2150 
2151 /**
2152 * Ticket #12705 - Turn optimization back on.
2153 */
2154 #if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1900) &amp;&amp; defined(_MSC_FULL_VER) &amp;&amp; (_MSC_FULL_VER &gt;= 190024210))
2155 #pragma optimize( &quot;&quot;, on )
2156 #endif
2157 
2158 static void
2159 ultag_close(ULanguageTag* langtag) {
2160 
2161     if (langtag == NULL) {
2162         return;
2163     }
2164 
2165     uprv_free(langtag-&gt;buf);
2166 
2167     if (langtag-&gt;variants) {
2168         VariantListEntry *curVar = langtag-&gt;variants;
</pre>
<hr />
<pre>
2318 static const char*
2319 ultag_getGrandfathered(const ULanguageTag* langtag) {
2320     return langtag-&gt;grandfathered;
2321 }
2322 #endif
2323 
2324 
2325 /*
2326 * -------------------------------------------------
2327 *
2328 * Locale/BCP47 conversion APIs, exposed as uloc_*
2329 *
2330 * -------------------------------------------------
2331 */
2332 U_CAPI int32_t U_EXPORT2
2333 uloc_toLanguageTag(const char* localeID,
2334                    char* langtag,
2335                    int32_t langtagCapacity,
2336                    UBool strict,
2337                    UErrorCode* status) {
<span class="line-modified">2338     /* char canonical[ULOC_FULLNAME_CAPACITY]; */ /* See #6822 */</span>
<span class="line-modified">2339     char canonical[256];</span>
<span class="line-modified">2340     int32_t reslen = 0;</span>



























2341     UErrorCode tmpStatus = U_ZERO_ERROR;
2342     UBool hadPosix = FALSE;
2343     const char* pKeywordStart;
2344 
2345     /* Note: uloc_canonicalize returns &quot;en_US_POSIX&quot; for input locale ID &quot;&quot;.  See #6835 */
<span class="line-modified">2346     canonical[0] = 0;</span>
<span class="line-modified">2347     if (uprv_strlen(localeID) &gt; 0) {</span>
<span class="line-modified">2348         uloc_canonicalize(localeID, canonical, sizeof(canonical), &amp;tmpStatus);</span>
<span class="line-modified">2349         if (tmpStatus != U_ZERO_ERROR) {</span>
























2350             *status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">2351             return 0;</span>










2352         }
2353     }
2354 
2355     /* For handling special case - private use only tag */
<span class="line-modified">2356     pKeywordStart = locale_getKeywordsStart(canonical);</span>
<span class="line-modified">2357     if (pKeywordStart == canonical) {</span>
<span class="line-removed">2358         UEnumeration *kwdEnum;</span>
2359         int kwdCnt = 0;
2360         UBool done = FALSE;
2361 
<span class="line-modified">2362         kwdEnum = uloc_openKeywords((const char*)canonical, &amp;tmpStatus);</span>
<span class="line-modified">2363         if (kwdEnum != NULL) {</span>
<span class="line-modified">2364             kwdCnt = uenum_count(kwdEnum, &amp;tmpStatus);</span>
2365             if (kwdCnt == 1) {
2366                 const char *key;
2367                 int32_t len = 0;
2368 
<span class="line-modified">2369                 key = uenum_next(kwdEnum, &amp;len, &amp;tmpStatus);</span>
2370                 if (len == 1 &amp;&amp; *key == PRIVATEUSE) {
2371                     char buf[ULOC_KEYWORD_AND_VALUES_CAPACITY];
2372                     buf[0] = PRIVATEUSE;
2373                     buf[1] = SEP;
2374                     len = uloc_getKeywordValue(localeID, key, &amp;buf[2], sizeof(buf) - 2, &amp;tmpStatus);
2375                     if (U_SUCCESS(tmpStatus)) {
<span class="line-modified">2376                         if (_isPrivateuseValueSubtags(&amp;buf[2], len)) {</span>
2377                             /* return private use only tag */
<span class="line-modified">2378                             reslen = len + 2;</span>
<span class="line-removed">2379                             uprv_memcpy(langtag, buf, uprv_min(reslen, langtagCapacity));</span>
<span class="line-removed">2380                             u_terminateChars(langtag, langtagCapacity, reslen, status);</span>
2381                             done = TRUE;
2382                         } else if (strict) {
2383                             *status = U_ILLEGAL_ARGUMENT_ERROR;
2384                             done = TRUE;
2385                         }
2386                         /* if not strict mode, then &quot;und&quot; will be returned */
2387                     } else {
2388                         *status = U_ILLEGAL_ARGUMENT_ERROR;
2389                         done = TRUE;
2390                     }
2391                 }
2392             }
<span class="line-removed">2393             uenum_close(kwdEnum);</span>
2394             if (done) {
<span class="line-modified">2395                 return reslen;</span>
2396             }
2397         }
2398     }
2399 
<span class="line-modified">2400     reslen += _appendLanguageToLanguageTag(canonical, langtag, langtagCapacity, strict, status);</span>
<span class="line-modified">2401     reslen += _appendScriptToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, status);</span>
<span class="line-modified">2402     reslen += _appendRegionToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, status);</span>
<span class="line-modified">2403     reslen += _appendVariantsToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, &amp;hadPosix, status);</span>
<span class="line-modified">2404     reslen += _appendKeywordsToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, hadPosix, status);</span>
<span class="line-modified">2405     reslen += _appendPrivateuseToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, hadPosix, status);</span>
<span class="line-removed">2406 </span>
<span class="line-removed">2407     return reslen;</span>
2408 }
2409 
2410 
2411 U_CAPI int32_t U_EXPORT2
2412 uloc_forLanguageTag(const char* langtag,
2413                     char* localeID,
2414                     int32_t localeIDCapacity,
2415                     int32_t* parsedLength,
2416                     UErrorCode* status) {
<span class="line-modified">2417     ULanguageTag *lt;</span>
<span class="line-modified">2418     int32_t reslen = 0;</span>




























2419     const char *subtag, *p;
2420     int32_t len;
2421     int32_t i, n;
2422     UBool noRegion = TRUE;
2423 
<span class="line-modified">2424     lt = ultag_parse(langtag, -1, parsedLength, status);</span>
2425     if (U_FAILURE(*status)) {
<span class="line-modified">2426         return 0;</span>
2427     }
2428 
2429     /* language */
<span class="line-modified">2430     subtag = ultag_getExtlangSize(lt) &gt; 0 ? ultag_getExtlang(lt, 0) : ultag_getLanguage(lt);</span>
2431     if (uprv_compareInvCharsAsAscii(subtag, LANG_UND) != 0) {
2432         len = (int32_t)uprv_strlen(subtag);
2433         if (len &gt; 0) {
<span class="line-modified">2434             if (reslen &lt; localeIDCapacity) {</span>
<span class="line-modified">2435                 uprv_memcpy(localeID, subtag, uprv_min(len, localeIDCapacity - reslen));</span>
<span class="line-removed">2436             }</span>
<span class="line-removed">2437             reslen += len;</span>
2438         }
2439     }
2440 
2441     /* script */
<span class="line-modified">2442     subtag = ultag_getScript(lt);</span>
2443     len = (int32_t)uprv_strlen(subtag);
2444     if (len &gt; 0) {
<span class="line-modified">2445         if (reslen &lt; localeIDCapacity) {</span>
<span class="line-modified">2446             *(localeID + reslen) = LOCALE_SEP;</span>
<span class="line-removed">2447         }</span>
<span class="line-removed">2448         reslen++;</span>
2449 
2450         /* write out the script in title case */
<span class="line-modified">2451         p = subtag;</span>
<span class="line-modified">2452         while (*p) {</span>
<span class="line-modified">2453             if (reslen &lt; localeIDCapacity) {</span>
<span class="line-removed">2454                 if (p == subtag) {</span>
<span class="line-removed">2455                     *(localeID + reslen) = uprv_toupper(*p);</span>
<span class="line-removed">2456                 } else {</span>
<span class="line-removed">2457                     *(localeID + reslen) = *p;</span>
<span class="line-removed">2458                 }</span>
<span class="line-removed">2459             }</span>
<span class="line-removed">2460             reslen++;</span>
<span class="line-removed">2461             p++;</span>
<span class="line-removed">2462         }</span>
2463     }
2464 
2465     /* region */
<span class="line-modified">2466     subtag = ultag_getRegion(lt);</span>
2467     len = (int32_t)uprv_strlen(subtag);
2468     if (len &gt; 0) {
<span class="line-modified">2469         if (reslen &lt; localeIDCapacity) {</span>
<span class="line-modified">2470             *(localeID + reslen) = LOCALE_SEP;</span>
<span class="line-modified">2471         }</span>
<span class="line-modified">2472         reslen++;</span>
<span class="line-removed">2473         /* write out the retion in upper case */</span>
2474         p = subtag;
2475         while (*p) {
<span class="line-modified">2476             if (reslen &lt; localeIDCapacity) {</span>
<span class="line-modified">2477                 *(localeID + reslen) = uprv_toupper(*p);</span>
<span class="line-removed">2478             }</span>
<span class="line-removed">2479             reslen++;</span>
2480             p++;
2481         }
2482         noRegion = FALSE;
2483     }
2484 
2485     /* variants */
<span class="line-modified">2486     n = ultag_getVariantsSize(lt);</span>
2487     if (n &gt; 0) {
2488         if (noRegion) {
<span class="line-modified">2489             if (reslen &lt; localeIDCapacity) {</span>
<span class="line-modified">2490                 *(localeID + reslen) = LOCALE_SEP;</span>
<span class="line-removed">2491             }</span>
<span class="line-removed">2492             reslen++;</span>
2493         }
2494 
2495         for (i = 0; i &lt; n; i++) {
<span class="line-modified">2496             subtag = ultag_getVariant(lt, i);</span>
<span class="line-modified">2497             if (reslen &lt; localeIDCapacity) {</span>
<span class="line-modified">2498                 *(localeID + reslen) = LOCALE_SEP;</span>
<span class="line-removed">2499             }</span>
<span class="line-removed">2500             reslen++;</span>
2501             /* write out the variant in upper case */
2502             p = subtag;
2503             while (*p) {
<span class="line-modified">2504                 if (reslen &lt; localeIDCapacity) {</span>
<span class="line-modified">2505                     *(localeID + reslen) = uprv_toupper(*p);</span>
<span class="line-removed">2506                 }</span>
<span class="line-removed">2507                 reslen++;</span>
2508                 p++;
2509             }
2510         }
2511     }
2512 
2513     /* keywords */
<span class="line-modified">2514     n = ultag_getExtensionsSize(lt);</span>
<span class="line-modified">2515     subtag = ultag_getPrivateUse(lt);</span>
2516     if (n &gt; 0 || uprv_strlen(subtag) &gt; 0) {
<span class="line-modified">2517         if (reslen == 0 &amp;&amp; n &gt; 0) {</span>
2518             /* need a language */
<span class="line-modified">2519             if (reslen &lt; localeIDCapacity) {</span>
<span class="line-removed">2520                 uprv_memcpy(localeID + reslen, LANG_UND, uprv_min(LANG_UND_LEN, localeIDCapacity - reslen));</span>
<span class="line-removed">2521             }</span>
<span class="line-removed">2522             reslen += LANG_UND_LEN;</span>
2523         }
<span class="line-modified">2524         len = _appendKeywords(lt, localeID + reslen, localeIDCapacity - reslen, status);</span>
<span class="line-removed">2525         reslen += len;</span>
2526     }
<span class="line-removed">2527 </span>
<span class="line-removed">2528     ultag_close(lt);</span>
<span class="line-removed">2529     return u_terminateChars(localeID, localeIDCapacity, reslen, status);</span>
2530 }
<span class="line-removed">2531 </span>
<span class="line-removed">2532 </span>
</pre>
</td>
<td>
<hr />
<pre>
   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 **********************************************************************
   5 *   Copyright (C) 2009-2015, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 **********************************************************************
   8 */
   9 
<span class="line-added">  10 #include &quot;unicode/bytestream.h&quot;</span>
  11 #include &quot;unicode/utypes.h&quot;
  12 #include &quot;unicode/ures.h&quot;
<span class="line-added">  13 #include &quot;unicode/localpointer.h&quot;</span>
  14 #include &quot;unicode/putil.h&quot;
<span class="line-added">  15 #include &quot;unicode/uenum.h&quot;</span>
  16 #include &quot;unicode/uloc.h&quot;
  17 #include &quot;ustr_imp.h&quot;
<span class="line-added">  18 #include &quot;charstr.h&quot;</span>
  19 #include &quot;cmemory.h&quot;
  20 #include &quot;cstring.h&quot;
  21 #include &quot;putilimp.h&quot;
  22 #include &quot;uinvchar.h&quot;
  23 #include &quot;ulocimp.h&quot;
  24 #include &quot;uassert.h&quot;
  25 
  26 
  27 /* struct holding a single variant */
  28 typedef struct VariantListEntry {
  29     const char              *variant;
  30     struct VariantListEntry *next;
  31 } VariantListEntry;
  32 
  33 /* struct holding a single attribute value */
<span class="line-modified">  34 struct AttributeListEntry : public icu::UMemory {</span>
  35     const char              *attribute;
  36     struct AttributeListEntry *next;
<span class="line-modified">  37 };</span>
  38 
  39 /* struct holding a single extension */
<span class="line-modified">  40 struct ExtensionListEntry : public icu::UMemory {</span>
  41     const char                  *key;
  42     const char                  *value;
  43     struct ExtensionListEntry   *next;
<span class="line-modified">  44 };</span>
  45 
  46 #define MAXEXTLANG 3
  47 typedef struct ULanguageTag {
  48     char                *buf;   /* holding parsed subtags */
  49     const char          *language;
  50     const char          *extlang[MAXEXTLANG];
  51     const char          *script;
  52     const char          *region;
  53     VariantListEntry    *variants;
  54     ExtensionListEntry  *extensions;
  55     const char          *privateuse;
  56     const char          *grandfathered;
  57 } ULanguageTag;
  58 
  59 #define MINLEN 2
  60 #define SEP &#39;-&#39;
  61 #define PRIVATEUSE &#39;x&#39;
  62 #define LDMLEXT &#39;u&#39;
  63 
  64 #define LOCALE_SEP &#39;_&#39;
  65 #define LOCALE_EXT_SEP &#39;@&#39;
  66 #define LOCALE_KEYWORD_SEP &#39;;&#39;
  67 #define LOCALE_KEY_TYPE_SEP &#39;=&#39;
  68 
  69 #define ISALPHA(c) uprv_isASCIILetter(c)
  70 #define ISNUMERIC(c) ((c)&gt;=&#39;0&#39; &amp;&amp; (c)&lt;=&#39;9&#39;)
  71 
  72 static const char EMPTY[] = &quot;&quot;;
  73 static const char LANG_UND[] = &quot;und&quot;;
  74 static const char PRIVATEUSE_KEY[] = &quot;x&quot;;
  75 static const char _POSIX[] = &quot;_POSIX&quot;;
  76 static const char POSIX_KEY[] = &quot;va&quot;;
  77 static const char POSIX_VALUE[] = &quot;posix&quot;;
  78 static const char LOCALE_ATTRIBUTE_KEY[] = &quot;attribute&quot;;
  79 static const char PRIVUSE_VARIANT_PREFIX[] = &quot;lvariant&quot;;
  80 static const char LOCALE_TYPE_YES[] = &quot;yes&quot;;
  81 
  82 #define LANG_UND_LEN 3
  83 
<span class="line-added">  84 /*</span>
<span class="line-added">  85  Updated on 2018-09-12 from</span>
<span class="line-added">  86  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry .</span>
<span class="line-added">  87 </span>
<span class="line-added">  88  This table has 2 parts. The parts for Grandfathered tags is generated by the</span>
<span class="line-added">  89  following scripts from the IANA language tag registry.</span>
<span class="line-added">  90 </span>
<span class="line-added">  91  curl  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry |\</span>
<span class="line-added">  92  egrep -A 7 &#39;Type: grandfathered&#39; | \</span>
<span class="line-added">  93  egrep &#39;Tag|Prefe&#39; | grep -B1 &#39;Preferred&#39; | grep -v &#39;^--&#39; | \</span>
<span class="line-added">  94  awk -n &#39;/Tag/ {printf(&quot;    \&quot;%s\&quot;, &quot;, $2);} /Preferred/ {printf(&quot;\&quot;%s\&quot;,\n&quot;, $2);}&#39; |\</span>
<span class="line-added">  95  tr &#39;A-Z&#39; &#39;a-z&#39;</span>
<span class="line-added">  96 </span>
<span class="line-added">  97 </span>
<span class="line-added">  98  The 2nd part is made of five ICU-specific entries. They&#39;re kept for</span>
<span class="line-added">  99  the backward compatibility for now, even though there are no preferred</span>
<span class="line-added"> 100  values. They may have to be removed for the strict BCP 47 compliance.</span>
<span class="line-added"> 101 </span>
<span class="line-added"> 102 */</span>
 103 static const char* const GRANDFATHERED[] = {
 104 /*  grandfathered   preferred */
 105     &quot;art-lojban&quot;,   &quot;jbo&quot;,
<span class="line-modified"> 106     &quot;en-gb-oed&quot;,    &quot;en-gb-oxendict&quot;,</span>

 107     &quot;i-ami&quot;,        &quot;ami&quot;,
 108     &quot;i-bnn&quot;,        &quot;bnn&quot;,


 109     &quot;i-hak&quot;,        &quot;hak&quot;,
 110     &quot;i-klingon&quot;,    &quot;tlh&quot;,
 111     &quot;i-lux&quot;,        &quot;lb&quot;,

 112     &quot;i-navajo&quot;,     &quot;nv&quot;,
 113     &quot;i-pwn&quot;,        &quot;pwn&quot;,
 114     &quot;i-tao&quot;,        &quot;tao&quot;,
 115     &quot;i-tay&quot;,        &quot;tay&quot;,
 116     &quot;i-tsu&quot;,        &quot;tsu&quot;,
 117     &quot;no-bok&quot;,       &quot;nb&quot;,
 118     &quot;no-nyn&quot;,       &quot;nn&quot;,
 119     &quot;sgn-be-fr&quot;,    &quot;sfb&quot;,
 120     &quot;sgn-be-nl&quot;,    &quot;vgt&quot;,
 121     &quot;sgn-ch-de&quot;,    &quot;sgg&quot;,
 122     &quot;zh-guoyu&quot;,     &quot;cmn&quot;,
 123     &quot;zh-hakka&quot;,     &quot;hak&quot;,

 124     &quot;zh-min-nan&quot;,   &quot;nan&quot;,
 125     &quot;zh-xiang&quot;,     &quot;hsn&quot;,
<span class="line-modified"> 126 </span>
<span class="line-added"> 127     // Grandfathered tags with no preferred value in the IANA</span>
<span class="line-added"> 128     // registry. Kept for now for the backward compatibility</span>
<span class="line-added"> 129     // because ICU has mapped them this way.</span>
<span class="line-added"> 130     &quot;cel-gaulish&quot;,  &quot;xtg-x-cel-gaulish&quot;,</span>
<span class="line-added"> 131     &quot;i-default&quot;,    &quot;en-x-i-default&quot;,</span>
<span class="line-added"> 132     &quot;i-enochian&quot;,   &quot;und-x-i-enochian&quot;,</span>
<span class="line-added"> 133     &quot;i-mingo&quot;,      &quot;see-x-i-mingo&quot;,</span>
<span class="line-added"> 134     &quot;zh-min&quot;,       &quot;nan-x-zh-min&quot;,</span>
<span class="line-added"> 135 };</span>
<span class="line-added"> 136 </span>
<span class="line-added"> 137 /*</span>
<span class="line-added"> 138  Updated on 2018-09-12 from</span>
<span class="line-added"> 139  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry .</span>
<span class="line-added"> 140 </span>
<span class="line-added"> 141  The table lists redundant tags with preferred value in the IANA languate tag registry.</span>
<span class="line-added"> 142  It&#39;s generated with the following command:</span>
<span class="line-added"> 143 </span>
<span class="line-added"> 144  curl  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry |\</span>
<span class="line-added"> 145  grep &#39;Type: redundant&#39; -A 5 | egrep &#39;^(Tag:|Prefer)&#39; | grep -B1 &#39;Preferred&#39; | \</span>
<span class="line-added"> 146  awk -n &#39;/Tag/ {printf(&quot;    \&quot;%s\&quot;,       &quot;, $2);} /Preferred/ {printf(&quot;\&quot;%s\&quot;,\n&quot;, $2);}&#39; | \</span>
<span class="line-added"> 147  tr &#39;A-Z&#39; &#39;a-z&#39;</span>
<span class="line-added"> 148 </span>
<span class="line-added"> 149  In addition, ja-latn-hepburn-heploc is mapped to ja-latn-alalc97 because</span>
<span class="line-added"> 150  a variant tag &#39;hepburn-heploc&#39; has the preferred subtag, &#39;alaic97&#39;.</span>
<span class="line-added"> 151 */</span>
<span class="line-added"> 152 </span>
<span class="line-added"> 153 static const char* const REDUNDANT[] = {</span>
<span class="line-added"> 154 //  redundant       preferred</span>
<span class="line-added"> 155     &quot;sgn-br&quot;,       &quot;bzs&quot;,</span>
<span class="line-added"> 156     &quot;sgn-co&quot;,       &quot;csn&quot;,</span>
<span class="line-added"> 157     &quot;sgn-de&quot;,       &quot;gsg&quot;,</span>
<span class="line-added"> 158     &quot;sgn-dk&quot;,       &quot;dsl&quot;,</span>
<span class="line-added"> 159     &quot;sgn-es&quot;,       &quot;ssp&quot;,</span>
<span class="line-added"> 160     &quot;sgn-fr&quot;,       &quot;fsl&quot;,</span>
<span class="line-added"> 161     &quot;sgn-gb&quot;,       &quot;bfi&quot;,</span>
<span class="line-added"> 162     &quot;sgn-gr&quot;,       &quot;gss&quot;,</span>
<span class="line-added"> 163     &quot;sgn-ie&quot;,       &quot;isg&quot;,</span>
<span class="line-added"> 164     &quot;sgn-it&quot;,       &quot;ise&quot;,</span>
<span class="line-added"> 165     &quot;sgn-jp&quot;,       &quot;jsl&quot;,</span>
<span class="line-added"> 166     &quot;sgn-mx&quot;,       &quot;mfs&quot;,</span>
<span class="line-added"> 167     &quot;sgn-ni&quot;,       &quot;ncs&quot;,</span>
<span class="line-added"> 168     &quot;sgn-nl&quot;,       &quot;dse&quot;,</span>
<span class="line-added"> 169     &quot;sgn-no&quot;,       &quot;nsl&quot;,</span>
<span class="line-added"> 170     &quot;sgn-pt&quot;,       &quot;psr&quot;,</span>
<span class="line-added"> 171     &quot;sgn-se&quot;,       &quot;swl&quot;,</span>
<span class="line-added"> 172     &quot;sgn-us&quot;,       &quot;ase&quot;,</span>
<span class="line-added"> 173     &quot;sgn-za&quot;,       &quot;sfs&quot;,</span>
<span class="line-added"> 174     &quot;zh-cmn&quot;,       &quot;cmn&quot;,</span>
<span class="line-added"> 175     &quot;zh-cmn-hans&quot;,  &quot;cmn-hans&quot;,</span>
<span class="line-added"> 176     &quot;zh-cmn-hant&quot;,  &quot;cmn-hant&quot;,</span>
<span class="line-added"> 177     &quot;zh-gan&quot;,       &quot;gan&quot;,</span>
<span class="line-added"> 178     &quot;zh-wuu&quot;,       &quot;wuu&quot;,</span>
<span class="line-added"> 179     &quot;zh-yue&quot;,       &quot;yue&quot;,</span>
<span class="line-added"> 180 </span>
<span class="line-added"> 181     // variant tag with preferred value</span>
<span class="line-added"> 182     &quot;ja-latn-hepburn-heploc&quot;, &quot;ja-latn-alalc97&quot;,</span>
 183 };
 184 
<span class="line-added"> 185 /*</span>
<span class="line-added"> 186   Updated on 2018-09-12 from</span>
<span class="line-added"> 187   https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry .</span>
<span class="line-added"> 188 </span>
<span class="line-added"> 189   grep &#39;Type: language&#39; -A 7 language-subtag-registry  | egrep &#39;Subtag|Prefe&#39; | \</span>
<span class="line-added"> 190   grep -B1 &#39;Preferred&#39; | grep -v &#39;^--&#39; | \</span>
<span class="line-added"> 191   awk -n &#39;/Subtag/ {printf(&quot;    \&quot;%s\&quot;,       &quot;, $2);} /Preferred/ {printf(&quot;\&quot;%s\&quot;,\n&quot;, $2);}&#39;</span>
<span class="line-added"> 192 </span>
<span class="line-added"> 193   Make sure that 2-letter language subtags come before 3-letter subtags.</span>
<span class="line-added"> 194 */</span>
 195 static const char DEPRECATEDLANGS[][4] = {
 196 /*  deprecated  new */
<span class="line-added"> 197     &quot;in&quot;,       &quot;id&quot;,</span>
 198     &quot;iw&quot;,       &quot;he&quot;,
 199     &quot;ji&quot;,       &quot;yi&quot;,
<span class="line-modified"> 200     &quot;jw&quot;,       &quot;jv&quot;,</span>
<span class="line-added"> 201     &quot;mo&quot;,       &quot;ro&quot;,</span>
<span class="line-added"> 202     &quot;aam&quot;,       &quot;aas&quot;,</span>
<span class="line-added"> 203     &quot;adp&quot;,       &quot;dz&quot;,</span>
<span class="line-added"> 204     &quot;aue&quot;,       &quot;ktz&quot;,</span>
<span class="line-added"> 205     &quot;ayx&quot;,       &quot;nun&quot;,</span>
<span class="line-added"> 206     &quot;bgm&quot;,       &quot;bcg&quot;,</span>
<span class="line-added"> 207     &quot;bjd&quot;,       &quot;drl&quot;,</span>
<span class="line-added"> 208     &quot;ccq&quot;,       &quot;rki&quot;,</span>
<span class="line-added"> 209     &quot;cjr&quot;,       &quot;mom&quot;,</span>
<span class="line-added"> 210     &quot;cka&quot;,       &quot;cmr&quot;,</span>
<span class="line-added"> 211     &quot;cmk&quot;,       &quot;xch&quot;,</span>
<span class="line-added"> 212     &quot;coy&quot;,       &quot;pij&quot;,</span>
<span class="line-added"> 213     &quot;cqu&quot;,       &quot;quh&quot;,</span>
<span class="line-added"> 214     &quot;drh&quot;,       &quot;khk&quot;,</span>
<span class="line-added"> 215     &quot;drw&quot;,       &quot;prs&quot;,</span>
<span class="line-added"> 216     &quot;gav&quot;,       &quot;dev&quot;,</span>
<span class="line-added"> 217     &quot;gfx&quot;,       &quot;vaj&quot;,</span>
<span class="line-added"> 218     &quot;ggn&quot;,       &quot;gvr&quot;,</span>
<span class="line-added"> 219     &quot;gti&quot;,       &quot;nyc&quot;,</span>
<span class="line-added"> 220     &quot;guv&quot;,       &quot;duz&quot;,</span>
<span class="line-added"> 221     &quot;hrr&quot;,       &quot;jal&quot;,</span>
<span class="line-added"> 222     &quot;ibi&quot;,       &quot;opa&quot;,</span>
<span class="line-added"> 223     &quot;ilw&quot;,       &quot;gal&quot;,</span>
<span class="line-added"> 224     &quot;jeg&quot;,       &quot;oyb&quot;,</span>
<span class="line-added"> 225     &quot;kgc&quot;,       &quot;tdf&quot;,</span>
<span class="line-added"> 226     &quot;kgh&quot;,       &quot;kml&quot;,</span>
<span class="line-added"> 227     &quot;koj&quot;,       &quot;kwv&quot;,</span>
<span class="line-added"> 228     &quot;krm&quot;,       &quot;bmf&quot;,</span>
<span class="line-added"> 229     &quot;ktr&quot;,       &quot;dtp&quot;,</span>
<span class="line-added"> 230     &quot;kvs&quot;,       &quot;gdj&quot;,</span>
<span class="line-added"> 231     &quot;kwq&quot;,       &quot;yam&quot;,</span>
<span class="line-added"> 232     &quot;kxe&quot;,       &quot;tvd&quot;,</span>
<span class="line-added"> 233     &quot;kzj&quot;,       &quot;dtp&quot;,</span>
<span class="line-added"> 234     &quot;kzt&quot;,       &quot;dtp&quot;,</span>
<span class="line-added"> 235     &quot;lii&quot;,       &quot;raq&quot;,</span>
<span class="line-added"> 236     &quot;lmm&quot;,       &quot;rmx&quot;,</span>
<span class="line-added"> 237     &quot;meg&quot;,       &quot;cir&quot;,</span>
<span class="line-added"> 238     &quot;mst&quot;,       &quot;mry&quot;,</span>
<span class="line-added"> 239     &quot;mwj&quot;,       &quot;vaj&quot;,</span>
<span class="line-added"> 240     &quot;myt&quot;,       &quot;mry&quot;,</span>
<span class="line-added"> 241     &quot;nad&quot;,       &quot;xny&quot;,</span>
<span class="line-added"> 242     &quot;ncp&quot;,       &quot;kdz&quot;,</span>
<span class="line-added"> 243     &quot;nnx&quot;,       &quot;ngv&quot;,</span>
<span class="line-added"> 244     &quot;nts&quot;,       &quot;pij&quot;,</span>
<span class="line-added"> 245     &quot;oun&quot;,       &quot;vaj&quot;,</span>
<span class="line-added"> 246     &quot;pcr&quot;,       &quot;adx&quot;,</span>
<span class="line-added"> 247     &quot;pmc&quot;,       &quot;huw&quot;,</span>
<span class="line-added"> 248     &quot;pmu&quot;,       &quot;phr&quot;,</span>
<span class="line-added"> 249     &quot;ppa&quot;,       &quot;bfy&quot;,</span>
<span class="line-added"> 250     &quot;ppr&quot;,       &quot;lcq&quot;,</span>
<span class="line-added"> 251     &quot;pry&quot;,       &quot;prt&quot;,</span>
<span class="line-added"> 252     &quot;puz&quot;,       &quot;pub&quot;,</span>
<span class="line-added"> 253     &quot;sca&quot;,       &quot;hle&quot;,</span>
<span class="line-added"> 254     &quot;skk&quot;,       &quot;oyb&quot;,</span>
<span class="line-added"> 255     &quot;tdu&quot;,       &quot;dtp&quot;,</span>
<span class="line-added"> 256     &quot;thc&quot;,       &quot;tpo&quot;,</span>
<span class="line-added"> 257     &quot;thx&quot;,       &quot;oyb&quot;,</span>
<span class="line-added"> 258     &quot;tie&quot;,       &quot;ras&quot;,</span>
<span class="line-added"> 259     &quot;tkk&quot;,       &quot;twm&quot;,</span>
<span class="line-added"> 260     &quot;tlw&quot;,       &quot;weo&quot;,</span>
<span class="line-added"> 261     &quot;tmp&quot;,       &quot;tyj&quot;,</span>
<span class="line-added"> 262     &quot;tne&quot;,       &quot;kak&quot;,</span>
<span class="line-added"> 263     &quot;tnf&quot;,       &quot;prs&quot;,</span>
<span class="line-added"> 264     &quot;tsf&quot;,       &quot;taj&quot;,</span>
<span class="line-added"> 265     &quot;uok&quot;,       &quot;ema&quot;,</span>
<span class="line-added"> 266     &quot;xba&quot;,       &quot;cax&quot;,</span>
<span class="line-added"> 267     &quot;xia&quot;,       &quot;acn&quot;,</span>
<span class="line-added"> 268     &quot;xkh&quot;,       &quot;waw&quot;,</span>
<span class="line-added"> 269     &quot;xsj&quot;,       &quot;suj&quot;,</span>
<span class="line-added"> 270     &quot;ybd&quot;,       &quot;rki&quot;,</span>
<span class="line-added"> 271     &quot;yma&quot;,       &quot;lrr&quot;,</span>
<span class="line-added"> 272     &quot;ymt&quot;,       &quot;mtm&quot;,</span>
<span class="line-added"> 273     &quot;yos&quot;,       &quot;zom&quot;,</span>
<span class="line-added"> 274     &quot;yuu&quot;,       &quot;yug&quot;,</span>
<span class="line-added"> 275 };</span>
<span class="line-added"> 276 </span>
<span class="line-added"> 277 /*</span>
<span class="line-added"> 278   Updated on 2018-04-24 from</span>
<span class="line-added"> 279 </span>
<span class="line-added"> 280   curl  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry | \</span>
<span class="line-added"> 281   grep &#39;Type: region&#39; -A 7 | egrep &#39;Subtag|Prefe&#39; | \</span>
<span class="line-added"> 282   grep -B1 &#39;Preferred&#39; | \</span>
<span class="line-added"> 283   awk -n &#39;/Subtag/ {printf(&quot;    \&quot;%s\&quot;,       &quot;, $2);} /Preferred/ {printf(&quot;\&quot;%s\&quot;,\n&quot;, $2);}&#39;</span>
<span class="line-added"> 284 */</span>
<span class="line-added"> 285 static const char DEPRECATEDREGIONS[][3] = {</span>
<span class="line-added"> 286 /*  deprecated  new */</span>
<span class="line-added"> 287     &quot;BU&quot;,       &quot;MM&quot;,</span>
<span class="line-added"> 288     &quot;DD&quot;,       &quot;DE&quot;,</span>
<span class="line-added"> 289     &quot;FX&quot;,       &quot;FR&quot;,</span>
<span class="line-added"> 290     &quot;TP&quot;,       &quot;TL&quot;,</span>
<span class="line-added"> 291     &quot;YD&quot;,       &quot;YE&quot;,</span>
<span class="line-added"> 292     &quot;ZR&quot;,       &quot;CD&quot;,</span>
 293 };
 294 
 295 /*
 296 * -------------------------------------------------
 297 *
 298 * These ultag_ functions may be exposed as APIs later
 299 *
 300 * -------------------------------------------------
 301 */
 302 
 303 static ULanguageTag*
 304 ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* status);
 305 
 306 static void
 307 ultag_close(ULanguageTag* langtag);
 308 
 309 static const char*
 310 ultag_getLanguage(const ULanguageTag* langtag);
 311 
 312 #if 0
</pre>
<hr />
<pre>
 332 static int32_t
 333 ultag_getVariantsSize(const ULanguageTag* langtag);
 334 
 335 static const char*
 336 ultag_getExtensionKey(const ULanguageTag* langtag, int32_t idx);
 337 
 338 static const char*
 339 ultag_getExtensionValue(const ULanguageTag* langtag, int32_t idx);
 340 
 341 static int32_t
 342 ultag_getExtensionsSize(const ULanguageTag* langtag);
 343 
 344 static const char*
 345 ultag_getPrivateUse(const ULanguageTag* langtag);
 346 
 347 #if 0
 348 static const char*
 349 ultag_getGrandfathered(const ULanguageTag* langtag);
 350 #endif
 351 
<span class="line-added"> 352 U_NAMESPACE_BEGIN</span>
<span class="line-added"> 353 </span>
<span class="line-added"> 354 /**</span>
<span class="line-added"> 355  * \class LocalULanguageTagPointer</span>
<span class="line-added"> 356  * &quot;Smart pointer&quot; class, closes a ULanguageTag via ultag_close().</span>
<span class="line-added"> 357  * For most methods see the LocalPointerBase base class.</span>
<span class="line-added"> 358  *</span>
<span class="line-added"> 359  * @see LocalPointerBase</span>
<span class="line-added"> 360  * @see LocalPointer</span>
<span class="line-added"> 361  * @internal</span>
<span class="line-added"> 362  */</span>
<span class="line-added"> 363 U_DEFINE_LOCAL_OPEN_POINTER(LocalULanguageTagPointer, ULanguageTag, ultag_close);</span>
<span class="line-added"> 364 </span>
<span class="line-added"> 365 U_NAMESPACE_END</span>
<span class="line-added"> 366 </span>
 367 /*
 368 * -------------------------------------------------
 369 *
 370 * Language subtag syntax validation functions
 371 *
 372 * -------------------------------------------------
 373 */
 374 
 375 static UBool
 376 _isAlphaString(const char* s, int32_t len) {
 377     int32_t i;
 378     for (i = 0; i &lt; len; i++) {
 379         if (!ISALPHA(*(s + i))) {
 380             return FALSE;
 381         }
 382     }
 383     return TRUE;
 384 }
 385 
 386 static UBool
</pre>
<hr />
<pre>
 389     for (i = 0; i &lt; len; i++) {
 390         if (!ISNUMERIC(*(s + i))) {
 391             return FALSE;
 392         }
 393     }
 394     return TRUE;
 395 }
 396 
 397 static UBool
 398 _isAlphaNumericString(const char* s, int32_t len) {
 399     int32_t i;
 400     for (i = 0; i &lt; len; i++) {
 401         if (!ISALPHA(*(s + i)) &amp;&amp; !ISNUMERIC(*(s + i))) {
 402             return FALSE;
 403         }
 404     }
 405     return TRUE;
 406 }
 407 
 408 static UBool
<span class="line-modified"> 409 _isAlphaNumericStringLimitedLength(const char* s, int32_t len, int32_t min, int32_t max) {</span>
<span class="line-added"> 410     if (len &lt; 0) {</span>
<span class="line-added"> 411         len = (int32_t)uprv_strlen(s);</span>
<span class="line-added"> 412     }</span>
<span class="line-added"> 413     if (len &gt;= min &amp;&amp; len &lt;= max &amp;&amp; _isAlphaNumericString(s, len)) {</span>
<span class="line-added"> 414         return TRUE;</span>
<span class="line-added"> 415     }</span>
<span class="line-added"> 416     return FALSE;</span>
<span class="line-added"> 417 }</span>
<span class="line-added"> 418 </span>
<span class="line-added"> 419 U_CFUNC UBool</span>
<span class="line-added"> 420 ultag_isLanguageSubtag(const char* s, int32_t len) {</span>
 421     /*
<span class="line-modified"> 422      * unicode_language_subtag = alpha{2,3} | alpha{5,8};</span>
<span class="line-modified"> 423      * NOTE: Per ICUTC 2019/01/23- accepting alpha 4</span>
<span class="line-modified"> 424      * See ICU-20372</span>


 425      */
 426     if (len &lt; 0) {
 427         len = (int32_t)uprv_strlen(s);
 428     }
 429     if (len &gt;= 2 &amp;&amp; len &lt;= 8 &amp;&amp; _isAlphaString(s, len)) {
 430         return TRUE;
 431     }
 432     return FALSE;
 433 }
 434 
 435 static UBool
 436 _isExtlangSubtag(const char* s, int32_t len) {
 437     /*
 438      * extlang       = 3ALPHA              ; selected ISO 639 codes
 439      *                 *2(&quot;-&quot; 3ALPHA)      ; permanently reserved
 440      */
 441     if (len &lt; 0) {
 442         len = (int32_t)uprv_strlen(s);
 443     }
 444     if (len == 3 &amp;&amp; _isAlphaString(s, len)) {
 445         return TRUE;
 446     }
 447     return FALSE;
 448 }
 449 
<span class="line-modified"> 450 U_CFUNC UBool</span>
<span class="line-modified"> 451 ultag_isScriptSubtag(const char* s, int32_t len) {</span>
 452     /*
 453      * script        = 4ALPHA              ; ISO 15924 code
 454      */
 455     if (len &lt; 0) {
 456         len = (int32_t)uprv_strlen(s);
 457     }
 458     if (len == 4 &amp;&amp; _isAlphaString(s, len)) {
 459         return TRUE;
 460     }
 461     return FALSE;
 462 }
 463 
<span class="line-modified"> 464 U_CFUNC UBool</span>
<span class="line-modified"> 465 ultag_isRegionSubtag(const char* s, int32_t len) {</span>
 466     /*
 467      * region        = 2ALPHA              ; ISO 3166-1 code
 468      *               / 3DIGIT              ; UN M.49 code
 469      */
 470     if (len &lt; 0) {
 471         len = (int32_t)uprv_strlen(s);
 472     }
 473     if (len == 2 &amp;&amp; _isAlphaString(s, len)) {
 474         return TRUE;
 475     }
 476     if (len == 3 &amp;&amp; _isNumericString(s, len)) {
 477         return TRUE;
 478     }
 479     return FALSE;
 480 }
 481 
 482 static UBool
 483 _isVariantSubtag(const char* s, int32_t len) {
 484     /*
 485      * variant       = 5*8alphanum         ; registered variants
 486      *               / (DIGIT 3alphanum)
 487      */
 488     if (len &lt; 0) {
 489         len = (int32_t)uprv_strlen(s);
 490     }
<span class="line-modified"> 491     if (_isAlphaNumericStringLimitedLength(s, len, 5, 8)) {</span>
 492         return TRUE;
 493     }
 494     if (len == 4 &amp;&amp; ISNUMERIC(*s) &amp;&amp; _isAlphaNumericString(s + 1, 3)) {
 495         return TRUE;
 496     }
 497     return FALSE;
 498 }
 499 
<span class="line-added"> 500 static UBool</span>
<span class="line-added"> 501 _isSepListOf(UBool (*test)(const char*, int32_t), const char* s, int32_t len) {</span>
<span class="line-added"> 502     const char *p = s;</span>
<span class="line-added"> 503     const char *pSubtag = NULL;</span>
<span class="line-added"> 504 </span>
<span class="line-added"> 505     if (len &lt; 0) {</span>
<span class="line-added"> 506         len = (int32_t)uprv_strlen(s);</span>
<span class="line-added"> 507     }</span>
<span class="line-added"> 508 </span>
<span class="line-added"> 509     while ((p - s) &lt; len) {</span>
<span class="line-added"> 510         if (*p == SEP) {</span>
<span class="line-added"> 511             if (pSubtag == NULL) {</span>
<span class="line-added"> 512                 return FALSE;</span>
<span class="line-added"> 513             }</span>
<span class="line-added"> 514             if (!test(pSubtag, (int32_t)(p - pSubtag))) {</span>
<span class="line-added"> 515                 return FALSE;</span>
<span class="line-added"> 516             }</span>
<span class="line-added"> 517             pSubtag = NULL;</span>
<span class="line-added"> 518         } else if (pSubtag == NULL) {</span>
<span class="line-added"> 519             pSubtag = p;</span>
<span class="line-added"> 520         }</span>
<span class="line-added"> 521         p++;</span>
<span class="line-added"> 522     }</span>
<span class="line-added"> 523     if (pSubtag == NULL) {</span>
<span class="line-added"> 524         return FALSE;</span>
<span class="line-added"> 525     }</span>
<span class="line-added"> 526     return test(pSubtag, (int32_t)(p - pSubtag));</span>
<span class="line-added"> 527 }</span>
<span class="line-added"> 528 </span>
<span class="line-added"> 529 U_CFUNC UBool</span>
<span class="line-added"> 530 ultag_isVariantSubtags(const char* s, int32_t len) {</span>
<span class="line-added"> 531     return _isSepListOf(&amp;_isVariantSubtag, s, len);</span>
<span class="line-added"> 532 }</span>
<span class="line-added"> 533 </span>
<span class="line-added"> 534 // This is for the ICU-specific &quot;lvariant&quot; handling.</span>
 535 static UBool
 536 _isPrivateuseVariantSubtag(const char* s, int32_t len) {
 537     /*
 538      * variant       = 1*8alphanum         ; registered variants
 539      *               / (DIGIT 3alphanum)
 540      */
<span class="line-modified"> 541     return _isAlphaNumericStringLimitedLength(s, len , 1, 8);</span>






 542 }
 543 
 544 static UBool
 545 _isExtensionSingleton(const char* s, int32_t len) {
 546     /*
 547      * extension     = singleton 1*(&quot;-&quot; (2*8alphanum))
<span class="line-added"> 548      *</span>
<span class="line-added"> 549      * singleton     = DIGIT               ; 0 - 9</span>
<span class="line-added"> 550      *               / %x41-57             ; A - W</span>
<span class="line-added"> 551      *               / %x59-5A             ; Y - Z</span>
<span class="line-added"> 552      *               / %x61-77             ; a - w</span>
<span class="line-added"> 553      *               / %x79-7A             ; y - z</span>
 554      */
 555     if (len &lt; 0) {
 556         len = (int32_t)uprv_strlen(s);
 557     }
<span class="line-modified"> 558     if (len == 1 &amp;&amp; (ISALPHA(*s) || ISNUMERIC(*s)) &amp;&amp; (uprv_tolower(*s) != PRIVATEUSE)) {</span>
 559         return TRUE;
 560     }
 561     return FALSE;
 562 }
 563 
 564 static UBool
 565 _isExtensionSubtag(const char* s, int32_t len) {
 566     /*
 567      * extension     = singleton 1*(&quot;-&quot; (2*8alphanum))
 568      */
<span class="line-added"> 569     return _isAlphaNumericStringLimitedLength(s, len, 2, 8);</span>
<span class="line-added"> 570 }</span>
<span class="line-added"> 571 </span>
<span class="line-added"> 572 U_CFUNC UBool</span>
<span class="line-added"> 573 ultag_isExtensionSubtags(const char* s, int32_t len) {</span>
<span class="line-added"> 574     return _isSepListOf(&amp;_isExtensionSubtag, s, len);</span>
<span class="line-added"> 575 }</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577 static UBool</span>
<span class="line-added"> 578 _isPrivateuseValueSubtag(const char* s, int32_t len) {</span>
<span class="line-added"> 579     /*</span>
<span class="line-added"> 580      * privateuse    = &quot;x&quot; 1*(&quot;-&quot; (1*8alphanum))</span>
<span class="line-added"> 581      */</span>
<span class="line-added"> 582     return _isAlphaNumericStringLimitedLength(s, len, 1, 8);</span>
<span class="line-added"> 583 }</span>
<span class="line-added"> 584 </span>
<span class="line-added"> 585 U_CFUNC UBool</span>
<span class="line-added"> 586 ultag_isPrivateuseValueSubtags(const char* s, int32_t len) {</span>
<span class="line-added"> 587     return _isSepListOf(&amp;_isPrivateuseValueSubtag, s, len);</span>
<span class="line-added"> 588 }</span>
<span class="line-added"> 589 </span>
<span class="line-added"> 590 U_CFUNC UBool</span>
<span class="line-added"> 591 ultag_isUnicodeLocaleAttribute(const char* s, int32_t len) {</span>
<span class="line-added"> 592     /*</span>
<span class="line-added"> 593      * attribute = alphanum{3,8} ;</span>
<span class="line-added"> 594      */</span>
<span class="line-added"> 595     return _isAlphaNumericStringLimitedLength(s, len , 3, 8);</span>
<span class="line-added"> 596 }</span>
<span class="line-added"> 597 </span>
<span class="line-added"> 598 U_CFUNC UBool</span>
<span class="line-added"> 599 ultag_isUnicodeLocaleAttributes(const char* s, int32_t len) {</span>
<span class="line-added"> 600     return _isSepListOf(&amp;ultag_isUnicodeLocaleAttribute, s, len);</span>
<span class="line-added"> 601 }</span>
<span class="line-added"> 602 </span>
<span class="line-added"> 603 U_CFUNC UBool</span>
<span class="line-added"> 604 ultag_isUnicodeLocaleKey(const char* s, int32_t len) {</span>
<span class="line-added"> 605     /*</span>
<span class="line-added"> 606      * key = alphanum alpha ;</span>
<span class="line-added"> 607      */</span>
 608     if (len &lt; 0) {
 609         len = (int32_t)uprv_strlen(s);
 610     }
<span class="line-modified"> 611     if (len == 2 &amp;&amp; (ISALPHA(*s) || ISNUMERIC(*s)) &amp;&amp; ISALPHA(s[1])) {</span>
 612         return TRUE;
 613     }
 614     return FALSE;
 615 }
 616 
<span class="line-modified"> 617 U_CFUNC UBool</span>
<span class="line-modified"> 618 _isUnicodeLocaleTypeSubtag(const char*s, int32_t len) {</span>
<span class="line-modified"> 619     /*</span>
<span class="line-modified"> 620      * alphanum{3,8}</span>
<span class="line-modified"> 621      */</span>
<span class="line-modified"> 622     return _isAlphaNumericStringLimitedLength(s, len , 3, 8);</span>
<span class="line-modified"> 623 }</span>

 624 
<span class="line-modified"> 625 U_CFUNC UBool</span>
<span class="line-modified"> 626 ultag_isUnicodeLocaleType(const char*s, int32_t len) {</span>
<span class="line-modified"> 627     /*</span>
<span class="line-modified"> 628      * type = alphanum{3,8} (sep alphanum{3,8})* ;</span>
<span class="line-modified"> 629      */</span>
<span class="line-modified"> 630     return _isSepListOf(&amp;_isUnicodeLocaleTypeSubtag, s, len);</span>












 631 }
 632 
 633 static UBool
<span class="line-modified"> 634 _isTKey(const char* s, int32_t len)</span>
<span class="line-added"> 635 {</span>
 636     /*
<span class="line-modified"> 637      * tkey = alpha digit ;</span>
 638      */
 639     if (len &lt; 0) {
 640         len = (int32_t)uprv_strlen(s);
 641     }
<span class="line-modified"> 642     if (len == 2 &amp;&amp; ISALPHA(*s) &amp;&amp; ISNUMERIC(*(s + 1))) {</span>
 643         return TRUE;
 644     }
 645     return FALSE;
 646 }
 647 
 648 static UBool
<span class="line-modified"> 649 _isTValue(const char* s, int32_t len)</span>
<span class="line-modified"> 650 {</span>
<span class="line-modified"> 651     /*</span>
<span class="line-modified"> 652      * tvalue = (sep alphanum{3,8})+ ;</span>
<span class="line-modified"> 653      */</span>
<span class="line-modified"> 654     return _isAlphaNumericStringLimitedLength(s, len , 3, 8);</span>
<span class="line-modified"> 655 }</span>
 656 
<span class="line-modified"> 657 static UBool</span>
<span class="line-modified"> 658 _isTransformedExtensionSubtag(int32_t&amp; state, const char* s, int32_t len)</span>
<span class="line-modified"> 659 {</span>
<span class="line-modified"> 660     const int32_t kStart = 0;       // Start, wait for unicode_language_subtag, tkey or end</span>
<span class="line-added"> 661     const int32_t kGotLanguage = 1; // Got unicode_language_subtag, wait for unicode_script_subtag,</span>
<span class="line-added"> 662                                     // unicode_region_subtag, unicode_variant_subtag, tkey or end</span>
<span class="line-added"> 663     const int32_t kGotScript = 2;   // Got unicode_script_subtag, wait for unicode_region_subtag,</span>
<span class="line-added"> 664                                     // unicode_variant_subtag, tkey, or end</span>
<span class="line-added"> 665     const int32_t kGotRegion = 3;   // Got unicode_region_subtag, wait for unicode_variant_subtag,</span>
<span class="line-added"> 666                                     // tkey, or end.</span>
<span class="line-added"> 667     const int32_t kGotVariant = 4;  // Got unicode_variant_subtag, wait for unicode_variant_subtag</span>
<span class="line-added"> 668                                     // tkey or end.</span>
<span class="line-added"> 669     const int32_t kGotTKey = -1;    // Got tkey, wait for tvalue. ERROR if stop here.</span>
<span class="line-added"> 670     const int32_t kGotTValue = 6;   // Got tvalue, wait for tkey, tvalue or end</span>
<span class="line-added"> 671 </span>
<span class="line-added"> 672     switch (state) {</span>
<span class="line-added"> 673         case kStart:</span>
<span class="line-added"> 674             if (ultag_isLanguageSubtag(s, len)) {</span>
<span class="line-added"> 675                 state = kGotLanguage;</span>
<span class="line-added"> 676                 return TRUE;</span>
<span class="line-added"> 677             }</span>
<span class="line-added"> 678             if (_isTKey(s, len)) {</span>
<span class="line-added"> 679                 state = kGotTKey;</span>
<span class="line-added"> 680                 return TRUE;</span>
 681             }
<span class="line-modified"> 682             return FALSE;</span>
<span class="line-modified"> 683         case kGotLanguage:</span>
<span class="line-added"> 684             if (ultag_isScriptSubtag(s, len)) {</span>
<span class="line-added"> 685                 state = kGotScript;</span>
<span class="line-added"> 686                 return TRUE;</span>
<span class="line-added"> 687             }</span>
<span class="line-added"> 688             U_FALLTHROUGH;</span>
<span class="line-added"> 689         case kGotScript:</span>
<span class="line-added"> 690             if (ultag_isRegionSubtag(s, len)) {</span>
<span class="line-added"> 691                 state = kGotRegion;</span>
<span class="line-added"> 692                 return TRUE;</span>
<span class="line-added"> 693             }</span>
<span class="line-added"> 694             U_FALLTHROUGH;</span>
<span class="line-added"> 695         case kGotRegion:</span>
<span class="line-added"> 696             U_FALLTHROUGH;</span>
<span class="line-added"> 697         case kGotVariant:</span>
<span class="line-added"> 698             if (_isVariantSubtag(s, len)) {</span>
<span class="line-added"> 699                 state = kGotVariant;</span>
<span class="line-added"> 700                 return TRUE;</span>
<span class="line-added"> 701             }</span>
<span class="line-added"> 702             if (_isTKey(s, len)) {</span>
<span class="line-added"> 703                 state = kGotTKey;</span>
<span class="line-added"> 704                 return TRUE;</span>
 705             }
<span class="line-modified"> 706             return FALSE;</span>
<span class="line-modified"> 707         case kGotTKey:</span>
<span class="line-modified"> 708             if (_isTValue(s, len)) {</span>
<span class="line-modified"> 709                 state = kGotTValue;</span>
<span class="line-modified"> 710                 return TRUE;</span>
<span class="line-modified"> 711             }</span>
<span class="line-modified"> 712             return FALSE;</span>
<span class="line-modified"> 713         case kGotTValue:</span>
<span class="line-added"> 714             if (_isTKey(s, len)) {</span>
<span class="line-added"> 715                 state = kGotTKey;</span>
<span class="line-added"> 716                 return TRUE;</span>
<span class="line-added"> 717             }</span>
<span class="line-added"> 718             if (_isTValue(s, len)) {</span>
<span class="line-added"> 719                 return TRUE;</span>
<span class="line-added"> 720             }</span>
<span class="line-added"> 721             return FALSE;</span>
 722     }
<span class="line-modified"> 723     return FALSE;</span>
 724 }
 725 
<span class="line-modified"> 726 static UBool</span>
<span class="line-modified"> 727 _isUnicodeExtensionSubtag(int32_t&amp; state, const char* s, int32_t len)</span>
<span class="line-modified"> 728 {</span>
<span class="line-modified"> 729     const int32_t kStart = 0;         // Start, wait for a key or attribute or end</span>
<span class="line-modified"> 730     const int32_t kGotKey = 1;        // Got a key, wait for type or key or end</span>
<span class="line-modified"> 731     const int32_t kGotType = 2;       // Got a type, wait for key or end</span>
<span class="line-modified"> 732 </span>
<span class="line-added"> 733     switch (state) {</span>
<span class="line-added"> 734         case kStart:</span>
<span class="line-added"> 735             if (ultag_isUnicodeLocaleKey(s, len)) {</span>
<span class="line-added"> 736                 state = kGotKey;</span>
<span class="line-added"> 737                 return TRUE;</span>
<span class="line-added"> 738             }</span>
<span class="line-added"> 739             if (ultag_isUnicodeLocaleAttribute(s, len)) {</span>
<span class="line-added"> 740                 return TRUE;</span>
<span class="line-added"> 741             }</span>
<span class="line-added"> 742             return FALSE;</span>
<span class="line-added"> 743         case kGotKey:</span>
<span class="line-added"> 744             if (ultag_isUnicodeLocaleKey(s, len)) {</span>
<span class="line-added"> 745                 return TRUE;</span>
<span class="line-added"> 746             }</span>
<span class="line-added"> 747             if (_isUnicodeLocaleTypeSubtag(s, len)) {</span>
<span class="line-added"> 748                 state = kGotType;</span>
<span class="line-added"> 749                 return TRUE;</span>
<span class="line-added"> 750             }</span>
<span class="line-added"> 751             return FALSE;</span>
<span class="line-added"> 752         case kGotType:</span>
<span class="line-added"> 753             if (ultag_isUnicodeLocaleKey(s, len)) {</span>
<span class="line-added"> 754                 state = kGotKey;</span>
<span class="line-added"> 755                 return TRUE;</span>
<span class="line-added"> 756             }</span>
<span class="line-added"> 757             if (_isUnicodeLocaleTypeSubtag(s, len)) {</span>
<span class="line-added"> 758                 return TRUE;</span>
<span class="line-added"> 759             }</span>
<span class="line-added"> 760             return FALSE;</span>
 761     }
 762     return FALSE;
 763 }
 764 
<span class="line-modified"> 765 static UBool</span>
<span class="line-modified"> 766 _isStatefulSepListOf(UBool (*test)(int32_t&amp;, const char*, int32_t), const char* s, int32_t len)</span>
<span class="line-added"> 767 {</span>
<span class="line-added"> 768     int32_t state = 0;</span>
 769     const char* p;
<span class="line-added"> 770     const char* start = s;</span>
 771     int32_t subtagLen = 0;
 772 
 773     if (len &lt; 0) {
 774         len = (int32_t)uprv_strlen(s);
 775     }
 776 
 777     for (p = s; len &gt; 0; p++, len--) {
 778         if (*p == SEP) {
<span class="line-modified"> 779             if (!test(state, start, subtagLen)) {</span>
 780                 return FALSE;
 781             }
 782             subtagLen = 0;
<span class="line-modified"> 783             start = p + 1;</span>




 784         } else {
<span class="line-modified"> 785             subtagLen++;</span>
 786         }
 787     }
 788 
<span class="line-modified"> 789     if (test(state, start, subtagLen) &amp;&amp; state &gt;= 0) {</span>
<span class="line-added"> 790         return TRUE;</span>
<span class="line-added"> 791     }</span>
<span class="line-added"> 792     return FALSE;</span>
<span class="line-added"> 793 }</span>
<span class="line-added"> 794 </span>
<span class="line-added"> 795 U_CFUNC UBool</span>
<span class="line-added"> 796 ultag_isTransformedExtensionSubtags(const char* s, int32_t len)</span>
<span class="line-added"> 797 {</span>
<span class="line-added"> 798     return _isStatefulSepListOf(&amp;_isTransformedExtensionSubtag, s, len);</span>
<span class="line-added"> 799 }</span>
<span class="line-added"> 800 </span>
<span class="line-added"> 801 U_CFUNC UBool</span>
<span class="line-added"> 802 ultag_isUnicodeExtensionSubtags(const char* s, int32_t len) {</span>
<span class="line-added"> 803     return _isStatefulSepListOf(&amp;_isUnicodeExtensionSubtag, s, len);</span>
 804 }
<span class="line-added"> 805 </span>
<span class="line-added"> 806 </span>
 807 /*
 808 * -------------------------------------------------
 809 *
 810 * Helper functions
 811 *
 812 * -------------------------------------------------
 813 */
 814 
 815 static UBool
 816 _addVariantToList(VariantListEntry **first, VariantListEntry *var) {
 817     UBool bAdded = TRUE;
 818 
 819     if (*first == NULL) {
 820         var-&gt;next = NULL;
 821         *first = var;
 822     } else {
 823         VariantListEntry *prev, *cur;
 824         int32_t cmp;
 825 
 826         /* variants order should be preserved */
</pre>
<hr />
<pre>
 973 _initializeULanguageTag(ULanguageTag* langtag) {
 974     int32_t i;
 975 
 976     langtag-&gt;buf = NULL;
 977 
 978     langtag-&gt;language = EMPTY;
 979     for (i = 0; i &lt; MAXEXTLANG; i++) {
 980         langtag-&gt;extlang[i] = NULL;
 981     }
 982 
 983     langtag-&gt;script = EMPTY;
 984     langtag-&gt;region = EMPTY;
 985 
 986     langtag-&gt;variants = NULL;
 987     langtag-&gt;extensions = NULL;
 988 
 989     langtag-&gt;grandfathered = EMPTY;
 990     langtag-&gt;privateuse = EMPTY;
 991 }
 992 
<span class="line-modified"> 993 static void</span>
<span class="line-modified"> 994 _appendLanguageToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UErrorCode* status) {</span>
 995     char buf[ULOC_LANG_CAPACITY];
 996     UErrorCode tmpStatus = U_ZERO_ERROR;
 997     int32_t len, i;

 998 
 999     if (U_FAILURE(*status)) {
<span class="line-modified">1000         return;</span>
1001     }
1002 
1003     len = uloc_getLanguage(localeID, buf, sizeof(buf), &amp;tmpStatus);
1004     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1005         if (strict) {
1006             *status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">1007             return;</span>
1008         }
1009         len = 0;
1010     }
1011 
1012     /* Note: returned language code is in lower case letters */
1013 
1014     if (len == 0) {
<span class="line-modified">1015         sink.Append(LANG_UND, LANG_UND_LEN);</span>
<span class="line-modified">1016     } else if (!ultag_isLanguageSubtag(buf, len)) {</span>



1017             /* invalid language code */
1018         if (strict) {
1019             *status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">1020             return;</span>



1021         }
<span class="line-modified">1022         sink.Append(LANG_UND, LANG_UND_LEN);</span>
1023     } else {
1024         /* resolve deprecated */
1025         for (i = 0; i &lt; UPRV_LENGTHOF(DEPRECATEDLANGS); i += 2) {
<span class="line-added">1026             // 2-letter deprecated subtags are listede before 3-letter</span>
<span class="line-added">1027             // ones in DEPRECATEDLANGS[]. Get out of loop on coming</span>
<span class="line-added">1028             // across the 1st 3-letter subtag, if the input is a 2-letter code.</span>
<span class="line-added">1029             // to avoid continuing to try when there&#39;s no match.</span>
<span class="line-added">1030             if (uprv_strlen(buf) &lt; uprv_strlen(DEPRECATEDLANGS[i])) break;</span>
1031             if (uprv_compareInvCharsAsAscii(buf, DEPRECATEDLANGS[i]) == 0) {
1032                 uprv_strcpy(buf, DEPRECATEDLANGS[i + 1]);
1033                 len = (int32_t)uprv_strlen(buf);
1034                 break;
1035             }
1036         }
<span class="line-modified">1037         sink.Append(buf, len);</span>



1038     }


1039 }
1040 
<span class="line-modified">1041 static void</span>
<span class="line-modified">1042 _appendScriptToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UErrorCode* status) {</span>
1043     char buf[ULOC_SCRIPT_CAPACITY];
1044     UErrorCode tmpStatus = U_ZERO_ERROR;
1045     int32_t len;

1046 
1047     if (U_FAILURE(*status)) {
<span class="line-modified">1048         return;</span>
1049     }
1050 
1051     len = uloc_getScript(localeID, buf, sizeof(buf), &amp;tmpStatus);
1052     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1053         if (strict) {
1054             *status = U_ILLEGAL_ARGUMENT_ERROR;
1055         }
<span class="line-modified">1056         return;</span>
1057     }
1058 
1059     if (len &gt; 0) {
<span class="line-modified">1060         if (!ultag_isScriptSubtag(buf, len)) {</span>
1061             /* invalid script code */
1062             if (strict) {
1063                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1064             }
<span class="line-modified">1065             return;</span>
1066         } else {
<span class="line-modified">1067             sink.Append(&quot;-&quot;, 1);</span>
<span class="line-modified">1068             sink.Append(buf, len);</span>







1069         }
1070     }


1071 }
1072 
<span class="line-modified">1073 static void</span>
<span class="line-modified">1074 _appendRegionToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UErrorCode* status) {</span>
1075     char buf[ULOC_COUNTRY_CAPACITY];
1076     UErrorCode tmpStatus = U_ZERO_ERROR;
1077     int32_t len;

1078 
1079     if (U_FAILURE(*status)) {
<span class="line-modified">1080         return;</span>
1081     }
1082 
1083     len = uloc_getCountry(localeID, buf, sizeof(buf), &amp;tmpStatus);
1084     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1085         if (strict) {
1086             *status = U_ILLEGAL_ARGUMENT_ERROR;
1087         }
<span class="line-modified">1088         return;</span>
1089     }
1090 
1091     if (len &gt; 0) {
<span class="line-modified">1092         if (!ultag_isRegionSubtag(buf, len)) {</span>
1093             /* invalid region code */
1094             if (strict) {
1095                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1096             }
<span class="line-modified">1097             return;</span>
1098         } else {
<span class="line-modified">1099             sink.Append(&quot;-&quot;, 1);</span>
<span class="line-modified">1100             /* resolve deprecated */</span>
<span class="line-modified">1101             for (int i = 0; i &lt; UPRV_LENGTHOF(DEPRECATEDREGIONS); i += 2) {</span>
<span class="line-modified">1102                 if (uprv_compareInvCharsAsAscii(buf, DEPRECATEDREGIONS[i]) == 0) {</span>
<span class="line-modified">1103                     uprv_strcpy(buf, DEPRECATEDREGIONS[i + 1]);</span>
<span class="line-modified">1104                     len = (int32_t)uprv_strlen(buf);</span>
<span class="line-modified">1105                     break;</span>
<span class="line-added">1106                 }</span>
1107             }
<span class="line-modified">1108             sink.Append(buf, len);</span>
1109         }
1110     }


1111 }
1112 
<span class="line-modified">1113 static void</span>
<span class="line-modified">1114 _appendVariantsToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UBool *hadPosix, UErrorCode* status) {</span>
1115     char buf[ULOC_FULLNAME_CAPACITY];
1116     UErrorCode tmpStatus = U_ZERO_ERROR;
1117     int32_t len, i;

1118 
1119     if (U_FAILURE(*status)) {
<span class="line-modified">1120         return;</span>
1121     }
1122 
1123     len = uloc_getVariant(localeID, buf, sizeof(buf), &amp;tmpStatus);
1124     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1125         if (strict) {
1126             *status = U_ILLEGAL_ARGUMENT_ERROR;
1127         }
<span class="line-modified">1128         return;</span>
1129     }
1130 
1131     if (len &gt; 0) {
1132         char *p, *pVar;
1133         UBool bNext = TRUE;
1134         VariantListEntry *var;
1135         VariantListEntry *varFirst = NULL;
1136 
1137         pVar = NULL;
1138         p = buf;
1139         while (bNext) {
1140             if (*p == SEP || *p == LOCALE_SEP || *p == 0) {
1141                 if (*p == 0) {
1142                     bNext = FALSE;
1143                 } else {
1144                     *p = 0; /* terminate */
1145                 }
1146                 if (pVar == NULL) {
1147                     if (strict) {
1148                         *status = U_ILLEGAL_ARGUMENT_ERROR;
</pre>
<hr />
<pre>
1185                     } else if (_isPrivateuseValueSubtag(pVar, -1)) {
1186                         /* Handle private use subtags separately */
1187                         break;
1188                     }
1189                 }
1190                 /* reset variant starting position */
1191                 pVar = NULL;
1192             } else if (pVar == NULL) {
1193                 pVar = p;
1194             }
1195             p++;
1196         }
1197 
1198         if (U_SUCCESS(*status)) {
1199             if (varFirst != NULL) {
1200                 int32_t varLen;
1201 
1202                 /* write out validated/normalized variants to the target */
1203                 var = varFirst;
1204                 while (var != NULL) {
<span class="line-modified">1205                     sink.Append(&quot;-&quot;, 1);</span>



1206                     varLen = (int32_t)uprv_strlen(var-&gt;variant);
<span class="line-modified">1207                     sink.Append(var-&gt;variant, varLen);</span>



1208                     var = var-&gt;next;
1209                 }
1210             }
1211         }
1212 
1213         /* clean up */
1214         var = varFirst;
1215         while (var != NULL) {
1216             VariantListEntry *tmpVar = var-&gt;next;
1217             uprv_free(var);
1218             var = tmpVar;
1219         }
1220 
1221         if (U_FAILURE(*status)) {
<span class="line-modified">1222             return;</span>
1223         }
1224     }



1225 }
1226 
<span class="line-modified">1227 static void</span>
<span class="line-modified">1228 _appendKeywordsToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UBool hadPosix, UErrorCode* status) {</span>

1229     char attrBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY] = { 0 };
1230     int32_t attrBufLength = 0;


1231 
<span class="line-modified">1232     icu::MemoryPool&lt;AttributeListEntry&gt; attrPool;</span>
<span class="line-added">1233     icu::MemoryPool&lt;ExtensionListEntry&gt; extPool;</span>
<span class="line-added">1234     icu::MemoryPool&lt;icu::CharString&gt; strPool;</span>
<span class="line-added">1235 </span>
<span class="line-added">1236     icu::LocalUEnumerationPointer keywordEnum(uloc_openKeywords(localeID, status));</span>
1237     if (U_FAILURE(*status) &amp;&amp; !hadPosix) {
<span class="line-modified">1238         return;</span>

1239     }
<span class="line-modified">1240     if (keywordEnum.isValid() || hadPosix) {</span>
1241         /* reorder extensions */
1242         int32_t len;
1243         const char *key;
1244         ExtensionListEntry *firstExt = NULL;
1245         ExtensionListEntry *ext;
1246         AttributeListEntry *firstAttr = NULL;
1247         AttributeListEntry *attr;
<span class="line-modified">1248         icu::MemoryPool&lt;icu::CharString&gt; extBufPool;</span>



1249         const char *bcpKey=nullptr, *bcpValue=nullptr;
1250         UErrorCode tmpStatus = U_ZERO_ERROR;
1251         int32_t keylen;
1252         UBool isBcpUExt;
1253 
1254         while (TRUE) {
<span class="line-modified">1255             icu::CharString buf;</span>
<span class="line-added">1256             key = uenum_next(keywordEnum.getAlias(), NULL, status);</span>
1257             if (key == NULL) {
1258                 break;
1259             }
<span class="line-modified">1260             char* buffer;</span>
<span class="line-modified">1261             int32_t resultCapacity = ULOC_KEYWORD_AND_VALUES_CAPACITY;</span>
<span class="line-modified">1262 </span>
<span class="line-added">1263             for (;;) {</span>
<span class="line-added">1264                 buffer = buf.getAppendBuffer(</span>
<span class="line-added">1265                         /*minCapacity=*/resultCapacity,</span>
<span class="line-added">1266                         /*desiredCapacityHint=*/resultCapacity,</span>
<span class="line-added">1267                         resultCapacity,</span>
<span class="line-added">1268                         tmpStatus);</span>
<span class="line-added">1269 </span>
<span class="line-added">1270                 if (U_FAILURE(tmpStatus)) {</span>
<span class="line-added">1271                     break;</span>
<span class="line-added">1272                 }</span>
<span class="line-added">1273 </span>
<span class="line-added">1274                 len = uloc_getKeywordValue(</span>
<span class="line-added">1275                         localeID, key, buffer, resultCapacity, &amp;tmpStatus);</span>
<span class="line-added">1276 </span>
<span class="line-added">1277                 if (tmpStatus != U_BUFFER_OVERFLOW_ERROR) {</span>
<span class="line-added">1278                     break;</span>
<span class="line-added">1279                 }</span>
<span class="line-added">1280 </span>
<span class="line-added">1281                 resultCapacity = len;</span>
<span class="line-added">1282                 tmpStatus = U_ZERO_ERROR;</span>
<span class="line-added">1283             }</span>
<span class="line-added">1284 </span>
<span class="line-added">1285             if (U_FAILURE(tmpStatus)) {</span>
<span class="line-added">1286                 if (tmpStatus == U_MEMORY_ALLOCATION_ERROR) {</span>
<span class="line-added">1287                     *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1288                     break;</span>
<span class="line-added">1289                 }</span>
1290                 if (strict) {
1291                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1292                     break;
1293                 }
1294                 /* ignore this keyword */
1295                 tmpStatus = U_ZERO_ERROR;
1296                 continue;
1297             }
1298 
<span class="line-added">1299             buf.append(buffer, len, tmpStatus);</span>
<span class="line-added">1300             if (tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {</span>
<span class="line-added">1301                 tmpStatus = U_ZERO_ERROR;  // Terminators provided by CharString.</span>
<span class="line-added">1302             }</span>
<span class="line-added">1303 </span>
1304             keylen = (int32_t)uprv_strlen(key);
1305             isBcpUExt = (keylen &gt; 1);
1306 
1307             /* special keyword used for representing Unicode locale attributes */
1308             if (uprv_strcmp(key, LOCALE_ATTRIBUTE_KEY) == 0) {
1309                 if (len &gt; 0) {
1310                     int32_t i = 0;
1311                     while (TRUE) {
1312                         attrBufLength = 0;
1313                         for (; i &lt; len; i++) {
1314                             if (buf[i] != &#39;-&#39;) {
1315                                 attrBuf[attrBufLength++] = buf[i];
1316                             } else {
1317                                 i++;
1318                                 break;
1319                             }
1320                         }
1321                         if (attrBufLength &gt; 0) {
1322                             attrBuf[attrBufLength] = 0;
1323 
1324                         } else if (i &gt;= len){
1325                             break;
1326                         }
1327 
1328                         /* create AttributeListEntry */
<span class="line-modified">1329                         attr = attrPool.create();</span>
1330                         if (attr == NULL) {
1331                             *status = U_MEMORY_ALLOCATION_ERROR;
1332                             break;
1333                         }
<span class="line-modified">1334                         icu::CharString* attrValue =</span>
<span class="line-added">1335                                 strPool.create(attrBuf, attrBufLength, *status);</span>
1336                         if (attrValue == NULL) {
1337                             *status = U_MEMORY_ALLOCATION_ERROR;
1338                             break;
1339                         }
<span class="line-modified">1340                         if (U_FAILURE(*status)) {</span>
<span class="line-modified">1341                             break;</span>
<span class="line-added">1342                         }</span>
<span class="line-added">1343                         attr-&gt;attribute = attrValue-&gt;data();</span>
1344 
1345                         if (!_addAttributeToList(&amp;firstAttr, attr)) {


1346                             if (strict) {
1347                                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1348                                 break;
1349                             }
1350                         }
1351                     }
1352                     /* for a place holder ExtensionListEntry */
1353                     bcpKey = LOCALE_ATTRIBUTE_KEY;
1354                     bcpValue = NULL;
1355                 }
1356             } else if (isBcpUExt) {
1357                 bcpKey = uloc_toUnicodeLocaleKey(key);
1358                 if (bcpKey == NULL) {
1359                     if (strict) {
1360                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1361                         break;
1362                     }
1363                     continue;
1364                 }
1365 
1366                 /* we&#39;ve checked buf is null-terminated above */
<span class="line-modified">1367                 bcpValue = uloc_toUnicodeLocaleType(key, buf.data());</span>
1368                 if (bcpValue == NULL) {
1369                     if (strict) {
1370                         *status = U_ILLEGAL_ARGUMENT_ERROR;
1371                         break;
1372                     }
1373                     continue;
1374                 }
<span class="line-modified">1375                 if (bcpValue == buf.data()) {</span>
1376                     /*
1377                     When uloc_toUnicodeLocaleType(key, buf) returns the
1378                     input value as is, the value is well-formed, but has
1379                     no known mapping. This implementation normalizes the
<span class="line-modified">1380                     value to lower case</span>
1381                     */
<span class="line-added">1382                     icu::CharString* extBuf = extBufPool.create();</span>
<span class="line-added">1383                     if (extBuf == nullptr) {</span>
<span class="line-added">1384                         *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1385                         break;</span>
<span class="line-added">1386                     }</span>
1387                     int32_t bcpValueLen = static_cast&lt;int32_t&gt;(uprv_strlen(bcpValue));
<span class="line-modified">1388                     int32_t resultCapacity;</span>
<span class="line-modified">1389                     char* pExtBuf = extBuf-&gt;getAppendBuffer(</span>
<span class="line-modified">1390                             /*minCapacity=*/bcpValueLen,</span>
<span class="line-added">1391                             /*desiredCapacityHint=*/bcpValueLen,</span>
<span class="line-added">1392                             resultCapacity,</span>
<span class="line-added">1393                             tmpStatus);</span>
<span class="line-added">1394                     if (U_FAILURE(tmpStatus)) {</span>
<span class="line-added">1395                         *status = tmpStatus;</span>
<span class="line-added">1396                         break;</span>
<span class="line-added">1397                     }</span>
1398 
<span class="line-modified">1399                     uprv_strcpy(pExtBuf, bcpValue);</span>
<span class="line-added">1400                     T_CString_toLowerCase(pExtBuf);</span>
1401 
<span class="line-modified">1402                     extBuf-&gt;append(pExtBuf, bcpValueLen, tmpStatus);</span>
<span class="line-modified">1403                     if (U_FAILURE(tmpStatus)) {</span>
<span class="line-modified">1404                         *status = tmpStatus;</span>
<span class="line-modified">1405                         break;</span>




1406                     }
<span class="line-added">1407 </span>
<span class="line-added">1408                     bcpValue = extBuf-&gt;data();</span>
1409                 }
1410             } else {
1411                 if (*key == PRIVATEUSE) {
<span class="line-modified">1412                     if (!ultag_isPrivateuseValueSubtags(buf.data(), len)) {</span>
1413                         if (strict) {
1414                             *status = U_ILLEGAL_ARGUMENT_ERROR;
1415                             break;
1416                         }
1417                         continue;
1418                     }
1419                 } else {
<span class="line-modified">1420                     if (!_isExtensionSingleton(key, keylen) || !ultag_isExtensionSubtags(buf.data(), len)) {</span>
1421                         if (strict) {
1422                             *status = U_ILLEGAL_ARGUMENT_ERROR;
1423                             break;
1424                         }
1425                         continue;
1426                     }
1427                 }
1428                 bcpKey = key;
<span class="line-modified">1429                 icu::CharString* extBuf =</span>
<span class="line-modified">1430                     extBufPool.create(buf.data(), len, tmpStatus);</span>
<span class="line-modified">1431                 if (extBuf == nullptr) {</span>
<span class="line-modified">1432                     *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1433                     break;</span>
<span class="line-modified">1434                 }</span>
<span class="line-modified">1435                 if (U_FAILURE(tmpStatus)) {</span>
<span class="line-modified">1436                     *status = tmpStatus;</span>




1437                     break;
1438                 }
<span class="line-added">1439                 bcpValue = extBuf-&gt;data();</span>
1440             }
1441 
1442             /* create ExtensionListEntry */
<span class="line-modified">1443             ext = extPool.create();</span>
1444             if (ext == NULL) {
1445                 *status = U_MEMORY_ALLOCATION_ERROR;
1446                 break;
1447             }
1448             ext-&gt;key = bcpKey;
1449             ext-&gt;value = bcpValue;
1450 
1451             if (!_addExtensionToList(&amp;firstExt, ext, TRUE)) {

1452                 if (strict) {
1453                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1454                     break;
1455                 }
1456             }
1457         }
1458 
1459         /* Special handling for POSIX variant - add the keywords for POSIX */
1460         if (hadPosix) {
1461             /* create ExtensionListEntry for POSIX */
<span class="line-modified">1462             ext = extPool.create();</span>
1463             if (ext == NULL) {
1464                 *status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified">1465                 return;</span>
1466             }
1467             ext-&gt;key = POSIX_KEY;
1468             ext-&gt;value = POSIX_VALUE;
1469 
1470             if (!_addExtensionToList(&amp;firstExt, ext, TRUE)) {
<span class="line-modified">1471                 // Silently ignore errors.</span>
1472             }
1473         }
1474 
1475         if (U_SUCCESS(*status) &amp;&amp; (firstExt != NULL || firstAttr != NULL)) {
1476             UBool startLDMLExtension = FALSE;
1477             for (ext = firstExt; ext; ext = ext-&gt;next) {
1478                 if (!startLDMLExtension &amp;&amp; uprv_strlen(ext-&gt;key) &gt; 1) {
1479                     /* first LDML u singlton extension */
<span class="line-modified">1480                    sink.Append(&quot;-u&quot;, 2);</span>








1481                    startLDMLExtension = TRUE;
1482                 }
1483 
1484                 /* write out the sorted BCP47 attributes, extensions and private use */
1485                 if (uprv_strcmp(ext-&gt;key, LOCALE_ATTRIBUTE_KEY) == 0) {
1486                     /* write the value for the attributes */
1487                     for (attr = firstAttr; attr; attr = attr-&gt;next) {
<span class="line-modified">1488                         sink.Append(&quot;-&quot;, 1);</span>
<span class="line-modified">1489                         sink.Append(</span>
<span class="line-modified">1490                                 attr-&gt;attribute, static_cast&lt;int32_t&gt;(uprv_strlen(attr-&gt;attribute)));</span>






1491                     }
1492                 } else {
<span class="line-modified">1493                     sink.Append(&quot;-&quot;, 1);</span>
<span class="line-modified">1494                     sink.Append(ext-&gt;key, static_cast&lt;int32_t&gt;(uprv_strlen(ext-&gt;key)));</span>
<span class="line-modified">1495                     sink.Append(&quot;-&quot;, 1);</span>
<span class="line-modified">1496                     sink.Append(ext-&gt;value, static_cast&lt;int32_t&gt;(uprv_strlen(ext-&gt;value)));</span>














1497                 }
1498             }
1499         }























1500     }


1501 }
1502 
1503 /**
1504  * Append keywords parsed from LDML extension value
1505  * e.g. &quot;u-ca-gregory-co-trad&quot; -&gt; {calendar = gregorian} {collation = traditional}
1506  * Note: char* buf is used for storing keywords
1507  */
1508 static void
<span class="line-modified">1509 _appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendTo, icu::MemoryPool&lt;ExtensionListEntry&gt;&amp; extPool, icu::MemoryPool&lt;icu::CharString&gt;&amp; kwdBuf, UBool *posixVariant, UErrorCode *status) {</span>
1510     const char *pTag;   /* beginning of current subtag */
1511     const char *pKwds;  /* beginning of key-type pairs */
1512     UBool variantExists = *posixVariant;
1513 
1514     ExtensionListEntry *kwdFirst = NULL;    /* first LDML keyword */
1515     ExtensionListEntry *kwd, *nextKwd;
1516 



1517     int32_t len;




1518 
1519     /* Reset the posixVariant value */
1520     *posixVariant = FALSE;
1521 
1522     pTag = ldmlext;
1523     pKwds = NULL;
1524 
<span class="line-modified">1525     {</span>
<span class="line-modified">1526         AttributeListEntry *attrFirst = NULL;   /* first attribute */</span>
<span class="line-modified">1527         AttributeListEntry *attr, *nextAttr;</span>

1528 
<span class="line-modified">1529         char attrBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY];</span>
<span class="line-modified">1530         int32_t attrBufIdx = 0;</span>


1531 
<span class="line-modified">1532         icu::MemoryPool&lt;AttributeListEntry&gt; attrPool;</span>





1533 
<span class="line-modified">1534         /* Iterate through u extension attributes */</span>
<span class="line-modified">1535         while (*pTag) {</span>
<span class="line-modified">1536             /* locate next separator char */</span>
<span class="line-modified">1537             for (len = 0; *(pTag + len) &amp;&amp; *(pTag + len) != SEP; len++);</span>





1538 
<span class="line-modified">1539             if (ultag_isUnicodeLocaleKey(pTag, len)) {</span>
<span class="line-modified">1540                 pKwds = pTag;</span>
<span class="line-modified">1541                 break;</span>
<span class="line-modified">1542             }</span>

1543 
<span class="line-modified">1544             /* add this attribute to the list */</span>
<span class="line-modified">1545             attr = attrPool.create();</span>
<span class="line-modified">1546             if (attr == NULL) {</span>
<span class="line-modified">1547                 *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1548                 return;</span>
<span class="line-modified">1549             }</span>

1550 
<span class="line-modified">1551             if (len &lt; (int32_t)sizeof(attrBuf) - attrBufIdx) {</span>
<span class="line-modified">1552                 uprv_memcpy(&amp;attrBuf[attrBufIdx], pTag, len);</span>
<span class="line-added">1553                 attrBuf[attrBufIdx + len] = 0;</span>
<span class="line-added">1554                 attr-&gt;attribute = &amp;attrBuf[attrBufIdx];</span>
<span class="line-added">1555                 attrBufIdx += (len + 1);</span>
<span class="line-added">1556             } else {</span>
<span class="line-added">1557                 *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1558                 return;</span>
<span class="line-added">1559             }</span>
1560 
<span class="line-modified">1561             if (!_addAttributeToList(&amp;attrFirst, attr)) {</span>
<span class="line-modified">1562                 *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-modified">1563                 return;</span>
<span class="line-modified">1564             }</span>

1565 
<span class="line-modified">1566             /* next tag */</span>
<span class="line-modified">1567             pTag += len;</span>
<span class="line-modified">1568             if (*pTag) {</span>
<span class="line-modified">1569                 /* next to the separator */</span>
<span class="line-added">1570                 pTag++;</span>
<span class="line-added">1571             }</span>
1572         }
1573 
<span class="line-modified">1574         if (attrFirst) {</span>
<span class="line-modified">1575             /* emit attributes as an LDML keyword, e.g. attribute=attr1-attr2 */</span>
1576 
<span class="line-modified">1577             kwd = extPool.create();</span>
<span class="line-modified">1578             if (kwd == NULL) {</span>
<span class="line-modified">1579                 *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1580                 return;</span>





1581             }
1582 
<span class="line-modified">1583             icu::CharString* value = kwdBuf.create();</span>
<span class="line-modified">1584             if (value == NULL) {</span>
<span class="line-modified">1585                 *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1586                 return;</span>
<span class="line-added">1587             }</span>
1588 
<span class="line-modified">1589             /* attribute subtags sorted in alphabetical order as type */</span>
<span class="line-modified">1590             attr = attrFirst;</span>
<span class="line-modified">1591             while (attr != NULL) {</span>
<span class="line-modified">1592                 nextAttr = attr-&gt;next;</span>
<span class="line-added">1593                 if (attr != attrFirst) {</span>
<span class="line-added">1594                     value-&gt;append(&#39;-&#39;, *status);</span>
<span class="line-added">1595                 }</span>
<span class="line-added">1596                 value-&gt;append(attr-&gt;attribute, *status);</span>
<span class="line-added">1597                 attr = nextAttr;</span>
<span class="line-added">1598             }</span>
<span class="line-added">1599             if (U_FAILURE(*status)) {</span>
<span class="line-added">1600                 return;</span>
<span class="line-added">1601             }</span>
1602 
<span class="line-modified">1603             kwd-&gt;key = LOCALE_ATTRIBUTE_KEY;</span>
<span class="line-modified">1604             kwd-&gt;value = value-&gt;data();</span>



1605 
<span class="line-modified">1606             if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {</span>
<span class="line-modified">1607                 *status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-modified">1608                 return;</span>
<span class="line-modified">1609             }</span>


1610         }

1611     }
1612 
1613     if (pKwds) {
1614         const char *pBcpKey = NULL;     /* u extenstion key subtag */
1615         const char *pBcpType = NULL;    /* beginning of u extension type subtag(s) */
1616         int32_t bcpKeyLen = 0;
1617         int32_t bcpTypeLen = 0;
1618         UBool isDone = FALSE;
1619 
1620         pTag = pKwds;
1621         /* BCP47 representation of LDML key/type pairs */
1622         while (!isDone) {
1623             const char *pNextBcpKey = NULL;
1624             int32_t nextBcpKeyLen = 0;
1625             UBool emitKeyword = FALSE;
1626 
1627             if (*pTag) {
1628                 /* locate next separator char */
1629                 for (len = 0; *(pTag + len) &amp;&amp; *(pTag + len) != SEP; len++);
1630 
</pre>
<hr />
<pre>
1654                     /* next to the separator */
1655                     pTag++;
1656                 }
1657             } else {
1658                 /* processing last one */
1659                 emitKeyword = TRUE;
1660                 isDone = TRUE;
1661             }
1662 
1663             if (emitKeyword) {
1664                 const char *pKey = NULL;    /* LDML key */
1665                 const char *pType = NULL;   /* LDML type */
1666 
1667                 char bcpKeyBuf[9];          /* BCP key length is always 2 for now */
1668 
1669                 U_ASSERT(pBcpKey != NULL);
1670 
1671                 if (bcpKeyLen &gt;= (int32_t)sizeof(bcpKeyBuf)) {
1672                     /* the BCP key is invalid */
1673                     *status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">1674                     return;</span>
1675                 }
1676 
1677                 uprv_strncpy(bcpKeyBuf, pBcpKey, bcpKeyLen);
1678                 bcpKeyBuf[bcpKeyLen] = 0;
1679 
1680                 /* u extension key to LDML key */
1681                 pKey = uloc_toLegacyKey(bcpKeyBuf);
1682                 if (pKey == NULL) {
1683                     *status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">1684                     return;</span>
1685                 }
1686                 if (pKey == bcpKeyBuf) {
1687                     /*
1688                     The key returned by toLegacyKey points to the input buffer.
1689                     We normalize the result key to lower case.
1690                     */
1691                     T_CString_toLowerCase(bcpKeyBuf);
<span class="line-modified">1692                     icu::CharString* key = kwdBuf.create(bcpKeyBuf, bcpKeyLen, *status);</span>
<span class="line-modified">1693                     if (key == NULL) {</span>
<span class="line-modified">1694                         *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1695                         return;</span>
<span class="line-modified">1696                     }</span>
<span class="line-modified">1697                     if (U_FAILURE(*status)) {</span>
<span class="line-modified">1698                         return;</span>


1699                     }
<span class="line-added">1700                     pKey = key-&gt;data();</span>
1701                 }
1702 
1703                 if (pBcpType) {
1704                     char bcpTypeBuf[128];       /* practically long enough even considering multiple subtag type */
1705                     if (bcpTypeLen &gt;= (int32_t)sizeof(bcpTypeBuf)) {
1706                         /* the BCP type is too long */
1707                         *status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">1708                         return;</span>
1709                     }
1710 
1711                     uprv_strncpy(bcpTypeBuf, pBcpType, bcpTypeLen);
1712                     bcpTypeBuf[bcpTypeLen] = 0;
1713 
1714                     /* BCP type to locale type */
1715                     pType = uloc_toLegacyType(pKey, bcpTypeBuf);
1716                     if (pType == NULL) {
1717                         *status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">1718                         return;</span>
1719                     }
1720                     if (pType == bcpTypeBuf) {
1721                         /*
1722                         The type returned by toLegacyType points to the input buffer.
1723                         We normalize the result type to lower case.
1724                         */
1725                         /* normalize to lower case */
1726                         T_CString_toLowerCase(bcpTypeBuf);
<span class="line-modified">1727                         icu::CharString* type = kwdBuf.create(bcpTypeBuf, bcpTypeLen, *status);</span>
<span class="line-modified">1728                         if (type == NULL) {</span>
<span class="line-modified">1729                             *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-modified">1730                             return;</span>





1731                         }
<span class="line-added">1732                         if (U_FAILURE(*status)) {</span>
<span class="line-added">1733                             return;</span>
<span class="line-added">1734                         }</span>
<span class="line-added">1735                         pType = type-&gt;data();</span>
1736                     }
1737                 } else {
1738                     /* typeless - default type value is &quot;yes&quot; */
1739                     pType = LOCALE_TYPE_YES;
1740                 }
1741 
1742                 /* Special handling for u-va-posix, since we want to treat this as a variant,
1743                    not as a keyword */
1744                 if (!variantExists &amp;&amp; !uprv_strcmp(pKey, POSIX_KEY) &amp;&amp; !uprv_strcmp(pType, POSIX_VALUE) ) {
1745                     *posixVariant = TRUE;
1746                 } else {
1747                     /* create an ExtensionListEntry for this keyword */
<span class="line-modified">1748                     kwd = extPool.create();</span>
1749                     if (kwd == NULL) {
1750                         *status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified">1751                         return;</span>
1752                     }
1753 
1754                     kwd-&gt;key = pKey;
1755                     kwd-&gt;value = pType;
1756 
1757                     if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {
<span class="line-modified">1758                         // duplicate keyword is allowed, Only the first</span>
<span class="line-modified">1759                         // is honored.</span>

1760                     }
1761                 }
1762 
1763                 pBcpKey = pNextBcpKey;
1764                 bcpKeyLen = pNextBcpKey != NULL ? nextBcpKeyLen : 0;
1765                 pBcpType = NULL;
1766                 bcpTypeLen = 0;
1767             }
1768         }
1769     }
1770 
1771     kwd = kwdFirst;
1772     while (kwd != NULL) {
1773         nextKwd = kwd-&gt;next;
1774         _addExtensionToList(appendTo, kwd, FALSE);
1775         kwd = nextKwd;
1776     }

















1777 }
1778 
1779 
<span class="line-modified">1780 static void</span>
<span class="line-modified">1781 _appendKeywords(ULanguageTag* langtag, icu::ByteSink&amp; sink, UErrorCode* status) {</span>

1782     int32_t i, n;
1783     int32_t len;
1784     ExtensionListEntry *kwdFirst = NULL;
1785     ExtensionListEntry *kwd;
1786     const char *key, *type;
<span class="line-modified">1787     icu::MemoryPool&lt;ExtensionListEntry&gt; extPool;</span>
<span class="line-modified">1788     icu::MemoryPool&lt;icu::CharString&gt; kwdBuf;</span>
1789     UBool posixVariant = FALSE;
1790 
1791     if (U_FAILURE(*status)) {
<span class="line-modified">1792         return;</span>






1793     }
1794 
1795     /* Determine if variants already exists */
1796     if (ultag_getVariantsSize(langtag)) {
1797         posixVariant = TRUE;
1798     }
1799 
1800     n = ultag_getExtensionsSize(langtag);
1801 
1802     /* resolve locale keywords and reordering keys */
1803     for (i = 0; i &lt; n; i++) {
1804         key = ultag_getExtensionKey(langtag, i);
1805         type = ultag_getExtensionValue(langtag, i);
1806         if (*key == LDMLEXT) {
<span class="line-modified">1807             _appendLDMLExtensionAsKeywords(type, &amp;kwdFirst, extPool, kwdBuf, &amp;posixVariant, status);</span>
1808             if (U_FAILURE(*status)) {
1809                 break;
1810             }
1811         } else {
<span class="line-modified">1812             kwd = extPool.create();</span>
1813             if (kwd == NULL) {
1814                 *status = U_MEMORY_ALLOCATION_ERROR;
1815                 break;
1816             }
1817             kwd-&gt;key = key;
1818             kwd-&gt;value = type;
1819             if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {

1820                 *status = U_ILLEGAL_ARGUMENT_ERROR;
1821                 break;
1822             }
1823         }
1824     }
1825 
1826     if (U_SUCCESS(*status)) {
1827         type = ultag_getPrivateUse(langtag);
1828         if ((int32_t)uprv_strlen(type) &gt; 0) {
1829             /* add private use as a keyword */
<span class="line-modified">1830             kwd = extPool.create();</span>
1831             if (kwd == NULL) {
1832                 *status = U_MEMORY_ALLOCATION_ERROR;
1833             } else {
1834                 kwd-&gt;key = PRIVATEUSE_KEY;
1835                 kwd-&gt;value = type;
1836                 if (!_addExtensionToList(&amp;kwdFirst, kwd, FALSE)) {

1837                     *status = U_ILLEGAL_ARGUMENT_ERROR;
1838                 }
1839             }
1840         }
1841     }
1842 
1843     /* If a POSIX variant was in the extensions, write it out before writing the keywords. */
1844 
1845     if (U_SUCCESS(*status) &amp;&amp; posixVariant) {
1846         len = (int32_t) uprv_strlen(_POSIX);
<span class="line-modified">1847         sink.Append(_POSIX, len);</span>



1848     }
1849 
1850     if (U_SUCCESS(*status) &amp;&amp; kwdFirst != NULL) {
1851         /* write out the sorted keywords */
1852         UBool firstValue = TRUE;
1853         kwd = kwdFirst;
1854         do {
<span class="line-modified">1855             if (firstValue) {</span>
<span class="line-modified">1856                 sink.Append(&quot;@&quot;, 1);</span>
<span class="line-modified">1857                 firstValue = FALSE;</span>
<span class="line-modified">1858             } else {</span>
<span class="line-modified">1859                 sink.Append(&quot;;&quot;, 1);</span>




1860             }

1861 
1862             /* key */
1863             len = (int32_t)uprv_strlen(kwd-&gt;key);
<span class="line-modified">1864             sink.Append(kwd-&gt;key, len);</span>
<span class="line-modified">1865             sink.Append(&quot;=&quot;, 1);</span>








1866 
1867             /* type */
1868             len = (int32_t)uprv_strlen(kwd-&gt;value);
<span class="line-modified">1869             sink.Append(kwd-&gt;value, len);</span>



1870 
1871             kwd = kwd-&gt;next;
1872         } while (kwd);
1873     }
















1874 }
1875 
<span class="line-modified">1876 static void</span>
<span class="line-modified">1877 _appendPrivateuseToLanguageTag(const char* localeID, icu::ByteSink&amp; sink, UBool strict, UBool hadPosix, UErrorCode* status) {</span>
1878     (void)hadPosix;
1879     char buf[ULOC_FULLNAME_CAPACITY];
1880     char tmpAppend[ULOC_FULLNAME_CAPACITY];
1881     UErrorCode tmpStatus = U_ZERO_ERROR;
1882     int32_t len, i;
1883     int32_t reslen = 0;
<span class="line-added">1884     int32_t capacity = sizeof tmpAppend;</span>
1885 
1886     if (U_FAILURE(*status)) {
<span class="line-modified">1887         return;</span>
1888     }
1889 
1890     len = uloc_getVariant(localeID, buf, sizeof(buf), &amp;tmpStatus);
1891     if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {
1892         if (strict) {
1893             *status = U_ILLEGAL_ARGUMENT_ERROR;
1894         }
<span class="line-modified">1895         return;</span>
1896     }
1897 
1898     if (len &gt; 0) {
1899         char *p, *pPriv;
1900         UBool bNext = TRUE;
1901         UBool firstValue = TRUE;
1902         UBool writeValue;
1903 
1904         pPriv = NULL;
1905         p = buf;
1906         while (bNext) {
1907             writeValue = FALSE;
1908             if (*p == SEP || *p == LOCALE_SEP || *p == 0) {
1909                 if (*p == 0) {
1910                     bNext = FALSE;
1911                 } else {
1912                     *p = 0; /* terminate */
1913                 }
1914                 if (pPriv != NULL) {
1915                     /* Private use in the canonical format is lowercase in BCP47 */
</pre>
<hr />
<pre>
1959 
1960                             firstValue = FALSE;
1961                         }
1962 
1963                         len = (int32_t)uprv_strlen(pPriv);
1964                         if (reslen &lt; capacity) {
1965                             uprv_memcpy(tmpAppend + reslen, pPriv, uprv_min(len, capacity - reslen));
1966                         }
1967                         reslen += len;
1968                     }
1969                 }
1970                 /* reset private use starting position */
1971                 pPriv = NULL;
1972             } else if (pPriv == NULL) {
1973                 pPriv = p;
1974             }
1975             p++;
1976         }
1977 
1978         if (U_FAILURE(*status)) {
<span class="line-modified">1979             return;</span>
1980         }
1981     }
1982 
1983     if (U_SUCCESS(*status)) {
1984         len = reslen;
<span class="line-modified">1985         sink.Append(tmpAppend, len);</span>


1986     }




1987 }
1988 
1989 /*
1990 * -------------------------------------------------
1991 *
1992 * ultag_ functions
1993 *
1994 * -------------------------------------------------
1995 */
1996 
1997 /* Bit flags used by the parser */
1998 #define LANG 0x0001
1999 #define EXTL 0x0002
2000 #define SCRT 0x0004
2001 #define REGN 0x0008
2002 #define VART 0x0010
2003 #define EXTS 0x0020
2004 #define EXTV 0x0040
2005 #define PRIV 0x0080
2006 
2007 /**
2008  * Ticket #12705 - Visual Studio 2015 Update 3 contains a new code optimizer which has problems optimizing
2009  * this function. (See https://blogs.msdn.microsoft.com/vcblog/2016/05/04/new-code-optimizer/ )
2010  * As a workaround, we will turn off optimization just for this function on VS2015 Update 3 and above.
2011  */
2012 #if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1900) &amp;&amp; defined(_MSC_FULL_VER) &amp;&amp; (_MSC_FULL_VER &gt;= 190024210))
2013 #pragma optimize( &quot;&quot;, off )
2014 #endif
2015 
2016 static ULanguageTag*
2017 ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* status) {

2018     char *tagBuf;
2019     int16_t next;
2020     char *pSubtag, *pNext, *pLastGoodPosition;
2021     int32_t subtagLen;
2022     int32_t extlangIdx;
2023     ExtensionListEntry *pExtension;
2024     char *pExtValueSubtag, *pExtValueSubtagEnd;
2025     int32_t i;
2026     UBool privateuseVar = FALSE;
2027     int32_t grandfatheredLen = 0;
2028 
2029     if (parsedLen != NULL) {
2030         *parsedLen = 0;
2031     }
2032 
2033     if (U_FAILURE(*status)) {
2034         return NULL;
2035     }
2036 
2037     if (tagLen &lt; 0) {
2038         tagLen = (int32_t)uprv_strlen(tag);
2039     }
2040 
2041     /* copy the entire string */
2042     tagBuf = (char*)uprv_malloc(tagLen + 1);
2043     if (tagBuf == NULL) {
2044         *status = U_MEMORY_ALLOCATION_ERROR;
2045         return NULL;
2046     }
2047     uprv_memcpy(tagBuf, tag, tagLen);
2048     *(tagBuf + tagLen) = 0;
2049 
2050     /* create a ULanguageTag */
<span class="line-modified">2051     icu::LocalULanguageTagPointer t(</span>
<span class="line-modified">2052             (ULanguageTag*)uprv_malloc(sizeof(ULanguageTag)));</span>
<span class="line-added">2053     if (t.isNull()) {</span>
2054         uprv_free(tagBuf);
2055         *status = U_MEMORY_ALLOCATION_ERROR;
2056         return NULL;
2057     }
<span class="line-modified">2058     _initializeULanguageTag(t.getAlias());</span>
2059     t-&gt;buf = tagBuf;
2060 
2061     if (tagLen &lt; MINLEN) {
2062         /* the input tag is too short - return empty ULanguageTag */
<span class="line-modified">2063         return t.orphan();</span>
2064     }
2065 
<span class="line-added">2066     size_t parsedLenDelta = 0;</span>
<span class="line-added">2067     // Grandfathered tag will be consider together. Grandfathered tag with intervening</span>
<span class="line-added">2068     // script and region such as art-DE-lojban or art-Latn-lojban won&#39;t be</span>
<span class="line-added">2069     // matched.</span>
2070     /* check if the tag is grandfathered */
<span class="line-modified">2071     for (i = 0; i &lt; UPRV_LENGTHOF(GRANDFATHERED); i += 2) {</span>
<span class="line-modified">2072         int32_t checkGrandfatheredLen = static_cast&lt;int32_t&gt;(uprv_strlen(GRANDFATHERED[i]));</span>
<span class="line-added">2073         if (tagLen &lt; checkGrandfatheredLen) {</span>
<span class="line-added">2074             continue;</span>
<span class="line-added">2075         }</span>
<span class="line-added">2076         if (tagLen &gt; checkGrandfatheredLen &amp;&amp; tagBuf[checkGrandfatheredLen] != &#39;-&#39;) {</span>
<span class="line-added">2077             // make sure next char is &#39;-&#39;.</span>
<span class="line-added">2078             continue;</span>
<span class="line-added">2079         }</span>
<span class="line-added">2080         if (uprv_strnicmp(GRANDFATHERED[i], tagBuf, checkGrandfatheredLen) == 0) {</span>
2081             int32_t newTagLength;
2082 
<span class="line-modified">2083             grandfatheredLen = checkGrandfatheredLen;  /* back up for output parsedLen */</span>
<span class="line-modified">2084             int32_t replacementLen = static_cast&lt;int32_t&gt;(uprv_strlen(GRANDFATHERED[i+1]));</span>
<span class="line-added">2085             newTagLength = replacementLen + tagLen - checkGrandfatheredLen;</span>
2086             if (tagLen &lt; newTagLength) {
2087                 uprv_free(tagBuf);
2088                 tagBuf = (char*)uprv_malloc(newTagLength + 1);
2089                 if (tagBuf == NULL) {
2090                     *status = U_MEMORY_ALLOCATION_ERROR;

2091                     return NULL;
2092                 }
2093                 t-&gt;buf = tagBuf;
2094                 tagLen = newTagLength;
2095             }
<span class="line-added">2096             parsedLenDelta = checkGrandfatheredLen - replacementLen;</span>
2097             uprv_strcpy(t-&gt;buf, GRANDFATHERED[i + 1]);
<span class="line-added">2098             if (checkGrandfatheredLen != tagLen) {</span>
<span class="line-added">2099                 uprv_strcpy(t-&gt;buf + replacementLen, tag + checkGrandfatheredLen);</span>
<span class="line-added">2100             }</span>
2101             break;
2102         }
2103     }
2104 
<span class="line-added">2105     if (grandfatheredLen == 0) {</span>
<span class="line-added">2106         for (i = 0; i &lt; UPRV_LENGTHOF(REDUNDANT); i += 2) {</span>
<span class="line-added">2107             const char* redundantTag = REDUNDANT[i];</span>
<span class="line-added">2108             size_t redundantTagLen = uprv_strlen(redundantTag);</span>
<span class="line-added">2109             // The preferred tag for a redundant tag is always shorter than redundant</span>
<span class="line-added">2110             // tag. A redundant tag may or may not be followed by other subtags.</span>
<span class="line-added">2111             // (i.e. &quot;zh-yue&quot; or &quot;zh-yue-u-co-pinyin&quot;).</span>
<span class="line-added">2112             if (uprv_strnicmp(redundantTag, tagBuf, static_cast&lt;uint32_t&gt;(redundantTagLen)) == 0) {</span>
<span class="line-added">2113                 const char* redundantTagEnd = tagBuf + redundantTagLen;</span>
<span class="line-added">2114                 if (*redundantTagEnd  == &#39;\0&#39; || *redundantTagEnd == SEP) {</span>
<span class="line-added">2115                     const char* preferredTag = REDUNDANT[i + 1];</span>
<span class="line-added">2116                     size_t preferredTagLen = uprv_strlen(preferredTag);</span>
<span class="line-added">2117                     uprv_strncpy(t-&gt;buf, preferredTag, preferredTagLen);</span>
<span class="line-added">2118                     if (*redundantTagEnd == SEP) {</span>
<span class="line-added">2119                         uprv_memmove(tagBuf + preferredTagLen,</span>
<span class="line-added">2120                                      redundantTagEnd,</span>
<span class="line-added">2121                                      tagLen - redundantTagLen + 1);</span>
<span class="line-added">2122                     } else {</span>
<span class="line-added">2123                         tagBuf[preferredTagLen] = &#39;\0&#39;;</span>
<span class="line-added">2124                     }</span>
<span class="line-added">2125                     // parsedLen should be the length of the input</span>
<span class="line-added">2126                     // before redundantTag is replaced by preferredTag.</span>
<span class="line-added">2127                     // Save the delta to add it back later.</span>
<span class="line-added">2128                     parsedLenDelta = redundantTagLen - preferredTagLen;</span>
<span class="line-added">2129                     break;</span>
<span class="line-added">2130                 }</span>
<span class="line-added">2131             }</span>
<span class="line-added">2132         }</span>
<span class="line-added">2133     }</span>
<span class="line-added">2134 </span>
2135     /*
2136      * langtag      =   language
2137      *                  [&quot;-&quot; script]
2138      *                  [&quot;-&quot; region]
2139      *                  *(&quot;-&quot; variant)
2140      *                  *(&quot;-&quot; extension)
2141      *                  [&quot;-&quot; privateuse]
2142      */
2143 
2144     next = LANG | PRIV;
2145     pNext = pLastGoodPosition = tagBuf;
2146     extlangIdx = 0;
2147     pExtension = NULL;
2148     pExtValueSubtag = NULL;
2149     pExtValueSubtagEnd = NULL;
2150 
2151     while (pNext) {
2152         char *pSep;
2153 
2154         pSubtag = pNext;
2155 
2156         /* locate next separator char */
2157         pSep = pSubtag;
2158         while (*pSep) {
2159             if (*pSep == SEP) {
2160                 break;
2161             }
2162             pSep++;
2163         }
2164         if (*pSep == 0) {
2165             /* last subtag */
2166             pNext = NULL;
2167         } else {
2168             pNext = pSep + 1;
2169         }
2170         subtagLen = (int32_t)(pSep - pSubtag);
2171 
2172         if (next &amp; LANG) {
<span class="line-modified">2173             if (ultag_isLanguageSubtag(pSubtag, subtagLen)) {</span>
2174                 *pSep = 0;  /* terminate */
<span class="line-added">2175                 // TODO: move deprecated language code handling here.</span>
2176                 t-&gt;language = T_CString_toLowerCase(pSubtag);
2177 
2178                 pLastGoodPosition = pSep;
<span class="line-modified">2179                 next = SCRT | REGN | VART | EXTS | PRIV;</span>
<span class="line-added">2180                 if (subtagLen &lt;= 3)</span>
<span class="line-added">2181                   next |= EXTL;</span>
2182                 continue;
2183             }
2184         }
2185         if (next &amp; EXTL) {
2186             if (_isExtlangSubtag(pSubtag, subtagLen)) {
2187                 *pSep = 0;
2188                 t-&gt;extlang[extlangIdx++] = T_CString_toLowerCase(pSubtag);
2189 
2190                 pLastGoodPosition = pSep;
2191                 if (extlangIdx &lt; 3) {
2192                     next = EXTL | SCRT | REGN | VART | EXTS | PRIV;
2193                 } else {
2194                     next = SCRT | REGN | VART | EXTS | PRIV;
2195                 }
2196                 continue;
2197             }
2198         }
2199         if (next &amp; SCRT) {
<span class="line-modified">2200             if (ultag_isScriptSubtag(pSubtag, subtagLen)) {</span>
2201                 char *p = pSubtag;
2202 
2203                 *pSep = 0;
2204 
2205                 /* to title case */
2206                 *p = uprv_toupper(*p);
2207                 p++;
2208                 for (; *p; p++) {
2209                     *p = uprv_tolower(*p);
2210                 }
2211 
2212                 t-&gt;script = pSubtag;
2213 
2214                 pLastGoodPosition = pSep;
2215                 next = REGN | VART | EXTS | PRIV;
2216                 continue;
2217             }
2218         }
2219         if (next &amp; REGN) {
<span class="line-modified">2220             if (ultag_isRegionSubtag(pSubtag, subtagLen)) {</span>
2221                 *pSep = 0;
<span class="line-added">2222                 // TODO: move deprecated region code handling here.</span>
2223                 t-&gt;region = T_CString_toUpperCase(pSubtag);
2224 
2225                 pLastGoodPosition = pSep;
2226                 next = VART | EXTS | PRIV;
2227                 continue;
2228             }
2229         }
2230         if (next &amp; VART) {
2231             if (_isVariantSubtag(pSubtag, subtagLen) ||
2232                (privateuseVar &amp;&amp; _isPrivateuseVariantSubtag(pSubtag, subtagLen))) {
2233                 VariantListEntry *var;
2234                 UBool isAdded;
2235 
2236                 var = (VariantListEntry*)uprv_malloc(sizeof(VariantListEntry));
2237                 if (var == NULL) {
2238                     *status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified">2239                     return NULL;</span>
2240                 }
2241                 *pSep = 0;
2242                 var-&gt;variant = T_CString_toUpperCase(pSubtag);
2243                 isAdded = _addVariantToList(&amp;(t-&gt;variants), var);
2244                 if (!isAdded) {
2245                     /* duplicated variant entry */
2246                     uprv_free(var);
2247                     break;
2248                 }
2249                 pLastGoodPosition = pSep;
2250                 next = VART | EXTS | PRIV;
2251                 continue;
2252             }
2253         }
2254         if (next &amp; EXTS) {
2255             if (_isExtensionSingleton(pSubtag, subtagLen)) {
2256                 if (pExtension != NULL) {
2257                     if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
2258                         /* the previous extension is incomplete */
2259                         uprv_free(pExtension);
</pre>
<hr />
<pre>
2263 
2264                     /* terminate the previous extension value */
2265                     *pExtValueSubtagEnd = 0;
2266                     pExtension-&gt;value = T_CString_toLowerCase(pExtValueSubtag);
2267 
2268                     /* insert the extension to the list */
2269                     if (_addExtensionToList(&amp;(t-&gt;extensions), pExtension, FALSE)) {
2270                         pLastGoodPosition = pExtValueSubtagEnd;
2271                     } else {
2272                         /* stop parsing here */
2273                         uprv_free(pExtension);
2274                         pExtension = NULL;
2275                         break;
2276                     }
2277                 }
2278 
2279                 /* create a new extension */
2280                 pExtension = (ExtensionListEntry*)uprv_malloc(sizeof(ExtensionListEntry));
2281                 if (pExtension == NULL) {
2282                     *status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified">2283                     return NULL;</span>
2284                 }
2285                 *pSep = 0;
2286                 pExtension-&gt;key = T_CString_toLowerCase(pSubtag);
2287                 pExtension-&gt;value = NULL;   /* will be set later */
2288 
2289                 /*
2290                  * reset the start and the end location of extension value
2291                  * subtags for this extension
2292                  */
2293                 pExtValueSubtag = NULL;
2294                 pExtValueSubtagEnd = NULL;
2295 
2296                 next = EXTV;
2297                 continue;
2298             }
2299         }
2300         if (next &amp; EXTV) {
2301             if (_isExtensionSubtag(pSubtag, subtagLen)) {
2302                 if (pExtValueSubtag == NULL) {
2303                     /* if the start postion of this extension&#39;s value is not yet,
2304                         this one is the first value subtag */
2305                     pExtValueSubtag = pSubtag;
2306                 }
2307 
2308                 /* Mark the end of this subtag */
2309                 pExtValueSubtagEnd = pSep;
2310                 next = EXTS | EXTV | PRIV;
2311 
2312                 continue;
2313             }
2314         }
2315         if (next &amp; PRIV) {
<span class="line-modified">2316             if (uprv_tolower(*pSubtag) == PRIVATEUSE &amp;&amp; subtagLen == 1) {</span>
2317                 char *pPrivuseVal;
2318 
2319                 if (pExtension != NULL) {
2320                     /* Process the last extension */
2321                     if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
2322                         /* the previous extension is incomplete */
2323                         uprv_free(pExtension);
2324                         pExtension = NULL;
2325                         break;
2326                     } else {
2327                         /* terminate the previous extension value */
2328                         *pExtValueSubtagEnd = 0;
2329                         pExtension-&gt;value = T_CString_toLowerCase(pExtValueSubtag);
2330 
2331                         /* insert the extension to the list */
2332                         if (_addExtensionToList(&amp;(t-&gt;extensions), pExtension, FALSE)) {
2333                             pLastGoodPosition = pExtValueSubtagEnd;
2334                             pExtension = NULL;
2335                         } else {
2336                         /* stop parsing here */
</pre>
<hr />
<pre>
2399 
2400     if (pExtension != NULL) {
2401         /* Process the last extension */
2402         if (pExtValueSubtag == NULL || pExtValueSubtagEnd == NULL) {
2403             /* the previous extension is incomplete */
2404             uprv_free(pExtension);
2405         } else {
2406             /* terminate the previous extension value */
2407             *pExtValueSubtagEnd = 0;
2408             pExtension-&gt;value = T_CString_toLowerCase(pExtValueSubtag);
2409             /* insert the extension to the list */
2410             if (_addExtensionToList(&amp;(t-&gt;extensions), pExtension, FALSE)) {
2411                 pLastGoodPosition = pExtValueSubtagEnd;
2412             } else {
2413                 uprv_free(pExtension);
2414             }
2415         }
2416     }
2417 
2418     if (parsedLen != NULL) {
<span class="line-modified">2419         *parsedLen = (int32_t)(pLastGoodPosition - t-&gt;buf + parsedLenDelta);</span>
2420     }
2421 
<span class="line-modified">2422     return t.orphan();</span>




2423 }
2424 
2425 /**
2426 * Ticket #12705 - Turn optimization back on.
2427 */
2428 #if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1900) &amp;&amp; defined(_MSC_FULL_VER) &amp;&amp; (_MSC_FULL_VER &gt;= 190024210))
2429 #pragma optimize( &quot;&quot;, on )
2430 #endif
2431 
2432 static void
2433 ultag_close(ULanguageTag* langtag) {
2434 
2435     if (langtag == NULL) {
2436         return;
2437     }
2438 
2439     uprv_free(langtag-&gt;buf);
2440 
2441     if (langtag-&gt;variants) {
2442         VariantListEntry *curVar = langtag-&gt;variants;
</pre>
<hr />
<pre>
2592 static const char*
2593 ultag_getGrandfathered(const ULanguageTag* langtag) {
2594     return langtag-&gt;grandfathered;
2595 }
2596 #endif
2597 
2598 
2599 /*
2600 * -------------------------------------------------
2601 *
2602 * Locale/BCP47 conversion APIs, exposed as uloc_*
2603 *
2604 * -------------------------------------------------
2605 */
2606 U_CAPI int32_t U_EXPORT2
2607 uloc_toLanguageTag(const char* localeID,
2608                    char* langtag,
2609                    int32_t langtagCapacity,
2610                    UBool strict,
2611                    UErrorCode* status) {
<span class="line-modified">2612     if (U_FAILURE(*status)) {</span>
<span class="line-modified">2613         return 0;</span>
<span class="line-modified">2614     }</span>
<span class="line-added">2615 </span>
<span class="line-added">2616     icu::CheckedArrayByteSink sink(langtag, langtagCapacity);</span>
<span class="line-added">2617     ulocimp_toLanguageTag(localeID, sink, strict, status);</span>
<span class="line-added">2618 </span>
<span class="line-added">2619     int32_t reslen = sink.NumberOfBytesAppended();</span>
<span class="line-added">2620 </span>
<span class="line-added">2621     if (U_FAILURE(*status)) {</span>
<span class="line-added">2622         return reslen;</span>
<span class="line-added">2623     }</span>
<span class="line-added">2624 </span>
<span class="line-added">2625     if (sink.Overflowed()) {</span>
<span class="line-added">2626         *status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-added">2627     } else {</span>
<span class="line-added">2628         u_terminateChars(langtag, langtagCapacity, reslen, status);</span>
<span class="line-added">2629     }</span>
<span class="line-added">2630 </span>
<span class="line-added">2631     return reslen;</span>
<span class="line-added">2632 }</span>
<span class="line-added">2633 </span>
<span class="line-added">2634 </span>
<span class="line-added">2635 U_CAPI void U_EXPORT2</span>
<span class="line-added">2636 ulocimp_toLanguageTag(const char* localeID,</span>
<span class="line-added">2637                       icu::ByteSink&amp; sink,</span>
<span class="line-added">2638                       UBool strict,</span>
<span class="line-added">2639                       UErrorCode* status) {</span>
<span class="line-added">2640     icu::CharString canonical;</span>
<span class="line-added">2641     int32_t reslen;</span>
2642     UErrorCode tmpStatus = U_ZERO_ERROR;
2643     UBool hadPosix = FALSE;
2644     const char* pKeywordStart;
2645 
2646     /* Note: uloc_canonicalize returns &quot;en_US_POSIX&quot; for input locale ID &quot;&quot;.  See #6835 */
<span class="line-modified">2647     int32_t resultCapacity = static_cast&lt;int32_t&gt;(uprv_strlen(localeID));</span>
<span class="line-modified">2648     if (resultCapacity &gt; 0) {</span>
<span class="line-modified">2649         char* buffer;</span>
<span class="line-modified">2650 </span>
<span class="line-added">2651         for (;;) {</span>
<span class="line-added">2652             buffer = canonical.getAppendBuffer(</span>
<span class="line-added">2653                     /*minCapacity=*/resultCapacity,</span>
<span class="line-added">2654                     /*desiredCapacityHint=*/resultCapacity,</span>
<span class="line-added">2655                     resultCapacity,</span>
<span class="line-added">2656                     tmpStatus);</span>
<span class="line-added">2657 </span>
<span class="line-added">2658             if (U_FAILURE(tmpStatus)) {</span>
<span class="line-added">2659                 *status = tmpStatus;</span>
<span class="line-added">2660                 return;</span>
<span class="line-added">2661             }</span>
<span class="line-added">2662 </span>
<span class="line-added">2663             reslen =</span>
<span class="line-added">2664                 uloc_canonicalize(localeID, buffer, resultCapacity, &amp;tmpStatus);</span>
<span class="line-added">2665 </span>
<span class="line-added">2666             if (tmpStatus != U_BUFFER_OVERFLOW_ERROR) {</span>
<span class="line-added">2667                 break;</span>
<span class="line-added">2668             }</span>
<span class="line-added">2669 </span>
<span class="line-added">2670             resultCapacity = reslen;</span>
<span class="line-added">2671             tmpStatus = U_ZERO_ERROR;</span>
<span class="line-added">2672         }</span>
<span class="line-added">2673 </span>
<span class="line-added">2674         if (U_FAILURE(tmpStatus)) {</span>
2675             *status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">2676             return;</span>
<span class="line-added">2677         }</span>
<span class="line-added">2678 </span>
<span class="line-added">2679         canonical.append(buffer, reslen, tmpStatus);</span>
<span class="line-added">2680         if (tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {</span>
<span class="line-added">2681             tmpStatus = U_ZERO_ERROR;  // Terminators provided by CharString.</span>
<span class="line-added">2682         }</span>
<span class="line-added">2683 </span>
<span class="line-added">2684         if (U_FAILURE(tmpStatus)) {</span>
<span class="line-added">2685             *status = tmpStatus;</span>
<span class="line-added">2686             return;</span>
2687         }
2688     }
2689 
2690     /* For handling special case - private use only tag */
<span class="line-modified">2691     pKeywordStart = locale_getKeywordsStart(canonical.data());</span>
<span class="line-modified">2692     if (pKeywordStart == canonical.data()) {</span>

2693         int kwdCnt = 0;
2694         UBool done = FALSE;
2695 
<span class="line-modified">2696         icu::LocalUEnumerationPointer kwdEnum(uloc_openKeywords(canonical.data(), &amp;tmpStatus));</span>
<span class="line-modified">2697         if (U_SUCCESS(tmpStatus)) {</span>
<span class="line-modified">2698             kwdCnt = uenum_count(kwdEnum.getAlias(), &amp;tmpStatus);</span>
2699             if (kwdCnt == 1) {
2700                 const char *key;
2701                 int32_t len = 0;
2702 
<span class="line-modified">2703                 key = uenum_next(kwdEnum.getAlias(), &amp;len, &amp;tmpStatus);</span>
2704                 if (len == 1 &amp;&amp; *key == PRIVATEUSE) {
2705                     char buf[ULOC_KEYWORD_AND_VALUES_CAPACITY];
2706                     buf[0] = PRIVATEUSE;
2707                     buf[1] = SEP;
2708                     len = uloc_getKeywordValue(localeID, key, &amp;buf[2], sizeof(buf) - 2, &amp;tmpStatus);
2709                     if (U_SUCCESS(tmpStatus)) {
<span class="line-modified">2710                         if (ultag_isPrivateuseValueSubtags(&amp;buf[2], len)) {</span>
2711                             /* return private use only tag */
<span class="line-modified">2712                             sink.Append(buf, len + 2);</span>


2713                             done = TRUE;
2714                         } else if (strict) {
2715                             *status = U_ILLEGAL_ARGUMENT_ERROR;
2716                             done = TRUE;
2717                         }
2718                         /* if not strict mode, then &quot;und&quot; will be returned */
2719                     } else {
2720                         *status = U_ILLEGAL_ARGUMENT_ERROR;
2721                         done = TRUE;
2722                     }
2723                 }
2724             }

2725             if (done) {
<span class="line-modified">2726                 return;</span>
2727             }
2728         }
2729     }
2730 
<span class="line-modified">2731     _appendLanguageToLanguageTag(canonical.data(), sink, strict, status);</span>
<span class="line-modified">2732     _appendScriptToLanguageTag(canonical.data(), sink, strict, status);</span>
<span class="line-modified">2733     _appendRegionToLanguageTag(canonical.data(), sink, strict, status);</span>
<span class="line-modified">2734     _appendVariantsToLanguageTag(canonical.data(), sink, strict, &amp;hadPosix, status);</span>
<span class="line-modified">2735     _appendKeywordsToLanguageTag(canonical.data(), sink, strict, hadPosix, status);</span>
<span class="line-modified">2736     _appendPrivateuseToLanguageTag(canonical.data(), sink, strict, hadPosix, status);</span>


2737 }
2738 
2739 
2740 U_CAPI int32_t U_EXPORT2
2741 uloc_forLanguageTag(const char* langtag,
2742                     char* localeID,
2743                     int32_t localeIDCapacity,
2744                     int32_t* parsedLength,
2745                     UErrorCode* status) {
<span class="line-modified">2746     if (U_FAILURE(*status)) {</span>
<span class="line-modified">2747         return 0;</span>
<span class="line-added">2748     }</span>
<span class="line-added">2749 </span>
<span class="line-added">2750     icu::CheckedArrayByteSink sink(localeID, localeIDCapacity);</span>
<span class="line-added">2751     ulocimp_forLanguageTag(langtag, -1, sink, parsedLength, status);</span>
<span class="line-added">2752 </span>
<span class="line-added">2753     int32_t reslen = sink.NumberOfBytesAppended();</span>
<span class="line-added">2754 </span>
<span class="line-added">2755     if (U_FAILURE(*status)) {</span>
<span class="line-added">2756         return reslen;</span>
<span class="line-added">2757     }</span>
<span class="line-added">2758 </span>
<span class="line-added">2759     if (sink.Overflowed()) {</span>
<span class="line-added">2760         *status = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="line-added">2761     } else {</span>
<span class="line-added">2762         u_terminateChars(localeID, localeIDCapacity, reslen, status);</span>
<span class="line-added">2763     }</span>
<span class="line-added">2764 </span>
<span class="line-added">2765     return reslen;</span>
<span class="line-added">2766 }</span>
<span class="line-added">2767 </span>
<span class="line-added">2768 </span>
<span class="line-added">2769 U_CAPI void U_EXPORT2</span>
<span class="line-added">2770 ulocimp_forLanguageTag(const char* langtag,</span>
<span class="line-added">2771                        int32_t tagLen,</span>
<span class="line-added">2772                        icu::ByteSink&amp; sink,</span>
<span class="line-added">2773                        int32_t* parsedLength,</span>
<span class="line-added">2774                        UErrorCode* status) {</span>
<span class="line-added">2775     UBool isEmpty = TRUE;</span>
2776     const char *subtag, *p;
2777     int32_t len;
2778     int32_t i, n;
2779     UBool noRegion = TRUE;
2780 
<span class="line-modified">2781     icu::LocalULanguageTagPointer lt(ultag_parse(langtag, tagLen, parsedLength, status));</span>
2782     if (U_FAILURE(*status)) {
<span class="line-modified">2783         return;</span>
2784     }
2785 
2786     /* language */
<span class="line-modified">2787     subtag = ultag_getExtlangSize(lt.getAlias()) &gt; 0 ? ultag_getExtlang(lt.getAlias(), 0) : ultag_getLanguage(lt.getAlias());</span>
2788     if (uprv_compareInvCharsAsAscii(subtag, LANG_UND) != 0) {
2789         len = (int32_t)uprv_strlen(subtag);
2790         if (len &gt; 0) {
<span class="line-modified">2791             sink.Append(subtag, len);</span>
<span class="line-modified">2792             isEmpty = FALSE;</span>


2793         }
2794     }
2795 
2796     /* script */
<span class="line-modified">2797     subtag = ultag_getScript(lt.getAlias());</span>
2798     len = (int32_t)uprv_strlen(subtag);
2799     if (len &gt; 0) {
<span class="line-modified">2800         sink.Append(&quot;_&quot;, 1);</span>
<span class="line-modified">2801         isEmpty = FALSE;</span>


2802 
2803         /* write out the script in title case */
<span class="line-modified">2804         char c = uprv_toupper(*subtag);</span>
<span class="line-modified">2805         sink.Append(&amp;c, 1);</span>
<span class="line-modified">2806         sink.Append(subtag + 1, len - 1);</span>









2807     }
2808 
2809     /* region */
<span class="line-modified">2810     subtag = ultag_getRegion(lt.getAlias());</span>
2811     len = (int32_t)uprv_strlen(subtag);
2812     if (len &gt; 0) {
<span class="line-modified">2813         sink.Append(&quot;_&quot;, 1);</span>
<span class="line-modified">2814         isEmpty = FALSE;</span>
<span class="line-modified">2815 </span>
<span class="line-modified">2816         /* write out the region in upper case */</span>

2817         p = subtag;
2818         while (*p) {
<span class="line-modified">2819             char c = uprv_toupper(*p);</span>
<span class="line-modified">2820             sink.Append(&amp;c, 1);</span>


2821             p++;
2822         }
2823         noRegion = FALSE;
2824     }
2825 
2826     /* variants */
<span class="line-modified">2827     n = ultag_getVariantsSize(lt.getAlias());</span>
2828     if (n &gt; 0) {
2829         if (noRegion) {
<span class="line-modified">2830             sink.Append(&quot;_&quot;, 1);</span>
<span class="line-modified">2831             isEmpty = FALSE;</span>


2832         }
2833 
2834         for (i = 0; i &lt; n; i++) {
<span class="line-modified">2835             subtag = ultag_getVariant(lt.getAlias(), i);</span>
<span class="line-modified">2836             sink.Append(&quot;_&quot;, 1);</span>
<span class="line-modified">2837 </span>


2838             /* write out the variant in upper case */
2839             p = subtag;
2840             while (*p) {
<span class="line-modified">2841                 char c = uprv_toupper(*p);</span>
<span class="line-modified">2842                 sink.Append(&amp;c, 1);</span>


2843                 p++;
2844             }
2845         }
2846     }
2847 
2848     /* keywords */
<span class="line-modified">2849     n = ultag_getExtensionsSize(lt.getAlias());</span>
<span class="line-modified">2850     subtag = ultag_getPrivateUse(lt.getAlias());</span>
2851     if (n &gt; 0 || uprv_strlen(subtag) &gt; 0) {
<span class="line-modified">2852         if (isEmpty &amp;&amp; n &gt; 0) {</span>
2853             /* need a language */
<span class="line-modified">2854             sink.Append(LANG_UND, LANG_UND_LEN);</span>



2855         }
<span class="line-modified">2856         _appendKeywords(lt.getAlias(), sink, status);</span>

2857     }



2858 }


</pre>
</td>
</tr>
</table>
<center><a href="uloc_keytype.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ulocimp.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>