<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/char16ptr.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="casemap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="docmain.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/unicode/char16ptr.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11 #include &quot;unicode/utypes.h&quot;
 12 
 13 /**
 14  * \file
 15  * \brief C++ API: char16_t pointer wrappers with
 16  *        implicit conversion from bit-compatible raw pointer types.
 17  *        Also conversion functions from char16_t * to UChar * and OldUChar *.
 18  */
 19 
 20 U_NAMESPACE_BEGIN
 21 
 22 /**
 23  * \def U_ALIASING_BARRIER
 24  * Barrier for pointer anti-aliasing optimizations even across function boundaries.
 25  * @internal
 26  */
 27 #ifdef U_ALIASING_BARRIER
 28     // Use the predefined value.
 29 #elif (defined(__clang__) || defined(__GNUC__)) &amp;&amp; U_PLATFORM != U_PF_BROWSER_NATIVE_CLIENT
 30 #   define U_ALIASING_BARRIER(ptr) asm volatile(&quot;&quot; : : &quot;rm&quot;(ptr) : &quot;memory&quot;)


 31 #endif
 32 
 33 /**
 34  * char16_t * wrapper with implicit conversion from distinct but bit-compatible pointer types.
 35  * @stable ICU 59
 36  */
 37 class U_COMMON_API Char16Ptr U_FINAL {
 38 public:
 39     /**
 40      * Copies the pointer.
 41      * @param p pointer
 42      * @stable ICU 59
 43      */
 44     inline Char16Ptr(char16_t *p);
 45 #if !U_CHAR16_IS_TYPEDEF
 46     /**
 47      * Converts the pointer to char16_t *.
 48      * @param p pointer to be converted
 49      * @stable ICU 59
 50      */
</pre>
<hr />
<pre>
 86 
 87 private:
 88     Char16Ptr() = delete;
 89 
 90 #ifdef U_ALIASING_BARRIER
 91     template&lt;typename T&gt; static char16_t *cast(T *t) {
 92         U_ALIASING_BARRIER(t);
 93         return reinterpret_cast&lt;char16_t *&gt;(t);
 94     }
 95 
 96     char16_t *p_;
 97 #else
 98     union {
 99         char16_t *cp;
100         uint16_t *up;
101         wchar_t *wp;
102     } u_;
103 #endif
104 };
105 

106 #ifdef U_ALIASING_BARRIER
107 
108 Char16Ptr::Char16Ptr(char16_t *p) : p_(p) {}
109 #if !U_CHAR16_IS_TYPEDEF
110 Char16Ptr::Char16Ptr(uint16_t *p) : p_(cast(p)) {}
111 #endif
112 #if U_SIZEOF_WCHAR_T==2
113 Char16Ptr::Char16Ptr(wchar_t *p) : p_(cast(p)) {}
114 #endif
115 Char16Ptr::Char16Ptr(std::nullptr_t p) : p_(p) {}
116 Char16Ptr::~Char16Ptr() {
117     U_ALIASING_BARRIER(p_);
118 }
119 
120 char16_t *Char16Ptr::get() const { return p_; }
121 
122 #else
123 
124 Char16Ptr::Char16Ptr(char16_t *p) { u_.cp = p; }
125 #if !U_CHAR16_IS_TYPEDEF

137 
138 /**
139  * const char16_t * wrapper with implicit conversion from distinct but bit-compatible pointer types.
140  * @stable ICU 59
141  */
142 class U_COMMON_API ConstChar16Ptr U_FINAL {
143 public:
144     /**
145      * Copies the pointer.
146      * @param p pointer
147      * @stable ICU 59
148      */
149     inline ConstChar16Ptr(const char16_t *p);
150 #if !U_CHAR16_IS_TYPEDEF
151     /**
152      * Converts the pointer to char16_t *.
153      * @param p pointer to be converted
154      * @stable ICU 59
155      */
156     inline ConstChar16Ptr(const uint16_t *p);
</pre>
<hr />
<pre>
192 
193 private:
194     ConstChar16Ptr() = delete;
195 
196 #ifdef U_ALIASING_BARRIER
197     template&lt;typename T&gt; static const char16_t *cast(const T *t) {
198         U_ALIASING_BARRIER(t);
199         return reinterpret_cast&lt;const char16_t *&gt;(t);
200     }
201 
202     const char16_t *p_;
203 #else
204     union {
205         const char16_t *cp;
206         const uint16_t *up;
207         const wchar_t *wp;
208     } u_;
209 #endif
210 };
211 

212 #ifdef U_ALIASING_BARRIER
213 
214 ConstChar16Ptr::ConstChar16Ptr(const char16_t *p) : p_(p) {}
215 #if !U_CHAR16_IS_TYPEDEF
216 ConstChar16Ptr::ConstChar16Ptr(const uint16_t *p) : p_(cast(p)) {}
217 #endif
218 #if U_SIZEOF_WCHAR_T==2
219 ConstChar16Ptr::ConstChar16Ptr(const wchar_t *p) : p_(cast(p)) {}
220 #endif
221 ConstChar16Ptr::ConstChar16Ptr(const std::nullptr_t p) : p_(p) {}
222 ConstChar16Ptr::~ConstChar16Ptr() {
223     U_ALIASING_BARRIER(p_);
224 }
225 
226 const char16_t *ConstChar16Ptr::get() const { return p_; }
227 
228 #else
229 
230 ConstChar16Ptr::ConstChar16Ptr(const char16_t *p) { u_.cp = p; }
231 #if !U_CHAR16_IS_TYPEDEF

243 
244 /**
245  * Converts from const char16_t * to const UChar *.
246  * Includes an aliasing barrier if available.
247  * @param p pointer
248  * @return p as const UChar *
249  * @stable ICU 59
250  */
251 inline const UChar *toUCharPtr(const char16_t *p) {
252 #ifdef U_ALIASING_BARRIER
253     U_ALIASING_BARRIER(p);
254 #endif
255     return reinterpret_cast&lt;const UChar *&gt;(p);
256 }
257 
258 /**
259  * Converts from char16_t * to UChar *.
260  * Includes an aliasing barrier if available.
261  * @param p pointer
262  * @return p as UChar *
</pre>
</td>
<td>
<hr />
<pre>
 11 #include &quot;unicode/utypes.h&quot;
 12 
 13 /**
 14  * \file
 15  * \brief C++ API: char16_t pointer wrappers with
 16  *        implicit conversion from bit-compatible raw pointer types.
 17  *        Also conversion functions from char16_t * to UChar * and OldUChar *.
 18  */
 19 
 20 U_NAMESPACE_BEGIN
 21 
 22 /**
 23  * \def U_ALIASING_BARRIER
 24  * Barrier for pointer anti-aliasing optimizations even across function boundaries.
 25  * @internal
 26  */
 27 #ifdef U_ALIASING_BARRIER
 28     // Use the predefined value.
 29 #elif (defined(__clang__) || defined(__GNUC__)) &amp;&amp; U_PLATFORM != U_PF_BROWSER_NATIVE_CLIENT
 30 #   define U_ALIASING_BARRIER(ptr) asm volatile(&quot;&quot; : : &quot;rm&quot;(ptr) : &quot;memory&quot;)
<span class="line-added"> 31 #elif defined(U_IN_DOXYGEN)</span>
<span class="line-added"> 32 #   define U_ALIASING_BARRIER(ptr)</span>
 33 #endif
 34 
 35 /**
 36  * char16_t * wrapper with implicit conversion from distinct but bit-compatible pointer types.
 37  * @stable ICU 59
 38  */
 39 class U_COMMON_API Char16Ptr U_FINAL {
 40 public:
 41     /**
 42      * Copies the pointer.
 43      * @param p pointer
 44      * @stable ICU 59
 45      */
 46     inline Char16Ptr(char16_t *p);
 47 #if !U_CHAR16_IS_TYPEDEF
 48     /**
 49      * Converts the pointer to char16_t *.
 50      * @param p pointer to be converted
 51      * @stable ICU 59
 52      */
</pre>
<hr />
<pre>
 88 
 89 private:
 90     Char16Ptr() = delete;
 91 
 92 #ifdef U_ALIASING_BARRIER
 93     template&lt;typename T&gt; static char16_t *cast(T *t) {
 94         U_ALIASING_BARRIER(t);
 95         return reinterpret_cast&lt;char16_t *&gt;(t);
 96     }
 97 
 98     char16_t *p_;
 99 #else
100     union {
101         char16_t *cp;
102         uint16_t *up;
103         wchar_t *wp;
104     } u_;
105 #endif
106 };
107 
<span class="line-added">108 /// \cond</span>
109 #ifdef U_ALIASING_BARRIER
110 
111 Char16Ptr::Char16Ptr(char16_t *p) : p_(p) {}
112 #if !U_CHAR16_IS_TYPEDEF
113 Char16Ptr::Char16Ptr(uint16_t *p) : p_(cast(p)) {}
114 #endif
115 #if U_SIZEOF_WCHAR_T==2
116 Char16Ptr::Char16Ptr(wchar_t *p) : p_(cast(p)) {}
117 #endif
118 Char16Ptr::Char16Ptr(std::nullptr_t p) : p_(p) {}
119 Char16Ptr::~Char16Ptr() {
120     U_ALIASING_BARRIER(p_);
121 }
122 
123 char16_t *Char16Ptr::get() const { return p_; }
124 
125 #else
126 
127 Char16Ptr::Char16Ptr(char16_t *p) { u_.cp = p; }
128 #if !U_CHAR16_IS_TYPEDEF
<span class="line-added">140 /// \endcond</span>
141 
142 /**
143  * const char16_t * wrapper with implicit conversion from distinct but bit-compatible pointer types.
144  * @stable ICU 59
145  */
146 class U_COMMON_API ConstChar16Ptr U_FINAL {
147 public:
148     /**
149      * Copies the pointer.
150      * @param p pointer
151      * @stable ICU 59
152      */
153     inline ConstChar16Ptr(const char16_t *p);
154 #if !U_CHAR16_IS_TYPEDEF
155     /**
156      * Converts the pointer to char16_t *.
157      * @param p pointer to be converted
158      * @stable ICU 59
159      */
160     inline ConstChar16Ptr(const uint16_t *p);
</pre>
<hr />
<pre>
196 
197 private:
198     ConstChar16Ptr() = delete;
199 
200 #ifdef U_ALIASING_BARRIER
201     template&lt;typename T&gt; static const char16_t *cast(const T *t) {
202         U_ALIASING_BARRIER(t);
203         return reinterpret_cast&lt;const char16_t *&gt;(t);
204     }
205 
206     const char16_t *p_;
207 #else
208     union {
209         const char16_t *cp;
210         const uint16_t *up;
211         const wchar_t *wp;
212     } u_;
213 #endif
214 };
215 
<span class="line-added">216 /// \cond</span>
217 #ifdef U_ALIASING_BARRIER
218 
219 ConstChar16Ptr::ConstChar16Ptr(const char16_t *p) : p_(p) {}
220 #if !U_CHAR16_IS_TYPEDEF
221 ConstChar16Ptr::ConstChar16Ptr(const uint16_t *p) : p_(cast(p)) {}
222 #endif
223 #if U_SIZEOF_WCHAR_T==2
224 ConstChar16Ptr::ConstChar16Ptr(const wchar_t *p) : p_(cast(p)) {}
225 #endif
226 ConstChar16Ptr::ConstChar16Ptr(const std::nullptr_t p) : p_(p) {}
227 ConstChar16Ptr::~ConstChar16Ptr() {
228     U_ALIASING_BARRIER(p_);
229 }
230 
231 const char16_t *ConstChar16Ptr::get() const { return p_; }
232 
233 #else
234 
235 ConstChar16Ptr::ConstChar16Ptr(const char16_t *p) { u_.cp = p; }
236 #if !U_CHAR16_IS_TYPEDEF
<span class="line-added">248 /// \endcond</span>
249 
250 /**
251  * Converts from const char16_t * to const UChar *.
252  * Includes an aliasing barrier if available.
253  * @param p pointer
254  * @return p as const UChar *
255  * @stable ICU 59
256  */
257 inline const UChar *toUCharPtr(const char16_t *p) {
258 #ifdef U_ALIASING_BARRIER
259     U_ALIASING_BARRIER(p);
260 #endif
261     return reinterpret_cast&lt;const UChar *&gt;(p);
262 }
263 
264 /**
265  * Converts from char16_t * to UChar *.
266  * Includes an aliasing barrier if available.
267  * @param p pointer
268  * @return p as UChar *
</pre>
</td>
</tr>
</table>
<center><a href="casemap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="docmain.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>