<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/reldatefmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ******************************************************************************
   5 * Copyright (C) 2014-2016, International Business Machines Corporation and
   6 * others. All Rights Reserved.
   7 ******************************************************************************
   8 *
   9 * File reldatefmt.cpp
  10 ******************************************************************************
  11 */
  12 
  13 #include &quot;unicode/reldatefmt.h&quot;
  14 
  15 #if !UCONFIG_NO_FORMATTING &amp;&amp; !UCONFIG_NO_BREAK_ITERATION
  16 
  17 #include &lt;cmath&gt;
<a name="1" id="anc1"></a><span class="line-added">  18 #include &lt;functional&gt;</span>
  19 #include &quot;unicode/dtfmtsym.h&quot;
  20 #include &quot;unicode/ucasemap.h&quot;
  21 #include &quot;unicode/ureldatefmt.h&quot;
  22 #include &quot;unicode/udisplaycontext.h&quot;
  23 #include &quot;unicode/unum.h&quot;
  24 #include &quot;unicode/localpointer.h&quot;
  25 #include &quot;unicode/plurrule.h&quot;
  26 #include &quot;unicode/simpleformatter.h&quot;
  27 #include &quot;unicode/decimfmt.h&quot;
  28 #include &quot;unicode/numfmt.h&quot;
  29 #include &quot;unicode/brkiter.h&quot;
  30 #include &quot;unicode/simpleformatter.h&quot;
  31 #include &quot;uresimp.h&quot;
  32 #include &quot;unicode/ures.h&quot;
  33 #include &quot;cstring.h&quot;
  34 #include &quot;ucln_in.h&quot;
  35 #include &quot;mutex.h&quot;
  36 #include &quot;charstr.h&quot;
  37 #include &quot;uassert.h&quot;
  38 #include &quot;quantityformatter.h&quot;
  39 #include &quot;resource.h&quot;
  40 #include &quot;sharedbreakiterator.h&quot;
  41 #include &quot;sharedpluralrules.h&quot;
  42 #include &quot;sharednumberformat.h&quot;
  43 #include &quot;standardplural.h&quot;
  44 #include &quot;unifiedcache.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  45 #include &quot;util.h&quot;</span>
<span class="line-added">  46 #include &quot;number_stringbuilder.h&quot;</span>
<span class="line-added">  47 #include &quot;number_utypes.h&quot;</span>
<span class="line-added">  48 #include &quot;number_modifiers.h&quot;</span>
<span class="line-added">  49 #include &quot;formattedval_impl.h&quot;</span>
<span class="line-added">  50 #include &quot;number_utils.h&quot;</span>
  51 
  52 // Copied from uscript_props.cpp
  53 
<a name="3" id="anc3"></a>

  54 U_NAMESPACE_BEGIN
  55 
  56 // RelativeDateTimeFormatter specific data for a single locale
  57 class RelativeDateTimeCacheData: public SharedObject {
  58 public:
<a name="4" id="anc4"></a><span class="line-modified">  59     RelativeDateTimeCacheData() : combinedDateAndTime(nullptr) {</span>
  60         // Initialize the cache arrays
  61         for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
<a name="5" id="anc5"></a><span class="line-modified">  62             for (int32_t relUnit = 0; relUnit &lt; UDAT_REL_UNIT_COUNT; ++relUnit) {</span>
  63                 for (int32_t pl = 0; pl &lt; StandardPlural::COUNT; ++pl) {
<a name="6" id="anc6"></a><span class="line-modified">  64                     relativeUnitsFormatters[style][relUnit][0][pl] = nullptr;</span>
<span class="line-modified">  65                     relativeUnitsFormatters[style][relUnit][1][pl] = nullptr;</span>
  66                 }
  67             }
  68         }
  69         for (int32_t i = 0; i &lt; UDAT_STYLE_COUNT; ++i) {
  70           fallBackCache[i] = -1;
  71         }
  72     }
  73     virtual ~RelativeDateTimeCacheData();
  74 
  75     // no numbers: e.g Next Tuesday; Yesterday; etc.
  76     UnicodeString absoluteUnits[UDAT_STYLE_COUNT][UDAT_ABSOLUTE_UNIT_COUNT][UDAT_DIRECTION_COUNT];
  77 
  78     // SimpleFormatter pointers for relative unit format,
  79     // e.g., Next Tuesday; Yesterday; etc. For third index, 0
  80     // means past, e.g., 5 days ago; 1 means future, e.g., in 5 days.
  81     SimpleFormatter *relativeUnitsFormatters[UDAT_STYLE_COUNT]
<a name="7" id="anc7"></a><span class="line-modified">  82         [UDAT_REL_UNIT_COUNT][2][StandardPlural::COUNT];</span>
  83 
  84     const UnicodeString&amp; getAbsoluteUnitString(int32_t fStyle,
  85                                                UDateAbsoluteUnit unit,
  86                                                UDateDirection direction) const;
  87     const SimpleFormatter* getRelativeUnitFormatter(int32_t fStyle,
  88                                                     UDateRelativeUnit unit,
  89                                                     int32_t pastFutureIndex,
  90                                                     int32_t pluralUnit) const;
<a name="8" id="anc8"></a><span class="line-added">  91     const SimpleFormatter* getRelativeDateTimeUnitFormatter(int32_t fStyle,</span>
<span class="line-added">  92                                                     URelativeDateTimeUnit unit,</span>
<span class="line-added">  93                                                     int32_t pastFutureIndex,</span>
<span class="line-added">  94                                                     int32_t pluralUnit) const;</span>
  95 
  96     const UnicodeString emptyString;
  97 
  98     // Mappping from source to target styles for alias fallback.
  99     int32_t fallBackCache[UDAT_STYLE_COUNT];
 100 
 101     void adoptCombinedDateAndTime(SimpleFormatter *fmtToAdopt) {
 102         delete combinedDateAndTime;
 103         combinedDateAndTime = fmtToAdopt;
 104     }
 105     const SimpleFormatter *getCombinedDateAndTime() const {
 106         return combinedDateAndTime;
 107     }
 108 
 109 private:
 110     SimpleFormatter *combinedDateAndTime;
 111     RelativeDateTimeCacheData(const RelativeDateTimeCacheData &amp;other);
 112     RelativeDateTimeCacheData&amp; operator=(
 113             const RelativeDateTimeCacheData &amp;other);
 114 };
 115 
 116 RelativeDateTimeCacheData::~RelativeDateTimeCacheData() {
 117     // clear out the cache arrays
 118     for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
<a name="9" id="anc9"></a><span class="line-modified"> 119         for (int32_t relUnit = 0; relUnit &lt; UDAT_REL_UNIT_COUNT; ++relUnit) {</span>
 120             for (int32_t pl = 0; pl &lt; StandardPlural::COUNT; ++pl) {
 121                 delete relativeUnitsFormatters[style][relUnit][0][pl];
 122                 delete relativeUnitsFormatters[style][relUnit][1][pl];
 123             }
 124         }
 125     }
 126     delete combinedDateAndTime;
 127 }
 128 
 129 
 130 // Use fallback cache for absolute units.
 131 const UnicodeString&amp; RelativeDateTimeCacheData::getAbsoluteUnitString(
 132         int32_t fStyle, UDateAbsoluteUnit unit, UDateDirection direction) const {
 133     int32_t style = fStyle;
 134     do {
 135         if (!absoluteUnits[style][unit][direction].isEmpty()) {
 136             return absoluteUnits[style][unit][direction];
 137         }
 138         style = fallBackCache[style];
 139     } while (style != -1);
 140     return emptyString;
 141 }
 142 
<a name="10" id="anc10"></a>
 143  const SimpleFormatter* RelativeDateTimeCacheData::getRelativeUnitFormatter(
 144         int32_t fStyle,
 145         UDateRelativeUnit unit,
 146         int32_t pastFutureIndex,
 147         int32_t pluralUnit) const {
<a name="11" id="anc11"></a><span class="line-modified"> 148    URelativeDateTimeUnit rdtunit = UDAT_REL_UNIT_COUNT;</span>
<span class="line-modified"> 149    switch (unit) {</span>
<span class="line-modified"> 150        case UDAT_RELATIVE_YEARS:   rdtunit = UDAT_REL_UNIT_YEAR; break;</span>
<span class="line-modified"> 151        case UDAT_RELATIVE_MONTHS:  rdtunit = UDAT_REL_UNIT_MONTH; break;</span>
<span class="line-added"> 152        case UDAT_RELATIVE_WEEKS:   rdtunit = UDAT_REL_UNIT_WEEK; break;</span>
<span class="line-added"> 153        case UDAT_RELATIVE_DAYS:    rdtunit = UDAT_REL_UNIT_DAY; break;</span>
<span class="line-added"> 154        case UDAT_RELATIVE_HOURS:   rdtunit = UDAT_REL_UNIT_HOUR; break;</span>
<span class="line-added"> 155        case UDAT_RELATIVE_MINUTES: rdtunit = UDAT_REL_UNIT_MINUTE; break;</span>
<span class="line-added"> 156        case UDAT_RELATIVE_SECONDS: rdtunit = UDAT_REL_UNIT_SECOND; break;</span>
<span class="line-added"> 157        default: // a unit that the above method does not handle</span>
<span class="line-added"> 158             return nullptr;</span>
<span class="line-added"> 159    }</span>
<span class="line-added"> 160 </span>
<span class="line-added"> 161    return getRelativeDateTimeUnitFormatter(fStyle, rdtunit, pastFutureIndex, pluralUnit);</span>
<span class="line-added"> 162  }</span>
<span class="line-added"> 163 </span>
<span class="line-added"> 164  // Use fallback cache for SimpleFormatter relativeUnits.</span>
<span class="line-added"> 165  const SimpleFormatter* RelativeDateTimeCacheData::getRelativeDateTimeUnitFormatter(</span>
<span class="line-added"> 166         int32_t fStyle,</span>
<span class="line-added"> 167         URelativeDateTimeUnit unit,</span>
<span class="line-added"> 168         int32_t pastFutureIndex,</span>
<span class="line-added"> 169         int32_t pluralUnit) const {</span>
<span class="line-added"> 170     while (true) {</span>
<span class="line-added"> 171         int32_t style = fStyle;</span>
<span class="line-added"> 172         do {</span>
<span class="line-added"> 173             if (relativeUnitsFormatters[style][unit][pastFutureIndex][pluralUnit] != nullptr) {</span>
<span class="line-added"> 174                 return relativeUnitsFormatters[style][unit][pastFutureIndex][pluralUnit];</span>
<span class="line-added"> 175             }</span>
<span class="line-added"> 176             style = fallBackCache[style];</span>
<span class="line-added"> 177         } while (style != -1);</span>
<span class="line-added"> 178 </span>
<span class="line-added"> 179         if (pluralUnit == StandardPlural::OTHER) {</span>
<span class="line-added"> 180             break;</span>
 181         }
<a name="12" id="anc12"></a><span class="line-modified"> 182         pluralUnit = StandardPlural::OTHER;</span>
<span class="line-modified"> 183     }</span>
<span class="line-modified"> 184     return nullptr;  // No formatter found.</span>
 185  }
 186 
 187 static UBool getStringWithFallback(
 188         const UResourceBundle *resource,
 189         const char *key,
 190         UnicodeString &amp;result,
 191         UErrorCode &amp;status) {
 192     int32_t len = 0;
 193     const UChar *resStr = ures_getStringByKeyWithFallback(
 194         resource, key, &amp;len, &amp;status);
 195     if (U_FAILURE(status)) {
 196         return FALSE;
 197     }
 198     result.setTo(TRUE, resStr, len);
 199     return TRUE;
 200 }
 201 
 202 
 203 static UBool getStringByIndex(
 204         const UResourceBundle *resource,
 205         int32_t idx,
 206         UnicodeString &amp;result,
 207         UErrorCode &amp;status) {
 208     int32_t len = 0;
 209     const UChar *resStr = ures_getStringByIndex(
 210             resource, idx, &amp;len, &amp;status);
 211     if (U_FAILURE(status)) {
 212         return FALSE;
 213     }
 214     result.setTo(TRUE, resStr, len);
 215     return TRUE;
 216 }
 217 
 218 namespace {
 219 
 220 /**
 221  * Sink for enumerating all of the measurement unit display names.
 222  *
 223  * More specific bundles (en_GB) are enumerated before their parents (en_001, en, root):
 224  * Only store a value if it is still missing, that is, it has not been overridden.
 225  */
 226 struct RelDateTimeFmtDataSink : public ResourceSink {
 227 
 228     /**
 229      * Sink for patterns for relative dates and times. For example,
 230      * fields/relative/...
 231      */
 232 
 233     // Generic unit enum for storing Unit info.
 234     typedef enum RelAbsUnit {
 235         INVALID_UNIT = -1,
 236         SECOND,
 237         MINUTE,
 238         HOUR,
 239         DAY,
 240         WEEK,
 241         MONTH,
 242         QUARTER,
 243         YEAR,
 244         SUNDAY,
 245         MONDAY,
 246         TUESDAY,
 247         WEDNESDAY,
 248         THURSDAY,
 249         FRIDAY,
 250         SATURDAY
 251     } RelAbsUnit;
 252 
 253     static int32_t relUnitFromGeneric(RelAbsUnit genUnit) {
 254         // Converts the generic units to UDAT_RELATIVE version.
 255         switch (genUnit) {
 256             case SECOND:
<a name="13" id="anc13"></a><span class="line-modified"> 257                 return UDAT_REL_UNIT_SECOND;</span>
 258             case MINUTE:
<a name="14" id="anc14"></a><span class="line-modified"> 259                 return UDAT_REL_UNIT_MINUTE;</span>
 260             case HOUR:
<a name="15" id="anc15"></a><span class="line-modified"> 261                 return UDAT_REL_UNIT_HOUR;</span>
 262             case DAY:
<a name="16" id="anc16"></a><span class="line-modified"> 263                 return UDAT_REL_UNIT_DAY;</span>
 264             case WEEK:
<a name="17" id="anc17"></a><span class="line-modified"> 265                 return UDAT_REL_UNIT_WEEK;</span>
 266             case MONTH:
<a name="18" id="anc18"></a><span class="line-modified"> 267                 return UDAT_REL_UNIT_MONTH;</span>
<span class="line-modified"> 268             case QUARTER:</span>
<span class="line-modified"> 269                 return UDAT_REL_UNIT_QUARTER;</span>


 270             case YEAR:
<a name="19" id="anc19"></a><span class="line-modified"> 271                 return UDAT_REL_UNIT_YEAR;</span>
<span class="line-added"> 272             case SUNDAY:</span>
<span class="line-added"> 273                 return UDAT_REL_UNIT_SUNDAY;</span>
<span class="line-added"> 274             case MONDAY:</span>
<span class="line-added"> 275                 return UDAT_REL_UNIT_MONDAY;</span>
<span class="line-added"> 276             case TUESDAY:</span>
<span class="line-added"> 277                 return UDAT_REL_UNIT_TUESDAY;</span>
<span class="line-added"> 278             case WEDNESDAY:</span>
<span class="line-added"> 279                 return UDAT_REL_UNIT_WEDNESDAY;</span>
<span class="line-added"> 280             case THURSDAY:</span>
<span class="line-added"> 281                 return UDAT_REL_UNIT_THURSDAY;</span>
<span class="line-added"> 282             case FRIDAY:</span>
<span class="line-added"> 283                 return UDAT_REL_UNIT_FRIDAY;</span>
<span class="line-added"> 284             case SATURDAY:</span>
<span class="line-added"> 285                 return UDAT_REL_UNIT_SATURDAY;</span>
 286             default:
 287                 return -1;
 288         }
 289     }
 290 
 291     static int32_t absUnitFromGeneric(RelAbsUnit genUnit) {
 292         // Converts the generic units to UDAT_RELATIVE version.
 293         switch (genUnit) {
 294             case DAY:
 295                 return UDAT_ABSOLUTE_DAY;
 296             case WEEK:
 297                 return UDAT_ABSOLUTE_WEEK;
 298             case MONTH:
 299                 return UDAT_ABSOLUTE_MONTH;
<a name="20" id="anc20"></a><span class="line-modified"> 300             case QUARTER:</span>
<span class="line-modified"> 301                 return UDAT_ABSOLUTE_QUARTER;</span>


 302             case YEAR:
 303                 return UDAT_ABSOLUTE_YEAR;
 304             case SUNDAY:
 305                 return UDAT_ABSOLUTE_SUNDAY;
 306             case MONDAY:
 307                 return UDAT_ABSOLUTE_MONDAY;
 308             case TUESDAY:
 309                 return UDAT_ABSOLUTE_TUESDAY;
 310             case WEDNESDAY:
 311                 return UDAT_ABSOLUTE_WEDNESDAY;
 312             case THURSDAY:
 313                 return UDAT_ABSOLUTE_THURSDAY;
 314             case FRIDAY:
 315                 return UDAT_ABSOLUTE_FRIDAY;
 316             case SATURDAY:
 317                 return UDAT_ABSOLUTE_SATURDAY;
 318             default:
 319                 return -1;
 320         }
 321     }
 322 
 323     static int32_t keyToDirection(const char* key) {
 324         if (uprv_strcmp(key, &quot;-2&quot;) == 0) {
 325             return UDAT_DIRECTION_LAST_2;
 326         }
 327         if (uprv_strcmp(key, &quot;-1&quot;) == 0) {
 328             return UDAT_DIRECTION_LAST;
 329         }
 330         if (uprv_strcmp(key, &quot;0&quot;) == 0) {
 331             return UDAT_DIRECTION_THIS;
 332         }
 333         if (uprv_strcmp(key, &quot;1&quot;) == 0) {
 334             return UDAT_DIRECTION_NEXT;
 335         }
 336         if (uprv_strcmp(key, &quot;2&quot;) == 0) {
 337             return UDAT_DIRECTION_NEXT_2;
 338         }
 339         return -1;
 340     }
 341 
 342     // Values kept between levels of parsing the CLDR data.
 343     int32_t pastFutureIndex;  // 0 == past or 1 ==  future
 344     UDateRelativeDateTimeFormatterStyle style;  // {LONG, SHORT, NARROW}
 345     RelAbsUnit genericUnit;
 346 
 347     RelativeDateTimeCacheData &amp;outputData;
 348 
 349     // Constructor
 350     RelDateTimeFmtDataSink(RelativeDateTimeCacheData&amp; cacheData)
 351         : outputData(cacheData) {
 352         // Clear cacheData.fallBackCache
 353         cacheData.fallBackCache[UDAT_STYLE_LONG] = -1;
 354         cacheData.fallBackCache[UDAT_STYLE_SHORT] = -1;
 355         cacheData.fallBackCache[UDAT_STYLE_NARROW] = -1;
 356     }
 357 
 358     ~RelDateTimeFmtDataSink();
 359 
 360     // Utility functions
 361     static UDateRelativeDateTimeFormatterStyle styleFromString(const char *s) {
<a name="21" id="anc21"></a><span class="line-modified"> 362         int32_t len = static_cast&lt;int32_t&gt;(uprv_strlen(s));</span>
 363         if (len &gt;= 7 &amp;&amp; uprv_strcmp(s + len - 7, &quot;-narrow&quot;) == 0) {
 364             return UDAT_STYLE_NARROW;
 365         }
 366         if (len &gt;= 6 &amp;&amp; uprv_strcmp(s + len - 6, &quot;-short&quot;) == 0) {
 367             return UDAT_STYLE_SHORT;
 368         }
 369         return UDAT_STYLE_LONG;
 370     }
 371 
 372     static int32_t styleSuffixLength(UDateRelativeDateTimeFormatterStyle style) {
 373         switch (style) {
 374             case UDAT_STYLE_NARROW:
 375                 return 7;
 376             case UDAT_STYLE_SHORT:
 377                 return 6;
 378             default:
 379                 return 0;
 380         }
 381     }
 382 
 383     // Utility functions
 384     static UDateRelativeDateTimeFormatterStyle styleFromAliasUnicodeString(UnicodeString s) {
 385         static const UChar narrow[7] = {0x002D, 0x006E, 0x0061, 0x0072, 0x0072, 0x006F, 0x0077};
 386         static const UChar sshort[6] = {0x002D, 0x0073, 0x0068, 0x006F, 0x0072, 0x0074,};
 387         if (s.endsWith(narrow, 7)) {
 388             return UDAT_STYLE_NARROW;
 389         }
 390         if (s.endsWith(sshort, 6)) {
 391             return UDAT_STYLE_SHORT;
 392         }
 393         return UDAT_STYLE_LONG;
 394     }
 395 
 396     static RelAbsUnit unitOrNegativeFromString(const char* keyword, int32_t length) {
 397         // Quick check from string to enum.
 398         switch (length) {
 399             case 3:
 400                 if (uprv_strncmp(keyword, &quot;day&quot;, length) == 0) {
 401                     return DAY;
 402                 } else if (uprv_strncmp(keyword, &quot;sun&quot;, length) == 0) {
 403                     return SUNDAY;
 404                 } else if (uprv_strncmp(keyword, &quot;mon&quot;, length) == 0) {
 405                     return MONDAY;
 406                 } else if (uprv_strncmp(keyword, &quot;tue&quot;, length) == 0) {
 407                     return TUESDAY;
 408                 } else if (uprv_strncmp(keyword, &quot;wed&quot;, length) == 0) {
 409                     return WEDNESDAY;
 410                 } else if (uprv_strncmp(keyword, &quot;thu&quot;, length) == 0) {
 411                     return THURSDAY;
 412                 } else if (uprv_strncmp(keyword, &quot;fri&quot;, length) == 0) {
 413                     return FRIDAY;
 414                 } else if (uprv_strncmp(keyword, &quot;sat&quot;, length) == 0) {
 415                     return SATURDAY;
 416                 }
 417                 break;
 418             case 4:
 419                 if (uprv_strncmp(keyword, &quot;hour&quot;, length) == 0) {
 420                     return HOUR;
 421                 } else if (uprv_strncmp(keyword, &quot;week&quot;, length) == 0) {
 422                     return WEEK;
 423                 } else if (uprv_strncmp(keyword, &quot;year&quot;, length) == 0) {
 424                     return YEAR;
 425                 }
 426                 break;
 427             case 5:
 428                 if (uprv_strncmp(keyword, &quot;month&quot;, length) == 0) {
 429                     return MONTH;
 430                 }
 431                 break;
 432             case 6:
 433                 if (uprv_strncmp(keyword, &quot;minute&quot;, length) == 0) {
 434                     return MINUTE;
 435                 } else if (uprv_strncmp(keyword, &quot;second&quot;, length) == 0) {
 436                     return SECOND;
 437                 }
 438                 break;
 439             case 7:
 440                 if (uprv_strncmp(keyword, &quot;quarter&quot;, length) == 0) {
 441                     return QUARTER;  // TODO: Check @provisional
 442                   }
 443                 break;
 444             default:
 445                 break;
 446         }
 447         return INVALID_UNIT;
 448     }
 449 
 450     void handlePlainDirection(ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 451         // Handle Display Name for PLAIN direction for some units.
 452         if (U_FAILURE(errorCode)) { return; }
 453 
 454         int32_t absUnit = absUnitFromGeneric(genericUnit);
 455         if (absUnit &lt; 0) {
 456           return;  // Not interesting.
 457         }
 458 
 459         // Store displayname if not set.
 460         if (outputData.absoluteUnits[style]
 461             [absUnit][UDAT_DIRECTION_PLAIN].isEmpty()) {
 462             outputData.absoluteUnits[style]
 463                 [absUnit][UDAT_DIRECTION_PLAIN].fastCopyFrom(value.getUnicodeString(errorCode));
 464             return;
 465         }
 466     }
 467 
 468     void consumeTableRelative(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 469         ResourceTable unitTypesTable = value.getTable(errorCode);
 470         if (U_FAILURE(errorCode)) { return; }
 471 
 472         for (int32_t i = 0; unitTypesTable.getKeyAndValue(i, key, value); ++i) {
 473             if (value.getType() == URES_STRING) {
 474                 int32_t direction = keyToDirection(key);
 475                 if (direction &lt; 0) {
 476                   continue;
 477                 }
 478 
 479                 int32_t relUnitIndex = relUnitFromGeneric(genericUnit);
<a name="22" id="anc22"></a><span class="line-modified"> 480                 if (relUnitIndex == UDAT_REL_UNIT_SECOND &amp;&amp; uprv_strcmp(key, &quot;0&quot;) == 0 &amp;&amp;</span>
 481                     outputData.absoluteUnits[style][UDAT_ABSOLUTE_NOW][UDAT_DIRECTION_PLAIN].isEmpty()) {
 482                     // Handle &quot;NOW&quot;
 483                     outputData.absoluteUnits[style][UDAT_ABSOLUTE_NOW]
 484                         [UDAT_DIRECTION_PLAIN].fastCopyFrom(value.getUnicodeString(errorCode));
 485                 }
 486 
 487                 int32_t absUnitIndex = absUnitFromGeneric(genericUnit);
 488                 if (absUnitIndex &lt; 0) {
 489                     continue;
 490                 }
 491                 // Only reset if slot is empty.
 492                 if (outputData.absoluteUnits[style][absUnitIndex][direction].isEmpty()) {
 493                     outputData.absoluteUnits[style][absUnitIndex]
 494                         [direction].fastCopyFrom(value.getUnicodeString(errorCode));
 495                 }
 496             }
 497         }
 498     }
 499 
 500     void consumeTimeDetail(int32_t relUnitIndex,
 501                            const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 502         ResourceTable unitTypesTable = value.getTable(errorCode);
 503         if (U_FAILURE(errorCode)) { return; }
 504 
 505           for (int32_t i = 0; unitTypesTable.getKeyAndValue(i, key, value); ++i) {
 506             if (value.getType() == URES_STRING) {
 507                 int32_t pluralIndex = StandardPlural::indexOrNegativeFromString(key);
 508                 if (pluralIndex &gt;= 0) {
 509                     SimpleFormatter **patterns =
 510                         outputData.relativeUnitsFormatters[style][relUnitIndex]
 511                         [pastFutureIndex];
 512                     // Only set if not already established.
<a name="23" id="anc23"></a><span class="line-modified"> 513                     if (patterns[pluralIndex] == nullptr) {</span>
 514                         patterns[pluralIndex] = new SimpleFormatter(
 515                             value.getUnicodeString(errorCode), 0, 1, errorCode);
<a name="24" id="anc24"></a><span class="line-modified"> 516                         if (patterns[pluralIndex] == nullptr) {</span>
 517                             errorCode = U_MEMORY_ALLOCATION_ERROR;
 518                         }
 519                     }
 520                 }
 521             }
 522         }
 523     }
 524 
 525     void consumeTableRelativeTime(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 526         ResourceTable relativeTimeTable = value.getTable(errorCode);
 527         if (U_FAILURE(errorCode)) { return; }
 528 
 529         int32_t relUnitIndex = relUnitFromGeneric(genericUnit);
 530         if (relUnitIndex &lt; 0) {
 531             return;
 532         }
 533         for (int32_t i = 0; relativeTimeTable.getKeyAndValue(i, key, value); ++i) {
 534             if (uprv_strcmp(key, &quot;past&quot;) == 0) {
 535                 pastFutureIndex = 0;
 536             } else if (uprv_strcmp(key, &quot;future&quot;) == 0) {
 537                 pastFutureIndex = 1;
 538             } else {
 539                 // Unknown key.
 540                 continue;
 541             }
 542             consumeTimeDetail(relUnitIndex, key, value, errorCode);
 543         }
 544     }
 545 
 546     void consumeAlias(const char *key, const ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 547 
 548         UDateRelativeDateTimeFormatterStyle sourceStyle = styleFromString(key);
 549         const UnicodeString valueStr = value.getAliasUnicodeString(errorCode);
 550         if (U_FAILURE(errorCode)) { return; }
 551 
 552         UDateRelativeDateTimeFormatterStyle targetStyle =
 553             styleFromAliasUnicodeString(valueStr);
 554 
 555         if (sourceStyle == targetStyle) {
 556             errorCode = U_INVALID_FORMAT_ERROR;
 557             return;
 558         }
 559         if (outputData.fallBackCache[sourceStyle] != -1 &amp;&amp;
 560             outputData.fallBackCache[sourceStyle] != targetStyle) {
 561             errorCode = U_INVALID_FORMAT_ERROR;
 562             return;
 563         }
 564         outputData.fallBackCache[sourceStyle] = targetStyle;
 565     }
 566 
 567     void consumeTimeUnit(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 568         ResourceTable unitTypesTable = value.getTable(errorCode);
 569         if (U_FAILURE(errorCode)) { return; }
 570 
 571         for (int32_t i = 0; unitTypesTable.getKeyAndValue(i, key, value); ++i) {
 572             // Handle display name.
 573             if (uprv_strcmp(key, &quot;dn&quot;) == 0 &amp;&amp; value.getType() == URES_STRING) {
 574                 handlePlainDirection(value, errorCode);
 575             }
 576             if (value.getType() == URES_TABLE) {
 577                 if (uprv_strcmp(key, &quot;relative&quot;) == 0) {
 578                     consumeTableRelative(key, value, errorCode);
 579                 } else if (uprv_strcmp(key, &quot;relativeTime&quot;) == 0) {
 580                     consumeTableRelativeTime(key, value, errorCode);
 581                 }
 582             }
 583         }
 584     }
 585 
 586     virtual void put(const char *key, ResourceValue &amp;value,
 587                      UBool /*noFallback*/, UErrorCode &amp;errorCode) {
 588         // Main entry point to sink
 589         ResourceTable table = value.getTable(errorCode);
 590         if (U_FAILURE(errorCode)) { return; }
 591         for (int32_t i = 0; table.getKeyAndValue(i, key, value); ++i) {
 592             if (value.getType() == URES_ALIAS) {
 593                 consumeAlias(key, value, errorCode);
 594             } else {
 595                 style = styleFromString(key);
<a name="25" id="anc25"></a><span class="line-modified"> 596                 int32_t unitSize = static_cast&lt;int32_t&gt;(uprv_strlen(key)) - styleSuffixLength(style);</span>
 597                 genericUnit = unitOrNegativeFromString(key, unitSize);
 598                 if (style &gt;= 0 &amp;&amp; genericUnit != INVALID_UNIT) {
 599                     consumeTimeUnit(key, value, errorCode);
 600                 }
 601             }
 602         }
 603     }
 604 
 605 };
 606 
 607 // Virtual destructors must be defined out of line.
 608 RelDateTimeFmtDataSink::~RelDateTimeFmtDataSink() {}
 609 } // namespace
 610 
 611 static const DateFormatSymbols::DtWidthType styleToDateFormatSymbolWidth[UDAT_STYLE_COUNT] = {
 612   DateFormatSymbols::WIDE, DateFormatSymbols::SHORT, DateFormatSymbols::NARROW
 613 };
 614 
 615 // Get days of weeks from the DateFormatSymbols class.
 616 static void loadWeekdayNames(UnicodeString absoluteUnits[UDAT_STYLE_COUNT]
 617                                  [UDAT_ABSOLUTE_UNIT_COUNT][UDAT_DIRECTION_COUNT],
 618                              const char* localeId,
 619                              UErrorCode&amp; status) {
<a name="26" id="anc26"></a><span class="line-added"> 620     if (U_FAILURE(status)) {</span>
<span class="line-added"> 621         return;</span>
<span class="line-added"> 622     }</span>
 623     Locale locale(localeId);
 624     DateFormatSymbols dfSym(locale, status);
<a name="27" id="anc27"></a><span class="line-added"> 625     if (U_FAILURE(status)) {</span>
<span class="line-added"> 626         return;</span>
<span class="line-added"> 627     }</span>
 628     for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
 629         DateFormatSymbols::DtWidthType dtfmtWidth = styleToDateFormatSymbolWidth[style];
 630         int32_t count;
 631         const UnicodeString* weekdayNames =
 632             dfSym.getWeekdays(count, DateFormatSymbols::STANDALONE, dtfmtWidth);
 633         for (int32_t dayIndex = UDAT_ABSOLUTE_SUNDAY;
 634                 dayIndex &lt;= UDAT_ABSOLUTE_SATURDAY; ++ dayIndex) {
 635             int32_t dateSymbolIndex = (dayIndex - UDAT_ABSOLUTE_SUNDAY) + UCAL_SUNDAY;
 636             absoluteUnits[style][dayIndex][UDAT_DIRECTION_PLAIN].fastCopyFrom(
 637                 weekdayNames[dateSymbolIndex]);
 638         }
 639     }
 640 }
 641 
 642 static UBool loadUnitData(
 643         const UResourceBundle *resource,
 644         RelativeDateTimeCacheData &amp;cacheData,
 645         const char* localeId,
 646         UErrorCode &amp;status) {
 647 
 648     RelDateTimeFmtDataSink sink(cacheData);
 649 
 650     ures_getAllItemsWithFallback(resource, &quot;fields&quot;, sink, status);
<a name="28" id="anc28"></a><span class="line-added"> 651     if (U_FAILURE(status)) {</span>
<span class="line-added"> 652         return false;</span>
<span class="line-added"> 653     }</span>
 654 
 655     // Get the weekday names from DateFormatSymbols.
 656     loadWeekdayNames(cacheData.absoluteUnits, localeId, status);
 657     return U_SUCCESS(status);
 658 }
 659 
 660 static UBool getDateTimePattern(
 661         const UResourceBundle *resource,
 662         UnicodeString &amp;result,
 663         UErrorCode &amp;status) {
 664     UnicodeString defaultCalendarName;
 665     if (!getStringWithFallback(
 666             resource,
 667             &quot;calendar/default&quot;,
 668             defaultCalendarName,
 669             status)) {
 670         return FALSE;
 671     }
 672     CharString pathBuffer;
 673     pathBuffer.append(&quot;calendar/&quot;, status)
 674             .appendInvariantChars(defaultCalendarName, status)
 675             .append(&quot;/DateTimePatterns&quot;, status);
 676     LocalUResourceBundlePointer topLevel(
 677             ures_getByKeyWithFallback(
<a name="29" id="anc29"></a><span class="line-modified"> 678                     resource, pathBuffer.data(), nullptr, &amp;status));</span>
 679     if (U_FAILURE(status)) {
 680         return FALSE;
 681     }
 682     int32_t size = ures_getSize(topLevel.getAlias());
 683     if (size &lt;= 8) {
 684         // Oops, size is too small to access the index that we want, fallback
 685         // to a hard-coded value.
 686         result = UNICODE_STRING_SIMPLE(&quot;{1} {0}&quot;);
 687         return TRUE;
 688     }
 689     return getStringByIndex(topLevel.getAlias(), 8, result, status);
 690 }
 691 
 692 template&lt;&gt; U_I18N_API
 693 const RelativeDateTimeCacheData *LocaleCacheKey&lt;RelativeDateTimeCacheData&gt;::createObject(const void * /*unused*/, UErrorCode &amp;status) const {
 694     const char *localeId = fLoc.getName();
<a name="30" id="anc30"></a><span class="line-modified"> 695     LocalUResourceBundlePointer topLevel(ures_open(nullptr, localeId, &amp;status));</span>
 696     if (U_FAILURE(status)) {
<a name="31" id="anc31"></a><span class="line-modified"> 697         return nullptr;</span>
 698     }
 699     LocalPointer&lt;RelativeDateTimeCacheData&gt; result(
 700             new RelativeDateTimeCacheData());
 701     if (result.isNull()) {
 702         status = U_MEMORY_ALLOCATION_ERROR;
<a name="32" id="anc32"></a><span class="line-modified"> 703         return nullptr;</span>
 704     }
 705     if (!loadUnitData(
 706             topLevel.getAlias(),
 707             *result,
 708             localeId,
 709             status)) {
<a name="33" id="anc33"></a><span class="line-modified"> 710         return nullptr;</span>
 711     }
 712     UnicodeString dateTimePattern;
 713     if (!getDateTimePattern(topLevel.getAlias(), dateTimePattern, status)) {
<a name="34" id="anc34"></a><span class="line-modified"> 714         return nullptr;</span>
 715     }
 716     result-&gt;adoptCombinedDateAndTime(
 717             new SimpleFormatter(dateTimePattern, 2, 2, status));
 718     if (U_FAILURE(status)) {
<a name="35" id="anc35"></a><span class="line-modified"> 719         return nullptr;</span>
 720     }
 721     result-&gt;addRef();
 722     return result.orphan();
 723 }
 724 
<a name="36" id="anc36"></a><span class="line-added"> 725 </span>
<span class="line-added"> 726 </span>
<span class="line-added"> 727 static constexpr number::impl::Field kRDTNumericField</span>
<span class="line-added"> 728     = number::impl::NumFieldUtils::compress&lt;UFIELD_CATEGORY_RELATIVE_DATETIME, UDAT_REL_NUMERIC_FIELD&gt;();</span>
<span class="line-added"> 729 </span>
<span class="line-added"> 730 static constexpr number::impl::Field kRDTLiteralField</span>
<span class="line-added"> 731     = number::impl::NumFieldUtils::compress&lt;UFIELD_CATEGORY_RELATIVE_DATETIME, UDAT_REL_LITERAL_FIELD&gt;();</span>
<span class="line-added"> 732 </span>
<span class="line-added"> 733 class FormattedRelativeDateTimeData : public FormattedValueNumberStringBuilderImpl {</span>
<span class="line-added"> 734 public:</span>
<span class="line-added"> 735     FormattedRelativeDateTimeData() : FormattedValueNumberStringBuilderImpl(kRDTNumericField) {}</span>
<span class="line-added"> 736     virtual ~FormattedRelativeDateTimeData();</span>
<span class="line-added"> 737 };</span>
<span class="line-added"> 738 </span>
<span class="line-added"> 739 FormattedRelativeDateTimeData::~FormattedRelativeDateTimeData() = default;</span>
<span class="line-added"> 740 </span>
<span class="line-added"> 741 </span>
<span class="line-added"> 742 UPRV_FORMATTED_VALUE_SUBCLASS_AUTO_IMPL(FormattedRelativeDateTime)</span>
<span class="line-added"> 743 </span>
<span class="line-added"> 744 </span>
 745 RelativeDateTimeFormatter::RelativeDateTimeFormatter(UErrorCode&amp; status) :
<a name="37" id="anc37"></a><span class="line-modified"> 746         fCache(nullptr),</span>
<span class="line-modified"> 747         fNumberFormat(nullptr),</span>
<span class="line-modified"> 748         fPluralRules(nullptr),</span>
 749         fStyle(UDAT_STYLE_LONG),
 750         fContext(UDISPCTX_CAPITALIZATION_NONE),
<a name="38" id="anc38"></a><span class="line-modified"> 751         fOptBreakIterator(nullptr) {</span>
<span class="line-modified"> 752     init(nullptr, nullptr, status);</span>
 753 }
 754 
 755 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 756         const Locale&amp; locale, UErrorCode&amp; status) :
<a name="39" id="anc39"></a><span class="line-modified"> 757         fCache(nullptr),</span>
<span class="line-modified"> 758         fNumberFormat(nullptr),</span>
<span class="line-modified"> 759         fPluralRules(nullptr),</span>
 760         fStyle(UDAT_STYLE_LONG),
 761         fContext(UDISPCTX_CAPITALIZATION_NONE),
<a name="40" id="anc40"></a><span class="line-modified"> 762         fOptBreakIterator(nullptr),</span>
 763         fLocale(locale) {
<a name="41" id="anc41"></a><span class="line-modified"> 764     init(nullptr, nullptr, status);</span>
 765 }
 766 
 767 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 768         const Locale&amp; locale, NumberFormat *nfToAdopt, UErrorCode&amp; status) :
<a name="42" id="anc42"></a><span class="line-modified"> 769         fCache(nullptr),</span>
<span class="line-modified"> 770         fNumberFormat(nullptr),</span>
<span class="line-modified"> 771         fPluralRules(nullptr),</span>
 772         fStyle(UDAT_STYLE_LONG),
 773         fContext(UDISPCTX_CAPITALIZATION_NONE),
<a name="43" id="anc43"></a><span class="line-modified"> 774         fOptBreakIterator(nullptr),</span>
 775         fLocale(locale) {
<a name="44" id="anc44"></a><span class="line-modified"> 776     init(nfToAdopt, nullptr, status);</span>
 777 }
 778 
 779 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 780         const Locale&amp; locale,
 781         NumberFormat *nfToAdopt,
 782         UDateRelativeDateTimeFormatterStyle styl,
 783         UDisplayContext capitalizationContext,
 784         UErrorCode&amp; status) :
<a name="45" id="anc45"></a><span class="line-modified"> 785         fCache(nullptr),</span>
<span class="line-modified"> 786         fNumberFormat(nullptr),</span>
<span class="line-modified"> 787         fPluralRules(nullptr),</span>
 788         fStyle(styl),
 789         fContext(capitalizationContext),
<a name="46" id="anc46"></a><span class="line-modified"> 790         fOptBreakIterator(nullptr),</span>
 791         fLocale(locale) {
 792     if (U_FAILURE(status)) {
 793         return;
 794     }
 795     if ((capitalizationContext &gt;&gt; 8) != UDISPCTX_TYPE_CAPITALIZATION) {
 796         status = U_ILLEGAL_ARGUMENT_ERROR;
 797         return;
 798     }
 799     if (capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE) {
 800         BreakIterator *bi = BreakIterator::createSentenceInstance(locale, status);
 801         if (U_FAILURE(status)) {
 802             return;
 803         }
 804         init(nfToAdopt, bi, status);
 805     } else {
<a name="47" id="anc47"></a><span class="line-modified"> 806         init(nfToAdopt, nullptr, status);</span>
 807     }
 808 }
 809 
 810 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 811         const RelativeDateTimeFormatter&amp; other)
 812         : UObject(other),
 813           fCache(other.fCache),
 814           fNumberFormat(other.fNumberFormat),
 815           fPluralRules(other.fPluralRules),
 816           fStyle(other.fStyle),
 817           fContext(other.fContext),
 818           fOptBreakIterator(other.fOptBreakIterator),
 819           fLocale(other.fLocale) {
 820     fCache-&gt;addRef();
 821     fNumberFormat-&gt;addRef();
 822     fPluralRules-&gt;addRef();
<a name="48" id="anc48"></a><span class="line-modified"> 823     if (fOptBreakIterator != nullptr) {</span>
 824       fOptBreakIterator-&gt;addRef();
 825     }
 826 }
 827 
 828 RelativeDateTimeFormatter&amp; RelativeDateTimeFormatter::operator=(
 829         const RelativeDateTimeFormatter&amp; other) {
 830     if (this != &amp;other) {
 831         SharedObject::copyPtr(other.fCache, fCache);
 832         SharedObject::copyPtr(other.fNumberFormat, fNumberFormat);
 833         SharedObject::copyPtr(other.fPluralRules, fPluralRules);
 834         SharedObject::copyPtr(other.fOptBreakIterator, fOptBreakIterator);
 835         fStyle = other.fStyle;
 836         fContext = other.fContext;
 837         fLocale = other.fLocale;
 838     }
 839     return *this;
 840 }
 841 
 842 RelativeDateTimeFormatter::~RelativeDateTimeFormatter() {
<a name="49" id="anc49"></a><span class="line-modified"> 843     if (fCache != nullptr) {</span>
 844         fCache-&gt;removeRef();
 845     }
<a name="50" id="anc50"></a><span class="line-modified"> 846     if (fNumberFormat != nullptr) {</span>
 847         fNumberFormat-&gt;removeRef();
 848     }
<a name="51" id="anc51"></a><span class="line-modified"> 849     if (fPluralRules != nullptr) {</span>
 850         fPluralRules-&gt;removeRef();
 851     }
<a name="52" id="anc52"></a><span class="line-modified"> 852     if (fOptBreakIterator != nullptr) {</span>
 853         fOptBreakIterator-&gt;removeRef();
 854     }
 855 }
 856 
 857 const NumberFormat&amp; RelativeDateTimeFormatter::getNumberFormat() const {
 858     return **fNumberFormat;
 859 }
 860 
 861 UDisplayContext RelativeDateTimeFormatter::getCapitalizationContext() const {
 862     return fContext;
 863 }
 864 
 865 UDateRelativeDateTimeFormatterStyle RelativeDateTimeFormatter::getFormatStyle() const {
 866     return fStyle;
 867 }
 868 
<a name="53" id="anc53"></a><span class="line-modified"> 869 </span>
<span class="line-modified"> 870 // To reduce boilerplate code, we use a helper function that forwards variadic</span>
<span class="line-modified"> 871 // arguments to the formatImpl function.</span>
<span class="line-added"> 872 </span>
<span class="line-added"> 873 template&lt;typename F, typename... Args&gt;</span>
<span class="line-added"> 874 UnicodeString&amp; RelativeDateTimeFormatter::doFormat(</span>
<span class="line-added"> 875         F callback,</span>
<span class="line-added"> 876         UnicodeString&amp; appendTo,</span>
<span class="line-added"> 877         UErrorCode&amp; status,</span>
<span class="line-added"> 878         Args... args) const {</span>
<span class="line-added"> 879     FormattedRelativeDateTimeData output;</span>
<span class="line-added"> 880     (this-&gt;*callback)(std::forward&lt;Args&gt;(args)..., output, status);</span>
 881     if (U_FAILURE(status)) {
 882         return appendTo;
 883     }
<a name="54" id="anc54"></a><span class="line-added"> 884     UnicodeString result = output.getStringRef().toUnicodeString();</span>
<span class="line-added"> 885     return appendTo.append(adjustForContext(result));</span>
<span class="line-added"> 886 }</span>
<span class="line-added"> 887 </span>
<span class="line-added"> 888 template&lt;typename F, typename... Args&gt;</span>
<span class="line-added"> 889 FormattedRelativeDateTime RelativeDateTimeFormatter::doFormatToValue(</span>
<span class="line-added"> 890         F callback,</span>
<span class="line-added"> 891         UErrorCode&amp; status,</span>
<span class="line-added"> 892         Args... args) const {</span>
<span class="line-added"> 893     if (!checkNoAdjustForContext(status)) {</span>
<span class="line-added"> 894         return FormattedRelativeDateTime(status);</span>
<span class="line-added"> 895     }</span>
<span class="line-added"> 896     LocalPointer&lt;FormattedRelativeDateTimeData&gt; output(</span>
<span class="line-added"> 897         new FormattedRelativeDateTimeData(), status);</span>
<span class="line-added"> 898     if (U_FAILURE(status)) {</span>
<span class="line-added"> 899         return FormattedRelativeDateTime(status);</span>
<span class="line-added"> 900     }</span>
<span class="line-added"> 901     (this-&gt;*callback)(std::forward&lt;Args&gt;(args)..., *output, status);</span>
<span class="line-added"> 902     output-&gt;getStringRef().writeTerminator(status);</span>
<span class="line-added"> 903     return FormattedRelativeDateTime(output.orphan());</span>
<span class="line-added"> 904 }</span>
<span class="line-added"> 905 </span>
<span class="line-added"> 906 UnicodeString&amp; RelativeDateTimeFormatter::format(</span>
<span class="line-added"> 907         double quantity,</span>
<span class="line-added"> 908         UDateDirection direction,</span>
<span class="line-added"> 909         UDateRelativeUnit unit,</span>
<span class="line-added"> 910         UnicodeString&amp; appendTo,</span>
<span class="line-added"> 911         UErrorCode&amp; status) const {</span>
<span class="line-added"> 912     return doFormat(</span>
<span class="line-added"> 913         &amp;RelativeDateTimeFormatter::formatImpl,</span>
<span class="line-added"> 914         appendTo,</span>
<span class="line-added"> 915         status,</span>
<span class="line-added"> 916         quantity,</span>
<span class="line-added"> 917         direction,</span>
<span class="line-added"> 918         unit);</span>
<span class="line-added"> 919 }</span>
<span class="line-added"> 920 </span>
<span class="line-added"> 921 FormattedRelativeDateTime RelativeDateTimeFormatter::formatToValue(</span>
<span class="line-added"> 922         double quantity,</span>
<span class="line-added"> 923         UDateDirection direction,</span>
<span class="line-added"> 924         UDateRelativeUnit unit,</span>
<span class="line-added"> 925         UErrorCode&amp; status) const {</span>
<span class="line-added"> 926     return doFormatToValue(</span>
<span class="line-added"> 927         &amp;RelativeDateTimeFormatter::formatImpl,</span>
<span class="line-added"> 928         status,</span>
<span class="line-added"> 929         quantity,</span>
<span class="line-added"> 930         direction,</span>
<span class="line-added"> 931         unit);</span>
<span class="line-added"> 932 }</span>
<span class="line-added"> 933 </span>
<span class="line-added"> 934 void RelativeDateTimeFormatter::formatImpl(</span>
<span class="line-added"> 935         double quantity,</span>
<span class="line-added"> 936         UDateDirection direction,</span>
<span class="line-added"> 937         UDateRelativeUnit unit,</span>
<span class="line-added"> 938         FormattedRelativeDateTimeData&amp; output,</span>
<span class="line-added"> 939         UErrorCode&amp; status) const {</span>
<span class="line-added"> 940     if (U_FAILURE(status)) {</span>
<span class="line-added"> 941         return;</span>
<span class="line-added"> 942     }</span>
 943     if (direction != UDAT_DIRECTION_LAST &amp;&amp; direction != UDAT_DIRECTION_NEXT) {
 944         status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="55" id="anc55"></a><span class="line-modified"> 945         return;</span>
 946     }
 947     int32_t bFuture = direction == UDAT_DIRECTION_NEXT ? 1 : 0;
<a name="56" id="anc56"></a>



 948 
<a name="57" id="anc57"></a><span class="line-modified"> 949     StandardPlural::Form pluralForm;</span>
<span class="line-modified"> 950     QuantityFormatter::formatAndSelect(</span>
<span class="line-added"> 951         quantity,</span>
<span class="line-added"> 952         **fNumberFormat,</span>
<span class="line-added"> 953         **fPluralRules,</span>
<span class="line-added"> 954         output.getStringRef(),</span>
<span class="line-added"> 955         pluralForm,</span>
 956         status);
<a name="58" id="anc58"></a><span class="line-added"> 957     if (U_FAILURE(status)) {</span>
<span class="line-added"> 958         return;</span>
<span class="line-added"> 959     }</span>
 960 
 961     const SimpleFormatter* formatter =
<a name="59" id="anc59"></a><span class="line-modified"> 962         fCache-&gt;getRelativeUnitFormatter(fStyle, unit, bFuture, pluralForm);</span>
<span class="line-modified"> 963     if (formatter == nullptr) {</span>
 964         // TODO: WARN - look at quantity formatter&#39;s action with an error.
 965         status = U_INVALID_FORMAT_ERROR;
<a name="60" id="anc60"></a><span class="line-modified"> 966         return;</span>
 967     }
<a name="61" id="anc61"></a><span class="line-modified"> 968 </span>
<span class="line-modified"> 969     number::impl::SimpleModifier modifier(*formatter, kRDTLiteralField, false);</span>
<span class="line-modified"> 970     modifier.formatAsPrefixSuffix(</span>
<span class="line-added"> 971         output.getStringRef(), 0, output.getStringRef().length(), status);</span>
 972 }
 973 
 974 UnicodeString&amp; RelativeDateTimeFormatter::formatNumeric(
<a name="62" id="anc62"></a><span class="line-modified"> 975         double offset,</span>
<span class="line-modified"> 976         URelativeDateTimeUnit unit,</span>
<span class="line-added"> 977         UnicodeString&amp; appendTo,</span>
<span class="line-added"> 978         UErrorCode&amp; status) const {</span>
<span class="line-added"> 979     return doFormat(</span>
<span class="line-added"> 980         &amp;RelativeDateTimeFormatter::formatNumericImpl,</span>
<span class="line-added"> 981         appendTo,</span>
<span class="line-added"> 982         status,</span>
<span class="line-added"> 983         offset,</span>
<span class="line-added"> 984         unit);</span>
<span class="line-added"> 985 }</span>
<span class="line-added"> 986 </span>
<span class="line-added"> 987 FormattedRelativeDateTime RelativeDateTimeFormatter::formatNumericToValue(</span>
<span class="line-added"> 988         double offset,</span>
<span class="line-added"> 989         URelativeDateTimeUnit unit,</span>
<span class="line-added"> 990         UErrorCode&amp; status) const {</span>
<span class="line-added"> 991     return doFormatToValue(</span>
<span class="line-added"> 992         &amp;RelativeDateTimeFormatter::formatNumericImpl,</span>
<span class="line-added"> 993         status,</span>
<span class="line-added"> 994         offset,</span>
<span class="line-added"> 995         unit);</span>
<span class="line-added"> 996 }</span>
<span class="line-added"> 997 </span>
<span class="line-added"> 998 void RelativeDateTimeFormatter::formatNumericImpl(</span>
<span class="line-added"> 999         double offset,</span>
<span class="line-added">1000         URelativeDateTimeUnit unit,</span>
<span class="line-added">1001         FormattedRelativeDateTimeData&amp; output,</span>
<span class="line-added">1002         UErrorCode&amp; status) const {</span>
1003     if (U_FAILURE(status)) {
<a name="63" id="anc63"></a><span class="line-modified">1004         return;</span>





















1005     }
1006     UDateDirection direction = UDAT_DIRECTION_NEXT;
1007     if (std::signbit(offset)) { // needed to handle -0.0
1008         direction = UDAT_DIRECTION_LAST;
1009         offset = -offset;
1010     }
<a name="64" id="anc64"></a><span class="line-modified">1011     if (direction != UDAT_DIRECTION_LAST &amp;&amp; direction != UDAT_DIRECTION_NEXT) {</span>
<span class="line-added">1012         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1013         return;</span>
<span class="line-added">1014     }</span>
<span class="line-added">1015     int32_t bFuture = direction == UDAT_DIRECTION_NEXT ? 1 : 0;</span>
<span class="line-added">1016 </span>
<span class="line-added">1017     StandardPlural::Form pluralForm;</span>
<span class="line-added">1018     QuantityFormatter::formatAndSelect(</span>
<span class="line-added">1019         offset,</span>
<span class="line-added">1020         **fNumberFormat,</span>
<span class="line-added">1021         **fPluralRules,</span>
<span class="line-added">1022         output.getStringRef(),</span>
<span class="line-added">1023         pluralForm,</span>
<span class="line-added">1024         status);</span>
<span class="line-added">1025     if (U_FAILURE(status)) {</span>
<span class="line-added">1026         return;</span>
<span class="line-added">1027     }</span>
<span class="line-added">1028 </span>
<span class="line-added">1029     const SimpleFormatter* formatter =</span>
<span class="line-added">1030         fCache-&gt;getRelativeDateTimeUnitFormatter(fStyle, unit, bFuture, pluralForm);</span>
<span class="line-added">1031     if (formatter == nullptr) {</span>
<span class="line-added">1032         // TODO: WARN - look at quantity formatter&#39;s action with an error.</span>
<span class="line-added">1033         status = U_INVALID_FORMAT_ERROR;</span>
<span class="line-added">1034         return;</span>
<span class="line-added">1035     }</span>
<span class="line-added">1036 </span>
<span class="line-added">1037     number::impl::SimpleModifier modifier(*formatter, kRDTLiteralField, false);</span>
<span class="line-added">1038     modifier.formatAsPrefixSuffix(</span>
<span class="line-added">1039         output.getStringRef(), 0, output.getStringRef().length(), status);</span>
1040 }
1041 
1042 UnicodeString&amp; RelativeDateTimeFormatter::format(
<a name="65" id="anc65"></a><span class="line-modified">1043         UDateDirection direction,</span>
<span class="line-modified">1044         UDateAbsoluteUnit unit,</span>
<span class="line-added">1045         UnicodeString&amp; appendTo,</span>
<span class="line-added">1046         UErrorCode&amp; status) const {</span>
<span class="line-added">1047     return doFormat(</span>
<span class="line-added">1048         &amp;RelativeDateTimeFormatter::formatAbsoluteImpl,</span>
<span class="line-added">1049         appendTo,</span>
<span class="line-added">1050         status,</span>
<span class="line-added">1051         direction,</span>
<span class="line-added">1052         unit);</span>
<span class="line-added">1053 }</span>
<span class="line-added">1054 </span>
<span class="line-added">1055 FormattedRelativeDateTime RelativeDateTimeFormatter::formatToValue(</span>
<span class="line-added">1056         UDateDirection direction,</span>
<span class="line-added">1057         UDateAbsoluteUnit unit,</span>
<span class="line-added">1058         UErrorCode&amp; status) const {</span>
<span class="line-added">1059     return doFormatToValue(</span>
<span class="line-added">1060         &amp;RelativeDateTimeFormatter::formatAbsoluteImpl,</span>
<span class="line-added">1061         status,</span>
<span class="line-added">1062         direction,</span>
<span class="line-added">1063         unit);</span>
<span class="line-added">1064 }</span>
<span class="line-added">1065 </span>
<span class="line-added">1066 void RelativeDateTimeFormatter::formatAbsoluteImpl(</span>
<span class="line-added">1067         UDateDirection direction,</span>
<span class="line-added">1068         UDateAbsoluteUnit unit,</span>
<span class="line-added">1069         FormattedRelativeDateTimeData&amp; output,</span>
<span class="line-added">1070         UErrorCode&amp; status) const {</span>
1071     if (U_FAILURE(status)) {
<a name="66" id="anc66"></a><span class="line-modified">1072         return;</span>
1073     }
1074     if (unit == UDAT_ABSOLUTE_NOW &amp;&amp; direction != UDAT_DIRECTION_PLAIN) {
1075         status = U_ILLEGAL_ARGUMENT_ERROR;
<a name="67" id="anc67"></a><span class="line-modified">1076         return;</span>
1077     }
1078 
1079     // Get string using fallback.
<a name="68" id="anc68"></a><span class="line-modified">1080     output.getStringRef().append(</span>
<span class="line-modified">1081         fCache-&gt;getAbsoluteUnitString(fStyle, unit, direction),</span>
<span class="line-modified">1082         kRDTLiteralField,</span>
<span class="line-modified">1083         status);</span>


1084 }
1085 
1086 UnicodeString&amp; RelativeDateTimeFormatter::format(
<a name="69" id="anc69"></a><span class="line-modified">1087         double offset,</span>
<span class="line-modified">1088         URelativeDateTimeUnit unit,</span>
<span class="line-added">1089         UnicodeString&amp; appendTo,</span>
<span class="line-added">1090         UErrorCode&amp; status) const {</span>
<span class="line-added">1091     return doFormat(</span>
<span class="line-added">1092         &amp;RelativeDateTimeFormatter::formatRelativeImpl,</span>
<span class="line-added">1093         appendTo,</span>
<span class="line-added">1094         status,</span>
<span class="line-added">1095         offset,</span>
<span class="line-added">1096         unit);</span>
<span class="line-added">1097 }</span>
<span class="line-added">1098 </span>
<span class="line-added">1099 FormattedRelativeDateTime RelativeDateTimeFormatter::formatToValue(</span>
<span class="line-added">1100         double offset,</span>
<span class="line-added">1101         URelativeDateTimeUnit unit,</span>
<span class="line-added">1102         UErrorCode&amp; status) const {</span>
<span class="line-added">1103     return doFormatToValue(</span>
<span class="line-added">1104         &amp;RelativeDateTimeFormatter::formatRelativeImpl,</span>
<span class="line-added">1105         status,</span>
<span class="line-added">1106         offset,</span>
<span class="line-added">1107         unit);</span>
<span class="line-added">1108 }</span>
<span class="line-added">1109 </span>
<span class="line-added">1110 void RelativeDateTimeFormatter::formatRelativeImpl(</span>
<span class="line-added">1111         double offset,</span>
<span class="line-added">1112         URelativeDateTimeUnit unit,</span>
<span class="line-added">1113         FormattedRelativeDateTimeData&amp; output,</span>
<span class="line-added">1114         UErrorCode&amp; status) const {</span>
1115     if (U_FAILURE(status)) {
<a name="70" id="anc70"></a><span class="line-modified">1116         return;</span>
1117     }
1118     // TODO:
1119     // The full implementation of this depends on CLDR data that is not yet available,
1120     // see: http://unicode.org/cldr/trac/ticket/9165 Add more relative field data.
1121     // In the meantime do a quick bring-up by calling the old format method; this
1122     // leaves some holes (even for data that is currently available, such as quarter).
1123     // When the new CLDR data is available, update the data storage accordingly,
1124     // rewrite this to use it directly, and rewrite the old format method to call this
1125     // new one; that is covered by http://bugs.icu-project.org/trac/ticket/12171.
1126     UDateDirection direction = UDAT_DIRECTION_COUNT;
1127     if (offset &gt; -2.1 &amp;&amp; offset &lt; 2.1) {
1128         // Allow a 1% epsilon, so offsets in -1.01..-0.99 map to LAST
1129         double offsetx100 = offset * 100.0;
1130         int32_t intoffset = (offsetx100 &lt; 0)? (int32_t)(offsetx100-0.5) : (int32_t)(offsetx100+0.5);
1131         switch (intoffset) {
1132             case -200/*-2*/: direction = UDAT_DIRECTION_LAST_2; break;
1133             case -100/*-1*/: direction = UDAT_DIRECTION_LAST; break;
1134             case    0/* 0*/: direction = UDAT_DIRECTION_THIS; break;
1135             case  100/* 1*/: direction = UDAT_DIRECTION_NEXT; break;
1136             case  200/* 2*/: direction = UDAT_DIRECTION_NEXT_2; break;
1137             default: break;
1138         }
1139     }
1140     UDateAbsoluteUnit absunit = UDAT_ABSOLUTE_UNIT_COUNT;
1141     switch (unit) {
1142         case UDAT_REL_UNIT_YEAR:    absunit = UDAT_ABSOLUTE_YEAR; break;
<a name="71" id="anc71"></a><span class="line-added">1143         case UDAT_REL_UNIT_QUARTER: absunit = UDAT_ABSOLUTE_QUARTER; break;</span>
1144         case UDAT_REL_UNIT_MONTH:   absunit = UDAT_ABSOLUTE_MONTH; break;
1145         case UDAT_REL_UNIT_WEEK:    absunit = UDAT_ABSOLUTE_WEEK; break;
1146         case UDAT_REL_UNIT_DAY:     absunit = UDAT_ABSOLUTE_DAY; break;
1147         case UDAT_REL_UNIT_SECOND:
1148             if (direction == UDAT_DIRECTION_THIS) {
1149                 absunit = UDAT_ABSOLUTE_NOW;
1150                 direction = UDAT_DIRECTION_PLAIN;
1151             }
1152             break;
1153         case UDAT_REL_UNIT_SUNDAY:  absunit = UDAT_ABSOLUTE_SUNDAY; break;
1154         case UDAT_REL_UNIT_MONDAY:  absunit = UDAT_ABSOLUTE_MONDAY; break;
1155         case UDAT_REL_UNIT_TUESDAY:  absunit = UDAT_ABSOLUTE_TUESDAY; break;
1156         case UDAT_REL_UNIT_WEDNESDAY:  absunit = UDAT_ABSOLUTE_WEDNESDAY; break;
1157         case UDAT_REL_UNIT_THURSDAY:  absunit = UDAT_ABSOLUTE_THURSDAY; break;
1158         case UDAT_REL_UNIT_FRIDAY:  absunit = UDAT_ABSOLUTE_FRIDAY; break;
1159         case UDAT_REL_UNIT_SATURDAY:  absunit = UDAT_ABSOLUTE_SATURDAY; break;
1160         default: break;
1161     }
1162     if (direction != UDAT_DIRECTION_COUNT &amp;&amp; absunit != UDAT_ABSOLUTE_UNIT_COUNT) {
<a name="72" id="anc72"></a><span class="line-modified">1163         formatAbsoluteImpl(direction, absunit, output, status);</span>
<span class="line-modified">1164         if (output.getStringRef().length() != 0) {</span>
<span class="line-modified">1165             return;</span>







1166         }
1167     }
1168     // otherwise fallback to formatNumeric
<a name="73" id="anc73"></a><span class="line-modified">1169     formatNumericImpl(offset, unit, output, status);</span>
1170 }
1171 
1172 UnicodeString&amp; RelativeDateTimeFormatter::combineDateAndTime(
1173         const UnicodeString&amp; relativeDateString, const UnicodeString&amp; timeString,
1174         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {
1175     return fCache-&gt;getCombinedDateAndTime()-&gt;format(
1176             timeString, relativeDateString, appendTo, status);
1177 }
1178 
<a name="74" id="anc74"></a><span class="line-modified">1179 UnicodeString&amp; RelativeDateTimeFormatter::adjustForContext(UnicodeString &amp;str) const {</span>
<span class="line-modified">1180     if (fOptBreakIterator == nullptr</span>
1181         || str.length() == 0 || !u_islower(str.char32At(0))) {
<a name="75" id="anc75"></a><span class="line-modified">1182         return str;</span>
1183     }
1184 
1185     // Must guarantee that one thread at a time accesses the shared break
1186     // iterator.
<a name="76" id="anc76"></a><span class="line-added">1187     static icu::UMutex gBrkIterMutex = U_MUTEX_INITIALIZER;</span>
1188     Mutex lock(&amp;gBrkIterMutex);
1189     str.toTitle(
1190             fOptBreakIterator-&gt;get(),
1191             fLocale,
1192             U_TITLECASE_NO_LOWERCASE | U_TITLECASE_NO_BREAK_ADJUSTMENT);
<a name="77" id="anc77"></a><span class="line-added">1193     return str;</span>
<span class="line-added">1194 }</span>
<span class="line-added">1195 </span>
<span class="line-added">1196 UBool RelativeDateTimeFormatter::checkNoAdjustForContext(UErrorCode&amp; status) const {</span>
<span class="line-added">1197     // This is unsupported because it&#39;s hard to keep fields in sync with title</span>
<span class="line-added">1198     // casing. The code could be written and tested if there is demand.</span>
<span class="line-added">1199     if (fOptBreakIterator != nullptr) {</span>
<span class="line-added">1200         status = U_UNSUPPORTED_ERROR;</span>
<span class="line-added">1201         return FALSE;</span>
<span class="line-added">1202     }</span>
<span class="line-added">1203     return TRUE;</span>
1204 }
1205 
1206 void RelativeDateTimeFormatter::init(
1207         NumberFormat *nfToAdopt,
1208         BreakIterator *biToAdopt,
1209         UErrorCode &amp;status) {
1210     LocalPointer&lt;NumberFormat&gt; nf(nfToAdopt);
1211     LocalPointer&lt;BreakIterator&gt; bi(biToAdopt);
1212     UnifiedCache::getByLocale(fLocale, fCache, status);
1213     if (U_FAILURE(status)) {
1214         return;
1215     }
1216     const SharedPluralRules *pr = PluralRules::createSharedInstance(
1217             fLocale, UPLURAL_TYPE_CARDINAL, status);
1218     if (U_FAILURE(status)) {
1219         return;
1220     }
1221     SharedObject::copyPtr(pr, fPluralRules);
1222     pr-&gt;removeRef();
1223     if (nf.isNull()) {
1224        const SharedNumberFormat *shared = NumberFormat::createSharedInstance(
1225                fLocale, UNUM_DECIMAL, status);
1226         if (U_FAILURE(status)) {
1227             return;
1228         }
1229         SharedObject::copyPtr(shared, fNumberFormat);
1230         shared-&gt;removeRef();
1231     } else {
1232         SharedNumberFormat *shared = new SharedNumberFormat(nf.getAlias());
<a name="78" id="anc78"></a><span class="line-modified">1233         if (shared == nullptr) {</span>
1234             status = U_MEMORY_ALLOCATION_ERROR;
1235             return;
1236         }
1237         nf.orphan();
1238         SharedObject::copyPtr(shared, fNumberFormat);
1239     }
1240     if (bi.isNull()) {
1241         SharedObject::clearPtr(fOptBreakIterator);
1242     } else {
1243         SharedBreakIterator *shared = new SharedBreakIterator(bi.getAlias());
<a name="79" id="anc79"></a><span class="line-modified">1244         if (shared == nullptr) {</span>
1245             status = U_MEMORY_ALLOCATION_ERROR;
1246             return;
1247         }
1248         bi.orphan();
1249         SharedObject::copyPtr(shared, fOptBreakIterator);
1250     }
1251 }
1252 
1253 U_NAMESPACE_END
1254 
1255 // Plain C API
1256 
1257 U_NAMESPACE_USE
1258 
<a name="80" id="anc80"></a><span class="line-added">1259 </span>
<span class="line-added">1260 // Magic number: &quot;FRDT&quot; (FormattedRelativeDateTime) in ASCII</span>
<span class="line-added">1261 UPRV_FORMATTED_VALUE_CAPI_AUTO_IMPL(</span>
<span class="line-added">1262     FormattedRelativeDateTime,</span>
<span class="line-added">1263     UFormattedRelativeDateTime,</span>
<span class="line-added">1264     UFormattedRelativeDateTimeImpl,</span>
<span class="line-added">1265     UFormattedRelativeDateTimeApiHelper,</span>
<span class="line-added">1266     ureldatefmt,</span>
<span class="line-added">1267     0x46524454)</span>
<span class="line-added">1268 </span>
<span class="line-added">1269 </span>
1270 U_CAPI URelativeDateTimeFormatter* U_EXPORT2
1271 ureldatefmt_open( const char*          locale,
1272                   UNumberFormat*       nfToAdopt,
1273                   UDateRelativeDateTimeFormatterStyle width,
1274                   UDisplayContext      capitalizationContext,
1275                   UErrorCode*          status )
1276 {
1277     if (U_FAILURE(*status)) {
<a name="81" id="anc81"></a><span class="line-modified">1278         return nullptr;</span>
1279     }
1280     LocalPointer&lt;RelativeDateTimeFormatter&gt; formatter(new RelativeDateTimeFormatter(Locale(locale),
1281                                                               (NumberFormat*)nfToAdopt, width,
1282                                                               capitalizationContext, *status), *status);
1283     if (U_FAILURE(*status)) {
<a name="82" id="anc82"></a><span class="line-modified">1284         return nullptr;</span>
1285     }
1286     return (URelativeDateTimeFormatter*)formatter.orphan();
1287 }
1288 
1289 U_CAPI void U_EXPORT2
1290 ureldatefmt_close(URelativeDateTimeFormatter *reldatefmt)
1291 {
1292     delete (RelativeDateTimeFormatter*)reldatefmt;
1293 }
1294 
1295 U_CAPI int32_t U_EXPORT2
1296 ureldatefmt_formatNumeric( const URelativeDateTimeFormatter* reldatefmt,
1297                     double                offset,
1298                     URelativeDateTimeUnit unit,
1299                     UChar*                result,
1300                     int32_t               resultCapacity,
1301                     UErrorCode*           status)
1302 {
1303     if (U_FAILURE(*status)) {
1304         return 0;
1305     }
<a name="83" id="anc83"></a><span class="line-modified">1306     if (result == nullptr ? resultCapacity != 0 : resultCapacity &lt; 0) {</span>
1307         *status = U_ILLEGAL_ARGUMENT_ERROR;
1308         return 0;
1309     }
1310     UnicodeString res;
<a name="84" id="anc84"></a><span class="line-modified">1311     if (result != nullptr) {</span>
<span class="line-modified">1312         // nullptr destination for pure preflighting: empty dummy string</span>
1313         // otherwise, alias the destination buffer (copied from udat_format)
1314         res.setTo(result, 0, resultCapacity);
1315     }
1316     ((RelativeDateTimeFormatter*)reldatefmt)-&gt;formatNumeric(offset, unit, res, *status);
1317     if (U_FAILURE(*status)) {
1318         return 0;
1319     }
1320     return res.extract(result, resultCapacity, *status);
1321 }
1322 
<a name="85" id="anc85"></a><span class="line-added">1323 U_STABLE void U_EXPORT2</span>
<span class="line-added">1324 ureldatefmt_formatNumericToResult(</span>
<span class="line-added">1325         const URelativeDateTimeFormatter* reldatefmt,</span>
<span class="line-added">1326         double                            offset,</span>
<span class="line-added">1327         URelativeDateTimeUnit             unit,</span>
<span class="line-added">1328         UFormattedRelativeDateTime*       result,</span>
<span class="line-added">1329         UErrorCode*                       status) {</span>
<span class="line-added">1330     if (U_FAILURE(*status)) {</span>
<span class="line-added">1331         return;</span>
<span class="line-added">1332     }</span>
<span class="line-added">1333     auto* fmt = reinterpret_cast&lt;const RelativeDateTimeFormatter*&gt;(reldatefmt);</span>
<span class="line-added">1334     auto* resultImpl = UFormattedRelativeDateTimeApiHelper::validate(result, *status);</span>
<span class="line-added">1335     resultImpl-&gt;fImpl = fmt-&gt;formatNumericToValue(offset, unit, *status);</span>
<span class="line-added">1336 }</span>
<span class="line-added">1337 </span>
1338 U_CAPI int32_t U_EXPORT2
1339 ureldatefmt_format( const URelativeDateTimeFormatter* reldatefmt,
1340                     double                offset,
1341                     URelativeDateTimeUnit unit,
1342                     UChar*                result,
1343                     int32_t               resultCapacity,
1344                     UErrorCode*           status)
1345 {
1346     if (U_FAILURE(*status)) {
1347         return 0;
1348     }
<a name="86" id="anc86"></a><span class="line-modified">1349     if (result == nullptr ? resultCapacity != 0 : resultCapacity &lt; 0) {</span>
1350         *status = U_ILLEGAL_ARGUMENT_ERROR;
1351         return 0;
1352     }
1353     UnicodeString res;
<a name="87" id="anc87"></a><span class="line-modified">1354     if (result != nullptr) {</span>
<span class="line-modified">1355         // nullptr destination for pure preflighting: empty dummy string</span>
1356         // otherwise, alias the destination buffer (copied from udat_format)
1357         res.setTo(result, 0, resultCapacity);
1358     }
1359     ((RelativeDateTimeFormatter*)reldatefmt)-&gt;format(offset, unit, res, *status);
1360     if (U_FAILURE(*status)) {
1361         return 0;
1362     }
1363     return res.extract(result, resultCapacity, *status);
1364 }
1365 
<a name="88" id="anc88"></a><span class="line-added">1366 U_DRAFT void U_EXPORT2</span>
<span class="line-added">1367 ureldatefmt_formatToResult(</span>
<span class="line-added">1368         const URelativeDateTimeFormatter* reldatefmt,</span>
<span class="line-added">1369         double                            offset,</span>
<span class="line-added">1370         URelativeDateTimeUnit             unit,</span>
<span class="line-added">1371         UFormattedRelativeDateTime*       result,</span>
<span class="line-added">1372         UErrorCode*                       status) {</span>
<span class="line-added">1373     if (U_FAILURE(*status)) {</span>
<span class="line-added">1374         return;</span>
<span class="line-added">1375     }</span>
<span class="line-added">1376     auto* fmt = reinterpret_cast&lt;const RelativeDateTimeFormatter*&gt;(reldatefmt);</span>
<span class="line-added">1377     auto* resultImpl = UFormattedRelativeDateTimeApiHelper::validate(result, *status);</span>
<span class="line-added">1378     resultImpl-&gt;fImpl = fmt-&gt;formatToValue(offset, unit, *status);</span>
<span class="line-added">1379 }</span>
<span class="line-added">1380 </span>
1381 U_CAPI int32_t U_EXPORT2
1382 ureldatefmt_combineDateAndTime( const URelativeDateTimeFormatter* reldatefmt,
1383                     const UChar *     relativeDateString,
1384                     int32_t           relativeDateStringLen,
1385                     const UChar *     timeString,
1386                     int32_t           timeStringLen,
1387                     UChar*            result,
1388                     int32_t           resultCapacity,
1389                     UErrorCode*       status )
1390 {
1391     if (U_FAILURE(*status)) {
1392         return 0;
1393     }
<a name="89" id="anc89"></a><span class="line-modified">1394     if (result == nullptr ? resultCapacity != 0 : resultCapacity &lt; 0 ||</span>
<span class="line-modified">1395             (relativeDateString == nullptr ? relativeDateStringLen != 0 : relativeDateStringLen &lt; -1) ||</span>
<span class="line-modified">1396             (timeString == nullptr ? timeStringLen != 0 : timeStringLen &lt; -1)) {</span>
1397         *status = U_ILLEGAL_ARGUMENT_ERROR;
1398         return 0;
1399     }
1400     UnicodeString relDateStr((UBool)(relativeDateStringLen == -1), relativeDateString, relativeDateStringLen);
1401     UnicodeString timeStr((UBool)(timeStringLen == -1), timeString, timeStringLen);
1402     UnicodeString res(result, 0, resultCapacity);
1403     ((RelativeDateTimeFormatter*)reldatefmt)-&gt;combineDateAndTime(relDateStr, timeStr, res, *status);
1404     if (U_FAILURE(*status)) {
1405         return 0;
1406     }
1407     return res.extract(result, resultCapacity, *status);
1408 }
1409 
1410 #endif /* !UCONFIG_NO_FORMATTING */
<a name="90" id="anc90"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="90" type="hidden" />
</body>
</html>