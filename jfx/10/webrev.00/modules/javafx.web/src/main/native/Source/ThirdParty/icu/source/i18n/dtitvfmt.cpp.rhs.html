<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtitvfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*******************************************************************************
   4 * Copyright (C) 2008-2016, International Business Machines Corporation and
   5 * others. All Rights Reserved.
   6 *******************************************************************************
   7 *
   8 * File DTITVFMT.CPP
   9 *
  10 *******************************************************************************
  11 */
  12 
  13 #include &quot;utypeinfo.h&quot;  // for &#39;typeid&#39; to work
  14 
  15 #include &quot;unicode/dtitvfmt.h&quot;
  16 
  17 #if !UCONFIG_NO_FORMATTING
  18 
  19 //TODO: put in compilation
  20 //#define DTITVFMT_DEBUG 1
  21 
  22 #include &quot;unicode/calendar.h&quot;
  23 #include &quot;unicode/dtptngen.h&quot;
  24 #include &quot;unicode/dtitvinf.h&quot;
  25 #include &quot;unicode/simpleformatter.h&quot;
  26 #include &quot;cmemory.h&quot;
  27 #include &quot;cstring.h&quot;
  28 #include &quot;dtitv_impl.h&quot;
  29 #include &quot;mutex.h&quot;
  30 #include &quot;uresimp.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  31 #include &quot;formattedval_impl.h&quot;</span>
  32 
  33 #ifdef DTITVFMT_DEBUG
  34 #include &lt;iostream&gt;
  35 #endif
  36 
  37 U_NAMESPACE_BEGIN
  38 
  39 
  40 
  41 #ifdef DTITVFMT_DEBUG
  42 #define PRINTMESG(msg) { std::cout &lt;&lt; &quot;(&quot; &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;) &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;; }
  43 #endif
  44 
  45 
  46 static const UChar gDateFormatSkeleton[][11] = {
  47 //yMMMMEEEEd
  48 {LOW_Y, CAP_M, CAP_M, CAP_M, CAP_M, CAP_E, CAP_E, CAP_E, CAP_E, LOW_D, 0},
  49 //yMMMMd
  50 {LOW_Y, CAP_M, CAP_M, CAP_M, CAP_M, LOW_D, 0},
  51 //yMMMd
  52 {LOW_Y, CAP_M, CAP_M, CAP_M, LOW_D, 0},
  53 //yMd
  54 {LOW_Y, CAP_M, LOW_D, 0} };
  55 
  56 
  57 static const char gCalendarTag[] = &quot;calendar&quot;;
  58 static const char gGregorianTag[] = &quot;gregorian&quot;;
  59 static const char gDateTimePatternsTag[] = &quot;DateTimePatterns&quot;;
  60 
  61 
  62 // latestFirst:
  63 static const UChar gLaterFirstPrefix[] = {LOW_L, LOW_A, LOW_T, LOW_E, LOW_S,LOW_T, CAP_F, LOW_I, LOW_R, LOW_S, LOW_T, COLON};
  64 
  65 // earliestFirst:
  66 static const UChar gEarlierFirstPrefix[] = {LOW_E, LOW_A, LOW_R, LOW_L, LOW_I, LOW_E, LOW_S, LOW_T, CAP_F, LOW_I, LOW_R, LOW_S, LOW_T, COLON};
  67 
  68 
<a name="2" id="anc2"></a><span class="line-added">  69 class FormattedDateIntervalData : public FormattedValueFieldPositionIteratorImpl {</span>
<span class="line-added">  70 public:</span>
<span class="line-added">  71     FormattedDateIntervalData(UErrorCode&amp; status) : FormattedValueFieldPositionIteratorImpl(5, status) {}</span>
<span class="line-added">  72     virtual ~FormattedDateIntervalData();</span>
<span class="line-added">  73 };</span>
<span class="line-added">  74 </span>
<span class="line-added">  75 FormattedDateIntervalData::~FormattedDateIntervalData() = default;</span>
<span class="line-added">  76 </span>
<span class="line-added">  77 UPRV_FORMATTED_VALUE_SUBCLASS_AUTO_IMPL(FormattedDateInterval)</span>
<span class="line-added">  78 </span>
<span class="line-added">  79 </span>
  80 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DateIntervalFormat)
  81 
  82 // Mutex, protects access to fDateFormat, fFromCalendar and fToCalendar.
  83 //        Needed because these data members are modified by const methods of DateIntervalFormat.
  84 
<a name="3" id="anc3"></a><span class="line-modified">  85 static UMutex *gFormatterMutex() {</span>
<span class="line-added">  86     static UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added">  87     return &amp;m;</span>
<span class="line-added">  88 }</span>
  89 
  90 DateIntervalFormat* U_EXPORT2
  91 DateIntervalFormat::createInstance(const UnicodeString&amp; skeleton,
  92                                    UErrorCode&amp; status) {
  93     return createInstance(skeleton, Locale::getDefault(), status);
  94 }
  95 
  96 
  97 DateIntervalFormat* U_EXPORT2
  98 DateIntervalFormat::createInstance(const UnicodeString&amp; skeleton,
  99                                    const Locale&amp; locale,
 100                                    UErrorCode&amp; status) {
 101 #ifdef DTITVFMT_DEBUG
 102     char result[1000];
 103     char result_1[1000];
 104     char mesg[2000];
 105     skeleton.extract(0,  skeleton.length(), result, &quot;UTF-8&quot;);
 106     UnicodeString pat;
 107     ((SimpleDateFormat*)dtfmt)-&gt;toPattern(pat);
 108     pat.extract(0,  pat.length(), result_1, &quot;UTF-8&quot;);
 109     sprintf(mesg, &quot;skeleton: %s; pattern: %s\n&quot;, result, result_1);
 110     PRINTMESG(mesg)
 111 #endif
 112 
 113     DateIntervalInfo* dtitvinf = new DateIntervalInfo(locale, status);
 114     return create(locale, dtitvinf, &amp;skeleton, status);
 115 }
 116 
 117 
 118 
 119 DateIntervalFormat* U_EXPORT2
 120 DateIntervalFormat::createInstance(const UnicodeString&amp; skeleton,
 121                                    const DateIntervalInfo&amp; dtitvinf,
 122                                    UErrorCode&amp; status) {
 123     return createInstance(skeleton, Locale::getDefault(), dtitvinf, status);
 124 }
 125 
 126 
 127 DateIntervalFormat* U_EXPORT2
 128 DateIntervalFormat::createInstance(const UnicodeString&amp; skeleton,
 129                                    const Locale&amp; locale,
 130                                    const DateIntervalInfo&amp; dtitvinf,
 131                                    UErrorCode&amp; status) {
 132     DateIntervalInfo* ptn = dtitvinf.clone();
 133     return create(locale, ptn, &amp;skeleton, status);
 134 }
 135 
 136 
 137 DateIntervalFormat::DateIntervalFormat()
 138 :   fInfo(NULL),
 139     fDateFormat(NULL),
 140     fFromCalendar(NULL),
 141     fToCalendar(NULL),
 142     fLocale(Locale::getRoot()),
 143     fDatePattern(NULL),
 144     fTimePattern(NULL),
 145     fDateTimeFormat(NULL)
 146 {}
 147 
 148 
 149 DateIntervalFormat::DateIntervalFormat(const DateIntervalFormat&amp; itvfmt)
 150 :   Format(itvfmt),
 151     fInfo(NULL),
 152     fDateFormat(NULL),
 153     fFromCalendar(NULL),
 154     fToCalendar(NULL),
 155     fLocale(itvfmt.fLocale),
 156     fDatePattern(NULL),
 157     fTimePattern(NULL),
 158     fDateTimeFormat(NULL) {
 159     *this = itvfmt;
 160 }
 161 
 162 
 163 DateIntervalFormat&amp;
 164 DateIntervalFormat::operator=(const DateIntervalFormat&amp; itvfmt) {
 165     if ( this != &amp;itvfmt ) {
 166         delete fDateFormat;
 167         delete fInfo;
 168         delete fFromCalendar;
 169         delete fToCalendar;
 170         delete fDatePattern;
 171         delete fTimePattern;
 172         delete fDateTimeFormat;
 173         {
<a name="4" id="anc4"></a><span class="line-modified"> 174             Mutex lock(gFormatterMutex());</span>
 175             if ( itvfmt.fDateFormat ) {
 176                 fDateFormat = (SimpleDateFormat*)itvfmt.fDateFormat-&gt;clone();
 177             } else {
 178                 fDateFormat = NULL;
 179             }
 180             if ( itvfmt.fFromCalendar ) {
 181                 fFromCalendar = itvfmt.fFromCalendar-&gt;clone();
 182             } else {
 183                 fFromCalendar = NULL;
 184             }
 185             if ( itvfmt.fToCalendar ) {
 186                 fToCalendar = itvfmt.fToCalendar-&gt;clone();
 187             } else {
 188                 fToCalendar = NULL;
 189             }
 190         }
 191         if ( itvfmt.fInfo ) {
 192             fInfo = itvfmt.fInfo-&gt;clone();
 193         } else {
 194             fInfo = NULL;
 195         }
 196         fSkeleton = itvfmt.fSkeleton;
 197         int8_t i;
 198         for ( i = 0; i&lt; DateIntervalInfo::kIPI_MAX_INDEX; ++i ) {
 199             fIntervalPatterns[i] = itvfmt.fIntervalPatterns[i];
 200         }
 201         fLocale = itvfmt.fLocale;
 202         fDatePattern    = (itvfmt.fDatePattern)?    (UnicodeString*)itvfmt.fDatePattern-&gt;clone(): NULL;
 203         fTimePattern    = (itvfmt.fTimePattern)?    (UnicodeString*)itvfmt.fTimePattern-&gt;clone(): NULL;
 204         fDateTimeFormat = (itvfmt.fDateTimeFormat)? (UnicodeString*)itvfmt.fDateTimeFormat-&gt;clone(): NULL;
 205     }
 206     return *this;
 207 }
 208 
 209 
 210 DateIntervalFormat::~DateIntervalFormat() {
 211     delete fInfo;
 212     delete fDateFormat;
 213     delete fFromCalendar;
 214     delete fToCalendar;
 215     delete fDatePattern;
 216     delete fTimePattern;
 217     delete fDateTimeFormat;
 218 }
 219 
 220 
 221 Format*
 222 DateIntervalFormat::clone(void) const {
 223     return new DateIntervalFormat(*this);
 224 }
 225 
 226 
 227 UBool
 228 DateIntervalFormat::operator==(const Format&amp; other) const {
 229     if (typeid(*this) != typeid(other)) {return FALSE;}
 230     const DateIntervalFormat* fmt = (DateIntervalFormat*)&amp;other;
 231     if (this == fmt) {return TRUE;}
 232     if (!Format::operator==(other)) {return FALSE;}
 233     if ((fInfo != fmt-&gt;fInfo) &amp;&amp; (fInfo == NULL || fmt-&gt;fInfo == NULL)) {return FALSE;}
 234     if (fInfo &amp;&amp; fmt-&gt;fInfo &amp;&amp; (*fInfo != *fmt-&gt;fInfo )) {return FALSE;}
 235     {
<a name="5" id="anc5"></a><span class="line-modified"> 236         Mutex lock(gFormatterMutex());</span>
 237         if (fDateFormat != fmt-&gt;fDateFormat &amp;&amp; (fDateFormat == NULL || fmt-&gt;fDateFormat == NULL)) {return FALSE;}
 238         if (fDateFormat &amp;&amp; fmt-&gt;fDateFormat &amp;&amp; (*fDateFormat != *fmt-&gt;fDateFormat)) {return FALSE;}
 239     }
 240     // note: fFromCalendar and fToCalendar hold no persistent state, and therefore do not participate in operator ==.
 241     //       fDateFormat has the master calendar for the DateIntervalFormat.
 242     if (fSkeleton != fmt-&gt;fSkeleton) {return FALSE;}
 243     if (fDatePattern != fmt-&gt;fDatePattern &amp;&amp; (fDatePattern == NULL || fmt-&gt;fDatePattern == NULL)) {return FALSE;}
 244     if (fDatePattern &amp;&amp; fmt-&gt;fDatePattern &amp;&amp; (*fDatePattern != *fmt-&gt;fDatePattern)) {return FALSE;}
 245     if (fTimePattern != fmt-&gt;fTimePattern &amp;&amp; (fTimePattern == NULL || fmt-&gt;fTimePattern == NULL)) {return FALSE;}
 246     if (fTimePattern &amp;&amp; fmt-&gt;fTimePattern &amp;&amp; (*fTimePattern != *fmt-&gt;fTimePattern)) {return FALSE;}
 247     if (fDateTimeFormat != fmt-&gt;fDateTimeFormat &amp;&amp; (fDateTimeFormat == NULL || fmt-&gt;fDateTimeFormat == NULL)) {return FALSE;}
 248     if (fDateTimeFormat &amp;&amp; fmt-&gt;fDateTimeFormat &amp;&amp; (*fDateTimeFormat != *fmt-&gt;fDateTimeFormat)) {return FALSE;}
 249     if (fLocale != fmt-&gt;fLocale) {return FALSE;}
 250 
 251     for (int32_t i = 0; i&lt; DateIntervalInfo::kIPI_MAX_INDEX; ++i ) {
 252         if (fIntervalPatterns[i].firstPart != fmt-&gt;fIntervalPatterns[i].firstPart) {return FALSE;}
 253         if (fIntervalPatterns[i].secondPart != fmt-&gt;fIntervalPatterns[i].secondPart ) {return FALSE;}
 254         if (fIntervalPatterns[i].laterDateFirst != fmt-&gt;fIntervalPatterns[i].laterDateFirst) {return FALSE;}
 255     }
 256     return TRUE;
 257 }
 258 
 259 
 260 UnicodeString&amp;
 261 DateIntervalFormat::format(const Formattable&amp; obj,
 262                            UnicodeString&amp; appendTo,
 263                            FieldPosition&amp; fieldPosition,
 264                            UErrorCode&amp; status) const {
 265     if ( U_FAILURE(status) ) {
 266         return appendTo;
 267     }
 268 
 269     if ( obj.getType() == Formattable::kObject ) {
 270         const UObject* formatObj = obj.getObject();
 271         const DateInterval* interval = dynamic_cast&lt;const DateInterval*&gt;(formatObj);
 272         if (interval != NULL) {
 273             return format(interval, appendTo, fieldPosition, status);
 274         }
 275     }
 276     status = U_ILLEGAL_ARGUMENT_ERROR;
 277     return appendTo;
 278 }
 279 
 280 
 281 UnicodeString&amp;
 282 DateIntervalFormat::format(const DateInterval* dtInterval,
 283                            UnicodeString&amp; appendTo,
 284                            FieldPosition&amp; fieldPosition,
 285                            UErrorCode&amp; status) const {
 286     if ( U_FAILURE(status) ) {
 287         return appendTo;
 288     }
<a name="6" id="anc6"></a><span class="line-modified"> 289     if (fDateFormat == NULL || fInfo == NULL) {</span>
 290         status = U_INVALID_STATE_ERROR;
 291         return appendTo;
 292     }
 293 
<a name="7" id="anc7"></a><span class="line-modified"> 294     FieldPositionOnlyHandler handler(fieldPosition);</span>
<span class="line-modified"> 295     handler.setAcceptFirstOnly(TRUE);</span>
<span class="line-modified"> 296     int8_t ignore;</span>
<span class="line-modified"> 297 </span>
<span class="line-added"> 298     Mutex lock(gFormatterMutex());</span>
<span class="line-added"> 299     return formatIntervalImpl(*dtInterval, appendTo, ignore, handler, status);</span>
<span class="line-added"> 300 }</span>
<span class="line-added"> 301 </span>
<span class="line-added"> 302 </span>
<span class="line-added"> 303 FormattedDateInterval DateIntervalFormat::formatToValue(</span>
<span class="line-added"> 304         const DateInterval&amp; dtInterval,</span>
<span class="line-added"> 305         UErrorCode&amp; status) const {</span>
<span class="line-added"> 306     LocalPointer&lt;FormattedDateIntervalData&gt; result(new FormattedDateIntervalData(status), status);</span>
<span class="line-added"> 307     if (U_FAILURE(status)) {</span>
<span class="line-added"> 308         return FormattedDateInterval(status);</span>
<span class="line-added"> 309     }</span>
<span class="line-added"> 310     UnicodeString string;</span>
<span class="line-added"> 311     int8_t firstIndex;</span>
<span class="line-added"> 312     auto handler = result-&gt;getHandler(status);</span>
<span class="line-added"> 313     handler.setCategory(UFIELD_CATEGORY_DATE);</span>
<span class="line-added"> 314     {</span>
<span class="line-added"> 315         Mutex lock(gFormatterMutex());</span>
<span class="line-added"> 316         formatIntervalImpl(dtInterval, string, firstIndex, handler, status);</span>
<span class="line-added"> 317     }</span>
<span class="line-added"> 318     handler.getError(status);</span>
<span class="line-added"> 319     result-&gt;appendString(string, status);</span>
<span class="line-added"> 320     if (U_FAILURE(status)) {</span>
<span class="line-added"> 321         return FormattedDateInterval(status);</span>
<span class="line-added"> 322     }</span>
<span class="line-added"> 323 </span>
<span class="line-added"> 324     // Compute the span fields and sort them into place:</span>
<span class="line-added"> 325     if (firstIndex != -1) {</span>
<span class="line-added"> 326         result-&gt;addOverlapSpans(UFIELD_CATEGORY_DATE_INTERVAL_SPAN, firstIndex, status);</span>
<span class="line-added"> 327         if (U_FAILURE(status)) {</span>
<span class="line-added"> 328             return FormattedDateInterval(status);</span>
<span class="line-added"> 329         }</span>
<span class="line-added"> 330         result-&gt;sort();</span>
<span class="line-added"> 331     }</span>
<span class="line-added"> 332 </span>
<span class="line-added"> 333     return FormattedDateInterval(result.orphan());</span>
 334 }
 335 
 336 
 337 UnicodeString&amp;
 338 DateIntervalFormat::format(Calendar&amp; fromCalendar,
 339                            Calendar&amp; toCalendar,
 340                            UnicodeString&amp; appendTo,
 341                            FieldPosition&amp; pos,
 342                            UErrorCode&amp; status) const {
<a name="8" id="anc8"></a><span class="line-modified"> 343     FieldPositionOnlyHandler handler(pos);</span>
<span class="line-modified"> 344     handler.setAcceptFirstOnly(TRUE);</span>
<span class="line-added"> 345     int8_t ignore;</span>
<span class="line-added"> 346 </span>
<span class="line-added"> 347     Mutex lock(gFormatterMutex());</span>
<span class="line-added"> 348     return formatImpl(fromCalendar, toCalendar, appendTo, ignore, handler, status);</span>
<span class="line-added"> 349 }</span>
<span class="line-added"> 350 </span>
<span class="line-added"> 351 </span>
<span class="line-added"> 352 FormattedDateInterval DateIntervalFormat::formatToValue(</span>
<span class="line-added"> 353         Calendar&amp; fromCalendar,</span>
<span class="line-added"> 354         Calendar&amp; toCalendar,</span>
<span class="line-added"> 355         UErrorCode&amp; status) const {</span>
<span class="line-added"> 356     LocalPointer&lt;FormattedDateIntervalData&gt; result(new FormattedDateIntervalData(status), status);</span>
<span class="line-added"> 357     if (U_FAILURE(status)) {</span>
<span class="line-added"> 358         return FormattedDateInterval(status);</span>
<span class="line-added"> 359     }</span>
<span class="line-added"> 360     UnicodeString string;</span>
<span class="line-added"> 361     int8_t firstIndex;</span>
<span class="line-added"> 362     auto handler = result-&gt;getHandler(status);</span>
<span class="line-added"> 363     handler.setCategory(UFIELD_CATEGORY_DATE);</span>
<span class="line-added"> 364     {</span>
<span class="line-added"> 365         Mutex lock(gFormatterMutex());</span>
<span class="line-added"> 366         formatImpl(fromCalendar, toCalendar, string, firstIndex, handler, status);</span>
<span class="line-added"> 367     }</span>
<span class="line-added"> 368     handler.getError(status);</span>
<span class="line-added"> 369     result-&gt;appendString(string, status);</span>
<span class="line-added"> 370     if (U_FAILURE(status)) {</span>
<span class="line-added"> 371         return FormattedDateInterval(status);</span>
<span class="line-added"> 372     }</span>
<span class="line-added"> 373 </span>
<span class="line-added"> 374     // Compute the span fields and sort them into place:</span>
<span class="line-added"> 375     if (firstIndex != -1) {</span>
<span class="line-added"> 376         result-&gt;addOverlapSpans(UFIELD_CATEGORY_DATE_INTERVAL_SPAN, firstIndex, status);</span>
<span class="line-added"> 377         result-&gt;sort();</span>
<span class="line-added"> 378     }</span>
<span class="line-added"> 379 </span>
<span class="line-added"> 380     return FormattedDateInterval(result.orphan());</span>
<span class="line-added"> 381 }</span>
<span class="line-added"> 382 </span>
<span class="line-added"> 383 </span>
<span class="line-added"> 384 UnicodeString&amp; DateIntervalFormat::formatIntervalImpl(</span>
<span class="line-added"> 385         const DateInterval&amp; dtInterval,</span>
<span class="line-added"> 386         UnicodeString&amp; appendTo,</span>
<span class="line-added"> 387         int8_t&amp; firstIndex,</span>
<span class="line-added"> 388         FieldPositionHandler&amp; fphandler,</span>
<span class="line-added"> 389         UErrorCode&amp; status) const {</span>
<span class="line-added"> 390     if (U_FAILURE(status)) {</span>
<span class="line-added"> 391         return appendTo;</span>
<span class="line-added"> 392     }</span>
<span class="line-added"> 393     if (fFromCalendar == nullptr || fToCalendar == nullptr) {</span>
<span class="line-added"> 394         status = U_INVALID_STATE_ERROR;</span>
<span class="line-added"> 395         return appendTo;</span>
<span class="line-added"> 396     }</span>
<span class="line-added"> 397     fFromCalendar-&gt;setTime(dtInterval.getFromDate(), status);</span>
<span class="line-added"> 398     fToCalendar-&gt;setTime(dtInterval.getToDate(), status);</span>
<span class="line-added"> 399     return formatImpl(*fFromCalendar, *fToCalendar, appendTo, firstIndex, fphandler, status);</span>
 400 }
 401 
 402 
 403 UnicodeString&amp;
 404 DateIntervalFormat::formatImpl(Calendar&amp; fromCalendar,
 405                            Calendar&amp; toCalendar,
 406                            UnicodeString&amp; appendTo,
<a name="9" id="anc9"></a><span class="line-modified"> 407                            int8_t&amp; firstIndex,</span>
<span class="line-added"> 408                            FieldPositionHandler&amp; fphandler,</span>
 409                            UErrorCode&amp; status) const {
 410     if ( U_FAILURE(status) ) {
 411         return appendTo;
 412     }
 413 
<a name="10" id="anc10"></a><span class="line-added"> 414     // Initialize firstIndex to -1 (single date, no range)</span>
<span class="line-added"> 415     firstIndex = -1;</span>
<span class="line-added"> 416 </span>
 417     // not support different calendar types and time zones
 418     //if ( fromCalendar.getType() != toCalendar.getType() ) {
 419     if ( !fromCalendar.isEquivalentTo(toCalendar) ) {
 420         status = U_ILLEGAL_ARGUMENT_ERROR;
 421         return appendTo;
 422     }
 423 
 424     // First, find the largest different calendar field.
 425     UCalendarDateFields field = UCAL_FIELD_COUNT;
 426 
 427     if ( fromCalendar.get(UCAL_ERA,status) != toCalendar.get(UCAL_ERA,status)) {
 428         field = UCAL_ERA;
 429     } else if ( fromCalendar.get(UCAL_YEAR, status) !=
 430                 toCalendar.get(UCAL_YEAR, status) ) {
 431         field = UCAL_YEAR;
 432     } else if ( fromCalendar.get(UCAL_MONTH, status) !=
 433                 toCalendar.get(UCAL_MONTH, status) ) {
 434         field = UCAL_MONTH;
 435     } else if ( fromCalendar.get(UCAL_DATE, status) !=
 436                 toCalendar.get(UCAL_DATE, status) ) {
 437         field = UCAL_DATE;
 438     } else if ( fromCalendar.get(UCAL_AM_PM, status) !=
 439                 toCalendar.get(UCAL_AM_PM, status) ) {
 440         field = UCAL_AM_PM;
 441     } else if ( fromCalendar.get(UCAL_HOUR, status) !=
 442                 toCalendar.get(UCAL_HOUR, status) ) {
 443         field = UCAL_HOUR;
 444     } else if ( fromCalendar.get(UCAL_MINUTE, status) !=
 445                 toCalendar.get(UCAL_MINUTE, status) ) {
 446         field = UCAL_MINUTE;
 447     } else if ( fromCalendar.get(UCAL_SECOND, status) !=
 448                 toCalendar.get(UCAL_SECOND, status) ) {
 449         field = UCAL_SECOND;
 450     }
 451 
 452     if ( U_FAILURE(status) ) {
 453         return appendTo;
 454     }
 455     if ( field == UCAL_FIELD_COUNT ) {
 456         /* ignore the millisecond etc. small fields&#39; difference.
 457          * use single date when all the above are the same.
 458          */
<a name="11" id="anc11"></a><span class="line-modified"> 459         return fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
 460     }
 461     UBool fromToOnSameDay = (field==UCAL_AM_PM || field==UCAL_HOUR || field==UCAL_MINUTE || field==UCAL_SECOND);
 462 
 463     // following call should not set wrong status,
 464     // all the pass-in fields are valid till here
 465     int32_t itvPtnIndex = DateIntervalInfo::calendarFieldToIntervalIndex(field,
 466                                                                         status);
 467     const PatternInfo&amp; intervalPattern = fIntervalPatterns[itvPtnIndex];
 468 
 469     if ( intervalPattern.firstPart.isEmpty() &amp;&amp;
 470          intervalPattern.secondPart.isEmpty() ) {
 471         if ( fDateFormat-&gt;isFieldUnitIgnored(field) ) {
 472             /* the largest different calendar field is small than
 473              * the smallest calendar field in pattern,
 474              * return single date format.
 475              */
<a name="12" id="anc12"></a><span class="line-modified"> 476             return fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
 477         }
<a name="13" id="anc13"></a><span class="line-modified"> 478         return fallbackFormat(fromCalendar, toCalendar, fromToOnSameDay, appendTo, firstIndex, fphandler, status);</span>
 479     }
 480     // If the first part in interval pattern is empty,
 481     // the 2nd part of it saves the full-pattern used in fall-back.
 482     // For a &#39;real&#39; interval pattern, the first part will never be empty.
 483     if ( intervalPattern.firstPart.isEmpty() ) {
 484         // fall back
 485         UnicodeString originalPattern;
 486         fDateFormat-&gt;toPattern(originalPattern);
 487         fDateFormat-&gt;applyPattern(intervalPattern.secondPart);
<a name="14" id="anc14"></a><span class="line-modified"> 488         appendTo = fallbackFormat(fromCalendar, toCalendar, fromToOnSameDay, appendTo, firstIndex, fphandler, status);</span>
 489         fDateFormat-&gt;applyPattern(originalPattern);
 490         return appendTo;
 491     }
 492     Calendar* firstCal;
 493     Calendar* secondCal;
 494     if ( intervalPattern.laterDateFirst ) {
 495         firstCal = &amp;toCalendar;
 496         secondCal = &amp;fromCalendar;
<a name="15" id="anc15"></a><span class="line-added"> 497         firstIndex = 1;</span>
 498     } else {
 499         firstCal = &amp;fromCalendar;
 500         secondCal = &amp;toCalendar;
<a name="16" id="anc16"></a><span class="line-added"> 501         firstIndex = 0;</span>
 502     }
 503     // break the interval pattern into 2 parts,
 504     // first part should not be empty,
 505     UnicodeString originalPattern;
 506     fDateFormat-&gt;toPattern(originalPattern);
 507     fDateFormat-&gt;applyPattern(intervalPattern.firstPart);
<a name="17" id="anc17"></a><span class="line-modified"> 508     fDateFormat-&gt;_format(*firstCal, appendTo, fphandler, status);</span>
<span class="line-added"> 509 </span>
 510     if ( !intervalPattern.secondPart.isEmpty() ) {
 511         fDateFormat-&gt;applyPattern(intervalPattern.secondPart);
<a name="18" id="anc18"></a><span class="line-modified"> 512         fDateFormat-&gt;_format(*secondCal, appendTo, fphandler, status);</span>





 513     }
 514     fDateFormat-&gt;applyPattern(originalPattern);
 515     return appendTo;
 516 }
 517 
 518 
 519 
 520 void
 521 DateIntervalFormat::parseObject(const UnicodeString&amp; /* source */,
 522                                 Formattable&amp; /* result */,
 523                                 ParsePosition&amp; /* parse_pos */) const {
 524     // parseObject(const UnicodeString&amp;, Formattable&amp;, UErrorCode&amp;) const
 525     // will set status as U_INVALID_FORMAT_ERROR if
 526     // parse_pos is still 0
 527 }
 528 
 529 
 530 
 531 
 532 const DateIntervalInfo*
 533 DateIntervalFormat::getDateIntervalInfo() const {
 534     return fInfo;
 535 }
 536 
 537 
 538 void
 539 DateIntervalFormat::setDateIntervalInfo(const DateIntervalInfo&amp; newItvPattern,
 540                                         UErrorCode&amp; status) {
 541     delete fInfo;
 542     fInfo = new DateIntervalInfo(newItvPattern);
 543 
 544     // Delete patterns that get reset by initializePattern
 545     delete fDatePattern;
 546     fDatePattern = NULL;
 547     delete fTimePattern;
 548     fTimePattern = NULL;
 549     delete fDateTimeFormat;
 550     fDateTimeFormat = NULL;
 551 
 552     if (fDateFormat) {
 553         initializePattern(status);
 554     }
 555 }
 556 
 557 
 558 
 559 const DateFormat*
 560 DateIntervalFormat::getDateFormat() const {
 561     return fDateFormat;
 562 }
 563 
 564 
 565 void
 566 DateIntervalFormat::adoptTimeZone(TimeZone* zone)
 567 {
 568     if (fDateFormat != NULL) {
 569         fDateFormat-&gt;adoptTimeZone(zone);
 570     }
 571     // The fDateFormat has the master calendar for the DateIntervalFormat and has
 572     // ownership of any adopted TimeZone; fFromCalendar and fToCalendar are internal
 573     // work clones of that calendar (and should not also be given ownership of the
 574     // adopted TimeZone).
 575     if (fFromCalendar) {
 576         fFromCalendar-&gt;setTimeZone(*zone);
 577     }
 578     if (fToCalendar) {
 579         fToCalendar-&gt;setTimeZone(*zone);
 580     }
 581 }
 582 
 583 void
 584 DateIntervalFormat::setTimeZone(const TimeZone&amp; zone)
 585 {
 586     if (fDateFormat != NULL) {
 587         fDateFormat-&gt;setTimeZone(zone);
 588     }
 589     // The fDateFormat has the master calendar for the DateIntervalFormat;
 590     // fFromCalendar and fToCalendar are internal work clones of that calendar.
 591     if (fFromCalendar) {
 592         fFromCalendar-&gt;setTimeZone(zone);
 593     }
 594     if (fToCalendar) {
 595         fToCalendar-&gt;setTimeZone(zone);
 596     }
 597 }
 598 
 599 const TimeZone&amp;
 600 DateIntervalFormat::getTimeZone() const
 601 {
 602     if (fDateFormat != NULL) {
<a name="19" id="anc19"></a><span class="line-modified"> 603         Mutex lock(gFormatterMutex());</span>
 604         return fDateFormat-&gt;getTimeZone();
 605     }
 606     // If fDateFormat is NULL (unexpected), create default timezone.
 607     return *(TimeZone::createDefault());
 608 }
 609 
 610 DateIntervalFormat::DateIntervalFormat(const Locale&amp; locale,
 611                                        DateIntervalInfo* dtItvInfo,
 612                                        const UnicodeString* skeleton,
 613                                        UErrorCode&amp; status)
 614 :   fInfo(NULL),
 615     fDateFormat(NULL),
 616     fFromCalendar(NULL),
 617     fToCalendar(NULL),
 618     fLocale(locale),
 619     fDatePattern(NULL),
 620     fTimePattern(NULL),
 621     fDateTimeFormat(NULL)
 622 {
 623     LocalPointer&lt;DateIntervalInfo&gt; info(dtItvInfo, status);
 624     LocalPointer&lt;SimpleDateFormat&gt; dtfmt(static_cast&lt;SimpleDateFormat *&gt;(
 625             DateFormat::createInstanceForSkeleton(*skeleton, locale, status)), status);
 626     if (U_FAILURE(status)) {
 627         return;
 628     }
 629 
 630     if ( skeleton ) {
 631         fSkeleton = *skeleton;
 632     }
 633     fInfo = info.orphan();
 634     fDateFormat = dtfmt.orphan();
 635     if ( fDateFormat-&gt;getCalendar() ) {
 636         fFromCalendar = fDateFormat-&gt;getCalendar()-&gt;clone();
 637         fToCalendar = fDateFormat-&gt;getCalendar()-&gt;clone();
 638     }
 639     initializePattern(status);
 640 }
 641 
 642 DateIntervalFormat* U_EXPORT2
 643 DateIntervalFormat::create(const Locale&amp; locale,
 644                            DateIntervalInfo* dtitvinf,
 645                            const UnicodeString* skeleton,
 646                            UErrorCode&amp; status) {
 647     DateIntervalFormat* f = new DateIntervalFormat(locale, dtitvinf,
 648                                                    skeleton, status);
 649     if ( f == NULL ) {
 650         status = U_MEMORY_ALLOCATION_ERROR;
 651         delete dtitvinf;
 652     } else if ( U_FAILURE(status) ) {
 653         // safe to delete f, although nothing acutally is saved
 654         delete f;
 655         f = 0;
 656     }
 657     return f;
 658 }
 659 
 660 
 661 
 662 /**
 663  * Initialize interval patterns locale to this formatter
 664  *
 665  * This code is a bit complicated since
 666  * 1. the interval patterns saved in resource bundle files are interval
 667  *    patterns based on date or time only.
 668  *    It does not have interval patterns based on both date and time.
 669  *    Interval patterns on both date and time are algorithm generated.
 670  *
 671  *    For example, it has interval patterns on skeleton &quot;dMy&quot; and &quot;hm&quot;,
 672  *    but it does not have interval patterns on skeleton &quot;dMyhm&quot;.
 673  *
 674  *    The rule to genearte interval patterns for both date and time skeleton are
 675  *    1) when the year, month, or day differs, concatenate the two original
 676  *    expressions with a separator between,
 677  *    For example, interval pattern from &quot;Jan 10, 2007 10:10 am&quot;
 678  *    to &quot;Jan 11, 2007 10:10am&quot; is
 679  *    &quot;Jan 10, 2007 10:10 am - Jan 11, 2007 10:10am&quot;
 680  *
 681  *    2) otherwise, present the date followed by the range expression
 682  *    for the time.
 683  *    For example, interval pattern from &quot;Jan 10, 2007 10:10 am&quot;
 684  *    to &quot;Jan 10, 2007 11:10am&quot; is
 685  *    &quot;Jan 10, 2007 10:10 am - 11:10am&quot;
 686  *
 687  * 2. even a pattern does not request a certion calendar field,
 688  *    the interval pattern needs to include such field if such fields are
 689  *    different between 2 dates.
 690  *    For example, a pattern/skeleton is &quot;hm&quot;, but the interval pattern
 691  *    includes year, month, and date when year, month, and date differs.
 692  *
 693  * @param status          output param set to success/failure code on exit
 694  * @stable ICU 4.0
 695  */
 696 void
 697 DateIntervalFormat::initializePattern(UErrorCode&amp; status) {
 698     if ( U_FAILURE(status) ) {
 699         return;
 700     }
 701     const Locale&amp; locale = fDateFormat-&gt;getSmpFmtLocale();
 702     if ( fSkeleton.isEmpty() ) {
 703         UnicodeString fullPattern;
 704         fDateFormat-&gt;toPattern(fullPattern);
 705 #ifdef DTITVFMT_DEBUG
 706     char result[1000];
 707     char result_1[1000];
 708     char mesg[2000];
 709     fSkeleton.extract(0,  fSkeleton.length(), result, &quot;UTF-8&quot;);
 710     sprintf(mesg, &quot;in getBestSkeleton: fSkeleton: %s; \n&quot;, result);
 711     PRINTMESG(mesg)
 712 #endif
 713         // fSkeleton is already set by createDateIntervalInstance()
 714         // or by createInstance(UnicodeString skeleton, .... )
 715         fSkeleton = DateTimePatternGenerator::staticGetSkeleton(
 716                 fullPattern, status);
 717         if ( U_FAILURE(status) ) {
 718             return;
 719         }
 720     }
 721 
 722     // initialize the fIntervalPattern ordering
 723     int8_t i;
 724     for ( i = 0; i &lt; DateIntervalInfo::kIPI_MAX_INDEX; ++i ) {
 725         fIntervalPatterns[i].laterDateFirst = fInfo-&gt;getDefaultOrder();
 726     }
 727 
 728     /* Check whether the skeleton is a combination of date and time.
 729      * For the complication reason 1 explained above.
 730      */
 731     UnicodeString dateSkeleton;
 732     UnicodeString timeSkeleton;
 733     UnicodeString normalizedTimeSkeleton;
 734     UnicodeString normalizedDateSkeleton;
 735 
 736 
 737     /* the difference between time skeleton and normalizedTimeSkeleton are:
 738      * 1. (Formerly, normalized time skeleton folded &#39;H&#39; to &#39;h&#39;; no longer true)
 739      * 2. &#39;a&#39; is omitted in normalized time skeleton.
 740      * 3. there is only one appearance for &#39;h&#39; or &#39;H&#39;, &#39;m&#39;,&#39;v&#39;, &#39;z&#39; in normalized
 741      *    time skeleton
 742      *
 743      * The difference between date skeleton and normalizedDateSkeleton are:
 744      * 1. both &#39;y&#39; and &#39;d&#39; appear only once in normalizeDateSkeleton
 745      * 2. &#39;E&#39; and &#39;EE&#39; are normalized into &#39;EEE&#39;
 746      * 3. &#39;MM&#39; is normalized into &#39;M&#39;
 747      */
 748     getDateTimeSkeleton(fSkeleton, dateSkeleton, normalizedDateSkeleton,
 749                         timeSkeleton, normalizedTimeSkeleton);
 750 
 751 #ifdef DTITVFMT_DEBUG
 752     char result[1000];
 753     char result_1[1000];
 754     char mesg[2000];
 755     fSkeleton.extract(0,  fSkeleton.length(), result, &quot;UTF-8&quot;);
 756     sprintf(mesg, &quot;in getBestSkeleton: fSkeleton: %s; \n&quot;, result);
 757     PRINTMESG(mesg)
 758 #endif
 759 
 760     // move this up here since we need it for fallbacks
 761     if ( timeSkeleton.length() &gt; 0 &amp;&amp; dateSkeleton.length() &gt; 0 ) {
 762         // Need the Date/Time pattern for concatenation of the date
 763         // with the time interval.
 764         // The date/time pattern ( such as {0} {1} ) is saved in
 765         // calendar, that is why need to get the CalendarData here.
 766         LocalUResourceBundlePointer dateTimePatternsRes(ures_open(NULL, locale.getBaseName(), &amp;status));
 767         ures_getByKey(dateTimePatternsRes.getAlias(), gCalendarTag,
 768                       dateTimePatternsRes.getAlias(), &amp;status);
 769         ures_getByKeyWithFallback(dateTimePatternsRes.getAlias(), gGregorianTag,
 770                                   dateTimePatternsRes.getAlias(), &amp;status);
 771         ures_getByKeyWithFallback(dateTimePatternsRes.getAlias(), gDateTimePatternsTag,
 772                                   dateTimePatternsRes.getAlias(), &amp;status);
 773 
 774         int32_t dateTimeFormatLength;
 775         const UChar* dateTimeFormat = ures_getStringByIndex(
 776                                             dateTimePatternsRes.getAlias(),
 777                                             (int32_t)DateFormat::kDateTime,
 778                                             &amp;dateTimeFormatLength, &amp;status);
 779         if ( U_SUCCESS(status) &amp;&amp; dateTimeFormatLength &gt;= 3 ) {
 780             fDateTimeFormat = new UnicodeString(dateTimeFormat, dateTimeFormatLength);
 781         }
 782     }
 783 
 784     UBool found = setSeparateDateTimePtn(normalizedDateSkeleton,
 785                                          normalizedTimeSkeleton);
 786 
 787     // for skeletons with seconds, found is false and we enter this block
 788     if ( found == false ) {
 789         // use fallback
 790         // TODO: if user asks &quot;m&quot;(minute), but &quot;d&quot;(day) differ
 791         if ( timeSkeleton.length() != 0 ) {
 792             if ( dateSkeleton.length() == 0 ) {
 793                 // prefix with yMd
 794                 timeSkeleton.insert(0, gDateFormatSkeleton[DateFormat::kShort], -1);
 795                 UnicodeString pattern = DateFormat::getBestPattern(
 796                         locale, timeSkeleton, status);
 797                 if ( U_FAILURE(status) ) {
 798                     return;
 799                 }
 800                 // for fall back interval patterns,
 801                 // the first part of the pattern is empty,
 802                 // the second part of the pattern is the full-pattern
 803                 // should be used in fall-back.
 804                 setPatternInfo(UCAL_DATE, NULL, &amp;pattern, fInfo-&gt;getDefaultOrder());
 805                 setPatternInfo(UCAL_MONTH, NULL, &amp;pattern, fInfo-&gt;getDefaultOrder());
 806                 setPatternInfo(UCAL_YEAR, NULL, &amp;pattern, fInfo-&gt;getDefaultOrder());
 807             } else {
 808                 // TODO: fall back
 809             }
 810         } else {
 811             // TODO: fall back
 812         }
 813         return;
 814     } // end of skeleton not found
 815     // interval patterns for skeleton are found in resource
 816     if ( timeSkeleton.length() == 0 ) {
 817         // done
 818     } else if ( dateSkeleton.length() == 0 ) {
 819         // prefix with yMd
 820         timeSkeleton.insert(0, gDateFormatSkeleton[DateFormat::kShort], -1);
 821         UnicodeString pattern = DateFormat::getBestPattern(
 822                 locale, timeSkeleton, status);
 823         if ( U_FAILURE(status) ) {
 824             return;
 825         }
 826         // for fall back interval patterns,
 827         // the first part of the pattern is empty,
 828         // the second part of the pattern is the full-pattern
 829         // should be used in fall-back.
 830         setPatternInfo(UCAL_DATE, NULL, &amp;pattern, fInfo-&gt;getDefaultOrder());
 831         setPatternInfo(UCAL_MONTH, NULL, &amp;pattern, fInfo-&gt;getDefaultOrder());
 832         setPatternInfo(UCAL_YEAR, NULL, &amp;pattern, fInfo-&gt;getDefaultOrder());
 833     } else {
 834         /* if both present,
 835          * 1) when the year, month, or day differs,
 836          * concatenate the two original expressions with a separator between,
 837          * 2) otherwise, present the date followed by the
 838          * range expression for the time.
 839          */
 840         /*
 841          * 1) when the year, month, or day differs,
 842          * concatenate the two original expressions with a separator between,
 843          */
 844         // if field exists, use fall back
 845         UnicodeString skeleton = fSkeleton;
 846         if ( !fieldExistsInSkeleton(UCAL_DATE, dateSkeleton) ) {
 847             // prefix skeleton with &#39;d&#39;
 848             skeleton.insert(0, LOW_D);
 849             setFallbackPattern(UCAL_DATE, skeleton, status);
 850         }
 851         if ( !fieldExistsInSkeleton(UCAL_MONTH, dateSkeleton) ) {
 852             // then prefix skeleton with &#39;M&#39;
 853             skeleton.insert(0, CAP_M);
 854             setFallbackPattern(UCAL_MONTH, skeleton, status);
 855         }
 856         if ( !fieldExistsInSkeleton(UCAL_YEAR, dateSkeleton) ) {
 857             // then prefix skeleton with &#39;y&#39;
 858             skeleton.insert(0, LOW_Y);
 859             setFallbackPattern(UCAL_YEAR, skeleton, status);
 860         }
 861 
 862         /*
 863          * 2) otherwise, present the date followed by the
 864          * range expression for the time.
 865          */
 866 
 867         if ( fDateTimeFormat == NULL ) {
 868             // earlier failure getting dateTimeFormat
 869             return;
 870         }
 871 
 872         UnicodeString datePattern = DateFormat::getBestPattern(
 873                 locale, dateSkeleton, status);
 874 
 875         concatSingleDate2TimeInterval(*fDateTimeFormat, datePattern, UCAL_AM_PM, status);
 876         concatSingleDate2TimeInterval(*fDateTimeFormat, datePattern, UCAL_HOUR, status);
 877         concatSingleDate2TimeInterval(*fDateTimeFormat, datePattern, UCAL_MINUTE, status);
 878     }
 879 }
 880 
 881 
 882 
 883 void  U_EXPORT2
 884 DateIntervalFormat::getDateTimeSkeleton(const UnicodeString&amp; skeleton,
 885                                         UnicodeString&amp; dateSkeleton,
 886                                         UnicodeString&amp; normalizedDateSkeleton,
 887                                         UnicodeString&amp; timeSkeleton,
 888                                         UnicodeString&amp; normalizedTimeSkeleton) {
 889     // dateSkeleton follows the sequence of y*M*E*d*
 890     // timeSkeleton follows the sequence of hm*[v|z]?
 891     int32_t ECount = 0;
 892     int32_t dCount = 0;
 893     int32_t MCount = 0;
 894     int32_t yCount = 0;
 895     int32_t hCount = 0;
 896     int32_t HCount = 0;
 897     int32_t mCount = 0;
 898     int32_t vCount = 0;
 899     int32_t zCount = 0;
 900     int32_t i;
 901 
 902     for (i = 0; i &lt; skeleton.length(); ++i) {
 903         UChar ch = skeleton[i];
 904         switch ( ch ) {
 905           case CAP_E:
 906             dateSkeleton.append(ch);
 907             ++ECount;
 908             break;
 909           case LOW_D:
 910             dateSkeleton.append(ch);
 911             ++dCount;
 912             break;
 913           case CAP_M:
 914             dateSkeleton.append(ch);
 915             ++MCount;
 916             break;
 917           case LOW_Y:
 918             dateSkeleton.append(ch);
 919             ++yCount;
 920             break;
 921           case CAP_G:
 922           case CAP_Y:
 923           case LOW_U:
 924           case CAP_Q:
 925           case LOW_Q:
 926           case CAP_L:
 927           case LOW_L:
 928           case CAP_W:
 929           case LOW_W:
 930           case CAP_D:
 931           case CAP_F:
 932           case LOW_G:
 933           case LOW_E:
 934           case LOW_C:
 935           case CAP_U:
 936           case LOW_R:
 937             normalizedDateSkeleton.append(ch);
 938             dateSkeleton.append(ch);
 939             break;
 940           case LOW_A:
 941             // &#39;a&#39; is implicitly handled
 942             timeSkeleton.append(ch);
 943             break;
 944           case LOW_H:
 945             timeSkeleton.append(ch);
 946             ++hCount;
 947             break;
 948           case CAP_H:
 949             timeSkeleton.append(ch);
 950             ++HCount;
 951             break;
 952           case LOW_M:
 953             timeSkeleton.append(ch);
 954             ++mCount;
 955             break;
 956           case LOW_Z:
 957             ++zCount;
 958             timeSkeleton.append(ch);
 959             break;
 960           case LOW_V:
 961             ++vCount;
 962             timeSkeleton.append(ch);
 963             break;
 964           case CAP_V:
 965           case CAP_Z:
 966           case LOW_K:
 967           case CAP_K:
 968           case LOW_J:
 969           case LOW_S:
 970           case CAP_S:
 971           case CAP_A:
 972             timeSkeleton.append(ch);
 973             normalizedTimeSkeleton.append(ch);
 974             break;
 975         }
 976     }
 977 
 978     /* generate normalized form for date*/
 979     if ( yCount != 0 ) {
 980         for (i = 0; i &lt; yCount; ++i) {
 981             normalizedDateSkeleton.append(LOW_Y);
 982         }
 983     }
 984     if ( MCount != 0 ) {
 985         if ( MCount &lt; 3 ) {
 986             normalizedDateSkeleton.append(CAP_M);
 987         } else {
<a name="20" id="anc20"></a><span class="line-modified"> 988             for ( int32_t j = 0; j &lt; MCount &amp;&amp; j &lt; MAX_M_COUNT; ++j) {</span>

 989                  normalizedDateSkeleton.append(CAP_M);
 990             }
 991         }
 992     }
 993     if ( ECount != 0 ) {
 994         if ( ECount &lt;= 3 ) {
 995             normalizedDateSkeleton.append(CAP_E);
 996         } else {
<a name="21" id="anc21"></a><span class="line-modified"> 997             for ( int32_t j = 0; j &lt; ECount &amp;&amp; j &lt; MAX_E_COUNT; ++j ) {</span>

 998                  normalizedDateSkeleton.append(CAP_E);
 999             }
1000         }
1001     }
1002     if ( dCount != 0 ) {
1003         normalizedDateSkeleton.append(LOW_D);
1004     }
1005 
1006     /* generate normalized form for time */
1007     if ( HCount != 0 ) {
1008         normalizedTimeSkeleton.append(CAP_H);
1009     }
1010     else if ( hCount != 0 ) {
1011         normalizedTimeSkeleton.append(LOW_H);
1012     }
1013     if ( mCount != 0 ) {
1014         normalizedTimeSkeleton.append(LOW_M);
1015     }
1016     if ( zCount != 0 ) {
1017         normalizedTimeSkeleton.append(LOW_Z);
1018     }
1019     if ( vCount != 0 ) {
1020         normalizedTimeSkeleton.append(LOW_V);
1021     }
1022 }
1023 
1024 
1025 /**
1026  * Generate date or time interval pattern from resource,
1027  * and set them into the interval pattern locale to this formatter.
1028  *
1029  * It needs to handle the following:
1030  * 1. need to adjust field width.
1031  *    For example, the interval patterns saved in DateIntervalInfo
1032  *    includes &quot;dMMMy&quot;, but not &quot;dMMMMy&quot;.
1033  *    Need to get interval patterns for dMMMMy from dMMMy.
1034  *    Another example, the interval patterns saved in DateIntervalInfo
1035  *    includes &quot;hmv&quot;, but not &quot;hmz&quot;.
1036  *    Need to get interval patterns for &quot;hmz&#39; from &#39;hmv&#39;
1037  *
1038  * 2. there might be no pattern for &#39;y&#39; differ for skeleton &quot;Md&quot;,
1039  *    in order to get interval patterns for &#39;y&#39; differ,
1040  *    need to look for it from skeleton &#39;yMd&#39;
1041  *
1042  * @param dateSkeleton   normalized date skeleton
1043  * @param timeSkeleton   normalized time skeleton
1044  * @return               whether the resource is found for the skeleton.
1045  *                       TRUE if interval pattern found for the skeleton,
1046  *                       FALSE otherwise.
1047  * @stable ICU 4.0
1048  */
1049 UBool
1050 DateIntervalFormat::setSeparateDateTimePtn(
1051                                  const UnicodeString&amp; dateSkeleton,
1052                                  const UnicodeString&amp; timeSkeleton) {
1053     const UnicodeString* skeleton;
1054     // if both date and time skeleton present,
1055     // the final interval pattern might include time interval patterns
1056     // ( when, am_pm, hour, minute differ ),
1057     // but not date interval patterns ( when year, month, day differ ).
1058     // For year/month/day differ, it falls back to fall-back pattern.
1059     if ( timeSkeleton.length() != 0  ) {
1060         skeleton = &amp;timeSkeleton;
1061     } else {
1062         skeleton = &amp;dateSkeleton;
1063     }
1064 
1065     /* interval patterns for skeleton &quot;dMMMy&quot; (but not &quot;dMMMMy&quot;)
1066      * are defined in resource,
1067      * interval patterns for skeleton &quot;dMMMMy&quot; are calculated by
1068      * 1. get the best match skeleton for &quot;dMMMMy&quot;, which is &quot;dMMMy&quot;
1069      * 2. get the interval patterns for &quot;dMMMy&quot;,
1070      * 3. extend &quot;MMM&quot; to &quot;MMMM&quot; in above interval patterns for &quot;dMMMMy&quot;
1071      * getBestSkeleton() is step 1.
1072      */
1073     // best skeleton, and the difference information
1074     int8_t differenceInfo = 0;
1075     const UnicodeString* bestSkeleton = fInfo-&gt;getBestSkeleton(*skeleton,
1076                                                                differenceInfo);
1077     /* best skeleton could be NULL.
1078        For example: in &quot;ca&quot; resource file,
1079        interval format is defined as following
1080            intervalFormats{
1081                 fallback{&quot;{0} - {1}&quot;}
1082             }
1083        there is no skeletons/interval patterns defined,
1084        and the best skeleton match could be NULL
1085      */
1086     if ( bestSkeleton == NULL ) {
1087         return false;
1088     }
1089 
1090     // Set patterns for fallback use, need to do this
1091     // before returning if differenceInfo == -1
1092     UErrorCode status;
1093     if ( dateSkeleton.length() != 0) {
1094         status = U_ZERO_ERROR;
1095         fDatePattern = new UnicodeString(DateFormat::getBestPattern(
1096                 fLocale, dateSkeleton, status));
1097     }
1098     if ( timeSkeleton.length() != 0) {
1099         status = U_ZERO_ERROR;
1100         fTimePattern = new UnicodeString(DateFormat::getBestPattern(
1101                 fLocale, timeSkeleton, status));
1102     }
1103 
1104     // difference:
1105     // 0 means the best matched skeleton is the same as input skeleton
1106     // 1 means the fields are the same, but field width are different
1107     // 2 means the only difference between fields are v/z,
1108     // -1 means there are other fields difference
1109     // (this will happen, for instance, if the supplied skeleton has seconds,
1110     //  but no skeletons in the intervalFormats data do)
1111     if ( differenceInfo == -1 ) {
1112         // skeleton has different fields, not only  v/z difference
1113         return false;
1114     }
1115 
1116     if ( timeSkeleton.length() == 0 ) {
1117         UnicodeString extendedSkeleton;
1118         UnicodeString extendedBestSkeleton;
1119         // only has date skeleton
1120         setIntervalPattern(UCAL_DATE, skeleton, bestSkeleton, differenceInfo,
1121                            &amp;extendedSkeleton, &amp;extendedBestSkeleton);
1122 
1123         UBool extended = setIntervalPattern(UCAL_MONTH, skeleton, bestSkeleton,
1124                                      differenceInfo,
1125                                      &amp;extendedSkeleton, &amp;extendedBestSkeleton);
1126 
1127         if ( extended ) {
1128             bestSkeleton = &amp;extendedBestSkeleton;
1129             skeleton = &amp;extendedSkeleton;
1130         }
1131         setIntervalPattern(UCAL_YEAR, skeleton, bestSkeleton, differenceInfo,
1132                            &amp;extendedSkeleton, &amp;extendedBestSkeleton);
<a name="22" id="anc22"></a><span class="line-modified">1133         setIntervalPattern(UCAL_ERA, skeleton, bestSkeleton, differenceInfo,</span>
<span class="line-added">1134                            &amp;extendedSkeleton, &amp;extendedBestSkeleton);</span>
<span class="line-added">1135      } else {</span>
1136         setIntervalPattern(UCAL_MINUTE, skeleton, bestSkeleton, differenceInfo);
1137         setIntervalPattern(UCAL_HOUR, skeleton, bestSkeleton, differenceInfo);
1138         setIntervalPattern(UCAL_AM_PM, skeleton, bestSkeleton, differenceInfo);
1139     }
1140     return true;
1141 }
1142 
1143 
1144 
1145 void
1146 DateIntervalFormat::setFallbackPattern(UCalendarDateFields field,
1147                                        const UnicodeString&amp; skeleton,
1148                                        UErrorCode&amp; status) {
1149     if ( U_FAILURE(status) ) {
1150         return;
1151     }
1152     UnicodeString pattern = DateFormat::getBestPattern(
1153             fLocale, skeleton, status);
1154     if ( U_FAILURE(status) ) {
1155         return;
1156     }
1157     setPatternInfo(field, NULL, &amp;pattern, fInfo-&gt;getDefaultOrder());
1158 }
1159 
1160 
1161 
1162 
1163 void
1164 DateIntervalFormat::setPatternInfo(UCalendarDateFields field,
1165                                    const UnicodeString* firstPart,
1166                                    const UnicodeString* secondPart,
1167                                    UBool laterDateFirst) {
1168     // for fall back interval patterns,
1169     // the first part of the pattern is empty,
1170     // the second part of the pattern is the full-pattern
1171     // should be used in fall-back.
1172     UErrorCode status = U_ZERO_ERROR;
1173     // following should not set any wrong status.
1174     int32_t itvPtnIndex = DateIntervalInfo::calendarFieldToIntervalIndex(field,
1175                                                                         status);
1176     if ( U_FAILURE(status) ) {
1177         return;
1178     }
1179     PatternInfo&amp; ptn = fIntervalPatterns[itvPtnIndex];
1180     if ( firstPart ) {
1181         ptn.firstPart = *firstPart;
1182     }
1183     if ( secondPart ) {
1184         ptn.secondPart = *secondPart;
1185     }
1186     ptn.laterDateFirst = laterDateFirst;
1187 }
1188 
1189 void
1190 DateIntervalFormat::setIntervalPattern(UCalendarDateFields field,
1191                                        const UnicodeString&amp; intervalPattern) {
1192     UBool order = fInfo-&gt;getDefaultOrder();
1193     setIntervalPattern(field, intervalPattern, order);
1194 }
1195 
1196 
1197 void
1198 DateIntervalFormat::setIntervalPattern(UCalendarDateFields field,
1199                                        const UnicodeString&amp; intervalPattern,
1200                                        UBool laterDateFirst) {
1201     const UnicodeString* pattern = &amp;intervalPattern;
1202     UBool order = laterDateFirst;
1203     // check for &quot;latestFirst:&quot; or &quot;earliestFirst:&quot; prefix
1204     int8_t prefixLength = UPRV_LENGTHOF(gLaterFirstPrefix);
1205     int8_t earliestFirstLength = UPRV_LENGTHOF(gEarlierFirstPrefix);
1206     UnicodeString realPattern;
1207     if ( intervalPattern.startsWith(gLaterFirstPrefix, prefixLength) ) {
1208         order = true;
1209         intervalPattern.extract(prefixLength,
1210                                 intervalPattern.length() - prefixLength,
1211                                 realPattern);
1212         pattern = &amp;realPattern;
1213     } else if ( intervalPattern.startsWith(gEarlierFirstPrefix,
1214                                            earliestFirstLength) ) {
1215         order = false;
1216         intervalPattern.extract(earliestFirstLength,
1217                                 intervalPattern.length() - earliestFirstLength,
1218                                 realPattern);
1219         pattern = &amp;realPattern;
1220     }
1221 
1222     int32_t splitPoint = splitPatternInto2Part(*pattern);
1223 
1224     UnicodeString firstPart;
1225     UnicodeString secondPart;
1226     pattern-&gt;extract(0, splitPoint, firstPart);
1227     if ( splitPoint &lt; pattern-&gt;length() ) {
1228         pattern-&gt;extract(splitPoint, pattern-&gt;length()-splitPoint, secondPart);
1229     }
1230     setPatternInfo(field, &amp;firstPart, &amp;secondPart, order);
1231 }
1232 
1233 
1234 
1235 
1236 /**
1237  * Generate interval pattern from existing resource
1238  *
1239  * It not only save the interval patterns,
1240  * but also return the extended skeleton and its best match skeleton.
1241  *
1242  * @param field           largest different calendar field
1243  * @param skeleton        skeleton
1244  * @param bestSkeleton    the best match skeleton which has interval pattern
1245  *                        defined in resource
1246  * @param differenceInfo  the difference between skeleton and best skeleton
1247  *         0 means the best matched skeleton is the same as input skeleton
1248  *         1 means the fields are the same, but field width are different
1249  *         2 means the only difference between fields are v/z,
1250  *        -1 means there are other fields difference
1251  *
1252  * @param extendedSkeleton      extended skeleton
1253  * @param extendedBestSkeleton  extended best match skeleton
1254  * @return                      whether the interval pattern is found
1255  *                              through extending skeleton or not.
1256  *                              TRUE if interval pattern is found by
1257  *                              extending skeleton, FALSE otherwise.
1258  * @stable ICU 4.0
1259  */
1260 UBool
1261 DateIntervalFormat::setIntervalPattern(UCalendarDateFields field,
1262                                        const UnicodeString* skeleton,
1263                                        const UnicodeString* bestSkeleton,
1264                                        int8_t differenceInfo,
1265                                        UnicodeString* extendedSkeleton,
1266                                        UnicodeString* extendedBestSkeleton) {
1267     UErrorCode status = U_ZERO_ERROR;
1268     // following getIntervalPattern() should not generate error status
1269     UnicodeString pattern;
1270     fInfo-&gt;getIntervalPattern(*bestSkeleton, field, pattern, status);
1271     if ( pattern.isEmpty() ) {
1272         // single date
1273         if ( SimpleDateFormat::isFieldUnitIgnored(*bestSkeleton, field) ) {
1274             // do nothing, format will handle it
1275             return false;
1276         }
1277 
1278         // for 24 hour system, interval patterns in resource file
1279         // might not include pattern when am_pm differ,
1280         // which should be the same as hour differ.
1281         // add it here for simplicity
1282         if ( field == UCAL_AM_PM ) {
1283             fInfo-&gt;getIntervalPattern(*bestSkeleton, UCAL_HOUR, pattern,status);
1284             if ( !pattern.isEmpty() ) {
1285                 setIntervalPattern(field, pattern);
1286             }
1287             return false;
1288         }
1289         // else, looking for pattern when &#39;y&#39; differ for &#39;dMMMM&#39; skeleton,
1290         // first, get best match pattern &quot;MMMd&quot;,
1291         // since there is no pattern for &#39;y&#39; differs for skeleton &#39;MMMd&#39;,
1292         // need to look for it from skeleton &#39;yMMMd&#39;,
1293         // if found, adjust field width in interval pattern from
1294         // &quot;MMM&quot; to &quot;MMMM&quot;.
1295         UChar fieldLetter = fgCalendarFieldToPatternLetter[field];
1296         if ( extendedSkeleton ) {
1297             *extendedSkeleton = *skeleton;
1298             *extendedBestSkeleton = *bestSkeleton;
1299             extendedSkeleton-&gt;insert(0, fieldLetter);
1300             extendedBestSkeleton-&gt;insert(0, fieldLetter);
1301             // for example, looking for patterns when &#39;y&#39; differ for
1302             // skeleton &quot;MMMM&quot;.
1303             fInfo-&gt;getIntervalPattern(*extendedBestSkeleton,field,pattern,status);
1304             if ( pattern.isEmpty() &amp;&amp; differenceInfo == 0 ) {
1305                 // if there is no skeleton &quot;yMMMM&quot; defined,
1306                 // look for the best match skeleton, for example: &quot;yMMM&quot;
1307                 const UnicodeString* tmpBest = fInfo-&gt;getBestSkeleton(
1308                                         *extendedBestSkeleton, differenceInfo);
1309                 if ( tmpBest != 0 &amp;&amp; differenceInfo != -1 ) {
1310                     fInfo-&gt;getIntervalPattern(*tmpBest, field, pattern, status);
1311                     bestSkeleton = tmpBest;
1312                 }
1313             }
1314         }
1315     }
1316     if ( !pattern.isEmpty() ) {
1317         if ( differenceInfo != 0 ) {
1318             UnicodeString adjustIntervalPattern;
1319             adjustFieldWidth(*skeleton, *bestSkeleton, pattern, differenceInfo,
1320                               adjustIntervalPattern);
1321             setIntervalPattern(field, adjustIntervalPattern);
1322         } else {
1323             setIntervalPattern(field, pattern);
1324         }
1325         if ( extendedSkeleton &amp;&amp; !extendedSkeleton-&gt;isEmpty() ) {
1326             return TRUE;
1327         }
1328     }
1329     return FALSE;
1330 }
1331 
1332 
1333 
1334 int32_t  U_EXPORT2
1335 DateIntervalFormat::splitPatternInto2Part(const UnicodeString&amp; intervalPattern) {
1336     UBool inQuote = false;
1337     UChar prevCh = 0;
1338     int32_t count = 0;
1339 
1340     /* repeatedPattern used to record whether a pattern has already seen.
1341        It is a pattern applies to first calendar if it is first time seen,
1342        otherwise, it is a pattern applies to the second calendar
1343      */
1344     UBool patternRepeated[] =
1345     {
1346     //       A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
1347              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
1348     //   P   Q   R   S   T   U   V   W   X   Y   Z
1349          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0,  0, 0, 0,
1350     //       a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
1351          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
1352     //   p   q   r   s   t   u   v   w   x   y   z
1353          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
1354     };
1355 
1356     int8_t PATTERN_CHAR_BASE = 0x41;
1357 
1358     /* loop through the pattern string character by character looking for
1359      * the first repeated pattern letter, which breaks the interval pattern
1360      * into 2 parts.
1361      */
1362     int32_t i;
1363     UBool foundRepetition = false;
1364     for (i = 0; i &lt; intervalPattern.length(); ++i) {
1365         UChar ch = intervalPattern.charAt(i);
1366 
1367         if (ch != prevCh &amp;&amp; count &gt; 0) {
1368             // check the repeativeness of pattern letter
1369             UBool repeated = patternRepeated[(int)(prevCh - PATTERN_CHAR_BASE)];
1370             if ( repeated == FALSE ) {
1371                 patternRepeated[prevCh - PATTERN_CHAR_BASE] = TRUE;
1372             } else {
1373                 foundRepetition = true;
1374                 break;
1375             }
1376             count = 0;
1377         }
1378         if (ch == 0x0027 /*&#39;*/) {
1379             // Consecutive single quotes are a single quote literal,
1380             // either outside of quotes or between quotes
1381             if ((i+1) &lt; intervalPattern.length() &amp;&amp;
1382                 intervalPattern.charAt(i+1) == 0x0027 /*&#39;*/) {
1383                 ++i;
1384             } else {
1385                 inQuote = ! inQuote;
1386             }
1387         }
1388         else if (!inQuote &amp;&amp; ((ch &gt;= 0x0061 /*&#39;a&#39;*/ &amp;&amp; ch &lt;= 0x007A /*&#39;z&#39;*/)
1389                     || (ch &gt;= 0x0041 /*&#39;A&#39;*/ &amp;&amp; ch &lt;= 0x005A /*&#39;Z&#39;*/))) {
1390             // ch is a date-time pattern character
1391             prevCh = ch;
1392             ++count;
1393         }
1394     }
1395     // check last pattern char, distinguish
1396     // &quot;dd MM&quot; ( no repetition ),
1397     // &quot;d-d&quot;(last char repeated ), and
1398     // &quot;d-d MM&quot; ( repetition found )
1399     if ( count &gt; 0 &amp;&amp; foundRepetition == FALSE ) {
1400         if ( patternRepeated[(int)(prevCh - PATTERN_CHAR_BASE)] == FALSE ) {
1401             count = 0;
1402         }
1403     }
1404     return (i - count);
1405 }
1406 
<a name="23" id="anc23"></a><span class="line-modified">1407 void DateIntervalFormat::fallbackFormatRange(</span>
<span class="line-modified">1408         Calendar&amp; fromCalendar,</span>
<span class="line-modified">1409         Calendar&amp; toCalendar,</span>
<span class="line-modified">1410         UnicodeString&amp; appendTo,</span>
<span class="line-modified">1411         int8_t&amp; firstIndex,</span>
<span class="line-modified">1412         FieldPositionHandler&amp; fphandler,</span>
<span class="line-modified">1413         UErrorCode&amp; status) const {</span>
<span class="line-modified">1414     UnicodeString fallbackPattern;</span>
<span class="line-modified">1415     fInfo-&gt;getFallbackIntervalPattern(fallbackPattern);</span>
<span class="line-modified">1416     SimpleFormatter sf(fallbackPattern, 2, 2, status);</span>
<span class="line-modified">1417     if (U_FAILURE(status)) {</span>
1418         return;
1419     }
<a name="24" id="anc24"></a><span class="line-modified">1420     int32_t offsets[2];</span>
<span class="line-modified">1421     UnicodeString patternBody = sf.getTextWithNoArguments(offsets, 2);</span>
<span class="line-modified">1422 </span>
<span class="line-modified">1423     // TODO(ICU-20406): Use SimpleFormatter Iterator interface when available.</span>
<span class="line-modified">1424     if (offsets[0] &lt; offsets[1]) {</span>
<span class="line-modified">1425         firstIndex = 0;</span>
<span class="line-modified">1426         appendTo.append(patternBody.tempSubStringBetween(0, offsets[0]));</span>
<span class="line-modified">1427         fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">1428         appendTo.append(patternBody.tempSubStringBetween(offsets[0], offsets[1]));</span>
<span class="line-modified">1429         fDateFormat-&gt;_format(toCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">1430         appendTo.append(patternBody.tempSubStringBetween(offsets[1]));</span>
1431     } else {
<a name="25" id="anc25"></a><span class="line-modified">1432         firstIndex = 1;</span>
<span class="line-modified">1433         appendTo.append(patternBody.tempSubStringBetween(0, offsets[1]));</span>
<span class="line-modified">1434         fDateFormat-&gt;_format(toCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">1435         appendTo.append(patternBody.tempSubStringBetween(offsets[1], offsets[0]));</span>
<span class="line-modified">1436         fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">1437         appendTo.append(patternBody.tempSubStringBetween(offsets[0]));</span>



1438     }
1439 }
1440 
1441 UnicodeString&amp;
1442 DateIntervalFormat::fallbackFormat(Calendar&amp; fromCalendar,
1443                                    Calendar&amp; toCalendar,
1444                                    UBool fromToOnSameDay, // new
1445                                    UnicodeString&amp; appendTo,
<a name="26" id="anc26"></a><span class="line-modified">1446                                    int8_t&amp; firstIndex,</span>
<span class="line-added">1447                                    FieldPositionHandler&amp; fphandler,</span>
1448                                    UErrorCode&amp; status) const {
1449     if ( U_FAILURE(status) ) {
1450         return appendTo;
1451     }
<a name="27" id="anc27"></a><span class="line-modified">1452 </span>
1453     UBool formatDatePlusTimeRange = (fromToOnSameDay &amp;&amp; fDatePattern &amp;&amp; fTimePattern);
<a name="28" id="anc28"></a>
1454     if (formatDatePlusTimeRange) {
<a name="29" id="anc29"></a><span class="line-added">1455         SimpleFormatter sf(*fDateTimeFormat, 2, 2, status);</span>
<span class="line-added">1456         if (U_FAILURE(status)) {</span>
<span class="line-added">1457             return appendTo;</span>
<span class="line-added">1458         }</span>
<span class="line-added">1459         int32_t offsets[2];</span>
<span class="line-added">1460         UnicodeString patternBody = sf.getTextWithNoArguments(offsets, 2);</span>
<span class="line-added">1461 </span>
<span class="line-added">1462         UnicodeString fullPattern; // for saving the pattern in fDateFormat</span>
1463         fDateFormat-&gt;toPattern(fullPattern); // save current pattern, restore later
<a name="30" id="anc30"></a><span class="line-modified">1464 </span>
<span class="line-modified">1465         // {0} is time range</span>
<span class="line-modified">1466         // {1} is single date portion</span>
<span class="line-modified">1467         // TODO(ICU-20406): Use SimpleFormatter Iterator interface when available.</span>
<span class="line-modified">1468         if (offsets[0] &lt; offsets[1]) {</span>
<span class="line-modified">1469             appendTo.append(patternBody.tempSubStringBetween(0, offsets[0]));</span>
<span class="line-modified">1470             fDateFormat-&gt;applyPattern(*fTimePattern);</span>
<span class="line-modified">1471             fallbackFormatRange(fromCalendar, toCalendar, appendTo, firstIndex, fphandler, status);</span>
<span class="line-modified">1472             appendTo.append(patternBody.tempSubStringBetween(offsets[0], offsets[1]));</span>
<span class="line-modified">1473             fDateFormat-&gt;applyPattern(*fDatePattern);</span>
<span class="line-modified">1474             fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">1475             appendTo.append(patternBody.tempSubStringBetween(offsets[1]));</span>
<span class="line-modified">1476         } else {</span>
<span class="line-modified">1477             appendTo.append(patternBody.tempSubStringBetween(0, offsets[1]));</span>
<span class="line-modified">1478             fDateFormat-&gt;applyPattern(*fDatePattern);</span>
<span class="line-modified">1479             fDateFormat-&gt;_format(fromCalendar, appendTo, fphandler, status);</span>
<span class="line-modified">1480             appendTo.append(patternBody.tempSubStringBetween(offsets[1], offsets[0]));</span>
<span class="line-modified">1481             fDateFormat-&gt;applyPattern(*fTimePattern);</span>
<span class="line-modified">1482             fallbackFormatRange(fromCalendar, toCalendar, appendTo, firstIndex, fphandler, status);</span>
<span class="line-modified">1483             appendTo.append(patternBody.tempSubStringBetween(offsets[0]));</span>
<span class="line-modified">1484         }</span>
<span class="line-modified">1485 </span>











1486         // restore full pattern
1487         fDateFormat-&gt;applyPattern(fullPattern);
<a name="31" id="anc31"></a><span class="line-added">1488     } else {</span>
<span class="line-added">1489         fallbackFormatRange(fromCalendar, toCalendar, appendTo, firstIndex, fphandler, status);</span>
1490     }
1491     return appendTo;
1492 }
1493 
1494 
1495 
1496 
1497 UBool  U_EXPORT2
1498 DateIntervalFormat::fieldExistsInSkeleton(UCalendarDateFields field,
1499                                           const UnicodeString&amp; skeleton)
1500 {
1501     const UChar fieldChar = fgCalendarFieldToPatternLetter[field];
1502     return ( (skeleton.indexOf(fieldChar) == -1)?FALSE:TRUE ) ;
1503 }
1504 
1505 
1506 
1507 void  U_EXPORT2
1508 DateIntervalFormat::adjustFieldWidth(const UnicodeString&amp; inputSkeleton,
1509                  const UnicodeString&amp; bestMatchSkeleton,
1510                  const UnicodeString&amp; bestIntervalPattern,
1511                  int8_t differenceInfo,
1512                  UnicodeString&amp; adjustedPtn) {
1513     adjustedPtn = bestIntervalPattern;
1514     int32_t inputSkeletonFieldWidth[] =
1515     {
1516     //       A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
1517              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
1518     //   P   Q   R   S   T   U   V   W   X   Y   Z
1519          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0,  0, 0, 0,
1520     //       a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
1521          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
1522     //   p   q   r   s   t   u   v   w   x   y   z
1523          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
1524     };
1525 
1526     int32_t bestMatchSkeletonFieldWidth[] =
1527     {
1528     //       A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
1529              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
1530     //   P   Q   R   S   T   U   V   W   X   Y   Z
1531          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0,  0, 0, 0,
1532     //       a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
1533          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
1534     //   p   q   r   s   t   u   v   w   x   y   z
1535          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
1536     };
1537 
1538     DateIntervalInfo::parseSkeleton(inputSkeleton, inputSkeletonFieldWidth);
1539     DateIntervalInfo::parseSkeleton(bestMatchSkeleton, bestMatchSkeletonFieldWidth);
1540     if ( differenceInfo == 2 ) {
1541         adjustedPtn.findAndReplace(UnicodeString((UChar)0x76 /* v */),
1542                                    UnicodeString((UChar)0x7a /* z */));
1543     }
1544 
1545     UBool inQuote = false;
1546     UChar prevCh = 0;
1547     int32_t count = 0;
1548 
1549     const int8_t PATTERN_CHAR_BASE = 0x41;
1550 
1551     // loop through the pattern string character by character
1552     int32_t adjustedPtnLength = adjustedPtn.length();
1553     int32_t i;
1554     for (i = 0; i &lt; adjustedPtnLength; ++i) {
1555         UChar ch = adjustedPtn.charAt(i);
1556         if (ch != prevCh &amp;&amp; count &gt; 0) {
1557             // check the repeativeness of pattern letter
1558             UChar skeletonChar = prevCh;
1559             if ( skeletonChar ==  CAP_L ) {
1560                 // there is no &quot;L&quot; (always be &quot;M&quot;) in skeleton,
1561                 // but there is &quot;L&quot; in pattern.
1562                 // for skeleton &quot;M+&quot;, the pattern might be &quot;...L...&quot;
1563                 skeletonChar = CAP_M;
1564             }
1565             int32_t fieldCount = bestMatchSkeletonFieldWidth[(int)(skeletonChar - PATTERN_CHAR_BASE)];
1566             int32_t inputFieldCount = inputSkeletonFieldWidth[(int)(skeletonChar - PATTERN_CHAR_BASE)];
1567             if ( fieldCount == count &amp;&amp; inputFieldCount &gt; fieldCount ) {
1568                 count = inputFieldCount - fieldCount;
1569                 int32_t j;
1570                 for ( j = 0; j &lt; count; ++j ) {
1571                     adjustedPtn.insert(i, prevCh);
1572                 }
1573                 i += count;
1574                 adjustedPtnLength += count;
1575             }
1576             count = 0;
1577         }
1578         if (ch == 0x0027 /*&#39;*/) {
1579             // Consecutive single quotes are a single quote literal,
1580             // either outside of quotes or between quotes
1581             if ((i+1) &lt; adjustedPtn.length() &amp;&amp; adjustedPtn.charAt(i+1) == 0x0027 /* &#39; */) {
1582                 ++i;
1583             } else {
1584                 inQuote = ! inQuote;
1585             }
1586         }
1587         else if ( ! inQuote &amp;&amp; ((ch &gt;= 0x0061 /*&#39;a&#39;*/ &amp;&amp; ch &lt;= 0x007A /*&#39;z&#39;*/)
1588                     || (ch &gt;= 0x0041 /*&#39;A&#39;*/ &amp;&amp; ch &lt;= 0x005A /*&#39;Z&#39;*/))) {
1589             // ch is a date-time pattern character
1590             prevCh = ch;
1591             ++count;
1592         }
1593     }
1594     if ( count &gt; 0 ) {
1595         // last item
1596         // check the repeativeness of pattern letter
1597         UChar skeletonChar = prevCh;
1598         if ( skeletonChar == CAP_L ) {
1599             // there is no &quot;L&quot; (always be &quot;M&quot;) in skeleton,
1600             // but there is &quot;L&quot; in pattern.
1601             // for skeleton &quot;M+&quot;, the pattern might be &quot;...L...&quot;
1602             skeletonChar = CAP_M;
1603         }
1604         int32_t fieldCount = bestMatchSkeletonFieldWidth[(int)(skeletonChar - PATTERN_CHAR_BASE)];
1605         int32_t inputFieldCount = inputSkeletonFieldWidth[(int)(skeletonChar - PATTERN_CHAR_BASE)];
1606         if ( fieldCount == count &amp;&amp; inputFieldCount &gt; fieldCount ) {
1607             count = inputFieldCount - fieldCount;
1608             int32_t j;
1609             for ( j = 0; j &lt; count; ++j ) {
1610                 adjustedPtn.append(prevCh);
1611             }
1612         }
1613     }
1614 }
1615 
1616 
1617 
1618 void
1619 DateIntervalFormat::concatSingleDate2TimeInterval(UnicodeString&amp; format,
1620                                               const UnicodeString&amp; datePattern,
1621                                               UCalendarDateFields field,
1622                                               UErrorCode&amp; status) {
1623     // following should not set wrong status
1624     int32_t itvPtnIndex = DateIntervalInfo::calendarFieldToIntervalIndex(field,
1625                                                                         status);
1626     if ( U_FAILURE(status) ) {
1627         return;
1628     }
1629     PatternInfo&amp;  timeItvPtnInfo = fIntervalPatterns[itvPtnIndex];
1630     if ( !timeItvPtnInfo.firstPart.isEmpty() ) {
1631         UnicodeString timeIntervalPattern(timeItvPtnInfo.firstPart);
1632         timeIntervalPattern.append(timeItvPtnInfo.secondPart);
1633         UnicodeString combinedPattern;
1634         SimpleFormatter(format, 2, 2, status).
1635                 format(timeIntervalPattern, datePattern, combinedPattern, status);
1636         if ( U_FAILURE(status) ) {
1637             return;
1638         }
1639         setIntervalPattern(field, combinedPattern, timeItvPtnInfo.laterDateFirst);
1640     }
1641     // else: fall back
1642     // it should not happen if the interval format defined is valid
1643 }
1644 
1645 
1646 
1647 const UChar
1648 DateIntervalFormat::fgCalendarFieldToPatternLetter[] =
1649 {
1650     /*GyM*/ CAP_G, LOW_Y, CAP_M,
1651     /*wWd*/ LOW_W, CAP_W, LOW_D,
1652     /*DEF*/ CAP_D, CAP_E, CAP_F,
1653     /*ahH*/ LOW_A, LOW_H, CAP_H,
1654     /*msS*/ LOW_M, LOW_S, CAP_S, // MINUTE, SECOND, MILLISECOND
1655     /*z.Y*/ LOW_Z, SPACE, CAP_Y, // ZONE_OFFSET, DST_OFFSET, YEAR_WOY,
1656     /*eug*/ LOW_E, LOW_U, LOW_G, // DOW_LOCAL, EXTENDED_YEAR, JULIAN_DAY,
1657     /*A..*/ CAP_A, SPACE, SPACE, // MILLISECONDS_IN_DAY, IS_LEAP_MONTH, FIELD_COUNT
1658 };
1659 
1660 
<a name="32" id="anc32"></a><span class="line-added">1661 </span>
1662 U_NAMESPACE_END
1663 
1664 #endif
<a name="33" id="anc33"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="33" type="hidden" />
</body>
</html>