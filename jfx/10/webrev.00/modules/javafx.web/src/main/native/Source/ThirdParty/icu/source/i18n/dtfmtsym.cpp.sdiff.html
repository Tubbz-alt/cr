<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtfmtsym.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="double-conversion.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="dtitvfmt.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/dtfmtsym.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   4 *******************************************************************************
   5 * Copyright (C) 1997-2016, International Business Machines Corporation and    *
   6 * others. All Rights Reserved.                                                *
   7 *******************************************************************************
   8 *
   9 * File DTFMTSYM.CPP
  10 *
  11 * Modification History:
  12 *
  13 *   Date        Name        Description
  14 *   02/19/97    aliu        Converted from java.
  15 *   07/21/98    stephen     Added getZoneIndex
  16 *                            Changed weekdays/short weekdays to be one-based
  17 *   06/14/99    stephen     Removed SimpleDateFormat::fgTimeZoneDataSuffix
  18 *   11/16/99    weiv        Added &#39;Y&#39; and &#39;e&#39; to fgPatternChars
  19 *   03/27/00    weiv        Keeping resource bundle around!
  20 *   06/30/05    emmons      Added eraNames, narrow month/day, standalone context
  21 *   10/12/05    emmons      Added setters for eraNames, month/day by width/context
  22 *******************************************************************************
  23 */



  24 #include &quot;unicode/utypes.h&quot;
  25 
  26 #if !UCONFIG_NO_FORMATTING
  27 #include &quot;unicode/ustring.h&quot;
  28 #include &quot;unicode/localpointer.h&quot;
  29 #include &quot;unicode/dtfmtsym.h&quot;
  30 #include &quot;unicode/smpdtfmt.h&quot;
  31 #include &quot;unicode/msgfmt.h&quot;
  32 #include &quot;unicode/numsys.h&quot;
  33 #include &quot;unicode/tznames.h&quot;
  34 #include &quot;cpputils.h&quot;
  35 #include &quot;umutex.h&quot;
  36 #include &quot;cmemory.h&quot;
  37 #include &quot;cstring.h&quot;
  38 #include &quot;charstr.h&quot;
  39 #include &quot;dt_impl.h&quot;
  40 #include &quot;locbased.h&quot;
  41 #include &quot;gregoimp.h&quot;
  42 #include &quot;hash.h&quot;
  43 #include &quot;uassert.h&quot;
</pre>
<hr />
<pre>
 215 static const char gNamesNarrowTag[]=&quot;narrow&quot;;
 216 static const char gNamesAllTag[]=&quot;all&quot;;
 217 static const char gNamesFormatTag[]=&quot;format&quot;;
 218 static const char gNamesStandaloneTag[]=&quot;stand-alone&quot;;
 219 static const char gNamesNumericTag[]=&quot;numeric&quot;;
 220 static const char gAmPmMarkersTag[]=&quot;AmPmMarkers&quot;;
 221 static const char gAmPmMarkersAbbrTag[]=&quot;AmPmMarkersAbbr&quot;;
 222 static const char gAmPmMarkersNarrowTag[]=&quot;AmPmMarkersNarrow&quot;;
 223 static const char gQuartersTag[]=&quot;quarters&quot;;
 224 static const char gNumberElementsTag[]=&quot;NumberElements&quot;;
 225 static const char gSymbolsTag[]=&quot;symbols&quot;;
 226 static const char gTimeSeparatorTag[]=&quot;timeSeparator&quot;;
 227 static const char gDayPeriodTag[]=&quot;dayPeriod&quot;;
 228 
 229 // static const char gZoneStringsTag[]=&quot;zoneStrings&quot;;
 230 
 231 // static const char gLocalPatternCharsTag[]=&quot;localPatternChars&quot;;
 232 
 233 static const char gContextTransformsTag[]=&quot;contextTransforms&quot;;
 234 
<span class="line-removed"> 235 static UMutex LOCK = U_MUTEX_INITIALIZER;</span>
<span class="line-removed"> 236 </span>
 237 /**
 238  * Jitterbug 2974: MSVC has a bug whereby new X[0] behaves badly.
 239  * Work around this.
 240  */
 241 static inline UnicodeString* newUnicodeStringArray(size_t count) {
 242     return new UnicodeString[count ? count : 1];
 243 }
 244 
 245 //------------------------------------------------------
 246 
 247 DateFormatSymbols * U_EXPORT2
 248 DateFormatSymbols::createForLocale(
 249         const Locale&amp; locale, UErrorCode &amp;status) {
 250     const SharedDateFormatSymbols *shared = NULL;
 251     UnifiedCache::getByLocale(locale, shared, status);
 252     if (U_FAILURE(status)) {
 253         return NULL;
 254     }
 255     DateFormatSymbols *result = new DateFormatSymbols(shared-&gt;get());
 256     shared-&gt;removeRef();
</pre>
<hr />
<pre>
 314     // *and* for as long as all the strings are in *private* fields, preventing
 315     // a subclass from creating these strings in an &quot;unsafe&quot; way (with respect to fastCopyFrom()).
 316     dstCount = srcCount;
 317     dstArray = newUnicodeStringArray(srcCount);
 318     if(dstArray != NULL) {
 319         int32_t i;
 320         for(i=0; i&lt;srcCount; ++i) {
 321             dstArray[i].fastCopyFrom(srcArray[i]);
 322         }
 323     }
 324 }
 325 
 326 /**
 327  * Create a copy, in fZoneStrings, of the given zone strings array.  The
 328  * member variables fZoneStringsRowCount and fZoneStringsColCount should
 329  * be set already by the caller.
 330  */
 331 void
 332 DateFormatSymbols::createZoneStrings(const UnicodeString *const * otherStrings)
 333 {
<span class="line-modified"> 334     int32_t row = 0, col;</span>
 335     UBool failed = FALSE;
 336 
 337     fZoneStrings = (UnicodeString **)uprv_malloc(fZoneStringsRowCount * sizeof(UnicodeString *));
 338     if (fZoneStrings != NULL) {
 339         for (row=0; row&lt;fZoneStringsRowCount; ++row)
 340         {
 341             fZoneStrings[row] = newUnicodeStringArray(fZoneStringsColCount);
 342             if (fZoneStrings[row] == NULL) {
 343                 failed = TRUE;
 344                 break;
 345             }
 346             for (col=0; col&lt;fZoneStringsColCount; ++col) {
 347                 // fastCopyFrom() - see assignArray comments
 348                 fZoneStrings[row][col].fastCopyFrom(otherStrings[row][col]);
 349             }
 350         }
 351     }
 352     // If memory allocation failed, roll back and delete fZoneStrings
 353     if (failed) {
 354         for (int i = row; i &gt;= 0; i--) {
</pre>
<hr />
<pre>
1228     // delete the old list if we own it
1229     if (fAmPms) delete[] fAmPms;
1230 
1231     // we always own the new list, which we create here (we duplicate rather
1232     // than adopting the list passed in)
1233     fAmPms = newUnicodeStringArray(count);
1234     uprv_arrayCopy(amPmsArray,fAmPms,count);
1235     fAmPmsCount = count;
1236 }
1237 
1238 void
1239 DateFormatSymbols::setTimeSeparatorString(const UnicodeString&amp; newTimeSeparator)
1240 {
1241     fTimeSeparator = newTimeSeparator;
1242 }
1243 
1244 const UnicodeString**
1245 DateFormatSymbols::getZoneStrings(int32_t&amp; rowCount, int32_t&amp; columnCount) const
1246 {
1247     const UnicodeString **result = NULL;

1248 
1249     umtx_lock(&amp;LOCK);
1250     if (fZoneStrings == NULL) {
1251         if (fLocaleZoneStrings == NULL) {
1252             ((DateFormatSymbols*)this)-&gt;initZoneStringsArray();
1253         }
1254         result = (const UnicodeString**)fLocaleZoneStrings;
1255     } else {
1256         result = (const UnicodeString**)fZoneStrings;
1257     }
1258     rowCount = fZoneStringsRowCount;
1259     columnCount = fZoneStringsColCount;
1260     umtx_unlock(&amp;LOCK);
1261 
1262     return result;
1263 }
1264 
1265 // For now, we include all zones
1266 #define ZONE_SET UCAL_ZONE_TYPE_ANY
1267 
</pre>
<hr />
<pre>
1294         }
1295 
1296         // Allocate array
1297         int32_t size = rows * sizeof(UnicodeString*);
1298         zarray = (UnicodeString**)uprv_malloc(size);
1299         if (zarray == NULL) {
1300             status = U_MEMORY_ALLOCATION_ERROR;
1301             break;
1302         }
1303         uprv_memset(zarray, 0, size);
1304 
1305         tzNames = TimeZoneNames::createInstance(fZSFLocale, status);
1306         tzNames-&gt;loadAllDisplayNames(status);
1307         if (U_FAILURE(status)) { break; }
1308 
1309         const UnicodeString *tzid;
1310         int32_t i = 0;
1311         UDate now = Calendar::getNow();
1312         UnicodeString tzDispName;
1313 
<span class="line-modified">1314         while ((tzid = tzids-&gt;snext(status))) {</span>
1315             if (U_FAILURE(status)) {
1316                 break;
1317             }
1318 
1319             zarray[i] = new UnicodeString[5];
1320             if (zarray[i] == NULL) {
1321                 status = U_MEMORY_ALLOCATION_ERROR;
1322                 break;
1323             }
1324 
1325             zarray[i][0].setTo(*tzid);
1326             tzNames-&gt;getDisplayNames(*tzid, TYPES, NUM_TYPES, now, zarray[i]+1, status);
1327             i++;
1328         }
1329 
1330     } while (FALSE);
1331 
1332     if (U_FAILURE(status)) {
1333         if (zarray) {
1334             for (int32_t i = 0; i &lt; rows; i++) {
</pre>
<hr />
<pre>
1483 // ResourceSink to enumerate all calendar resources
1484 struct CalendarDataSink : public ResourceSink {
1485 
1486     // Enum which specifies the type of alias received, or no alias
1487     enum AliasType {
1488         SAME_CALENDAR,
1489         DIFFERENT_CALENDAR,
1490         GREGORIAN,
1491         NONE
1492     };
1493 
1494     // Data structures to store resources from the current resource bundle
1495     Hashtable arrays;
1496     Hashtable arraySizes;
1497     Hashtable maps;
1498     /**
1499      * Whenever there are aliases, the same object will be added twice to &#39;map&#39;.
1500      * To avoid double deletion, &#39;maps&#39; won&#39;t take ownership of the objects. Instead,
1501      * &#39;mapRefs&#39; will own them and will delete them when CalendarDataSink is deleted.
1502      */
<span class="line-modified">1503     UVector mapRefs;</span>
1504 
1505     // Paths and the aliases they point to
1506     UVector aliasPathPairs;
1507 
1508     // Current and next calendar resource table which should be loaded
1509     UnicodeString currentCalendarType;
1510     UnicodeString nextCalendarType;
1511 
1512     // Resources to visit when enumerating fallback calendars
1513     LocalPointer&lt;UVector&gt; resourcesToVisit;
1514 
1515     // Alias&#39; relative path populated whenever an alias is read
1516     UnicodeString aliasRelativePath;
1517 
1518     // Initializes CalendarDataSink with default values
1519     CalendarDataSink(UErrorCode&amp; status)
1520     :   arrays(FALSE, status), arraySizes(FALSE, status), maps(FALSE, status),
<span class="line-modified">1521         mapRefs(deleteHashtable, NULL, 10, status),</span>
1522         aliasPathPairs(uprv_deleteUObject, uhash_compareUnicodeString, status),
1523         currentCalendarType(), nextCalendarType(),
1524         resourcesToVisit(NULL), aliasRelativePath() {
1525         if (U_FAILURE(status)) { return; }
1526     }
1527     virtual ~CalendarDataSink();
1528 
1529     // Configure the CalendarSink to visit all the resources
1530     void visitAllResources() {
1531         resourcesToVisit.adoptInstead(NULL);
1532     }
1533 
1534     // Actions to be done before enumerating
1535     void preEnumerate(const UnicodeString &amp;calendarType) {
1536         currentCalendarType = calendarType;
1537         nextCalendarType.setToBogus();
1538         aliasPathPairs.removeAllElements();
1539     }
1540 
1541     virtual void put(const char *key, ResourceValue &amp;value, UBool, UErrorCode &amp;errorCode) {
</pre>
<hr />
<pre>
1646                 } else if ((aliasMap = (Hashtable*)maps.get(*alias)) != NULL) {
1647                     UnicodeString *path = (UnicodeString*)aliasPathPairs[i + 1];
1648                     if (maps.get(*path) == NULL) {
1649                         maps.put(*path, aliasMap, errorCode);
1650                     }
1651                     if (U_FAILURE(errorCode)) { return; }
1652                     mod = true;
1653                 }
1654                 if (mod) {
1655                     aliasPathPairs.removeElementAt(i + 1);
1656                     aliasPathPairs.removeElementAt(i);
1657                     modified = true;
1658                 } else {
1659                     i += 2;
1660                 }
1661             }
1662         } while (modified &amp;&amp; !aliasPathPairs.isEmpty());
1663 
1664         // Set the resources to visit on the next calendar
1665         if (!resourcesToVisitNext.isNull()) {
<span class="line-modified">1666             resourcesToVisit.moveFrom(resourcesToVisitNext);</span>
1667         }
1668     }
1669 
1670     // Process the nested resource bundle tables
1671     void processResource(UnicodeString &amp;path, const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
1672         if (U_FAILURE(errorCode)) return;
1673 
1674         ResourceTable table = value.getTable(errorCode);
1675         if (U_FAILURE(errorCode)) return;
1676         Hashtable* stringMap = NULL;
1677 
1678         // Iterate over all the elements of the table and add them to the map
1679         for (int i = 0; table.getKeyAndValue(i, key, value); i++) {
1680             UnicodeString keyUString(key, -1, US_INV);
1681 
1682             // Ignore &#39;%variant&#39; keys
1683             if (keyUString.endsWith(kVariantTagUChar, UPRV_LENGTHOF(kVariantTagUChar))) {
1684                 continue;
1685             }
1686 
1687             // == Handle String elements ==
1688             if (value.getType() == URES_STRING) {
1689                 // We are on a leaf, store the map elements into the stringMap
1690                 if (i == 0) {
<span class="line-modified">1691                     LocalPointer&lt;Hashtable&gt; stringMapPtr(new Hashtable(FALSE, errorCode), errorCode);</span>
<span class="line-modified">1692                     stringMap = stringMapPtr.getAlias();</span>




1693                     maps.put(path, stringMap, errorCode);
<span class="line-removed">1694                     // mapRefs will take ownership of &#39;stringMap&#39;:</span>
<span class="line-removed">1695                     mapRefs.addElement(stringMap, errorCode);</span>
1696                     if (U_FAILURE(errorCode)) { return; }
<span class="line-removed">1697                     // Only release ownership after mapRefs takes it (no error happened):</span>
<span class="line-removed">1698                     stringMapPtr.orphan();</span>
1699                     stringMap-&gt;setValueDeleter(uprv_deleteUObject);
1700                 }
1701                 U_ASSERT(stringMap != NULL);
1702                 int32_t valueStringSize;
1703                 const UChar *valueString = value.getString(valueStringSize, errorCode);
1704                 if (U_FAILURE(errorCode)) { return; }
1705                 LocalPointer&lt;UnicodeString&gt; valueUString(new UnicodeString(TRUE, valueString, valueStringSize), errorCode);
1706                 stringMap-&gt;put(keyUString, valueUString.orphan(), errorCode);
1707                 if (U_FAILURE(errorCode)) { return; }
1708                 continue;
1709             }
1710             U_ASSERT(stringMap == NULL);
1711 
1712             // Store the current path&#39;s length and append the current key to the path.
1713             int32_t pathLength = path.length();
1714             path.append(SOLIDUS).append(keyUString);
1715 
1716             // In cyclicNameSets ignore everything but years/format/abbreviated
1717             // and zodiacs/format/abbreviated
1718             if (path.startsWith(kCyclicNameSetsTagUChar, UPRV_LENGTHOF(kCyclicNameSetsTagUChar))) {
</pre>
<hr />
<pre>
1822                             return GREGORIAN;
1823                         } else if (nextCalendarType.isBogus()) {
1824                             nextCalendarType = aliasCalendarType;
1825                             return DIFFERENT_CALENDAR;
1826                         } else if (nextCalendarType == aliasCalendarType) {
1827                             return DIFFERENT_CALENDAR;
1828                         }
1829                     }
1830                 }
1831             }
1832             errorCode = U_INTERNAL_PROGRAM_ERROR;
1833             return NONE;
1834         }
1835         return NONE;
1836     }
1837 
1838     // Deleter function to be used by &#39;arrays&#39;
1839     static void U_CALLCONV deleteUnicodeStringArray(void *uArray) {
1840         delete[] static_cast&lt;UnicodeString *&gt;(uArray);
1841     }
<span class="line-removed">1842 </span>
<span class="line-removed">1843     // Deleter function to be used by &#39;maps&#39;</span>
<span class="line-removed">1844     static void U_CALLCONV deleteHashtable(void *table) {</span>
<span class="line-removed">1845         delete static_cast&lt;Hashtable *&gt;(table);</span>
<span class="line-removed">1846     }</span>
1847 };
1848 // Virtual destructors have to be defined out of line
1849 CalendarDataSink::~CalendarDataSink() {
1850     arrays.setValueDeleter(deleteUnicodeStringArray);
1851 }
1852 }
1853 
1854 //------------------------------------------------------
1855 
1856 static void
1857 initField(UnicodeString **field, int32_t&amp; length, const UChar *data, LastResortSize numStr, LastResortSize strLen, UErrorCode &amp;status) {
1858     if (U_SUCCESS(status)) {
1859         length = numStr;
1860         *field = newUnicodeStringArray((size_t)numStr);
1861         if (*field) {
1862             for(int32_t i = 0; i&lt;length; i++) {
1863                 // readonly aliases - all &quot;data&quot; strings are constant
1864                 // -1 as length for variable-length strings (gLastResortDayNames[0] is empty)
1865                 (*(field)+i)-&gt;setTo(TRUE, data+(i*((int32_t)strLen)), -1);
1866             }
</pre>
<hr />
<pre>
2207 
2208     // Load context transforms and capitalization
2209     tempStatus = U_ZERO_ERROR;
2210     UResourceBundle *localeBundle = ures_open(NULL, locale.getName(), &amp;tempStatus);
2211     if (U_SUCCESS(tempStatus)) {
2212         UResourceBundle *contextTransforms = ures_getByKeyWithFallback(localeBundle, gContextTransformsTag, NULL, &amp;tempStatus);
2213         if (U_SUCCESS(tempStatus)) {
2214             UResourceBundle *contextTransformUsage;
2215             while ( (contextTransformUsage = ures_getNextResource(contextTransforms, NULL, &amp;tempStatus)) != NULL ) {
2216                 const int32_t * intVector = ures_getIntVector(contextTransformUsage, &amp;len, &amp;status);
2217                 if (U_SUCCESS(tempStatus) &amp;&amp; intVector != NULL &amp;&amp; len &gt;= 2) {
2218                     const char* usageType = ures_getKey(contextTransformUsage);
2219                     if (usageType != NULL) {
2220                         const ContextUsageTypeNameToEnumValue * typeMapPtr = contextUsageTypeMap;
2221                         int32_t compResult = 0;
2222                         // linear search; list is short and we cannot be sure that bsearch is available
2223                         while ( typeMapPtr-&gt;usageTypeName != NULL &amp;&amp; (compResult = uprv_strcmp(usageType, typeMapPtr-&gt;usageTypeName)) &gt; 0 ) {
2224                             ++typeMapPtr;
2225                         }
2226                         if (typeMapPtr-&gt;usageTypeName != NULL &amp;&amp; compResult == 0) {
<span class="line-modified">2227                             fCapitalization[typeMapPtr-&gt;usageTypeEnumValue][0] = intVector[0];</span>
<span class="line-modified">2228                             fCapitalization[typeMapPtr-&gt;usageTypeEnumValue][1] = intVector[1];</span>
2229                         }
2230                     }
2231                 }
2232                 tempStatus = U_ZERO_ERROR;
2233                 ures_close(contextTransformUsage);
2234             }
2235             ures_close(contextTransforms);
2236         }
2237 
2238         tempStatus = U_ZERO_ERROR;
2239         const LocalPointer&lt;NumberingSystem&gt; numberingSystem(
2240                 NumberingSystem::createInstance(locale, tempStatus), tempStatus);
2241         if (U_SUCCESS(tempStatus)) {
2242             // These functions all fail gracefully if passed NULL pointers and
2243             // do nothing unless U_SUCCESS(tempStatus), so it&#39;s only necessary
2244             // to check for errors once after all calls are made.
2245             const LocalUResourceBundlePointer numberElementsData(ures_getByKeyWithFallback(
2246                     localeBundle, gNumberElementsTag, NULL, &amp;tempStatus));
2247             const LocalUResourceBundlePointer nsNameData(ures_getByKeyWithFallback(
2248                     numberElementsData.getAlias(), numberingSystem-&gt;getName(), NULL, &amp;tempStatus));
</pre>
</td>
<td>
<hr />
<pre>
   4 *******************************************************************************
   5 * Copyright (C) 1997-2016, International Business Machines Corporation and    *
   6 * others. All Rights Reserved.                                                *
   7 *******************************************************************************
   8 *
   9 * File DTFMTSYM.CPP
  10 *
  11 * Modification History:
  12 *
  13 *   Date        Name        Description
  14 *   02/19/97    aliu        Converted from java.
  15 *   07/21/98    stephen     Added getZoneIndex
  16 *                            Changed weekdays/short weekdays to be one-based
  17 *   06/14/99    stephen     Removed SimpleDateFormat::fgTimeZoneDataSuffix
  18 *   11/16/99    weiv        Added &#39;Y&#39; and &#39;e&#39; to fgPatternChars
  19 *   03/27/00    weiv        Keeping resource bundle around!
  20 *   06/30/05    emmons      Added eraNames, narrow month/day, standalone context
  21 *   10/12/05    emmons      Added setters for eraNames, month/day by width/context
  22 *******************************************************************************
  23 */
<span class="line-added">  24 </span>
<span class="line-added">  25 #include &lt;utility&gt;</span>
<span class="line-added">  26 </span>
  27 #include &quot;unicode/utypes.h&quot;
  28 
  29 #if !UCONFIG_NO_FORMATTING
  30 #include &quot;unicode/ustring.h&quot;
  31 #include &quot;unicode/localpointer.h&quot;
  32 #include &quot;unicode/dtfmtsym.h&quot;
  33 #include &quot;unicode/smpdtfmt.h&quot;
  34 #include &quot;unicode/msgfmt.h&quot;
  35 #include &quot;unicode/numsys.h&quot;
  36 #include &quot;unicode/tznames.h&quot;
  37 #include &quot;cpputils.h&quot;
  38 #include &quot;umutex.h&quot;
  39 #include &quot;cmemory.h&quot;
  40 #include &quot;cstring.h&quot;
  41 #include &quot;charstr.h&quot;
  42 #include &quot;dt_impl.h&quot;
  43 #include &quot;locbased.h&quot;
  44 #include &quot;gregoimp.h&quot;
  45 #include &quot;hash.h&quot;
  46 #include &quot;uassert.h&quot;
</pre>
<hr />
<pre>
 218 static const char gNamesNarrowTag[]=&quot;narrow&quot;;
 219 static const char gNamesAllTag[]=&quot;all&quot;;
 220 static const char gNamesFormatTag[]=&quot;format&quot;;
 221 static const char gNamesStandaloneTag[]=&quot;stand-alone&quot;;
 222 static const char gNamesNumericTag[]=&quot;numeric&quot;;
 223 static const char gAmPmMarkersTag[]=&quot;AmPmMarkers&quot;;
 224 static const char gAmPmMarkersAbbrTag[]=&quot;AmPmMarkersAbbr&quot;;
 225 static const char gAmPmMarkersNarrowTag[]=&quot;AmPmMarkersNarrow&quot;;
 226 static const char gQuartersTag[]=&quot;quarters&quot;;
 227 static const char gNumberElementsTag[]=&quot;NumberElements&quot;;
 228 static const char gSymbolsTag[]=&quot;symbols&quot;;
 229 static const char gTimeSeparatorTag[]=&quot;timeSeparator&quot;;
 230 static const char gDayPeriodTag[]=&quot;dayPeriod&quot;;
 231 
 232 // static const char gZoneStringsTag[]=&quot;zoneStrings&quot;;
 233 
 234 // static const char gLocalPatternCharsTag[]=&quot;localPatternChars&quot;;
 235 
 236 static const char gContextTransformsTag[]=&quot;contextTransforms&quot;;
 237 


 238 /**
 239  * Jitterbug 2974: MSVC has a bug whereby new X[0] behaves badly.
 240  * Work around this.
 241  */
 242 static inline UnicodeString* newUnicodeStringArray(size_t count) {
 243     return new UnicodeString[count ? count : 1];
 244 }
 245 
 246 //------------------------------------------------------
 247 
 248 DateFormatSymbols * U_EXPORT2
 249 DateFormatSymbols::createForLocale(
 250         const Locale&amp; locale, UErrorCode &amp;status) {
 251     const SharedDateFormatSymbols *shared = NULL;
 252     UnifiedCache::getByLocale(locale, shared, status);
 253     if (U_FAILURE(status)) {
 254         return NULL;
 255     }
 256     DateFormatSymbols *result = new DateFormatSymbols(shared-&gt;get());
 257     shared-&gt;removeRef();
</pre>
<hr />
<pre>
 315     // *and* for as long as all the strings are in *private* fields, preventing
 316     // a subclass from creating these strings in an &quot;unsafe&quot; way (with respect to fastCopyFrom()).
 317     dstCount = srcCount;
 318     dstArray = newUnicodeStringArray(srcCount);
 319     if(dstArray != NULL) {
 320         int32_t i;
 321         for(i=0; i&lt;srcCount; ++i) {
 322             dstArray[i].fastCopyFrom(srcArray[i]);
 323         }
 324     }
 325 }
 326 
 327 /**
 328  * Create a copy, in fZoneStrings, of the given zone strings array.  The
 329  * member variables fZoneStringsRowCount and fZoneStringsColCount should
 330  * be set already by the caller.
 331  */
 332 void
 333 DateFormatSymbols::createZoneStrings(const UnicodeString *const * otherStrings)
 334 {
<span class="line-modified"> 335     int32_t row, col;</span>
 336     UBool failed = FALSE;
 337 
 338     fZoneStrings = (UnicodeString **)uprv_malloc(fZoneStringsRowCount * sizeof(UnicodeString *));
 339     if (fZoneStrings != NULL) {
 340         for (row=0; row&lt;fZoneStringsRowCount; ++row)
 341         {
 342             fZoneStrings[row] = newUnicodeStringArray(fZoneStringsColCount);
 343             if (fZoneStrings[row] == NULL) {
 344                 failed = TRUE;
 345                 break;
 346             }
 347             for (col=0; col&lt;fZoneStringsColCount; ++col) {
 348                 // fastCopyFrom() - see assignArray comments
 349                 fZoneStrings[row][col].fastCopyFrom(otherStrings[row][col]);
 350             }
 351         }
 352     }
 353     // If memory allocation failed, roll back and delete fZoneStrings
 354     if (failed) {
 355         for (int i = row; i &gt;= 0; i--) {
</pre>
<hr />
<pre>
1229     // delete the old list if we own it
1230     if (fAmPms) delete[] fAmPms;
1231 
1232     // we always own the new list, which we create here (we duplicate rather
1233     // than adopting the list passed in)
1234     fAmPms = newUnicodeStringArray(count);
1235     uprv_arrayCopy(amPmsArray,fAmPms,count);
1236     fAmPmsCount = count;
1237 }
1238 
1239 void
1240 DateFormatSymbols::setTimeSeparatorString(const UnicodeString&amp; newTimeSeparator)
1241 {
1242     fTimeSeparator = newTimeSeparator;
1243 }
1244 
1245 const UnicodeString**
1246 DateFormatSymbols::getZoneStrings(int32_t&amp; rowCount, int32_t&amp; columnCount) const
1247 {
1248     const UnicodeString **result = NULL;
<span class="line-added">1249     static UMutex LOCK = U_MUTEX_INITIALIZER;</span>
1250 
1251     umtx_lock(&amp;LOCK);
1252     if (fZoneStrings == NULL) {
1253         if (fLocaleZoneStrings == NULL) {
1254             ((DateFormatSymbols*)this)-&gt;initZoneStringsArray();
1255         }
1256         result = (const UnicodeString**)fLocaleZoneStrings;
1257     } else {
1258         result = (const UnicodeString**)fZoneStrings;
1259     }
1260     rowCount = fZoneStringsRowCount;
1261     columnCount = fZoneStringsColCount;
1262     umtx_unlock(&amp;LOCK);
1263 
1264     return result;
1265 }
1266 
1267 // For now, we include all zones
1268 #define ZONE_SET UCAL_ZONE_TYPE_ANY
1269 
</pre>
<hr />
<pre>
1296         }
1297 
1298         // Allocate array
1299         int32_t size = rows * sizeof(UnicodeString*);
1300         zarray = (UnicodeString**)uprv_malloc(size);
1301         if (zarray == NULL) {
1302             status = U_MEMORY_ALLOCATION_ERROR;
1303             break;
1304         }
1305         uprv_memset(zarray, 0, size);
1306 
1307         tzNames = TimeZoneNames::createInstance(fZSFLocale, status);
1308         tzNames-&gt;loadAllDisplayNames(status);
1309         if (U_FAILURE(status)) { break; }
1310 
1311         const UnicodeString *tzid;
1312         int32_t i = 0;
1313         UDate now = Calendar::getNow();
1314         UnicodeString tzDispName;
1315 
<span class="line-modified">1316         while ((tzid = tzids-&gt;snext(status)) != 0) {</span>
1317             if (U_FAILURE(status)) {
1318                 break;
1319             }
1320 
1321             zarray[i] = new UnicodeString[5];
1322             if (zarray[i] == NULL) {
1323                 status = U_MEMORY_ALLOCATION_ERROR;
1324                 break;
1325             }
1326 
1327             zarray[i][0].setTo(*tzid);
1328             tzNames-&gt;getDisplayNames(*tzid, TYPES, NUM_TYPES, now, zarray[i]+1, status);
1329             i++;
1330         }
1331 
1332     } while (FALSE);
1333 
1334     if (U_FAILURE(status)) {
1335         if (zarray) {
1336             for (int32_t i = 0; i &lt; rows; i++) {
</pre>
<hr />
<pre>
1485 // ResourceSink to enumerate all calendar resources
1486 struct CalendarDataSink : public ResourceSink {
1487 
1488     // Enum which specifies the type of alias received, or no alias
1489     enum AliasType {
1490         SAME_CALENDAR,
1491         DIFFERENT_CALENDAR,
1492         GREGORIAN,
1493         NONE
1494     };
1495 
1496     // Data structures to store resources from the current resource bundle
1497     Hashtable arrays;
1498     Hashtable arraySizes;
1499     Hashtable maps;
1500     /**
1501      * Whenever there are aliases, the same object will be added twice to &#39;map&#39;.
1502      * To avoid double deletion, &#39;maps&#39; won&#39;t take ownership of the objects. Instead,
1503      * &#39;mapRefs&#39; will own them and will delete them when CalendarDataSink is deleted.
1504      */
<span class="line-modified">1505     MemoryPool&lt;Hashtable&gt; mapRefs;</span>
1506 
1507     // Paths and the aliases they point to
1508     UVector aliasPathPairs;
1509 
1510     // Current and next calendar resource table which should be loaded
1511     UnicodeString currentCalendarType;
1512     UnicodeString nextCalendarType;
1513 
1514     // Resources to visit when enumerating fallback calendars
1515     LocalPointer&lt;UVector&gt; resourcesToVisit;
1516 
1517     // Alias&#39; relative path populated whenever an alias is read
1518     UnicodeString aliasRelativePath;
1519 
1520     // Initializes CalendarDataSink with default values
1521     CalendarDataSink(UErrorCode&amp; status)
1522     :   arrays(FALSE, status), arraySizes(FALSE, status), maps(FALSE, status),
<span class="line-modified">1523         mapRefs(),</span>
1524         aliasPathPairs(uprv_deleteUObject, uhash_compareUnicodeString, status),
1525         currentCalendarType(), nextCalendarType(),
1526         resourcesToVisit(NULL), aliasRelativePath() {
1527         if (U_FAILURE(status)) { return; }
1528     }
1529     virtual ~CalendarDataSink();
1530 
1531     // Configure the CalendarSink to visit all the resources
1532     void visitAllResources() {
1533         resourcesToVisit.adoptInstead(NULL);
1534     }
1535 
1536     // Actions to be done before enumerating
1537     void preEnumerate(const UnicodeString &amp;calendarType) {
1538         currentCalendarType = calendarType;
1539         nextCalendarType.setToBogus();
1540         aliasPathPairs.removeAllElements();
1541     }
1542 
1543     virtual void put(const char *key, ResourceValue &amp;value, UBool, UErrorCode &amp;errorCode) {
</pre>
<hr />
<pre>
1648                 } else if ((aliasMap = (Hashtable*)maps.get(*alias)) != NULL) {
1649                     UnicodeString *path = (UnicodeString*)aliasPathPairs[i + 1];
1650                     if (maps.get(*path) == NULL) {
1651                         maps.put(*path, aliasMap, errorCode);
1652                     }
1653                     if (U_FAILURE(errorCode)) { return; }
1654                     mod = true;
1655                 }
1656                 if (mod) {
1657                     aliasPathPairs.removeElementAt(i + 1);
1658                     aliasPathPairs.removeElementAt(i);
1659                     modified = true;
1660                 } else {
1661                     i += 2;
1662                 }
1663             }
1664         } while (modified &amp;&amp; !aliasPathPairs.isEmpty());
1665 
1666         // Set the resources to visit on the next calendar
1667         if (!resourcesToVisitNext.isNull()) {
<span class="line-modified">1668             resourcesToVisit = std::move(resourcesToVisitNext);</span>
1669         }
1670     }
1671 
1672     // Process the nested resource bundle tables
1673     void processResource(UnicodeString &amp;path, const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
1674         if (U_FAILURE(errorCode)) return;
1675 
1676         ResourceTable table = value.getTable(errorCode);
1677         if (U_FAILURE(errorCode)) return;
1678         Hashtable* stringMap = NULL;
1679 
1680         // Iterate over all the elements of the table and add them to the map
1681         for (int i = 0; table.getKeyAndValue(i, key, value); i++) {
1682             UnicodeString keyUString(key, -1, US_INV);
1683 
1684             // Ignore &#39;%variant&#39; keys
1685             if (keyUString.endsWith(kVariantTagUChar, UPRV_LENGTHOF(kVariantTagUChar))) {
1686                 continue;
1687             }
1688 
1689             // == Handle String elements ==
1690             if (value.getType() == URES_STRING) {
1691                 // We are on a leaf, store the map elements into the stringMap
1692                 if (i == 0) {
<span class="line-modified">1693                     // mapRefs will keep ownership of &#39;stringMap&#39;:</span>
<span class="line-modified">1694                     stringMap = mapRefs.create(FALSE, errorCode);</span>
<span class="line-added">1695                     if (stringMap == NULL) {</span>
<span class="line-added">1696                         errorCode = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="line-added">1697                         return;</span>
<span class="line-added">1698                     }</span>
1699                     maps.put(path, stringMap, errorCode);


1700                     if (U_FAILURE(errorCode)) { return; }


1701                     stringMap-&gt;setValueDeleter(uprv_deleteUObject);
1702                 }
1703                 U_ASSERT(stringMap != NULL);
1704                 int32_t valueStringSize;
1705                 const UChar *valueString = value.getString(valueStringSize, errorCode);
1706                 if (U_FAILURE(errorCode)) { return; }
1707                 LocalPointer&lt;UnicodeString&gt; valueUString(new UnicodeString(TRUE, valueString, valueStringSize), errorCode);
1708                 stringMap-&gt;put(keyUString, valueUString.orphan(), errorCode);
1709                 if (U_FAILURE(errorCode)) { return; }
1710                 continue;
1711             }
1712             U_ASSERT(stringMap == NULL);
1713 
1714             // Store the current path&#39;s length and append the current key to the path.
1715             int32_t pathLength = path.length();
1716             path.append(SOLIDUS).append(keyUString);
1717 
1718             // In cyclicNameSets ignore everything but years/format/abbreviated
1719             // and zodiacs/format/abbreviated
1720             if (path.startsWith(kCyclicNameSetsTagUChar, UPRV_LENGTHOF(kCyclicNameSetsTagUChar))) {
</pre>
<hr />
<pre>
1824                             return GREGORIAN;
1825                         } else if (nextCalendarType.isBogus()) {
1826                             nextCalendarType = aliasCalendarType;
1827                             return DIFFERENT_CALENDAR;
1828                         } else if (nextCalendarType == aliasCalendarType) {
1829                             return DIFFERENT_CALENDAR;
1830                         }
1831                     }
1832                 }
1833             }
1834             errorCode = U_INTERNAL_PROGRAM_ERROR;
1835             return NONE;
1836         }
1837         return NONE;
1838     }
1839 
1840     // Deleter function to be used by &#39;arrays&#39;
1841     static void U_CALLCONV deleteUnicodeStringArray(void *uArray) {
1842         delete[] static_cast&lt;UnicodeString *&gt;(uArray);
1843     }





1844 };
1845 // Virtual destructors have to be defined out of line
1846 CalendarDataSink::~CalendarDataSink() {
1847     arrays.setValueDeleter(deleteUnicodeStringArray);
1848 }
1849 }
1850 
1851 //------------------------------------------------------
1852 
1853 static void
1854 initField(UnicodeString **field, int32_t&amp; length, const UChar *data, LastResortSize numStr, LastResortSize strLen, UErrorCode &amp;status) {
1855     if (U_SUCCESS(status)) {
1856         length = numStr;
1857         *field = newUnicodeStringArray((size_t)numStr);
1858         if (*field) {
1859             for(int32_t i = 0; i&lt;length; i++) {
1860                 // readonly aliases - all &quot;data&quot; strings are constant
1861                 // -1 as length for variable-length strings (gLastResortDayNames[0] is empty)
1862                 (*(field)+i)-&gt;setTo(TRUE, data+(i*((int32_t)strLen)), -1);
1863             }
</pre>
<hr />
<pre>
2204 
2205     // Load context transforms and capitalization
2206     tempStatus = U_ZERO_ERROR;
2207     UResourceBundle *localeBundle = ures_open(NULL, locale.getName(), &amp;tempStatus);
2208     if (U_SUCCESS(tempStatus)) {
2209         UResourceBundle *contextTransforms = ures_getByKeyWithFallback(localeBundle, gContextTransformsTag, NULL, &amp;tempStatus);
2210         if (U_SUCCESS(tempStatus)) {
2211             UResourceBundle *contextTransformUsage;
2212             while ( (contextTransformUsage = ures_getNextResource(contextTransforms, NULL, &amp;tempStatus)) != NULL ) {
2213                 const int32_t * intVector = ures_getIntVector(contextTransformUsage, &amp;len, &amp;status);
2214                 if (U_SUCCESS(tempStatus) &amp;&amp; intVector != NULL &amp;&amp; len &gt;= 2) {
2215                     const char* usageType = ures_getKey(contextTransformUsage);
2216                     if (usageType != NULL) {
2217                         const ContextUsageTypeNameToEnumValue * typeMapPtr = contextUsageTypeMap;
2218                         int32_t compResult = 0;
2219                         // linear search; list is short and we cannot be sure that bsearch is available
2220                         while ( typeMapPtr-&gt;usageTypeName != NULL &amp;&amp; (compResult = uprv_strcmp(usageType, typeMapPtr-&gt;usageTypeName)) &gt; 0 ) {
2221                             ++typeMapPtr;
2222                         }
2223                         if (typeMapPtr-&gt;usageTypeName != NULL &amp;&amp; compResult == 0) {
<span class="line-modified">2224                             fCapitalization[typeMapPtr-&gt;usageTypeEnumValue][0] = static_cast&lt;UBool&gt;(intVector[0]);</span>
<span class="line-modified">2225                             fCapitalization[typeMapPtr-&gt;usageTypeEnumValue][1] = static_cast&lt;UBool&gt;(intVector[1]);</span>
2226                         }
2227                     }
2228                 }
2229                 tempStatus = U_ZERO_ERROR;
2230                 ures_close(contextTransformUsage);
2231             }
2232             ures_close(contextTransforms);
2233         }
2234 
2235         tempStatus = U_ZERO_ERROR;
2236         const LocalPointer&lt;NumberingSystem&gt; numberingSystem(
2237                 NumberingSystem::createInstance(locale, tempStatus), tempStatus);
2238         if (U_SUCCESS(tempStatus)) {
2239             // These functions all fail gracefully if passed NULL pointers and
2240             // do nothing unless U_SUCCESS(tempStatus), so it&#39;s only necessary
2241             // to check for errors once after all calls are made.
2242             const LocalUResourceBundlePointer numberElementsData(ures_getByKeyWithFallback(
2243                     localeBundle, gNumberElementsTag, NULL, &amp;tempStatus));
2244             const LocalUResourceBundlePointer nsNameData(ures_getByKeyWithFallback(
2245                     numberElementsData.getAlias(), numberingSystem-&gt;getName(), NULL, &amp;tempStatus));
</pre>
</td>
</tr>
</table>
<center><a href="double-conversion.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="dtitvfmt.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>