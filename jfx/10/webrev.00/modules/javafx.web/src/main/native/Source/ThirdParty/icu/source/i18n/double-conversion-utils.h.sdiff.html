<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/double-conversion-utils.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="double-conversion-ieee.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/double-conversion-utils.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20 //
 21 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 22 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 23 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 24 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 25 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 26 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 27 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 28 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 29 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 30 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 31 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32 
 33 // ICU PATCH: ifdef around UCONFIG_NO_FORMATTING
 34 #include &quot;unicode/utypes.h&quot;
 35 #if !UCONFIG_NO_FORMATTING
 36 
 37 #ifndef DOUBLE_CONVERSION_UTILS_H_
 38 #define DOUBLE_CONVERSION_UTILS_H_
 39 
<span class="line-modified"> 40 #include &lt;stdlib.h&gt;</span>
<span class="line-modified"> 41 #include &lt;string.h&gt;</span>
 42 
 43 // ICU PATCH: Use U_ASSERT instead of &lt;assert.h&gt;
 44 #include &quot;uassert.h&quot;
 45 #define ASSERT U_ASSERT
 46 
 47 #ifndef UNIMPLEMENTED
 48 #define UNIMPLEMENTED() (abort())
 49 #endif
 50 #ifndef DOUBLE_CONVERSION_NO_RETURN
 51 #ifdef _MSC_VER
 52 #define DOUBLE_CONVERSION_NO_RETURN __declspec(noreturn)
 53 #else
 54 #define DOUBLE_CONVERSION_NO_RETURN __attribute__((noreturn))
 55 #endif
 56 #endif
 57 #ifndef UNREACHABLE
 58 #ifdef _MSC_VER
 59 void DOUBLE_CONVERSION_NO_RETURN abort_noreturn();
 60 inline void abort_noreturn() { abort(); }
 61 #define UNREACHABLE()   (abort_noreturn())
 62 #else
 63 #define UNREACHABLE()   (abort())
 64 #endif
 65 #endif
 66 
 67 
 68 // Double operations detection based on target architecture.
 69 // Linux uses a 80bit wide floating point stack on x86. This induces double
 70 // rounding, which in turn leads to wrong results.
 71 // An easy way to test if the floating-point operations are correct is to
 72 // evaluate: 89255.0/1e22. If the floating-point stack is 64 bits wide then
 73 // the result is equal to 89255e-22.
 74 // The best way to test this, is to create a division-function and to compare
 75 // the output of the division with the expected result. (Inlining must be
 76 // disabled.)
 77 // On Linux,x86 89255e-22 != Div_double(89255.0/1e22)
<span class="line-modified"> 78 // ICU PATCH: Enable ARM32 &amp; ARM64 builds for Windows with &#39;defined(_M_ARM) || defined(_M_ARM64)&#39;.</span>















 79 #if defined(_M_X64) || defined(__x86_64__) || \
 80     defined(__ARMEL__) || defined(__avr32__) || defined(_M_ARM) || defined(_M_ARM64) || \
 81     defined(__hppa__) || defined(__ia64__) || \
 82     defined(__mips__) || \
 83     defined(__powerpc__) || defined(__ppc__) || defined(__ppc64__) || \
 84     defined(_POWER) || defined(_ARCH_PPC) || defined(_ARCH_PPC64) || \
 85     defined(__sparc__) || defined(__sparc) || defined(__s390__) || \
 86     defined(__SH4__) || defined(__alpha__) || \
 87     defined(_MIPS_ARCH_MIPS32R2) || \
<span class="line-modified"> 88     defined(__AARCH64EL__) || defined(__aarch64__) || \</span>
<span class="line-modified"> 89     defined(__riscv)</span>


 90 #define DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS 1
<span class="line-modified"> 91 #elif defined(__mc68000__)</span>

 92 #undef DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
 93 #elif defined(_M_IX86) || defined(__i386__) || defined(__i386)
 94 #if defined(_WIN32)
 95 // Windows uses a 64bit wide floating point stack.
 96 #define DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS 1
 97 #else
 98 #undef DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
 99 #endif  // _WIN32
100 #else
101 #error Target architecture was not detected as supported by Double-Conversion.
102 #endif
103 
<span class="line-removed">104 #if defined(__GNUC__)</span>
<span class="line-removed">105 #define DOUBLE_CONVERSION_UNUSED __attribute__((unused))</span>
<span class="line-removed">106 #else</span>
<span class="line-removed">107 #define DOUBLE_CONVERSION_UNUSED</span>
<span class="line-removed">108 #endif</span>
<span class="line-removed">109 </span>
110 #if defined(_WIN32) &amp;&amp; !defined(__MINGW32__)
111 
112 typedef signed char int8_t;
113 typedef unsigned char uint8_t;
114 typedef short int16_t;  // NOLINT
115 typedef unsigned short uint16_t;  // NOLINT
116 typedef int int32_t;
117 typedef unsigned int uint32_t;
118 typedef __int64 int64_t;
119 typedef unsigned __int64 uint64_t;
120 // intptr_t and friends are defined in crtdefs.h through stdio.h.
121 
122 #else
123 
124 #include &lt;stdint.h&gt;
125 
126 #endif
127 
128 typedef uint16_t uc16;
129 
130 // The following macro works on both 32 and 64-bit platforms.
131 // Usage: instead of writing 0x1234567890123456
132 //      write UINT64_2PART_C(0x12345678,90123456);
133 #define UINT64_2PART_C(a, b) (((static_cast&lt;uint64_t&gt;(a) &lt;&lt; 32) + 0x##b##u))
134 
135 
136 // The expression ARRAY_SIZE(a) is a compile-time constant of type
137 // size_t which represents the number of elements of the given
138 // array. You should only use ARRAY_SIZE on statically allocated
139 // arrays.
140 #ifndef ARRAY_SIZE
141 #define ARRAY_SIZE(a)                                   \
142   ((sizeof(a) / sizeof(*(a))) /                         \
143   static_cast&lt;size_t&gt;(!(sizeof(a) % sizeof(*(a)))))
144 #endif
145 
146 // A macro to disallow the evil copy constructor and operator= functions
147 // This should be used in the private: declarations for a class
<span class="line-modified">148 #ifndef DISALLOW_COPY_AND_ASSIGN</span>
<span class="line-modified">149 #define DISALLOW_COPY_AND_ASSIGN(TypeName)      \</span>
150   TypeName(const TypeName&amp;);                    \
151   void operator=(const TypeName&amp;)
152 #endif
153 
154 // A macro to disallow all the implicit constructors, namely the
155 // default constructor, copy constructor and operator= functions.
156 //
157 // This should be used in the private: declarations for a class
158 // that wants to prevent anyone from instantiating it. This is
159 // especially useful for classes containing only static methods.
<span class="line-modified">160 #ifndef DISALLOW_IMPLICIT_CONSTRUCTORS</span>
<span class="line-modified">161 #define DISALLOW_IMPLICIT_CONSTRUCTORS(TypeName) \</span>
162   TypeName();                                    \
<span class="line-modified">163   DISALLOW_COPY_AND_ASSIGN(TypeName)</span>
164 #endif
165 
166 // ICU PATCH: Wrap in ICU namespace
167 U_NAMESPACE_BEGIN
168 
169 namespace double_conversion {
170 
171 static const int kCharSize = sizeof(char);
172 
173 // Returns the maximum of the two parameters.
174 template &lt;typename T&gt;
175 static T Max(T a, T b) {
176   return a &lt; b ? b : a;
177 }
178 
179 
180 // Returns the minimum of the two parameters.
181 template &lt;typename T&gt;
182 static T Min(T a, T b) {
183   return a &lt; b ? a : b;
</pre>
<hr />
<pre>
288   }
289 
290   // Finalize the string by 0-terminating it and returning the buffer.
291   char* Finalize() {
292     ASSERT(!is_finalized() &amp;&amp; position_ &lt; buffer_.length());
293     buffer_[position_] = &#39;\0&#39;;
294     // Make sure nobody managed to add a 0-character to the
295     // buffer while building the string.
296     ASSERT(strlen(buffer_.start()) == static_cast&lt;size_t&gt;(position_));
297     position_ = -1;
298     ASSERT(is_finalized());
299     return buffer_.start();
300   }
301 
302  private:
303   Vector&lt;char&gt; buffer_;
304   int position_;
305 
306   bool is_finalized() const { return position_ &lt; 0; }
307 
<span class="line-modified">308   DISALLOW_IMPLICIT_CONSTRUCTORS(StringBuilder);</span>
309 };
310 
311 // The type-based aliasing rule allows the compiler to assume that pointers of
312 // different types (for some definition of different) never alias each other.
313 // Thus the following code does not work:
314 //
315 // float f = foo();
316 // int fbits = *(int*)(&amp;f);
317 //
318 // The compiler &#39;knows&#39; that the int pointer can&#39;t refer to f since the types
319 // don&#39;t match, so the compiler may cache f in a register, leaving random data
320 // in fbits.  Using C++ style casts makes no difference, however a pointer to
321 // char data is assumed to alias any other pointer.  This is the &#39;memcpy
322 // exception&#39;.
323 //
324 // Bit_cast uses the memcpy exception to move the bits from a variable of one
325 // type of a variable of another type.  Of course the end result is likely to
326 // be implementation dependent.  Most compilers (gcc-4.2 and MSVC 2005)
327 // will completely optimize BitCast away.
328 //
329 // There is an additional use for BitCast.
330 // Recent gccs will warn when they see casts that may result in breakage due to
331 // the type-based aliasing rule.  If you have checked that there is no breakage
332 // you can use BitCast to cast one pointer type to another.  This confuses gcc
333 // enough that it can no longer see that you have cast one pointer type to
334 // another thus avoiding the warning.
335 template &lt;class Dest, class Source&gt;
336 inline Dest BitCast(const Source&amp; source) {
337   // Compile time assertion: sizeof(Dest) == sizeof(Source)
338   // A compile error here means your Dest and Source have different sizes.
<span class="line-modified">339   DOUBLE_CONVERSION_UNUSED</span>
<span class="line-modified">340       typedef char VerifySizesAreEqual[sizeof(Dest) == sizeof(Source) ? 1 : -1];</span>




341 
342   Dest dest;
343   memmove(&amp;dest, &amp;source, sizeof(dest));
344   return dest;
345 }
346 
347 template &lt;class Dest, class Source&gt;
348 inline Dest BitCast(Source* source) {
349   return BitCast&lt;Dest&gt;(reinterpret_cast&lt;uintptr_t&gt;(source));
350 }
351 
352 }  // namespace double_conversion
353 
354 // ICU PATCH: Close ICU namespace
355 U_NAMESPACE_END
356 
357 #endif  // DOUBLE_CONVERSION_UTILS_H_
358 #endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING
</pre>
</td>
<td>
<hr />
<pre>
 20 //
 21 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 22 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 23 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 24 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 25 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 26 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 27 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 28 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 29 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 30 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 31 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32 
 33 // ICU PATCH: ifdef around UCONFIG_NO_FORMATTING
 34 #include &quot;unicode/utypes.h&quot;
 35 #if !UCONFIG_NO_FORMATTING
 36 
 37 #ifndef DOUBLE_CONVERSION_UTILS_H_
 38 #define DOUBLE_CONVERSION_UTILS_H_
 39 
<span class="line-modified"> 40 #include &lt;cstdlib&gt;</span>
<span class="line-modified"> 41 #include &lt;cstring&gt;</span>
 42 
 43 // ICU PATCH: Use U_ASSERT instead of &lt;assert.h&gt;
 44 #include &quot;uassert.h&quot;
 45 #define ASSERT U_ASSERT
 46 
 47 #ifndef UNIMPLEMENTED
 48 #define UNIMPLEMENTED() (abort())
 49 #endif
 50 #ifndef DOUBLE_CONVERSION_NO_RETURN
 51 #ifdef _MSC_VER
 52 #define DOUBLE_CONVERSION_NO_RETURN __declspec(noreturn)
 53 #else
 54 #define DOUBLE_CONVERSION_NO_RETURN __attribute__((noreturn))
 55 #endif
 56 #endif
 57 #ifndef UNREACHABLE
 58 #ifdef _MSC_VER
 59 void DOUBLE_CONVERSION_NO_RETURN abort_noreturn();
 60 inline void abort_noreturn() { abort(); }
 61 #define UNREACHABLE()   (abort_noreturn())
 62 #else
 63 #define UNREACHABLE()   (abort())
 64 #endif
 65 #endif
 66 
 67 
 68 // Double operations detection based on target architecture.
 69 // Linux uses a 80bit wide floating point stack on x86. This induces double
 70 // rounding, which in turn leads to wrong results.
 71 // An easy way to test if the floating-point operations are correct is to
 72 // evaluate: 89255.0/1e22. If the floating-point stack is 64 bits wide then
 73 // the result is equal to 89255e-22.
 74 // The best way to test this, is to create a division-function and to compare
 75 // the output of the division with the expected result. (Inlining must be
 76 // disabled.)
 77 // On Linux,x86 89255e-22 != Div_double(89255.0/1e22)
<span class="line-modified"> 78 //</span>
<span class="line-added"> 79 // For example:</span>
<span class="line-added"> 80 /*</span>
<span class="line-added"> 81 // -- in div.c</span>
<span class="line-added"> 82 double Div_double(double x, double y) { return x / y; }</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 // -- in main.c</span>
<span class="line-added"> 85 double Div_double(double x, double y);  // Forward declaration.</span>
<span class="line-added"> 86 </span>
<span class="line-added"> 87 int main(int argc, char** argv) {</span>
<span class="line-added"> 88   return Div_double(89255.0, 1e22) == 89255e-22;</span>
<span class="line-added"> 89 }</span>
<span class="line-added"> 90 */</span>
<span class="line-added"> 91 // Run as follows ./main || echo &quot;correct&quot;</span>
<span class="line-added"> 92 //</span>
<span class="line-added"> 93 // If it prints &quot;correct&quot; then the architecture should be here, in the &quot;correct&quot; section.</span>
 94 #if defined(_M_X64) || defined(__x86_64__) || \
 95     defined(__ARMEL__) || defined(__avr32__) || defined(_M_ARM) || defined(_M_ARM64) || \
 96     defined(__hppa__) || defined(__ia64__) || \
 97     defined(__mips__) || \
 98     defined(__powerpc__) || defined(__ppc__) || defined(__ppc64__) || \
 99     defined(_POWER) || defined(_ARCH_PPC) || defined(_ARCH_PPC64) || \
100     defined(__sparc__) || defined(__sparc) || defined(__s390__) || \
101     defined(__SH4__) || defined(__alpha__) || \
102     defined(_MIPS_ARCH_MIPS32R2) || \
<span class="line-modified">103     defined(__AARCH64EL__) || defined(__aarch64__) || defined(__AARCH64EB__) || \</span>
<span class="line-modified">104     defined(__riscv) || \</span>
<span class="line-added">105     defined(__or1k__) || defined(__arc__) || \</span>
<span class="line-added">106     defined(__EMSCRIPTEN__)</span>
107 #define DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS 1
<span class="line-modified">108 #elif defined(__mc68000__) || \</span>
<span class="line-added">109     defined(__pnacl__) || defined(__native_client__)</span>
110 #undef DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
111 #elif defined(_M_IX86) || defined(__i386__) || defined(__i386)
112 #if defined(_WIN32)
113 // Windows uses a 64bit wide floating point stack.
114 #define DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS 1
115 #else
116 #undef DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
117 #endif  // _WIN32
118 #else
119 #error Target architecture was not detected as supported by Double-Conversion.
120 #endif
121 






122 #if defined(_WIN32) &amp;&amp; !defined(__MINGW32__)
123 
124 typedef signed char int8_t;
125 typedef unsigned char uint8_t;
126 typedef short int16_t;  // NOLINT
127 typedef unsigned short uint16_t;  // NOLINT
128 typedef int int32_t;
129 typedef unsigned int uint32_t;
130 typedef __int64 int64_t;
131 typedef unsigned __int64 uint64_t;
132 // intptr_t and friends are defined in crtdefs.h through stdio.h.
133 
134 #else
135 
136 #include &lt;stdint.h&gt;
137 
138 #endif
139 
140 typedef uint16_t uc16;
141 
142 // The following macro works on both 32 and 64-bit platforms.
143 // Usage: instead of writing 0x1234567890123456
144 //      write UINT64_2PART_C(0x12345678,90123456);
145 #define UINT64_2PART_C(a, b) (((static_cast&lt;uint64_t&gt;(a) &lt;&lt; 32) + 0x##b##u))
146 
147 
148 // The expression ARRAY_SIZE(a) is a compile-time constant of type
149 // size_t which represents the number of elements of the given
150 // array. You should only use ARRAY_SIZE on statically allocated
151 // arrays.
152 #ifndef ARRAY_SIZE
153 #define ARRAY_SIZE(a)                                   \
154   ((sizeof(a) / sizeof(*(a))) /                         \
155   static_cast&lt;size_t&gt;(!(sizeof(a) % sizeof(*(a)))))
156 #endif
157 
158 // A macro to disallow the evil copy constructor and operator= functions
159 // This should be used in the private: declarations for a class
<span class="line-modified">160 #ifndef DC_DISALLOW_COPY_AND_ASSIGN</span>
<span class="line-modified">161 #define DC_DISALLOW_COPY_AND_ASSIGN(TypeName)      \</span>
162   TypeName(const TypeName&amp;);                    \
163   void operator=(const TypeName&amp;)
164 #endif
165 
166 // A macro to disallow all the implicit constructors, namely the
167 // default constructor, copy constructor and operator= functions.
168 //
169 // This should be used in the private: declarations for a class
170 // that wants to prevent anyone from instantiating it. This is
171 // especially useful for classes containing only static methods.
<span class="line-modified">172 #ifndef DC_DISALLOW_IMPLICIT_CONSTRUCTORS</span>
<span class="line-modified">173 #define DC_DISALLOW_IMPLICIT_CONSTRUCTORS(TypeName) \</span>
174   TypeName();                                    \
<span class="line-modified">175   DC_DISALLOW_COPY_AND_ASSIGN(TypeName)</span>
176 #endif
177 
178 // ICU PATCH: Wrap in ICU namespace
179 U_NAMESPACE_BEGIN
180 
181 namespace double_conversion {
182 
183 static const int kCharSize = sizeof(char);
184 
185 // Returns the maximum of the two parameters.
186 template &lt;typename T&gt;
187 static T Max(T a, T b) {
188   return a &lt; b ? b : a;
189 }
190 
191 
192 // Returns the minimum of the two parameters.
193 template &lt;typename T&gt;
194 static T Min(T a, T b) {
195   return a &lt; b ? a : b;
</pre>
<hr />
<pre>
300   }
301 
302   // Finalize the string by 0-terminating it and returning the buffer.
303   char* Finalize() {
304     ASSERT(!is_finalized() &amp;&amp; position_ &lt; buffer_.length());
305     buffer_[position_] = &#39;\0&#39;;
306     // Make sure nobody managed to add a 0-character to the
307     // buffer while building the string.
308     ASSERT(strlen(buffer_.start()) == static_cast&lt;size_t&gt;(position_));
309     position_ = -1;
310     ASSERT(is_finalized());
311     return buffer_.start();
312   }
313 
314  private:
315   Vector&lt;char&gt; buffer_;
316   int position_;
317 
318   bool is_finalized() const { return position_ &lt; 0; }
319 
<span class="line-modified">320   DC_DISALLOW_IMPLICIT_CONSTRUCTORS(StringBuilder);</span>
321 };
322 
323 // The type-based aliasing rule allows the compiler to assume that pointers of
324 // different types (for some definition of different) never alias each other.
325 // Thus the following code does not work:
326 //
327 // float f = foo();
328 // int fbits = *(int*)(&amp;f);
329 //
330 // The compiler &#39;knows&#39; that the int pointer can&#39;t refer to f since the types
331 // don&#39;t match, so the compiler may cache f in a register, leaving random data
332 // in fbits.  Using C++ style casts makes no difference, however a pointer to
333 // char data is assumed to alias any other pointer.  This is the &#39;memcpy
334 // exception&#39;.
335 //
336 // Bit_cast uses the memcpy exception to move the bits from a variable of one
337 // type of a variable of another type.  Of course the end result is likely to
338 // be implementation dependent.  Most compilers (gcc-4.2 and MSVC 2005)
339 // will completely optimize BitCast away.
340 //
341 // There is an additional use for BitCast.
342 // Recent gccs will warn when they see casts that may result in breakage due to
343 // the type-based aliasing rule.  If you have checked that there is no breakage
344 // you can use BitCast to cast one pointer type to another.  This confuses gcc
345 // enough that it can no longer see that you have cast one pointer type to
346 // another thus avoiding the warning.
347 template &lt;class Dest, class Source&gt;
348 inline Dest BitCast(const Source&amp; source) {
349   // Compile time assertion: sizeof(Dest) == sizeof(Source)
350   // A compile error here means your Dest and Source have different sizes.
<span class="line-modified">351 #if __cplusplus &gt;= 201103L</span>
<span class="line-modified">352   static_assert(sizeof(Dest) == sizeof(Source),</span>
<span class="line-added">353                 &quot;source and destination size mismatch&quot;);</span>
<span class="line-added">354 #else</span>
<span class="line-added">355   typedef char VerifySizesAreEqual[sizeof(Dest) == sizeof(Source) ? 1 : -1];</span>
<span class="line-added">356 #endif</span>
357 
358   Dest dest;
359   memmove(&amp;dest, &amp;source, sizeof(dest));
360   return dest;
361 }
362 
363 template &lt;class Dest, class Source&gt;
364 inline Dest BitCast(Source* source) {
365   return BitCast&lt;Dest&gt;(reinterpret_cast&lt;uintptr_t&gt;(source));
366 }
367 
368 }  // namespace double_conversion
369 
370 // ICU PATCH: Close ICU namespace
371 U_NAMESPACE_END
372 
373 #endif  // DOUBLE_CONVERSION_UTILS_H_
374 #endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING
</pre>
</td>
</tr>
</table>
<center><a href="double-conversion-ieee.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>