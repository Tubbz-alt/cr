<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/formattedvalue.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2018 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 
  4 #ifndef __FORMATTEDVALUE_H__
  5 #define __FORMATTEDVALUE_H__
  6 
  7 #include &quot;unicode/utypes.h&quot;
  8 #if !UCONFIG_NO_FORMATTING
  9 #ifndef U_HIDE_DRAFT_API
 10 
 11 #include &quot;unicode/appendable.h&quot;
 12 #include &quot;unicode/fpositer.h&quot;
 13 #include &quot;unicode/unistr.h&quot;
 14 #include &quot;unicode/uformattedvalue.h&quot;
 15 
 16 U_NAMESPACE_BEGIN
 17 
 18 /**
 19  * \file
 20  * \brief C++ API: Abstract operations for localized strings.
 21  *
 22  * This file contains declarations for classes that deal with formatted strings. A number
 23  * of APIs throughout ICU use these classes for expressing their localized output.
 24  */
 25 
 26 
 27 /**
 28  * Represents a span of a string containing a given field.
 29  *
 30  * This class differs from FieldPosition in the following ways:
 31  *
 32  *   1. It has information on the field category.
 33  *   2. It allows you to set constraints to use when iterating over field positions.
 34  *   3. It is used for the newer FormattedValue APIs.
 35  *
 36  * This class is not intended for public subclassing.
 37  *
 38  * @draft ICU 64
 39  */
 40 class U_I18N_API ConstrainedFieldPosition : public UMemory {
 41   public:
 42 
 43     /**
 44      * Initializes a ConstrainedFieldPosition.
 45      *
 46      * By default, the ConstrainedFieldPosition has no iteration constraints.
 47      *
 48      * @draft ICU 64
 49      */
 50     ConstrainedFieldPosition();
 51 
 52     /** @draft ICU 64 */
 53     ~ConstrainedFieldPosition();
 54 
 55     /**
 56      * Resets this ConstrainedFieldPosition to its initial state, as if it were newly created:
 57      *
 58      * - Removes any constraints that may have been set on the instance.
 59      * - Resets the iteration position.
 60      *
 61      * @draft ICU 64
 62      */
 63     void reset();
 64 
 65     /**
 66      * Sets a constraint on the field category.
 67      *
 68      * When this instance of ConstrainedFieldPosition is passed to FormattedValue#nextPosition,
 69      * positions are skipped unless they have the given category.
 70      *
 71      * Any previously set constraints are cleared.
 72      *
 73      * For example, to loop over only the number-related fields:
 74      *
 75      *     ConstrainedFieldPosition cfpos;
 76      *     cfpos.constrainCategory(UFIELDCATEGORY_NUMBER_FORMAT);
 77      *     while (fmtval.nextPosition(cfpos, status)) {
 78      *         // handle the number-related field position
 79      *     }
 80      *
 81      * Changing the constraint while in the middle of iterating over a FormattedValue
 82      * does not generally have well-defined behavior.
 83      *
 84      * @param category The field category to fix when iterating.
 85      * @draft ICU 64
 86      */
 87     void constrainCategory(int32_t category);
 88 
 89     /**
 90      * Sets a constraint on the category and field.
 91      *
 92      * When this instance of ConstrainedFieldPosition is passed to FormattedValue#nextPosition,
 93      * positions are skipped unless they have the given category and field.
 94      *
 95      * Any previously set constraints are cleared.
 96      *
 97      * For example, to loop over all grouping separators:
 98      *
 99      *     ConstrainedFieldPosition cfpos;
100      *     cfpos.constrainField(UFIELDCATEGORY_NUMBER_FORMAT, UNUM_GROUPING_SEPARATOR_FIELD);
101      *     while (fmtval.nextPosition(cfpos, status)) {
102      *         // handle the grouping separator position
103      *     }
104      *
105      * Changing the constraint while in the middle of iterating over a FormattedValue
106      * does not generally have well-defined behavior.
107      *
108      * @param category The field category to fix when iterating.
109      * @param field The field to fix when iterating.
110      * @draft ICU 64
111      */
112     void constrainField(int32_t category, int32_t field);
113 
114     /**
115      * Gets the field category for the current position.
116      *
117      * The return value is well-defined only after
118      * FormattedValue#nextPosition returns TRUE.
119      *
120      * @return The field category saved in the instance.
121      * @draft ICU 64
122      */
123     inline int32_t getCategory() const {
124         return fCategory;
125     }
126 
127     /**
128      * Gets the field for the current position.
129      *
130      * The return value is well-defined only after
131      * FormattedValue#nextPosition returns TRUE.
132      *
133      * @return The field saved in the instance.
134      * @draft ICU 64
135      */
136     inline int32_t getField() const {
137         return fField;
138     }
139 
140     /**
141      * Gets the INCLUSIVE start index for the current position.
142      *
143      * The return value is well-defined only after FormattedValue#nextPosition returns TRUE.
144      *
145      * @return The start index saved in the instance.
146      * @draft ICU 64
147      */
148     inline int32_t getStart() const {
149         return fStart;
150     }
151 
152     /**
153      * Gets the EXCLUSIVE end index stored for the current position.
154      *
155      * The return value is well-defined only after FormattedValue#nextPosition returns TRUE.
156      *
157      * @return The end index saved in the instance.
158      * @draft ICU 64
159      */
160     inline int32_t getLimit() const {
161         return fLimit;
162     }
163 
164     ////////////////////////////////////////////////////////////////////
165     //// The following methods are for FormattedValue implementers; ////
166     //// most users can ignore them.                                ////
167     ////////////////////////////////////////////////////////////////////
168 
169     /**
170      * Gets an int64 that FormattedValue implementations may use for storage.
171      *
172      * The initial value is zero.
173      *
174      * Users of FormattedValue should not need to call this method.
175      *
176      * @return The current iteration context from {@link #setInt64IterationContext}.
177      * @draft ICU 64
178      */
179     inline int64_t getInt64IterationContext() const {
180         return fContext;
181     }
182 
183     /**
184      * Sets an int64 that FormattedValue implementations may use for storage.
185      *
186      * Intended to be used by FormattedValue implementations.
187      *
188      * @param context The new iteration context.
189      * @draft ICU 64
190      */
191     void setInt64IterationContext(int64_t context);
192 
193     /**
194      * Determines whether a given field should be included given the
195      * constraints.
196      *
197      * Intended to be used by FormattedValue implementations.
198      *
199      * @param category The category to test.
200      * @param field The field to test.
201      * @draft ICU 64
202      */
203     UBool matchesField(int32_t category, int32_t field) const;
204 
205     /**
206      * Sets new values for the primary public getters.
207      *
208      * Intended to be used by FormattedValue implementations.
209      *
210      * It is up to the implementation to ensure that the user-requested
211      * constraints are satisfied. This method does not check!
212      *
213      * @param category The new field category.
214      * @param field The new field.
215      * @param start The new inclusive start index.
216      * @param limit The new exclusive end index.
217      * @draft ICU 64
218      */
219     void setState(
220         int32_t category,
221         int32_t field,
222         int32_t start,
223         int32_t limit);
224 
225   private:
226     int64_t fContext = 0LL;
227     int32_t fField = 0;
228     int32_t fStart = 0;
229     int32_t fLimit = 0;
230     int32_t fCategory = UFIELD_CATEGORY_UNDEFINED;
231     int8_t fConstraint = 0;
232 };
233 
234 
235 /**
236  * An abstract formatted value: a string with associated field attributes.
237  * Many formatters format to classes implementing FormattedValue.
238  *
239  * @draft ICU 64
240  */
241 class U_I18N_API FormattedValue /* not : public UObject because this is an interface/mixin class */ {
242   public:
243     /** @draft ICU 64 */
244     virtual ~FormattedValue();
245 
246     /**
247      * Returns the formatted string as a self-contained UnicodeString.
248      *
249      * If you need the string within the current scope only, consider #toTempString.
250      *
251      * @param status Set if an error occurs.
252      * @return a UnicodeString containing the formatted string.
253      *
254      * @draft ICU 64
255      */
256     virtual UnicodeString toString(UErrorCode&amp; status) const = 0;
257 
258     /**
259      * Returns the formatted string as a read-only alias to memory owned by the FormattedValue.
260      *
261      * The return value is valid only as long as this FormattedValue is present and unchanged in
262      * memory. If you need the string outside the current scope, consider #toString.
263      *
264      * The buffer returned by calling UnicodeString#getBuffer() on the return value is
265      * guaranteed to be NUL-terminated.
266      *
267      * @param status Set if an error occurs.
268      * @return a temporary UnicodeString containing the formatted string.
269      *
270      * @draft ICU 64
271      */
272     virtual UnicodeString toTempString(UErrorCode&amp; status) const = 0;
273 
274     /**
275      * Appends the formatted string to an Appendable.
276      *
277      * @param appendable
278      *         The Appendable to which to append the string output.
279      * @param status Set if an error occurs.
280      * @return The same Appendable, for chaining.
281      *
282      * @draft ICU 64
283      * @see Appendable
284      */
285     virtual Appendable&amp; appendTo(Appendable&amp; appendable, UErrorCode&amp; status) const = 0;
286 
287     /**
288      * Iterates over field positions in the FormattedValue. This lets you determine the position
289      * of specific types of substrings, like a month or a decimal separator.
290      *
291      * To loop over all field positions:
292      *
293      *     ConstrainedFieldPosition cfpos;
294      *     while (fmtval.nextPosition(cfpos, status)) {
295      *         // handle the field position; get information from cfpos
296      *     }
297      *
298      * @param cfpos
299      *         The object used for iteration state. This can provide constraints to iterate over
300      *         only one specific category or field;
301      *         see ConstrainedFieldPosition#constrainCategory
302      *         and ConstrainedFieldPosition#constrainField.
303      * @param status Set if an error occurs.
304      * @return TRUE if a new occurrence of the field was found;
305      *         FALSE otherwise or if an error was set.
306      *
307      * @draft ICU 64
308      */
309     virtual UBool nextPosition(ConstrainedFieldPosition&amp; cfpos, UErrorCode&amp; status) const = 0;
310 };
311 
312 
313 U_NAMESPACE_END
314 
315 #endif  /* U_HIDE_DRAFT_API */
316 #endif /* #if !UCONFIG_NO_FORMATTING */
317 #endif // __FORMATTEDVALUE_H__
    </pre>
  </body>
</html>