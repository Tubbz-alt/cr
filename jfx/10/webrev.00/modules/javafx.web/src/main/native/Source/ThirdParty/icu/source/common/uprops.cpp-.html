<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/uprops.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Â© 2016 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 /*
  4 *******************************************************************************
  5 *
  6 *   Copyright (C) 2002-2016, International Business Machines
  7 *   Corporation and others.  All Rights Reserved.
  8 *
  9 *******************************************************************************
 10 *   file name:  uprops.cpp
 11 *   encoding:   UTF-8
 12 *   tab size:   8 (not used)
 13 *   indentation:4
 14 *
 15 *   created on: 2002feb24
 16 *   created by: Markus W. Scherer
 17 *
 18 *   Implementations for mostly non-core Unicode character properties
 19 *   stored in uprops.icu.
 20 *
 21 *   With the APIs implemented here, almost all properties files and
 22 *   their associated implementation files are used from this file,
 23 *   including those for normalization and case mappings.
 24 */
 25 
 26 #include &quot;unicode/utypes.h&quot;
 27 #include &quot;unicode/uchar.h&quot;
 28 #include &quot;unicode/unorm2.h&quot;
 29 #include &quot;unicode/uscript.h&quot;
 30 #include &quot;unicode/ustring.h&quot;
 31 #include &quot;cstring.h&quot;
 32 #include &quot;normalizer2impl.h&quot;
 33 #include &quot;umutex.h&quot;
 34 #include &quot;ubidi_props.h&quot;
 35 #include &quot;uprops.h&quot;
 36 #include &quot;ucase.h&quot;
 37 #include &quot;ustr_imp.h&quot;
 38 
 39 U_NAMESPACE_USE
 40 
 41 /* general properties API functions ----------------------------------------- */
 42 
 43 struct BinaryProperty;
 44 
 45 typedef UBool BinaryPropertyContains(const BinaryProperty &amp;prop, UChar32 c, UProperty which);
 46 
 47 struct BinaryProperty {
 48     int32_t column;  // SRC_PROPSVEC column, or &quot;source&quot; if mask==0
 49     uint32_t mask;
 50     BinaryPropertyContains *contains;
 51 };
 52 
 53 static UBool defaultContains(const BinaryProperty &amp;prop, UChar32 c, UProperty /*which*/) {
 54     /* systematic, directly stored properties */
 55     return (u_getUnicodeProperties(c, prop.column)&amp;prop.mask)!=0;
 56 }
 57 
 58 static UBool caseBinaryPropertyContains(const BinaryProperty &amp;/*prop*/, UChar32 c, UProperty which) {
 59     return ucase_hasBinaryProperty(c, which);
 60 }
 61 
 62 static UBool isBidiControl(const BinaryProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
 63     return ubidi_isBidiControl(c);
 64 }
 65 
 66 static UBool isMirrored(const BinaryProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
 67     return ubidi_isMirrored(c);
 68 }
 69 
 70 static UBool isJoinControl(const BinaryProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
 71     return ubidi_isJoinControl(c);
 72 }
 73 
 74 #if UCONFIG_NO_NORMALIZATION
 75 static UBool hasFullCompositionExclusion(const BinaryProperty &amp;, UChar32, UProperty) {
 76     return FALSE;
 77 }
 78 #else
 79 static UBool hasFullCompositionExclusion(const BinaryProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
 80     // By definition, Full_Composition_Exclusion is the same as NFC_QC=No.
 81     UErrorCode errorCode=U_ZERO_ERROR;
 82     const Normalizer2Impl *impl=Normalizer2Factory::getNFCImpl(errorCode);
 83     return U_SUCCESS(errorCode) &amp;&amp; impl-&gt;isCompNo(impl-&gt;getNorm16(c));
 84 }
 85 #endif
 86 
 87 // UCHAR_NF*_INERT properties
 88 #if UCONFIG_NO_NORMALIZATION
 89 static UBool isNormInert(const BinaryProperty &amp;, UChar32, UProperty) {
 90     return FALSE;
 91 }
 92 #else
 93 static UBool isNormInert(const BinaryProperty &amp;/*prop*/, UChar32 c, UProperty which) {
 94     UErrorCode errorCode=U_ZERO_ERROR;
 95     const Normalizer2 *norm2=Normalizer2Factory::getInstance(
 96         (UNormalizationMode)(which-UCHAR_NFD_INERT+UNORM_NFD), errorCode);
 97     return U_SUCCESS(errorCode) &amp;&amp; norm2-&gt;isInert(c);
 98 }
 99 #endif
100 
101 #if UCONFIG_NO_NORMALIZATION
102 static UBool changesWhenCasefolded(const BinaryProperty &amp;, UChar32, UProperty) {
103     return FALSE;
104 }
105 #else
106 static UBool changesWhenCasefolded(const BinaryProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
107     UnicodeString nfd;
108     UErrorCode errorCode=U_ZERO_ERROR;
109     const Normalizer2 *nfcNorm2=Normalizer2::getNFCInstance(errorCode);
110     if(U_FAILURE(errorCode)) {
111         return FALSE;
112     }
113     if(nfcNorm2-&gt;getDecomposition(c, nfd)) {
114         /* c has a decomposition */
115         if(nfd.length()==1) {
116             c=nfd[0];  /* single BMP code point */
117         } else if(nfd.length()&lt;=U16_MAX_LENGTH &amp;&amp;
118                   nfd.length()==U16_LENGTH(c=nfd.char32At(0))
119         ) {
120             /* single supplementary code point */
121         } else {
122             c=U_SENTINEL;
123         }
124     } else if(c&lt;0) {
125         return FALSE;  /* protect against bad input */
126     }
127     if(c&gt;=0) {
128         /* single code point */
129         const UChar *resultString;
130         return (UBool)(ucase_toFullFolding(c, &amp;resultString, U_FOLD_CASE_DEFAULT)&gt;=0);
131     } else {
132         /* guess some large but stack-friendly capacity */
133         UChar dest[2*UCASE_MAX_STRING_LENGTH];
134         int32_t destLength;
135         destLength=u_strFoldCase(dest, UPRV_LENGTHOF(dest),
136                                   nfd.getBuffer(), nfd.length(),
137                                   U_FOLD_CASE_DEFAULT, &amp;errorCode);
138         return (UBool)(U_SUCCESS(errorCode) &amp;&amp;
139                        0!=u_strCompare(nfd.getBuffer(), nfd.length(),
140                                        dest, destLength, FALSE));
141     }
142 }
143 #endif
144 
145 #if UCONFIG_NO_NORMALIZATION
146 static UBool changesWhenNFKC_Casefolded(const BinaryProperty &amp;, UChar32, UProperty) {
147     return FALSE;
148 }
149 #else
150 static UBool changesWhenNFKC_Casefolded(const BinaryProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
151     UErrorCode errorCode=U_ZERO_ERROR;
152     const Normalizer2Impl *kcf=Normalizer2Factory::getNFKC_CFImpl(errorCode);
153     if(U_FAILURE(errorCode)) {
154         return FALSE;
155     }
156     UnicodeString src(c);
157     UnicodeString dest;
158     {
159         // The ReorderingBuffer must be in a block because its destructor
160         // needs to release dest&#39;s buffer before we look at its contents.
161         ReorderingBuffer buffer(*kcf, dest);
162         // Small destCapacity for NFKC_CF(c).
163         if(buffer.init(5, errorCode)) {
164             const UChar *srcArray=src.getBuffer();
165             kcf-&gt;compose(srcArray, srcArray+src.length(), FALSE,
166                           TRUE, buffer, errorCode);
167         }
168     }
169     return U_SUCCESS(errorCode) &amp;&amp; dest!=src;
170 }
171 #endif
172 
173 #if UCONFIG_NO_NORMALIZATION
174 static UBool isCanonSegmentStarter(const BinaryProperty &amp;, UChar32, UProperty) {
175     return FALSE;
176 }
177 #else
178 static UBool isCanonSegmentStarter(const BinaryProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
179     UErrorCode errorCode=U_ZERO_ERROR;
180     const Normalizer2Impl *impl=Normalizer2Factory::getNFCImpl(errorCode);
181     return
182         U_SUCCESS(errorCode) &amp;&amp; impl-&gt;ensureCanonIterData(errorCode) &amp;&amp;
183         impl-&gt;isCanonSegmentStarter(c);
184 }
185 #endif
186 
187 static UBool isPOSIX_alnum(const BinaryProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
188     return u_isalnumPOSIX(c);
189 }
190 
191 static UBool isPOSIX_blank(const BinaryProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
192     return u_isblank(c);
193 }
194 
195 static UBool isPOSIX_graph(const BinaryProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
196     return u_isgraphPOSIX(c);
197 }
198 
199 static UBool isPOSIX_print(const BinaryProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
200     return u_isprintPOSIX(c);
201 }
202 
203 static UBool isPOSIX_xdigit(const BinaryProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
204     return u_isxdigit(c);
205 }
206 
207 static UBool isRegionalIndicator(const BinaryProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
208     // Property starts are a subset of lb=RI etc.
209     return 0x1F1E6&lt;=c &amp;&amp; c&lt;=0x1F1FF;
210 }
211 
212 static const BinaryProperty binProps[UCHAR_BINARY_LIMIT]={
213     /*
214      * column and mask values for binary properties from u_getUnicodeProperties().
215      * Must be in order of corresponding UProperty,
216      * and there must be exactly one entry per binary UProperty.
217      *
218      * Properties with mask==0 are handled in code.
219      * For them, column is the UPropertySource value.
220      */
221     { 1,                U_MASK(UPROPS_ALPHABETIC), defaultContains },
222     { 1,                U_MASK(UPROPS_ASCII_HEX_DIGIT), defaultContains },
223     { UPROPS_SRC_BIDI,  0, isBidiControl },
224     { UPROPS_SRC_BIDI,  0, isMirrored },
225     { 1,                U_MASK(UPROPS_DASH), defaultContains },
226     { 1,                U_MASK(UPROPS_DEFAULT_IGNORABLE_CODE_POINT), defaultContains },
227     { 1,                U_MASK(UPROPS_DEPRECATED), defaultContains },
228     { 1,                U_MASK(UPROPS_DIACRITIC), defaultContains },
229     { 1,                U_MASK(UPROPS_EXTENDER), defaultContains },
230     { UPROPS_SRC_NFC,   0, hasFullCompositionExclusion },
231     { 1,                U_MASK(UPROPS_GRAPHEME_BASE), defaultContains },
232     { 1,                U_MASK(UPROPS_GRAPHEME_EXTEND), defaultContains },
233     { 1,                U_MASK(UPROPS_GRAPHEME_LINK), defaultContains },
234     { 1,                U_MASK(UPROPS_HEX_DIGIT), defaultContains },
235     { 1,                U_MASK(UPROPS_HYPHEN), defaultContains },
236     { 1,                U_MASK(UPROPS_ID_CONTINUE), defaultContains },
237     { 1,                U_MASK(UPROPS_ID_START), defaultContains },
238     { 1,                U_MASK(UPROPS_IDEOGRAPHIC), defaultContains },
239     { 1,                U_MASK(UPROPS_IDS_BINARY_OPERATOR), defaultContains },
240     { 1,                U_MASK(UPROPS_IDS_TRINARY_OPERATOR), defaultContains },
241     { UPROPS_SRC_BIDI,  0, isJoinControl },
242     { 1,                U_MASK(UPROPS_LOGICAL_ORDER_EXCEPTION), defaultContains },
243     { UPROPS_SRC_CASE,  0, caseBinaryPropertyContains },  // UCHAR_LOWERCASE
244     { 1,                U_MASK(UPROPS_MATH), defaultContains },
245     { 1,                U_MASK(UPROPS_NONCHARACTER_CODE_POINT), defaultContains },
246     { 1,                U_MASK(UPROPS_QUOTATION_MARK), defaultContains },
247     { 1,                U_MASK(UPROPS_RADICAL), defaultContains },
248     { UPROPS_SRC_CASE,  0, caseBinaryPropertyContains },  // UCHAR_SOFT_DOTTED
249     { 1,                U_MASK(UPROPS_TERMINAL_PUNCTUATION), defaultContains },
250     { 1,                U_MASK(UPROPS_UNIFIED_IDEOGRAPH), defaultContains },
251     { UPROPS_SRC_CASE,  0, caseBinaryPropertyContains },  // UCHAR_UPPERCASE
252     { 1,                U_MASK(UPROPS_WHITE_SPACE), defaultContains },
253     { 1,                U_MASK(UPROPS_XID_CONTINUE), defaultContains },
254     { 1,                U_MASK(UPROPS_XID_START), defaultContains },
255     { UPROPS_SRC_CASE,  0, caseBinaryPropertyContains },  // UCHAR_CASE_SENSITIVE
256     { 1,                U_MASK(UPROPS_S_TERM), defaultContains },
257     { 1,                U_MASK(UPROPS_VARIATION_SELECTOR), defaultContains },
258     { UPROPS_SRC_NFC,   0, isNormInert },  // UCHAR_NFD_INERT
259     { UPROPS_SRC_NFKC,  0, isNormInert },  // UCHAR_NFKD_INERT
260     { UPROPS_SRC_NFC,   0, isNormInert },  // UCHAR_NFC_INERT
261     { UPROPS_SRC_NFKC,  0, isNormInert },  // UCHAR_NFKC_INERT
262     { UPROPS_SRC_NFC_CANON_ITER, 0, isCanonSegmentStarter },
263     { 1,                U_MASK(UPROPS_PATTERN_SYNTAX), defaultContains },
264     { 1,                U_MASK(UPROPS_PATTERN_WHITE_SPACE), defaultContains },
265     { UPROPS_SRC_CHAR_AND_PROPSVEC,  0, isPOSIX_alnum },
266     { UPROPS_SRC_CHAR,  0, isPOSIX_blank },
267     { UPROPS_SRC_CHAR,  0, isPOSIX_graph },
268     { UPROPS_SRC_CHAR,  0, isPOSIX_print },
269     { UPROPS_SRC_CHAR,  0, isPOSIX_xdigit },
270     { UPROPS_SRC_CASE,  0, caseBinaryPropertyContains },  // UCHAR_CASED
271     { UPROPS_SRC_CASE,  0, caseBinaryPropertyContains },  // UCHAR_CASE_IGNORABLE
272     { UPROPS_SRC_CASE,  0, caseBinaryPropertyContains },  // UCHAR_CHANGES_WHEN_LOWERCASED
273     { UPROPS_SRC_CASE,  0, caseBinaryPropertyContains },  // UCHAR_CHANGES_WHEN_UPPERCASED
274     { UPROPS_SRC_CASE,  0, caseBinaryPropertyContains },  // UCHAR_CHANGES_WHEN_TITLECASED
275     { UPROPS_SRC_CASE_AND_NORM,  0, changesWhenCasefolded },
276     { UPROPS_SRC_CASE,  0, caseBinaryPropertyContains },  // UCHAR_CHANGES_WHEN_CASEMAPPED
277     { UPROPS_SRC_NFKC_CF, 0, changesWhenNFKC_Casefolded },
278     { 2,                U_MASK(UPROPS_2_EMOJI), defaultContains },
279     { 2,                U_MASK(UPROPS_2_EMOJI_PRESENTATION), defaultContains },
280     { 2,                U_MASK(UPROPS_2_EMOJI_MODIFIER), defaultContains },
281     { 2,                U_MASK(UPROPS_2_EMOJI_MODIFIER_BASE), defaultContains },
282     { 2,                U_MASK(UPROPS_2_EMOJI_COMPONENT), defaultContains },
283     { 2,                0, isRegionalIndicator },
284     { 1,                U_MASK(UPROPS_PREPENDED_CONCATENATION_MARK), defaultContains },
285     { 2,                U_MASK(UPROPS_2_EXTENDED_PICTOGRAPHIC), defaultContains },
286 };
287 
288 U_CAPI UBool U_EXPORT2
289 u_hasBinaryProperty(UChar32 c, UProperty which) {
290     /* c is range-checked in the functions that are called from here */
291     if(which&lt;UCHAR_BINARY_START || UCHAR_BINARY_LIMIT&lt;=which) {
292         /* not a known binary property */
293         return FALSE;
294     } else {
295         const BinaryProperty &amp;prop=binProps[which];
296         return prop.contains(prop, c, which);
297     }
298 }
299 
300 struct IntProperty;
301 
302 typedef int32_t IntPropertyGetValue(const IntProperty &amp;prop, UChar32 c, UProperty which);
303 typedef int32_t IntPropertyGetMaxValue(const IntProperty &amp;prop, UProperty which);
304 
305 struct IntProperty {
306     int32_t column;  // SRC_PROPSVEC column, or &quot;source&quot; if mask==0
307     uint32_t mask;
308     int32_t shift;  // =maxValue if getMaxValueFromShift() is used
309     IntPropertyGetValue *getValue;
310     IntPropertyGetMaxValue *getMaxValue;
311 };
312 
313 static int32_t defaultGetValue(const IntProperty &amp;prop, UChar32 c, UProperty /*which*/) {
314     /* systematic, directly stored properties */
315     return (int32_t)(u_getUnicodeProperties(c, prop.column)&amp;prop.mask)&gt;&gt;prop.shift;
316 }
317 
318 static int32_t defaultGetMaxValue(const IntProperty &amp;prop, UProperty /*which*/) {
319     return (uprv_getMaxValues(prop.column)&amp;prop.mask)&gt;&gt;prop.shift;
320 }
321 
322 static int32_t getMaxValueFromShift(const IntProperty &amp;prop, UProperty /*which*/) {
323     return prop.shift;
324 }
325 
326 static int32_t getBiDiClass(const IntProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
327     return (int32_t)u_charDirection(c);
328 }
329 
330 static int32_t getBiDiPairedBracketType(const IntProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
331     return (int32_t)ubidi_getPairedBracketType(c);
332 }
333 
334 static int32_t biDiGetMaxValue(const IntProperty &amp;/*prop*/, UProperty which) {
335     return ubidi_getMaxValue(which);
336 }
337 
338 #if UCONFIG_NO_NORMALIZATION
339 static int32_t getCombiningClass(const IntProperty &amp;, UChar32, UProperty) {
340     return 0;
341 }
342 #else
343 static int32_t getCombiningClass(const IntProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
344     return u_getCombiningClass(c);
345 }
346 #endif
347 
348 static int32_t getGeneralCategory(const IntProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
349     return (int32_t)u_charType(c);
350 }
351 
352 static int32_t getJoiningGroup(const IntProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
353     return ubidi_getJoiningGroup(c);
354 }
355 
356 static int32_t getJoiningType(const IntProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
357     return ubidi_getJoiningType(c);
358 }
359 
360 static int32_t getNumericType(const IntProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
361     int32_t ntv=(int32_t)GET_NUMERIC_TYPE_VALUE(u_getMainProperties(c));
362     return UPROPS_NTV_GET_TYPE(ntv);
363 }
364 
365 static int32_t getScript(const IntProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
366     UErrorCode errorCode=U_ZERO_ERROR;
367     return (int32_t)uscript_getScript(c, &amp;errorCode);
368 }
369 
370 /*
371  * Map some of the Grapheme Cluster Break values to Hangul Syllable Types.
372  * Hangul_Syllable_Type is fully redundant with a subset of Grapheme_Cluster_Break.
373  */
374 static const UHangulSyllableType gcbToHst[]={
375     U_HST_NOT_APPLICABLE,   /* U_GCB_OTHER */
376     U_HST_NOT_APPLICABLE,   /* U_GCB_CONTROL */
377     U_HST_NOT_APPLICABLE,   /* U_GCB_CR */
378     U_HST_NOT_APPLICABLE,   /* U_GCB_EXTEND */
379     U_HST_LEADING_JAMO,     /* U_GCB_L */
380     U_HST_NOT_APPLICABLE,   /* U_GCB_LF */
381     U_HST_LV_SYLLABLE,      /* U_GCB_LV */
382     U_HST_LVT_SYLLABLE,     /* U_GCB_LVT */
383     U_HST_TRAILING_JAMO,    /* U_GCB_T */
384     U_HST_VOWEL_JAMO        /* U_GCB_V */
385     /*
386      * Omit GCB values beyond what we need for hst.
387      * The code below checks for the array length.
388      */
389 };
390 
391 static int32_t getHangulSyllableType(const IntProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
392     /* see comments on gcbToHst[] above */
393     int32_t gcb=(int32_t)(u_getUnicodeProperties(c, 2)&amp;UPROPS_GCB_MASK)&gt;&gt;UPROPS_GCB_SHIFT;
394     if(gcb&lt;UPRV_LENGTHOF(gcbToHst)) {
395         return gcbToHst[gcb];
396     } else {
397         return U_HST_NOT_APPLICABLE;
398     }
399 }
400 
401 #if UCONFIG_NO_NORMALIZATION
402 static int32_t getNormQuickCheck(const IntProperty &amp;, UChar32, UProperty) {
403     return 0;
404 }
405 #else
406 static int32_t getNormQuickCheck(const IntProperty &amp;/*prop*/, UChar32 c, UProperty which) {
407     return (int32_t)unorm_getQuickCheck(c, (UNormalizationMode)(which-UCHAR_NFD_QUICK_CHECK+UNORM_NFD));
408 }
409 #endif
410 
411 #if UCONFIG_NO_NORMALIZATION
412 static int32_t getLeadCombiningClass(const IntProperty &amp;, UChar32, UProperty) {
413     return 0;
414 }
415 #else
416 static int32_t getLeadCombiningClass(const IntProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
417     return unorm_getFCD16(c)&gt;&gt;8;
418 }
419 #endif
420 
421 #if UCONFIG_NO_NORMALIZATION
422 static int32_t getTrailCombiningClass(const IntProperty &amp;, UChar32, UProperty) {
423     return 0;
424 }
425 #else
426 static int32_t getTrailCombiningClass(const IntProperty &amp;/*prop*/, UChar32 c, UProperty /*which*/) {
427     return unorm_getFCD16(c)&amp;0xff;
428 }
429 #endif
430 
431 static const IntProperty intProps[UCHAR_INT_LIMIT-UCHAR_INT_START]={
432     /*
433      * column, mask and shift values for int-value properties from u_getUnicodeProperties().
434      * Must be in order of corresponding UProperty,
435      * and there must be exactly one entry per int UProperty.
436      *
437      * Properties with mask==0 are handled in code.
438      * For them, column is the UPropertySource value.
439      */
440     { UPROPS_SRC_BIDI,  0, 0,                               getBiDiClass, biDiGetMaxValue },
441     { 0,                UPROPS_BLOCK_MASK, UPROPS_BLOCK_SHIFT, defaultGetValue, defaultGetMaxValue },
442     { UPROPS_SRC_NFC,   0, 0xff,                            getCombiningClass, getMaxValueFromShift },
443     { 2,                UPROPS_DT_MASK, 0,                  defaultGetValue, defaultGetMaxValue },
444     { 0,                UPROPS_EA_MASK, UPROPS_EA_SHIFT,    defaultGetValue, defaultGetMaxValue },
445     { UPROPS_SRC_CHAR,  0, (int32_t)U_CHAR_CATEGORY_COUNT-1,getGeneralCategory, getMaxValueFromShift },
446     { UPROPS_SRC_BIDI,  0, 0,                               getJoiningGroup, biDiGetMaxValue },
447     { UPROPS_SRC_BIDI,  0, 0,                               getJoiningType, biDiGetMaxValue },
448     { 2,                UPROPS_LB_MASK, UPROPS_LB_SHIFT,    defaultGetValue, defaultGetMaxValue },
449     { UPROPS_SRC_CHAR,  0, (int32_t)U_NT_COUNT-1,           getNumericType, getMaxValueFromShift },
450     { 0,                UPROPS_SCRIPT_MASK, 0,              getScript, defaultGetMaxValue },
451     { UPROPS_SRC_PROPSVEC, 0, (int32_t)U_HST_COUNT-1,       getHangulSyllableType, getMaxValueFromShift },
452     // UCHAR_NFD_QUICK_CHECK: max=1=YES -- never &quot;maybe&quot;, only &quot;no&quot; or &quot;yes&quot;
453     { UPROPS_SRC_NFC,   0, (int32_t)UNORM_YES,              getNormQuickCheck, getMaxValueFromShift },
454     // UCHAR_NFKD_QUICK_CHECK: max=1=YES -- never &quot;maybe&quot;, only &quot;no&quot; or &quot;yes&quot;
455     { UPROPS_SRC_NFKC,  0, (int32_t)UNORM_YES,              getNormQuickCheck, getMaxValueFromShift },
456     // UCHAR_NFC_QUICK_CHECK: max=2=MAYBE
457     { UPROPS_SRC_NFC,   0, (int32_t)UNORM_MAYBE,            getNormQuickCheck, getMaxValueFromShift },
458     // UCHAR_NFKC_QUICK_CHECK: max=2=MAYBE
459     { UPROPS_SRC_NFKC,  0, (int32_t)UNORM_MAYBE,            getNormQuickCheck, getMaxValueFromShift },
460     { UPROPS_SRC_NFC,   0, 0xff,                            getLeadCombiningClass, getMaxValueFromShift },
461     { UPROPS_SRC_NFC,   0, 0xff,                            getTrailCombiningClass, getMaxValueFromShift },
462     { 2,                UPROPS_GCB_MASK, UPROPS_GCB_SHIFT,  defaultGetValue, defaultGetMaxValue },
463     { 2,                UPROPS_SB_MASK, UPROPS_SB_SHIFT,    defaultGetValue, defaultGetMaxValue },
464     { 2,                UPROPS_WB_MASK, UPROPS_WB_SHIFT,    defaultGetValue, defaultGetMaxValue },
465     { UPROPS_SRC_BIDI,  0, 0,                               getBiDiPairedBracketType, biDiGetMaxValue },
466 };
467 
468 U_CAPI int32_t U_EXPORT2
469 u_getIntPropertyValue(UChar32 c, UProperty which) {
470     if(which&lt;UCHAR_INT_START) {
471         if(UCHAR_BINARY_START&lt;=which &amp;&amp; which&lt;UCHAR_BINARY_LIMIT) {
472             const BinaryProperty &amp;prop=binProps[which];
473             return prop.contains(prop, c, which);
474         }
475     } else if(which&lt;UCHAR_INT_LIMIT) {
476         const IntProperty &amp;prop=intProps[which-UCHAR_INT_START];
477         return prop.getValue(prop, c, which);
478     } else if(which==UCHAR_GENERAL_CATEGORY_MASK) {
479         return U_MASK(u_charType(c));
480     }
481     return 0;  // undefined
482 }
483 
484 U_CAPI int32_t U_EXPORT2
485 u_getIntPropertyMinValue(UProperty /*which*/) {
486     return 0; /* all binary/enum/int properties have a minimum value of 0 */
487 }
488 
489 U_CAPI int32_t U_EXPORT2
490 u_getIntPropertyMaxValue(UProperty which) {
491     if(which&lt;UCHAR_INT_START) {
492         if(UCHAR_BINARY_START&lt;=which &amp;&amp; which&lt;UCHAR_BINARY_LIMIT) {
493             return 1;  // maximum TRUE for all binary properties
494         }
495     } else if(which&lt;UCHAR_INT_LIMIT) {
496         const IntProperty &amp;prop=intProps[which-UCHAR_INT_START];
497         return prop.getMaxValue(prop, which);
498     }
499     return -1;  // undefined
500 }
501 
502 U_CFUNC UPropertySource U_EXPORT2
503 uprops_getSource(UProperty which) {
504     if(which&lt;UCHAR_BINARY_START) {
505         return UPROPS_SRC_NONE; /* undefined */
506     } else if(which&lt;UCHAR_BINARY_LIMIT) {
507         const BinaryProperty &amp;prop=binProps[which];
508         if(prop.mask!=0) {
509             return UPROPS_SRC_PROPSVEC;
510         } else {
511             return (UPropertySource)prop.column;
512         }
513     } else if(which&lt;UCHAR_INT_START) {
514         return UPROPS_SRC_NONE; /* undefined */
515     } else if(which&lt;UCHAR_INT_LIMIT) {
516         const IntProperty &amp;prop=intProps[which-UCHAR_INT_START];
517         if(prop.mask!=0) {
518             return UPROPS_SRC_PROPSVEC;
519         } else {
520             return (UPropertySource)prop.column;
521         }
522     } else if(which&lt;UCHAR_STRING_START) {
523         switch(which) {
524         case UCHAR_GENERAL_CATEGORY_MASK:
525         case UCHAR_NUMERIC_VALUE:
526             return UPROPS_SRC_CHAR;
527 
528         default:
529             return UPROPS_SRC_NONE;
530         }
531     } else if(which&lt;UCHAR_STRING_LIMIT) {
532         switch(which) {
533         case UCHAR_AGE:
534             return UPROPS_SRC_PROPSVEC;
535 
536         case UCHAR_BIDI_MIRRORING_GLYPH:
537             return UPROPS_SRC_BIDI;
538 
539         case UCHAR_CASE_FOLDING:
540         case UCHAR_LOWERCASE_MAPPING:
541         case UCHAR_SIMPLE_CASE_FOLDING:
542         case UCHAR_SIMPLE_LOWERCASE_MAPPING:
543         case UCHAR_SIMPLE_TITLECASE_MAPPING:
544         case UCHAR_SIMPLE_UPPERCASE_MAPPING:
545         case UCHAR_TITLECASE_MAPPING:
546         case UCHAR_UPPERCASE_MAPPING:
547             return UPROPS_SRC_CASE;
548 
549         case UCHAR_ISO_COMMENT:
550         case UCHAR_NAME:
551         case UCHAR_UNICODE_1_NAME:
552             return UPROPS_SRC_NAMES;
553 
554         default:
555             return UPROPS_SRC_NONE;
556         }
557     } else {
558         switch(which) {
559         case UCHAR_SCRIPT_EXTENSIONS:
560             return UPROPS_SRC_PROPSVEC;
561         default:
562             return UPROPS_SRC_NONE; /* undefined */
563         }
564     }
565 }
566 
567 #if !UCONFIG_NO_NORMALIZATION
568 
569 U_CAPI int32_t U_EXPORT2
570 u_getFC_NFKC_Closure(UChar32 c, UChar *dest, int32_t destCapacity, UErrorCode *pErrorCode) {
571     if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {
572         return 0;
573     }
574     if(destCapacity&lt;0 || (dest==NULL &amp;&amp; destCapacity&gt;0)) {
575         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
576         return 0;
577     }
578     // Compute the FC_NFKC_Closure on the fly:
579     // We have the API for complete coverage of Unicode properties, although
580     // this value by itself is not useful via API.
581     // (What could be useful is a custom normalization table that combines
582     // case folding and NFKC.)
583     // For the derivation, see Unicode&#39;s DerivedNormalizationProps.txt.
584     const Normalizer2 *nfkc=Normalizer2::getNFKCInstance(*pErrorCode);
585     if(U_FAILURE(*pErrorCode)) {
586         return 0;
587     }
588     // first: b = NFKC(Fold(a))
589     UnicodeString folded1String;
590     const UChar *folded1;
591     int32_t folded1Length=ucase_toFullFolding(c, &amp;folded1, U_FOLD_CASE_DEFAULT);
592     if(folded1Length&lt;0) {
593         const Normalizer2Impl *nfkcImpl=Normalizer2Factory::getImpl(nfkc);
594         if(nfkcImpl-&gt;getCompQuickCheck(nfkcImpl-&gt;getNorm16(c))!=UNORM_NO) {
595             return u_terminateUChars(dest, destCapacity, 0, pErrorCode);  // c does not change at all under CaseFolding+NFKC
596         }
597         folded1String.setTo(c);
598     } else {
599         if(folded1Length&gt;UCASE_MAX_STRING_LENGTH) {
600             folded1String.setTo(folded1Length);
601         } else {
602             folded1String.setTo(FALSE, folded1, folded1Length);
603         }
604     }
605     UnicodeString kc1=nfkc-&gt;normalize(folded1String, *pErrorCode);
606     // second: c = NFKC(Fold(b))
607     UnicodeString folded2String(kc1);
608     UnicodeString kc2=nfkc-&gt;normalize(folded2String.foldCase(), *pErrorCode);
609     // if (c != b) add the mapping from a to c
610     if(U_FAILURE(*pErrorCode) || kc1==kc2) {
611         return u_terminateUChars(dest, destCapacity, 0, pErrorCode);
612     } else {
613         return kc2.extract(dest, destCapacity, *pErrorCode);
614     }
615 }
616 
617 #endif
    </pre>
  </body>
</html>