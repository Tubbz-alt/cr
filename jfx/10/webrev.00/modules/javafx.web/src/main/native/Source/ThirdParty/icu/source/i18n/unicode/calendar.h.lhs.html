<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/unicode/calendar.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Â© 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ********************************************************************************
   5 *   Copyright (C) 1997-2014, International Business Machines
   6 *   Corporation and others.  All Rights Reserved.
   7 ********************************************************************************
   8 *
   9 * File CALENDAR.H
  10 *
  11 * Modification History:
  12 *
  13 *   Date        Name        Description
  14 *   04/22/97    aliu        Expanded and corrected comments and other header
  15 *                           contents.
  16 *   05/01/97    aliu        Made equals(), before(), after() arguments const.
  17 *   05/20/97    aliu        Replaced fAreFieldsSet with fAreFieldsInSync and
  18 *                           fAreAllFieldsSet.
  19 *   07/27/98    stephen     Sync up with JDK 1.2
  20 *   11/15/99    weiv        added YEAR_WOY and DOW_LOCAL
  21 *                           to EDateFields
  22 *    8/19/2002  srl         Removed Javaisms
  23 *   11/07/2003  srl         Update, clean up documentation.
  24 ********************************************************************************
  25 */
  26 
  27 #ifndef CALENDAR_H
  28 #define CALENDAR_H
  29 
  30 #include &quot;unicode/utypes.h&quot;
  31 
  32 /**
  33  * \file
  34  * \brief C++ API: Calendar object
  35  */
  36 #if !UCONFIG_NO_FORMATTING
  37 
  38 #include &quot;unicode/uobject.h&quot;
  39 #include &quot;unicode/locid.h&quot;
  40 #include &quot;unicode/timezone.h&quot;
  41 #include &quot;unicode/ucal.h&quot;
  42 #include &quot;unicode/umisc.h&quot;
  43 
  44 U_NAMESPACE_BEGIN
  45 
  46 class ICUServiceFactory;
  47 
  48 /**
  49  * @internal
  50  */
  51 typedef int32_t UFieldResolutionTable[12][8];
  52 
  53 class BasicTimeZone;
  54 /**
<a name="1" id="anc1"></a><span class="line-modified">  55  * &lt;code&gt;Calendar&lt;/code&gt; is an abstract base class for converting between</span>
<span class="line-modified">  56  * a &lt;code&gt;UDate&lt;/code&gt; object and a set of integer fields such as</span>
<span class="line-modified">  57  * &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH&lt;/code&gt;, &lt;code&gt;DAY&lt;/code&gt;, &lt;code&gt;HOUR&lt;/code&gt;,</span>
<span class="line-modified">  58  * and so on. (A &lt;code&gt;UDate&lt;/code&gt; object represents a specific instant in</span>
  59  * time with millisecond precision. See UDate
<a name="2" id="anc2"></a><span class="line-modified">  60  * for information about the &lt;code&gt;UDate&lt;/code&gt; class.)</span>
  61  *
<a name="3" id="anc3"></a><span class="line-modified">  62  * &lt;p&gt;</span>
<span class="line-removed">  63  * Subclasses of &lt;code&gt;Calendar&lt;/code&gt; interpret a &lt;code&gt;UDate&lt;/code&gt;</span>
  64  * according to the rules of a specific calendar system.
<a name="4" id="anc4"></a><span class="line-modified">  65  * The most commonly used subclass of &lt;code&gt;Calendar&lt;/code&gt; is</span>
<span class="line-modified">  66  * &lt;code&gt;GregorianCalendar&lt;/code&gt;. Other subclasses could represent</span>
  67  * the various types of lunar calendars in use in many parts of the world.
  68  *
<a name="5" id="anc5"></a><span class="line-modified">  69  * &lt;p&gt;</span>
<span class="line-modified">  70  * &lt;b&gt;NOTE&lt;/b&gt;: (ICU 2.6) The subclass interface should be considered unstable</span>
<span class="line-removed">  71  * - it WILL change.</span>
  72  *
<a name="6" id="anc6"></a><span class="line-modified">  73  * &lt;p&gt;</span>
<span class="line-modified">  74  * Like other locale-sensitive classes, &lt;code&gt;Calendar&lt;/code&gt; provides a</span>
<span class="line-modified">  75  * static method, &lt;code&gt;createInstance&lt;/code&gt;, for getting a generally useful</span>
<span class="line-modified">  76  * object of this type. &lt;code&gt;Calendar&lt;/code&gt;&#39;s &lt;code&gt;createInstance&lt;/code&gt; method</span>
<span class="line-removed">  77  * returns the appropriate &lt;code&gt;Calendar&lt;/code&gt; subclass whose</span>
  78  * time fields have been initialized with the current date and time:
<a name="7" id="anc7"></a><span class="line-removed">  79  * \htmlonly&lt;blockquote&gt;\endhtmlonly</span>
<span class="line-removed">  80  * &lt;pre&gt;</span>
<span class="line-removed">  81  * Calendar *rightNow = Calendar::createInstance(errCode);</span>
<span class="line-removed">  82  * &lt;/pre&gt;</span>
<span class="line-removed">  83  * \htmlonly&lt;/blockquote&gt;\endhtmlonly</span>
  84  *
<a name="8" id="anc8"></a><span class="line-modified">  85  * &lt;p&gt;</span>
<span class="line-modified">  86  * A &lt;code&gt;Calendar&lt;/code&gt; object can produce all the time field values</span>

  87  * needed to implement the date-time formatting for a particular language
  88  * and calendar style (for example, Japanese-Gregorian, Japanese-Traditional).
  89  *
<a name="9" id="anc9"></a><span class="line-modified">  90  * &lt;p&gt;</span>
<span class="line-removed">  91  * When computing a &lt;code&gt;UDate&lt;/code&gt; from time fields, some special circumstances</span>
  92  * may arise: there may be insufficient information to compute the
<a name="10" id="anc10"></a><span class="line-modified">  93  * &lt;code&gt;UDate&lt;/code&gt; (such as only year and month but no day in the month),</span>
  94  * there may be inconsistent information (such as &quot;Tuesday, July 15, 1996&quot;
  95  * -- July 15, 1996 is actually a Monday), or the input time might be ambiguous
  96  * because of time zone transition.
  97  *
<a name="11" id="anc11"></a><span class="line-modified">  98  * &lt;p&gt;</span>
<span class="line-removed">  99  * &lt;strong&gt;Insufficient information.&lt;/strong&gt; The calendar will use default</span>
 100  * information to specify the missing fields. This may vary by calendar; for
 101  * the Gregorian calendar, the default for a field is the same as that of the
 102  * start of the epoch: i.e., YEAR = 1970, MONTH = JANUARY, DATE = 1, etc.
 103  *
<a name="12" id="anc12"></a><span class="line-modified"> 104  * &lt;p&gt;</span>
<span class="line-removed"> 105  * &lt;strong&gt;Inconsistent information.&lt;/strong&gt; If fields conflict, the calendar</span>
 106  * will give preference to fields set more recently. For example, when
 107  * determining the day, the calendar will look for one of the following
 108  * combinations of fields.  The most recent combination, as determined by the
 109  * most recently set single field, will be used.
 110  *
<a name="13" id="anc13"></a><span class="line-modified"> 111  * \htmlonly&lt;blockquote&gt;\endhtmlonly</span>
<span class="line-modified"> 112  * &lt;pre&gt;</span>
<span class="line-modified"> 113  * MONTH + DAY_OF_MONTH</span>
<span class="line-modified"> 114  * MONTH + WEEK_OF_MONTH + DAY_OF_WEEK</span>
<span class="line-modified"> 115  * MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK</span>
<span class="line-removed"> 116  * DAY_OF_YEAR</span>
<span class="line-removed"> 117  * DAY_OF_WEEK + WEEK_OF_YEAR</span>
<span class="line-removed"> 118  * &lt;/pre&gt;</span>
<span class="line-removed"> 119  * \htmlonly&lt;/blockquote&gt;\endhtmlonly</span>
 120  *
 121  * For the time of day:
 122  *
<a name="14" id="anc14"></a><span class="line-modified"> 123  * \htmlonly&lt;blockquote&gt;\endhtmlonly</span>
<span class="line-modified"> 124  * &lt;pre&gt;</span>
<span class="line-removed"> 125  * HOUR_OF_DAY</span>
<span class="line-removed"> 126  * AM_PM + HOUR</span>
<span class="line-removed"> 127  * &lt;/pre&gt;</span>
<span class="line-removed"> 128  * \htmlonly&lt;/blockquote&gt;\endhtmlonly</span>
 129  *
<a name="15" id="anc15"></a><span class="line-modified"> 130  * &lt;p&gt;</span>
<span class="line-removed"> 131  * &lt;strong&gt;Ambiguous Wall Clock Time.&lt;/strong&gt; When time offset from UTC has</span>
 132  * changed, it produces an ambiguous time slot around the transition. For example,
 133  * many US locations observe daylight saving time. On the date switching to daylight
 134  * saving time in US, wall clock time jumps from 12:59 AM (standard) to 2:00 AM
 135  * (daylight). Therefore, wall clock time from 1:00 AM to 1:59 AM do not exist on
 136  * the date. When the input wall time fall into this missing time slot, the ICU
 137  * Calendar resolves the time using the UTC offset before the transition by default.
 138  * In this example, 1:30 AM is interpreted as 1:30 AM standard time (non-exist),
 139  * so the final result will be 2:30 AM daylight time.
 140  *
<a name="16" id="anc16"></a><span class="line-modified"> 141  * &lt;p&gt;On the date switching back to standard time, wall clock time is moved back one</span>
 142  * hour at 2:00 AM. So wall clock time from 1:00 AM to 1:59 AM occur twice. In this
 143  * case, the ICU Calendar resolves the time using the UTC offset after the transition
 144  * by default. For example, 1:30 AM on the date is resolved as 1:30 AM standard time.
 145  *
<a name="17" id="anc17"></a><span class="line-modified"> 146  * &lt;p&gt;Ambiguous wall clock time resolution behaviors can be customized by Calendar APIs</span>
 147  * {@link #setRepeatedWallTimeOption} and {@link #setSkippedWallTimeOption}.
 148  * These methods are available in ICU 49 or later versions.
 149  *
<a name="18" id="anc18"></a><span class="line-modified"> 150  * &lt;p&gt;</span>
<span class="line-removed"> 151  * &lt;strong&gt;Note:&lt;/strong&gt; for some non-Gregorian calendars, different</span>
 152  * fields may be necessary for complete disambiguation. For example, a full
<a name="19" id="anc19"></a><span class="line-modified"> 153  * specification of the historial Arabic astronomical calendar requires year,</span>
<span class="line-modified"> 154  * month, day-of-month &lt;em&gt;and&lt;/em&gt; day-of-week in some cases.</span>
 155  *
<a name="20" id="anc20"></a><span class="line-modified"> 156  * &lt;p&gt;</span>
<span class="line-removed"> 157  * &lt;strong&gt;Note:&lt;/strong&gt; There are certain possible ambiguities in</span>
 158  * interpretation of certain singular times, which are resolved in the
 159  * following ways:
<a name="21" id="anc21"></a><span class="line-removed"> 160  * &lt;ol&gt;</span>
<span class="line-removed"> 161  *     &lt;li&gt; 24:00:00 &quot;belongs&quot; to the following day. That is,</span>
<span class="line-removed"> 162  *          23:59 on Dec 31, 1969 &amp;lt; 24:00 on Jan 1, 1970 &amp;lt; 24:01:00 on Jan 1, 1970</span>
 163  *
<a name="22" id="anc22"></a><span class="line-modified"> 164  *     &lt;li&gt; Although historically not precise, midnight also belongs to &quot;am&quot;,</span>
<span class="line-modified"> 165  *          and noon belongs to &quot;pm&quot;, so on the same day,</span>
<span class="line-modified"> 166  *          12:00 am (midnight) &amp;lt; 12:01 am, and 12:00 pm (noon) &amp;lt; 12:01 pm</span>
<span class="line-modified"> 167  * &lt;/ol&gt;</span>

 168  *
<a name="23" id="anc23"></a><span class="line-removed"> 169  * &lt;p&gt;</span>
 170  * The date or time format strings are not part of the definition of a
 171  * calendar, as those must be modifiable or overridable by the user at
<a name="24" id="anc24"></a><span class="line-modified"> 172  * runtime. Use {@link DateFormat}</span>
<span class="line-removed"> 173  * to format dates.</span>
 174  *
<a name="25" id="anc25"></a><span class="line-modified"> 175  * &lt;p&gt;</span>
<span class="line-removed"> 176  * &lt;code&gt;Calendar&lt;/code&gt; provides an API for field &quot;rolling&quot;, where fields</span>
 177  * can be incremented or decremented, but wrap around. For example, rolling the
<a name="26" id="anc26"></a><span class="line-modified"> 178  * month up in the date &lt;code&gt;December 12, &lt;b&gt;1996&lt;/b&gt;&lt;/code&gt; results in</span>
<span class="line-modified"> 179  * &lt;code&gt;January 12, &lt;b&gt;1996&lt;/b&gt;&lt;/code&gt;.</span>
 180  *
<a name="27" id="anc27"></a><span class="line-modified"> 181  * &lt;p&gt;</span>
<span class="line-removed"> 182  * &lt;code&gt;Calendar&lt;/code&gt; also provides a date arithmetic function for</span>
 183  * adding the specified (signed) amount of time to a particular time field.
<a name="28" id="anc28"></a><span class="line-modified"> 184  * For example, subtracting 5 days from the date &lt;code&gt;September 12, 1996&lt;/code&gt;</span>
<span class="line-modified"> 185  * results in &lt;code&gt;September 7, 1996&lt;/code&gt;.</span>
 186  *
<a name="29" id="anc29"></a><span class="line-modified"> 187  * &lt;p&gt;&lt;big&gt;&lt;b&gt;Supported range&lt;/b&gt;&lt;/big&gt;</span>
 188  *
<a name="30" id="anc30"></a><span class="line-modified"> 189  * &lt;p&gt;The allowable range of &lt;code&gt;Calendar&lt;/code&gt; has been</span>
<span class="line-modified"> 190  * narrowed. &lt;code&gt;GregorianCalendar&lt;/code&gt; used to attempt to support</span>
<span class="line-modified"> 191  * the range of dates with millisecond values from</span>
<span class="line-removed"> 192  * &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; to &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</span>
<span class="line-removed"> 193  * The new &lt;code&gt;Calendar&lt;/code&gt; protocol specifies the</span>
 194  * maximum range of supportable dates as those having Julian day numbers
<a name="31" id="anc31"></a><span class="line-modified"> 195  * of &lt;code&gt;-0x7F000000&lt;/code&gt; to &lt;code&gt;+0x7F000000&lt;/code&gt;. This</span>
<span class="line-modified"> 196  * corresponds to years from ~5,800,000 BCE to ~5,800,000 CE. Programmers</span>
<span class="line-modified"> 197  * should use the protected constants in &lt;code&gt;Calendar&lt;/code&gt; to</span>
<span class="line-modified"> 198  * specify an extremely early or extremely late date.&lt;/p&gt;</span>












 199  *
 200  * @stable ICU 2.0
 201  */
 202 class U_I18N_API Calendar : public UObject {
 203 public:
 204 
 205     /**
 206      * Field IDs for date and time. Used to specify date/time fields. ERA is calendar
 207      * specific. Example ranges given are for illustration only; see specific Calendar
 208      * subclasses for actual ranges.
 209      * @deprecated ICU 2.6. Use C enum UCalendarDateFields defined in ucal.h
 210      */
 211     enum EDateFields {
 212 #ifndef U_HIDE_DEPRECATED_API
 213 /*
 214  * ERA may be defined on other platforms. To avoid any potential problems undefined it here.
 215  */
 216 #ifdef ERA
 217 #undef ERA
 218 #endif
 219         ERA,                  // Example: 0..1
 220         YEAR,                 // Example: 1..big number
 221         MONTH,                // Example: 0..11
 222         WEEK_OF_YEAR,         // Example: 1..53
 223         WEEK_OF_MONTH,        // Example: 1..4
 224         DATE,                 // Example: 1..31
 225         DAY_OF_YEAR,          // Example: 1..365
 226         DAY_OF_WEEK,          // Example: 1..7
 227         DAY_OF_WEEK_IN_MONTH, // Example: 1..4, may be specified as -1
 228         AM_PM,                // Example: 0..1
 229         HOUR,                 // Example: 0..11
 230         HOUR_OF_DAY,          // Example: 0..23
 231         MINUTE,               // Example: 0..59
 232         SECOND,               // Example: 0..59
 233         MILLISECOND,          // Example: 0..999
 234         ZONE_OFFSET,          // Example: -12*U_MILLIS_PER_HOUR..12*U_MILLIS_PER_HOUR
 235         DST_OFFSET,           // Example: 0 or U_MILLIS_PER_HOUR
 236         YEAR_WOY,             // &#39;Y&#39; Example: 1..big number - Year of Week of Year
 237         DOW_LOCAL,            // &#39;e&#39; Example: 1..7 - Day of Week / Localized
 238 
 239         EXTENDED_YEAR,
 240         JULIAN_DAY,
 241         MILLISECONDS_IN_DAY,
 242         IS_LEAP_MONTH,
 243 
 244         FIELD_COUNT = UCAL_FIELD_COUNT // See ucal.h for other fields.
 245 #endif /* U_HIDE_DEPRECATED_API */
 246     };
 247 
 248 #ifndef U_HIDE_DEPRECATED_API
 249     /**
 250      * Useful constant for days of week. Note: Calendar day-of-week is 1-based. Clients
 251      * who create locale resources for the field of first-day-of-week should be aware of
 252      * this. For instance, in US locale, first-day-of-week is set to 1, i.e., SUNDAY.
 253      * @deprecated ICU 2.6. Use C enum UCalendarDaysOfWeek defined in ucal.h
 254      */
 255     enum EDaysOfWeek {
 256         SUNDAY = 1,
 257         MONDAY,
 258         TUESDAY,
 259         WEDNESDAY,
 260         THURSDAY,
 261         FRIDAY,
 262         SATURDAY
 263     };
 264 
 265     /**
 266      * Useful constants for month. Note: Calendar month is 0-based.
 267      * @deprecated ICU 2.6. Use C enum UCalendarMonths defined in ucal.h
 268      */
 269     enum EMonths {
 270         JANUARY,
 271         FEBRUARY,
 272         MARCH,
 273         APRIL,
 274         MAY,
 275         JUNE,
 276         JULY,
 277         AUGUST,
 278         SEPTEMBER,
 279         OCTOBER,
 280         NOVEMBER,
 281         DECEMBER,
 282         UNDECIMBER
 283     };
 284 
 285     /**
 286      * Useful constants for hour in 12-hour clock. Used in GregorianCalendar.
 287      * @deprecated ICU 2.6. Use C enum UCalendarAMPMs defined in ucal.h
 288      */
 289     enum EAmpm {
 290         AM,
 291         PM
 292     };
 293 #endif  /* U_HIDE_DEPRECATED_API */
 294 
 295     /**
 296      * destructor
 297      * @stable ICU 2.0
 298      */
 299     virtual ~Calendar();
 300 
 301     /**
 302      * Create and return a polymorphic copy of this calendar.
 303      *
 304      * @return    a polymorphic copy of this calendar.
 305      * @stable ICU 2.0
 306      */
 307     virtual Calendar* clone(void) const = 0;
 308 
 309     /**
 310      * Creates a Calendar using the default timezone and locale. Clients are responsible
 311      * for deleting the object returned.
 312      *
 313      * @param success  Indicates the success/failure of Calendar creation. Filled in
 314      *                 with U_ZERO_ERROR if created successfully, set to a failure result
 315      *                 otherwise. U_MISSING_RESOURCE_ERROR will be returned if the resource data
 316      *                 requests a calendar type which has not been installed.
 317      * @return         A Calendar if created successfully. NULL otherwise.
 318      * @stable ICU 2.0
 319      */
 320     static Calendar* U_EXPORT2 createInstance(UErrorCode&amp; success);
 321 
 322     /**
 323      * Creates a Calendar using the given timezone and the default locale.
 324      * The Calendar takes ownership of zoneToAdopt; the
 325      * client must not delete it.
 326      *
 327      * @param zoneToAdopt  The given timezone to be adopted.
 328      * @param success      Indicates the success/failure of Calendar creation. Filled in
 329      *                     with U_ZERO_ERROR if created successfully, set to a failure result
 330      *                     otherwise.
 331      * @return             A Calendar if created successfully. NULL otherwise.
 332      * @stable ICU 2.0
 333      */
 334     static Calendar* U_EXPORT2 createInstance(TimeZone* zoneToAdopt, UErrorCode&amp; success);
 335 
 336     /**
 337      * Creates a Calendar using the given timezone and the default locale.  The TimeZone
 338      * is _not_ adopted; the client is still responsible for deleting it.
 339      *
 340      * @param zone  The timezone.
 341      * @param success      Indicates the success/failure of Calendar creation. Filled in
 342      *                     with U_ZERO_ERROR if created successfully, set to a failure result
 343      *                     otherwise.
 344      * @return             A Calendar if created successfully. NULL otherwise.
 345      * @stable ICU 2.0
 346      */
 347     static Calendar* U_EXPORT2 createInstance(const TimeZone&amp; zone, UErrorCode&amp; success);
 348 
 349     /**
 350      * Creates a Calendar using the default timezone and the given locale.
 351      *
 352      * @param aLocale  The given locale.
 353      * @param success  Indicates the success/failure of Calendar creation. Filled in
 354      *                 with U_ZERO_ERROR if created successfully, set to a failure result
 355      *                 otherwise.
 356      * @return         A Calendar if created successfully. NULL otherwise.
 357      * @stable ICU 2.0
 358      */
 359     static Calendar* U_EXPORT2 createInstance(const Locale&amp; aLocale, UErrorCode&amp; success);
 360 
 361     /**
 362      * Creates a Calendar using the given timezone and given locale.
 363      * The Calendar takes ownership of zoneToAdopt; the
 364      * client must not delete it.
 365      *
 366      * @param zoneToAdopt  The given timezone to be adopted.
 367      * @param aLocale      The given locale.
 368      * @param success      Indicates the success/failure of Calendar creation. Filled in
 369      *                     with U_ZERO_ERROR if created successfully, set to a failure result
 370      *                     otherwise.
 371      * @return             A Calendar if created successfully. NULL otherwise.
 372      * @stable ICU 2.0
 373      */
 374     static Calendar* U_EXPORT2 createInstance(TimeZone* zoneToAdopt, const Locale&amp; aLocale, UErrorCode&amp; success);
 375 
 376     /**
 377      * Gets a Calendar using the given timezone and given locale.  The TimeZone
 378      * is _not_ adopted; the client is still responsible for deleting it.
 379      *
 380      * @param zone         The given timezone.
 381      * @param aLocale      The given locale.
 382      * @param success      Indicates the success/failure of Calendar creation. Filled in
 383      *                     with U_ZERO_ERROR if created successfully, set to a failure result
 384      *                     otherwise.
 385      * @return             A Calendar if created successfully. NULL otherwise.
 386      * @stable ICU 2.0
 387      */
 388     static Calendar* U_EXPORT2 createInstance(const TimeZone&amp; zone, const Locale&amp; aLocale, UErrorCode&amp; success);
 389 
 390     /**
 391      * Returns a list of the locales for which Calendars are installed.
 392      *
 393      * @param count  Number of locales returned.
 394      * @return       An array of Locale objects representing the set of locales for which
 395      *               Calendars are installed.  The system retains ownership of this list;
 396      *               the caller must NOT delete it. Does not include user-registered Calendars.
 397      * @stable ICU 2.0
 398      */
 399     static const Locale* U_EXPORT2 getAvailableLocales(int32_t&amp; count);
 400 
 401 
 402     /**
 403      * Given a key and a locale, returns an array of string values in a preferred
 404      * order that would make a difference. These are all and only those values where
 405      * the open (creation) of the service with the locale formed from the input locale
 406      * plus input keyword and that value has different behavior than creation with the
 407      * input locale alone.
 408      * @param key           one of the keys supported by this service.  For now, only
 409      *                      &quot;calendar&quot; is supported.
 410      * @param locale        the locale
 411      * @param commonlyUsed  if set to true it will return only commonly used values
 412      *                      with the given locale in preferred order.  Otherwise,
 413      *                      it will return all the available values for the locale.
 414      * @param status        ICU Error Code
 415      * @return a string enumeration over keyword values for the given key and the locale.
 416      * @stable ICU 4.2
 417      */
 418     static StringEnumeration* U_EXPORT2 getKeywordValuesForLocale(const char* key,
 419                     const Locale&amp; locale, UBool commonlyUsed, UErrorCode&amp; status);
 420 
 421     /**
 422      * Returns the current UTC (GMT) time measured in milliseconds since 0:00:00 on 1/1/70
 423      * (derived from the system time).
 424      *
 425      * @return   The current UTC time in milliseconds.
 426      * @stable ICU 2.0
 427      */
 428     static UDate U_EXPORT2 getNow(void);
 429 
 430     /**
 431      * Gets this Calendar&#39;s time as milliseconds. May involve recalculation of time due
 432      * to previous calls to set time field values. The time specified is non-local UTC
 433      * (GMT) time. Although this method is const, this object may actually be changed
 434      * (semantically const).
 435      *
 436      * @param status  Output param set to success/failure code on exit. If any value
 437      *                previously set in the time field is invalid or restricted by
 438      *                leniency, this will be set to an error status.
 439      * @return        The current time in UTC (GMT) time, or zero if the operation
 440      *                failed.
 441      * @stable ICU 2.0
 442      */
 443     inline UDate getTime(UErrorCode&amp; status) const { return getTimeInMillis(status); }
 444 
 445     /**
 446      * Sets this Calendar&#39;s current time with the given UDate. The time specified should
 447      * be in non-local UTC (GMT) time.
 448      *
 449      * @param date  The given UDate in UTC (GMT) time.
 450      * @param status  Output param set to success/failure code on exit. If any value
 451      *                set in the time field is invalid or restricted by
 452      *                leniency, this will be set to an error status.
 453      * @stable ICU 2.0
 454      */
 455     inline void setTime(UDate date, UErrorCode&amp; status) { setTimeInMillis(date, status); }
 456 
 457     /**
 458      * Compares the equality of two Calendar objects. Objects of different subclasses
 459      * are considered unequal. This comparison is very exacting; two Calendar objects
 460      * must be in exactly the same state to be considered equal. To compare based on the
 461      * represented time, use equals() instead.
 462      *
 463      * @param that  The Calendar object to be compared with.
 464      * @return      True if the given Calendar is the same as this Calendar; false
 465      *              otherwise.
 466      * @stable ICU 2.0
 467      */
 468     virtual UBool operator==(const Calendar&amp; that) const;
 469 
 470     /**
 471      * Compares the inequality of two Calendar objects.
 472      *
 473      * @param that  The Calendar object to be compared with.
 474      * @return      True if the given Calendar is not the same as this Calendar; false
 475      *              otherwise.
 476      * @stable ICU 2.0
 477      */
 478     UBool operator!=(const Calendar&amp; that) const {return !operator==(that);}
 479 
 480     /**
 481      * Returns TRUE if the given Calendar object is equivalent to this
 482      * one.  An equivalent Calendar will behave exactly as this one
 483      * does, but it may be set to a different time.  By contrast, for
 484      * the operator==() method to return TRUE, the other Calendar must
 485      * be set to the same time.
 486      *
 487      * @param other the Calendar to be compared with this Calendar
 488      * @stable ICU 2.4
 489      */
 490     virtual UBool isEquivalentTo(const Calendar&amp; other) const;
 491 
 492     /**
 493      * Compares the Calendar time, whereas Calendar::operator== compares the equality of
 494      * Calendar objects.
 495      *
 496      * @param when    The Calendar to be compared with this Calendar. Although this is a
 497      *                const parameter, the object may be modified physically
 498      *                (semantically const).
 499      * @param status  Output param set to success/failure code on exit. If any value
 500      *                previously set in the time field is invalid or restricted by
 501      *                leniency, this will be set to an error status.
 502      * @return        True if the current time of this Calendar is equal to the time of
 503      *                Calendar when; false otherwise.
 504      * @stable ICU 2.0
 505      */
 506     UBool equals(const Calendar&amp; when, UErrorCode&amp; status) const;
 507 
 508     /**
 509      * Returns true if this Calendar&#39;s current time is before &quot;when&quot;&#39;s current time.
 510      *
 511      * @param when    The Calendar to be compared with this Calendar. Although this is a
 512      *                const parameter, the object may be modified physically
 513      *                (semantically const).
 514      * @param status  Output param set to success/failure code on exit. If any value
 515      *                previously set in the time field is invalid or restricted by
 516      *                leniency, this will be set to an error status.
 517      * @return        True if the current time of this Calendar is before the time of
 518      *                Calendar when; false otherwise.
 519      * @stable ICU 2.0
 520      */
 521     UBool before(const Calendar&amp; when, UErrorCode&amp; status) const;
 522 
 523     /**
 524      * Returns true if this Calendar&#39;s current time is after &quot;when&quot;&#39;s current time.
 525      *
 526      * @param when    The Calendar to be compared with this Calendar. Although this is a
 527      *                const parameter, the object may be modified physically
 528      *                (semantically const).
 529      * @param status  Output param set to success/failure code on exit. If any value
 530      *                previously set in the time field is invalid or restricted by
 531      *                leniency, this will be set to an error status.
 532      * @return        True if the current time of this Calendar is after the time of
 533      *                Calendar when; false otherwise.
 534      * @stable ICU 2.0
 535      */
 536     UBool after(const Calendar&amp; when, UErrorCode&amp; status) const;
 537 
 538     /**
 539      * UDate Arithmetic function. Adds the specified (signed) amount of time to the given
 540      * time field, based on the calendar&#39;s rules. For example, to subtract 5 days from
 541      * the current time of the calendar, call add(Calendar::DATE, -5). When adding on
 542      * the month or Calendar::MONTH field, other fields like date might conflict and
 543      * need to be changed. For instance, adding 1 month on the date 01/31/96 will result
 544      * in 02/29/96.
 545      * Adding a positive value always means moving forward in time, so for the Gregorian calendar,
 546      * starting with 100 BC and adding +1 to year results in 99 BC (even though this actually reduces
 547      * the numeric value of the field itself).
 548      *
 549      * @param field   Specifies which date field to modify.
 550      * @param amount  The amount of time to be added to the field, in the natural unit
 551      *                for that field (e.g., days for the day fields, hours for the hour
 552      *                field.)
 553      * @param status  Output param set to success/failure code on exit. If any value
 554      *                previously set in the time field is invalid or restricted by
 555      *                leniency, this will be set to an error status.
 556      * @deprecated ICU 2.6. use add(UCalendarDateFields field, int32_t amount, UErrorCode&amp; status) instead.
 557      */
 558     virtual void add(EDateFields field, int32_t amount, UErrorCode&amp; status);
 559 
 560     /**
 561      * UDate Arithmetic function. Adds the specified (signed) amount of time to the given
 562      * time field, based on the calendar&#39;s rules. For example, to subtract 5 days from
 563      * the current time of the calendar, call add(Calendar::DATE, -5). When adding on
 564      * the month or Calendar::MONTH field, other fields like date might conflict and
 565      * need to be changed. For instance, adding 1 month on the date 01/31/96 will result
 566      * in 02/29/96.
 567      * Adding a positive value always means moving forward in time, so for the Gregorian calendar,
 568      * starting with 100 BC and adding +1 to year results in 99 BC (even though this actually reduces
 569      * the numeric value of the field itself).
 570      *
 571      * @param field   Specifies which date field to modify.
 572      * @param amount  The amount of time to be added to the field, in the natural unit
 573      *                for that field (e.g., days for the day fields, hours for the hour
 574      *                field.)
 575      * @param status  Output param set to success/failure code on exit. If any value
 576      *                previously set in the time field is invalid or restricted by
 577      *                leniency, this will be set to an error status.
 578      * @stable ICU 2.6.
 579      */
 580     virtual void add(UCalendarDateFields field, int32_t amount, UErrorCode&amp; status);
 581 
 582 #ifndef U_HIDE_DEPRECATED_API
 583     /**
 584      * Time Field Rolling function. Rolls (up/down) a single unit of time on the given
 585      * time field. For example, to roll the current date up by one day, call
 586      * roll(Calendar::DATE, true). When rolling on the year or Calendar::YEAR field, it
 587      * will roll the year value in the range between getMinimum(Calendar::YEAR) and the
 588      * value returned by getMaximum(Calendar::YEAR). When rolling on the month or
 589      * Calendar::MONTH field, other fields like date might conflict and, need to be
 590      * changed. For instance, rolling the month up on the date 01/31/96 will result in
 591      * 02/29/96. Rolling up always means rolling forward in time (unless the limit of the
 592      * field is reached, in which case it may pin or wrap), so for Gregorian calendar,
 593      * starting with 100 BC and rolling the year up results in 99 BC.
 594      * When eras have a definite beginning and end (as in the Chinese calendar, or as in
 595      * most eras in the Japanese calendar) then rolling the year past either limit of the
 596      * era will cause the year to wrap around. When eras only have a limit at one end,
 597      * then attempting to roll the year past that limit will result in pinning the year
 598      * at that limit. Note that for most calendars in which era 0 years move forward in
 599      * time (such as Buddhist, Hebrew, or Islamic), it is possible for add or roll to
 600      * result in negative years for era 0 (that is the only way to represent years before
 601      * the calendar epoch).
 602      * When rolling on the hour-in-day or Calendar::HOUR_OF_DAY field, it will roll the
 603      * hour value in the range between 0 and 23, which is zero-based.
 604      * &lt;P&gt;
 605      * NOTE: Do not use this method -- use roll(EDateFields, int, UErrorCode&amp;) instead.
 606      *
 607      * @param field   The time field.
 608      * @param up      Indicates if the value of the specified time field is to be rolled
 609      *                up or rolled down. Use true if rolling up, false otherwise.
 610      * @param status  Output param set to success/failure code on exit. If any value
 611      *                previously set in the time field is invalid or restricted by
 612      *                leniency, this will be set to an error status.
 613      * @deprecated ICU 2.6. Use roll(UCalendarDateFields field, UBool up, UErrorCode&amp; status) instead.
 614      */
 615     inline void roll(EDateFields field, UBool up, UErrorCode&amp; status);
 616 #endif  /* U_HIDE_DEPRECATED_API */
 617 
 618     /**
 619      * Time Field Rolling function. Rolls (up/down) a single unit of time on the given
 620      * time field. For example, to roll the current date up by one day, call
 621      * roll(Calendar::DATE, true). When rolling on the year or Calendar::YEAR field, it
 622      * will roll the year value in the range between getMinimum(Calendar::YEAR) and the
 623      * value returned by getMaximum(Calendar::YEAR). When rolling on the month or
 624      * Calendar::MONTH field, other fields like date might conflict and, need to be
 625      * changed. For instance, rolling the month up on the date 01/31/96 will result in
 626      * 02/29/96. Rolling up always means rolling forward in time (unless the limit of the
 627      * field is reached, in which case it may pin or wrap), so for Gregorian calendar,
 628      * starting with 100 BC and rolling the year up results in 99 BC.
 629      * When eras have a definite beginning and end (as in the Chinese calendar, or as in
 630      * most eras in the Japanese calendar) then rolling the year past either limit of the
 631      * era will cause the year to wrap around. When eras only have a limit at one end,
 632      * then attempting to roll the year past that limit will result in pinning the year
 633      * at that limit. Note that for most calendars in which era 0 years move forward in
 634      * time (such as Buddhist, Hebrew, or Islamic), it is possible for add or roll to
 635      * result in negative years for era 0 (that is the only way to represent years before
 636      * the calendar epoch).
 637      * When rolling on the hour-in-day or Calendar::HOUR_OF_DAY field, it will roll the
 638      * hour value in the range between 0 and 23, which is zero-based.
 639      * &lt;P&gt;
 640      * NOTE: Do not use this method -- use roll(UCalendarDateFields, int, UErrorCode&amp;) instead.
 641      *
 642      * @param field   The time field.
 643      * @param up      Indicates if the value of the specified time field is to be rolled
 644      *                up or rolled down. Use true if rolling up, false otherwise.
 645      * @param status  Output param set to success/failure code on exit. If any value
 646      *                previously set in the time field is invalid or restricted by
 647      *                leniency, this will be set to an error status.
 648      * @stable ICU 2.6.
 649      */
 650     inline void roll(UCalendarDateFields field, UBool up, UErrorCode&amp; status);
 651 
 652     /**
 653      * Time Field Rolling function. Rolls by the given amount on the given
 654      * time field. For example, to roll the current date up by one day, call
 655      * roll(Calendar::DATE, +1, status). When rolling on the month or
 656      * Calendar::MONTH field, other fields like date might conflict and, need to be
 657      * changed. For instance, rolling the month up on the date 01/31/96 will result in
 658      * 02/29/96. Rolling by a positive value always means rolling forward in time (unless
 659      * the limit of the field is reached, in which case it may pin or wrap), so for
 660      * Gregorian calendar, starting with 100 BC and rolling the year by + 1 results in 99 BC.
 661      * When eras have a definite beginning and end (as in the Chinese calendar, or as in
 662      * most eras in the Japanese calendar) then rolling the year past either limit of the
 663      * era will cause the year to wrap around. When eras only have a limit at one end,
 664      * then attempting to roll the year past that limit will result in pinning the year
 665      * at that limit. Note that for most calendars in which era 0 years move forward in
 666      * time (such as Buddhist, Hebrew, or Islamic), it is possible for add or roll to
 667      * result in negative years for era 0 (that is the only way to represent years before
 668      * the calendar epoch).
 669      * When rolling on the hour-in-day or Calendar::HOUR_OF_DAY field, it will roll the
 670      * hour value in the range between 0 and 23, which is zero-based.
 671      * &lt;P&gt;
 672      * The only difference between roll() and add() is that roll() does not change
 673      * the value of more significant fields when it reaches the minimum or maximum
 674      * of its range, whereas add() does.
 675      *
 676      * @param field   The time field.
 677      * @param amount  Indicates amount to roll.
 678      * @param status  Output param set to success/failure code on exit. If any value
 679      *                previously set in the time field is invalid, this will be set to
 680      *                an error status.
 681      * @deprecated ICU 2.6. Use roll(UCalendarDateFields field, int32_t amount, UErrorCode&amp; status) instead.
 682      */
 683     virtual void roll(EDateFields field, int32_t amount, UErrorCode&amp; status);
 684 
 685     /**
 686      * Time Field Rolling function. Rolls by the given amount on the given
 687      * time field. For example, to roll the current date up by one day, call
 688      * roll(Calendar::DATE, +1, status). When rolling on the month or
 689      * Calendar::MONTH field, other fields like date might conflict and, need to be
 690      * changed. For instance, rolling the month up on the date 01/31/96 will result in
 691      * 02/29/96. Rolling by a positive value always means rolling forward in time (unless
 692      * the limit of the field is reached, in which case it may pin or wrap), so for
 693      * Gregorian calendar, starting with 100 BC and rolling the year by + 1 results in 99 BC.
 694      * When eras have a definite beginning and end (as in the Chinese calendar, or as in
 695      * most eras in the Japanese calendar) then rolling the year past either limit of the
 696      * era will cause the year to wrap around. When eras only have a limit at one end,
 697      * then attempting to roll the year past that limit will result in pinning the year
 698      * at that limit. Note that for most calendars in which era 0 years move forward in
 699      * time (such as Buddhist, Hebrew, or Islamic), it is possible for add or roll to
 700      * result in negative years for era 0 (that is the only way to represent years before
 701      * the calendar epoch).
 702      * When rolling on the hour-in-day or Calendar::HOUR_OF_DAY field, it will roll the
 703      * hour value in the range between 0 and 23, which is zero-based.
 704      * &lt;P&gt;
 705      * The only difference between roll() and add() is that roll() does not change
 706      * the value of more significant fields when it reaches the minimum or maximum
 707      * of its range, whereas add() does.
 708      *
 709      * @param field   The time field.
 710      * @param amount  Indicates amount to roll.
 711      * @param status  Output param set to success/failure code on exit. If any value
 712      *                previously set in the time field is invalid, this will be set to
 713      *                an error status.
 714      * @stable ICU 2.6.
 715      */
 716     virtual void roll(UCalendarDateFields field, int32_t amount, UErrorCode&amp; status);
 717 
 718     /**
 719      * Return the difference between the given time and the time this
 720      * calendar object is set to.  If this calendar is set
 721      * &lt;em&gt;before&lt;/em&gt; the given time, the returned value will be
 722      * positive.  If this calendar is set &lt;em&gt;after&lt;/em&gt; the given
 723      * time, the returned value will be negative.  The
 724      * &lt;code&gt;field&lt;/code&gt; parameter specifies the units of the return
 725      * value.  For example, if &lt;code&gt;fieldDifference(when,
 726      * Calendar::MONTH)&lt;/code&gt; returns 3, then this calendar is set to
 727      * 3 months before &lt;code&gt;when&lt;/code&gt;, and possibly some addition
 728      * time less than one month.
 729      *
 730      * &lt;p&gt;As a side effect of this call, this calendar is advanced
 731      * toward &lt;code&gt;when&lt;/code&gt; by the given amount.  That is, calling
 732      * this method has the side effect of calling &lt;code&gt;add(field,
 733      * n)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the return value.
 734      *
 735      * &lt;p&gt;Usage: To use this method, call it first with the largest
 736      * field of interest, then with progressively smaller fields.  For
 737      * example:
 738      *
 739      * &lt;pre&gt;
 740      * int y = cal-&gt;fieldDifference(when, Calendar::YEAR, err);
 741      * int m = cal-&gt;fieldDifference(when, Calendar::MONTH, err);
 742      * int d = cal-&gt;fieldDifference(when, Calendar::DATE, err);&lt;/pre&gt;
 743      *
 744      * computes the difference between &lt;code&gt;cal&lt;/code&gt; and
 745      * &lt;code&gt;when&lt;/code&gt; in years, months, and days.
 746      *
 747      * &lt;p&gt;Note: &lt;code&gt;fieldDifference()&lt;/code&gt; is
 748      * &lt;em&gt;asymmetrical&lt;/em&gt;.  That is, in the following code:
 749      *
 750      * &lt;pre&gt;
 751      * cal-&gt;setTime(date1, err);
 752      * int m1 = cal-&gt;fieldDifference(date2, Calendar::MONTH, err);
 753      * int d1 = cal-&gt;fieldDifference(date2, Calendar::DATE, err);
 754      * cal-&gt;setTime(date2, err);
 755      * int m2 = cal-&gt;fieldDifference(date1, Calendar::MONTH, err);
 756      * int d2 = cal-&gt;fieldDifference(date1, Calendar::DATE, err);&lt;/pre&gt;
 757      *
 758      * one might expect that &lt;code&gt;m1 == -m2 &amp;&amp; d1 == -d2&lt;/code&gt;.
 759      * However, this is not generally the case, because of
 760      * irregularities in the underlying calendar system (e.g., the
 761      * Gregorian calendar has a varying number of days per month).
 762      *
 763      * @param when the date to compare this calendar&#39;s time to
 764      * @param field the field in which to compute the result
 765      * @param status  Output param set to success/failure code on exit. If any value
 766      *                previously set in the time field is invalid, this will be set to
 767      *                an error status.
 768      * @return the difference, either positive or negative, between
 769      * this calendar&#39;s time and &lt;code&gt;when&lt;/code&gt;, in terms of
 770      * &lt;code&gt;field&lt;/code&gt;.
 771      * @deprecated ICU 2.6. Use fieldDifference(UDate when, UCalendarDateFields field, UErrorCode&amp; status).
 772      */
 773     virtual int32_t fieldDifference(UDate when, EDateFields field, UErrorCode&amp; status);
 774 
 775     /**
 776      * Return the difference between the given time and the time this
 777      * calendar object is set to.  If this calendar is set
 778      * &lt;em&gt;before&lt;/em&gt; the given time, the returned value will be
 779      * positive.  If this calendar is set &lt;em&gt;after&lt;/em&gt; the given
 780      * time, the returned value will be negative.  The
 781      * &lt;code&gt;field&lt;/code&gt; parameter specifies the units of the return
 782      * value.  For example, if &lt;code&gt;fieldDifference(when,
 783      * Calendar::MONTH)&lt;/code&gt; returns 3, then this calendar is set to
 784      * 3 months before &lt;code&gt;when&lt;/code&gt;, and possibly some addition
 785      * time less than one month.
 786      *
 787      * &lt;p&gt;As a side effect of this call, this calendar is advanced
 788      * toward &lt;code&gt;when&lt;/code&gt; by the given amount.  That is, calling
 789      * this method has the side effect of calling &lt;code&gt;add(field,
 790      * n)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the return value.
 791      *
 792      * &lt;p&gt;Usage: To use this method, call it first with the largest
 793      * field of interest, then with progressively smaller fields.  For
 794      * example:
 795      *
 796      * &lt;pre&gt;
 797      * int y = cal-&gt;fieldDifference(when, Calendar::YEAR, err);
 798      * int m = cal-&gt;fieldDifference(when, Calendar::MONTH, err);
 799      * int d = cal-&gt;fieldDifference(when, Calendar::DATE, err);&lt;/pre&gt;
 800      *
 801      * computes the difference between &lt;code&gt;cal&lt;/code&gt; and
 802      * &lt;code&gt;when&lt;/code&gt; in years, months, and days.
 803      *
 804      * &lt;p&gt;Note: &lt;code&gt;fieldDifference()&lt;/code&gt; is
 805      * &lt;em&gt;asymmetrical&lt;/em&gt;.  That is, in the following code:
 806      *
 807      * &lt;pre&gt;
 808      * cal-&gt;setTime(date1, err);
 809      * int m1 = cal-&gt;fieldDifference(date2, Calendar::MONTH, err);
 810      * int d1 = cal-&gt;fieldDifference(date2, Calendar::DATE, err);
 811      * cal-&gt;setTime(date2, err);
 812      * int m2 = cal-&gt;fieldDifference(date1, Calendar::MONTH, err);
 813      * int d2 = cal-&gt;fieldDifference(date1, Calendar::DATE, err);&lt;/pre&gt;
 814      *
 815      * one might expect that &lt;code&gt;m1 == -m2 &amp;&amp; d1 == -d2&lt;/code&gt;.
 816      * However, this is not generally the case, because of
 817      * irregularities in the underlying calendar system (e.g., the
 818      * Gregorian calendar has a varying number of days per month).
 819      *
 820      * @param when the date to compare this calendar&#39;s time to
 821      * @param field the field in which to compute the result
 822      * @param status  Output param set to success/failure code on exit. If any value
 823      *                previously set in the time field is invalid, this will be set to
 824      *                an error status.
 825      * @return the difference, either positive or negative, between
 826      * this calendar&#39;s time and &lt;code&gt;when&lt;/code&gt;, in terms of
 827      * &lt;code&gt;field&lt;/code&gt;.
 828      * @stable ICU 2.6.
 829      */
 830     virtual int32_t fieldDifference(UDate when, UCalendarDateFields field, UErrorCode&amp; status);
 831 
 832     /**
 833      * Sets the calendar&#39;s time zone to be the one passed in. The Calendar takes ownership
 834      * of the TimeZone; the caller is no longer responsible for deleting it.  If the
 835      * given time zone is NULL, this function has no effect.
 836      *
 837      * @param value  The given time zone.
 838      * @stable ICU 2.0
 839      */
 840     void adoptTimeZone(TimeZone* value);
 841 
 842     /**
 843      * Sets the calendar&#39;s time zone to be the same as the one passed in. The TimeZone
 844      * passed in is _not_ adopted; the client is still responsible for deleting it.
 845      *
 846      * @param zone  The given time zone.
 847      * @stable ICU 2.0
 848      */
 849     void setTimeZone(const TimeZone&amp; zone);
 850 
 851     /**
 852      * Returns a reference to the time zone owned by this calendar. The returned reference
 853      * is only valid until clients make another call to adoptTimeZone or setTimeZone,
 854      * or this Calendar is destroyed.
 855      *
 856      * @return   The time zone object associated with this calendar.
 857      * @stable ICU 2.0
 858      */
 859     const TimeZone&amp; getTimeZone(void) const;
 860 
 861     /**
 862      * Returns the time zone owned by this calendar. The caller owns the returned object
 863      * and must delete it when done.  After this call, the new time zone associated
 864      * with this Calendar is the default TimeZone as returned by TimeZone::createDefault().
 865      *
 866      * @return   The time zone object which was associated with this calendar.
 867      * @stable ICU 2.0
 868      */
 869     TimeZone* orphanTimeZone(void);
 870 
 871     /**
 872      * Queries if the current date for this Calendar is in Daylight Savings Time.
 873      *
 874      * @param status Fill-in parameter which receives the status of this operation.
 875      * @return   True if the current date for this Calendar is in Daylight Savings Time,
 876      *           false, otherwise.
 877      * @stable ICU 2.0
 878      */
 879     virtual UBool inDaylightTime(UErrorCode&amp; status) const = 0;
 880 
 881     /**
 882      * Specifies whether or not date/time interpretation is to be lenient. With lenient
 883      * interpretation, a date such as &quot;February 942, 1996&quot; will be treated as being
 884      * equivalent to the 941st day after February 1, 1996. With strict interpretation,
 885      * such dates will cause an error when computing time from the time field values
 886      * representing the dates.
 887      *
 888      * @param lenient  True specifies date/time interpretation to be lenient.
 889      *
 890      * @see            DateFormat#setLenient
 891      * @stable ICU 2.0
 892      */
 893     void setLenient(UBool lenient);
 894 
 895     /**
 896      * Tells whether date/time interpretation is to be lenient.
 897      *
 898      * @return   True tells that date/time interpretation is to be lenient.
 899      * @stable ICU 2.0
 900      */
 901     UBool isLenient(void) const;
 902 
 903     /**
 904      * Sets the behavior for handling wall time repeating multiple times
 905      * at negative time zone offset transitions. For example, 1:30 AM on
<a name="32" id="anc32"></a><span class="line-modified"> 906      * November 6, 2011 in US Eastern time (Ameirca/New_York) occurs twice;</span>
 907      * 1:30 AM EDT, then 1:30 AM EST one hour later. When &lt;code&gt;UCAL_WALLTIME_FIRST&lt;/code&gt;
 908      * is used, the wall time 1:30AM in this example will be interpreted as 1:30 AM EDT
 909      * (first occurrence). When &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt; is used, it will be
 910      * interpreted as 1:30 AM EST (last occurrence). The default value is
 911      * &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt;.
 912      * &lt;p&gt;
 913      * &lt;b&gt;Note:&lt;/b&gt;When &lt;code&gt;UCAL_WALLTIME_NEXT_VALID&lt;/code&gt; is not a valid
 914      * option for this. When the argument is neither &lt;code&gt;UCAL_WALLTIME_FIRST&lt;/code&gt;
 915      * nor &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt;, this method has no effect and will keep
 916      * the current setting.
 917      *
 918      * @param option the behavior for handling repeating wall time, either
 919      * &lt;code&gt;UCAL_WALLTIME_FIRST&lt;/code&gt; or &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt;.
 920      * @see #getRepeatedWallTimeOption
 921      * @stable ICU 49
 922      */
 923     void setRepeatedWallTimeOption(UCalendarWallTimeOption option);
 924 
 925     /**
 926      * Gets the behavior for handling wall time repeating multiple times
 927      * at negative time zone offset transitions.
 928      *
 929      * @return the behavior for handling repeating wall time, either
 930      * &lt;code&gt;UCAL_WALLTIME_FIRST&lt;/code&gt; or &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt;.
 931      * @see #setRepeatedWallTimeOption
 932      * @stable ICU 49
 933      */
 934     UCalendarWallTimeOption getRepeatedWallTimeOption(void) const;
 935 
 936     /**
 937      * Sets the behavior for handling skipped wall time at positive time zone offset
 938      * transitions. For example, 2:30 AM on March 13, 2011 in US Eastern time (America/New_York)
 939      * does not exist because the wall time jump from 1:59 AM EST to 3:00 AM EDT. When
 940      * &lt;code&gt;UCAL_WALLTIME_FIRST&lt;/code&gt; is used, 2:30 AM is interpreted as 30 minutes before 3:00 AM
 941      * EDT, therefore, it will be resolved as 1:30 AM EST. When &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt;
 942      * is used, 2:30 AM is interpreted as 31 minutes after 1:59 AM EST, therefore, it will be
 943      * resolved as 3:30 AM EDT. When &lt;code&gt;UCAL_WALLTIME_NEXT_VALID&lt;/code&gt; is used, 2:30 AM will
 944      * be resolved as next valid wall time, that is 3:00 AM EDT. The default value is
 945      * &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt;.
 946      * &lt;p&gt;
 947      * &lt;b&gt;Note:&lt;/b&gt;This option is effective only when this calendar is lenient.
 948      * When the calendar is strict, such non-existing wall time will cause an error.
 949      *
 950      * @param option the behavior for handling skipped wall time at positive time zone
 951      * offset transitions, one of &lt;code&gt;UCAL_WALLTIME_FIRST&lt;/code&gt;, &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt; and
 952      * &lt;code&gt;UCAL_WALLTIME_NEXT_VALID&lt;/code&gt;.
 953      * @see #getSkippedWallTimeOption
 954      *
 955      * @stable ICU 49
 956      */
 957     void setSkippedWallTimeOption(UCalendarWallTimeOption option);
 958 
 959     /**
 960      * Gets the behavior for handling skipped wall time at positive time zone offset
 961      * transitions.
 962      *
 963      * @return the behavior for handling skipped wall time, one of
 964      * &lt;code&gt;UCAL_WALLTIME_FIRST&lt;/code&gt;, &lt;code&gt;UCAL_WALLTIME_LAST&lt;/code&gt;
 965      * and &lt;code&gt;UCAL_WALLTIME_NEXT_VALID&lt;/code&gt;.
 966      * @see #setSkippedWallTimeOption
 967      * @stable ICU 49
 968      */
 969     UCalendarWallTimeOption getSkippedWallTimeOption(void) const;
 970 
 971 #ifndef U_HIDE_DEPRECATED_API
 972     /**
 973      * Sets what the first day of the week is; e.g., Sunday in US, Monday in France.
 974      *
 975      * @param value  The given first day of the week.
 976      * @deprecated ICU 2.6. Use setFirstDayOfWeek(UCalendarDaysOfWeek value) instead.
 977      */
 978     void setFirstDayOfWeek(EDaysOfWeek value);
 979 #endif  /* U_HIDE_DEPRECATED_API */
 980 
 981     /**
 982      * Sets what the first day of the week is; e.g., Sunday in US, Monday in France.
 983      *
 984      * @param value  The given first day of the week.
 985      * @stable ICU 2.6.
 986      */
 987     void setFirstDayOfWeek(UCalendarDaysOfWeek value);
 988 
 989 #ifndef U_HIDE_DEPRECATED_API
 990     /**
 991      * Gets what the first day of the week is; e.g., Sunday in US, Monday in France.
 992      *
 993      * @return   The first day of the week.
 994      * @deprecated ICU 2.6 use the overload with error code
 995      */
 996     EDaysOfWeek getFirstDayOfWeek(void) const;
 997 #endif  /* U_HIDE_DEPRECATED_API */
 998 
 999     /**
1000      * Gets what the first day of the week is; e.g., Sunday in US, Monday in France.
1001      *
1002      * @param status error code
1003      * @return   The first day of the week.
1004      * @stable ICU 2.6
1005      */
1006     UCalendarDaysOfWeek getFirstDayOfWeek(UErrorCode &amp;status) const;
1007 
1008     /**
1009      * Sets what the minimal days required in the first week of the year are; For
1010      * example, if the first week is defined as one that contains the first day of the
1011      * first month of a year, call the method with value 1. If it must be a full week,
1012      * use value 7.
1013      *
1014      * @param value  The given minimal days required in the first week of the year.
1015      * @stable ICU 2.0
1016      */
1017     void setMinimalDaysInFirstWeek(uint8_t value);
1018 
1019     /**
1020      * Gets what the minimal days required in the first week of the year are; e.g., if
1021      * the first week is defined as one that contains the first day of the first month
1022      * of a year, getMinimalDaysInFirstWeek returns 1. If the minimal days required must
1023      * be a full week, getMinimalDaysInFirstWeek returns 7.
1024      *
1025      * @return   The minimal days required in the first week of the year.
1026      * @stable ICU 2.0
1027      */
1028     uint8_t getMinimalDaysInFirstWeek(void) const;
1029 
1030     /**
1031      * Gets the minimum value for the given time field. e.g., for Gregorian
1032      * DAY_OF_MONTH, 1.
1033      *
1034      * @param field  The given time field.
1035      * @return       The minimum value for the given time field.
1036      * @deprecated ICU 2.6. Use getMinimum(UCalendarDateFields field) instead.
1037      */
1038     virtual int32_t getMinimum(EDateFields field) const;
1039 
1040     /**
1041      * Gets the minimum value for the given time field. e.g., for Gregorian
1042      * DAY_OF_MONTH, 1.
1043      *
1044      * @param field  The given time field.
1045      * @return       The minimum value for the given time field.
1046      * @stable ICU 2.6.
1047      */
1048     virtual int32_t getMinimum(UCalendarDateFields field) const;
1049 
1050     /**
1051      * Gets the maximum value for the given time field. e.g. for Gregorian DAY_OF_MONTH,
1052      * 31.
1053      *
1054      * @param field  The given time field.
1055      * @return       The maximum value for the given time field.
1056      * @deprecated ICU 2.6. Use getMaximum(UCalendarDateFields field) instead.
1057      */
1058     virtual int32_t getMaximum(EDateFields field) const;
1059 
1060     /**
1061      * Gets the maximum value for the given time field. e.g. for Gregorian DAY_OF_MONTH,
1062      * 31.
1063      *
1064      * @param field  The given time field.
1065      * @return       The maximum value for the given time field.
1066      * @stable ICU 2.6.
1067      */
1068     virtual int32_t getMaximum(UCalendarDateFields field) const;
1069 
1070     /**
1071      * Gets the highest minimum value for the given field if varies. Otherwise same as
1072      * getMinimum(). For Gregorian, no difference.
1073      *
1074      * @param field  The given time field.
1075      * @return       The highest minimum value for the given time field.
1076      * @deprecated ICU 2.6. Use getGreatestMinimum(UCalendarDateFields field) instead.
1077      */
1078     virtual int32_t getGreatestMinimum(EDateFields field) const;
1079 
1080     /**
1081      * Gets the highest minimum value for the given field if varies. Otherwise same as
1082      * getMinimum(). For Gregorian, no difference.
1083      *
1084      * @param field  The given time field.
1085      * @return       The highest minimum value for the given time field.
1086      * @stable ICU 2.6.
1087      */
1088     virtual int32_t getGreatestMinimum(UCalendarDateFields field) const;
1089 
1090     /**
1091      * Gets the lowest maximum value for the given field if varies. Otherwise same as
1092      * getMaximum(). e.g., for Gregorian DAY_OF_MONTH, 28.
1093      *
1094      * @param field  The given time field.
1095      * @return       The lowest maximum value for the given time field.
1096      * @deprecated ICU 2.6. Use getLeastMaximum(UCalendarDateFields field) instead.
1097      */
1098     virtual int32_t getLeastMaximum(EDateFields field) const;
1099 
1100     /**
1101      * Gets the lowest maximum value for the given field if varies. Otherwise same as
1102      * getMaximum(). e.g., for Gregorian DAY_OF_MONTH, 28.
1103      *
1104      * @param field  The given time field.
1105      * @return       The lowest maximum value for the given time field.
1106      * @stable ICU 2.6.
1107      */
1108     virtual int32_t getLeastMaximum(UCalendarDateFields field) const;
1109 
1110 #ifndef U_HIDE_DEPRECATED_API
1111     /**
1112      * Return the minimum value that this field could have, given the current date.
1113      * For the Gregorian calendar, this is the same as getMinimum() and getGreatestMinimum().
1114      *
1115      * The version of this function on Calendar uses an iterative algorithm to determine the
1116      * actual minimum value for the field.  There is almost always a more efficient way to
1117      * accomplish this (in most cases, you can simply return getMinimum()).  GregorianCalendar
1118      * overrides this function with a more efficient implementation.
1119      *
1120      * @param field    the field to determine the minimum of
1121      * @param status   Fill-in parameter which receives the status of this operation.
1122      * @return         the minimum of the given field for the current date of this Calendar
1123      * @deprecated ICU 2.6. Use getActualMinimum(UCalendarDateFields field, UErrorCode&amp; status) instead.
1124      */
1125     int32_t getActualMinimum(EDateFields field, UErrorCode&amp; status) const;
1126 #endif  /* U_HIDE_DEPRECATED_API */
1127 
1128     /**
1129      * Return the minimum value that this field could have, given the current date.
1130      * For the Gregorian calendar, this is the same as getMinimum() and getGreatestMinimum().
1131      *
1132      * The version of this function on Calendar uses an iterative algorithm to determine the
1133      * actual minimum value for the field.  There is almost always a more efficient way to
1134      * accomplish this (in most cases, you can simply return getMinimum()).  GregorianCalendar
1135      * overrides this function with a more efficient implementation.
1136      *
1137      * @param field    the field to determine the minimum of
1138      * @param status   Fill-in parameter which receives the status of this operation.
1139      * @return         the minimum of the given field for the current date of this Calendar
1140      * @stable ICU 2.6.
1141      */
1142     virtual int32_t getActualMinimum(UCalendarDateFields field, UErrorCode&amp; status) const;
1143 
1144 #ifndef U_HIDE_DEPRECATED_API
1145     /**
1146      * Return the maximum value that this field could have, given the current date.
1147      * For example, with the date &quot;Feb 3, 1997&quot; and the DAY_OF_MONTH field, the actual
1148      * maximum would be 28; for &quot;Feb 3, 1996&quot; it s 29.  Similarly for a Hebrew calendar,
1149      * for some years the actual maximum for MONTH is 12, and for others 13.
1150      *
1151      * The version of this function on Calendar uses an iterative algorithm to determine the
1152      * actual maximum value for the field.  There is almost always a more efficient way to
1153      * accomplish this (in most cases, you can simply return getMaximum()).  GregorianCalendar
1154      * overrides this function with a more efficient implementation.
1155      *
1156      * @param field    the field to determine the maximum of
1157      * @param status   Fill-in parameter which receives the status of this operation.
1158      * @return         the maximum of the given field for the current date of this Calendar
1159      * @deprecated ICU 2.6. Use getActualMaximum(UCalendarDateFields field, UErrorCode&amp; status) instead.
1160      */
1161     int32_t getActualMaximum(EDateFields field, UErrorCode&amp; status) const;
1162 #endif  /* U_HIDE_DEPRECATED_API */
1163 
1164     /**
1165      * Return the maximum value that this field could have, given the current date.
1166      * For example, with the date &quot;Feb 3, 1997&quot; and the DAY_OF_MONTH field, the actual
1167      * maximum would be 28; for &quot;Feb 3, 1996&quot; it s 29.  Similarly for a Hebrew calendar,
1168      * for some years the actual maximum for MONTH is 12, and for others 13.
1169      *
1170      * The version of this function on Calendar uses an iterative algorithm to determine the
1171      * actual maximum value for the field.  There is almost always a more efficient way to
1172      * accomplish this (in most cases, you can simply return getMaximum()).  GregorianCalendar
1173      * overrides this function with a more efficient implementation.
1174      *
1175      * @param field    the field to determine the maximum of
1176      * @param status   Fill-in parameter which receives the status of this operation.
1177      * @return         the maximum of the given field for the current date of this Calendar
1178      * @stable ICU 2.6.
1179      */
1180     virtual int32_t getActualMaximum(UCalendarDateFields field, UErrorCode&amp; status) const;
1181 
1182 #ifndef U_HIDE_DEPRECATED_API
1183     /**
1184      * Gets the value for a given time field. Recalculate the current time field values
1185      * if the time value has been changed by a call to setTime(). Return zero for unset
1186      * fields if any fields have been explicitly set by a call to set(). To force a
1187      * recomputation of all fields regardless of the previous state, call complete().
1188      * This method is semantically const, but may alter the object in memory.
1189      *
1190      * @param field  The given time field.
1191      * @param status Fill-in parameter which receives the status of the operation.
1192      * @return       The value for the given time field, or zero if the field is unset,
1193      *               and set() has been called for any other field.
1194      * @deprecated ICU 2.6. Use get(UCalendarDateFields field, UErrorCode&amp; status) instead.
1195      */
1196     int32_t get(EDateFields field, UErrorCode&amp; status) const;
1197 #endif  /* U_HIDE_DEPRECATED_API */
1198 
1199     /**
1200      * Gets the value for a given time field. Recalculate the current time field values
1201      * if the time value has been changed by a call to setTime(). Return zero for unset
1202      * fields if any fields have been explicitly set by a call to set(). To force a
1203      * recomputation of all fields regardless of the previous state, call complete().
1204      * This method is semantically const, but may alter the object in memory.
1205      *
1206      * @param field  The given time field.
1207      * @param status Fill-in parameter which receives the status of the operation.
1208      * @return       The value for the given time field, or zero if the field is unset,
1209      *               and set() has been called for any other field.
1210      * @stable ICU 2.6.
1211      */
1212     int32_t get(UCalendarDateFields field, UErrorCode&amp; status) const;
1213 
1214 #ifndef U_HIDE_DEPRECATED_API
1215     /**
1216      * Determines if the given time field has a value set. This can affect in the
1217      * resolving of time in Calendar. Unset fields have a value of zero, by definition.
1218      *
1219      * @param field  The given time field.
1220      * @return   True if the given time field has a value set; false otherwise.
1221      * @deprecated ICU 2.6. Use isSet(UCalendarDateFields field) instead.
1222      */
1223     UBool isSet(EDateFields field) const;
1224 #endif  /* U_HIDE_DEPRECATED_API */
1225 
1226     /**
1227      * Determines if the given time field has a value set. This can affect in the
1228      * resolving of time in Calendar. Unset fields have a value of zero, by definition.
1229      *
1230      * @param field  The given time field.
1231      * @return   True if the given time field has a value set; false otherwise.
1232      * @stable ICU 2.6.
1233      */
1234     UBool isSet(UCalendarDateFields field) const;
1235 
1236 #ifndef U_HIDE_DEPRECATED_API
1237     /**
1238      * Sets the given time field with the given value.
1239      *
1240      * @param field  The given time field.
1241      * @param value  The value to be set for the given time field.
1242      * @deprecated ICU 2.6. Use set(UCalendarDateFields field, int32_t value) instead.
1243      */
1244     void set(EDateFields field, int32_t value);
1245 #endif  /* U_HIDE_DEPRECATED_API */
1246 
1247     /**
1248      * Sets the given time field with the given value.
1249      *
1250      * @param field  The given time field.
1251      * @param value  The value to be set for the given time field.
1252      * @stable ICU 2.6.
1253      */
1254     void set(UCalendarDateFields field, int32_t value);
1255 
1256     /**
1257      * Sets the values for the fields YEAR, MONTH, and DATE. Other field values are
1258      * retained; call clear() first if this is not desired.
1259      *
1260      * @param year   The value used to set the YEAR time field.
1261      * @param month  The value used to set the MONTH time field. Month value is 0-based.
1262      *               e.g., 0 for January.
1263      * @param date   The value used to set the DATE time field.
1264      * @stable ICU 2.0
1265      */
1266     void set(int32_t year, int32_t month, int32_t date);
1267 
1268     /**
1269      * Sets the values for the fields YEAR, MONTH, DATE, HOUR_OF_DAY, and MINUTE. Other
1270      * field values are retained; call clear() first if this is not desired.
1271      *
1272      * @param year    The value used to set the YEAR time field.
1273      * @param month   The value used to set the MONTH time field. Month value is
1274      *                0-based. E.g., 0 for January.
1275      * @param date    The value used to set the DATE time field.
1276      * @param hour    The value used to set the HOUR_OF_DAY time field.
1277      * @param minute  The value used to set the MINUTE time field.
1278      * @stable ICU 2.0
1279      */
1280     void set(int32_t year, int32_t month, int32_t date, int32_t hour, int32_t minute);
1281 
1282     /**
1283      * Sets the values for the fields YEAR, MONTH, DATE, HOUR_OF_DAY, MINUTE, and SECOND.
1284      * Other field values are retained; call clear() first if this is not desired.
1285      *
1286      * @param year    The value used to set the YEAR time field.
1287      * @param month   The value used to set the MONTH time field. Month value is
1288      *                0-based. E.g., 0 for January.
1289      * @param date    The value used to set the DATE time field.
1290      * @param hour    The value used to set the HOUR_OF_DAY time field.
1291      * @param minute  The value used to set the MINUTE time field.
1292      * @param second  The value used to set the SECOND time field.
1293      * @stable ICU 2.0
1294      */
1295     void set(int32_t year, int32_t month, int32_t date, int32_t hour, int32_t minute, int32_t second);
1296 
1297     /**
1298      * Clears the values of all the time fields, making them both unset and assigning
1299      * them a value of zero. The field values will be determined during the next
1300      * resolving of time into time fields.
1301      * @stable ICU 2.0
1302      */
1303     void clear(void);
1304 
1305 #ifndef U_HIDE_DEPRECATED_API
1306     /**
1307      * Clears the value in the given time field, both making it unset and assigning it a
1308      * value of zero. This field value will be determined during the next resolving of
1309      * time into time fields.
1310      *
1311      * @param field  The time field to be cleared.
1312      * @deprecated ICU 2.6. Use clear(UCalendarDateFields field) instead.
1313      */
1314     void clear(EDateFields field);
1315 #endif  /* U_HIDE_DEPRECATED_API */
1316 
1317     /**
1318      * Clears the value in the given time field, both making it unset and assigning it a
1319      * value of zero. This field value will be determined during the next resolving of
1320      * time into time fields.
1321      *
1322      * @param field  The time field to be cleared.
1323      * @stable ICU 2.6.
1324      */
1325     void clear(UCalendarDateFields field);
1326 
1327     /**
1328      * Returns a unique class ID POLYMORPHICALLY. Pure virtual method. This method is to
1329      * implement a simple version of RTTI, since not all C++ compilers support genuine
1330      * RTTI. Polymorphic operator==() and clone() methods call this method.
1331      * &lt;P&gt;
1332      * Concrete subclasses of Calendar must implement getDynamicClassID() and also a
1333      * static method and data member:
1334      *
1335      *      static UClassID getStaticClassID() { return (UClassID)&amp;amp;fgClassID; }
1336      *      static char fgClassID;
1337      *
1338      * @return   The class ID for this object. All objects of a given class have the
1339      *           same class ID. Objects of other classes have different class IDs.
1340      * @stable ICU 2.0
1341      */
1342     virtual UClassID getDynamicClassID(void) const = 0;
1343 
1344     /**
1345      * Returns the calendar type name string for this Calendar object.
1346      * The returned string is the legacy ICU calendar attribute value,
1347      * for example, &quot;gregorian&quot; or &quot;japanese&quot;.
1348      *
1349      * See type=&quot;old type name&quot; for the calendar attribute of locale IDs
1350      * at http://www.unicode.org/reports/tr35/#Key_Type_Definitions
1351      *
1352      * Sample code for getting the LDML/BCP 47 calendar key value:
1353      * \code
1354      * const char *calType = cal-&gt;getType();
1355      * if (0 == strcmp(calType, &quot;unknown&quot;)) {
1356      *     // deal with unknown calendar type
1357      * } else {
1358      *     string localeID(&quot;root@calendar=&quot;);
1359      *     localeID.append(calType);
1360      *     char langTag[100];
1361      *     UErrorCode errorCode = U_ZERO_ERROR;
1362      *     int32_t length = uloc_toLanguageTag(localeID.c_str(), langTag, (int32_t)sizeof(langTag), TRUE, &amp;errorCode);
1363      *     if (U_FAILURE(errorCode)) {
1364      *         // deal with errors &amp; overflow
1365      *     }
1366      *     string lang(langTag, length);
1367      *     size_t caPos = lang.find(&quot;-ca-&quot;);
1368      *     lang.erase(0, caPos + 4);
1369      *     // lang now contains the LDML calendar type
1370      * }
1371      * \endcode
1372      *
1373      * @return legacy calendar type name string
1374      * @stable ICU 49
1375      */
1376     virtual const char * getType() const = 0;
1377 
1378     /**
1379      * Returns whether the given day of the week is a weekday, a weekend day,
1380      * or a day that transitions from one to the other, for the locale and
1381      * calendar system associated with this Calendar (the locale&#39;s region is
1382      * often the most determinant factor). If a transition occurs at midnight,
1383      * then the days before and after the transition will have the
1384      * type UCAL_WEEKDAY or UCAL_WEEKEND. If a transition occurs at a time
1385      * other than midnight, then the day of the transition will have
1386      * the type UCAL_WEEKEND_ONSET or UCAL_WEEKEND_CEASE. In this case, the
1387      * method getWeekendTransition() will return the point of
1388      * transition.
1389      * @param dayOfWeek The day of the week whose type is desired (UCAL_SUNDAY..UCAL_SATURDAY).
1390      * @param status The error code for the operation.
1391      * @return The UCalendarWeekdayType for the day of the week.
1392      * @stable ICU 4.4
1393      */
1394     virtual UCalendarWeekdayType getDayOfWeekType(UCalendarDaysOfWeek dayOfWeek, UErrorCode &amp;status) const;
1395 
1396     /**
1397      * Returns the time during the day at which the weekend begins or ends in
1398      * this calendar system.  If getDayOfWeekType() returns UCAL_WEEKEND_ONSET
1399      * for the specified dayOfWeek, return the time at which the weekend begins.
1400      * If getDayOfWeekType() returns UCAL_WEEKEND_CEASE for the specified dayOfWeek,
1401      * return the time at which the weekend ends. If getDayOfWeekType() returns
1402      * some other UCalendarWeekdayType for the specified dayOfWeek, is it an error condition
1403      * (U_ILLEGAL_ARGUMENT_ERROR).
1404      * @param dayOfWeek The day of the week for which the weekend transition time is
1405      * desired (UCAL_SUNDAY..UCAL_SATURDAY).
1406      * @param status The error code for the operation.
1407      * @return The milliseconds after midnight at which the weekend begins or ends.
1408      * @stable ICU 4.4
1409      */
1410     virtual int32_t getWeekendTransition(UCalendarDaysOfWeek dayOfWeek, UErrorCode &amp;status) const;
1411 
1412     /**
1413      * Returns TRUE if the given UDate is in the weekend in
1414      * this calendar system.
1415      * @param date The UDate in question.
1416      * @param status The error code for the operation.
1417      * @return TRUE if the given UDate is in the weekend in
1418      * this calendar system, FALSE otherwise.
1419      * @stable ICU 4.4
1420      */
1421     virtual UBool isWeekend(UDate date, UErrorCode &amp;status) const;
1422 
1423     /**
1424      * Returns TRUE if this Calendar&#39;s current date-time is in the weekend in
1425      * this calendar system.
1426      * @return TRUE if this Calendar&#39;s current date-time is in the weekend in
1427      * this calendar system, FALSE otherwise.
1428      * @stable ICU 4.4
1429      */
1430     virtual UBool isWeekend(void) const;
1431 
1432 protected:
1433 
1434      /**
1435       * Constructs a Calendar with the default time zone as returned by
1436       * TimeZone::createInstance(), and the default locale.
1437       *
1438       * @param success  Indicates the status of Calendar object construction. Returns
1439       *                 U_ZERO_ERROR if constructed successfully.
1440      * @stable ICU 2.0
1441       */
1442     Calendar(UErrorCode&amp; success);
1443 
1444     /**
1445      * Copy constructor
1446      *
1447      * @param source    Calendar object to be copied from
1448      * @stable ICU 2.0
1449      */
1450     Calendar(const Calendar&amp; source);
1451 
1452     /**
1453      * Default assignment operator
1454      *
1455      * @param right    Calendar object to be copied
1456      * @stable ICU 2.0
1457      */
1458     Calendar&amp; operator=(const Calendar&amp; right);
1459 
1460     /**
1461      * Constructs a Calendar with the given time zone and locale. Clients are no longer
1462      * responsible for deleting the given time zone object after it&#39;s adopted.
1463      *
1464      * @param zone     The given time zone.
1465      * @param aLocale  The given locale.
1466      * @param success  Indicates the status of Calendar object construction. Returns
1467      *                 U_ZERO_ERROR if constructed successfully.
1468      * @stable ICU 2.0
1469      */
1470     Calendar(TimeZone* zone, const Locale&amp; aLocale, UErrorCode&amp; success);
1471 
1472     /**
1473      * Constructs a Calendar with the given time zone and locale.
1474      *
1475      * @param zone     The given time zone.
1476      * @param aLocale  The given locale.
1477      * @param success  Indicates the status of Calendar object construction. Returns
1478      *                 U_ZERO_ERROR if constructed successfully.
1479      * @stable ICU 2.0
1480      */
1481     Calendar(const TimeZone&amp; zone, const Locale&amp; aLocale, UErrorCode&amp; success);
1482 
1483     /**
1484      * Converts Calendar&#39;s time field values to GMT as milliseconds.
1485      *
1486      * @param status  Output param set to success/failure code on exit. If any value
1487      *                previously set in the time field is invalid or restricted by
1488      *                leniency, this will be set to an error status.
1489      * @stable ICU 2.0
1490      */
1491     virtual void computeTime(UErrorCode&amp; status);
1492 
1493     /**
1494      * Converts GMT as milliseconds to time field values. This allows you to sync up the
1495      * time field values with a new time that is set for the calendar.  This method
1496      * does NOT recompute the time first; to recompute the time, then the fields, use
1497      * the method complete().
1498      *
1499      * @param status  Output param set to success/failure code on exit. If any value
1500      *                previously set in the time field is invalid or restricted by
1501      *                leniency, this will be set to an error status.
1502      * @stable ICU 2.0
1503      */
1504     virtual void computeFields(UErrorCode&amp; status);
1505 
1506     /**
1507      * Gets this Calendar&#39;s current time as a long.
1508      *
1509      * @param status  Output param set to success/failure code on exit. If any value
1510      *                previously set in the time field is invalid or restricted by
1511      *                leniency, this will be set to an error status.
1512      * @return the current time as UTC milliseconds from the epoch.
1513      * @stable ICU 2.0
1514      */
1515     double getTimeInMillis(UErrorCode&amp; status) const;
1516 
1517     /**
1518      * Sets this Calendar&#39;s current time from the given long value.
1519      * @param millis  the new time in UTC milliseconds from the epoch.
1520      * @param status  Output param set to success/failure code on exit. If any value
1521      *                previously set in the time field is invalid or restricted by
1522      *                leniency, this will be set to an error status.
1523      * @stable ICU 2.0
1524      */
1525     void setTimeInMillis( double millis, UErrorCode&amp; status );
1526 
1527     /**
1528      * Recomputes the current time from currently set fields, and then fills in any
1529      * unset fields in the time field list.
1530      *
1531      * @param status  Output param set to success/failure code on exit. If any value
1532      *                previously set in the time field is invalid or restricted by
1533      *                leniency, this will be set to an error status.
1534      * @stable ICU 2.0
1535      */
1536     void complete(UErrorCode&amp; status);
1537 
1538 #ifndef U_HIDE_DEPRECATED_API
1539     /**
1540      * Gets the value for a given time field. Subclasses can use this function to get
1541      * field values without forcing recomputation of time.
1542      *
1543      * @param field  The given time field.
1544      * @return       The value for the given time field.
1545      * @deprecated ICU 2.6. Use internalGet(UCalendarDateFields field) instead.
1546      */
1547     inline int32_t internalGet(EDateFields field) const {return fFields[field];}
1548 #endif  /* U_HIDE_DEPRECATED_API */
1549 
1550 #ifndef U_HIDE_INTERNAL_API
1551     /**
1552      * Gets the value for a given time field. Subclasses can use this function to get
1553      * field values without forcing recomputation of time. If the field&#39;s stamp is UNSET,
1554      * the defaultValue is used.
1555      *
1556      * @param field  The given time field.
1557      * @param defaultValue a default value used if the field is unset.
1558      * @return       The value for the given time field.
1559      * @internal
1560      */
1561     inline int32_t internalGet(UCalendarDateFields field, int32_t defaultValue) const {return fStamp[field]&gt;kUnset ? fFields[field] : defaultValue;}
1562 
1563     /**
1564      * Gets the value for a given time field. Subclasses can use this function to get
1565      * field values without forcing recomputation of time.
1566      *
1567      * @param field  The given time field.
1568      * @return       The value for the given time field.
1569      * @internal
1570      */
1571     inline int32_t internalGet(UCalendarDateFields field) const {return fFields[field];}
1572 #endif  /* U_HIDE_INTERNAL_API */
1573 
1574 #ifndef U_HIDE_DEPRECATED_API
1575     /**
1576      * Sets the value for a given time field.  This is a fast internal method for
1577      * subclasses.  It does not affect the areFieldsInSync, isTimeSet, or areAllFieldsSet
1578      * flags.
1579      *
1580      * @param field    The given time field.
1581      * @param value    The value for the given time field.
1582      * @deprecated ICU 2.6. Use internalSet(UCalendarDateFields field, int32_t value) instead.
1583      */
1584     void internalSet(EDateFields field, int32_t value);
1585 #endif  /* U_HIDE_DEPRECATED_API */
1586 
1587     /**
1588      * Sets the value for a given time field.  This is a fast internal method for
1589      * subclasses.  It does not affect the areFieldsInSync, isTimeSet, or areAllFieldsSet
1590      * flags.
1591      *
1592      * @param field    The given time field.
1593      * @param value    The value for the given time field.
1594      * @stable ICU 2.6.
1595      */
1596     inline void internalSet(UCalendarDateFields field, int32_t value);
1597 
1598     /**
1599      * Prepare this calendar for computing the actual minimum or maximum.
1600      * This method modifies this calendar&#39;s fields; it is called on a
1601      * temporary calendar.
1602      * @internal
1603      */
1604     virtual void prepareGetActual(UCalendarDateFields field, UBool isMinimum, UErrorCode &amp;status);
1605 
1606     /**
1607      * Limit enums. Not in sync with UCalendarLimitType (refers to internal fields).
1608      * @internal
1609      */
1610     enum ELimitType {
1611 #ifndef U_HIDE_INTERNAL_API
1612       UCAL_LIMIT_MINIMUM = 0,
1613       UCAL_LIMIT_GREATEST_MINIMUM,
1614       UCAL_LIMIT_LEAST_MAXIMUM,
1615       UCAL_LIMIT_MAXIMUM,
1616       UCAL_LIMIT_COUNT
1617 #endif  /* U_HIDE_INTERNAL_API */
1618     };
1619 
1620     /**
1621      * Subclass API for defining limits of different types.
1622      * Subclasses must implement this method to return limits for the
1623      * following fields:
1624      *
1625      * &lt;pre&gt;UCAL_ERA
1626      * UCAL_YEAR
1627      * UCAL_MONTH
1628      * UCAL_WEEK_OF_YEAR
1629      * UCAL_WEEK_OF_MONTH
1630      * UCAL_DATE (DAY_OF_MONTH on Java)
1631      * UCAL_DAY_OF_YEAR
1632      * UCAL_DAY_OF_WEEK_IN_MONTH
1633      * UCAL_YEAR_WOY
1634      * UCAL_EXTENDED_YEAR&lt;/pre&gt;
1635      *
1636      * @param field one of the above field numbers
1637      * @param limitType one of &lt;code&gt;MINIMUM&lt;/code&gt;, &lt;code&gt;GREATEST_MINIMUM&lt;/code&gt;,
1638      * &lt;code&gt;LEAST_MAXIMUM&lt;/code&gt;, or &lt;code&gt;MAXIMUM&lt;/code&gt;
1639      * @internal
1640      */
1641     virtual int32_t handleGetLimit(UCalendarDateFields field, ELimitType limitType) const = 0;
1642 
1643     /**
1644      * Return a limit for a field.
1645      * @param field the field, from &lt;code&gt;0..UCAL_MAX_FIELD&lt;/code&gt;
1646      * @param limitType the type specifier for the limit
1647      * @see #ELimitType
1648      * @internal
1649      */
1650     virtual int32_t getLimit(UCalendarDateFields field, ELimitType limitType) const;
1651 
1652 
1653     /**
1654      * Return the Julian day number of day before the first day of the
1655      * given month in the given extended year.  Subclasses should override
1656      * this method to implement their calendar system.
1657      * @param eyear the extended year
1658      * @param month the zero-based month, or 0 if useMonth is false
1659      * @param useMonth if false, compute the day before the first day of
1660      * the given year, otherwise, compute the day before the first day of
1661      * the given month
1662      * @return the Julian day number of the day before the first
1663      * day of the given month and year
1664      * @internal
1665      */
1666     virtual int32_t handleComputeMonthStart(int32_t eyear, int32_t month,
1667                                                    UBool useMonth) const  = 0;
1668 
1669     /**
1670      * Return the number of days in the given month of the given extended
1671      * year of this calendar system.  Subclasses should override this
1672      * method if they can provide a more correct or more efficient
1673      * implementation than the default implementation in Calendar.
1674      * @internal
1675      */
1676     virtual int32_t handleGetMonthLength(int32_t extendedYear, int32_t month) const ;
1677 
1678     /**
1679      * Return the number of days in the given extended year of this
1680      * calendar system.  Subclasses should override this method if they can
1681      * provide a more correct or more efficient implementation than the
1682      * default implementation in Calendar.
1683      * @stable ICU 2.0
1684      */
1685     virtual int32_t handleGetYearLength(int32_t eyear) const;
1686 
1687 
1688     /**
1689      * Return the extended year defined by the current fields.  This will
1690      * use the UCAL_EXTENDED_YEAR field or the UCAL_YEAR and supra-year fields (such
1691      * as UCAL_ERA) specific to the calendar system, depending on which set of
1692      * fields is newer.
1693      * @return the extended year
1694      * @internal
1695      */
1696     virtual int32_t handleGetExtendedYear() = 0;
1697 
1698     /**
1699      * Subclasses may override this.  This method calls
1700      * handleGetMonthLength() to obtain the calendar-specific month
1701      * length.
1702      * @param bestField which field to use to calculate the date
1703      * @return julian day specified by calendar fields.
1704      * @internal
1705      */
1706     virtual int32_t handleComputeJulianDay(UCalendarDateFields bestField);
1707 
1708     /**
1709      * Subclasses must override this to convert from week fields
1710      * (YEAR_WOY and WEEK_OF_YEAR) to an extended year in the case
1711      * where YEAR, EXTENDED_YEAR are not set.
1712      * The Calendar implementation assumes yearWoy is in extended gregorian form
1713      * @return the extended year, UCAL_EXTENDED_YEAR
1714      * @internal
1715      */
1716     virtual int32_t handleGetExtendedYearFromWeekFields(int32_t yearWoy, int32_t woy);
1717 
1718     /**
1719      * Validate a single field of this calendar.  Subclasses should
1720      * override this method to validate any calendar-specific fields.
<a name="33" id="anc33"></a><span class="line-modified">1721      * Generic fields can be handled by</span>
<span class="line-removed">1722      * &lt;code&gt;Calendar::validateField()&lt;/code&gt;.</span>
<span class="line-removed">1723      * @see #validateField(int, int, int, int&amp;)</span>
1724      * @internal
1725      */
1726     virtual void validateField(UCalendarDateFields field, UErrorCode &amp;status);
1727 
1728 #ifndef U_HIDE_INTERNAL_API
1729     /**
1730      * Compute the Julian day from fields.  Will determine whether to use
1731      * the JULIAN_DAY field directly, or other fields.
1732      * @return the julian day
1733      * @internal
1734      */
1735     int32_t computeJulianDay();
1736 
1737     /**
1738      * Compute the milliseconds in the day from the fields.  This is a
1739      * value from 0 to 23:59:59.999 inclusive, unless fields are out of
1740      * range, in which case it can be an arbitrary value.  This value
1741      * reflects local zone wall time.
1742      * @internal
1743      */
1744     double computeMillisInDay();
1745 
1746     /**
1747      * This method can assume EXTENDED_YEAR has been set.
1748      * @param millis milliseconds of the date fields
1749      * @param millisInDay milliseconds of the time fields; may be out
1750      * or range.
1751      * @param ec Output param set to failure code on function return
1752      *          when this function fails.
1753      * @internal
1754      */
1755     int32_t computeZoneOffset(double millis, double millisInDay, UErrorCode &amp;ec);
1756 
1757 
1758     /**
1759      * Determine the best stamp in a range.
1760      * @param start first enum to look at
1761      * @param end last enum to look at
1762      * @param bestSoFar stamp prior to function call
1763      * @return the stamp value of the best stamp
1764      * @internal
1765      */
1766     int32_t newestStamp(UCalendarDateFields start, UCalendarDateFields end, int32_t bestSoFar) const;
1767 
1768     /**
1769      * Values for field resolution tables
1770      * @see #resolveFields
1771      * @internal
1772      */
1773     enum {
1774       /** Marker for end of resolve set (row or group). */
1775       kResolveSTOP = -1,
1776       /** Value to be bitwised &quot;ORed&quot; against resolve table field values for remapping.  Example: (UCAL_DATE | kResolveRemap) in 1st column will cause &#39;UCAL_DATE&#39; to be returned, but will not examine the value of UCAL_DATE.  */
1777       kResolveRemap = 32
1778     };
1779 
1780     /**
1781      * Precedence table for Dates
1782      * @see #resolveFields
1783      * @internal
1784      */
1785     static const UFieldResolutionTable kDatePrecedence[];
1786 
1787     /**
1788      * Precedence table for Year
1789      * @see #resolveFields
1790      * @internal
1791      */
1792     static const UFieldResolutionTable kYearPrecedence[];
1793 
1794     /**
1795      * Precedence table for Day of Week
1796      * @see #resolveFields
1797      * @internal
1798      */
1799     static const UFieldResolutionTable kDOWPrecedence[];
1800 
1801     /**
1802      * Given a precedence table, return the newest field combination in
1803      * the table, or UCAL_FIELD_COUNT if none is found.
1804      *
1805      * &lt;p&gt;The precedence table is a 3-dimensional array of integers.  It
1806      * may be thought of as an array of groups.  Each group is an array of
1807      * lines.  Each line is an array of field numbers.  Within a line, if
1808      * all fields are set, then the time stamp of the line is taken to be
1809      * the stamp of the most recently set field.  If any field of a line is
1810      * unset, then the line fails to match.  Within a group, the line with
1811      * the newest time stamp is selected.  The first field of the line is
1812      * returned to indicate which line matched.
1813      *
1814      * &lt;p&gt;In some cases, it may be desirable to map a line to field that
1815      * whose stamp is NOT examined.  For example, if the best field is
1816      * DAY_OF_WEEK then the DAY_OF_WEEK_IN_MONTH algorithm may be used.  In
1817      * order to do this, insert the value &lt;code&gt;kResolveRemap | F&lt;/code&gt; at
1818      * the start of the line, where &lt;code&gt;F&lt;/code&gt; is the desired return
1819      * field value.  This field will NOT be examined; it only determines
1820      * the return value if the other fields in the line are the newest.
1821      *
1822      * &lt;p&gt;If all lines of a group contain at least one unset field, then no
1823      * line will match, and the group as a whole will fail to match.  In
1824      * that case, the next group will be processed.  If all groups fail to
1825      * match, then UCAL_FIELD_COUNT is returned.
1826      * @internal
1827      */
1828     UCalendarDateFields resolveFields(const UFieldResolutionTable *precedenceTable);
1829 #endif  /* U_HIDE_INTERNAL_API */
1830 
1831 
1832     /**
1833      * @internal
1834      */
1835     virtual const UFieldResolutionTable* getFieldResolutionTable() const;
1836 
1837 #ifndef U_HIDE_INTERNAL_API
1838     /**
1839      * Return the field that is newer, either defaultField, or
1840      * alternateField.  If neither is newer or neither is set, return defaultField.
1841      * @internal
1842      */
1843     UCalendarDateFields newerField(UCalendarDateFields defaultField, UCalendarDateFields alternateField) const;
1844 #endif  /* U_HIDE_INTERNAL_API */
1845 
1846 
1847 private:
1848     /**
1849      * Helper function for calculating limits by trial and error
1850      * @param field The field being investigated
1851      * @param startValue starting (least max) value of field
1852      * @param endValue ending (greatest max) value of field
1853      * @param status return type
1854      * @internal
1855      */
1856     int32_t getActualHelper(UCalendarDateFields field, int32_t startValue, int32_t endValue, UErrorCode &amp;status) const;
1857 
1858 
1859 protected:
1860     /**
1861      * The flag which indicates if the current time is set in the calendar.
1862      * @stable ICU 2.0
1863      */
1864     UBool      fIsTimeSet;
1865 
1866     /**
1867      * True if the fields are in sync with the currently set time of this Calendar.
1868      * If false, then the next attempt to get the value of a field will
1869      * force a recomputation of all fields from the current value of the time
1870      * field.
1871      * &lt;P&gt;
1872      * This should really be named areFieldsInSync, but the old name is retained
1873      * for backward compatibility.
1874      * @stable ICU 2.0
1875      */
1876     UBool      fAreFieldsSet;
1877 
1878     /**
1879      * True if all of the fields have been set.  This is initially false, and set to
1880      * true by computeFields().
1881      * @stable ICU 2.0
1882      */
1883     UBool      fAreAllFieldsSet;
1884 
1885     /**
1886      * True if all fields have been virtually set, but have not yet been
1887      * computed.  This occurs only in setTimeInMillis().  A calendar set
1888      * to this state will compute all fields from the time if it becomes
1889      * necessary, but otherwise will delay such computation.
1890      * @stable ICU 3.0
1891      */
1892     UBool fAreFieldsVirtuallySet;
1893 
1894     /**
1895      * Get the current time without recomputing.
1896      *
1897      * @return     the current time without recomputing.
1898      * @stable ICU 2.0
1899      */
1900     UDate        internalGetTime(void) const     { return fTime; }
1901 
1902     /**
1903      * Set the current time without affecting flags or fields.
1904      *
1905      * @param time    The time to be set
1906      * @return        the current time without recomputing.
1907      * @stable ICU 2.0
1908      */
1909     void        internalSetTime(UDate time)     { fTime = time; }
1910 
1911     /**
1912      * The time fields containing values into which the millis is computed.
1913      * @stable ICU 2.0
1914      */
1915     int32_t     fFields[UCAL_FIELD_COUNT];
1916 
1917     /**
1918      * The flags which tell if a specified time field for the calendar is set.
1919      * @deprecated ICU 2.8 use (fStamp[n]!=kUnset)
1920      */
1921     UBool      fIsSet[UCAL_FIELD_COUNT];
1922 
1923     /** Special values of stamp[]
1924      * @stable ICU 2.0
1925      */
1926     enum {
1927         kUnset                 = 0,
1928         kInternallySet,
1929         kMinimumUserStamp
1930     };
1931 
1932     /**
1933      * Pseudo-time-stamps which specify when each field was set. There
1934      * are two special values, UNSET and INTERNALLY_SET. Values from
1935      * MINIMUM_USER_SET to Integer.MAX_VALUE are legal user set values.
1936      * @stable ICU 2.0
1937      */
1938     int32_t        fStamp[UCAL_FIELD_COUNT];
1939 
1940     /**
1941      * Subclasses may override this method to compute several fields
1942      * specific to each calendar system.  These are:
1943      *
1944      * &lt;ul&gt;&lt;li&gt;ERA
1945      * &lt;li&gt;YEAR
1946      * &lt;li&gt;MONTH
1947      * &lt;li&gt;DAY_OF_MONTH
1948      * &lt;li&gt;DAY_OF_YEAR
1949      * &lt;li&gt;EXTENDED_YEAR&lt;/ul&gt;
1950      *
1951      * Subclasses can refer to the DAY_OF_WEEK and DOW_LOCAL fields, which
1952      * will be set when this method is called.  Subclasses can also call
1953      * the getGregorianXxx() methods to obtain Gregorian calendar
1954      * equivalents for the given Julian day.
1955      *
1956      * &lt;p&gt;In addition, subclasses should compute any subclass-specific
1957      * fields, that is, fields from BASE_FIELD_COUNT to
1958      * getFieldCount() - 1.
1959      *
1960      * &lt;p&gt;The default implementation in &lt;code&gt;Calendar&lt;/code&gt; implements
1961      * a pure proleptic Gregorian calendar.
1962      * @internal
1963      */
1964     virtual void handleComputeFields(int32_t julianDay, UErrorCode &amp;status);
1965 
1966 #ifndef U_HIDE_INTERNAL_API
1967     /**
1968      * Return the extended year on the Gregorian calendar as computed by
1969      * &lt;code&gt;computeGregorianFields()&lt;/code&gt;.
1970      * @internal
1971      */
1972     int32_t getGregorianYear() const {
1973         return fGregorianYear;
1974     }
1975 
1976     /**
1977      * Return the month (0-based) on the Gregorian calendar as computed by
1978      * &lt;code&gt;computeGregorianFields()&lt;/code&gt;.
1979      * @internal
1980      */
1981     int32_t getGregorianMonth() const {
1982         return fGregorianMonth;
1983     }
1984 
1985     /**
1986      * Return the day of year (1-based) on the Gregorian calendar as
1987      * computed by &lt;code&gt;computeGregorianFields()&lt;/code&gt;.
1988      * @internal
1989      */
1990     int32_t getGregorianDayOfYear() const {
1991         return fGregorianDayOfYear;
1992     }
1993 
1994     /**
1995      * Return the day of month (1-based) on the Gregorian calendar as
1996      * computed by &lt;code&gt;computeGregorianFields()&lt;/code&gt;.
1997      * @internal
1998      */
1999     int32_t getGregorianDayOfMonth() const {
2000       return fGregorianDayOfMonth;
2001     }
2002 #endif  /* U_HIDE_INTERNAL_API */
2003 
2004     /**
2005      * Called by computeJulianDay.  Returns the default month (0-based) for the year,
2006      * taking year and era into account.  Defaults to 0 for Gregorian, which doesn&#39;t care.
2007      * @param eyear The extended year
2008      * @internal
2009      */
2010     virtual int32_t getDefaultMonthInYear(int32_t eyear) ;
2011 
2012 
2013     /**
2014      * Called by computeJulianDay.  Returns the default day (1-based) for the month,
2015      * taking currently-set year and era into account.  Defaults to 1 for Gregorian.
2016      * @param eyear the extended year
2017      * @param month the month in the year
2018      * @internal
2019      */
2020     virtual int32_t getDefaultDayInMonth(int32_t eyear, int32_t month);
2021 
2022     //-------------------------------------------------------------------------
2023     // Protected utility methods for use by subclasses.  These are very handy
2024     // for implementing add, roll, and computeFields.
2025     //-------------------------------------------------------------------------
2026 
2027     /**
2028      * Adjust the specified field so that it is within
2029      * the allowable range for the date to which this calendar is set.
2030      * For example, in a Gregorian calendar pinning the {@link #UCalendarDateFields DAY_OF_MONTH}
2031      * field for a calendar set to April 31 would cause it to be set
2032      * to April 30.
2033      * &lt;p&gt;
2034      * &lt;b&gt;Subclassing:&lt;/b&gt;
2035      * &lt;br&gt;
2036      * This utility method is intended for use by subclasses that need to implement
2037      * their own overrides of {@link #roll roll} and {@link #add add}.
2038      * &lt;p&gt;
2039      * &lt;b&gt;Note:&lt;/b&gt;
2040      * &lt;code&gt;pinField&lt;/code&gt; is implemented in terms of
2041      * {@link #getActualMinimum getActualMinimum}
2042      * and {@link #getActualMaximum getActualMaximum}.  If either of those methods uses
2043      * a slow, iterative algorithm for a particular field, it would be
2044      * unwise to attempt to call &lt;code&gt;pinField&lt;/code&gt; for that field.  If you
2045      * really do need to do so, you should override this method to do
2046      * something more efficient for that field.
2047      * &lt;p&gt;
2048      * @param field The calendar field whose value should be pinned.
2049      * @param status Output param set to failure code on function return
2050      *          when this function fails.
2051      *
2052      * @see #getActualMinimum
2053      * @see #getActualMaximum
2054      * @stable ICU 2.0
2055      */
2056     virtual void pinField(UCalendarDateFields field, UErrorCode&amp; status);
2057 
2058     /**
2059      * Return the week number of a day, within a period. This may be the week number in
2060      * a year or the week number in a month. Usually this will be a value &gt;= 1, but if
2061      * some initial days of the period are excluded from week 1, because
2062      * {@link #getMinimalDaysInFirstWeek getMinimalDaysInFirstWeek} is &gt; 1, then
2063      * the week number will be zero for those
2064      * initial days. This method requires the day number and day of week for some
2065      * known date in the period in order to determine the day of week
2066      * on the desired day.
2067      * &lt;p&gt;
2068      * &lt;b&gt;Subclassing:&lt;/b&gt;
2069      * &lt;br&gt;
2070      * This method is intended for use by subclasses in implementing their
2071      * {@link #computeTime computeTime} and/or {@link #computeFields computeFields} methods.
2072      * It is often useful in {@link #getActualMinimum getActualMinimum} and
2073      * {@link #getActualMaximum getActualMaximum} as well.
2074      * &lt;p&gt;
2075      * This variant is handy for computing the week number of some other
2076      * day of a period (often the first or last day of the period) when its day
2077      * of the week is not known but the day number and day of week for some other
2078      * day in the period (e.g. the current date) &lt;em&gt;is&lt;/em&gt; known.
2079      * &lt;p&gt;
2080      * @param desiredDay    The {@link #UCalendarDateFields DAY_OF_YEAR} or
2081      *              {@link #UCalendarDateFields DAY_OF_MONTH} whose week number is desired.
2082      *              Should be 1 for the first day of the period.
2083      *
2084      * @param dayOfPeriod   The {@link #UCalendarDateFields DAY_OF_YEAR}
2085      *              or {@link #UCalendarDateFields DAY_OF_MONTH} for a day in the period whose
2086      *              {@link #UCalendarDateFields DAY_OF_WEEK} is specified by the
2087      *              &lt;code&gt;knownDayOfWeek&lt;/code&gt; parameter.
2088      *              Should be 1 for first day of period.
2089      *
2090      * @param dayOfWeek  The {@link #UCalendarDateFields DAY_OF_WEEK} for the day
2091      *              corresponding to the &lt;code&gt;knownDayOfPeriod&lt;/code&gt; parameter.
2092      *              1-based with 1=Sunday.
2093      *
2094      * @return      The week number (one-based), or zero if the day falls before
2095      *              the first week because
2096      *              {@link #getMinimalDaysInFirstWeek getMinimalDaysInFirstWeek}
2097      *              is more than one.
2098      *
2099      * @stable ICU 2.8
2100      */
2101     int32_t weekNumber(int32_t desiredDay, int32_t dayOfPeriod, int32_t dayOfWeek);
2102 
2103 
2104 #ifndef U_HIDE_INTERNAL_API
2105     /**
2106      * Return the week number of a day, within a period. This may be the week number in
2107      * a year, or the week number in a month. Usually this will be a value &gt;= 1, but if
2108      * some initial days of the period are excluded from week 1, because
2109      * {@link #getMinimalDaysInFirstWeek getMinimalDaysInFirstWeek} is &gt; 1,
2110      * then the week number will be zero for those
2111      * initial days. This method requires the day of week for the given date in order to
2112      * determine the result.
2113      * &lt;p&gt;
2114      * &lt;b&gt;Subclassing:&lt;/b&gt;
2115      * &lt;br&gt;
2116      * This method is intended for use by subclasses in implementing their
2117      * {@link #computeTime computeTime} and/or {@link #computeFields computeFields} methods.
2118      * It is often useful in {@link #getActualMinimum getActualMinimum} and
2119      * {@link #getActualMaximum getActualMaximum} as well.
2120      * &lt;p&gt;
2121      * @param dayOfPeriod   The {@link #UCalendarDateFields DAY_OF_YEAR} or
2122      *                      {@link #UCalendarDateFields DAY_OF_MONTH} whose week number is desired.
2123      *                      Should be 1 for the first day of the period.
2124      *
2125      * @param dayOfWeek     The {@link #UCalendarDateFields DAY_OF_WEEK} for the day
2126      *                      corresponding to the &lt;code&gt;dayOfPeriod&lt;/code&gt; parameter.
2127      *                      1-based with 1=Sunday.
2128      *
2129      * @return      The week number (one-based), or zero if the day falls before
2130      *              the first week because
2131      *              {@link #getMinimalDaysInFirstWeek getMinimalDaysInFirstWeek}
2132      *              is more than one.
2133      * @internal
2134      */
2135     inline int32_t weekNumber(int32_t dayOfPeriod, int32_t dayOfWeek);
2136 
2137     /**
2138      * returns the local DOW, valid range 0..6
2139      * @internal
2140      */
2141     int32_t getLocalDOW();
2142 #endif  /* U_HIDE_INTERNAL_API */
2143 
2144 private:
2145 
2146     /**
2147      * The next available value for fStamp[]
2148      */
2149     int32_t fNextStamp;// = MINIMUM_USER_STAMP;
2150 
2151     /**
2152      * Recalculates the time stamp array (fStamp).
2153      * Resets fNextStamp to lowest next stamp value.
2154      */
2155     void recalculateStamp();
2156 
2157     /**
2158      * The current time set for the calendar.
2159      */
2160     UDate        fTime;
2161 
2162     /**
2163      * @see   #setLenient
2164      */
2165     UBool      fLenient;
2166 
2167     /**
2168      * Time zone affects the time calculation done by Calendar. Calendar subclasses use
2169      * the time zone data to produce the local time. Always set; never NULL.
2170      */
2171     TimeZone*   fZone;
2172 
2173     /**
<a name="34" id="anc34"></a><span class="line-modified">2174      * Option for rpeated wall time</span>
2175      * @see #setRepeatedWallTimeOption
2176      */
2177     UCalendarWallTimeOption fRepeatedWallTime;
2178 
2179     /**
2180      * Option for skipped wall time
2181      * @see #setSkippedWallTimeOption
2182      */
2183     UCalendarWallTimeOption fSkippedWallTime;
2184 
2185     /**
2186      * Both firstDayOfWeek and minimalDaysInFirstWeek are locale-dependent. They are
2187      * used to figure out the week count for a specific date for a given locale. These
2188      * must be set when a Calendar is constructed. For example, in US locale,
2189      * firstDayOfWeek is SUNDAY; minimalDaysInFirstWeek is 1. They are used to figure
2190      * out the week count for a specific date for a given locale. These must be set when
2191      * a Calendar is constructed.
2192      */
2193     UCalendarDaysOfWeek fFirstDayOfWeek;
2194     uint8_t     fMinimalDaysInFirstWeek;
2195     UCalendarDaysOfWeek fWeekendOnset;
2196     int32_t fWeekendOnsetMillis;
2197     UCalendarDaysOfWeek fWeekendCease;
2198     int32_t fWeekendCeaseMillis;
2199 
2200     /**
2201      * Sets firstDayOfWeek and minimalDaysInFirstWeek. Called at Calendar construction
2202      * time.
2203      *
2204      * @param desiredLocale  The given locale.
2205      * @param type           The calendar type identifier, e.g: gregorian, buddhist, etc.
2206      * @param success        Indicates the status of setting the week count data from
2207      *                       the resource for the given locale. Returns U_ZERO_ERROR if
2208      *                       constructed successfully.
2209      */
2210     void        setWeekData(const Locale&amp; desiredLocale, const char *type, UErrorCode&amp; success);
2211 
2212     /**
2213      * Recompute the time and update the status fields isTimeSet
2214      * and areFieldsSet.  Callers should check isTimeSet and only
2215      * call this method if isTimeSet is false.
2216      *
2217      * @param status  Output param set to success/failure code on exit. If any value
2218      *                previously set in the time field is invalid or restricted by
2219      *                leniency, this will be set to an error status.
2220      */
2221     void updateTime(UErrorCode&amp; status);
2222 
2223     /**
2224      * The Gregorian year, as computed by computeGregorianFields() and
2225      * returned by getGregorianYear().
2226      * @see #computeGregorianFields
2227      */
2228     int32_t fGregorianYear;
2229 
2230     /**
2231      * The Gregorian month, as computed by computeGregorianFields() and
2232      * returned by getGregorianMonth().
2233      * @see #computeGregorianFields
2234      */
2235     int32_t fGregorianMonth;
2236 
2237     /**
2238      * The Gregorian day of the year, as computed by
2239      * computeGregorianFields() and returned by getGregorianDayOfYear().
2240      * @see #computeGregorianFields
2241      */
2242     int32_t fGregorianDayOfYear;
2243 
2244     /**
2245      * The Gregorian day of the month, as computed by
2246      * computeGregorianFields() and returned by getGregorianDayOfMonth().
2247      * @see #computeGregorianFields
2248      */
2249     int32_t fGregorianDayOfMonth;
2250 
2251     /* calculations */
2252 
2253     /**
2254      * Compute the Gregorian calendar year, month, and day of month from
2255      * the given Julian day.  These values are not stored in fields, but in
2256      * member variables gregorianXxx.  Also compute the DAY_OF_WEEK and
2257      * DOW_LOCAL fields.
2258      */
2259     void computeGregorianAndDOWFields(int32_t julianDay, UErrorCode &amp;ec);
2260 
2261 protected:
2262 
2263     /**
2264      * Compute the Gregorian calendar year, month, and day of month from the
2265      * Julian day.  These values are not stored in fields, but in member
2266      * variables gregorianXxx.  They are used for time zone computations and by
2267      * subclasses that are Gregorian derivatives.  Subclasses may call this
2268      * method to perform a Gregorian calendar millis-&gt;fields computation.
2269      */
2270     void computeGregorianFields(int32_t julianDay, UErrorCode &amp;ec);
2271 
2272 private:
2273 
2274     /**
2275      * Compute the fields WEEK_OF_YEAR, YEAR_WOY, WEEK_OF_MONTH,
2276      * DAY_OF_WEEK_IN_MONTH, and DOW_LOCAL from EXTENDED_YEAR, YEAR,
2277      * DAY_OF_WEEK, and DAY_OF_YEAR.  The latter fields are computed by the
2278      * subclass based on the calendar system.
2279      *
2280      * &lt;p&gt;The YEAR_WOY field is computed simplistically.  It is equal to YEAR
2281      * most of the time, but at the year boundary it may be adjusted to YEAR-1
2282      * or YEAR+1 to reflect the overlap of a week into an adjacent year.  In
2283      * this case, a simple increment or decrement is performed on YEAR, even
2284      * though this may yield an invalid YEAR value.  For instance, if the YEAR
2285      * is part of a calendar system with an N-year cycle field CYCLE, then
2286      * incrementing the YEAR may involve incrementing CYCLE and setting YEAR
2287      * back to 0 or 1.  This is not handled by this code, and in fact cannot be
2288      * simply handled without having subclasses define an entire parallel set of
2289      * fields for fields larger than or equal to a year.  This additional
2290      * complexity is not warranted, since the intention of the YEAR_WOY field is
2291      * to support ISO 8601 notation, so it will typically be used with a
2292      * proleptic Gregorian calendar, which has no field larger than a year.
2293      */
2294     void computeWeekFields(UErrorCode &amp;ec);
2295 
2296 
2297     /**
2298      * Ensure that each field is within its valid range by calling {@link
2299      * #validateField(int, int&amp;)} on each field that has been set.  This method
2300      * should only be called if this calendar is not lenient.
2301      * @see #isLenient
2302      * @see #validateField(int, int&amp;)
2303      * @internal
2304      */
2305     void validateFields(UErrorCode &amp;status);
2306 
2307     /**
2308      * Validate a single field of this calendar given its minimum and
2309      * maximum allowed value.  If the field is out of range,
2310      * &lt;code&gt;U_ILLEGAL_ARGUMENT_ERROR&lt;/code&gt; will be set.  Subclasses may
2311      * use this method in their implementation of {@link
2312      * #validateField(int, int&amp;)}.
2313      * @internal
2314      */
2315     void validateField(UCalendarDateFields field, int32_t min, int32_t max, UErrorCode&amp; status);
2316 
2317  protected:
2318 #ifndef U_HIDE_INTERNAL_API
2319     /**
2320      * Convert a quasi Julian date to the day of the week. The Julian date used here is
2321      * not a true Julian date, since it is measured from midnight, not noon. Return
2322      * value is one-based.
2323      *
2324      * @param julian  The given Julian date number.
2325      * @return   Day number from 1..7 (SUN..SAT).
2326      * @internal
2327      */
2328     static uint8_t julianDayToDayOfWeek(double julian);
2329 #endif  /* U_HIDE_INTERNAL_API */
2330 
2331  private:
2332     char validLocale[ULOC_FULLNAME_CAPACITY];
2333     char actualLocale[ULOC_FULLNAME_CAPACITY];
2334 
2335  public:
2336 #if !UCONFIG_NO_SERVICE
2337     /**
2338      * INTERNAL FOR 2.6 --  Registration.
2339      */
2340 
2341 #ifndef U_HIDE_INTERNAL_API
2342     /**
2343      * Return a StringEnumeration over the locales available at the time of the call,
2344      * including registered locales.
2345      * @return a StringEnumeration over the locales available at the time of the call
2346      * @internal
2347      */
2348     static StringEnumeration* getAvailableLocales(void);
2349 
2350     /**
2351      * Register a new Calendar factory.  The factory will be adopted.
2352      * INTERNAL in 2.6
2353      *
2354      * Because ICU may choose to cache Calendars internally, this must
2355      * be called at application startup, prior to any calls to
2356      * Calendar::createInstance to avoid undefined behavior.
2357      *
2358      * @param toAdopt the factory instance to be adopted
2359      * @param status the in/out status code, no special meanings are assigned
2360      * @return a registry key that can be used to unregister this factory
2361      * @internal
2362      */
2363     static URegistryKey registerFactory(ICUServiceFactory* toAdopt, UErrorCode&amp; status);
2364 
2365     /**
2366      * Unregister a previously-registered CalendarFactory using the key returned from the
2367      * register call.  Key becomes invalid after a successful call and should not be used again.
2368      * The CalendarFactory corresponding to the key will be deleted.
2369      * INTERNAL in 2.6
2370      *
2371      * Because ICU may choose to cache Calendars internally, this should
2372      * be called during application shutdown, after all calls to
2373      * Calendar::createInstance to avoid undefined behavior.
2374      *
2375      * @param key the registry key returned by a previous call to registerFactory
2376      * @param status the in/out status code, no special meanings are assigned
2377      * @return TRUE if the factory for the key was successfully unregistered
2378      * @internal
2379      */
2380     static UBool unregister(URegistryKey key, UErrorCode&amp; status);
2381 #endif  /* U_HIDE_INTERNAL_API */
2382 
2383     /**
2384      * Multiple Calendar Implementation
2385      * @internal
2386      */
2387     friend class CalendarFactory;
2388 
2389     /**
2390      * Multiple Calendar Implementation
2391      * @internal
2392      */
2393     friend class CalendarService;
2394 
2395     /**
2396      * Multiple Calendar Implementation
2397      * @internal
2398      */
2399     friend class DefaultCalendarFactory;
2400 #endif /* !UCONFIG_NO_SERVICE */
2401 
2402     /**
2403      * @return TRUE if this calendar has a default century (i.e. 03 -&gt; 2003)
2404      * @internal
2405      */
2406     virtual UBool haveDefaultCentury() const = 0;
2407 
2408     /**
2409      * @return the start of the default century, as a UDate
2410      * @internal
2411      */
2412     virtual UDate defaultCenturyStart() const = 0;
2413     /**
2414      * @return the beginning year of the default century, as a year
2415      * @internal
2416      */
2417     virtual int32_t defaultCenturyStartYear() const = 0;
2418 
2419     /** Get the locale for this calendar object. You can choose between valid and actual locale.
2420      *  @param type type of the locale we&#39;re looking for (valid or actual)
2421      *  @param status error code for the operation
2422      *  @return the locale
2423      *  @stable ICU 2.8
2424      */
2425     Locale getLocale(ULocDataLocaleType type, UErrorCode &amp;status) const;
2426 
2427     /**
2428      * @return      The related Gregorian year; will be obtained by modifying the value
2429      *              obtained by get from UCAL_EXTENDED_YEAR field
2430      * @internal
2431      */
2432     virtual int32_t getRelatedYear(UErrorCode &amp;status) const;
2433 
2434     /**
2435      * @param year  The related Gregorian year to set; will be modified as necessary then
2436      *              set in UCAL_EXTENDED_YEAR field
2437      * @internal
2438      */
2439     virtual void setRelatedYear(int32_t year);
2440 
2441 #ifndef U_HIDE_INTERNAL_API
2442     /** Get the locale for this calendar object. You can choose between valid and actual locale.
2443      *  @param type type of the locale we&#39;re looking for (valid or actual)
2444      *  @param status error code for the operation
2445      *  @return the locale
2446      *  @internal
2447      */
2448     const char* getLocaleID(ULocDataLocaleType type, UErrorCode &amp;status) const;
2449 #endif  /* U_HIDE_INTERNAL_API */
2450 
2451 private:
2452     /**
2453      * Cast TimeZone used by this object to BasicTimeZone, or NULL if the TimeZone
2454      * is not an instance of BasicTimeZone.
2455      */
2456     BasicTimeZone* getBasicTimeZone() const;
2457 
2458     /**
<a name="35" id="anc35"></a><span class="line-modified">2459      * Find the previous zone transtion near the given time.</span>
2460      * @param base The base time, inclusive
2461      * @param transitionTime Receives the result time
2462      * @param status The error status
2463      * @return TRUE if a transition is found.
2464      */
2465     UBool getImmediatePreviousZoneTransition(UDate base, UDate *transitionTime, UErrorCode&amp; status) const;
2466 
2467 public:
2468 #ifndef U_HIDE_INTERNAL_API
2469     /**
2470      * Creates a new Calendar from a Locale for the cache.
2471      * This method does not set the time or timezone in returned calendar.
2472      * @param locale the locale.
2473      * @param status any error returned here.
2474      * @return the new Calendar object with no time or timezone set.
2475      * @internal For ICU use only.
2476      */
2477     static Calendar * U_EXPORT2 makeInstance(
2478             const Locale &amp;locale, UErrorCode &amp;status);
2479 
2480     /**
2481      * Get the calendar type for given locale.
2482      * @param locale the locale
2483      * @param typeBuffer calendar type returned here
2484      * @param typeBufferSize The size of typeBuffer in bytes. If the type
2485      *   can&#39;t fit in the buffer, this method sets status to
2486      *   U_BUFFER_OVERFLOW_ERROR
2487      * @param status error, if any, returned here.
2488      * @internal For ICU use only.
2489      */
2490     static void U_EXPORT2 getCalendarTypeFromLocale(
2491             const Locale &amp;locale,
2492             char *typeBuffer,
2493             int32_t typeBufferSize,
2494             UErrorCode &amp;status);
2495 #endif  /* U_HIDE_INTERNAL_API */
2496 };
2497 
2498 // -------------------------------------
2499 
2500 inline Calendar*
2501 Calendar::createInstance(TimeZone* zone, UErrorCode&amp; errorCode)
2502 {
2503     // since the Locale isn&#39;t specified, use the default locale
2504     return createInstance(zone, Locale::getDefault(), errorCode);
2505 }
2506 
2507 // -------------------------------------
2508 
2509 inline void
2510 Calendar::roll(UCalendarDateFields field, UBool up, UErrorCode&amp; status)
2511 {
2512     roll(field, (int32_t)(up ? +1 : -1), status);
2513 }
2514 
2515 #ifndef U_HIDE_DEPRECATED_API
2516 inline void
2517 Calendar::roll(EDateFields field, UBool up, UErrorCode&amp; status)
2518 {
2519     roll((UCalendarDateFields) field, up, status);
2520 }
2521 #endif  /* U_HIDE_DEPRECATED_API */
2522 
2523 
2524 // -------------------------------------
2525 
2526 /**
2527  * Fast method for subclasses.  The caller must maintain fUserSetDSTOffset and
2528  * fUserSetZoneOffset, as well as the isSet[] array.
2529  */
2530 
2531 inline void
2532 Calendar::internalSet(UCalendarDateFields field, int32_t value)
2533 {
2534     fFields[field] = value;
2535     fStamp[field] = kInternallySet;
2536     fIsSet[field]     = TRUE; // Remove later
2537 }
2538 
2539 
2540 #ifndef U_HIDE_INTERNAL_API
2541 inline int32_t  Calendar::weekNumber(int32_t dayOfPeriod, int32_t dayOfWeek)
2542 {
2543   return weekNumber(dayOfPeriod, dayOfPeriod, dayOfWeek);
2544 }
2545 #endif  /* U_HIDE_INTERNAL_API */
2546 
2547 U_NAMESPACE_END
2548 
2549 #endif /* #if !UCONFIG_NO_FORMATTING */
2550 
2551 #endif // _CALENDAR
<a name="36" id="anc36"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="36" type="hidden" />
</body>
</html>