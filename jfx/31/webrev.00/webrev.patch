diff a/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/VERSION b/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/VERSION
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/VERSION
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/VERSION
@@ -1,1 +1,1 @@
-3.28.0
+3.30.1
diff a/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/sqlite3.c b/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/sqlite3.c
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/sqlite3.c
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/sqlite3.c
@@ -1,8 +1,8 @@
 /******************************************************************************
 ** This file is an amalgamation of many separate C source files from SQLite
-** version 3.28.0.  By combining all the individual C code files into this
+** version 3.30.1.  By combining all the individual C code files into this
 ** single large file, the entire code can be compiled as a single translation
 ** unit.  This allows many compilers to do optimizations that would not be
 ** possible if the files were compiled separately.  Performance improvements
 ** of 5% or more are commonly seen when SQLite is compiled as a single
 ** translation unit.
@@ -37,11 +37,11 @@
 **
 ** This file implements routines used to report what compile-time options
 ** SQLite was built with.
 */
 
-#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
+#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS /* IMP: R-16824-07538 */
 
 /*
 ** Include the configuration header output by 'configure' if we're using the
 ** autoconf-based build
 */
@@ -329,12 +329,10 @@
 #if SQLITE_ENABLE_SQLLOG
   "ENABLE_SQLLOG",
 #endif
 #if defined(SQLITE_ENABLE_STAT4)
   "ENABLE_STAT4",
-#elif defined(SQLITE_ENABLE_STAT3)
-  "ENABLE_STAT3",
 #endif
 #if SQLITE_ENABLE_STMTVTAB
   "ENABLE_STMTVTAB",
 #endif
 #if SQLITE_ENABLE_STMT_SCANSTATUS
@@ -886,10 +884,15 @@
 #pragma warning(disable : 4306)
 #pragma warning(disable : 4702)
 #pragma warning(disable : 4706)
 #endif /* defined(_MSC_VER) */
 
+#if defined(_MSC_VER) && !defined(_WIN64)
+#undef SQLITE_4_BYTE_ALIGNED_MALLOC
+#define SQLITE_4_BYTE_ALIGNED_MALLOC
+#endif /* defined(_MSC_VER) && !defined(_WIN64) */
+
 #endif /* SQLITE_MSVC_H */
 
 /************** End of msvc.h ************************************************/
 /************** Continuing where we left off in sqliteInt.h ******************/
 
@@ -1160,13 +1163,13 @@
 **
 ** See also: [sqlite3_libversion()],
 ** [sqlite3_libversion_number()], [sqlite3_sourceid()],
 ** [sqlite_version()] and [sqlite_source_id()].
 */
-#define SQLITE_VERSION        "3.28.0"
-#define SQLITE_VERSION_NUMBER 3028000
-#define SQLITE_SOURCE_ID      "2019-04-16 19:49:53 884b4b7e502b4e991677b53971277adfaf0a04a284f8e483e2553d0f83156b50"
+#define SQLITE_VERSION        "3.30.1"
+#define SQLITE_VERSION_NUMBER 3030001
+#define SQLITE_SOURCE_ID      "2019-10-10 20:19:45 18db032d058f1436ce3dea84081f4ee5a0f2259ad97301d43c426bc7f3df1b0b"
 
 /*
 ** CAPI3REF: Run-Time Library Version Numbers
 ** KEYWORDS: sqlite3_version sqlite3_sourceid
 **
@@ -2333,12 +2336,18 @@
 **
 ** [[sqlite3_vfs.xAccess]]
 ** ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]
 ** to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to
 ** test whether a file is readable and writable, or [SQLITE_ACCESS_READ]
-** to test whether a file is at least readable.   The file can be a
-** directory.
+** to test whether a file is at least readable.  The SQLITE_ACCESS_READ
+** flag is never actually used and is not implemented in the built-in
+** VFSes of SQLite.  The file is named by the second argument and can be a
+** directory. The xAccess method returns [SQLITE_OK] on success or some
+** non-zero error code if there is an I/O error or if the name of
+** the file given in the second argument is illegal.  If SQLITE_OK
+** is returned, then non-zero or zero is written into *pResOut to indicate
+** whether or not the file is accessible.
 **
 ** ^SQLite will always allocate at least mxPathname+1 bytes for the
 ** output buffer xFullPathname.  The exact size of the output buffer
 ** is also passed as a parameter to both  methods. If the output buffer
 ** is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is
@@ -3124,10 +3133,21 @@
 ** The second parameter is a pointer to an integer into which
 ** is written 0 or 1 to indicate whether triggers are disabled or enabled
 ** following this call.  The second parameter may be a NULL pointer, in
 ** which case the trigger setting is not reported back. </dd>
 **
+** [[SQLITE_DBCONFIG_ENABLE_VIEW]]
+** <dt>SQLITE_DBCONFIG_ENABLE_VIEW</dt>
+** <dd> ^This option is used to enable or disable [CREATE VIEW | views].
+** There should be two additional arguments.
+** The first argument is an integer which is 0 to disable views,
+** positive to enable views or negative to leave the setting unchanged.
+** The second parameter is a pointer to an integer into which
+** is written 0 or 1 to indicate whether views are disabled or enabled
+** following this call.  The second parameter may be a NULL pointer, in
+** which case the view setting is not reported back. </dd>
+**
 ** [[SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER]]
 ** <dt>SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER</dt>
 ** <dd> ^This option is used to enable or disable the
 ** [fts3_tokenizer()] function which is part of the
 ** [FTS3] full-text search engine extension.
@@ -3235,10 +3255,11 @@
 ** flag is enabled, language features that allow ordinary SQL to
 ** deliberately corrupt the database file are disabled.  The disabled
 ** features include but are not limited to the following:
 ** <ul>
 ** <li> The [PRAGMA writable_schema=ON] statement.
+** <li> The [PRAGMA journal_mode=OFF] statement.
 ** <li> Writes to the [sqlite_dbpage] virtual table.
 ** <li> Direct writes to [shadow tables].
 ** </ul>
 ** </dd>
 **
@@ -3250,10 +3271,38 @@
 ** the writable_schema, positive to enable writable_schema, or negative to
 ** leave the setting unchanged. The second parameter is a pointer to an
 ** integer into which is written 0 or 1 to indicate whether the writable_schema
 ** is enabled or disabled following this call.
 ** </dd>
+**
+** [[SQLITE_DBCONFIG_LEGACY_ALTER_TABLE]]
+** <dt>SQLITE_DBCONFIG_LEGACY_ALTER_TABLE</dt>
+** <dd>The SQLITE_DBCONFIG_LEGACY_ALTER_TABLE option activates or deactivates
+** the legacy behavior of the [ALTER TABLE RENAME] command such it
+** behaves as it did prior to [version 3.24.0] (2018-06-04).  See the
+** "Compatibility Notice" on the [ALTER TABLE RENAME documentation] for
+** additional information. This feature can also be turned on and off
+** using the [PRAGMA legacy_alter_table] statement.
+** </dd>
+**
+** [[SQLITE_DBCONFIG_DQS_DML]]
+** <dt>SQLITE_DBCONFIG_DQS_DML</td>
+** <dd>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates
+** the legacy [double-quoted string literal] misfeature for DML statement
+** only, that is DELETE, INSERT, SELECT, and UPDATE statements. The
+** default value of this setting is determined by the [-DSQLITE_DQS]
+** compile-time option.
+** </dd>
+**
+** [[SQLITE_DBCONFIG_DQS_DDL]]
+** <dt>SQLITE_DBCONFIG_DQS_DDL</td>
+** <dd>The SQLITE_DBCONFIG_DQS option activates or deactivates
+** the legacy [double-quoted string literal] misfeature for DDL statements,
+** such as CREATE TABLE and CREATE INDEX. The
+** default value of this setting is determined by the [-DSQLITE_DQS]
+** compile-time option.
+** </dd>
 ** </dl>
 */
 #define SQLITE_DBCONFIG_MAINDBNAME            1000 /* const char* */
 #define SQLITE_DBCONFIG_LOOKASIDE             1001 /* void* int int */
 #define SQLITE_DBCONFIG_ENABLE_FKEY           1002 /* int int* */
@@ -3264,11 +3313,15 @@
 #define SQLITE_DBCONFIG_ENABLE_QPSG           1007 /* int int* */
 #define SQLITE_DBCONFIG_TRIGGER_EQP           1008 /* int int* */
 #define SQLITE_DBCONFIG_RESET_DATABASE        1009 /* int int* */
 #define SQLITE_DBCONFIG_DEFENSIVE             1010 /* int int* */
 #define SQLITE_DBCONFIG_WRITABLE_SCHEMA       1011 /* int int* */
-#define SQLITE_DBCONFIG_MAX                   1011 /* Largest DBCONFIG */
+#define SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    1012 /* int int* */
+#define SQLITE_DBCONFIG_DQS_DML               1013 /* int int* */
+#define SQLITE_DBCONFIG_DQS_DDL               1014 /* int int* */
+#define SQLITE_DBCONFIG_ENABLE_VIEW           1015 /* int int* */
+#define SQLITE_DBCONFIG_MAX                   1015 /* Largest DBCONFIG */
 
 /*
 ** CAPI3REF: Enable Or Disable Extended Result Codes
 ** METHOD: sqlite3
 **
@@ -4813,11 +4866,11 @@
 ** a schema change, on the first  [sqlite3_step()] call following any change
 ** to the [sqlite3_bind_text | bindings] of that [parameter].
 ** ^The specific value of WHERE-clause [parameter] might influence the
 ** choice of query plan if the parameter is the left-hand side of a [LIKE]
 ** or [GLOB] operator or if the parameter is compared to an indexed column
-** and the [SQLITE_ENABLE_STAT3] compile-time option is enabled.
+** and the [SQLITE_ENABLE_STAT4] compile-time option is enabled.
 ** </li>
 ** </ol>
 **
 ** <p>^sqlite3_prepare_v3() differs from sqlite3_prepare_v2() only in having
 ** the extra prepFlags parameter, which is a bit array consisting of zero or
@@ -5848,10 +5901,16 @@
 ** deterministic.  The built-in [random()] SQL function is an example of a
 ** function that is not deterministic.  The SQLite query planner is able to
 ** perform additional optimizations on deterministic functions, so use
 ** of the [SQLITE_DETERMINISTIC] flag is recommended where possible.
 **
+** ^The fourth parameter may also optionally include the [SQLITE_DIRECTONLY]
+** flag, which if present prevents the function from being invoked from
+** within VIEWs or TRIGGERs.  For security reasons, the [SQLITE_DIRECTONLY]
+** flag is recommended for any application-defined SQL function that has
+** side-effects.
+**
 ** ^(The fifth parameter is an arbitrary pointer.  The implementation of the
 ** function can gain access to this pointer using [sqlite3_user_data()].)^
 **
 ** ^The sixth, seventh and eighth parameters passed to the three
 ** "sqlite3_create_function*" functions, xFunc, xStep and xFinal, are
@@ -5964,12 +6023,34 @@
 **
 ** These constants may be ORed together with the
 ** [SQLITE_UTF8 | preferred text encoding] as the fourth argument
 ** to [sqlite3_create_function()], [sqlite3_create_function16()], or
 ** [sqlite3_create_function_v2()].
+**
+** The SQLITE_DETERMINISTIC flag means that the new function will always
+** maps the same inputs into the same output.  The abs() function is
+** deterministic, for example, but randomblob() is not.
+**
+** The SQLITE_DIRECTONLY flag means that the function may only be invoked
+** from top-level SQL, and cannot be used in VIEWs or TRIGGERs.  This is
+** a security feature which is recommended for all
+** [application-defined SQL functions] that have side-effects.  This flag
+** prevents an attacker from adding triggers and views to a schema then
+** tricking a high-privilege application into causing unintended side-effects
+** while performing ordinary queries.
+**
+** The SQLITE_SUBTYPE flag indicates to SQLite that a function may call
+** [sqlite3_value_subtype()] to inspect the sub-types of its arguments.
+** Specifying this flag makes no difference for scalar or aggregate user
+** functions. However, if it is not specified for a user-defined window
+** function, then any sub-types belonging to arguments passed to the window
+** function may be discarded before the window function is called (i.e.
+** sqlite3_value_subtype() will always return 0).
 */
-#define SQLITE_DETERMINISTIC    0x800
+#define SQLITE_DETERMINISTIC    0x000000800
+#define SQLITE_DIRECTONLY       0x000080000
+#define SQLITE_SUBTYPE          0x000100000
 
 /*
 ** CAPI3REF: Deprecated Functions
 ** DEPRECATED
 **
@@ -7611,10 +7692,16 @@
 ** no longer needs the pClientData pointer.  ^The destructor will also
 ** be invoked if the call to sqlite3_create_module_v2() fails.
 ** ^The sqlite3_create_module()
 ** interface is equivalent to sqlite3_create_module_v2() with a NULL
 ** destructor.
+**
+** ^If the third parameter (the pointer to the sqlite3_module object) is
+** NULL then no new module is create and any existing modules with the
+** same name are dropped.
+**
+** See also: [sqlite3_drop_modules()]
 */
 SQLITE_API int sqlite3_create_module(
   sqlite3 *db,               /* SQLite connection to register module with */
   const char *zName,         /* Name of the module */
   const sqlite3_module *p,   /* Methods for the module */
@@ -7626,10 +7713,27 @@
   const sqlite3_module *p,   /* Methods for the module */
   void *pClientData,         /* Client data for xCreate/xConnect */
   void(*xDestroy)(void*)     /* Module destructor function */
 );
 
+/*
+** CAPI3REF: Remove Unnecessary Virtual Table Implementations
+** METHOD: sqlite3
+**
+** ^The sqlite3_drop_modules(D,L) interface removes all virtual
+** table modules from database connection D except those named on list L.
+** The L parameter must be either NULL or a pointer to an array of pointers
+** to strings where the array is terminated by a single NULL pointer.
+** ^If the L parameter is NULL, then all virtual table modules are removed.
+**
+** See also: [sqlite3_create_module()]
+*/
+SQLITE_API int sqlite3_drop_modules(
+  sqlite3 *db,                /* Remove modules from this connection */
+  const char **azKeep         /* Except, do not remove the ones named here */
+);
+
 /*
 ** CAPI3REF: Virtual Table Instance Object
 ** KEYWORDS: sqlite3_vtab
 **
 ** Every [virtual table module] implementation uses a subclass
@@ -8334,11 +8438,11 @@
 ** [sqlite3_test_control()] interface.
 */
 #define SQLITE_TESTCTRL_FIRST                    5
 #define SQLITE_TESTCTRL_PRNG_SAVE                5
 #define SQLITE_TESTCTRL_PRNG_RESTORE             6
-#define SQLITE_TESTCTRL_PRNG_RESET               7
+#define SQLITE_TESTCTRL_PRNG_RESET               7  /* NOT USED */
 #define SQLITE_TESTCTRL_BITVEC_TEST              8
 #define SQLITE_TESTCTRL_FAULT_INSTALL            9
 #define SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS     10
 #define SQLITE_TESTCTRL_PENDING_BYTE            11
 #define SQLITE_TESTCTRL_ASSERT                  12
@@ -8356,11 +8460,14 @@
 #define SQLITE_TESTCTRL_BYTEORDER               22
 #define SQLITE_TESTCTRL_ISINIT                  23
 #define SQLITE_TESTCTRL_SORTER_MMAP             24
 #define SQLITE_TESTCTRL_IMPOSTER                25
 #define SQLITE_TESTCTRL_PARSER_COVERAGE         26
-#define SQLITE_TESTCTRL_LAST                    26  /* Largest TESTCTRL */
+#define SQLITE_TESTCTRL_RESULT_INTREAL          27
+#define SQLITE_TESTCTRL_PRNG_SEED               28
+#define SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS     29
+#define SQLITE_TESTCTRL_LAST                    29  /* Largest TESTCTRL */
 
 /*
 ** CAPI3REF: SQL Keyword Checking
 **
 ** These routines provide access to the set of SQL language keywords
@@ -13053,19 +13160,19 @@
 ** Ticket #3860:  The llvm-gcc-4.2 compiler from Apple chokes on
 ** the ((void*)&((char*)0)[X]) construct.  But MSVC chokes on ((void*)(X)).
 ** So we have to define the macros in different ways depending on the
 ** compiler.
 */
-#if defined(__PTRDIFF_TYPE__)  /* This case should work for GCC */
+#if defined(HAVE_STDINT_H)   /* Use this case if we have ANSI headers */
+# define SQLITE_INT_TO_PTR(X)  ((void*)(intptr_t)(X))
+# define SQLITE_PTR_TO_INT(X)  ((int)(intptr_t)(X))
+#elif defined(__PTRDIFF_TYPE__)  /* This case should work for GCC */
 # define SQLITE_INT_TO_PTR(X)  ((void*)(__PTRDIFF_TYPE__)(X))
 # define SQLITE_PTR_TO_INT(X)  ((int)(__PTRDIFF_TYPE__)(X))
 #elif !defined(__GNUC__)       /* Works for compilers other than LLVM */
 # define SQLITE_INT_TO_PTR(X)  ((void*)&((char*)0)[X])
 # define SQLITE_PTR_TO_INT(X)  ((int)(((char*)X)-(char*)0))
-#elif defined(HAVE_STDINT_H)   /* Use this case if we have ANSI headers */
-# define SQLITE_INT_TO_PTR(X)  ((void*)(intptr_t)(X))
-# define SQLITE_PTR_TO_INT(X)  ((int)(intptr_t)(X))
 #else                          /* Generates a warning - but it always works */
 # define SQLITE_INT_TO_PTR(X)  ((void*)(X))
 # define SQLITE_PTR_TO_INT(X)  ((int)(X))
 #endif
 
@@ -13551,104 +13658,107 @@
 #define TK_TRIGGER                         77
 #define TK_VACUUM                          78
 #define TK_VIEW                            79
 #define TK_VIRTUAL                         80
 #define TK_WITH                            81
-#define TK_CURRENT                         82
-#define TK_FOLLOWING                       83
-#define TK_PARTITION                       84
-#define TK_PRECEDING                       85
-#define TK_RANGE                           86
-#define TK_UNBOUNDED                       87
-#define TK_EXCLUDE                         88
-#define TK_GROUPS                          89
-#define TK_OTHERS                          90
-#define TK_TIES                            91
-#define TK_REINDEX                         92
-#define TK_RENAME                          93
-#define TK_CTIME_KW                        94
-#define TK_ANY                             95
-#define TK_BITAND                          96
-#define TK_BITOR                           97
-#define TK_LSHIFT                          98
-#define TK_RSHIFT                          99
-#define TK_PLUS                           100
-#define TK_MINUS                          101
-#define TK_STAR                           102
-#define TK_SLASH                          103
-#define TK_REM                            104
-#define TK_CONCAT                         105
-#define TK_COLLATE                        106
-#define TK_BITNOT                         107
-#define TK_ON                             108
-#define TK_INDEXED                        109
-#define TK_STRING                         110
-#define TK_JOIN_KW                        111
-#define TK_CONSTRAINT                     112
-#define TK_DEFAULT                        113
-#define TK_NULL                           114
-#define TK_PRIMARY                        115
-#define TK_UNIQUE                         116
-#define TK_CHECK                          117
-#define TK_REFERENCES                     118
-#define TK_AUTOINCR                       119
-#define TK_INSERT                         120
-#define TK_DELETE                         121
-#define TK_UPDATE                         122
-#define TK_SET                            123
-#define TK_DEFERRABLE                     124
-#define TK_FOREIGN                        125
-#define TK_DROP                           126
-#define TK_UNION                          127
-#define TK_ALL                            128
-#define TK_EXCEPT                         129
-#define TK_INTERSECT                      130
-#define TK_SELECT                         131
-#define TK_VALUES                         132
-#define TK_DISTINCT                       133
-#define TK_DOT                            134
-#define TK_FROM                           135
-#define TK_JOIN                           136
-#define TK_USING                          137
-#define TK_ORDER                          138
-#define TK_GROUP                          139
-#define TK_HAVING                         140
-#define TK_LIMIT                          141
-#define TK_WHERE                          142
-#define TK_INTO                           143
-#define TK_NOTHING                        144
-#define TK_FLOAT                          145
-#define TK_BLOB                           146
-#define TK_INTEGER                        147
-#define TK_VARIABLE                       148
-#define TK_CASE                           149
-#define TK_WHEN                           150
-#define TK_THEN                           151
-#define TK_ELSE                           152
-#define TK_INDEX                          153
-#define TK_ALTER                          154
-#define TK_ADD                            155
-#define TK_WINDOW                         156
-#define TK_OVER                           157
-#define TK_FILTER                         158
-#define TK_TRUEFALSE                      159
-#define TK_ISNOT                          160
-#define TK_FUNCTION                       161
+#define TK_NULLS                           82
+#define TK_FIRST                           83
+#define TK_LAST                            84
+#define TK_CURRENT                         85
+#define TK_FOLLOWING                       86
+#define TK_PARTITION                       87
+#define TK_PRECEDING                       88
+#define TK_RANGE                           89
+#define TK_UNBOUNDED                       90
+#define TK_EXCLUDE                         91
+#define TK_GROUPS                          92
+#define TK_OTHERS                          93
+#define TK_TIES                            94
+#define TK_REINDEX                         95
+#define TK_RENAME                          96
+#define TK_CTIME_KW                        97
+#define TK_ANY                             98
+#define TK_BITAND                          99
+#define TK_BITOR                          100
+#define TK_LSHIFT                         101
+#define TK_RSHIFT                         102
+#define TK_PLUS                           103
+#define TK_MINUS                          104
+#define TK_STAR                           105
+#define TK_SLASH                          106
+#define TK_REM                            107
+#define TK_CONCAT                         108
+#define TK_COLLATE                        109
+#define TK_BITNOT                         110
+#define TK_ON                             111
+#define TK_INDEXED                        112
+#define TK_STRING                         113
+#define TK_JOIN_KW                        114
+#define TK_CONSTRAINT                     115
+#define TK_DEFAULT                        116
+#define TK_NULL                           117
+#define TK_PRIMARY                        118
+#define TK_UNIQUE                         119
+#define TK_CHECK                          120
+#define TK_REFERENCES                     121
+#define TK_AUTOINCR                       122
+#define TK_INSERT                         123
+#define TK_DELETE                         124
+#define TK_UPDATE                         125
+#define TK_SET                            126
+#define TK_DEFERRABLE                     127
+#define TK_FOREIGN                        128
+#define TK_DROP                           129
+#define TK_UNION                          130
+#define TK_ALL                            131
+#define TK_EXCEPT                         132
+#define TK_INTERSECT                      133
+#define TK_SELECT                         134
+#define TK_VALUES                         135
+#define TK_DISTINCT                       136
+#define TK_DOT                            137
+#define TK_FROM                           138
+#define TK_JOIN                           139
+#define TK_USING                          140
+#define TK_ORDER                          141
+#define TK_GROUP                          142
+#define TK_HAVING                         143
+#define TK_LIMIT                          144
+#define TK_WHERE                          145
+#define TK_INTO                           146
+#define TK_NOTHING                        147
+#define TK_FLOAT                          148
+#define TK_BLOB                           149
+#define TK_INTEGER                        150
+#define TK_VARIABLE                       151
+#define TK_CASE                           152
+#define TK_WHEN                           153
+#define TK_THEN                           154
+#define TK_ELSE                           155
+#define TK_INDEX                          156
+#define TK_ALTER                          157
+#define TK_ADD                            158
+#define TK_WINDOW                         159
+#define TK_OVER                           160
+#define TK_FILTER                         161
 #define TK_COLUMN                         162
 #define TK_AGG_FUNCTION                   163
 #define TK_AGG_COLUMN                     164
-#define TK_UMINUS                         165
-#define TK_UPLUS                          166
-#define TK_TRUTH                          167
-#define TK_REGISTER                       168
-#define TK_VECTOR                         169
-#define TK_SELECT_COLUMN                  170
-#define TK_IF_NULL_ROW                    171
-#define TK_ASTERISK                       172
-#define TK_SPAN                           173
-#define TK_SPACE                          174
-#define TK_ILLEGAL                        175
+#define TK_TRUEFALSE                      165
+#define TK_ISNOT                          166
+#define TK_FUNCTION                       167
+#define TK_UMINUS                         168
+#define TK_UPLUS                          169
+#define TK_TRUTH                          170
+#define TK_REGISTER                       171
+#define TK_VECTOR                         172
+#define TK_SELECT_COLUMN                  173
+#define TK_IF_NULL_ROW                    174
+#define TK_ASTERISK                       175
+#define TK_SPAN                           176
+#define TK_SPACE                          177
+#define TK_ILLEGAL                        178
 
 /************** End of parse.h ***********************************************/
 /************** Continuing where we left off in sqliteInt.h ******************/
 #include <stdio.h>
 #include <stdlib.h>
@@ -13950,16 +14060,17 @@
 ** using C-preprocessor macros.  If that is unsuccessful, or if
 ** -DSQLITE_BYTEORDER=0 is set, then byte-order is determined
 ** at run-time.
 */
 #ifndef SQLITE_BYTEORDER
-# if defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \
-     defined(__x86_64) || defined(__x86_64__) || defined(_M_X64)  ||    \
-     defined(_M_AMD64) || defined(_M_ARM)     || defined(__x86)   ||    \
-     defined(__arm__)  || defined(_M_ARM64)
+# if defined(i386)      || defined(__i386__)      || defined(_M_IX86) ||    \
+     defined(__x86_64)  || defined(__x86_64__)    || defined(_M_X64)  ||    \
+     defined(_M_AMD64)  || defined(_M_ARM)        || defined(__x86)   ||    \
+     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64)
 #   define SQLITE_BYTEORDER    1234
-# elif defined(sparc)    || defined(__ppc__)
+# elif defined(sparc)     || defined(__ppc__) || \
+       defined(__ARMEB__) || defined(__AARCH64EB__)
 #   define SQLITE_BYTEORDER    4321
 # else
 #   define SQLITE_BYTEORDER 0
 # endif
 #endif
@@ -14054,24 +14165,10 @@
 #if SQLITE_DEFAULT_MMAP_SIZE>SQLITE_MAX_MMAP_SIZE
 # undef SQLITE_DEFAULT_MMAP_SIZE
 # define SQLITE_DEFAULT_MMAP_SIZE SQLITE_MAX_MMAP_SIZE
 #endif
 
-/*
-** Only one of SQLITE_ENABLE_STAT3 or SQLITE_ENABLE_STAT4 can be defined.
-** Priority is given to SQLITE_ENABLE_STAT4.  If either are defined, also
-** define SQLITE_ENABLE_STAT3_OR_STAT4
-*/
-#ifdef SQLITE_ENABLE_STAT4
-# undef SQLITE_ENABLE_STAT3
-# define SQLITE_ENABLE_STAT3_OR_STAT4 1
-#elif SQLITE_ENABLE_STAT3
-# define SQLITE_ENABLE_STAT3_OR_STAT4 1
-#elif SQLITE_ENABLE_STAT3_OR_STAT4
-# undef SQLITE_ENABLE_STAT3_OR_STAT4
-#endif
-
 /*
 ** SELECTTRACE_ENABLED will be either 1 or 0 depending on whether or not
 ** the Select query generator tracing logic is turned on.
 */
 #if defined(SQLITE_ENABLE_SELECTTRACE)
@@ -14937,28 +15034,28 @@
 #define OP_Affinity       91 /* synopsis: affinity(r[P1@P2])               */
 #define OP_MakeRecord     92 /* synopsis: r[P3]=mkrec(r[P1@P2])            */
 #define OP_Count          93 /* synopsis: r[P2]=count()                    */
 #define OP_ReadCookie     94
 #define OP_SetCookie      95
-#define OP_BitAnd         96 /* same as TK_BITAND, synopsis: r[P3]=r[P1]&r[P2] */
-#define OP_BitOr          97 /* same as TK_BITOR, synopsis: r[P3]=r[P1]|r[P2] */
-#define OP_ShiftLeft      98 /* same as TK_LSHIFT, synopsis: r[P3]=r[P2]<<r[P1] */
-#define OP_ShiftRight     99 /* same as TK_RSHIFT, synopsis: r[P3]=r[P2]>>r[P1] */
-#define OP_Add           100 /* same as TK_PLUS, synopsis: r[P3]=r[P1]+r[P2] */
-#define OP_Subtract      101 /* same as TK_MINUS, synopsis: r[P3]=r[P2]-r[P1] */
-#define OP_Multiply      102 /* same as TK_STAR, synopsis: r[P3]=r[P1]*r[P2] */
-#define OP_Divide        103 /* same as TK_SLASH, synopsis: r[P3]=r[P2]/r[P1] */
-#define OP_Remainder     104 /* same as TK_REM, synopsis: r[P3]=r[P2]%r[P1] */
-#define OP_Concat        105 /* same as TK_CONCAT, synopsis: r[P3]=r[P2]+r[P1] */
-#define OP_ReopenIdx     106 /* synopsis: root=P2 iDb=P3                   */
-#define OP_BitNot        107 /* same as TK_BITNOT, synopsis: r[P2]= ~r[P1] */
-#define OP_OpenRead      108 /* synopsis: root=P2 iDb=P3                   */
-#define OP_OpenWrite     109 /* synopsis: root=P2 iDb=P3                   */
-#define OP_String8       110 /* same as TK_STRING, synopsis: r[P2]='P4'    */
-#define OP_OpenDup       111
-#define OP_OpenAutoindex 112 /* synopsis: nColumn=P2                       */
-#define OP_OpenEphemeral 113 /* synopsis: nColumn=P2                       */
+#define OP_ReopenIdx      96 /* synopsis: root=P2 iDb=P3                   */
+#define OP_OpenRead       97 /* synopsis: root=P2 iDb=P3                   */
+#define OP_OpenWrite      98 /* synopsis: root=P2 iDb=P3                   */
+#define OP_BitAnd         99 /* same as TK_BITAND, synopsis: r[P3]=r[P1]&r[P2] */
+#define OP_BitOr         100 /* same as TK_BITOR, synopsis: r[P3]=r[P1]|r[P2] */
+#define OP_ShiftLeft     101 /* same as TK_LSHIFT, synopsis: r[P3]=r[P2]<<r[P1] */
+#define OP_ShiftRight    102 /* same as TK_RSHIFT, synopsis: r[P3]=r[P2]>>r[P1] */
+#define OP_Add           103 /* same as TK_PLUS, synopsis: r[P3]=r[P1]+r[P2] */
+#define OP_Subtract      104 /* same as TK_MINUS, synopsis: r[P3]=r[P2]-r[P1] */
+#define OP_Multiply      105 /* same as TK_STAR, synopsis: r[P3]=r[P1]*r[P2] */
+#define OP_Divide        106 /* same as TK_SLASH, synopsis: r[P3]=r[P2]/r[P1] */
+#define OP_Remainder     107 /* same as TK_REM, synopsis: r[P3]=r[P2]%r[P1] */
+#define OP_Concat        108 /* same as TK_CONCAT, synopsis: r[P3]=r[P2]+r[P1] */
+#define OP_OpenDup       109
+#define OP_BitNot        110 /* same as TK_BITNOT, synopsis: r[P2]= ~r[P1] */
+#define OP_OpenAutoindex 111 /* synopsis: nColumn=P2                       */
+#define OP_OpenEphemeral 112 /* synopsis: nColumn=P2                       */
+#define OP_String8       113 /* same as TK_STRING, synopsis: r[P2]='P4'    */
 #define OP_SorterOpen    114
 #define OP_SequenceTest  115 /* synopsis: if( cursor[P1].ctr++ ) pc = P2   */
 #define OP_OpenPseudo    116 /* synopsis: P3 columns in r[P2]              */
 #define OP_Close         117
 #define OP_ColumnsUsed   118
@@ -14986,14 +15083,14 @@
 #define OP_SqlExec       140
 #define OP_ParseSchema   141
 #define OP_LoadAnalysis  142
 #define OP_DropTable     143
 #define OP_DropIndex     144
-#define OP_Real          145 /* same as TK_FLOAT, synopsis: r[P2]=P4       */
-#define OP_DropTrigger   146
-#define OP_IntegrityCk   147
-#define OP_RowSetAdd     148 /* synopsis: rowset(P1)=r[P2]                 */
+#define OP_DropTrigger   145
+#define OP_IntegrityCk   146
+#define OP_RowSetAdd     147 /* synopsis: rowset(P1)=r[P2]                 */
+#define OP_Real          148 /* same as TK_FLOAT, synopsis: r[P2]=P4       */
 #define OP_Param         149
 #define OP_FkCounter     150 /* synopsis: fkctr[P1]+=P2                    */
 #define OP_MemMax        151 /* synopsis: r[P1]=max(r[P1],r[P2])           */
 #define OP_OffsetLimit   152 /* synopsis: if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1) */
 #define OP_AggInverse    153 /* synopsis: accum=r[P3] inverse(r[P2@P5])    */
@@ -15038,17 +15135,17 @@
 /*  56 */ 0x0b, 0x0b, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,\
 /*  64 */ 0x00, 0x00, 0x02, 0x02, 0x08, 0x00, 0x10, 0x10,\
 /*  72 */ 0x10, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00, 0x10,\
 /*  80 */ 0x10, 0x00, 0x00, 0x02, 0x02, 0x02, 0x00, 0x00,\
 /*  88 */ 0x12, 0x20, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00,\
-/*  96 */ 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,\
-/* 104 */ 0x26, 0x26, 0x00, 0x12, 0x00, 0x00, 0x10, 0x00,\
-/* 112 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+/*  96 */ 0x00, 0x00, 0x00, 0x26, 0x26, 0x26, 0x26, 0x26,\
+/* 104 */ 0x26, 0x26, 0x26, 0x26, 0x26, 0x00, 0x12, 0x00,\
+/* 112 */ 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
 /* 120 */ 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
 /* 128 */ 0x10, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x10,\
 /* 136 */ 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,\
-/* 144 */ 0x00, 0x10, 0x00, 0x00, 0x06, 0x10, 0x00, 0x04,\
+/* 144 */ 0x00, 0x00, 0x00, 0x06, 0x10, 0x10, 0x00, 0x04,\
 /* 152 */ 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
 /* 160 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10,\
 /* 168 */ 0x00, 0x00, 0x00, 0x00, 0x00,}
 
 /* The sqlite3P2Values() routine is able to run faster if it knows
@@ -15114,14 +15211,14 @@
 SQLITE_PRIVATE   void sqlite3ExplainBreakpoint(const char*,const char*);
 #else
 # define sqlite3ExplainBreakpoint(A,B) /*no-op*/
 #endif
 SQLITE_PRIVATE void sqlite3VdbeAddParseSchemaOp(Vdbe*,int,char*);
-SQLITE_PRIVATE void sqlite3VdbeChangeOpcode(Vdbe*, u32 addr, u8);
-SQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe*, u32 addr, int P1);
-SQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe*, u32 addr, int P2);
-SQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe*, u32 addr, int P3);
+SQLITE_PRIVATE void sqlite3VdbeChangeOpcode(Vdbe*, int addr, u8);
+SQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe*, int addr, int P1);
+SQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe*, int addr, int P2);
+SQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe*, int addr, int P3);
 SQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe*, u16 P5);
 SQLITE_PRIVATE void sqlite3VdbeJumpHere(Vdbe*, int addr);
 SQLITE_PRIVATE int sqlite3VdbeChangeToNoop(Vdbe*, int addr);
 SQLITE_PRIVATE int sqlite3VdbeDeletePriorOpcode(Vdbe*, u8 op);
 SQLITE_PRIVATE void sqlite3VdbeChangeP4(Vdbe*, int addr, const char *zP4, int N);
@@ -16074,10 +16171,11 @@
 #define sqlite3MutexInit()        SQLITE_OK
 #define sqlite3MutexEnd()
 #define MUTEX_LOGIC(X)
 #else
 #define MUTEX_LOGIC(X)            X
+SQLITE_API int sqlite3_mutex_held(sqlite3_mutex*);
 #endif /* defined(SQLITE_MUTEX_OMIT) */
 
 /************** End of mutex.h ***********************************************/
 /************** Continuing where we left off in sqliteInt.h ******************/
 
@@ -16332,10 +16430,11 @@
     u8 iDb;                     /* Which db file is being initialized */
     u8 busy;                    /* TRUE if currently initializing */
     unsigned orphanTrigger : 1; /* Last statement is orphaned TEMP trigger */
     unsigned imposterTable : 1; /* Building an imposter table */
     unsigned reopenMemdb : 1;   /* ATTACH is really a reopen using MemDB */
+    char **azInit;              /* "type", "name", and "tbl_name" columns */
   } init;
   int nVdbeActive;              /* Number of VDBEs currently running */
   int nVdbeRead;                /* Number of active VDBEs that read or write */
   int nVdbeWrite;               /* Number of active VDBEs that read and write */
   int nVdbeExec;                /* Number of nested calls to VdbeExec() */
@@ -16468,20 +16567,23 @@
 #define SQLITE_TriggerEQP     0x01000000  /* Show trigger EXPLAIN QUERY PLAN */
 #define SQLITE_ResetDatabase  0x02000000  /* Reset the database */
 #define SQLITE_LegacyAlter    0x04000000  /* Legacy ALTER TABLE behaviour */
 #define SQLITE_NoSchemaError  0x08000000  /* Do not report schema parse errors*/
 #define SQLITE_Defensive      0x10000000  /* Input SQL is likely hostile */
+#define SQLITE_DqsDDL         0x20000000  /* dbl-quoted strings allowed in DDL*/
+#define SQLITE_DqsDML         0x40000000  /* dbl-quoted strings allowed in DML*/
+#define SQLITE_EnableView     0x80000000  /* Enable the use of views */
 
 /* Flags used only if debugging */
 #define HI(X)  ((u64)(X)<<32)
 #ifdef SQLITE_DEBUG
-#define SQLITE_SqlTrace       HI(0x0001)  /* Debug print SQL as it executes */
-#define SQLITE_VdbeListing    HI(0x0002)  /* Debug listings of VDBE progs */
-#define SQLITE_VdbeTrace      HI(0x0004)  /* True to trace VDBE execution */
-#define SQLITE_VdbeAddopTrace HI(0x0008)  /* Trace sqlite3VdbeAddOp() calls */
-#define SQLITE_VdbeEQP        HI(0x0010)  /* Debug EXPLAIN QUERY PLAN */
-#define SQLITE_ParserTrace    HI(0x0020)  /* PRAGMA parser_trace=ON */
+#define SQLITE_SqlTrace       HI(0x0100000) /* Debug print SQL as it executes */
+#define SQLITE_VdbeListing    HI(0x0200000) /* Debug listings of VDBE progs */
+#define SQLITE_VdbeTrace      HI(0x0400000) /* True to trace VDBE execution */
+#define SQLITE_VdbeAddopTrace HI(0x0800000) /* Trace sqlite3VdbeAddOp() calls */
+#define SQLITE_VdbeEQP        HI(0x1000000) /* Debug EXPLAIN QUERY PLAN */
+#define SQLITE_ParserTrace    HI(0x2000000) /* PRAGMA parser_trace=ON */
 #endif
 
 /*
 ** Allowed values for sqlite3.mDbFlags
 */
@@ -16505,12 +16607,12 @@
 #define SQLITE_OrderByIdxJoin 0x0040   /* ORDER BY of joins via index */
 #define SQLITE_Transitive     0x0080   /* Transitive constraints */
 #define SQLITE_OmitNoopJoin   0x0100   /* Omit unused tables in joins */
 #define SQLITE_CountOfView    0x0200   /* The count-of-view optimization */
 #define SQLITE_CursorHints    0x0400   /* Add OP_CursorHint opcodes */
-#define SQLITE_Stat34         0x0800   /* Use STAT3 or STAT4 data */
-   /* TH3 expects the Stat34  ^^^^^^ value to be 0x0800.  Don't change it */
+#define SQLITE_Stat4          0x0800   /* Use STAT4 data */
+   /* TH3 expects the Stat4   ^^^^^^ value to be 0x0800.  Don't change it */
 #define SQLITE_PushDown       0x1000   /* The push-down optimization */
 #define SQLITE_SimplifyJoin   0x2000   /* Convert LEFT JOIN to JOIN */
 #define SQLITE_SkipScan       0x4000   /* Skip-scans */
 #define SQLITE_PropagateConst 0x8000   /* The constant propagation opt */
 #define SQLITE_AllOpts        0xffff   /* All optimizations */
@@ -16594,10 +16696,11 @@
 ** Value constraints (enforced via assert()):
 **     SQLITE_FUNC_MINMAX    ==  NC_MinMaxAgg      == SF_MinMaxAgg
 **     SQLITE_FUNC_LENGTH    ==  OPFLAG_LENGTHARG
 **     SQLITE_FUNC_TYPEOF    ==  OPFLAG_TYPEOFARG
 **     SQLITE_FUNC_CONSTANT  ==  SQLITE_DETERMINISTIC from the API
+**     SQLITE_FUNC_DIRECT    ==  SQLITE_DIRECTONLY from the API
 **     SQLITE_FUNC_ENCMASK   depends on SQLITE_UTF* macros in the API
 */
 #define SQLITE_FUNC_ENCMASK  0x0003 /* SQLITE_UTF8, SQLITE_UTF16BE or UTF16LE */
 #define SQLITE_FUNC_LIKE     0x0004 /* Candidate for the LIKE optimization */
 #define SQLITE_FUNC_CASE     0x0008 /* Case-sensitive LIKE-type function */
@@ -16614,10 +16717,12 @@
                                     ** single query - might change over time */
 #define SQLITE_FUNC_AFFINITY 0x4000 /* Built-in affinity() function */
 #define SQLITE_FUNC_OFFSET   0x8000 /* Built-in sqlite_offset() function */
 #define SQLITE_FUNC_WINDOW   0x00010000 /* Built-in window-only function */
 #define SQLITE_FUNC_INTERNAL 0x00040000 /* For use by NestedParse() only */
+#define SQLITE_FUNC_DIRECT   0x00080000 /* Not for use in TRIGGERs or VIEWs */
+#define SQLITE_FUNC_SUBTYPE  0x00100000 /* Result likely to have sub-type */
 
 /*
 ** The following three macros, FUNCTION(), LIKEFUNC() and AGGREGATE() are
 ** used to create the initializers for the FuncDef structures.
 **
@@ -16727,10 +16832,11 @@
 ** hash table.
 */
 struct Module {
   const sqlite3_module *pModule;       /* Callback pointers */
   const char *zName;                   /* Name passed to create_module() */
+  int nRefModule;                      /* Number of pointers to this object */
   void *pAux;                          /* pAux passed to create_module() */
   void (*xDestroy)(void *);            /* Module destructor function */
   Table *pEpoTab;                      /* Eponymous table for this module */
 };
 
@@ -16792,15 +16898,16 @@
 ** used as the P4 operand, they will be more readable.
 **
 ** Note also that the numeric types are grouped together so that testing
 ** for a numeric type is a single comparison.  And the BLOB type is first.
 */
-#define SQLITE_AFF_BLOB     'A'
-#define SQLITE_AFF_TEXT     'B'
-#define SQLITE_AFF_NUMERIC  'C'
-#define SQLITE_AFF_INTEGER  'D'
-#define SQLITE_AFF_REAL     'E'
+#define SQLITE_AFF_NONE     0x40  /* '@' */
+#define SQLITE_AFF_BLOB     0x41  /* 'A' */
+#define SQLITE_AFF_TEXT     0x42  /* 'B' */
+#define SQLITE_AFF_NUMERIC  0x43  /* 'C' */
+#define SQLITE_AFF_INTEGER  0x44  /* 'D' */
+#define SQLITE_AFF_REAL     0x45  /* 'E' */
 
 #define sqlite3IsNumericAffinity(X)  ((X)>=SQLITE_AFF_NUMERIC)
 
 /*
 ** The SQLITE_AFF_MASK values masks off the significant bits of an
@@ -17064,14 +17171,20 @@
   u32 nRef;           /* Number of references to this KeyInfo object */
   u8 enc;             /* Text encoding - one of the SQLITE_UTF* values */
   u16 nKeyField;      /* Number of key columns in the index */
   u16 nAllField;      /* Total columns, including key plus others */
   sqlite3 *db;        /* The database connection */
-  u8 *aSortOrder;     /* Sort order for each column. */
+  u8 *aSortFlags;     /* Sort order for each column. */
   CollSeq *aColl[1];  /* Collating sequence for each term of the key */
 };
 
+/*
+** Allowed bit values for entries in the KeyInfo.aSortFlags[] array.
+*/
+#define KEYINFO_ORDER_DESC    0x01    /* DESC sort order */
+#define KEYINFO_ORDER_BIGNULL 0x02    /* NULL is larger than any other value */
+
 /*
 ** This object holds a record which has been parsed out into individual
 ** fields, for the purposes of doing a comparison.
 **
 ** A record is an object that contains one or more fields of data.
@@ -17174,11 +17287,12 @@
   unsigned isResized:1;    /* True if resizeIndexObject() has been called */
   unsigned isCovering:1;   /* True if this is a covering index */
   unsigned noSkipScan:1;   /* Do not try to use skip-scan if true */
   unsigned hasStat1:1;     /* aiRowLogEst values come from sqlite_stat1 */
   unsigned bNoQuery:1;     /* Do not use this index to optimize queries */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+  unsigned bAscKeyBug:1;   /* True if the bba7b69f9849b5bf bug applies */
+#ifdef SQLITE_ENABLE_STAT4
   int nSample;             /* Number of elements in aSample[] */
   int nSampleCol;          /* Size of IndexSample.anEq[] and so on */
   tRowcnt *aAvgEq;         /* Average nEq values for keys not in aSample */
   IndexSample *aSample;    /* Samples of the left-most key */
   tRowcnt *aiRowEst;       /* Non-logarithmic stat1 data for this index */
@@ -17206,11 +17320,11 @@
 */
 #define XN_ROWID     (-1)     /* Indexed column is the rowid */
 #define XN_EXPR      (-2)     /* Indexed column is an expression */
 
 /*
-** Each sample stored in the sqlite_stat3 table is represented in memory
+** Each sample stored in the sqlite_stat4 table is represented in memory
 ** using a structure of this type.  See documentation at the top of the
 ** analyze.c source file for additional information.
 */
 struct IndexSample {
   void *p;          /* Pointer to sampled record */
@@ -17364,11 +17478,11 @@
 ** the subtrees in Expr.x.pList or Expr.x.pSelect are always separately
 ** allocated, regardless of whether or not EP_Reduced is set.
 */
 struct Expr {
   u8 op;                 /* Operation performed by this node */
-  char affinity;         /* The affinity of the column or 0 if not a column */
+  char affExpr;          /* affinity, or RAISE type */
   u32 flags;             /* Various flags.  EP_* See below */
   union {
     char *zToken;          /* Token value. Zero terminated and dequoted */
     int iValue;            /* Non-negative integer value if EP_IntValue */
   } u;
@@ -17395,24 +17509,26 @@
 #endif
   int iTable;            /* TK_COLUMN: cursor number of table holding column
                          ** TK_REGISTER: register number
                          ** TK_TRIGGER: 1 -> new, 0 -> old
                          ** EP_Unlikely:  134217728 times likelihood
+                         ** TK_IN: ephemerial table holding RHS
+                         ** TK_SELECT_COLUMN: Number of columns on the LHS
                          ** TK_SELECT: 1st register of result vector */
   ynVar iColumn;         /* TK_COLUMN: column index.  -1 for rowid.
                          ** TK_VARIABLE: variable number (always >= 1).
                          ** TK_SELECT_COLUMN: column of the result vector */
   i16 iAgg;              /* Which entry in pAggInfo->aCol[] or ->aFunc[] */
   i16 iRightJoinTable;   /* If EP_FromJoin, the right table of the join */
-  u8 op2;                /* TK_REGISTER: original value of Expr.op
+  u8 op2;                /* TK_REGISTER/TK_TRUTH: original value of Expr.op
                          ** TK_COLUMN: the value of p5 for OP_Column
                          ** TK_AGG_FUNCTION: nesting depth */
   AggInfo *pAggInfo;     /* Used by TK_AGG_COLUMN and TK_AGG_FUNCTION */
   union {
     Table *pTab;           /* TK_COLUMN: Table containing column. Can be NULL
                            ** for a column of an index on an expression */
-    Window *pWin;          /* TK_FUNCTION: Window definition for the func */
+    Window *pWin;          /* EP_WinFunc: Window/Filter defn for a function */
     struct {               /* TK_IN, TK_SELECT, and TK_EXISTS */
       int iAddr;             /* Subroutine entry address */
       int regReturn;         /* Register used to hold return address */
     } sub;
   } y;
@@ -17423,38 +17539,41 @@
 ** Value restrictions:
 **
 **          EP_Agg == NC_HasAgg == SF_HasAgg
 **          EP_Win == NC_HasWin
 */
-#define EP_FromJoin  0x000001 /* Originates in ON/USING clause of outer join */
-#define EP_Distinct  0x000002 /* Aggregate function with DISTINCT keyword */
-#define EP_HasFunc   0x000004 /* Contains one or more functions of any kind */
-#define EP_FixedCol  0x000008 /* TK_Column with a known fixed value */
-#define EP_Agg       0x000010 /* Contains one or more aggregate functions */
-#define EP_VarSelect 0x000020 /* pSelect is correlated, not constant */
-#define EP_DblQuoted 0x000040 /* token.z was originally in "..." */
-#define EP_InfixFunc 0x000080 /* True for an infix function: LIKE, GLOB, etc */
-#define EP_Collate   0x000100 /* Tree contains a TK_COLLATE operator */
-#define EP_Generic   0x000200 /* Ignore COLLATE or affinity on this tree */
-#define EP_IntValue  0x000400 /* Integer value contained in u.iValue */
-#define EP_xIsSelect 0x000800 /* x.pSelect is valid (otherwise x.pList is) */
-#define EP_Skip      0x001000 /* COLLATE, AS, or UNLIKELY */
-#define EP_Reduced   0x002000 /* Expr struct EXPR_REDUCEDSIZE bytes only */
-#define EP_TokenOnly 0x004000 /* Expr struct EXPR_TOKENONLYSIZE bytes only */
-#define EP_Win       0x008000 /* Contains window functions */
-#define EP_MemToken  0x010000 /* Need to sqlite3DbFree() Expr.zToken */
-#define EP_NoReduce  0x020000 /* Cannot EXPRDUP_REDUCE this Expr */
-#define EP_Unlikely  0x040000 /* unlikely() or likelihood() function */
-#define EP_ConstFunc 0x080000 /* A SQLITE_FUNC_CONSTANT or _SLOCHNG function */
-#define EP_CanBeNull 0x100000 /* Can be null despite NOT NULL constraint */
-#define EP_Subquery  0x200000 /* Tree contains a TK_SELECT operator */
-#define EP_Alias     0x400000 /* Is an alias for a result set column */
-#define EP_Leaf      0x800000 /* Expr.pLeft, .pRight, .u.pSelect all NULL */
-#define EP_WinFunc  0x1000000 /* TK_FUNCTION with Expr.y.pWin set */
-#define EP_Subrtn   0x2000000 /* Uses Expr.y.sub. TK_IN, _SELECT, or _EXISTS */
-#define EP_Quoted   0x4000000 /* TK_ID was originally quoted */
-#define EP_Static   0x8000000 /* Held in memory not obtained from malloc() */
+#define EP_FromJoin   0x000001 /* Originates in ON/USING clause of outer join */
+#define EP_Distinct   0x000002 /* Aggregate function with DISTINCT keyword */
+#define EP_HasFunc    0x000004 /* Contains one or more functions of any kind */
+#define EP_FixedCol   0x000008 /* TK_Column with a known fixed value */
+#define EP_Agg        0x000010 /* Contains one or more aggregate functions */
+#define EP_VarSelect  0x000020 /* pSelect is correlated, not constant */
+#define EP_DblQuoted  0x000040 /* token.z was originally in "..." */
+#define EP_InfixFunc  0x000080 /* True for an infix function: LIKE, GLOB, etc */
+#define EP_Collate    0x000100 /* Tree contains a TK_COLLATE operator */
+  /*                  0x000200 Available for reuse */
+#define EP_IntValue   0x000400 /* Integer value contained in u.iValue */
+#define EP_xIsSelect  0x000800 /* x.pSelect is valid (otherwise x.pList is) */
+#define EP_Skip       0x001000 /* Operator does not contribute to affinity */
+#define EP_Reduced    0x002000 /* Expr struct EXPR_REDUCEDSIZE bytes only */
+#define EP_TokenOnly  0x004000 /* Expr struct EXPR_TOKENONLYSIZE bytes only */
+#define EP_Win        0x008000 /* Contains window functions */
+#define EP_MemToken   0x010000 /* Need to sqlite3DbFree() Expr.zToken */
+#define EP_NoReduce   0x020000 /* Cannot EXPRDUP_REDUCE this Expr */
+#define EP_Unlikely   0x040000 /* unlikely() or likelihood() function */
+#define EP_ConstFunc  0x080000 /* A SQLITE_FUNC_CONSTANT or _SLOCHNG function */
+#define EP_CanBeNull  0x100000 /* Can be null despite NOT NULL constraint */
+#define EP_Subquery   0x200000 /* Tree contains a TK_SELECT operator */
+#define EP_Alias      0x400000 /* Is an alias for a result set column */
+#define EP_Leaf       0x800000 /* Expr.pLeft, .pRight, .u.pSelect all NULL */
+#define EP_WinFunc   0x1000000 /* TK_FUNCTION with Expr.y.pWin set */
+#define EP_Subrtn    0x2000000 /* Uses Expr.y.sub. TK_IN, _SELECT, or _EXISTS */
+#define EP_Quoted    0x4000000 /* TK_ID was originally quoted */
+#define EP_Static    0x8000000 /* Held in memory not obtained from malloc() */
+#define EP_IsTrue   0x10000000 /* Always has boolean value of TRUE */
+#define EP_IsFalse  0x20000000 /* Always has boolean value of FALSE */
+#define EP_Indirect 0x40000000 /* Contained within a TRIGGER or a VIEW */
 
 /*
 ** The EP_Propagate mask is a set of properties that automatically propagate
 ** upwards into parent nodes.
 */
@@ -17466,10 +17585,12 @@
 */
 #define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)
 #define ExprHasAllProperty(E,P)  (((E)->flags&(P))==(P))
 #define ExprSetProperty(E,P)     (E)->flags|=(P)
 #define ExprClearProperty(E,P)   (E)->flags&=~(P)
+#define ExprAlwaysTrue(E)   (((E)->flags&(EP_FromJoin|EP_IsTrue))==EP_IsTrue)
+#define ExprAlwaysFalse(E)  (((E)->flags&(EP_FromJoin|EP_IsFalse))==EP_IsFalse)
 
 /* The ExprSetVVAProperty() macro is used for Verification, Validation,
 ** and Accreditation only.  It works like ExprSetProperty() during VVA
 ** processes but is a no-op for delivery.
 */
@@ -17492,10 +17613,22 @@
 ** Flags passed to the sqlite3ExprDup() function. See the header comment
 ** above sqlite3ExprDup() for details.
 */
 #define EXPRDUP_REDUCE         0x0001  /* Used reduced-size Expr nodes */
 
+/*
+** True if the expression passed as an argument was a function with
+** an OVER() clause (a window function).
+*/
+#ifdef SQLITE_OMIT_WINDOWFUNC
+# define IsWindowFunc(p) 0
+#else
+# define IsWindowFunc(p) ( \
+    ExprHasProperty((p), EP_WinFunc) && p->y.pWin->eFrmType!=TK_FILTER \
+ )
+#endif
+
 /*
 ** A list of expressions.  Each expression may optionally have a
 ** name.  An expr/name combination can be used in several ways, such
 ** as the list of "expr AS ID" fields following a "SELECT" or in the
 ** list of "ID = expr" items in an UPDATE.  A list of expressions can
@@ -17514,15 +17647,16 @@
   int nExpr;             /* Number of expressions on the list */
   struct ExprList_item { /* For each expression in the list */
     Expr *pExpr;            /* The parse tree for this expression */
     char *zName;            /* Token associated with this expression */
     char *zSpan;            /* Original text of the expression */
-    u8 sortOrder;           /* 1 for DESC or 0 for ASC */
+    u8 sortFlags;           /* Mask of KEYINFO_ORDER_* flags */
     unsigned done :1;       /* A flag to indicate when processing is finished */
     unsigned bSpanIsTab :1; /* zSpan holds DB.TABLE.COLUMN */
     unsigned reusable :1;   /* Constant expression is reusable */
     unsigned bSorterRef :1; /* Defer evaluation until after sorting */
+    unsigned bNulls: 1;     /* True if explicit "NULLS FIRST/LAST" */
     union {
       struct {
         u16 iOrderByCol;      /* For ORDER BY, column number in result set */
         u16 iAlias;           /* Index into Parse.aAlias[] for zName */
       } x;
@@ -17682,11 +17816,11 @@
     Upsert *pUpsert;     /* ON CONFLICT clause information from an upsert */
   } uNC;
   NameContext *pNext;  /* Next outer name context.  NULL for outermost */
   int nRef;            /* Number of names resolved by this context */
   int nErr;            /* Number of errors encountered while resolving names */
-  u16 ncFlags;         /* Zero or more NC_* flags defined below */
+  int ncFlags;         /* Zero or more NC_* flags defined below */
   Select *pWinSelect;  /* SELECT statement for any window functions */
 };
 
 /*
 ** Allowed values for the NameContext, ncFlags field.
@@ -17709,10 +17843,11 @@
 #define NC_UUpsert   0x0200  /* True if uNC.pUpsert is used */
 #define NC_MinMaxAgg 0x1000  /* min/max aggregates seen.  See note above */
 #define NC_Complex   0x2000  /* True if a function or subquery seen */
 #define NC_AllowWin  0x4000  /* Window functions are allowed here */
 #define NC_HasWin    0x8000  /* One or more window functions seen */
+#define NC_IsDDL    0x10000  /* Resolving names in a CREATE statement */
 
 /*
 ** An instance of the following object describes a single ON CONFLICT
 ** clause in an upsert.
 **
@@ -17808,10 +17943,11 @@
 #define SF_FixedLimit     0x04000  /* nSelectRow set by a constant LIMIT */
 #define SF_MaybeConvert   0x08000  /* Need convertCompoundSelectToSubquery() */
 #define SF_Converted      0x10000  /* By convertCompoundSelectToSubquery() */
 #define SF_IncludeHidden  0x20000  /* Include hidden columns in output */
 #define SF_ComplexResult  0x40000  /* Result contains subquery or function */
+#define SF_WhereBegin     0x80000  /* Really a WhereBegin() call.  Debug Only */
 
 /*
 ** The results of a SELECT can be distributed in several ways, as defined
 ** by one of the following macros.  The "SRT" prefix means "SELECT Result
 ** Type".
@@ -18312,15 +18448,16 @@
 **
 ** This structure also contains some state information.
 */
 struct Sqlite3Config {
   int bMemstat;                     /* True to enable memory status */
-  int bCoreMutex;                   /* True to enable core mutexing */
-  int bFullMutex;                   /* True to enable full mutexing */
-  int bOpenUri;                     /* True to interpret filenames as URIs */
-  int bUseCis;                      /* Use covering indices for full-scans */
-  int bSmallMalloc;                 /* Avoid large memory allocations if true */
+  u8 bCoreMutex;                    /* True to enable core mutexing */
+  u8 bFullMutex;                    /* True to enable full mutexing */
+  u8 bOpenUri;                      /* True to interpret filenames as URIs */
+  u8 bUseCis;                       /* Use covering indices for full-scans */
+  u8 bSmallMalloc;                  /* Avoid large memory allocations if true */
+  u8 bExtraSchemaChecks;            /* Verify type,name,tbl_name in schema */
   int mxStrlen;                     /* Maximum string length */
   int neverCorrupt;                 /* Database is always well-formed */
   int szLookaside;                  /* Default lookaside buffer size */
   int nLookaside;                   /* Default lookaside buffer count */
   int nStmtSpill;                   /* Stmt-journal spill-to-disk threshold */
@@ -18368,10 +18505,11 @@
 #endif
   int bLocaltimeFault;              /* True to fail localtime() calls */
   int bInternalFunctions;           /* Internal SQL functions are visible */
   int iOnceResetThreshold;          /* When to reset OP_Once counters */
   u32 szSorterRef;                  /* Min size in bytes to use sorter-refs */
+  unsigned int iPrngSeed;           /* Alternative fixed seed for the PRNG */
 };
 
 /*
 ** This macro is used inside of assert() statements to indicate that
 ** the assert is only valid on a well-formed database.  Instead of:
@@ -18464,24 +18602,29 @@
   u8  bLine[100];         /* Draw vertical in column i if bLine[i] is true */
 };
 #endif /* SQLITE_DEBUG */
 
 /*
-** This object is used in various ways, all related to window functions
+** This object is used in various ways, most (but not all) related to window
+** functions.
 **
 **   (1) A single instance of this structure is attached to the
-**       the Expr.pWin field for each window function in an expression tree.
+**       the Expr.y.pWin field for each window function in an expression tree.
 **       This object holds the information contained in the OVER clause,
 **       plus additional fields used during code generation.
 **
 **   (2) All window functions in a single SELECT form a linked-list
 **       attached to Select.pWin.  The Window.pFunc and Window.pExpr
 **       fields point back to the expression that is the window function.
 **
 **   (3) The terms of the WINDOW clause of a SELECT are instances of this
 **       object on a linked list attached to Select.pWinDefn.
 **
+**   (4) For an aggregate function with a FILTER clause, an instance
+**       of this object is stored in Expr.y.pWin with eFrmType set to
+**       TK_FILTER. In this case the only field used is Window.pFilter.
+**
 ** The uses (1) and (2) are really the same Window object that just happens
 ** to be accessible in two different ways.  Use case (3) are separate objects.
 */
 struct Window {
   char *zName;            /* Name of window (may be NULL) */
@@ -18493,33 +18636,38 @@
   u8 eEnd;                /* UNBOUNDED, CURRENT, PRECEDING or FOLLOWING */
   u8 bImplicitFrame;      /* True if frame was implicitly specified */
   u8 eExclude;            /* TK_NO, TK_CURRENT, TK_TIES, TK_GROUP, or 0 */
   Expr *pStart;           /* Expression for "<expr> PRECEDING" */
   Expr *pEnd;             /* Expression for "<expr> FOLLOWING" */
+  Window **ppThis;        /* Pointer to this object in Select.pWin list */
   Window *pNextWin;       /* Next window function belonging to this SELECT */
   Expr *pFilter;          /* The FILTER expression */
   FuncDef *pFunc;         /* The function */
   int iEphCsr;            /* Partition buffer or Peer buffer */
-  int regAccum;
-  int regResult;
+  int regAccum;           /* Accumulator */
+  int regResult;          /* Interim result */
   int csrApp;             /* Function cursor (used by min/max) */
   int regApp;             /* Function register (also used by min/max) */
   int regPart;            /* Array of registers for PARTITION BY values */
   Expr *pOwner;           /* Expression object this window is attached to */
   int nBufferCol;         /* Number of columns in buffer table */
   int iArgCol;            /* Offset of first argument for this function */
   int regOne;             /* Register containing constant value 1 */
   int regStartRowid;
   int regEndRowid;
+  u8 bExprArgs;           /* Defer evaluation of window function arguments
+                          ** due to the SQLITE_SUBTYPE flag */
 };
 
 #ifndef SQLITE_OMIT_WINDOWFUNC
 SQLITE_PRIVATE void sqlite3WindowDelete(sqlite3*, Window*);
+SQLITE_PRIVATE void sqlite3WindowUnlinkFromSelect(Window*);
 SQLITE_PRIVATE void sqlite3WindowListDelete(sqlite3 *db, Window *p);
 SQLITE_PRIVATE Window *sqlite3WindowAlloc(Parse*, int, int, Expr*, int , Expr*, u8);
 SQLITE_PRIVATE void sqlite3WindowAttach(Parse*, Expr*, Window*);
-SQLITE_PRIVATE int sqlite3WindowCompare(Parse*, Window*, Window*);
+SQLITE_PRIVATE void sqlite3WindowLink(Select *pSel, Window *pWin);
+SQLITE_PRIVATE int sqlite3WindowCompare(Parse*, Window*, Window*, int);
 SQLITE_PRIVATE void sqlite3WindowCodeInit(Parse*, Window*);
 SQLITE_PRIVATE void sqlite3WindowCodeStep(Parse*, Select*, WhereInfo*, int, int);
 SQLITE_PRIVATE int sqlite3WindowRewrite(Parse*, Select*);
 SQLITE_PRIVATE int sqlite3ExpandSubquery(Parse*, struct SrcList_item*);
 SQLITE_PRIVATE void sqlite3WindowUpdate(Parse*, Window*, Window*, FuncDef*);
@@ -18715,12 +18863,16 @@
 #else
 # define sqlite3MutexWarnOnContention(x)
 #endif
 
 #ifndef SQLITE_OMIT_FLOATING_POINT
+# define EXP754 (((u64)0x7ff)<<52)
+# define MAN754 ((((u64)1)<<52)-1)
+# define IsNaN(X) (((X)&EXP754)==EXP754 && ((X)&MAN754)!=0)
 SQLITE_PRIVATE   int sqlite3IsNaN(double);
 #else
+# define IsNaN(X)         0
 # define sqlite3IsNaN(X)  0
 #endif
 
 /*
 ** An instance of the following structure holds information about SQL
@@ -18775,17 +18927,19 @@
 SQLITE_PRIVATE Expr *sqlite3ExprAlloc(sqlite3*,int,const Token*,int);
 SQLITE_PRIVATE Expr *sqlite3Expr(sqlite3*,int,const char*);
 SQLITE_PRIVATE void sqlite3ExprAttachSubtrees(sqlite3*,Expr*,Expr*,Expr*);
 SQLITE_PRIVATE Expr *sqlite3PExpr(Parse*, int, Expr*, Expr*);
 SQLITE_PRIVATE void sqlite3PExprAddSelect(Parse*, Expr*, Select*);
-SQLITE_PRIVATE Expr *sqlite3ExprAnd(sqlite3*,Expr*, Expr*);
+SQLITE_PRIVATE Expr *sqlite3ExprAnd(Parse*,Expr*, Expr*);
+SQLITE_PRIVATE Expr *sqlite3ExprSimplifiedAndOr(Expr*);
 SQLITE_PRIVATE Expr *sqlite3ExprFunction(Parse*,ExprList*, Token*, int);
 SQLITE_PRIVATE void sqlite3ExprAssignVarNumber(Parse*, Expr*, u32);
 SQLITE_PRIVATE void sqlite3ExprDelete(sqlite3*, Expr*);
+SQLITE_PRIVATE void sqlite3ExprUnmapAndDelete(Parse*, Expr*);
 SQLITE_PRIVATE ExprList *sqlite3ExprListAppend(Parse*,ExprList*,Expr*);
 SQLITE_PRIVATE ExprList *sqlite3ExprListAppendVector(Parse*,ExprList*,IdList*,Expr*);
-SQLITE_PRIVATE void sqlite3ExprListSetSortOrder(ExprList*,int);
+SQLITE_PRIVATE void sqlite3ExprListSetSortOrder(ExprList*,int,int);
 SQLITE_PRIVATE void sqlite3ExprListSetName(Parse*,ExprList*,Token*,int);
 SQLITE_PRIVATE void sqlite3ExprListSetSpan(Parse*,ExprList*,const char*,const char*);
 SQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3*, ExprList*);
 SQLITE_PRIVATE u32 sqlite3ExprListFlags(const ExprList*);
 SQLITE_PRIVATE int sqlite3IndexHasDuplicateRootPage(Index*);
@@ -18800,12 +18954,12 @@
 SQLITE_PRIVATE void sqlite3ResetOneSchema(sqlite3*,int);
 SQLITE_PRIVATE void sqlite3CollapseDatabaseArray(sqlite3*);
 SQLITE_PRIVATE void sqlite3CommitInternalChanges(sqlite3*);
 SQLITE_PRIVATE void sqlite3DeleteColumnNames(sqlite3*,Table*);
 SQLITE_PRIVATE int sqlite3ColumnsFromExprList(Parse*,ExprList*,i16*,Column**);
-SQLITE_PRIVATE void sqlite3SelectAddColumnTypeAndCollation(Parse*,Table*,Select*);
-SQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse*,Select*);
+SQLITE_PRIVATE void sqlite3SelectAddColumnTypeAndCollation(Parse*,Table*,Select*,char);
+SQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse*,Select*,char);
 SQLITE_PRIVATE void sqlite3OpenMasterTable(Parse *, int);
 SQLITE_PRIVATE Index *sqlite3PrimaryKeyIndex(Table*);
 SQLITE_PRIVATE i16 sqlite3ColumnOfIndex(Index*, i16);
 SQLITE_PRIVATE void sqlite3StartTable(Parse*,Token*,Token*,int,int,int,int);
 #if SQLITE_ENABLE_HIDDEN_COLUMNS
@@ -19087,10 +19241,11 @@
 SQLITE_PRIVATE int sqlite3FixSrcList(DbFixer*, SrcList*);
 SQLITE_PRIVATE int sqlite3FixSelect(DbFixer*, Select*);
 SQLITE_PRIVATE int sqlite3FixExpr(DbFixer*, Expr*);
 SQLITE_PRIVATE int sqlite3FixExprList(DbFixer*, ExprList*);
 SQLITE_PRIVATE int sqlite3FixTriggerStep(DbFixer*, TriggerStep*);
+SQLITE_PRIVATE int sqlite3RealSameAsInt(double,sqlite3_int64);
 SQLITE_PRIVATE int sqlite3AtoF(const char *z, double*, int, u8);
 SQLITE_PRIVATE int sqlite3GetInt32(const char *, int*);
 SQLITE_PRIVATE int sqlite3Atoi(const char*);
 #ifndef SQLITE_OMIT_UTF16
 SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *pData, int nChar);
@@ -19101,11 +19256,11 @@
 SQLITE_PRIVATE LogEst sqlite3LogEstAdd(LogEst,LogEst);
 #ifndef SQLITE_OMIT_VIRTUALTABLE
 SQLITE_PRIVATE LogEst sqlite3LogEstFromDouble(double);
 #endif
 #if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \
-    defined(SQLITE_ENABLE_STAT3_OR_STAT4) || \
+    defined(SQLITE_ENABLE_STAT4) || \
     defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)
 SQLITE_PRIVATE u64 sqlite3LogEstToInt(LogEst);
 #endif
 SQLITE_PRIVATE VList *sqlite3VListAdd(sqlite3*,VList*,const char*,int,int);
 SQLITE_PRIVATE const char *sqlite3VListNumToName(VList*,int);
@@ -19167,13 +19322,14 @@
 SQLITE_PRIVATE CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, Expr *pExpr);
 SQLITE_PRIVATE int sqlite3ExprCollSeqMatch(Parse*,Expr*,Expr*);
 SQLITE_PRIVATE Expr *sqlite3ExprAddCollateToken(Parse *pParse, Expr*, const Token*, int);
 SQLITE_PRIVATE Expr *sqlite3ExprAddCollateString(Parse*,Expr*,const char*);
 SQLITE_PRIVATE Expr *sqlite3ExprSkipCollate(Expr*);
+SQLITE_PRIVATE Expr *sqlite3ExprSkipCollateAndLikely(Expr*);
 SQLITE_PRIVATE int sqlite3CheckCollSeq(Parse *, CollSeq *);
 SQLITE_PRIVATE int sqlite3WritableSchema(sqlite3*);
-SQLITE_PRIVATE int sqlite3CheckObjectName(Parse *, const char *);
+SQLITE_PRIVATE int sqlite3CheckObjectName(Parse*, const char*,const char*,const char*);
 SQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *, int);
 SQLITE_PRIVATE int sqlite3AddInt64(i64*,i64);
 SQLITE_PRIVATE int sqlite3SubInt64(i64*,i64);
 SQLITE_PRIVATE int sqlite3MulInt64(i64*,i64);
 SQLITE_PRIVATE int sqlite3AbsInt32(int);
@@ -19188,10 +19344,13 @@
 SQLITE_PRIVATE int sqlite3ValueBytes(sqlite3_value*, u8);
 SQLITE_PRIVATE void sqlite3ValueSetStr(sqlite3_value*, int, const void *,u8,
                         void(*)(void*));
 SQLITE_PRIVATE void sqlite3ValueSetNull(sqlite3_value*);
 SQLITE_PRIVATE void sqlite3ValueFree(sqlite3_value*);
+#ifndef SQLITE_UNTESTABLE
+SQLITE_PRIVATE void sqlite3ResultIntReal(sqlite3_context*);
+#endif
 SQLITE_PRIVATE sqlite3_value *sqlite3ValueNew(sqlite3 *);
 #ifndef SQLITE_OMIT_UTF16
 SQLITE_PRIVATE char *sqlite3Utf16to8(sqlite3 *, const void*, int, u8);
 #endif
 SQLITE_PRIVATE int sqlite3ValueFromExpr(sqlite3 *, Expr *, u8, u8, sqlite3_value **);
@@ -19199,11 +19358,10 @@
 #ifndef SQLITE_AMALGAMATION
 SQLITE_PRIVATE const unsigned char sqlite3OpcodeProperty[];
 SQLITE_PRIVATE const char sqlite3StrBINARY[];
 SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[];
 SQLITE_PRIVATE const unsigned char sqlite3CtypeMap[];
-SQLITE_PRIVATE const Token sqlite3IntTokens[];
 SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config;
 SQLITE_PRIVATE FuncDefHash sqlite3BuiltinFunctions;
 #ifndef SQLITE_OMIT_WSD
 SQLITE_PRIVATE int sqlite3PendingByte;
 #endif
@@ -19253,10 +19411,11 @@
 SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoAlloc(sqlite3*,int,int);
 SQLITE_PRIVATE void sqlite3KeyInfoUnref(KeyInfo*);
 SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoRef(KeyInfo*);
 SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoOfIndex(Parse*, Index*);
 SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoFromExprList(Parse*, ExprList*, int, int);
+SQLITE_PRIVATE int sqlite3HasExplicitNulls(Parse*, ExprList*);
 
 #ifdef SQLITE_DEBUG
 SQLITE_PRIVATE int sqlite3KeyInfoIsWriteable(KeyInfo*);
 #endif
 SQLITE_PRIVATE int sqlite3CreateFunc(sqlite3 *, const char *, int, int, void *,
@@ -19285,12 +19444,11 @@
 SQLITE_PRIVATE int sqlite3ExprCheckIN(Parse*, Expr*);
 #else
 # define sqlite3ExprCheckIN(x,y) SQLITE_OK
 #endif
 
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
-SQLITE_PRIVATE void sqlite3AnalyzeFunctions(void);
+#ifdef SQLITE_ENABLE_STAT4
 SQLITE_PRIVATE int sqlite3Stat4ProbeSetValue(
     Parse*,Index*,UnpackedRecord**,Expr*,int,int,int*);
 SQLITE_PRIVATE int sqlite3Stat4ValueFromExpr(Parse*, Expr*, u8, sqlite3_value**);
 SQLITE_PRIVATE void sqlite3Stat4ProbeFree(UnpackedRecord*);
 SQLITE_PRIVATE int sqlite3Stat4Column(sqlite3*, const void*, int, int, sqlite3_value**);
@@ -19333,10 +19491,11 @@
 #  define sqlite3VtabRollback(X)
 #  define sqlite3VtabCommit(X)
 #  define sqlite3VtabInSync(db) 0
 #  define sqlite3VtabLock(X)
 #  define sqlite3VtabUnlock(X)
+#  define sqlite3VtabModuleUnref(D,X)
 #  define sqlite3VtabUnlockList(X)
 #  define sqlite3VtabSavepoint(X, Y, Z) SQLITE_OK
 #  define sqlite3GetVTable(X,Y)  ((VTable*)0)
 #else
 SQLITE_PRIVATE    void sqlite3VtabClear(sqlite3 *db, Table*);
@@ -19344,10 +19503,11 @@
 SQLITE_PRIVATE    int sqlite3VtabSync(sqlite3 *db, Vdbe*);
 SQLITE_PRIVATE    int sqlite3VtabRollback(sqlite3 *db);
 SQLITE_PRIVATE    int sqlite3VtabCommit(sqlite3 *db);
 SQLITE_PRIVATE    void sqlite3VtabLock(VTable *);
 SQLITE_PRIVATE    void sqlite3VtabUnlock(VTable *);
+SQLITE_PRIVATE    void sqlite3VtabModuleUnref(sqlite3*,Module*);
 SQLITE_PRIVATE    void sqlite3VtabUnlockList(sqlite3*);
 SQLITE_PRIVATE    int sqlite3VtabSavepoint(sqlite3 *, int, int);
 SQLITE_PRIVATE    void sqlite3VtabImportErrmsg(Vdbe*, sqlite3_vtab*);
 SQLITE_PRIVATE    VTable *sqlite3GetVTable(sqlite3*, Table*);
 SQLITE_PRIVATE    Module *sqlite3VtabCreateModule(
@@ -19750,12 +19910,19 @@
 
 /* EVIDENCE-OF: R-38720-18127 The default setting is determined by the
 ** SQLITE_ALLOW_COVERING_INDEX_SCAN compile-time option, or is "on" if
 ** that compile-time option is omitted.
 */
-#ifndef SQLITE_ALLOW_COVERING_INDEX_SCAN
+#if !defined(SQLITE_ALLOW_COVERING_INDEX_SCAN)
 # define SQLITE_ALLOW_COVERING_INDEX_SCAN 1
+#else
+# if !SQLITE_ALLOW_COVERING_INDEX_SCAN
+#   error "Compile-time disabling of covering index scan using the\
+ -DSQLITE_ALLOW_COVERING_INDEX_SCAN=0 option is deprecated.\
+ Contact SQLite developers if this is a problem for you, and\
+ delete this #error macro to continue with your build."
+# endif
 #endif
 
 /* The minimum PMA size is set to this value multiplied by the database
 ** page size in bytes.
 */
@@ -19804,10 +19971,11 @@
    1,                         /* bCoreMutex */
    SQLITE_THREADSAFE==1,      /* bFullMutex */
    SQLITE_USE_URI,            /* bOpenUri */
    SQLITE_ALLOW_COVERING_INDEX_SCAN,   /* bUseCis */
    0,                         /* bSmallMalloc */
+   1,                         /* bExtraSchemaChecks */
    0x7ffffffe,                /* mxStrlen */
    0,                         /* neverCorrupt */
    SQLITE_DEFAULT_LOOKASIDE,  /* szLookaside, nLookaside */
    SQLITE_STMTJRNL_SPILL,     /* nStmtSpill */
    {0,0,0,0,0,0,0,0},         /* m */
@@ -19850,27 +20018,20 @@
 #endif
    0,                         /* bLocaltimeFault */
    0,                         /* bInternalFunctions */
    0x7ffffffe,                /* iOnceResetThreshold */
    SQLITE_DEFAULT_SORTERREF_SIZE,   /* szSorterRef */
+   0,                         /* iPrngSeed */
 };
 
 /*
 ** Hash table for global functions - functions common to all
 ** database connections.  After initialization, this table is
 ** read-only.
 */
 SQLITE_PRIVATE FuncDefHash sqlite3BuiltinFunctions;
 
-/*
-** Constant tokens for values 0 and 1.
-*/
-SQLITE_PRIVATE const Token sqlite3IntTokens[] = {
-   { "0", 1 },
-   { "1", 1 }
-};
-
 #ifdef VDBE_PROFILE
 /*
 ** The following performance counter can be used in place of
 ** sqlite3Hwtime() for profiling.  This is a no-op on standard builds.
 */
@@ -20178,16 +20339,16 @@
 #define MEM_Null      0x0001   /* Value is NULL (or a pointer) */
 #define MEM_Str       0x0002   /* Value is a string */
 #define MEM_Int       0x0004   /* Value is an integer */
 #define MEM_Real      0x0008   /* Value is a real number */
 #define MEM_Blob      0x0010   /* Value is a BLOB */
-#define MEM_AffMask   0x001f   /* Mask of affinity bits */
-#define MEM_FromBind  0x0020   /* Value originates from sqlite3_bind() */
-/* Available          0x0040   */
+#define MEM_IntReal   0x0020   /* MEM_Int that stringifies like MEM_Real */
+#define MEM_AffMask   0x003f   /* Mask of affinity bits */
+#define MEM_FromBind  0x0040   /* Value originates from sqlite3_bind() */
 #define MEM_Undefined 0x0080   /* Value is undefined */
 #define MEM_Cleared   0x0100   /* NULL set by OP_Null, not from data */
-#define MEM_TypeMask  0xc1df   /* Mask of type bits */
+#define MEM_TypeMask  0xc1bf   /* Mask of type bits */
 
 
 /* Whenever Mem contains a valid string or blob representation, one of
 ** the following flags must be set to determine the memory management
 ** policy for Mem.z.  The MEM_Term flag tells us whether or not the
@@ -20419,11 +20580,10 @@
 void sqliteVdbePopStack(Vdbe*,int);
 SQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor**, int*);
 SQLITE_PRIVATE int sqlite3VdbeCursorRestore(VdbeCursor*);
 SQLITE_PRIVATE u32 sqlite3VdbeSerialTypeLen(u32);
 SQLITE_PRIVATE u8 sqlite3VdbeOneByteSerialTypeLen(u8);
-SQLITE_PRIVATE u32 sqlite3VdbeSerialType(Mem*, int, u32*);
 SQLITE_PRIVATE u32 sqlite3VdbeSerialPut(unsigned char*, Mem*, u32);
 SQLITE_PRIVATE u32 sqlite3VdbeSerialGet(const unsigned char*, u32, Mem*);
 SQLITE_PRIVATE void sqlite3VdbeDeleteAuxData(sqlite3*, AuxData**, int, int);
 
 int sqlite2BtreeKeyCompare(BtCursor *, const void *, int, int, int *);
@@ -21303,11 +21463,11 @@
     return 0;
   }else if( parseHhMmSs(zDate, p)==0 ){
     return 0;
   }else if( sqlite3StrICmp(zDate,"now")==0 && sqlite3NotPureFunc(context) ){
     return setDateTimeToCurrent(context, p);
-  }else if( sqlite3AtoF(zDate, &r, sqlite3Strlen30(zDate), SQLITE_UTF8) ){
+  }else if( sqlite3AtoF(zDate, &r, sqlite3Strlen30(zDate), SQLITE_UTF8)>0 ){
     setRawDateNumber(p, r);
     return 0;
   }
   return 1;
 }
@@ -21637,11 +21797,11 @@
       ** Move the date to the same time on the next occurrence of
       ** weekday N where 0==Sunday, 1==Monday, and so forth.  If the
       ** date is already on the appropriate weekday, this is a no-op.
       */
       if( sqlite3_strnicmp(z, "weekday ", 8)==0
-               && sqlite3AtoF(&z[8], &r, sqlite3Strlen30(&z[8]), SQLITE_UTF8)
+               && sqlite3AtoF(&z[8], &r, sqlite3Strlen30(&z[8]), SQLITE_UTF8)>0
                && (n=(int)r)==r && n>=0 && r<7 ){
         sqlite3_int64 Z;
         computeYMD_HMS(p);
         p->validTZ = 0;
         p->validJD = 0;
@@ -21696,11 +21856,11 @@
     case '8':
     case '9': {
       double rRounder;
       int i;
       for(n=1; z[n] && z[n]!=':' && !sqlite3Isspace(z[n]); n++){}
-      if( !sqlite3AtoF(z, &r, n, SQLITE_UTF8) ){
+      if( sqlite3AtoF(z, &r, n, SQLITE_UTF8)<=0 ){
         rc = 1;
         break;
       }
       if( z[n]==':' ){
         /* A modifier of the form (+|-)HH:MM:SS.FFF adds (or subtracts) the
@@ -22425,11 +22585,19 @@
 SQLITE_PRIVATE void sqlite3OsDlClose(sqlite3_vfs *pVfs, void *pHandle){
   pVfs->xDlClose(pVfs, pHandle);
 }
 #endif /* SQLITE_OMIT_LOAD_EXTENSION */
 SQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){
-  return pVfs->xRandomness(pVfs, nByte, zBufOut);
+  if( sqlite3Config.iPrngSeed ){
+    memset(zBufOut, 0, nByte);
+    if( ALWAYS(nByte>(signed)sizeof(unsigned)) ) nByte = sizeof(unsigned int);
+    memcpy(zBufOut, &sqlite3Config.iPrngSeed, nByte);
+    return SQLITE_OK;
+  }else{
+    return pVfs->xRandomness(pVfs, nByte, zBufOut);
+  }
+
 }
 SQLITE_PRIVATE int sqlite3OsSleep(sqlite3_vfs *pVfs, int nMicro){
   return pVfs->xSleep(pVfs, nMicro);
 }
 SQLITE_PRIVATE int sqlite3OsGetLastError(sqlite3_vfs *pVfs){
@@ -27329,10 +27497,16 @@
   {  'T',  0, 0, etTOKEN,      0,  0 },
   {  'S',  0, 0, etSRCLIST,    0,  0 },
   {  'r', 10, 1, etORDINAL,    0,  0 },
 };
 
+/* Floating point constants used for rounding */
+static const double arRound[] = {
+  5.0e-01, 5.0e-02, 5.0e-03, 5.0e-04, 5.0e-05,
+  5.0e-06, 5.0e-07, 5.0e-08, 5.0e-09, 5.0e-10,
+};
+
 /*
 ** If SQLITE_OMIT_FLOATING_POINT is defined, then none of the floating point
 ** conversions will work.
 */
 #ifndef SQLITE_OMIT_FLOATING_POINT
@@ -27747,12 +27921,22 @@
         }else{
           prefix = flag_prefix;
         }
         if( xtype==etGENERIC && precision>0 ) precision--;
         testcase( precision>0xfff );
-        for(idx=precision&0xfff, rounder=0.5; idx>0; idx--, rounder*=0.1){}
-        if( xtype==etFLOAT ) realvalue += rounder;
+        idx = precision & 0xfff;
+        rounder = arRound[idx%10];
+        while( idx>=10 ){ rounder *= 1.0e-10; idx -= 10; }
+        if( xtype==etFLOAT ){
+          double rx = (double)realvalue;
+          sqlite3_uint64 u;
+          int ex;
+          memcpy(&u, &rx, sizeof(u));
+          ex = -1023 + (int)((u>>52)&0x7ff);
+          if( precision+(ex/3) < 15 ) rounder += realvalue*3e-16;
+          realvalue += rounder;
+        }
         /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */
         exp = 0;
         if( sqlite3IsNaN((double)realvalue) ){
           bufpt = "NaN";
           length = 3;
@@ -28690,17 +28874,21 @@
     sqlite3TreeViewWith(pView, p->pWith, 1);
     cnt = 1;
     sqlite3TreeViewPush(pView, 1);
   }
   do{
-    sqlite3TreeViewLine(pView,
-      "SELECT%s%s (%u/%p) selFlags=0x%x nSelectRow=%d",
-      ((p->selFlags & SF_Distinct) ? " DISTINCT" : ""),
-      ((p->selFlags & SF_Aggregate) ? " agg_flag" : ""),
-      p->selId, p, p->selFlags,
-      (int)p->nSelectRow
-    );
+    if( p->selFlags & SF_WhereBegin ){
+      sqlite3TreeViewLine(pView, "sqlite3WhereBegin()");
+    }else{
+      sqlite3TreeViewLine(pView,
+        "SELECT%s%s (%u/%p) selFlags=0x%x nSelectRow=%d",
+        ((p->selFlags & SF_Distinct) ? " DISTINCT" : ""),
+        ((p->selFlags & SF_Aggregate) ? " agg_flag" : ""),
+        p->selId, p, p->selFlags,
+        (int)p->nSelectRow
+      );
+    }
     if( cnt++ ) sqlite3TreeViewPop(pView);
     if( p->pPrior ){
       n = 1000;
     }else{
       n = 0;
@@ -28713,11 +28901,14 @@
 #ifndef SQLITE_OMIT_WINDOWFUNC
       if( p->pWin ) n++;
       if( p->pWinDefn ) n++;
 #endif
     }
-    sqlite3TreeViewExprList(pView, p->pEList, (n--)>0, "result-set");
+    if( p->pEList ){
+      sqlite3TreeViewExprList(pView, p->pEList, n>0, "result-set");
+    }
+    n--;
 #ifndef SQLITE_OMIT_WINDOWFUNC
     if( p->pWin ){
       Window *pX;
       pView = sqlite3TreeViewPush(pView, (n--)>0);
       sqlite3TreeViewLine(pView, "window-functions");
@@ -28909,16 +29100,18 @@
   if( pExpr==0 ){
     sqlite3TreeViewLine(pView, "nil");
     sqlite3TreeViewPop(pView);
     return;
   }
-  if( pExpr->flags ){
+  if( pExpr->flags || pExpr->affExpr ){
     if( ExprHasProperty(pExpr, EP_FromJoin) ){
-      sqlite3_snprintf(sizeof(zFlgs),zFlgs,"  flags=0x%x iRJT=%d",
-                       pExpr->flags, pExpr->iRightJoinTable);
+      sqlite3_snprintf(sizeof(zFlgs),zFlgs,"  fg.af=%x.%c iRJT=%d",
+                       pExpr->flags, pExpr->affExpr ? pExpr->affExpr : 'n',
+                       pExpr->iRightJoinTable);
     }else{
-      sqlite3_snprintf(sizeof(zFlgs),zFlgs,"  flags=0x%x",pExpr->flags);
+      sqlite3_snprintf(sizeof(zFlgs),zFlgs,"  fg.af=%x.%c",
+                       pExpr->flags, pExpr->affExpr ? pExpr->affExpr : 'n');
     }
   }else{
     zFlgs[0] = 0;
   }
   switch( pExpr->op ){
@@ -29028,11 +29221,11 @@
       const char *azOp[] = {
          "IS-FALSE", "IS-TRUE", "IS-NOT-FALSE", "IS-NOT-TRUE"
       };
       assert( pExpr->op2==TK_IS || pExpr->op2==TK_ISNOT );
       assert( pExpr->pRight );
-      assert( pExpr->pRight->op==TK_TRUEFALSE );
+      assert( sqlite3ExprSkipCollate(pExpr->pRight)->op==TK_TRUEFALSE );
       x = (pExpr->op2==TK_ISNOT)*2 + sqlite3ExprTruthValue(pExpr->pRight);
       zUniOp = azOp[x];
       break;
     }
 
@@ -29041,11 +29234,18 @@
       sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
       break;
     }
 
     case TK_COLLATE: {
-      sqlite3TreeViewLine(pView, "COLLATE %Q", pExpr->u.zToken);
+      /* COLLATE operators without the EP_Collate flag are intended to
+      ** emulate collation associated with a table column.  These show
+      ** up in the treeview output as "SOFT-COLLATE".  Explicit COLLATE
+      ** operators that appear in the original SQL always have the
+      ** EP_Collate bit set and appear in treeview output as just "COLLATE" */
+      sqlite3TreeViewLine(pView, "%sCOLLATE %Q%s",
+        !ExprHasProperty(pExpr, EP_Collate) ? "SOFT-" : "",
+        pExpr->u.zToken, zFlgs);
       sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
       break;
     }
 
     case TK_AGG_FUNCTION:
@@ -29062,14 +29262,14 @@
 #else
         pWin = 0;
 #endif
       }
       if( pExpr->op==TK_AGG_FUNCTION ){
-        sqlite3TreeViewLine(pView, "AGG_FUNCTION%d %Q",
-                             pExpr->op2, pExpr->u.zToken);
+        sqlite3TreeViewLine(pView, "AGG_FUNCTION%d %Q%s",
+                             pExpr->op2, pExpr->u.zToken, zFlgs);
       }else{
-        sqlite3TreeViewLine(pView, "FUNCTION %Q", pExpr->u.zToken);
+        sqlite3TreeViewLine(pView, "FUNCTION %Q%s", pExpr->u.zToken, zFlgs);
       }
       if( pFarg ){
         sqlite3TreeViewExprList(pView, pFarg, pWin!=0, 0);
       }
 #ifndef SQLITE_OMIT_WINDOWFUNC
@@ -29142,11 +29342,11 @@
       break;
     }
 #ifndef SQLITE_OMIT_TRIGGER
     case TK_RAISE: {
       const char *zType = "unk";
-      switch( pExpr->affinity ){
+      switch( pExpr->affExpr ){
         case OE_Rollback:   zType = "rollback";  break;
         case OE_Abort:      zType = "abort";     break;
         case OE_Fail:       zType = "fail";      break;
         case OE_Ignore:     zType = "ignore";    break;
       }
@@ -29183,11 +29383,11 @@
     sqlite3TreeViewLine(pView, "%s%s", zBinOp, zFlgs);
     sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);
     sqlite3TreeViewExpr(pView, pExpr->pRight, 0);
   }else if( zUniOp ){
     sqlite3TreeViewLine(pView, "%s%s", zUniOp, zFlgs);
-    sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
+   sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
   }
   sqlite3TreeViewPop(pView);
 }
 
 
@@ -30210,13 +30410,11 @@
 ** strings, and stuff like that.
 **
 */
 /* #include "sqliteInt.h" */
 /* #include <stdarg.h> */
-#if HAVE_ISNAN || SQLITE_HAVE_ISNAN
-# include <math.h>
-#endif
+#include <math.h>
 
 /*
 ** Routine needed to support the testcase() macro.
 */
 #ifdef SQLITE_COVERAGE_TEST
@@ -30253,51 +30451,15 @@
 #endif
 
 #ifndef SQLITE_OMIT_FLOATING_POINT
 /*
 ** Return true if the floating point value is Not a Number (NaN).
-**
-** Use the math library isnan() function if compiled with SQLITE_HAVE_ISNAN.
-** Otherwise, we have our own implementation that works on most systems.
 */
 SQLITE_PRIVATE int sqlite3IsNaN(double x){
-  int rc;   /* The value return */
-#if !SQLITE_HAVE_ISNAN && !HAVE_ISNAN
-  /*
-  ** Systems that support the isnan() library function should probably
-  ** make use of it by compiling with -DSQLITE_HAVE_ISNAN.  But we have
-  ** found that many systems do not have a working isnan() function so
-  ** this implementation is provided as an alternative.
-  **
-  ** This NaN test sometimes fails if compiled on GCC with -ffast-math.
-  ** On the other hand, the use of -ffast-math comes with the following
-  ** warning:
-  **
-  **      This option [-ffast-math] should never be turned on by any
-  **      -O option since it can result in incorrect output for programs
-  **      which depend on an exact implementation of IEEE or ISO
-  **      rules/specifications for math functions.
-  **
-  ** Under MSVC, this NaN test may fail if compiled with a floating-
-  ** point precision mode other than /fp:precise.  From the MSDN
-  ** documentation:
-  **
-  **      The compiler [with /fp:precise] will properly handle comparisons
-  **      involving NaN. For example, x != x evaluates to true if x is NaN
-  **      ...
-  */
-#ifdef __FAST_MATH__
-# error SQLite will not work correctly with the -ffast-math option of GCC.
-#endif
-  volatile double y = x;
-  volatile double z = y;
-  rc = (y!=z);
-#else  /* if HAVE_ISNAN */
-  rc = isnan(x);
-#endif /* HAVE_ISNAN */
-  testcase( rc );
-  return rc;
+  u64 y;
+  memcpy(&y,&x,sizeof(y));
+  return IsNaN(y);
 }
 #endif /* SQLITE_OMIT_FLOATING_POINT */
 
 /*
 ** Compute a string length that is limited to what can be stored in
@@ -30515,16 +30677,22 @@
   }
   return sqlite3StrICmp(zLeft, zRight);
 }
 SQLITE_PRIVATE int sqlite3StrICmp(const char *zLeft, const char *zRight){
   unsigned char *a, *b;
-  int c;
+  int c, x;
   a = (unsigned char *)zLeft;
   b = (unsigned char *)zRight;
   for(;;){
-    c = (int)UpperToLower[*a] - (int)UpperToLower[*b];
-    if( c || *a==0 ) break;
+    c = *a;
+    x = *b;
+    if( c==x ){
+      if( c==0 ) break;
+    }else{
+      c = (int)UpperToLower[c] - (int)UpperToLower[x];
+      if( c ) break;
+    }
     a++;
     b++;
   }
   return c;
 }
@@ -30548,19 +30716,19 @@
 ** This routine only works for values of E between 1 and 341.
 */
 static LONGDOUBLE_TYPE sqlite3Pow10(int E){
 #if defined(_MSC_VER)
   static const LONGDOUBLE_TYPE x[] = {
-    1.0e+001,
-    1.0e+002,
-    1.0e+004,
-    1.0e+008,
-    1.0e+016,
-    1.0e+032,
-    1.0e+064,
-    1.0e+128,
-    1.0e+256
+    1.0e+001L,
+    1.0e+002L,
+    1.0e+004L,
+    1.0e+008L,
+    1.0e+016L,
+    1.0e+032L,
+    1.0e+064L,
+    1.0e+128L,
+    1.0e+256L
   };
   LONGDOUBLE_TYPE r = 1.0;
   int i;
   assert( E>=0 && E<=307 );
   for(i=0; E!=0; i++, E >>=1){
@@ -30586,12 +30754,19 @@
 **
 ** The string z[] is length bytes in length (bytes, not characters) and
 ** uses the encoding enc.  The string is not necessarily zero-terminated.
 **
 ** Return TRUE if the result is a valid real number (or integer) and FALSE
-** if the string is empty or contains extraneous text.  Valid numbers
-** are in one of these formats:
+** if the string is empty or contains extraneous text.  More specifically
+** return
+**      1          =>  The input string is a pure integer
+**      2 or more  =>  The input has a decimal point or eNNN clause
+**      0 or less  =>  The input string is not a valid number
+**     -1          =>  Not a valid number, but has a valid prefix which
+**                     includes a decimal point and/or an eNNN clause
+**
+** Valid numbers are in one of these formats:
 **
 **    [+-]digits[E[+-]digits]
 **    [+-]digits.[digits][E[+-]digits]
 **    [+-].digits[E[+-]digits]
 **
@@ -30612,24 +30787,26 @@
   int d = 0;       /* adjust exponent for shifting decimal point */
   int esign = 1;   /* sign of exponent */
   int e = 0;       /* exponent */
   int eValid = 1;  /* True exponent is either not used or is well-formed */
   double result;
-  int nDigits = 0;
-  int nonNum = 0;  /* True if input contains UTF16 with high byte non-zero */
+  int nDigit = 0;  /* Number of digits processed */
+  int eType = 1;   /* 1: pure integer,  2+: fractional  -1 or less: bad UTF16 */
 
   assert( enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE );
   *pResult = 0.0;   /* Default return value, in case of an error */
 
   if( enc==SQLITE_UTF8 ){
     incr = 1;
   }else{
     int i;
     incr = 2;
     assert( SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 );
+    testcase( enc==SQLITE_UTF16LE );
+    testcase( enc==SQLITE_UTF16BE );
     for(i=3-enc; i<length && z[i]==0; i+=2){}
-    nonNum = i<length;
+    if( i<length ) eType = -100;
     zEnd = &z[i^1];
     z += (enc&1);
   }
 
   /* skip leading spaces */
@@ -30643,39 +30820,43 @@
   }else if( *z=='+' ){
     z+=incr;
   }
 
   /* copy max significant digits to significand */
-  while( z<zEnd && sqlite3Isdigit(*z) && s<((LARGEST_INT64-9)/10) ){
+  while( z<zEnd && sqlite3Isdigit(*z) ){
     s = s*10 + (*z - '0');
-    z+=incr; nDigits++;
+    z+=incr; nDigit++;
+    if( s>=((LARGEST_INT64-9)/10) ){
+      /* skip non-significant significand digits
+      ** (increase exponent by d to shift decimal left) */
+      while( z<zEnd && sqlite3Isdigit(*z) ){ z+=incr; d++; }
+    }
   }
-
-  /* skip non-significant significand digits
-  ** (increase exponent by d to shift decimal left) */
-  while( z<zEnd && sqlite3Isdigit(*z) ){ z+=incr; nDigits++; d++; }
   if( z>=zEnd ) goto do_atof_calc;
 
   /* if decimal point is present */
   if( *z=='.' ){
     z+=incr;
+    eType++;
     /* copy digits from after decimal to significand
     ** (decrease exponent by d to shift decimal right) */
     while( z<zEnd && sqlite3Isdigit(*z) ){
       if( s<((LARGEST_INT64-9)/10) ){
         s = s*10 + (*z - '0');
         d--;
+        nDigit++;
       }
-      z+=incr; nDigits++;
+      z+=incr;
     }
   }
   if( z>=zEnd ) goto do_atof_calc;
 
   /* if exponent is present */
   if( *z=='e' || *z=='E' ){
     z+=incr;
     eValid = 0;
+    eType++;
 
     /* This branch is needed to avoid a (harmless) buffer overread.  The
     ** special comment alerts the mutation tester that the correct answer
     ** is obtained even if the branch is omitted */
     if( z>=zEnd ) goto do_atof_calc;              /*PREVENTS-HARMLESS-OVERREAD*/
@@ -30770,11 +30951,17 @@
 
   /* store the result */
   *pResult = result;
 
   /* return true if number and no extra non-whitespace chracters after */
-  return z==zEnd && nDigits>0 && eValid && nonNum==0;
+  if( z==zEnd && nDigit>0 && eValid && eType>0 ){
+    return eType;
+  }else if( eType>=2 && (eType==3 || eValid) && nDigit>0 ){
+    return -1;
+  }else{
+    return 0;
+  }
 #else
   return !sqlite3Atoi64(z, pResult, length, enc);
 #endif /* SQLITE_OMIT_FLOATING_POINT */
 }
 
@@ -30813,10 +31000,11 @@
 ** Convert zNum to a 64-bit signed integer.  zNum must be decimal. This
 ** routine does *not* accept hexadecimal notation.
 **
 ** Returns:
 **
+**    -1    Not even a prefix of the input text looks like an integer
 **     0    Successful transformation.  Fits in a 64-bit signed integer.
 **     1    Excess non-space text after the integer value
 **     2    Integer too large for a 64-bit signed integer or is malformed
 **     3    Special case of 9223372036854775808
 **
@@ -30872,13 +31060,13 @@
     *pNum = -(i64)u;
   }else{
     *pNum = (i64)u;
   }
   rc = 0;
-  if( (i==0 && zStart==zNum)     /* No digits */
-   || nonNum                     /* UTF16 with high-order bytes non-zero */
-  ){
+  if( i==0 && zStart==zNum ){    /* No digits */
+    rc = -1;
+  }else if( nonNum ){            /* UTF16 with high-order bytes non-zero */
     rc = 1;
   }else if( &zNum[i]<zEnd ){     /* Extra bytes at the end */
     int jj = i;
     do{
       if( !sqlite3Isspace(zNum[jj]) ){
@@ -31105,36 +31293,26 @@
 ** Return the number of bytes read.  The value is stored in *v.
 */
 SQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *p, u64 *v){
   u32 a,b,s;
 
-  a = *p;
-  /* a: p0 (unmasked) */
-  if (!(a&0x80))
-  {
-    *v = a;
+  if( ((signed char*)p)[0]>=0 ){
+    *v = *p;
     return 1;
   }
-
-  p++;
-  b = *p;
-  /* b: p1 (unmasked) */
-  if (!(b&0x80))
-  {
-    a &= 0x7f;
-    a = a<<7;
-    a |= b;
-    *v = a;
+  if( ((signed char*)p)[1]>=0 ){
+    *v = ((u32)(p[0]&0x7f)<<7) | p[1];
     return 2;
   }
 
   /* Verify that constants are precomputed correctly */
   assert( SLOT_2_0 == ((0x7f<<14) | (0x7f)) );
   assert( SLOT_4_2_0 == ((0xfU<<28) | (0x7f<<14) | (0x7f)) );
 
-  p++;
-  a = a<<14;
+  a = ((u32)p[0])<<14;
+  b = p[1];
+  p += 2;
   a |= *p;
   /* a: p0<<14 | p2 (unmasked) */
   if (!(a&0x80))
   {
     a &= SLOT_2_0;
@@ -31713,11 +31891,11 @@
   return e*10;
 }
 #endif /* SQLITE_OMIT_VIRTUALTABLE */
 
 #if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \
-    defined(SQLITE_ENABLE_STAT3_OR_STAT4) || \
+    defined(SQLITE_ENABLE_STAT4) || \
     defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)
 /*
 ** Convert a LogEst into an integer.
 **
 ** Note that this routine is only used when one or more of various
@@ -31731,11 +31909,11 @@
   else if( n>=1 ) n -= 1;
 #if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \
     defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)
   if( x>60 ) return (u64)LARGEST_INT64;
 #else
-  /* If only SQLITE_ENABLE_STAT3_OR_STAT4 is on, then the largest input
+  /* If only SQLITE_ENABLE_STAT4 is on, then the largest input
   ** possible to this routine is 310, resulting in a maximum x of 31 */
   assert( x<=60 );
 #endif
   return x>=3 ? (n+8)<<(x-3) : (n+8)>>(3-x);
 }
@@ -32224,28 +32402,28 @@
     /*  91 */ "Affinity"         OpHelp("affinity(r[P1@P2])"),
     /*  92 */ "MakeRecord"       OpHelp("r[P3]=mkrec(r[P1@P2])"),
     /*  93 */ "Count"            OpHelp("r[P2]=count()"),
     /*  94 */ "ReadCookie"       OpHelp(""),
     /*  95 */ "SetCookie"        OpHelp(""),
-    /*  96 */ "BitAnd"           OpHelp("r[P3]=r[P1]&r[P2]"),
-    /*  97 */ "BitOr"            OpHelp("r[P3]=r[P1]|r[P2]"),
-    /*  98 */ "ShiftLeft"        OpHelp("r[P3]=r[P2]<<r[P1]"),
-    /*  99 */ "ShiftRight"       OpHelp("r[P3]=r[P2]>>r[P1]"),
-    /* 100 */ "Add"              OpHelp("r[P3]=r[P1]+r[P2]"),
-    /* 101 */ "Subtract"         OpHelp("r[P3]=r[P2]-r[P1]"),
-    /* 102 */ "Multiply"         OpHelp("r[P3]=r[P1]*r[P2]"),
-    /* 103 */ "Divide"           OpHelp("r[P3]=r[P2]/r[P1]"),
-    /* 104 */ "Remainder"        OpHelp("r[P3]=r[P2]%r[P1]"),
-    /* 105 */ "Concat"           OpHelp("r[P3]=r[P2]+r[P1]"),
-    /* 106 */ "ReopenIdx"        OpHelp("root=P2 iDb=P3"),
-    /* 107 */ "BitNot"           OpHelp("r[P2]= ~r[P1]"),
-    /* 108 */ "OpenRead"         OpHelp("root=P2 iDb=P3"),
-    /* 109 */ "OpenWrite"        OpHelp("root=P2 iDb=P3"),
-    /* 110 */ "String8"          OpHelp("r[P2]='P4'"),
-    /* 111 */ "OpenDup"          OpHelp(""),
-    /* 112 */ "OpenAutoindex"    OpHelp("nColumn=P2"),
-    /* 113 */ "OpenEphemeral"    OpHelp("nColumn=P2"),
+    /*  96 */ "ReopenIdx"        OpHelp("root=P2 iDb=P3"),
+    /*  97 */ "OpenRead"         OpHelp("root=P2 iDb=P3"),
+    /*  98 */ "OpenWrite"        OpHelp("root=P2 iDb=P3"),
+    /*  99 */ "BitAnd"           OpHelp("r[P3]=r[P1]&r[P2]"),
+    /* 100 */ "BitOr"            OpHelp("r[P3]=r[P1]|r[P2]"),
+    /* 101 */ "ShiftLeft"        OpHelp("r[P3]=r[P2]<<r[P1]"),
+    /* 102 */ "ShiftRight"       OpHelp("r[P3]=r[P2]>>r[P1]"),
+    /* 103 */ "Add"              OpHelp("r[P3]=r[P1]+r[P2]"),
+    /* 104 */ "Subtract"         OpHelp("r[P3]=r[P2]-r[P1]"),
+    /* 105 */ "Multiply"         OpHelp("r[P3]=r[P1]*r[P2]"),
+    /* 106 */ "Divide"           OpHelp("r[P3]=r[P2]/r[P1]"),
+    /* 107 */ "Remainder"        OpHelp("r[P3]=r[P2]%r[P1]"),
+    /* 108 */ "Concat"           OpHelp("r[P3]=r[P2]+r[P1]"),
+    /* 109 */ "OpenDup"          OpHelp(""),
+    /* 110 */ "BitNot"           OpHelp("r[P2]= ~r[P1]"),
+    /* 111 */ "OpenAutoindex"    OpHelp("nColumn=P2"),
+    /* 112 */ "OpenEphemeral"    OpHelp("nColumn=P2"),
+    /* 113 */ "String8"          OpHelp("r[P2]='P4'"),
     /* 114 */ "SorterOpen"       OpHelp(""),
     /* 115 */ "SequenceTest"     OpHelp("if( cursor[P1].ctr++ ) pc = P2"),
     /* 116 */ "OpenPseudo"       OpHelp("P3 columns in r[P2]"),
     /* 117 */ "Close"            OpHelp(""),
     /* 118 */ "ColumnsUsed"      OpHelp(""),
@@ -32273,14 +32451,14 @@
     /* 140 */ "SqlExec"          OpHelp(""),
     /* 141 */ "ParseSchema"      OpHelp(""),
     /* 142 */ "LoadAnalysis"     OpHelp(""),
     /* 143 */ "DropTable"        OpHelp(""),
     /* 144 */ "DropIndex"        OpHelp(""),
-    /* 145 */ "Real"             OpHelp("r[P2]=P4"),
-    /* 146 */ "DropTrigger"      OpHelp(""),
-    /* 147 */ "IntegrityCk"      OpHelp(""),
-    /* 148 */ "RowSetAdd"        OpHelp("rowset(P1)=r[P2]"),
+    /* 145 */ "DropTrigger"      OpHelp(""),
+    /* 146 */ "IntegrityCk"      OpHelp(""),
+    /* 147 */ "RowSetAdd"        OpHelp("rowset(P1)=r[P2]"),
+    /* 148 */ "Real"             OpHelp("r[P2]=P4"),
     /* 149 */ "Param"            OpHelp(""),
     /* 150 */ "FkCounter"        OpHelp("fkctr[P1]+=P2"),
     /* 151 */ "MemMax"           OpHelp("r[P1]=max(r[P1],r[P2])"),
     /* 152 */ "OffsetLimit"      OpHelp("if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1)"),
     /* 153 */ "AggInverse"       OpHelp("accum=r[P3] inverse(r[P2@P5])"),
@@ -32415,17 +32593,33 @@
 /* # include <sys/ioctl.h> */
 # include <sys/file.h>
 # include <sys/param.h>
 #endif /* SQLITE_ENABLE_LOCKING_STYLE */
 
-#if defined(__APPLE__) && ((__MAC_OS_X_VERSION_MIN_REQUIRED > 1050) || \
-                           (__IPHONE_OS_VERSION_MIN_REQUIRED > 2000))
-#  if (!defined(TARGET_OS_EMBEDDED) || (TARGET_OS_EMBEDDED==0)) \
-       && (!defined(TARGET_IPHONE_SIMULATOR) || (TARGET_IPHONE_SIMULATOR==0))
-#    define HAVE_GETHOSTUUID 1
-#  else
-#    warning "gethostuuid() is disabled."
+/*
+** Try to determine if gethostuuid() is available based on standard
+** macros.  This might sometimes compute the wrong value for some
+** obscure platforms.  For those cases, simply compile with one of
+** the following:
+**
+**    -DHAVE_GETHOSTUUID=0
+**    -DHAVE_GETHOSTUUID=1
+**
+** None if this matters except when building on Apple products with
+** -DSQLITE_ENABLE_LOCKING_STYLE.
+*/
+#ifndef HAVE_GETHOSTUUID
+# define HAVE_GETHOSTUUID 0
+# if defined(__APPLE__) && ((__MAC_OS_X_VERSION_MIN_REQUIRED > 1050) || \
+                            (__IPHONE_OS_VERSION_MIN_REQUIRED > 2000))
+#    if (!defined(TARGET_OS_EMBEDDED) || (TARGET_OS_EMBEDDED==0)) \
+         && (!defined(TARGET_IPHONE_SIMULATOR) || (TARGET_IPHONE_SIMULATOR==0))
+#      undef HAVE_GETHOSTUUID
+#      define HAVE_GETHOSTUUID 1
+#    else
+#      warning "gethostuuid() is disabled."
+#    endif
 #  endif
 #endif
 
 
 #if OS_VXWORKS
@@ -33029,17 +33223,18 @@
 #define osLstat      ((int(*)(const char*,struct stat*))aSyscall[27].pCurrent)
 
 #if defined(__linux__) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)
 # ifdef __ANDROID__
   { "ioctl", (sqlite3_syscall_ptr)(int(*)(int, int, ...))ioctl, 0 },
+#define osIoctl ((int(*)(int,int,...))aSyscall[28].pCurrent)
 # else
   { "ioctl",         (sqlite3_syscall_ptr)ioctl,          0 },
+#define osIoctl ((int(*)(int,unsigned long,...))aSyscall[28].pCurrent)
 # endif
 #else
   { "ioctl",         (sqlite3_syscall_ptr)0,              0 },
 #endif
-#define osIoctl ((int(*)(int,int,...))aSyscall[28].pCurrent)
 
 }; /* End of the overrideable system calls */
 
 
 /*
@@ -38277,10 +38472,11 @@
     }
     if( pInode ){
       UnixUnusedFd **pp;
       assert( sqlite3_mutex_notheld(pInode->pLockMutex) );
       sqlite3_mutex_enter(pInode->pLockMutex);
+      flags &= (SQLITE_OPEN_READONLY|SQLITE_OPEN_READWRITE);
       for(pp=&pInode->pUnused; *pp && (*pp)->flags!=flags; pp=&((*pp)->pNext));
       pUnused = *pp;
       if( pUnused ){
         *pp = pUnused->pNext;
       }
@@ -38330,11 +38526,11 @@
 ** as the associated database file.
 **
 ** If the SQLITE_ENABLE_8_3_NAMES option is enabled, then the
 ** original filename is unavailable.  But 8_3_NAMES is only used for
 ** FAT filesystems and permissions do not matter there, so just use
-** the default permissions.
+** the default permissions.  In 8_3_NAMES mode, leave *pMode set to zero.
 */
 static int findCreateFileMode(
   const char *zPath,              /* Path of file (possibly) being created */
   int flags,                      /* Flags passed as 4th argument to xOpen() */
   mode_t *pMode,                  /* OUT: Permissions to open file with */
@@ -38565,26 +38761,35 @@
       int rc2 = unixLogError(SQLITE_CANTOPEN_BKPT, "open", zName);
       if( rc==SQLITE_OK ) rc = rc2;
       goto open_finished;
     }
 
-    /* If this process is running as root and if creating a new rollback
-    ** journal or WAL file, set the ownership of the journal or WAL to be
-    ** the same as the original database.
+    /* The owner of the rollback journal or WAL file should always be the
+    ** same as the owner of the database file.  Try to ensure that this is
+    ** the case.  The chown() system call will be a no-op if the current
+    ** process lacks root privileges, be we should at least try.  Without
+    ** this step, if a root process opens a database file, it can leave
+    ** behinds a journal/WAL that is owned by root and hence make the
+    ** database inaccessible to unprivileged processes.
+    **
+    ** If openMode==0, then that means uid and gid are not set correctly
+    ** (probably because SQLite is configured to use 8+3 filename mode) and
+    ** in that case we do not want to attempt the chown().
     */
-    if( flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL) ){
+    if( openMode && (flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL))!=0 ){
       robustFchown(fd, uid, gid);
     }
   }
   assert( fd>=0 );
   if( pOutFlags ){
     *pOutFlags = flags;
   }
 
   if( p->pPreallocatedUnused ){
     p->pPreallocatedUnused->fd = fd;
-    p->pPreallocatedUnused->flags = flags;
+    p->pPreallocatedUnused->flags =
+                          flags & (SQLITE_OPEN_READONLY|SQLITE_OPEN_READWRITE);
   }
 
   if( isDelete ){
 #if OS_VXWORKS
     zPath = zName;
@@ -39426,22 +39631,22 @@
 SQLITE_API int sqlite3_hostid_num = 0;
 #endif
 
 #define PROXY_HOSTIDLEN    16  /* conch file host id length */
 
-#ifdef HAVE_GETHOSTUUID
+#if HAVE_GETHOSTUUID
 /* Not always defined in the headers as it ought to be */
 extern int gethostuuid(uuid_t id, const struct timespec *wait);
 #endif
 
 /* get the host ID via gethostuuid(), pHostID must point to PROXY_HOSTIDLEN
 ** bytes of writable memory.
 */
 static int proxyGetHostID(unsigned char *pHostID, int *pError){
   assert(PROXY_HOSTIDLEN == sizeof(uuid_t));
   memset(pHostID, 0, PROXY_HOSTIDLEN);
-#ifdef HAVE_GETHOSTUUID
+#if HAVE_GETHOSTUUID
   {
     struct timespec timeout = {1, 0}; /* 1 sec timeout */
     if( gethostuuid(pHostID, &timeout) ){
       int err = errno;
       if( pError ){
@@ -40111,11 +40316,11 @@
     }
     default: {
       assert( 0 );  /* The call assures that only valid opcodes are sent */
     }
   }
-  /*NOTREACHED*/
+  /*NOTREACHED*/ assert(0);
   return SQLITE_ERROR;
 }
 
 /*
 ** Within this division (the proxying locking implementation) the procedures
@@ -44796,10 +45001,11 @@
 
   if( !pShm ){
     rc = winOpenSharedMemory(pDbFd);
     if( rc!=SQLITE_OK ) return rc;
     pShm = pDbFd->pShm;
+    assert( pShm!=0 );
   }
   pShmNode = pShm->pShmNode;
 
   sqlite3_mutex_enter(pShmNode->mutex);
   if( pShmNode->isUnlocked ){
@@ -45098,10 +45304,11 @@
                  osGetCurrentProcessId(), pFd, sqlite3ErrName(rc)));
         return rc;
       }
     }
     if( pFd->mmapSize >= iOff+nAmt ){
+      assert( pFd->pMapRegion!=0 );
       *pp = &((u8 *)pFd->pMapRegion)[iOff];
       pFd->nFetchOut++;
     }
   }
 #endif
@@ -48000,13 +48207,14 @@
   if( p->szCache>=0 ){
     /* IMPLEMENTATION-OF: R-42059-47211 If the argument N is positive then the
     ** suggested cache size is set to N. */
     return p->szCache;
   }else{
-    /* IMPLEMENTATION-OF: R-61436-13639 If the argument N is negative, then
-    ** the number of cache pages is adjusted to use approximately abs(N*1024)
-    ** bytes of memory. */
+    /* IMPLEMANTATION-OF: R-59858-46238 If the argument N is negative, then the
+    ** number of cache pages is adjusted to be a number of pages that would
+    ** use approximately abs(N*1024) bytes of memory based on the current
+    ** page size. */
     return (int)((-1024*(i64)p->szCache)/(p->szPage+p->szExtra));
   }
 }
 
 /*************************************************** General Interfaces ******
@@ -48018,10 +48226,11 @@
   if( sqlite3GlobalConfig.pcache2.xInit==0 ){
     /* IMPLEMENTATION-OF: R-26801-64137 If the xInit() method is NULL, then the
     ** built-in default page cache is used instead of the application defined
     ** page cache. */
     sqlite3PCacheSetDefault();
+    assert( sqlite3GlobalConfig.pcache2.xInit!=0 );
   }
   return sqlite3GlobalConfig.pcache2.xInit(sqlite3GlobalConfig.pcache2.pArg);
 }
 SQLITE_PRIVATE void sqlite3PcacheShutdown(void){
   if( sqlite3GlobalConfig.pcache2.xShutdown ){
@@ -49064,10 +49273,11 @@
   PgHdr1 *p = 0;
   void *pPg;
 
   assert( sqlite3_mutex_held(pCache->pGroup->mutex) );
   if( pCache->pFree || (pCache->nPage==0 && pcache1InitBulk(pCache)) ){
+    assert( pCache->pFree!=0 );
     p = pCache->pFree;
     pCache->pFree = p->pNext;
     p->pNext = 0;
   }else{
 #ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
@@ -49418,20 +49628,20 @@
       pGroup = (PGroup*)&pCache[1];
       pGroup->mxPinned = 10;
     }else{
       pGroup = &pcache1.grp;
     }
+    pcache1EnterMutex(pGroup);
     if( pGroup->lru.isAnchor==0 ){
       pGroup->lru.isAnchor = 1;
       pGroup->lru.pLruPrev = pGroup->lru.pLruNext = &pGroup->lru;
     }
     pCache->pGroup = pGroup;
     pCache->szPage = szPage;
     pCache->szExtra = szExtra;
     pCache->szAlloc = szPage + szExtra + ROUND8(sizeof(PgHdr1));
     pCache->bPurgeable = (bPurgeable ? 1 : 0);
-    pcache1EnterMutex(pGroup);
     pcache1ResizeHash(pCache);
     if( bPurgeable ){
       pCache->nMin = 10;
       pGroup->nMinPage += pCache->nMin;
       pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;
@@ -61220,13 +61430,13 @@
     if( rc!=SQLITE_OK ){
       return rc;
     }
     nCollide = HASHTABLE_NSLOT;
     for(iKey=walHash(pgno); sLoc.aHash[iKey]; iKey=walNextHash(iKey)){
-      u32 iFrame = sLoc.aHash[iKey] + sLoc.iZero;
-      if( iFrame<=iLast && iFrame>=pWal->minFrame
-       && sLoc.aPgno[sLoc.aHash[iKey]]==pgno ){
+      u32 iH = sLoc.aHash[iKey];
+      u32 iFrame = iH + sLoc.iZero;
+      if( iFrame<=iLast && iFrame>=pWal->minFrame && sLoc.aPgno[iH]==pgno ){
         assert( iFrame>iRead || CORRUPT_DB );
         iRead = iFrame;
       }
       if( (nCollide--)==0 ){
         return SQLITE_CORRUPT_BKPT;
@@ -61790,10 +62000,11 @@
       while( iOffset<w.iSyncPoint ){
         rc = walWriteOneFrame(&w, pLast, nTruncate, iOffset);
         if( rc ) return rc;
         iOffset += szFrame;
         nExtra++;
+        assert( pLast!=0 );
       }
     }
     if( bSync ){
       assert( rc==SQLITE_OK );
       rc = sqlite3OsSync(w.pFd, WAL_SYNC_FLAGS(sync_flags));
@@ -61822,10 +62033,11 @@
   for(p=pList; p && rc==SQLITE_OK; p=p->pDirty){
     if( (p->flags & PGHDR_WAL_APPEND)==0 ) continue;
     iFrame++;
     rc = walIndexAppend(pWal, iFrame, p->pgno);
   }
+  assert( pLast!=0 || nExtra==0 );
   while( rc==SQLITE_OK && nExtra>0 ){
     iFrame++;
     nExtra--;
     rc = walIndexAppend(pWal, iFrame, pLast->pgno);
   }
@@ -64814,11 +65026,11 @@
   ** and the reserved space is zero (the usual value for reserved space)
   ** then the cell content offset of an empty page wants to be 65536.
   ** However, that integer is too large to be stored in a 2-byte unsigned
   ** integer, so a value of 0 is used in its place. */
   top = get2byte(&data[hdr+5]);
-  assert( top<=(int)pPage->pBt->usableSize ); /* Prevent by getAndInitPage() */
+  assert( top<=(int)pPage->pBt->usableSize ); /* by btreeComputeFreeSpace() */
   if( gap>top ){
     if( top==0 && pPage->pBt->usableSize==65536 ){
       top = 65536;
     }else{
       return SQLITE_CORRUPT_PAGE(pPage);
@@ -64833,13 +65045,16 @@
   testcase( gap+1==top );
   testcase( gap==top );
   if( (data[hdr+2] || data[hdr+1]) && gap+2<=top ){
     u8 *pSpace = pageFindSlot(pPage, nByte, &rc);
     if( pSpace ){
-      assert( pSpace>=data && (pSpace - data)<65536 );
-      *pIdx = (int)(pSpace - data);
-      return SQLITE_OK;
+      assert( pSpace+nByte<=data+pPage->pBt->usableSize );
+      if( (*pIdx = (int)(pSpace-data))<=gap ){
+        return SQLITE_CORRUPT_PAGE(pPage);
+      }else{
+        return SQLITE_OK;
+      }
     }else if( rc ){
       return rc;
     }
   }
 
@@ -65111,11 +65326,11 @@
   ** the cell-content area. If this is greater than the usable-size
   ** of the page, then the page must be corrupted. This check also
   ** serves to verify that the offset to the start of the cell-content
   ** area, according to the page header, lies within the page.
   */
-  if( nFree>usableSize ){
+  if( nFree>usableSize || nFree<iCellFirst ){
     return SQLITE_CORRUPT_PAGE(pPage);
   }
   pPage->nFree = (u16)(nFree - iCellFirst);
   return SQLITE_OK;
 }
@@ -67339,10 +67554,22 @@
     sqlite3BtreeLeave(pBtree);
   }
   return rc;
 }
 
+/*
+** Set the pBt->nPage field correctly, according to the current
+** state of the database.  Assume pBt->pPage1 is valid.
+*/
+static void btreeSetNPage(BtShared *pBt, MemPage *pPage1){
+  int nPage = get4byte(&pPage1->aData[28]);
+  testcase( nPage==0 );
+  if( nPage==0 ) sqlite3PagerPagecount(pBt->pPager, &nPage);
+  testcase( pBt->nPage!=nPage );
+  pBt->nPage = nPage;
+}
+
 /*
 ** Rollback the transaction in progress.
 **
 ** If tripCode is not SQLITE_OK then cursors will be invalidated (tripped).
 ** Only write cursors are tripped if writeOnly is true but all cursors are
@@ -67384,15 +67611,11 @@
 
     /* The rollback may have destroyed the pPage1->aData value.  So
     ** call btreeGetPage() on page 1 again to make
     ** sure pPage1->aData is set correctly. */
     if( btreeGetPage(pBt, 1, &pPage1, 0)==SQLITE_OK ){
-      int nPage = get4byte(28+(u8*)pPage1->aData);
-      testcase( nPage==0 );
-      if( nPage==0 ) sqlite3PagerPagecount(pBt->pPager, &nPage);
-      testcase( pBt->nPage!=nPage );
-      pBt->nPage = nPage;
+      btreeSetNPage(pBt, pPage1);
       releasePageOne(pPage1);
     }
     assert( countValidCursors(pBt, 1)==0 );
     pBt->inTransaction = TRANS_READ;
     btreeClearHasContent(pBt);
@@ -67468,16 +67691,15 @@
     if( rc==SQLITE_OK ){
       if( iSavepoint<0 && (pBt->btsFlags & BTS_INITIALLY_EMPTY)!=0 ){
         pBt->nPage = 0;
       }
       rc = newDatabase(pBt);
-      pBt->nPage = get4byte(28 + pBt->pPage1->aData);
+      btreeSetNPage(pBt, pBt->pPage1);
 
-      /* The database size was written into the offset 28 of the header
-      ** when the transaction started, so we know that the value at offset
-      ** 28 is nonzero. */
-      assert( pBt->nPage>0 );
+      /* pBt->nPage might be zero if the database was corrupt when
+      ** the transaction was started. Otherwise, it must be at least 1.  */
+      assert( CORRUPT_DB || pBt->nPage>0 );
     }
     sqlite3BtreeLeave(p);
   }
   return rc;
 }
@@ -68055,10 +68277,11 @@
           u8 aSave[4];
           u8 *aWrite = &pBuf[-4];
           assert( aWrite>=pBufStart );                         /* due to (6) */
           memcpy(aSave, aWrite, 4);
           rc = sqlite3OsRead(fd, aWrite, a+4, (i64)pBt->pageSize*(nextPage-1));
+          if( rc && nextPage>pBt->nPage ) rc = SQLITE_CORRUPT_BKPT;
           nextPage = get4byte(aWrite);
           memcpy(aWrite, aSave, 4);
         }else
 #endif
 
@@ -68481,10 +68704,11 @@
       assert( pCur->aiIdx[ii]==pCur->apPage[ii]->nCell );
     }
     assert( pCur->ix==pCur->pPage->nCell-1 );
     assert( pCur->pPage->leaf );
 #endif
+    *pRes = 0;
     return SQLITE_OK;
   }
 
   rc = moveToRoot(pCur);
   if( rc==SQLITE_OK ){
@@ -68702,27 +68926,29 @@
           ** up to two varints past the end of the buffer. An extra 18
           ** bytes of padding is allocated at the end of the buffer in
           ** case this happens.  */
           void *pCellKey;
           u8 * const pCellBody = pCell - pPage->childPtrSize;
+          const int nOverrun = 18;  /* Size of the overrun padding */
           pPage->xParseCell(pPage, pCellBody, &pCur->info);
           nCell = (int)pCur->info.nKey;
           testcase( nCell<0 );   /* True if key size is 2^32 or more */
           testcase( nCell==0 );  /* Invalid key size:  0x80 0x80 0x00 */
           testcase( nCell==1 );  /* Invalid key size:  0x80 0x80 0x01 */
           testcase( nCell==2 );  /* Minimum legal index key size */
           if( nCell<2 || nCell/pCur->pBt->usableSize>pCur->pBt->nPage ){
             rc = SQLITE_CORRUPT_PAGE(pPage);
             goto moveto_finish;
           }
-          pCellKey = sqlite3Malloc( nCell+18 );
+          pCellKey = sqlite3Malloc( nCell+nOverrun );
           if( pCellKey==0 ){
             rc = SQLITE_NOMEM_BKPT;
             goto moveto_finish;
           }
           pCur->ix = (u16)idx;
           rc = accessPayload(pCur, 0, nCell, (unsigned char*)pCellKey, 0);
+          memset(((u8*)pCellKey)+nCell,0,nOverrun); /* Fix uninit warnings */
           pCur->curFlags &= ~BTCF_ValidOvfl;
           if( rc ){
             sqlite3_free(pCellKey);
             goto moveto_finish;
           }
@@ -69840,16 +70066,11 @@
   assert( MX_CELL(pPage->pBt)<=10921 );
   assert( pPage->nCell<=MX_CELL(pPage->pBt) || CORRUPT_DB );
   assert( pPage->nOverflow<=ArraySize(pPage->apOvfl) );
   assert( ArraySize(pPage->apOvfl)==ArraySize(pPage->aiOvfl) );
   assert( sqlite3_mutex_held(pPage->pBt->mutex) );
-  /* The cell should normally be sized correctly.  However, when moving a
-  ** malformed cell from a leaf page to an interior page, if the cell size
-  ** wanted to be less than 4 but got rounded up to 4 on the leaf, then size
-  ** might be less than 8 (leaf-size + pointer) on the interior node.  Hence
-  ** the term after the || in the following assert(). */
-  assert( sz==pPage->xCellSize(pPage, pCell) || (sz==8 && iChild>0) );
+  assert( sz==pPage->xCellSize(pPage, pCell) || CORRUPT_DB );
   assert( pPage->nFree>=0 );
   if( pPage->nOverflow || sz+2>pPage->nFree ){
     if( pTemp ){
       memcpy(pTemp, pCell, sz);
       pCell = pTemp;
@@ -70077,11 +70298,11 @@
   int k;                          /* Current slot in pCArray->apEnd[] */
   u8 *pSrcEnd;                    /* Current pCArray->apEnd[k] value */
 
   assert( i<iEnd );
   j = get2byte(&aData[hdr+5]);
-  if( NEVER(j>(u32)usableSize) ){ j = 0; }
+  if( j>(u32)usableSize ){ j = 0; }
   memcpy(&pTmp[j], &aData[j], usableSize - j);
 
   for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}
   pSrcEnd = pCArray->apEnd[k];
 
@@ -70169,11 +70390,12 @@
   for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}
   pEnd = pCArray->apEnd[k];
   while( 1 /*Exit by break*/ ){
     int sz, rc;
     u8 *pSlot;
-    sz = cachedCellSize(pCArray, i);
+    assert( pCArray->szCell[i]!=0 );
+    sz = pCArray->szCell[i];
     if( (aData[1]==0 && aData[2]==0) || (pSlot = pageFindSlot(pPg,sz,&rc))==0 ){
       if( (pData - pBegin)<sz ) return 1;
       pData -= sz;
       pSlot = pData;
     }
@@ -70330,10 +70552,11 @@
       pCellptr = &pPg->aCellIdx[iCell * 2];
       if( nCell>iCell ){
         memmove(&pCellptr[2], pCellptr, (nCell - iCell) * 2);
       }
       nCell++;
+      cachedCellSize(pCArray, iCell+iNew);
       if( pageInsertArray(
             pPg, pBegin, &pData, pCellptr,
             iCell+iNew, 1, pCArray
       ) ) goto editpage_fail;
     }
@@ -70823,10 +71046,11 @@
     int limit = pOld->nCell;
     u8 *aData = pOld->aData;
     u16 maskPage = pOld->maskPage;
     u8 *piCell = aData + pOld->cellOffset;
     u8 *piEnd;
+    VVA_ONLY( int nCellAtStart = b.nCell; )
 
     /* Verify that all sibling pages are of the same "type" (table-leaf,
     ** table-interior, index-leaf, or index-interior).
     */
     if( pOld->aData[0]!=apOld[0]->aData[0] ){
@@ -70851,10 +71075,14 @@
     ** long be able to find the cells if a pointer to each cell is not saved
     ** first.
     */
     memset(&b.szCell[b.nCell], 0, sizeof(b.szCell[0])*(limit+pOld->nOverflow));
     if( pOld->nOverflow>0 ){
+      if( NEVER(limit<pOld->aiOvfl[0]) ){
+        rc = SQLITE_CORRUPT_BKPT;
+        goto balance_cleanup;
+      }
       limit = pOld->aiOvfl[0];
       for(j=0; j<limit; j++){
         b.apCell[b.nCell] = aData + (maskPage & get2byteAligned(piCell));
         piCell += 2;
         b.nCell++;
@@ -70870,10 +71098,11 @@
       assert( b.nCell<nMaxCells );
       b.apCell[b.nCell] = aData + (maskPage & get2byteAligned(piCell));
       piCell += 2;
       b.nCell++;
     }
+    assert( (b.nCell-nCellAtStart)==(pOld->nCell+pOld->nOverflow) );
 
     cntOld[i] = b.nCell;
     if( i<nOld-1 && !leafData){
       u16 sz = (u16)szNew[i];
       u8 *pTemp;
@@ -71132,10 +71361,12 @@
     nNew>=5 ? apNew[4]->pgno : 0, nNew>=5 ? szNew[4] : 0,
     nNew>=5 ? cntNew[4] - cntNew[3] - !leafData : 0
   ));
 
   assert( sqlite3PagerIswriteable(pParent->pDbPage) );
+  assert( nNew>=1 && nNew<=ArraySize(apNew) );
+  assert( apNew[nNew-1]!=0 );
   put4byte(pRight, apNew[nNew-1]->pgno);
 
   /* If the sibling pages are not leaves, ensure that the right-child pointer
   ** of the right-most new sibling page is set to the value that was
   ** originally in the same field of the right-most old sibling page. */
@@ -71170,10 +71401,11 @@
     for(i=0; i<b.nCell; i++){
       u8 *pCell = b.apCell[i];
       while( i==cntOldNext ){
         iOld++;
         assert( iOld<nNew || iOld<nOld );
+        assert( iOld>=0 && iOld<NB );
         pOld = iOld<nNew ? apNew[iOld] : apOld[iOld];
         cntOldNext += pOld->nCell + pOld->nOverflow + !leafData;
       }
       if( i==cntNew[iNew] ){
         pNew = apNew[++iNew];
@@ -71476,15 +71708,17 @@
 
   VVA_ONLY( int balance_quick_called = 0 );
   VVA_ONLY( int balance_deeper_called = 0 );
 
   do {
-    int iPage = pCur->iPage;
+    int iPage;
     MemPage *pPage = pCur->pPage;
 
     if( NEVER(pPage->nFree<0) && btreeComputeFreeSpace(pPage) ) break;
-    if( iPage==0 ){
+    if( pPage->nOverflow==0 && pPage->nFree<=nMin ){
+      break;
+    }else if( (iPage = pCur->iPage)==0 ){
       if( pPage->nOverflow ){
         /* The root page of the b-tree is overfull. In this case call the
         ** balance_deeper() function to create a new child for the root-page
         ** and copy the current contents of the root-page to it. The
         ** next iteration of the do-loop will balance the child page.
@@ -71501,12 +71735,10 @@
           assert( pCur->pPage->nOverflow );
         }
       }else{
         break;
       }
-    }else if( pPage->nOverflow==0 && pPage->nFree<=nMin ){
-      break;
     }else{
       MemPage * const pParent = pCur->apPage[iPage-1];
       int const iIdx = pCur->aiIdx[iPage-1];
 
       rc = sqlite3PagerWrite(pParent->pDbPage);
@@ -71644,11 +71876,13 @@
   MemPage *pPage = pCur->pPage;       /* Page being written */
   BtShared *pBt;                      /* Btree */
   Pgno ovflPgno;                      /* Next overflow page to write */
   u32 ovflPageSize;                   /* Size to write on overflow page */
 
-  if( pCur->info.pPayload + pCur->info.nLocal > pPage->aDataEnd ){
+  if( pCur->info.pPayload + pCur->info.nLocal > pPage->aDataEnd
+   || pCur->info.pPayload < pPage->aData + pPage->cellOffset
+  ){
     return SQLITE_CORRUPT_BKPT;
   }
   /* Overwrite the local portion first */
   rc = btreeOverwriteContent(pPage, pCur->info.pPayload, pX,
                              0, pCur->info.nLocal);
@@ -71885,10 +72119,12 @@
     oldCell = findCell(pPage, idx);
     if( !pPage->leaf ){
       memcpy(newCell, oldCell, 4);
     }
     rc = clearCell(pPage, oldCell, &info);
+    testcase( pCur->curFlags & BTCF_ValidOvfl );
+    invalidateOverflowCache(pCur);
     if( info.nSize==szNew && info.nLocal==info.nPayload
      && (!ISAUTOVACUUM || szNew<pPage->minLocal)
     ){
       /* Overwrite the old cell with the new if they are the same size.
       ** We could also try to do this if the old cell is smaller, then add
@@ -71898,11 +72134,16 @@
       **
       ** This optimization cannot be used on an autovacuum database if the
       ** new entry uses overflow pages, as the insertCell() call below is
       ** necessary to add the PTRMAP_OVERFLOW1 pointer-map entry.  */
       assert( rc==SQLITE_OK ); /* clearCell never fails when nLocal==nPayload */
-      if( oldCell+szNew > pPage->aDataEnd ) return SQLITE_CORRUPT_BKPT;
+      if( oldCell < pPage->aData+pPage->hdrOffset+10 ){
+        return SQLITE_CORRUPT_BKPT;
+      }
+      if( oldCell+szNew > pPage->aDataEnd ){
+        return SQLITE_CORRUPT_BKPT;
+      }
       memcpy(oldCell, newCell, szNew);
       return SQLITE_OK;
     }
     dropCell(pPage, idx, info.nSize, &rc);
     if( rc ) goto end_insert;
@@ -73890,11 +74131,11 @@
   ** then the backup cannot proceed.
   */
   if( nSrcReserve!=nDestReserve ){
     u32 newPgsz = nSrcPgsz;
     rc = sqlite3PagerSetPagesize(pDestPager, &newPgsz, nSrcReserve);
-    if( rc==SQLITE_OK && newPgsz!=nSrcPgsz ) rc = SQLITE_READONLY;
+    if( rc==SQLITE_OK && newPgsz!=(u32)nSrcPgsz ) rc = SQLITE_READONLY;
   }
 #endif
 
   /* This loop runs once for each destination page spanned by the source
   ** page. For each iteration, variable iOff is set to the byte offset
@@ -74235,12 +74476,14 @@
   if( p->pDestDb ){
     p->pSrc->nBackup--;
   }
   if( p->isAttached ){
     pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));
+    assert( pp!=0 );
     while( *pp!=p ){
       pp = &(*pp)->pNext;
+      assert( pp!=0 );
     }
     *pp = p->pNext;
   }
 
   /* If a transaction is still open on the Btree, roll it back. */
@@ -74437,10 +74680,15 @@
 ** name sqlite_value
 */
 /* #include "sqliteInt.h" */
 /* #include "vdbeInt.h" */
 
+/* True if X is a power of two.  0 is considered a power of two here.
+** In other words, return true if X has at most one bit set.
+*/
+#define ISPOWEROF2(X)  (((X)&((X)-1))==0)
+
 #ifdef SQLITE_DEBUG
 /*
 ** Check invariants on a Mem object.
 **
 ** This routine is intended for use inside of assert() statements, like
@@ -74456,12 +74704,12 @@
   ** ensure that if Mem.szMalloc>0 then it is safe to do
   ** Mem.z = Mem.zMalloc without having to check Mem.flags&MEM_Dyn.
   ** That saves a few cycles in inner loops. */
   assert( (p->flags & MEM_Dyn)==0 || p->szMalloc==0 );
 
-  /* Cannot be both MEM_Int and MEM_Real at the same time */
-  assert( (p->flags & (MEM_Int|MEM_Real))!=(MEM_Int|MEM_Real) );
+  /* Cannot have more than one of MEM_Int, MEM_Real, or MEM_IntReal */
+  assert( ISPOWEROF2(p->flags & (MEM_Int|MEM_Real|MEM_IntReal)) );
 
   if( p->flags & MEM_Null ){
     /* Cannot be both MEM_Null and some other type */
     assert( (p->flags & (MEM_Int|MEM_Real|MEM_Str|MEM_Blob|MEM_Agg))==0 );
 
@@ -74511,13 +74759,35 @@
   }
   return 1;
 }
 #endif
 
+/*
+** Render a Mem object which is one of MEM_Int, MEM_Real, or MEM_IntReal
+** into a buffer.
+*/
+static void vdbeMemRenderNum(int sz, char *zBuf, Mem *p){
+  StrAccum acc;
+  assert( p->flags & (MEM_Int|MEM_Real|MEM_IntReal) );
+  sqlite3StrAccumInit(&acc, 0, zBuf, sz, 0);
+  if( p->flags & MEM_Int ){
+    sqlite3_str_appendf(&acc, "%lld", p->u.i);
+  }else if( p->flags & MEM_IntReal ){
+    sqlite3_str_appendf(&acc, "%!.15g", (double)p->u.i);
+  }else{
+    sqlite3_str_appendf(&acc, "%!.15g", p->u.r);
+  }
+  assert( acc.zText==zBuf && acc.mxAlloc<=0 );
+  zBuf[acc.nChar] = 0; /* Fast version of sqlite3StrAccumFinish(&acc) */
+}
+
 #ifdef SQLITE_DEBUG
 /*
-** Check that string value of pMem agrees with its integer or real value.
+** Validity checks on pMem.  pMem holds a string.
+**
+** (1) Check that string value of pMem agrees with its integer or real value.
+** (2) Check that the string is correctly zero terminated
 **
 ** A single int or real value always converts to the same strings.  But
 ** many different strings can be converted into the same int or real.
 ** If a table contains a numeric value and an index is based on the
 ** corresponding string value, then it is important that the string be
@@ -74531,21 +74801,28 @@
 ** been derived from the numeric and not the other way around.  It returns
 ** true if everything is ok and false if there is a problem.
 **
 ** This routine is for use inside of assert() statements only.
 */
-SQLITE_PRIVATE int sqlite3VdbeMemConsistentDualRep(Mem *p){
+SQLITE_PRIVATE int sqlite3VdbeMemValidStrRep(Mem *p){
   char zBuf[100];
   char *z;
   int i, j, incr;
   if( (p->flags & MEM_Str)==0 ) return 1;
-  if( (p->flags & (MEM_Int|MEM_Real))==0 ) return 1;
-  if( p->flags & MEM_Int ){
-    sqlite3_snprintf(sizeof(zBuf),zBuf,"%lld",p->u.i);
-  }else{
-    sqlite3_snprintf(sizeof(zBuf),zBuf,"%!.15g",p->u.r);
-  }
+  if( p->flags & MEM_Term ){
+    /* Insure that the string is properly zero-terminated.  Pay particular
+    ** attention to the case where p->n is odd */
+    if( p->szMalloc>0 && p->z==p->zMalloc ){
+      assert( p->enc==SQLITE_UTF8 || p->szMalloc >= ((p->n+1)&~1)+2 );
+      assert( p->enc!=SQLITE_UTF8 || p->szMalloc >= p->n+1 );
+    }
+    assert( p->z[p->n]==0 );
+    assert( p->enc==SQLITE_UTF8 || p->z[(p->n+1)&~1]==0 );
+    assert( p->enc==SQLITE_UTF8 || p->z[((p->n+1)&~1)+1]==0 );
+  }
+  if( (p->flags & (MEM_Int|MEM_Real|MEM_IntReal))==0 ) return 1;
+  vdbeMemRenderNum(sizeof(zBuf), zBuf, p);
   z = p->z;
   i = j = 0;
   incr = 1;
   if( p->enc!=SQLITE_UTF8 ){
     incr = 2;
@@ -74617,11 +74894,17 @@
   testcase( bPreserve && pMem->z==0 );
 
   assert( pMem->szMalloc==0
        || pMem->szMalloc==sqlite3DbMallocSize(pMem->db, pMem->zMalloc) );
   if( pMem->szMalloc>0 && bPreserve && pMem->z==pMem->zMalloc ){
-    pMem->z = pMem->zMalloc = sqlite3DbReallocOrFree(pMem->db, pMem->z, n);
+    if( pMem->db ){
+      pMem->z = pMem->zMalloc = sqlite3DbReallocOrFree(pMem->db, pMem->z, n);
+    }else{
+      pMem->zMalloc = sqlite3Realloc(pMem->z, n);
+      if( pMem->zMalloc==0 ) sqlite3_free(pMem->z);
+      pMem->z = pMem->zMalloc;
+    }
     bPreserve = 0;
   }else{
     if( pMem->szMalloc>0 ) sqlite3DbFreeNN(pMem->db, pMem->zMalloc);
     pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, n);
   }
@@ -74653,12 +74936,12 @@
 ** If pMem->zMalloc already meets or exceeds the requested size, this
 ** routine is a no-op.
 **
 ** Any prior string or blob content in the pMem object may be discarded.
 ** The pMem->xDel destructor is called, if it exists.  Though MEM_Str
-** and MEM_Blob values may be discarded, MEM_Int, MEM_Real, and MEM_Null
-** values are preserved.
+** and MEM_Blob values may be discarded, MEM_Int, MEM_Real, MEM_IntReal,
+** and MEM_Null values are preserved.
 **
 ** Return SQLITE_OK on success or an error code (probably SQLITE_NOMEM)
 ** if unable to complete the resizing.
 */
 SQLITE_PRIVATE int sqlite3VdbeMemClearAndResize(Mem *pMem, int szNew){
@@ -74667,24 +74950,30 @@
   if( pMem->szMalloc<szNew ){
     return sqlite3VdbeMemGrow(pMem, szNew, 0);
   }
   assert( (pMem->flags & MEM_Dyn)==0 );
   pMem->z = pMem->zMalloc;
-  pMem->flags &= (MEM_Null|MEM_Int|MEM_Real);
+  pMem->flags &= (MEM_Null|MEM_Int|MEM_Real|MEM_IntReal);
   return SQLITE_OK;
 }
 
 /*
 ** It is already known that pMem contains an unterminated string.
 ** Add the zero terminator.
+**
+** Three bytes of zero are added.  In this way, there is guaranteed
+** to be a double-zero byte at an even byte boundary in order to
+** terminate a UTF16 string, even if the initial size of the buffer
+** is an odd number of bytes.
 */
 static SQLITE_NOINLINE int vdbeMemAddTerminator(Mem *pMem){
-  if( sqlite3VdbeMemGrow(pMem, pMem->n+2, 1) ){
+  if( sqlite3VdbeMemGrow(pMem, pMem->n+3, 1) ){
     return SQLITE_NOMEM_BKPT;
   }
   pMem->z[pMem->n] = 0;
   pMem->z[pMem->n+1] = 0;
+  pMem->z[pMem->n+2] = 0;
   pMem->flags |= MEM_Term;
   return SQLITE_OK;
 }
 
 /*
@@ -74754,57 +75043,45 @@
     return vdbeMemAddTerminator(pMem);
   }
 }
 
 /*
-** Add MEM_Str to the set of representations for the given Mem.  Numbers
-** are converted using sqlite3_snprintf().  Converting a BLOB to a string
-** is a no-op.
+** Add MEM_Str to the set of representations for the given Mem.  This
+** routine is only called if pMem is a number of some kind, not a NULL
+** or a BLOB.
 **
-** Existing representations MEM_Int and MEM_Real are invalidated if
-** bForce is true but are retained if bForce is false.
+** Existing representations MEM_Int, MEM_Real, or MEM_IntReal are invalidated
+** if bForce is true but are retained if bForce is false.
 **
 ** A MEM_Null value will never be passed to this function. This function is
 ** used for converting values to text for returning to the user (i.e. via
 ** sqlite3_value_text()), or for ensuring that values to be used as btree
 ** keys are strings. In the former case a NULL pointer is returned the
 ** user and the latter is an internal programming error.
 */
 SQLITE_PRIVATE int sqlite3VdbeMemStringify(Mem *pMem, u8 enc, u8 bForce){
-  int fg = pMem->flags;
   const int nByte = 32;
 
   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
-  assert( !(fg&MEM_Zero) );
-  assert( !(fg&(MEM_Str|MEM_Blob)) );
-  assert( fg&(MEM_Int|MEM_Real) );
+  assert( !(pMem->flags&MEM_Zero) );
+  assert( !(pMem->flags&(MEM_Str|MEM_Blob)) );
+  assert( pMem->flags&(MEM_Int|MEM_Real|MEM_IntReal) );
   assert( !sqlite3VdbeMemIsRowSet(pMem) );
   assert( EIGHT_BYTE_ALIGNMENT(pMem) );
 
 
   if( sqlite3VdbeMemClearAndResize(pMem, nByte) ){
     pMem->enc = 0;
     return SQLITE_NOMEM_BKPT;
   }
 
-  /* For a Real or Integer, use sqlite3_snprintf() to produce the UTF-8
-  ** string representation of the value. Then, if the required encoding
-  ** is UTF-16le or UTF-16be do a translation.
-  **
-  ** FIX ME: It would be better if sqlite3_snprintf() could do UTF-16.
-  */
-  if( fg & MEM_Int ){
-    sqlite3_snprintf(nByte, pMem->z, "%lld", pMem->u.i);
-  }else{
-    assert( fg & MEM_Real );
-    sqlite3_snprintf(nByte, pMem->z, "%!.15g", pMem->u.r);
-  }
+  vdbeMemRenderNum(nByte, pMem->z, pMem);
   assert( pMem->z!=0 );
   pMem->n = sqlite3Strlen30NN(pMem->z);
   pMem->enc = SQLITE_UTF8;
   pMem->flags |= MEM_Str|MEM_Term;
-  if( bForce ) pMem->flags &= ~(MEM_Int|MEM_Real);
+  if( bForce ) pMem->flags &= ~(MEM_Int|MEM_Real|MEM_IntReal);
   sqlite3VdbeChangeEncoding(pMem, enc);
   return SQLITE_OK;
 }
 
 /*
@@ -74974,11 +75251,12 @@
 SQLITE_PRIVATE i64 sqlite3VdbeIntValue(Mem *pMem){
   int flags;
   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
   assert( EIGHT_BYTE_ALIGNMENT(pMem) );
   flags = pMem->flags;
-  if( flags & MEM_Int ){
+  if( flags & (MEM_Int|MEM_IntReal) ){
+    testcase( flags & MEM_IntReal );
     return pMem->u.i;
   }else if( flags & MEM_Real ){
     return doubleToInt64(pMem->u.r);
   }else if( flags & (MEM_Str|MEM_Blob) ){
     assert( pMem->z || pMem->n==0 );
@@ -75003,11 +75281,12 @@
 SQLITE_PRIVATE double sqlite3VdbeRealValue(Mem *pMem){
   assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
   assert( EIGHT_BYTE_ALIGNMENT(pMem) );
   if( pMem->flags & MEM_Real ){
     return pMem->u.r;
-  }else if( pMem->flags & MEM_Int ){
+  }else if( pMem->flags & (MEM_Int|MEM_IntReal) ){
+    testcase( pMem->flags & MEM_IntReal );
     return (double)pMem->u.i;
   }else if( pMem->flags & (MEM_Str|MEM_Blob) ){
     return memRealValue(pMem);
   }else{
     /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */
@@ -75018,11 +75297,12 @@
 /*
 ** Return 1 if pMem represents true, and return 0 if pMem represents false.
 ** Return the value ifNull if pMem is NULL.
 */
 SQLITE_PRIVATE int sqlite3VdbeBooleanValue(Mem *pMem, int ifNull){
-  if( pMem->flags & MEM_Int ) return pMem->u.i!=0;
+  testcase( pMem->flags & MEM_IntReal );
+  if( pMem->flags & (MEM_Int|MEM_IntReal) ) return pMem->u.i!=0;
   if( pMem->flags & MEM_Null ) return ifNull;
   return sqlite3VdbeRealValue(pMem)!=0.0;
 }
 
 /*
@@ -75081,47 +75361,52 @@
 }
 
 /* Compare a floating point value to an integer.  Return true if the two
 ** values are the same within the precision of the floating point value.
 **
+** This function assumes that i was obtained by assignment from r1.
+**
 ** For some versions of GCC on 32-bit machines, if you do the more obvious
 ** comparison of "r1==(double)i" you sometimes get an answer of false even
 ** though the r1 and (double)i values are bit-for-bit the same.
 */
-static int sqlite3RealSameAsInt(double r1, sqlite3_int64 i){
+SQLITE_PRIVATE int sqlite3RealSameAsInt(double r1, sqlite3_int64 i){
   double r2 = (double)i;
-  return memcmp(&r1, &r2, sizeof(r1))==0;
+  return r1==0.0
+      || (memcmp(&r1, &r2, sizeof(r1))==0
+          && i >= -2251799813685248LL && i < 2251799813685248LL);
 }
 
 /*
-** Convert pMem so that it has types MEM_Real or MEM_Int or both.
+** Convert pMem so that it has type MEM_Real or MEM_Int.
 ** Invalidate any prior representations.
 **
 ** Every effort is made to force the conversion, even if the input
 ** is a string that does not look completely like a number.  Convert
 ** as much of the string as we can and ignore the rest.
 */
 SQLITE_PRIVATE int sqlite3VdbeMemNumerify(Mem *pMem){
-  if( (pMem->flags & (MEM_Int|MEM_Real|MEM_Null))==0 ){
+  testcase( pMem->flags & MEM_Int );
+  testcase( pMem->flags & MEM_Real );
+  testcase( pMem->flags & MEM_IntReal );
+  testcase( pMem->flags & MEM_Null );
+  if( (pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Null))==0 ){
     int rc;
+    sqlite3_int64 ix;
     assert( (pMem->flags & (MEM_Blob|MEM_Str))!=0 );
     assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
-    rc = sqlite3Atoi64(pMem->z, &pMem->u.i, pMem->n, pMem->enc);
-    if( rc==0 ){
+    rc = sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc);
+    if( ((rc==0 || rc==1) && sqlite3Atoi64(pMem->z, &ix, pMem->n, pMem->enc)<=1)
+     || sqlite3RealSameAsInt(pMem->u.r, (ix = (i64)pMem->u.r))
+    ){
+      pMem->u.i = ix;
       MemSetTypeFlag(pMem, MEM_Int);
     }else{
-      i64 i = pMem->u.i;
-      sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc);
-      if( rc==1 && sqlite3RealSameAsInt(pMem->u.r, i) ){
-        pMem->u.i = i;
-        MemSetTypeFlag(pMem, MEM_Int);
-      }else{
-        MemSetTypeFlag(pMem, MEM_Real);
-      }
+      MemSetTypeFlag(pMem, MEM_Real);
     }
   }
-  assert( (pMem->flags & (MEM_Int|MEM_Real|MEM_Null))!=0 );
+  assert( (pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Null))!=0 );
   pMem->flags &= ~(MEM_Str|MEM_Blob|MEM_Zero);
   return SQLITE_OK;
 }
 
 /*
@@ -75160,11 +75445,11 @@
       assert( aff==SQLITE_AFF_TEXT );
       assert( MEM_Str==(MEM_Blob>>3) );
       pMem->flags |= (pMem->flags&MEM_Blob)>>3;
       sqlite3ValueApplyAffinity(pMem, SQLITE_AFF_TEXT, encoding);
       assert( pMem->flags & MEM_Str || pMem->db->mallocFailed );
-      pMem->flags &= ~(MEM_Int|MEM_Real|MEM_Blob|MEM_Zero);
+      pMem->flags &= ~(MEM_Int|MEM_Real|MEM_IntReal|MEM_Blob|MEM_Zero);
       break;
     }
   }
 }
 
@@ -75344,11 +75629,11 @@
       ** A significant change would indicated a missed call to this
       ** function for pX.  Minor changes, such as adding or removing a
       ** dual type, are allowed, as long as the underlying value is the
       ** same. */
       u16 mFlags = pMem->flags & pX->flags & pX->mScopyFlags;
-      assert( (mFlags&MEM_Int)==0 || pMem->u.i==pX->u.i );
+      assert( (mFlags&(MEM_Int|MEM_IntReal))==0 || pMem->u.i==pX->u.i );
       assert( (mFlags&MEM_Real)==0 || pMem->u.r==pX->u.r );
       assert( (mFlags&MEM_Str)==0  || (pMem->n==pX->n && pMem->z==pX->z) );
       assert( (mFlags&MEM_Blob)==0  || sqlite3BlobCompare(pMem,pX)==0 );
 
       /* pMem is the register that is changing.  But also mark pX as
@@ -75619,11 +75904,11 @@
     assert( 0==(1&SQLITE_PTR_TO_INT(pVal->z)) );
   }
   assert(pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) || pVal->db==0
               || pVal->db->mallocFailed );
   if( pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) ){
-    assert( sqlite3VdbeMemConsistentDualRep(pVal) );
+    assert( sqlite3VdbeMemValidStrRep(pVal) );
     return pVal->z;
   }else{
     return 0;
   }
 }
@@ -75642,11 +75927,11 @@
   if( !pVal ) return 0;
   assert( pVal->db==0 || sqlite3_mutex_held(pVal->db->mutex) );
   assert( (enc&3)==(enc&~SQLITE_UTF16_ALIGNED) );
   assert( !sqlite3VdbeMemIsRowSet(pVal) );
   if( (pVal->flags&(MEM_Str|MEM_Term))==(MEM_Str|MEM_Term) && pVal->enc==enc ){
-    assert( sqlite3VdbeMemConsistentDualRep(pVal) );
+    assert( sqlite3VdbeMemValidStrRep(pVal) );
     return pVal->z;
   }
   if( pVal->flags&MEM_Null ){
     return 0;
   }
@@ -75686,11 +75971,11 @@
 ** already been allocated, allocate the UnpackedRecord structure that
 ** that function will return to its caller here. Then return a pointer to
 ** an sqlite3_value within the UnpackedRecord.a[] array.
 */
 static sqlite3_value *valueNew(sqlite3 *db, struct ValueNewStat4Ctx *p){
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   if( p ){
     UnpackedRecord *pRec = p->ppRec[0];
 
     if( pRec==0 ){
       Index *pIdx = p->pIdx;      /* Index being probed */
@@ -75722,11 +76007,11 @@
     pRec->nField = p->iVal+1;
     return &pRec->aMem[p->iVal];
   }
 #else
   UNUSED_PARAMETER(p);
-#endif /* defined(SQLITE_ENABLE_STAT3_OR_STAT4) */
+#endif /* defined(SQLITE_ENABLE_STAT4) */
   return sqlite3ValueNew(db);
 }
 
 /*
 ** The expression object indicated by the second argument is guaranteed
@@ -75746,11 +76031,11 @@
 **
 ** If the conditions above are not met, this function returns SQLITE_OK
 ** and sets (*ppVal) to NULL. Or, if an error occurs, (*ppVal) is set to
 ** NULL and an SQLite error code returned.
 */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
 static int valueFromFunction(
   sqlite3 *db,                    /* The database connection */
   Expr *p,                        /* The expression to evaluate */
   u8 enc,                         /* Encoding to use */
   u8 aff,                         /* Affinity to use */
@@ -75829,11 +76114,11 @@
   *ppVal = pVal;
   return rc;
 }
 #else
 # define valueFromFunction(a,b,c,d,e,f) SQLITE_OK
-#endif /* defined(SQLITE_ENABLE_STAT3_OR_STAT4) */
+#endif /* defined(SQLITE_ENABLE_STAT4) */
 
 /*
 ** Extract a value from the supplied expression in the manner described
 ** above sqlite3ValueFromExpr(). Allocate the sqlite3_value object
 ** using valueNew().
@@ -75858,11 +76143,11 @@
   const char *zNeg = "";
   int rc = SQLITE_OK;
 
   assert( pExpr!=0 );
   while( (op = pExpr->op)==TK_UPLUS || op==TK_SPAN ) pExpr = pExpr->pLeft;
-#if defined(SQLITE_ENABLE_STAT3_OR_STAT4)
+#if defined(SQLITE_ENABLE_STAT4)
   if( op==TK_REGISTER ) op = pExpr->op2;
 #else
   if( NEVER(op==TK_REGISTER) ) op = pExpr->op2;
 #endif
 
@@ -75907,11 +76192,16 @@
     if( (op==TK_INTEGER || op==TK_FLOAT ) && affinity==SQLITE_AFF_BLOB ){
       sqlite3ValueApplyAffinity(pVal, SQLITE_AFF_NUMERIC, SQLITE_UTF8);
     }else{
       sqlite3ValueApplyAffinity(pVal, affinity, SQLITE_UTF8);
     }
-    if( pVal->flags & (MEM_Int|MEM_Real) ) pVal->flags &= ~MEM_Str;
+    assert( (pVal->flags & MEM_IntReal)==0 );
+    if( pVal->flags & (MEM_Int|MEM_IntReal|MEM_Real) ){
+      testcase( pVal->flags & MEM_Int );
+      testcase( pVal->flags & MEM_Real );
+      pVal->flags &= ~MEM_Str;
+    }
     if( enc!=SQLITE_UTF8 ){
       rc = sqlite3VdbeChangeEncoding(pVal, enc);
     }
   }else if( op==TK_UMINUS ) {
     /* This branch happens for multiple negative signs.  Ex: -(-5) */
@@ -75930,11 +76220,11 @@
       sqlite3ValueApplyAffinity(pVal, affinity, enc);
     }
   }else if( op==TK_NULL ){
     pVal = valueNew(db, pCtx);
     if( pVal==0 ) goto no_mem;
-    sqlite3VdbeMemNumerify(pVal);
+    sqlite3VdbeMemSetNull(pVal);
   }
 #ifndef SQLITE_OMIT_BLOB_LITERAL
   else if( op==TK_BLOB ){
     int nVal;
     assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );
@@ -75946,11 +76236,11 @@
     assert( zVal[nVal]=='\'' );
     sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, nVal), nVal/2,
                          0, SQLITE_DYNAMIC);
   }
 #endif
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   else if( op==TK_FUNCTION && pCtx!=0 ){
     rc = valueFromFunction(db, pExpr, enc, affinity, &pVal, pCtx);
   }
 #endif
   else if( op==TK_TRUEFALSE ){
@@ -75963,17 +76253,17 @@
 
   *ppVal = pVal;
   return rc;
 
 no_mem:
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   if( pCtx==0 || pCtx->pParse->nErr==0 )
 #endif
     sqlite3OomFault(db);
   sqlite3DbFree(db, zVal);
   assert( *ppVal==0 );
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   if( pCtx==0 ) sqlite3ValueFree(pVal);
 #else
   assert( pCtx==0 ); sqlite3ValueFree(pVal);
 #endif
   return SQLITE_NOMEM_BKPT;
@@ -75997,60 +76287,11 @@
   sqlite3_value **ppVal     /* Write the new value here */
 ){
   return pExpr ? valueFromExpr(db, pExpr, enc, affinity, ppVal, 0) : 0;
 }
 
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
-/*
-** The implementation of the sqlite_record() function. This function accepts
-** a single argument of any type. The return value is a formatted database
-** record (a blob) containing the argument value.
-**
-** This is used to convert the value stored in the 'sample' column of the
-** sqlite_stat3 table to the record format SQLite uses internally.
-*/
-static void recordFunc(
-  sqlite3_context *context,
-  int argc,
-  sqlite3_value **argv
-){
-  const int file_format = 1;
-  u32 iSerial;                    /* Serial type */
-  int nSerial;                    /* Bytes of space for iSerial as varint */
-  u32 nVal;                       /* Bytes of space required for argv[0] */
-  int nRet;
-  sqlite3 *db;
-  u8 *aRet;
-
-  UNUSED_PARAMETER( argc );
-  iSerial = sqlite3VdbeSerialType(argv[0], file_format, &nVal);
-  nSerial = sqlite3VarintLen(iSerial);
-  db = sqlite3_context_db_handle(context);
-
-  nRet = 1 + nSerial + nVal;
-  aRet = sqlite3DbMallocRawNN(db, nRet);
-  if( aRet==0 ){
-    sqlite3_result_error_nomem(context);
-  }else{
-    aRet[0] = nSerial+1;
-    putVarint32(&aRet[1], iSerial);
-    sqlite3VdbeSerialPut(&aRet[1+nSerial], argv[0], iSerial);
-    sqlite3_result_blob(context, aRet, nRet, SQLITE_TRANSIENT);
-    sqlite3DbFreeNN(db, aRet);
-  }
-}
-
-/*
-** Register built-in functions used to help read ANALYZE data.
-*/
-SQLITE_PRIVATE void sqlite3AnalyzeFunctions(void){
-  static FuncDef aAnalyzeTableFuncs[] = {
-    FUNCTION(sqlite_record,   1, 0, 0, recordFunc),
-  };
-  sqlite3InsertBuiltinFuncs(aAnalyzeTableFuncs, ArraySize(aAnalyzeTableFuncs));
-}
-
+#ifdef SQLITE_ENABLE_STAT4
 /*
 ** Attempt to extract a value from pExpr and use it to construct *ppVal.
 **
 ** If pAlloc is not NULL, then an UnpackedRecord object is created for
 ** pAlloc if one does not exist and the new value is added to the
@@ -76942,28 +77183,37 @@
 */
 SQLITE_PRIVATE int sqlite3VdbeAssertMayAbort(Vdbe *v, int mayAbort){
   int hasAbort = 0;
   int hasFkCounter = 0;
   int hasCreateTable = 0;
+  int hasCreateIndex = 0;
   int hasInitCoroutine = 0;
   Op *pOp;
   VdbeOpIter sIter;
   memset(&sIter, 0, sizeof(sIter));
   sIter.v = v;
 
   while( (pOp = opIterNext(&sIter))!=0 ){
     int opcode = pOp->opcode;
     if( opcode==OP_Destroy || opcode==OP_VUpdate || opcode==OP_VRename
      || opcode==OP_VDestroy
-     || (opcode==OP_Function0 && pOp->p4.pFunc->funcFlags&SQLITE_FUNC_INTERNAL)
+     || (opcode==OP_ParseSchema && pOp->p4.z==0)
      || ((opcode==OP_Halt || opcode==OP_HaltIfNull)
       && ((pOp->p1)!=SQLITE_OK && pOp->p2==OE_Abort))
     ){
       hasAbort = 1;
       break;
     }
     if( opcode==OP_CreateBtree && pOp->p3==BTREE_INTKEY ) hasCreateTable = 1;
+    if( mayAbort ){
+      /* hasCreateIndex may also be set for some DELETE statements that use
+      ** OP_Clear. So this routine may end up returning true in the case
+      ** where a "DELETE FROM tbl" has a statement-journal but does not
+      ** require one. This is not so bad - it is an inefficiency, not a bug. */
+      if( opcode==OP_CreateBtree && pOp->p3==BTREE_BLOBKEY ) hasCreateIndex = 1;
+      if( opcode==OP_Clear ) hasCreateIndex = 1;
+    }
     if( opcode==OP_InitCoroutine ) hasInitCoroutine = 1;
 #ifndef SQLITE_OMIT_FOREIGN_KEY
     if( opcode==OP_FkCounter && pOp->p1==0 && pOp->p2==1 ){
       hasFkCounter = 1;
     }
@@ -76975,11 +77225,12 @@
   ** If malloc failed, then the while() loop above may not have iterated
   ** through all opcodes and hasAbort may be set incorrectly. Return
   ** true for this case to prevent the assert() in the callers frame
   ** from failing.  */
   return ( v->db->mallocFailed || hasAbort==mayAbort || hasFkCounter
-              || (hasCreateTable && hasInitCoroutine) );
+        || (hasCreateTable && hasInitCoroutine) || hasCreateIndex
+  );
 }
 #endif /* SQLITE_DEBUG - the sqlite3AssertMayAbort() function */
 
 #ifdef SQLITE_DEBUG
 /*
@@ -77280,20 +77531,20 @@
 
 /*
 ** Change the value of the opcode, or P1, P2, P3, or P5 operands
 ** for a specific instruction.
 */
-SQLITE_PRIVATE void sqlite3VdbeChangeOpcode(Vdbe *p, u32 addr, u8 iNewOpcode){
+SQLITE_PRIVATE void sqlite3VdbeChangeOpcode(Vdbe *p, int addr, u8 iNewOpcode){
   sqlite3VdbeGetOp(p,addr)->opcode = iNewOpcode;
 }
-SQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe *p, u32 addr, int val){
+SQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe *p, int addr, int val){
   sqlite3VdbeGetOp(p,addr)->p1 = val;
 }
-SQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe *p, u32 addr, int val){
+SQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe *p, int addr, int val){
   sqlite3VdbeGetOp(p,addr)->p2 = val;
 }
-SQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe *p, u32 addr, int val){
+SQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe *p, int addr, int val){
   sqlite3VdbeGetOp(p,addr)->p3 = val;
 }
 SQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe *p, u16 p5){
   assert( p->nOp>0 || p->db->mallocFailed );
   if( p->nOp>0 ) p->aOp[p->nOp-1].p5 = p5;
@@ -77796,18 +78047,20 @@
   sqlite3StrAccumInit(&x, 0, zTemp, nTemp, 0);
   switch( pOp->p4type ){
     case P4_KEYINFO: {
       int j;
       KeyInfo *pKeyInfo = pOp->p4.pKeyInfo;
-      assert( pKeyInfo->aSortOrder!=0 );
+      assert( pKeyInfo->aSortFlags!=0 );
       sqlite3_str_appendf(&x, "k(%d", pKeyInfo->nKeyField);
       for(j=0; j<pKeyInfo->nKeyField; j++){
         CollSeq *pColl = pKeyInfo->aColl[j];
         const char *zColl = pColl ? pColl->zName : "";
         if( strcmp(zColl, "BINARY")==0 ) zColl = "B";
-        sqlite3_str_appendf(&x, ",%s%s",
-               pKeyInfo->aSortOrder[j] ? "-" : "", zColl);
+        sqlite3_str_appendf(&x, ",%s%s%s",
+               (pKeyInfo->aSortFlags[j] & KEYINFO_ORDER_DESC) ? "-" : "",
+               (pKeyInfo->aSortFlags[j] & KEYINFO_ORDER_BIGNULL)? "N." : "",
+               zColl);
       }
       sqlite3_str_append(&x, ")", 1);
       break;
     }
 #ifdef SQLITE_ENABLE_CURSOR_HINTS
@@ -77847,11 +78100,11 @@
     }
     case P4_MEM: {
       Mem *pMem = pOp->p4.pMem;
       if( pMem->flags & MEM_Str ){
         zP4 = pMem->z;
-      }else if( pMem->flags & MEM_Int ){
+      }else if( pMem->flags & (MEM_Int|MEM_IntReal) ){
         sqlite3_str_appendf(&x, "%lld", pMem->u.i);
       }else if( pMem->flags & MEM_Real ){
         sqlite3_str_appendf(&x, "%.16g", pMem->u.r);
       }else if( pMem->flags & MEM_Null ){
         zP4 = "NULL";
@@ -78210,12 +78463,15 @@
     }else{
       /* We are currently listing subprograms.  Figure out which one and
       ** pick up the appropriate opcode. */
       int j;
       i -= p->nOp;
+      assert( apSub!=0 );
+      assert( nSub>0 );
       for(j=0; i>=apSub[j]->nOp; j++){
         i -= apSub[j]->nOp;
+        assert( i<apSub[j]->nOp || j+1<nSub );
       }
       pOp = &apSub[j]->aOp[i];
     }
 
     /* When an OP_Program opcode is encounter (the only opcode that has
@@ -79209,11 +79465,11 @@
         }
       }
     }
 
     /* Check for immediate foreign key violations. */
-    if( p->rc==SQLITE_OK ){
+    if( p->rc==SQLITE_OK || (p->errorAction==OE_Fail && !isSpecialError) ){
       sqlite3VdbeCheckFk(p, 0);
     }
 
     /* If the auto-commit flag is set and this is the only active writer
     ** VM, then we do either a commit or rollback of the current transaction.
@@ -79733,27 +79989,38 @@
 **
 ** The 8 and 9 types were added in 3.3.0, file format 4.  Prior versions
 ** of SQLite will not understand those serial types.
 */
 
+#if 0 /* Inlined into the OP_MakeRecord opcode */
 /*
 ** Return the serial-type for the value stored in pMem.
+**
+** This routine might convert a large MEM_IntReal value into MEM_Real.
+**
+** 2019-07-11:  The primary user of this subroutine was the OP_MakeRecord
+** opcode in the byte-code engine.  But by moving this routine in-line, we
+** can omit some redundant tests and make that opcode a lot faster.  So
+** this routine is now only used by the STAT3 logic and STAT3 support has
+** ended.  The code is kept here for historical reference only.
 */
 SQLITE_PRIVATE u32 sqlite3VdbeSerialType(Mem *pMem, int file_format, u32 *pLen){
   int flags = pMem->flags;
   u32 n;
 
   assert( pLen!=0 );
   if( flags&MEM_Null ){
     *pLen = 0;
     return 0;
   }
-  if( flags&MEM_Int ){
+  if( flags&(MEM_Int|MEM_IntReal) ){
     /* Figure out whether to use 1, 2, 4, 6 or 8 bytes. */
 #   define MAX_6BYTE ((((i64)0x00008000)<<32)-1)
     i64 i = pMem->u.i;
     u64 u;
+    testcase( flags & MEM_Int );
+    testcase( flags & MEM_IntReal );
     if( i<0 ){
       u = ~i;
     }else{
       u = i;
     }
@@ -79769,10 +80036,19 @@
     if( u<=32767 ){ *pLen = 2; return 2; }
     if( u<=8388607 ){ *pLen = 3; return 3; }
     if( u<=2147483647 ){ *pLen = 4; return 4; }
     if( u<=MAX_6BYTE ){ *pLen = 6; return 5; }
     *pLen = 8;
+    if( flags&MEM_IntReal ){
+      /* If the value is IntReal and is going to take up 8 bytes to store
+      ** as an integer, then we might as well make it an 8-byte floating
+      ** point value */
+      pMem->u.r = (double)pMem->u.i;
+      pMem->flags &= ~MEM_IntReal;
+      pMem->flags |= MEM_Real;
+      return 7;
+    }
     return 6;
   }
   if( flags&MEM_Real ){
     *pLen = 8;
     return 7;
@@ -79784,10 +80060,11 @@
     n += pMem->u.nZero;
   }
   *pLen = n;
   return ((n*2) + 12 + ((flags&MEM_Str)!=0));
 }
+#endif /* inlined into OP_MakeRecord */
 
 /*
 ** The sizes for serial types less than 128
 */
 static const u8 sqlite3SmallTypeSizes[] = {
@@ -79942,11 +80219,11 @@
 ** This function is implemented as two separate routines for performance.
 ** The few cases that require local variables are broken out into a separate
 ** routine so that in most cases the overhead of moving the stack pointer
 ** is avoided.
 */
-static u32 SQLITE_NOINLINE serialGet(
+static u32 serialGet(
   const unsigned char *buf,     /* Buffer to deserialize from */
   u32 serial_type,              /* Serial type to deserialize */
   Mem *pMem                     /* Memory cell to write value into */
 ){
   u64 x = FOUR_BYTE_UINT(buf);
@@ -79974,11 +80251,11 @@
     assert( sizeof(r1)==sizeof(t2) && memcmp(&r1, &t2, sizeof(r1))==0 );
 #endif
     assert( sizeof(x)==8 && sizeof(pMem->u.r)==8 );
     swapMixedEndianFloat(x);
     memcpy(&pMem->u.r, &x, sizeof(x));
-    pMem->flags = sqlite3IsNaN(pMem->u.r) ? MEM_Null : MEM_Real;
+    pMem->flags = IsNaN(x) ? MEM_Null : MEM_Real;
   }
   return 8;
 }
 SQLITE_PRIVATE u32 sqlite3VdbeSerialGet(
   const unsigned char *buf,     /* Buffer to deserialize from */
@@ -80092,11 +80369,11 @@
   int nByte;                      /* Number of bytes required for *p */
   nByte = ROUND8(sizeof(UnpackedRecord)) + sizeof(Mem)*(pKeyInfo->nKeyField+1);
   p = (UnpackedRecord *)sqlite3DbMallocRaw(pKeyInfo->db, nByte);
   if( !p ) return 0;
   p->aMem = (Mem*)&((char*)p)[ROUND8(sizeof(UnpackedRecord))];
-  assert( pKeyInfo->aSortOrder!=0 );
+  assert( pKeyInfo->aSortFlags!=0 );
   p->pKeyInfo = pKeyInfo;
   p->nField = pKeyInfo->nKeyField + 1;
   return p;
 }
 
@@ -80191,11 +80468,11 @@
 
   idx1 = getVarint32(aKey1, szHdr1);
   if( szHdr1>98307 ) return SQLITE_CORRUPT;
   d1 = szHdr1;
   assert( pKeyInfo->nAllField>=pPKey2->nField || CORRUPT_DB );
-  assert( pKeyInfo->aSortOrder!=0 );
+  assert( pKeyInfo->aSortFlags!=0 );
   assert( pKeyInfo->nKeyField>0 );
   assert( idx1<=szHdr1 || CORRUPT_DB );
   do{
     u32 serial_type1;
 
@@ -80222,11 +80499,16 @@
     */
     rc = sqlite3MemCompare(&mem1, &pPKey2->aMem[i],
                            pKeyInfo->nAllField>i ? pKeyInfo->aColl[i] : 0);
     if( rc!=0 ){
       assert( mem1.szMalloc==0 );  /* See comment below */
-      if( pKeyInfo->aSortOrder[i] ){
+      if( (pKeyInfo->aSortFlags[i] & KEYINFO_ORDER_BIGNULL)
+       && ((mem1.flags & MEM_Null) || (pPKey2->aMem[i].flags & MEM_Null))
+      ){
+        rc = -rc;
+      }
+      if( pKeyInfo->aSortFlags[i] & KEYINFO_ORDER_DESC ){
         rc = -rc;  /* Invert the result for DESC sort order. */
       }
       goto debugCompareEnd;
     }
     i++;
@@ -80424,30 +80706,43 @@
     return (f2&MEM_Null) - (f1&MEM_Null);
   }
 
   /* At least one of the two values is a number
   */
-  if( combined_flags&(MEM_Int|MEM_Real) ){
-    if( (f1 & f2 & MEM_Int)!=0 ){
+  if( combined_flags&(MEM_Int|MEM_Real|MEM_IntReal) ){
+    testcase( combined_flags & MEM_Int );
+    testcase( combined_flags & MEM_Real );
+    testcase( combined_flags & MEM_IntReal );
+    if( (f1 & f2 & (MEM_Int|MEM_IntReal))!=0 ){
+      testcase( f1 & f2 & MEM_Int );
+      testcase( f1 & f2 & MEM_IntReal );
       if( pMem1->u.i < pMem2->u.i ) return -1;
       if( pMem1->u.i > pMem2->u.i ) return +1;
       return 0;
     }
     if( (f1 & f2 & MEM_Real)!=0 ){
       if( pMem1->u.r < pMem2->u.r ) return -1;
       if( pMem1->u.r > pMem2->u.r ) return +1;
       return 0;
     }
-    if( (f1&MEM_Int)!=0 ){
+    if( (f1&(MEM_Int|MEM_IntReal))!=0 ){
+      testcase( f1 & MEM_Int );
+      testcase( f1 & MEM_IntReal );
       if( (f2&MEM_Real)!=0 ){
         return sqlite3IntFloatCompare(pMem1->u.i, pMem2->u.r);
+      }else if( (f2&(MEM_Int|MEM_IntReal))!=0 ){
+        if( pMem1->u.i < pMem2->u.i ) return -1;
+        if( pMem1->u.i > pMem2->u.i ) return +1;
+        return 0;
       }else{
         return -1;
       }
     }
     if( (f1&MEM_Real)!=0 ){
-      if( (f2&MEM_Int)!=0 ){
+      if( (f2&(MEM_Int|MEM_IntReal))!=0 ){
+        testcase( f2 & MEM_Int );
+        testcase( f2 & MEM_IntReal );
         return -sqlite3IntFloatCompare(pMem2->u.i, pMem1->u.r);
       }else{
         return -1;
       }
     }
@@ -80585,18 +80880,20 @@
   }
 
   VVA_ONLY( mem1.szMalloc = 0; ) /* Only needed by assert() statements */
   assert( pPKey2->pKeyInfo->nAllField>=pPKey2->nField
        || CORRUPT_DB );
-  assert( pPKey2->pKeyInfo->aSortOrder!=0 );
+  assert( pPKey2->pKeyInfo->aSortFlags!=0 );
   assert( pPKey2->pKeyInfo->nKeyField>0 );
   assert( idx1<=szHdr1 || CORRUPT_DB );
   do{
     u32 serial_type;
 
     /* RHS is an integer */
-    if( pRhs->flags & MEM_Int ){
+    if( pRhs->flags & (MEM_Int|MEM_IntReal) ){
+      testcase( pRhs->flags & MEM_Int );
+      testcase( pRhs->flags & MEM_IntReal );
       serial_type = aKey1[idx1];
       testcase( serial_type==12 );
       if( serial_type>=10 ){
         rc = +1;
       }else if( serial_type==0 ){
@@ -80706,12 +81003,18 @@
       serial_type = aKey1[idx1];
       rc = (serial_type!=0);
     }
 
     if( rc!=0 ){
-      if( pPKey2->pKeyInfo->aSortOrder[i] ){
-        rc = -rc;
+      int sortFlags = pPKey2->pKeyInfo->aSortFlags[i];
+      if( sortFlags ){
+        if( (sortFlags & KEYINFO_ORDER_BIGNULL)==0
+         || ((sortFlags & KEYINFO_ORDER_DESC)
+           !=(serial_type==0 || (pRhs->flags&MEM_Null)))
+        ){
+          rc = -rc;
+        }
       }
       assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, rc) );
       assert( mem1.szMalloc==0 );  /* See comment below */
       return rc;
     }
@@ -80875,11 +81178,15 @@
       return 0;    /* Corruption */
     }
     nCmp = MIN( pPKey2->aMem[0].n, nStr );
     res = memcmp(&aKey1[szHdr], pPKey2->aMem[0].z, nCmp);
 
-    if( res==0 ){
+    if( res>0 ){
+      res = pPKey2->r2;
+    }else if( res<0 ){
+      res = pPKey2->r1;
+    }else{
       res = nStr - pPKey2->aMem[0].n;
       if( res==0 ){
         if( pPKey2->nField>1 ){
           res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);
         }else{
@@ -80889,14 +81196,10 @@
       }else if( res>0 ){
         res = pPKey2->r2;
       }else{
         res = pPKey2->r1;
       }
-    }else if( res>0 ){
-      res = pPKey2->r2;
-    }else{
-      res = pPKey2->r1;
     }
   }
 
   assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, res)
        || CORRUPT_DB
@@ -80924,11 +81227,14 @@
   ** The easiest way to enforce this limit is to consider only records with
   ** 13 fields or less. If the first field is an integer, the maximum legal
   ** header size is (12*5 + 1 + 1) bytes.  */
   if( p->pKeyInfo->nAllField<=13 ){
     int flags = p->aMem[0].flags;
-    if( p->pKeyInfo->aSortOrder[0] ){
+    if( p->pKeyInfo->aSortFlags[0] ){
+      if( p->pKeyInfo->aSortFlags[0] & KEYINFO_ORDER_BIGNULL ){
+        return sqlite3VdbeRecordCompare;
+      }
       p->r1 = 1;
       p->r2 = -1;
     }else{
       p->r1 = -1;
       p->r2 = 1;
@@ -80937,11 +81243,13 @@
       return vdbeRecordCompareInt;
     }
     testcase( flags & MEM_Real );
     testcase( flags & MEM_Null );
     testcase( flags & MEM_Blob );
-    if( (flags & (MEM_Real|MEM_Null|MEM_Blob))==0 && p->pKeyInfo->aColl[0]==0 ){
+    if( (flags & (MEM_Real|MEM_IntReal|MEM_Null|MEM_Blob))==0
+     && p->pKeyInfo->aColl[0]==0
+    ){
       assert( flags & MEM_Str );
       return vdbeRecordCompareString;
     }
   }
 
@@ -81171,11 +81479,11 @@
 ** throw an error if it is given inputs that would make it non-deterministic.
 ** This routine is invoked by date/time functions that use non-deterministic
 ** features such as 'now'.
 */
 SQLITE_PRIVATE int sqlite3NotPureFunc(sqlite3_context *pCtx){
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   if( pCtx->pVdbe==0 ) return 1;
 #endif
   if( pCtx->pVdbe->aOp[pCtx->iOp].opcode==OP_PureFunc ){
     sqlite3_result_error(pCtx,
        "non-deterministic function in index expression or CHECK constraint",
@@ -81268,11 +81576,11 @@
   preupdate.op = op;
   preupdate.iNewReg = iReg;
   preupdate.keyinfo.db = db;
   preupdate.keyinfo.enc = ENC(db);
   preupdate.keyinfo.nKeyField = pTab->nCol;
-  preupdate.keyinfo.aSortOrder = (u8*)&fakeSortOrder;
+  preupdate.keyinfo.aSortFlags = (u8*)&fakeSortOrder;
   preupdate.iKey1 = iKey1;
   preupdate.iKey2 = iKey2;
   preupdate.pTab = pTab;
 
   db->pPreUpdate = &preupdate;
@@ -81527,43 +81835,90 @@
 ** fundamental datatypes: 64-bit signed integer 64-bit IEEE floating
 ** point number string BLOB NULL
 */
 SQLITE_API int sqlite3_value_type(sqlite3_value* pVal){
   static const u8 aType[] = {
-     SQLITE_BLOB,     /* 0x00 */
-     SQLITE_NULL,     /* 0x01 */
-     SQLITE_TEXT,     /* 0x02 */
-     SQLITE_NULL,     /* 0x03 */
-     SQLITE_INTEGER,  /* 0x04 */
-     SQLITE_NULL,     /* 0x05 */
-     SQLITE_INTEGER,  /* 0x06 */
-     SQLITE_NULL,     /* 0x07 */
-     SQLITE_FLOAT,    /* 0x08 */
-     SQLITE_NULL,     /* 0x09 */
-     SQLITE_FLOAT,    /* 0x0a */
-     SQLITE_NULL,     /* 0x0b */
-     SQLITE_INTEGER,  /* 0x0c */
-     SQLITE_NULL,     /* 0x0d */
-     SQLITE_INTEGER,  /* 0x0e */
-     SQLITE_NULL,     /* 0x0f */
-     SQLITE_BLOB,     /* 0x10 */
-     SQLITE_NULL,     /* 0x11 */
-     SQLITE_TEXT,     /* 0x12 */
-     SQLITE_NULL,     /* 0x13 */
-     SQLITE_INTEGER,  /* 0x14 */
-     SQLITE_NULL,     /* 0x15 */
-     SQLITE_INTEGER,  /* 0x16 */
-     SQLITE_NULL,     /* 0x17 */
-     SQLITE_FLOAT,    /* 0x18 */
-     SQLITE_NULL,     /* 0x19 */
-     SQLITE_FLOAT,    /* 0x1a */
-     SQLITE_NULL,     /* 0x1b */
-     SQLITE_INTEGER,  /* 0x1c */
-     SQLITE_NULL,     /* 0x1d */
-     SQLITE_INTEGER,  /* 0x1e */
-     SQLITE_NULL,     /* 0x1f */
+     SQLITE_BLOB,     /* 0x00 (not possible) */
+     SQLITE_NULL,     /* 0x01 NULL */
+     SQLITE_TEXT,     /* 0x02 TEXT */
+     SQLITE_NULL,     /* 0x03 (not possible) */
+     SQLITE_INTEGER,  /* 0x04 INTEGER */
+     SQLITE_NULL,     /* 0x05 (not possible) */
+     SQLITE_INTEGER,  /* 0x06 INTEGER + TEXT */
+     SQLITE_NULL,     /* 0x07 (not possible) */
+     SQLITE_FLOAT,    /* 0x08 FLOAT */
+     SQLITE_NULL,     /* 0x09 (not possible) */
+     SQLITE_FLOAT,    /* 0x0a FLOAT + TEXT */
+     SQLITE_NULL,     /* 0x0b (not possible) */
+     SQLITE_INTEGER,  /* 0x0c (not possible) */
+     SQLITE_NULL,     /* 0x0d (not possible) */
+     SQLITE_INTEGER,  /* 0x0e (not possible) */
+     SQLITE_NULL,     /* 0x0f (not possible) */
+     SQLITE_BLOB,     /* 0x10 BLOB */
+     SQLITE_NULL,     /* 0x11 (not possible) */
+     SQLITE_TEXT,     /* 0x12 (not possible) */
+     SQLITE_NULL,     /* 0x13 (not possible) */
+     SQLITE_INTEGER,  /* 0x14 INTEGER + BLOB */
+     SQLITE_NULL,     /* 0x15 (not possible) */
+     SQLITE_INTEGER,  /* 0x16 (not possible) */
+     SQLITE_NULL,     /* 0x17 (not possible) */
+     SQLITE_FLOAT,    /* 0x18 FLOAT + BLOB */
+     SQLITE_NULL,     /* 0x19 (not possible) */
+     SQLITE_FLOAT,    /* 0x1a (not possible) */
+     SQLITE_NULL,     /* 0x1b (not possible) */
+     SQLITE_INTEGER,  /* 0x1c (not possible) */
+     SQLITE_NULL,     /* 0x1d (not possible) */
+     SQLITE_INTEGER,  /* 0x1e (not possible) */
+     SQLITE_NULL,     /* 0x1f (not possible) */
+     SQLITE_FLOAT,    /* 0x20 INTREAL */
+     SQLITE_NULL,     /* 0x21 (not possible) */
+     SQLITE_TEXT,     /* 0x22 INTREAL + TEXT */
+     SQLITE_NULL,     /* 0x23 (not possible) */
+     SQLITE_FLOAT,    /* 0x24 (not possible) */
+     SQLITE_NULL,     /* 0x25 (not possible) */
+     SQLITE_FLOAT,    /* 0x26 (not possible) */
+     SQLITE_NULL,     /* 0x27 (not possible) */
+     SQLITE_FLOAT,    /* 0x28 (not possible) */
+     SQLITE_NULL,     /* 0x29 (not possible) */
+     SQLITE_FLOAT,    /* 0x2a (not possible) */
+     SQLITE_NULL,     /* 0x2b (not possible) */
+     SQLITE_FLOAT,    /* 0x2c (not possible) */
+     SQLITE_NULL,     /* 0x2d (not possible) */
+     SQLITE_FLOAT,    /* 0x2e (not possible) */
+     SQLITE_NULL,     /* 0x2f (not possible) */
+     SQLITE_BLOB,     /* 0x30 (not possible) */
+     SQLITE_NULL,     /* 0x31 (not possible) */
+     SQLITE_TEXT,     /* 0x32 (not possible) */
+     SQLITE_NULL,     /* 0x33 (not possible) */
+     SQLITE_FLOAT,    /* 0x34 (not possible) */
+     SQLITE_NULL,     /* 0x35 (not possible) */
+     SQLITE_FLOAT,    /* 0x36 (not possible) */
+     SQLITE_NULL,     /* 0x37 (not possible) */
+     SQLITE_FLOAT,    /* 0x38 (not possible) */
+     SQLITE_NULL,     /* 0x39 (not possible) */
+     SQLITE_FLOAT,    /* 0x3a (not possible) */
+     SQLITE_NULL,     /* 0x3b (not possible) */
+     SQLITE_FLOAT,    /* 0x3c (not possible) */
+     SQLITE_NULL,     /* 0x3d (not possible) */
+     SQLITE_FLOAT,    /* 0x3e (not possible) */
+     SQLITE_NULL,     /* 0x3f (not possible) */
   };
+#ifdef SQLITE_DEBUG
+  {
+    int eType = SQLITE_BLOB;
+    if( pVal->flags & MEM_Null ){
+      eType = SQLITE_NULL;
+    }else if( pVal->flags & (MEM_Real|MEM_IntReal) ){
+      eType = SQLITE_FLOAT;
+    }else if( pVal->flags & MEM_Int ){
+      eType = SQLITE_INTEGER;
+    }else if( pVal->flags & MEM_Str ){
+      eType = SQLITE_TEXT;
+    }
+    assert( eType == aType[pVal->flags&MEM_AffMask] );
+  }
+#endif
   return aType[pVal->flags&MEM_AffMask];
 }
 
 /* Return true if a parameter to xUpdate represents an unchanged column */
 SQLITE_API int sqlite3_value_nochange(sqlite3_value *pVal){
@@ -81809,10 +82164,25 @@
   sqlite3VdbeMemSetNull(pCtx->pOut);
   pCtx->isError = SQLITE_NOMEM_BKPT;
   sqlite3OomFault(pCtx->pOut->db);
 }
 
+#ifndef SQLITE_UNTESTABLE
+/* Force the INT64 value currently stored as the result to be
+** a MEM_IntReal value.  See the SQLITE_TESTCTRL_RESULT_INTREAL
+** test-control.
+*/
+SQLITE_PRIVATE void sqlite3ResultIntReal(sqlite3_context *pCtx){
+  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
+  if( pCtx->pOut->flags & MEM_Int ){
+    pCtx->pOut->flags &= ~MEM_Int;
+    pCtx->pOut->flags |= MEM_IntReal;
+  }
+}
+#endif
+
+
 /*
 ** This function is called after a transaction has been committed. It
 ** invokes callbacks registered with sqlite3_wal_hook() as required.
 */
 static int doWalCallbacks(sqlite3 *db){
@@ -82075,11 +82445,11 @@
 ** of the amount of time that elapses between invocations.  In other words,
 ** the time returned is always the time of the first call.
 */
 SQLITE_PRIVATE sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context *p){
   int rc;
-#ifndef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifndef SQLITE_ENABLE_STAT4
   sqlite3_int64 *piTime = &p->pVdbe->iCurrentTime;
   assert( p->pVdbe!=0 );
 #else
   sqlite3_int64 iTime = 0;
   sqlite3_int64 *piTime = p->pVdbe!=0 ? &p->pVdbe->iCurrentTime : &iTime;
@@ -82140,11 +82510,11 @@
 */
 SQLITE_API void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){
   AuxData *pAuxData;
 
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
-#if SQLITE_ENABLE_STAT3_OR_STAT4
+#if SQLITE_ENABLE_STAT4
   if( pCtx->pVdbe==0 ) return 0;
 #else
   assert( pCtx->pVdbe!=0 );
 #endif
   for(pAuxData=pCtx->pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNextAux){
@@ -82174,11 +82544,11 @@
 ){
   AuxData *pAuxData;
   Vdbe *pVdbe = pCtx->pVdbe;
 
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   if( pVdbe==0 ) goto failed;
 #else
   assert( pVdbe!=0 );
 #endif
 
@@ -83095,11 +83465,13 @@
   if( iIdx==p->pTab->iPKey ){
     sqlite3VdbeMemSetInt64(pMem, p->iKey1);
   }else if( iIdx>=p->pUnpacked->nField ){
     *ppValue = (sqlite3_value *)columnNullValue();
   }else if( p->pTab->aCol[iIdx].affinity==SQLITE_AFF_REAL ){
-    if( pMem->flags & MEM_Int ){
+    if( pMem->flags & (MEM_Int|MEM_IntReal) ){
+      testcase( pMem->flags & MEM_Int );
+      testcase( pMem->flags & MEM_IntReal );
       sqlite3VdbeMemRealify(pMem);
     }
   }
 
  preupdate_old_out:
@@ -83414,11 +83786,11 @@
       nextIndex = idx + 1;
       assert( idx>0 && idx<=p->nVar );
       pVar = &p->aVar[idx-1];
       if( pVar->flags & MEM_Null ){
         sqlite3_str_append(&out, "NULL", 4);
-      }else if( pVar->flags & MEM_Int ){
+      }else if( pVar->flags & (MEM_Int|MEM_IntReal) ){
         sqlite3_str_appendf(&out, "%lld", pVar->u.i);
       }else if( pVar->flags & MEM_Real ){
         sqlite3_str_appendf(&out, "%!.15g", pVar->u.r);
       }else if( pVar->flags & MEM_Str ){
         int nOut;  /* Number of bytes of the string text to include in output */
@@ -83676,18 +84048,10 @@
     sqlite3GlobalConfig.xVdbeBranch(sqlite3GlobalConfig.pVdbeBranchArg,
                                     iSrcLine&0xffffff, I, M);
   }
 #endif
 
-/*
-** Convert the given register into a string if it isn't one
-** already. Return non-zero if a malloc() fails.
-*/
-#define Stringify(P, enc) \
-   if(((P)->flags&(MEM_Str|MEM_Blob))==0 && sqlite3VdbeMemStringify(P,enc,0)) \
-     { goto no_mem; }
-
 /*
 ** An ephemeral string value (signified by the MEM_Ephem flag) contains
 ** a pointer to a dynamically allocated string where some other entity
 ** is responsible for deallocating that string.  Because the register
 ** does not control the string, it might be deleted without the register
@@ -83745,11 +84109,11 @@
   if( p->apCsr[iCur] ){ /*OPTIMIZATION-IF-FALSE*/
     /* Before calling sqlite3VdbeFreeCursor(), ensure the isEphemeral flag
     ** is clear. Otherwise, if this is an ephemeral cursor created by
     ** OP_OpenDup, the cursor will not be closed and will still be part
     ** of a BtShared.pCursor list.  */
-    p->apCsr[iCur]->isEphemeral = 0;
+    if( p->apCsr[iCur]->pBtx==0 ) p->apCsr[iCur]->isEphemeral = 0;
     sqlite3VdbeFreeCursor(p, p->apCsr[iCur]);
     p->apCsr[iCur] = 0;
   }
   if( SQLITE_OK==sqlite3VdbeMemClearAndResize(pMem, nByte) ){
     p->apCsr[iCur] = pCx = (VdbeCursor*)pMem->z;
@@ -83765,10 +84129,25 @@
     }
   }
   return pCx;
 }
 
+/*
+** The string in pRec is known to look like an integer and to have a
+** floating point value of rValue.  Return true and set *piValue to the
+** integer value if the string is in range to be an integer.  Otherwise,
+** return false.
+*/
+static int alsoAnInt(Mem *pRec, double rValue, i64 *piValue){
+  i64 iValue = (double)rValue;
+  if( sqlite3RealSameAsInt(rValue,iValue) ){
+    *piValue = iValue;
+    return 1;
+  }
+  return 0==sqlite3Atoi64(pRec->z, piValue, pRec->n, pRec->enc);
+}
+
 /*
 ** Try to convert a value into a numeric representation if we can
 ** do so without loss of information.  In other words, if the string
 ** looks like a number, convert it into a number.  If it does not
 ** look like a number, leave it alone.
@@ -83782,16 +84161,16 @@
 ** point or exponential notation, the result is only MEM_Real, even
 ** if there is an exact integer representation of the quantity.
 */
 static void applyNumericAffinity(Mem *pRec, int bTryForInt){
   double rValue;
-  i64 iValue;
   u8 enc = pRec->enc;
-  assert( (pRec->flags & (MEM_Str|MEM_Int|MEM_Real))==MEM_Str );
-  if( sqlite3AtoF(pRec->z, &rValue, pRec->n, enc)==0 ) return;
-  if( 0==sqlite3Atoi64(pRec->z, &iValue, pRec->n, enc) ){
-    pRec->u.i = iValue;
+  int rc;
+  assert( (pRec->flags & (MEM_Str|MEM_Int|MEM_Real|MEM_IntReal))==MEM_Str );
+  rc = sqlite3AtoF(pRec->z, &rValue, pRec->n, enc);
+  if( rc<=0 ) return;
+  if( rc==1 && alsoAnInt(pRec, rValue, &pRec->u.i) ){
     pRec->flags |= MEM_Int;
   }else{
     pRec->u.r = rValue;
     pRec->flags |= MEM_Real;
     if( bTryForInt ) sqlite3VdbeIntegerAffinity(pRec);
@@ -83817,10 +84196,11 @@
 **
 ** SQLITE_AFF_TEXT:
 **    Convert pRec to a text representation.
 **
 ** SQLITE_AFF_BLOB:
+** SQLITE_AFF_NONE:
 **    No-op.  pRec is unchanged.
 */
 static void applyAffinity(
   Mem *pRec,          /* The value to apply affinity to */
   char affinity,      /* The affinity to be applied */
@@ -83841,15 +84221,18 @@
     ** representation (blob and NULL do not get converted) but no string
     ** representation.  It would be harmless to repeat the conversion if
     ** there is already a string rep, but it is pointless to waste those
     ** CPU cycles. */
     if( 0==(pRec->flags&MEM_Str) ){ /*OPTIMIZATION-IF-FALSE*/
-      if( (pRec->flags&(MEM_Real|MEM_Int)) ){
+      if( (pRec->flags&(MEM_Real|MEM_Int|MEM_IntReal)) ){
+        testcase( pRec->flags & MEM_Int );
+        testcase( pRec->flags & MEM_Real );
+        testcase( pRec->flags & MEM_IntReal );
         sqlite3VdbeMemStringify(pRec, enc, 1);
       }
     }
-    pRec->flags &= ~(MEM_Real|MEM_Int);
+    pRec->flags &= ~(MEM_Real|MEM_Int|MEM_IntReal);
   }
 }
 
 /*
 ** Try to convert the type of a function argument or a result column
@@ -83884,17 +84267,25 @@
 ** interpret as a string if we want to).  Compute its corresponding
 ** numeric type, if has one.  Set the pMem->u.r and pMem->u.i fields
 ** accordingly.
 */
 static u16 SQLITE_NOINLINE computeNumericType(Mem *pMem){
-  assert( (pMem->flags & (MEM_Int|MEM_Real))==0 );
+  int rc;
+  sqlite3_int64 ix;
+  assert( (pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal))==0 );
   assert( (pMem->flags & (MEM_Str|MEM_Blob))!=0 );
   ExpandBlob(pMem);
-  if( sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc)==0 ){
-    return 0;
-  }
-  if( sqlite3Atoi64(pMem->z, &pMem->u.i, pMem->n, pMem->enc)==0 ){
+  rc = sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc);
+  if( rc<=0 ){
+    if( rc==0 && sqlite3Atoi64(pMem->z, &ix, pMem->n, pMem->enc)<=1 ){
+      pMem->u.i = ix;
+      return MEM_Int;
+    }else{
+      return MEM_Real;
+    }
+  }else if( rc==1 && sqlite3Atoi64(pMem->z, &ix, pMem->n, pMem->enc)==0 ){
+    pMem->u.i = ix;
     return MEM_Int;
   }
   return MEM_Real;
 }
 
@@ -83904,14 +84295,19 @@
 **
 ** Unlike applyNumericAffinity(), this routine does not modify pMem->flags.
 ** But it does set pMem->u.r and pMem->u.i appropriately.
 */
 static u16 numericType(Mem *pMem){
-  if( pMem->flags & (MEM_Int|MEM_Real) ){
-    return pMem->flags & (MEM_Int|MEM_Real);
+  if( pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal) ){
+    testcase( pMem->flags & MEM_Int );
+    testcase( pMem->flags & MEM_Real );
+    testcase( pMem->flags & MEM_IntReal );
+    return pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal);
   }
   if( pMem->flags & (MEM_Str|MEM_Blob) ){
+    testcase( pMem->flags & MEM_Str );
+    testcase( pMem->flags & MEM_Blob );
     return computeNumericType(pMem);
   }
   return 0;
 }
 
@@ -83940,17 +84336,19 @@
       assert( (f & (MEM_Static|MEM_Dyn))==0 );
     }else{
       c = 's';
     }
     *(zCsr++) = c;
+    *(zCsr++) = 'x';
     sqlite3_snprintf(100, zCsr, "%d[", pMem->n);
     zCsr += sqlite3Strlen30(zCsr);
-    for(i=0; i<16 && i<pMem->n; i++){
+    for(i=0; i<25 && i<pMem->n; i++){
       sqlite3_snprintf(100, zCsr, "%02X", ((int)pMem->z[i] & 0xFF));
       zCsr += sqlite3Strlen30(zCsr);
     }
-    for(i=0; i<16 && i<pMem->n; i++){
+    *zCsr++ = '|';
+    for(i=0; i<25 && i<pMem->n; i++){
       char z = pMem->z[i];
       if( z<32 || z>126 ) *zCsr++ = '.';
       else *zCsr++ = z;
     }
     *(zCsr++) = ']';
@@ -83976,11 +84374,11 @@
     }
     k = 2;
     sqlite3_snprintf(100, &zBuf[k], "%d", pMem->n);
     k += sqlite3Strlen30(&zBuf[k]);
     zBuf[k++] = '[';
-    for(j=0; j<15 && j<pMem->n; j++){
+    for(j=0; j<25 && j<pMem->n; j++){
       u8 c = pMem->z[j];
       if( c>=0x20 && c<0x7f ){
         zBuf[k++] = c;
       }else{
         zBuf[k++] = '.';
@@ -84003,15 +84401,17 @@
     printf(" undefined");
   }else if( p->flags & MEM_Null ){
     printf(p->flags & MEM_Zero ? " NULL-nochng" : " NULL");
   }else if( (p->flags & (MEM_Int|MEM_Str))==(MEM_Int|MEM_Str) ){
     printf(" si:%lld", p->u.i);
+  }else if( (p->flags & (MEM_IntReal))!=0 ){
+    printf(" ir:%lld", p->u.i);
   }else if( p->flags & MEM_Int ){
     printf(" i:%lld", p->u.i);
 #ifndef SQLITE_OMIT_FLOATING_POINT
   }else if( p->flags & MEM_Real ){
-    printf(" r:%g", p->u.r);
+    printf(" r:%.17g", p->u.r);
 #endif
   }else if( sqlite3VdbeMemIsRowSet(p) ){
     printf(" (rowset)");
   }else{
     char zBuf[200];
@@ -84685,11 +85085,10 @@
 ** as the P1 parameter.
 */
 case OP_String8: {         /* same as TK_STRING, out2 */
   assert( pOp->p4.z!=0 );
   pOut = out2Prerelease(p, pOp);
-  pOp->opcode = OP_String;
   pOp->p1 = sqlite3Strlen30(pOp->p4.z);
 
 #ifndef SQLITE_OMIT_UTF16
   if( encoding!=SQLITE_UTF8 ){
     rc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, -1, SQLITE_UTF8, SQLITE_STATIC);
@@ -84709,10 +85108,11 @@
   }
 #endif
   if( pOp->p1>db->aLimit[SQLITE_LIMIT_LENGTH] ){
     goto too_big;
   }
+  pOp->opcode = OP_String;
   assert( rc==SQLITE_OK );
   /* Fall through to the next case, OP_String */
 }
 
 /* Opcode: String P1 P2 P3 P4 P5
@@ -85033,37 +85433,61 @@
 ** It is illegal for P1 and P3 to be the same register. Sometimes,
 ** if P3 is the same register as P2, the implementation is able
 ** to avoid a memcpy().
 */
 case OP_Concat: {           /* same as TK_CONCAT, in1, in2, out3 */
-  i64 nByte;
+  i64 nByte;          /* Total size of the output string or blob */
+  u16 flags1;         /* Initial flags for P1 */
+  u16 flags2;         /* Initial flags for P2 */
 
   pIn1 = &aMem[pOp->p1];
   pIn2 = &aMem[pOp->p2];
   pOut = &aMem[pOp->p3];
+  testcase( pIn1==pIn2 );
+  testcase( pOut==pIn2 );
   assert( pIn1!=pOut );
-  if( (pIn1->flags | pIn2->flags) & MEM_Null ){
+  flags1 = pIn1->flags;
+  testcase( flags1 & MEM_Null );
+  testcase( pIn2->flags & MEM_Null );
+  if( (flags1 | pIn2->flags) & MEM_Null ){
     sqlite3VdbeMemSetNull(pOut);
     break;
   }
-  if( ExpandBlob(pIn1) || ExpandBlob(pIn2) ) goto no_mem;
-  Stringify(pIn1, encoding);
-  Stringify(pIn2, encoding);
+  if( (flags1 & (MEM_Str|MEM_Blob))==0 ){
+    if( sqlite3VdbeMemStringify(pIn1,encoding,0) ) goto no_mem;
+    flags1 = pIn1->flags & ~MEM_Str;
+  }else if( (flags1 & MEM_Zero)!=0 ){
+    if( sqlite3VdbeMemExpandBlob(pIn1) ) goto no_mem;
+    flags1 = pIn1->flags & ~MEM_Str;
+  }
+  flags2 = pIn2->flags;
+  if( (flags2 & (MEM_Str|MEM_Blob))==0 ){
+    if( sqlite3VdbeMemStringify(pIn2,encoding,0) ) goto no_mem;
+    flags2 = pIn2->flags & ~MEM_Str;
+  }else if( (flags2 & MEM_Zero)!=0 ){
+    if( sqlite3VdbeMemExpandBlob(pIn2) ) goto no_mem;
+    flags2 = pIn2->flags & ~MEM_Str;
+  }
   nByte = pIn1->n + pIn2->n;
   if( nByte>db->aLimit[SQLITE_LIMIT_LENGTH] ){
     goto too_big;
   }
-  if( sqlite3VdbeMemGrow(pOut, (int)nByte+2, pOut==pIn2) ){
+  if( sqlite3VdbeMemGrow(pOut, (int)nByte+3, pOut==pIn2) ){
     goto no_mem;
   }
   MemSetTypeFlag(pOut, MEM_Str);
   if( pOut!=pIn2 ){
     memcpy(pOut->z, pIn2->z, pIn2->n);
+    assert( (pIn2->flags & MEM_Dyn) == (flags2 & MEM_Dyn) );
+    pIn2->flags = flags2;
   }
   memcpy(&pOut->z[pIn2->n], pIn1->z, pIn1->n);
+  assert( (pIn1->flags & MEM_Dyn) == (flags1 & MEM_Dyn) );
+  pIn1->flags = flags1;
   pOut->z[nByte]=0;
   pOut->z[nByte+1] = 0;
+  pOut->z[nByte+2] = 0;
   pOut->flags |= MEM_Term;
   pOut->n = (int)nByte;
   pOut->enc = encoding;
   UPDATE_MAX_BLOBSIZE(pOut);
   break;
@@ -85110,11 +85534,10 @@
 case OP_Add:                   /* same as TK_PLUS, in1, in2, out3 */
 case OP_Subtract:              /* same as TK_MINUS, in1, in2, out3 */
 case OP_Multiply:              /* same as TK_STAR, in1, in2, out3 */
 case OP_Divide:                /* same as TK_SLASH, in1, in2, out3 */
 case OP_Remainder: {           /* same as TK_REM, in1, in2, out3 */
-  char bIntint;   /* Started out as two integer operands */
   u16 flags;      /* Combined MEM_* flags from both inputs */
   u16 type1;      /* Numeric type of left operand */
   u16 type2;      /* Numeric type of right operand */
   i64 iA;         /* Integer value of left operand */
   i64 iB;         /* Integer value of right operand */
@@ -85128,11 +85551,10 @@
   pOut = &aMem[pOp->p3];
   flags = pIn1->flags | pIn2->flags;
   if( (type1 & type2 & MEM_Int)!=0 ){
     iA = pIn1->u.i;
     iB = pIn2->u.i;
-    bIntint = 1;
     switch( pOp->opcode ){
       case OP_Add:       if( sqlite3AddInt64(&iB,iA) ) goto fp_math;  break;
       case OP_Subtract:  if( sqlite3SubInt64(&iB,iA) ) goto fp_math;  break;
       case OP_Multiply:  if( sqlite3MulInt64(&iB,iA) ) goto fp_math;  break;
       case OP_Divide: {
@@ -85151,11 +85573,10 @@
     pOut->u.i = iB;
     MemSetTypeFlag(pOut, MEM_Int);
   }else if( (flags & MEM_Null)!=0 ){
     goto arithmetic_result_is_null;
   }else{
-    bIntint = 0;
 fp_math:
     rA = sqlite3VdbeRealValue(pIn1);
     rB = sqlite3VdbeRealValue(pIn2);
     switch( pOp->opcode ){
       case OP_Add:         rB += rA;       break;
@@ -85183,13 +85604,10 @@
     if( sqlite3IsNaN(rB) ){
       goto arithmetic_result_is_null;
     }
     pOut->u.r = rB;
     MemSetTypeFlag(pOut, MEM_Real);
-    if( ((type1|type2)&MEM_Real)==0 && !bIntint ){
-      sqlite3VdbeIntegerAffinity(pOut);
-    }
 #endif
   }
   break;
 
 arithmetic_result_is_null:
@@ -85354,12 +85772,15 @@
 ** integers, for space efficiency, but after extraction we want them
 ** to have only a real value.
 */
 case OP_RealAffinity: {                  /* in1 */
   pIn1 = &aMem[pOp->p1];
-  if( pIn1->flags & MEM_Int ){
+  if( pIn1->flags & (MEM_Int|MEM_IntReal) ){
+    testcase( pIn1->flags & MEM_Int );
+    testcase( pIn1->flags & MEM_IntReal );
     sqlite3VdbeMemRealify(pIn1);
+    REGISTER_TRACE(pOp->p1, pIn1);
   }
   break;
 }
 #endif
 
@@ -85546,21 +85967,21 @@
   }else{
     /* Neither operand is NULL.  Do a comparison. */
     affinity = pOp->p5 & SQLITE_AFF_MASK;
     if( affinity>=SQLITE_AFF_NUMERIC ){
       if( (flags1 | flags3)&MEM_Str ){
-        if( (flags1 & (MEM_Int|MEM_Real|MEM_Str))==MEM_Str ){
+        if( (flags1 & (MEM_Int|MEM_IntReal|MEM_Real|MEM_Str))==MEM_Str ){
           applyNumericAffinity(pIn1,0);
           assert( flags3==pIn3->flags );
           /* testcase( flags3!=pIn3->flags );
           ** this used to be possible with pIn1==pIn3, but not since
           ** the column cache was removed.  The following assignment
           ** is essentially a no-op.  But, it provides defense-in-depth
           ** in case our analysis is incorrect, so it is left in. */
           flags3 = pIn3->flags;
         }
-        if( (flags3 & (MEM_Int|MEM_Real|MEM_Str))==MEM_Str ){
+        if( (flags3 & (MEM_Int|MEM_IntReal|MEM_Real|MEM_Str))==MEM_Str ){
           applyNumericAffinity(pIn3,0);
         }
       }
       /* Handle the common case of integer comparison here, as an
       ** optimization, to avoid a call to sqlite3MemCompare() */
@@ -85569,21 +85990,23 @@
         if( pIn3->u.i < pIn1->u.i ){ res = -1; goto compare_op; }
         res = 0;
         goto compare_op;
       }
     }else if( affinity==SQLITE_AFF_TEXT ){
-      if( (flags1 & MEM_Str)==0 && (flags1 & (MEM_Int|MEM_Real))!=0 ){
+      if( (flags1 & MEM_Str)==0 && (flags1&(MEM_Int|MEM_Real|MEM_IntReal))!=0 ){
         testcase( pIn1->flags & MEM_Int );
         testcase( pIn1->flags & MEM_Real );
+        testcase( pIn1->flags & MEM_IntReal );
         sqlite3VdbeMemStringify(pIn1, encoding, 1);
         testcase( (flags1&MEM_Dyn) != (pIn1->flags&MEM_Dyn) );
         flags1 = (pIn1->flags & ~MEM_TypeMask) | (flags1 & MEM_TypeMask);
         assert( pIn1!=pIn3 );
       }
-      if( (flags3 & MEM_Str)==0 && (flags3 & (MEM_Int|MEM_Real))!=0 ){
+      if( (flags3 & MEM_Str)==0 && (flags3&(MEM_Int|MEM_Real|MEM_IntReal))!=0 ){
         testcase( pIn3->flags & MEM_Int );
         testcase( pIn3->flags & MEM_Real );
+        testcase( pIn3->flags & MEM_IntReal );
         sqlite3VdbeMemStringify(pIn3, encoding, 1);
         testcase( (flags3&MEM_Dyn) != (pIn3->flags&MEM_Dyn) );
         flags3 = (pIn3->flags & ~MEM_TypeMask) | (flags3 & MEM_TypeMask);
       }
     }
@@ -85749,13 +86172,18 @@
     assert( memIsValid(&aMem[p2+idx]) );
     REGISTER_TRACE(p1+idx, &aMem[p1+idx]);
     REGISTER_TRACE(p2+idx, &aMem[p2+idx]);
     assert( i<pKeyInfo->nKeyField );
     pColl = pKeyInfo->aColl[i];
-    bRev = pKeyInfo->aSortOrder[i];
+    bRev = (pKeyInfo->aSortFlags[i] & KEYINFO_ORDER_DESC);
     iCompare = sqlite3MemCompare(&aMem[p1+idx], &aMem[p2+idx], pColl);
     if( iCompare ){
+      if( (pKeyInfo->aSortFlags[i] & KEYINFO_ORDER_BIGNULL)
+       && ((aMem[p1+idx].flags & MEM_Null) || (aMem[p2+idx].flags & MEM_Null))
+      ){
+        iCompare = -iCompare;
+      }
       if( bRev ) iCompare = -iCompare;
       break;
     }
   }
   break;
@@ -86042,15 +86470,10 @@
 **
 ** If the record contains fewer than P2 fields, then extract a NULL.  Or,
 ** if the P4 argument is a P4_MEM use the value of the P4 argument as
 ** the result.
 **
-** If the OPFLAG_CLEARCACHE bit is set on P5 and P1 is a pseudo-table cursor,
-** then the cache of the cursor is reset prior to extracting the column.
-** The first OP_Column against a pseudo-table after the value of the content
-** register has changed should have this bit set.
-**
 ** If the OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG bits are set on P5 then
 ** the result is guaranteed to only be used as the argument of a length()
 ** or typeof() function, respectively.  The loading of large blobs can be
 ** skipped for length() and all content loading can be skipped for typeof().
 */
@@ -86335,16 +86758,37 @@
   zAffinity = pOp->p4.z;
   assert( zAffinity!=0 );
   assert( pOp->p2>0 );
   assert( zAffinity[pOp->p2]==0 );
   pIn1 = &aMem[pOp->p1];
-  do{
+  while( 1 /*exit-by-break*/ ){
     assert( pIn1 <= &p->aMem[(p->nMem+1 - p->nCursor)] );
     assert( memIsValid(pIn1) );
-    applyAffinity(pIn1, *(zAffinity++), encoding);
+    applyAffinity(pIn1, zAffinity[0], encoding);
+    if( zAffinity[0]==SQLITE_AFF_REAL && (pIn1->flags & MEM_Int)!=0 ){
+      /* When applying REAL affinity, if the result is still an MEM_Int
+      ** that will fit in 6 bytes, then change the type to MEM_IntReal
+      ** so that we keep the high-resolution integer value but know that
+      ** the type really wants to be REAL. */
+      testcase( pIn1->u.i==140737488355328LL );
+      testcase( pIn1->u.i==140737488355327LL );
+      testcase( pIn1->u.i==-140737488355328LL );
+      testcase( pIn1->u.i==-140737488355329LL );
+      if( pIn1->u.i<=140737488355327LL && pIn1->u.i>=-140737488355328LL ){
+        pIn1->flags |= MEM_IntReal;
+        pIn1->flags &= ~MEM_Int;
+      }else{
+        pIn1->u.r = (double)pIn1->u.i;
+        pIn1->flags |= MEM_Real;
+        pIn1->flags &= ~MEM_Int;
+      }
+    }
+    REGISTER_TRACE((int)(pIn1-aMem), pIn1);
+    zAffinity++;
+    if( zAffinity[0]==0 ) break;
     pIn1++;
-  }while( zAffinity[0] );
+  }
   break;
 }
 
 /* Opcode: MakeRecord P1 P2 P3 P4 *
 ** Synopsis: r[P3]=mkrec(r[P1@P2])
@@ -86361,11 +86805,10 @@
 ** macros defined in sqliteInt.h.
 **
 ** If P4 is NULL then all index fields have the affinity BLOB.
 */
 case OP_MakeRecord: {
-  u8 *zNewRecord;        /* A buffer to hold the data for the new record */
   Mem *pRec;             /* The new record */
   u64 nData;             /* Number of bytes of data space */
   int nHdr;              /* Number of bytes of header space */
   i64 nByte;             /* Data space required for this record */
   i64 nZero;             /* Number of zero bytes at the end of the record */
@@ -86374,13 +86817,13 @@
   Mem *pData0;           /* First field to be combined into the record */
   Mem *pLast;            /* Last field of the record */
   int nField;            /* Number of fields in the record */
   char *zAffinity;       /* The affinity string for the record */
   int file_format;       /* File format to use for encoding */
-  int i;                 /* Space used in zNewRecord[] header */
-  int j;                 /* Space used in zNewRecord[] content */
   u32 len;               /* Length of a field */
+  u8 *zHdr;              /* Where to write next byte of the header */
+  u8 *zPayload;          /* Where to write next byte of the payload */
 
   /* Assuming the record contains N fields, the record format looks
   ** like this:
   **
   ** ------------------------------------------------------------------------
@@ -86415,11 +86858,18 @@
   */
   assert( pData0<=pLast );
   if( zAffinity ){
     pRec = pData0;
     do{
-      applyAffinity(pRec++, *(zAffinity++), encoding);
+      applyAffinity(pRec, zAffinity[0], encoding);
+      if( zAffinity[0]==SQLITE_AFF_REAL && (pRec->flags & MEM_Int) ){
+        pRec->flags |= MEM_IntReal;
+        pRec->flags &= ~(MEM_Int);
+      }
+      REGISTER_TRACE((int)(pRec-aMem), pRec);
+      zAffinity++;
+      pRec++;
       assert( zAffinity[0]==0 || pRec<=pLast );
     }while( zAffinity[0] );
   }
 
 #ifdef SQLITE_ENABLE_NULL_TRIM
@@ -86435,38 +86885,124 @@
     }
   }
 #endif
 
   /* Loop through the elements that will make up the record to figure
-  ** out how much space is required for the new record.
+  ** out how much space is required for the new record.  After this loop,
+  ** the Mem.uTemp field of each term should hold the serial-type that will
+  ** be used for that term in the generated record:
+  **
+  **   Mem.uTemp value    type
+  **   ---------------    ---------------
+  **      0               NULL
+  **      1               1-byte signed integer
+  **      2               2-byte signed integer
+  **      3               3-byte signed integer
+  **      4               4-byte signed integer
+  **      5               6-byte signed integer
+  **      6               8-byte signed integer
+  **      7               IEEE float
+  **      8               Integer constant 0
+  **      9               Integer constant 1
+  **     10,11            reserved for expansion
+  **    N>=12 and even    BLOB
+  **    N>=13 and odd     text
+  **
+  ** The following additional values are computed:
+  **     nHdr        Number of bytes needed for the record header
+  **     nData       Number of bytes of data space needed for the record
+  **     nZero       Zero bytes at the end of the record
   */
   pRec = pLast;
   do{
     assert( memIsValid(pRec) );
-    serial_type = sqlite3VdbeSerialType(pRec, file_format, &len);
-    if( pRec->flags & MEM_Zero ){
-      if( serial_type==0 ){
+    if( pRec->flags & MEM_Null ){
+      if( pRec->flags & MEM_Zero ){
         /* Values with MEM_Null and MEM_Zero are created by xColumn virtual
         ** table methods that never invoke sqlite3_result_xxxxx() while
         ** computing an unchanging column value in an UPDATE statement.
         ** Give such values a special internal-use-only serial-type of 10
         ** so that they can be passed through to xUpdate and have
         ** a true sqlite3_value_nochange(). */
         assert( pOp->p5==OPFLAG_NOCHNG_MAGIC || CORRUPT_DB );
-        serial_type = 10;
-      }else if( nData ){
-        if( sqlite3VdbeMemExpandBlob(pRec) ) goto no_mem;
+        pRec->uTemp = 10;
+      }else{
+        pRec->uTemp = 0;
+      }
+      nHdr++;
+    }else if( pRec->flags & (MEM_Int|MEM_IntReal) ){
+      /* Figure out whether to use 1, 2, 4, 6 or 8 bytes. */
+      i64 i = pRec->u.i;
+      u64 uu;
+      testcase( pRec->flags & MEM_Int );
+      testcase( pRec->flags & MEM_IntReal );
+      if( i<0 ){
+        uu = ~i;
+      }else{
+        uu = i;
+      }
+      nHdr++;
+      testcase( uu==127 );               testcase( uu==128 );
+      testcase( uu==32767 );             testcase( uu==32768 );
+      testcase( uu==8388607 );           testcase( uu==8388608 );
+      testcase( uu==2147483647 );        testcase( uu==2147483648 );
+      testcase( uu==140737488355327LL ); testcase( uu==140737488355328LL );
+      if( uu<=127 ){
+        if( (i&1)==i && file_format>=4 ){
+          pRec->uTemp = 8+(u32)uu;
+        }else{
+          nData++;
+          pRec->uTemp = 1;
+        }
+      }else if( uu<=32767 ){
+        nData += 2;
+        pRec->uTemp = 2;
+      }else if( uu<=8388607 ){
+        nData += 3;
+        pRec->uTemp = 3;
+      }else if( uu<=2147483647 ){
+        nData += 4;
+        pRec->uTemp = 4;
+      }else if( uu<=140737488355327LL ){
+        nData += 6;
+        pRec->uTemp = 5;
       }else{
-        nZero += pRec->u.nZero;
-        len -= pRec->u.nZero;
+        nData += 8;
+        if( pRec->flags & MEM_IntReal ){
+          /* If the value is IntReal and is going to take up 8 bytes to store
+          ** as an integer, then we might as well make it an 8-byte floating
+          ** point value */
+          pRec->u.r = (double)pRec->u.i;
+          pRec->flags &= ~MEM_IntReal;
+          pRec->flags |= MEM_Real;
+          pRec->uTemp = 7;
+        }else{
+          pRec->uTemp = 6;
+        }
+      }
+    }else if( pRec->flags & MEM_Real ){
+      nHdr++;
+      nData += 8;
+      pRec->uTemp = 7;
+    }else{
+      assert( db->mallocFailed || pRec->flags&(MEM_Str|MEM_Blob) );
+      assert( pRec->n>=0 );
+      len = (u32)pRec->n;
+      serial_type = (len*2) + 12 + ((pRec->flags & MEM_Str)!=0);
+      if( pRec->flags & MEM_Zero ){
+        serial_type += pRec->u.nZero*2;
+        if( nData ){
+          if( sqlite3VdbeMemExpandBlob(pRec) ) goto no_mem;
+          len += pRec->u.nZero;
+        }else{
+          nZero += pRec->u.nZero;
+        }
       }
+      nData += len;
+      nHdr += sqlite3VarintLen(serial_type);
+      pRec->uTemp = serial_type;
     }
-    nData += len;
-    testcase( serial_type==127 );
-    testcase( serial_type==128 );
-    nHdr += serial_type<=127 ? 1 : sqlite3VarintLen(serial_type);
-    pRec->uTemp = serial_type;
     if( pRec==pData0 ) break;
     pRec--;
   }while(1);
 
   /* EVIDENCE-OF: R-22564-11647 The header begins with a single varint
@@ -86503,38 +87039,38 @@
     }
     if( sqlite3VdbeMemClearAndResize(pOut, (int)nByte) ){
       goto no_mem;
     }
   }
-  zNewRecord = (u8 *)pOut->z;
+  pOut->n = (int)nByte;
+  pOut->flags = MEM_Blob;
+  if( nZero ){
+    pOut->u.nZero = nZero;
+    pOut->flags |= MEM_Zero;
+  }
+  UPDATE_MAX_BLOBSIZE(pOut);
+  zHdr = (u8 *)pOut->z;
+  zPayload = zHdr + nHdr;
 
   /* Write the record */
-  i = putVarint32(zNewRecord, nHdr);
-  j = nHdr;
+  zHdr += putVarint32(zHdr, nHdr);
   assert( pData0<=pLast );
   pRec = pData0;
   do{
     serial_type = pRec->uTemp;
     /* EVIDENCE-OF: R-06529-47362 Following the size varint are one or more
     ** additional varints, one per column. */
-    i += putVarint32(&zNewRecord[i], serial_type);            /* serial type */
+    zHdr += putVarint32(zHdr, serial_type);            /* serial type */
     /* EVIDENCE-OF: R-64536-51728 The values for each column in the record
     ** immediately follow the header. */
-    j += sqlite3VdbeSerialPut(&zNewRecord[j], pRec, serial_type); /* content */
+    zPayload += sqlite3VdbeSerialPut(zPayload, pRec, serial_type); /* content */
   }while( (++pRec)<=pLast );
-  assert( i==nHdr );
-  assert( j==nByte );
+  assert( nHdr==(int)(zHdr - (u8*)pOut->z) );
+  assert( nByte==(int)(zPayload - (u8*)pOut->z) );
 
   assert( pOp->p3>0 && pOp->p3<=(p->nMem+1 - p->nCursor) );
-  pOut->n = (int)nByte;
-  pOut->flags = MEM_Blob;
-  if( nZero ){
-    pOut->u.nZero = nZero;
-    pOut->flags |= MEM_Zero;
-  }
   REGISTER_TRACE(pOp->p3, pOut);
-  UPDATE_MAX_BLOBSIZE(pOut);
   break;
 }
 
 /* Opcode: Count P1 P2 * * *
 ** Synopsis: r[P2]=count()
@@ -86560,12 +87096,13 @@
 #endif
 
 /* Opcode: Savepoint P1 * * P4 *
 **
 ** Open, release or rollback the savepoint named by parameter P4, depending
-** on the value of P1. To open a new savepoint, P1==0. To release (commit) an
-** existing savepoint, P1==1, or to rollback an existing savepoint P1==2.
+** on the value of P1. To open a new savepoint set P1==0 (SAVEPOINT_BEGIN).
+** To release (commit) an existing savepoint set P1==1 (SAVEPOINT_RELEASE).
+** To rollback an existing savepoint set P1==2 (SAVEPOINT_ROLLBACK).
 */
 case OP_Savepoint: {
   int p1;                         /* Value of P1 operand */
   char *zName;                    /* Name of savepoint */
   int nName;
@@ -86629,10 +87166,11 @@
         pNew->nDeferredCons = db->nDeferredCons;
         pNew->nDeferredImmCons = db->nDeferredImmCons;
       }
     }
   }else{
+    assert( p1==SAVEPOINT_RELEASE || p1==SAVEPOINT_ROLLBACK );
     iSavepoint = 0;
 
     /* Find the named savepoint. If there is no such savepoint, then an
     ** an error is returned to the user.  */
     for(
@@ -86682,10 +87220,11 @@
                                        SQLITE_ABORT_ROLLBACK,
                                        isSchemaChange==0);
             if( rc!=SQLITE_OK ) goto abort_due_to_error;
           }
         }else{
+          assert( p1==SAVEPOINT_RELEASE );
           isSchemaChange = 0;
         }
         for(ii=0; ii<db->nDb; ii++){
           rc = sqlite3BtreeSavepoint(db->aDb[ii].pBt, p1, iSavepoint);
           if( rc!=SQLITE_OK ){
@@ -86718,10 +87257,11 @@
         sqlite3DbFree(db, pSavepoint);
         if( !isTransaction ){
           db->nSavepoint--;
         }
       }else{
+        assert( p1==SAVEPOINT_ROLLBACK );
         db->nDeferredCons = pSavepoint->nDeferredCons;
         db->nDeferredImmCons = pSavepoint->nDeferredImmCons;
       }
 
       if( !isTransaction || p1==SAVEPOINT_ROLLBACK ){
@@ -86794,11 +87334,11 @@
                    "cannot commit - no transaction is active"));
 
     rc = SQLITE_ERROR;
     goto abort_due_to_error;
   }
-  break;
+  /*NOTREACHED*/ assert(0);
 }
 
 /* Opcode: Transaction P1 P2 P3 P4 P5
 **
 ** Begin a transaction on database P1 if a transaction is not already
@@ -87256,15 +87796,19 @@
   assert( pOp->p2>=0 );
   pCx = p->apCsr[pOp->p1];
   if( pCx ){
     /* If the ephermeral table is already open, erase all existing content
     ** so that the table is empty again, rather than creating a new table. */
-    rc = sqlite3BtreeClearTable(pCx->pBtx, pCx->pgnoRoot, 0);
+    assert( pCx->isEphemeral );
+    pCx->seqCount = 0;
+    pCx->cacheStatus = CACHE_STALE;
+    if( pCx->pBtx ){
+      rc = sqlite3BtreeClearTable(pCx->pBtx, pCx->pgnoRoot, 0);
+    }
   }else{
     pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, CURTYPE_BTREE);
     if( pCx==0 ) goto no_mem;
-    pCx->nullRow = 1;
     pCx->isEphemeral = 1;
     rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->pBtx,
                           BTREE_OMIT_JOURNAL | BTREE_SINGLE | pOp->p5,
                           vfsFlags);
     if( rc==SQLITE_OK ){
@@ -87296,10 +87840,11 @@
       }
     }
     pCx->isOrdered = (pOp->p5!=BTREE_UNORDERED);
   }
   if( rc ) goto abort_due_to_error;
+  pCx->nullRow = 1;
   break;
 }
 
 /* Opcode: SorterOpen P1 P2 P3 P4 *
 **
@@ -87524,33 +88069,43 @@
   pC->nullRow = 0;
 #ifdef SQLITE_DEBUG
   pC->seekOp = pOp->opcode;
 #endif
 
+  pC->deferredMoveto = 0;
+  pC->cacheStatus = CACHE_STALE;
   if( pC->isTable ){
+    u16 flags3, newType;
     /* The BTREE_SEEK_EQ flag is only set on index cursors */
     assert( sqlite3BtreeCursorHasHint(pC->uc.pCursor, BTREE_SEEK_EQ)==0
               || CORRUPT_DB );
 
     /* The input value in P3 might be of any type: integer, real, string,
     ** blob, or NULL.  But it needs to be an integer before we can do
     ** the seek, so convert it. */
     pIn3 = &aMem[pOp->p3];
-    if( (pIn3->flags & (MEM_Int|MEM_Real|MEM_Str))==MEM_Str ){
+    flags3 = pIn3->flags;
+    if( (flags3 & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Str))==MEM_Str ){
       applyNumericAffinity(pIn3, 0);
     }
-    iKey = sqlite3VdbeIntValue(pIn3);
+    iKey = sqlite3VdbeIntValue(pIn3); /* Get the integer key value */
+    newType = pIn3->flags; /* Record the type after applying numeric affinity */
+    pIn3->flags = flags3;  /* But convert the type back to its original */
 
     /* If the P3 value could not be converted into an integer without
     ** loss of information, then special processing is required... */
-    if( (pIn3->flags & MEM_Int)==0 ){
-      if( (pIn3->flags & MEM_Real)==0 ){
-        /* If the P3 value cannot be converted into any kind of a number,
-        ** then the seek is not possible, so jump to P2 */
-        VdbeBranchTaken(1,2); goto jump_to_p2;
-        break;
-      }
+    if( (newType & (MEM_Int|MEM_IntReal))==0 ){
+      if( (newType & MEM_Real)==0 ){
+        if( (newType & MEM_Null) || oc>=OP_SeekGE ){
+          VdbeBranchTaken(1,2);
+          goto jump_to_p2;
+        }else{
+          rc = sqlite3BtreeLast(pC->uc.pCursor, &res);
+          if( rc!=SQLITE_OK ) goto abort_due_to_error;
+          goto seek_not_found;
+        }
+      }else
 
       /* If the approximation iKey is larger than the actual real search
       ** term, substitute >= for > and < for <=. e.g. if the search term
       ** is 4.9 and the integer approximation 5:
       **
@@ -87624,12 +88179,10 @@
     if( eqOnly && r.eqSeen==0 ){
       assert( res!=0 );
       goto seek_not_found;
     }
   }
-  pC->deferredMoveto = 0;
-  pC->cacheStatus = CACHE_STALE;
 #ifdef SQLITE_TEST
   sqlite3_search_count++;
 #endif
   if( oc>=OP_SeekGE ){  assert( oc==OP_SeekGE || oc==OP_SeekGT );
     if( res<0 || (res==0 && oc==OP_SeekGT) ){
@@ -87925,38 +88478,43 @@
   BtCursor *pCrsr;
   int res;
   u64 iKey;
 
   pIn3 = &aMem[pOp->p3];
-  if( (pIn3->flags & MEM_Int)==0 ){
-    /* Make sure pIn3->u.i contains a valid integer representation of
-    ** the key value, but do not change the datatype of the register, as
-    ** other parts of the perpared statement might be depending on the
-    ** current datatype. */
-    u16 origFlags = pIn3->flags;
-    int isNotInt;
-    applyAffinity(pIn3, SQLITE_AFF_NUMERIC, encoding);
-    isNotInt = (pIn3->flags & MEM_Int)==0;
-    pIn3->flags = origFlags;
-    if( isNotInt ) goto jump_to_p2;
+  testcase( pIn3->flags & MEM_Int );
+  testcase( pIn3->flags & MEM_IntReal );
+  testcase( pIn3->flags & MEM_Real );
+  testcase( (pIn3->flags & (MEM_Str|MEM_Int))==MEM_Str );
+  if( (pIn3->flags & (MEM_Int|MEM_IntReal))==0 ){
+    /* If pIn3->u.i does not contain an integer, compute iKey as the
+    ** integer value of pIn3.  Jump to P2 if pIn3 cannot be converted
+    ** into an integer without loss of information.  Take care to avoid
+    ** changing the datatype of pIn3, however, as it is used by other
+    ** parts of the prepared statement. */
+    Mem x = pIn3[0];
+    applyAffinity(&x, SQLITE_AFF_NUMERIC, encoding);
+    if( (x.flags & MEM_Int)==0 ) goto jump_to_p2;
+    iKey = x.u.i;
+    goto notExistsWithKey;
   }
   /* Fall through into OP_NotExists */
 case OP_NotExists:          /* jump, in3 */
   pIn3 = &aMem[pOp->p3];
   assert( (pIn3->flags & MEM_Int)!=0 || pOp->opcode==OP_SeekRowid );
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
+  iKey = pIn3->u.i;
+notExistsWithKey:
   pC = p->apCsr[pOp->p1];
   assert( pC!=0 );
 #ifdef SQLITE_DEBUG
   if( pOp->opcode==OP_SeekRowid ) pC->seekOp = OP_SeekRowid;
 #endif
   assert( pC->isTable );
   assert( pC->eCurType==CURTYPE_BTREE );
   pCrsr = pC->uc.pCursor;
   assert( pCrsr!=0 );
   res = 0;
-  iKey = pIn3->u.i;
   rc = sqlite3BtreeMovetoUnpacked(pCrsr, 0, iKey, 0, &res);
   assert( rc==SQLITE_OK || res==0 );
   pC->movetoTarget = iKey;  /* Used by OP_Delete */
   pC->nullRow = 0;
   pC->cacheStatus = CACHE_STALE;
@@ -88300,11 +88858,11 @@
   if( pOp->p4type==P4_TABLE && HasRowid(pOp->p4.pTab) && pOp->p5==0 ){
     /* If p5 is zero, the seek operation that positioned the cursor prior to
     ** OP_Delete will have also set the pC->movetoTarget field to the rowid of
     ** the row that is being deleted */
     i64 iKey = sqlite3BtreeIntegerKey(pC->uc.pCursor);
-    assert( pC->movetoTarget==iKey );
+    assert( CORRUPT_DB || pC->movetoTarget==iKey );
   }
 #endif
 
   /* If the update-hook or pre-update-hook will be invoked, set zDb to
   ** the name of the db to pass as to it. Also set local pTab to a copy
@@ -88835,14 +89393,15 @@
   /* The Next opcode is only used after SeekGT, SeekGE, Rewind, and Found.
   ** The Prev opcode is only used after SeekLT, SeekLE, and Last. */
   assert( pOp->opcode!=OP_Next
        || pC->seekOp==OP_SeekGT || pC->seekOp==OP_SeekGE
        || pC->seekOp==OP_Rewind || pC->seekOp==OP_Found
-       || pC->seekOp==OP_NullRow|| pC->seekOp==OP_SeekRowid);
+       || pC->seekOp==OP_NullRow|| pC->seekOp==OP_SeekRowid
+       || pC->seekOp==OP_IfNoHope);
   assert( pOp->opcode!=OP_Prev
        || pC->seekOp==OP_SeekLT || pC->seekOp==OP_SeekLE
-       || pC->seekOp==OP_Last
+       || pC->seekOp==OP_Last   || pC->seekOp==OP_IfNoHope
        || pC->seekOp==OP_NullRow);
 
   rc = pOp->p4.xAdvance(pC->uc.pCursor, pOp->p3);
 next_tail:
   pC->cacheStatus = CACHE_STALE;
@@ -89357,11 +89916,11 @@
     initData.db = db;
     initData.iDb = iDb;
     initData.pzErrMsg = &p->zErrMsg;
     initData.mInitFlags = 0;
     zSql = sqlite3MPrintf(db,
-       "SELECT name, rootpage, sql FROM '%q'.%s WHERE %s ORDER BY rowid",
+       "SELECT*FROM\"%w\".%s WHERE %s ORDER BY rowid",
        db->aDb[iDb].zDbSName, zMaster, pOp->p4.z);
     if( zSql==0 ){
       rc = SQLITE_NOMEM_BKPT;
     }else{
       assert( db->init.busy==0 );
@@ -91564,15 +92123,16 @@
   Incrblob *p = (Incrblob *)pBlob;
   int rc;
   sqlite3 *db;
 
   if( p ){
+    sqlite3_stmt *pStmt = p->pStmt;
     db = p->db;
     sqlite3_mutex_enter(db->mutex);
-    rc = sqlite3_finalize(p->pStmt);
     sqlite3DbFree(db, p);
     sqlite3_mutex_leave(db->mutex);
+    rc = sqlite3_finalize(pStmt);
   }else{
     rc = SQLITE_OK;
   }
   return rc;
 }
@@ -92548,11 +93108,12 @@
       res = vdbeSorterCompareTail(
           pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2
       );
     }
   }else{
-    if( pTask->pSorter->pKeyInfo->aSortOrder[0] ){
+    assert( !(pTask->pSorter->pKeyInfo->aSortFlags[0]&KEYINFO_ORDER_BIGNULL) );
+    if( pTask->pSorter->pKeyInfo->aSortFlags[0] ){
       res = res * -1;
     }
   }
 
   return res;
@@ -92616,11 +93177,12 @@
     if( pTask->pSorter->pKeyInfo->nKeyField>1 ){
       res = vdbeSorterCompareTail(
           pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2
       );
     }
-  }else if( pTask->pSorter->pKeyInfo->aSortOrder[0] ){
+  }else if( pTask->pSorter->pKeyInfo->aSortFlags[0] ){
+    assert( !(pTask->pSorter->pKeyInfo->aSortFlags[0]&KEYINFO_ORDER_BIGNULL) );
     res = res * -1;
   }
 
   return res;
 }
@@ -92731,10 +93293,11 @@
       }
     }
 
     if( pKeyInfo->nAllField<13
      && (pKeyInfo->aColl[0]==0 || pKeyInfo->aColl[0]==db->pDfltColl)
+     && (pKeyInfo->aSortFlags[0] & KEYINFO_ORDER_BIGNULL)==0
     ){
       pSorter->typeMask = SORTER_TYPE_INTEGER | SORTER_TYPE_TEXT;
     }
   }
 
@@ -93447,17 +94010,20 @@
     if( i==nWorker ){
       /* Use the foreground thread for this operation */
       rc = vdbeSorterListToPMA(&pSorter->aTask[nWorker], &pSorter->list);
     }else{
       /* Launch a background thread for this operation */
-      u8 *aMem = pTask->list.aMemory;
-      void *pCtx = (void*)pTask;
+      u8 *aMem;
+      void *pCtx;
 
+      assert( pTask!=0 );
       assert( pTask->pThread==0 && pTask->bDone==0 );
       assert( pTask->list.pList==0 );
       assert( pTask->list.aMemory==0 || pSorter->list.aMemory!=0 );
 
+      aMem = pTask->list.aMemory;
+      pCtx = (void*)pTask;
       pSorter->iPrev = (u8)(pTask - pSorter->aTask);
       pTask->list = pSorter->list;
       pSorter->list.pList = 0;
       pSorter->list.szPMA = 0;
       if( aMem ){
@@ -94577,18 +95143,13 @@
   u8 *zOut = zBuf;
   int nRead = iAmt;
   int iChunkOffset;
   FileChunk *pChunk;
 
-#if defined(SQLITE_ENABLE_ATOMIC_WRITE) \
- || defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)
   if( (iAmt+iOfst)>p->endpoint.iOffset ){
     return SQLITE_IOERR_SHORT_READ;
   }
-#endif
-
-  assert( (iAmt+iOfst)<=p->endpoint.iOffset );
   assert( p->readpoint.iOffset==0 || p->readpoint.pChunk!=0 );
   if( p->readpoint.iOffset!=iOfst || iOfst==0 ){
     sqlite3_int64 iOff = 0;
     for(pChunk=p->pFirst;
         ALWAYS(pChunk) && (iOff+p->nChunkSize)<=iOfst;
@@ -94943,13 +95504,26 @@
 ** as the second argument.
 */
 static int walkWindowList(Walker *pWalker, Window *pList){
   Window *pWin;
   for(pWin=pList; pWin; pWin=pWin->pNextWin){
-    if( sqlite3WalkExprList(pWalker, pWin->pOrderBy) ) return WRC_Abort;
-    if( sqlite3WalkExprList(pWalker, pWin->pPartition) ) return WRC_Abort;
-    if( sqlite3WalkExpr(pWalker, pWin->pFilter) ) return WRC_Abort;
+    int rc;
+    rc = sqlite3WalkExprList(pWalker, pWin->pOrderBy);
+    if( rc ) return WRC_Abort;
+    rc = sqlite3WalkExprList(pWalker, pWin->pPartition);
+    if( rc ) return WRC_Abort;
+    rc = sqlite3WalkExpr(pWalker, pWin->pFilter);
+    if( rc ) return WRC_Abort;
+
+    /* The next two are purely for calls to sqlite3RenameExprUnmap()
+    ** within sqlite3WindowOffsetExpr().  Because of constraints imposed
+    ** by sqlite3WindowOffsetExpr(), they can never fail.  The results do
+    ** not matter anyhow. */
+    rc = sqlite3WalkExpr(pWalker, pWin->pStart);
+    if( NEVER(rc) ) return WRC_Abort;
+    rc = sqlite3WalkExpr(pWalker, pWin->pEnd);
+    if( NEVER(rc) ) return WRC_Abort;
   }
   return WRC_Continue;
 }
 #endif
 
@@ -94981,22 +95555,26 @@
     if( rc ) return rc & WRC_Abort;
     if( !ExprHasProperty(pExpr,(EP_TokenOnly|EP_Leaf)) ){
       if( pExpr->pLeft && walkExpr(pWalker, pExpr->pLeft) ) return WRC_Abort;
        assert( pExpr->x.pList==0 || pExpr->pRight==0 );
       if( pExpr->pRight ){
+        assert( !ExprHasProperty(pExpr, EP_WinFunc) );
         pExpr = pExpr->pRight;
         continue;
       }else if( ExprHasProperty(pExpr, EP_xIsSelect) ){
+        assert( !ExprHasProperty(pExpr, EP_WinFunc) );
         if( sqlite3WalkSelect(pWalker, pExpr->x.pSelect) ) return WRC_Abort;
-      }else if( pExpr->x.pList ){
-        if( sqlite3WalkExprList(pWalker, pExpr->x.pList) ) return WRC_Abort;
-      }
+      }else{
+        if( pExpr->x.pList ){
+          if( sqlite3WalkExprList(pWalker, pExpr->x.pList) ) return WRC_Abort;
+        }
 #ifndef SQLITE_OMIT_WINDOWFUNC
-      if( ExprHasProperty(pExpr, EP_WinFunc) ){
-        if( walkWindowList(pWalker, pExpr->y.pWin) ) return WRC_Abort;
-      }
+        if( ExprHasProperty(pExpr, EP_WinFunc) ){
+          if( walkWindowList(pWalker, pExpr->y.pWin) ) return WRC_Abort;
+        }
 #endif
+      }
     }
     break;
   }
   return WRC_Continue;
 }
@@ -95034,12 +95612,13 @@
   if( sqlite3WalkExpr(pWalker, p->pLimit) ) return WRC_Abort;
 #if !defined(SQLITE_OMIT_WINDOWFUNC) && !defined(SQLITE_OMIT_ALTERTABLE)
   {
     Parse *pParse = pWalker->pParse;
     if( pParse && IN_RENAME_OBJECT ){
+      /* The following may return WRC_Abort if there are unresolvable
+      ** symbols (e.g. a table that does not exist) in a window definition. */
       int rc = walkWindowList(pWalker, p->pWinDefn);
-      assert( rc==WRC_Continue );
       return rc;
     }
   }
 #endif
   return WRC_Continue;
@@ -95207,10 +95786,17 @@
     if( !ExprHasProperty(pExpr, EP_IntValue) && pExpr->u.zToken!=0 ){
       assert( (pExpr->flags & (EP_Reduced|EP_TokenOnly))==0 );
       pExpr->u.zToken = sqlite3DbStrDup(db, pExpr->u.zToken);
       pExpr->flags |= EP_MemToken;
     }
+    if( ExprHasProperty(pExpr, EP_WinFunc) ){
+      if( pExpr->y.pWin!=0 ){
+        pExpr->y.pWin->pOwner = pExpr;
+      }else{
+        assert( db->mallocFailed );
+      }
+    }
     sqlite3DbFree(db, pDup);
   }
   ExprSetProperty(pExpr, EP_Alias);
 }
 
@@ -95259,10 +95845,27 @@
     return 0;
   }
   return 1;
 }
 
+/*
+** Return TRUE if the double-quoted string  mis-feature should be supported.
+*/
+static int areDoubleQuotedStringsEnabled(sqlite3 *db, NameContext *pTopNC){
+  if( db->init.busy ) return 1;  /* Always support for legacy schemas */
+  if( pTopNC->ncFlags & NC_IsDDL ){
+    /* Currently parsing a DDL statement */
+    if( sqlite3WritableSchema(db) && (db->flags & SQLITE_DqsDML)!=0 ){
+      return 1;
+    }
+    return (db->flags & SQLITE_DqsDDL)!=0;
+  }else{
+    /* Currently parsing a DML statement */
+    return (db->flags & SQLITE_DqsDML)!=0;
+  }
+}
+
 /*
 ** Given the name of a column of the form X.Y.Z or Y.Z or just Z, look up
 ** that name in the set of source tables in pSrcList and make the pExpr
 ** expression node refer back to that source column.  The following changes
 ** are made to pExpr:
@@ -95475,11 +96078,11 @@
           }else
 #endif /* SQLITE_OMIT_UPSERT */
           {
 #ifndef SQLITE_OMIT_TRIGGER
             if( iCol<0 ){
-              pExpr->affinity = SQLITE_AFF_INTEGER;
+              pExpr->affExpr = SQLITE_AFF_INTEGER;
             }else if( pExpr->iTable==0 ){
               testcase( iCol==31 );
               testcase( iCol==32 );
               pParse->oldmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));
             }else{
@@ -95507,11 +96110,11 @@
      && sqlite3IsRowid(zCol)
      && VisibleRowid(pMatch->pTab)
     ){
       cnt = 1;
       pExpr->iColumn = -1;
-      pExpr->affinity = SQLITE_AFF_INTEGER;
+      pExpr->affExpr = SQLITE_AFF_INTEGER;
     }
 
     /*
     ** If the input is of the form Z (not Y.Z or X.Y.Z) then the name Z
     ** might refer to an result-set alias.  This happens, for example, when
@@ -95587,11 +96190,13 @@
   ** Because no reference was made to outer contexts, the pNC->nRef
   ** fields are not changed in any context.
   */
   if( cnt==0 && zTab==0 ){
     assert( pExpr->op==TK_ID );
-    if( ExprHasProperty(pExpr,EP_DblQuoted) ){
+    if( ExprHasProperty(pExpr,EP_DblQuoted)
+     && areDoubleQuotedStringsEnabled(db, pTopNC)
+    ){
       /* If a double-quoted identifier does not match any known column name,
       ** then treat it as a string.
       **
       ** This hack was added in the early days of SQLite in a misguided attempt
       ** to be compatible with MySQL 3.x, which used double-quotes for strings.
@@ -95781,11 +96386,11 @@
       assert( HasRowid(pItem->pTab) && pItem->pTab->pSelect==0 );
       pExpr->op = TK_COLUMN;
       pExpr->y.pTab = pItem->pTab;
       pExpr->iTable = pItem->iCursor;
       pExpr->iColumn = -1;
-      pExpr->affinity = SQLITE_AFF_INTEGER;
+      pExpr->affExpr = SQLITE_AFF_INTEGER;
       break;
     }
 #endif /* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT)
           && !defined(SQLITE_OMIT_SUBQUERY) */
 
@@ -95841,11 +96446,13 @@
       int nId;                    /* Number of characters in function name */
       const char *zId;            /* The function name. */
       FuncDef *pDef;              /* Information about the function */
       u8 enc = ENC(pParse->db);   /* The database encoding */
       int savedAllowFlags = (pNC->ncFlags & (NC_AllowAgg | NC_AllowWin));
-
+#ifndef SQLITE_OMIT_WINDOWFUNC
+      Window *pWin = (IsWindowFunc(pExpr) ? pExpr->y.pWin : 0);
+#endif
       assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
       zId = pExpr->u.zToken;
       nId = sqlite3Strlen30(zId);
       pDef = sqlite3FindFunction(pParse->db, zId, n, enc, 0);
       if( pDef==0 ){
@@ -95856,11 +96463,11 @@
           wrong_num_args = 1;
         }
       }else{
         is_agg = pDef->xFinalize!=0;
         if( pDef->funcFlags & SQLITE_FUNC_UNLIKELY ){
-          ExprSetProperty(pExpr, EP_Unlikely|EP_Skip);
+          ExprSetProperty(pExpr, EP_Unlikely);
           if( n==2 ){
             pExpr->iTable = exprProbability(pList->a[1].pExpr);
             if( pExpr->iTable<0 ){
               sqlite3ErrorMsg(pParse,
                 "second argument to likelihood() must be a "
@@ -95913,31 +96520,40 @@
         ){
           /* Internal-use-only functions are disallowed unless the
           ** SQL is being compiled using sqlite3NestedParse() */
           no_such_func = 1;
           pDef = 0;
+        }else
+        if( (pDef->funcFlags & SQLITE_FUNC_DIRECT)!=0
+         && ExprHasProperty(pExpr, EP_Indirect)
+         && !IN_RENAME_OBJECT
+        ){
+          /* Functions tagged with SQLITE_DIRECTONLY may not be used
+          ** inside of triggers and views */
+          sqlite3ErrorMsg(pParse, "%s() prohibited in triggers and views",
+                          pDef->zName);
         }
       }
 
       if( 0==IN_RENAME_OBJECT ){
 #ifndef SQLITE_OMIT_WINDOWFUNC
         assert( is_agg==0 || (pDef->funcFlags & SQLITE_FUNC_MINMAX)
           || (pDef->xValue==0 && pDef->xInverse==0)
           || (pDef->xValue && pDef->xInverse && pDef->xSFunc && pDef->xFinalize)
         );
-        if( pDef && pDef->xValue==0 && ExprHasProperty(pExpr, EP_WinFunc) ){
+        if( pDef && pDef->xValue==0 && pWin ){
           sqlite3ErrorMsg(pParse,
               "%.*s() may not be used as a window function", nId, zId
           );
           pNC->nErr++;
         }else if(
               (is_agg && (pNC->ncFlags & NC_AllowAgg)==0)
-           || (is_agg && (pDef->funcFlags&SQLITE_FUNC_WINDOW) && !pExpr->y.pWin)
-           || (is_agg && pExpr->y.pWin && (pNC->ncFlags & NC_AllowWin)==0)
+           || (is_agg && (pDef->funcFlags&SQLITE_FUNC_WINDOW) && !pWin)
+           || (is_agg && pWin && (pNC->ncFlags & NC_AllowWin)==0)
         ){
           const char *zType;
-          if( (pDef->funcFlags & SQLITE_FUNC_WINDOW) || pExpr->y.pWin ){
+          if( (pDef->funcFlags & SQLITE_FUNC_WINDOW) || pWin ){
             zType = "window";
           }else{
             zType = "aggregate";
           }
           sqlite3ErrorMsg(pParse, "misuse of %s function %.*s()",zType,nId,zId);
@@ -95961,49 +96577,66 @@
         }else if( wrong_num_args ){
           sqlite3ErrorMsg(pParse,"wrong number of arguments to function %.*s()",
                nId, zId);
           pNC->nErr++;
         }
+#ifndef SQLITE_OMIT_WINDOWFUNC
+        else if( is_agg==0 && ExprHasProperty(pExpr, EP_WinFunc) ){
+          sqlite3ErrorMsg(pParse,
+              "FILTER may not be used with non-aggregate %.*s()",
+              nId, zId
+          );
+          pNC->nErr++;
+        }
+#endif
         if( is_agg ){
           /* Window functions may not be arguments of aggregate functions.
           ** Or arguments of other window functions. But aggregate functions
           ** may be arguments for window functions.  */
 #ifndef SQLITE_OMIT_WINDOWFUNC
-          pNC->ncFlags &= ~(NC_AllowWin | (!pExpr->y.pWin ? NC_AllowAgg : 0));
+          pNC->ncFlags &= ~(NC_AllowWin | (!pWin ? NC_AllowAgg : 0));
 #else
           pNC->ncFlags &= ~NC_AllowAgg;
 #endif
         }
       }
+#ifndef SQLITE_OMIT_WINDOWFUNC
+      else if( ExprHasProperty(pExpr, EP_WinFunc) ){
+        is_agg = 1;
+      }
+#endif
       sqlite3WalkExprList(pWalker, pList);
       if( is_agg ){
 #ifndef SQLITE_OMIT_WINDOWFUNC
-        if( pExpr->y.pWin ){
+        if( pWin ){
           Select *pSel = pNC->pWinSelect;
-          sqlite3WindowUpdate(pParse, pSel->pWinDefn, pExpr->y.pWin, pDef);
-          sqlite3WalkExprList(pWalker, pExpr->y.pWin->pPartition);
-          sqlite3WalkExprList(pWalker, pExpr->y.pWin->pOrderBy);
-          sqlite3WalkExpr(pWalker, pExpr->y.pWin->pFilter);
-          if( 0==pSel->pWin
-           || 0==sqlite3WindowCompare(pParse, pSel->pWin, pExpr->y.pWin)
-          ){
-            pExpr->y.pWin->pNextWin = pSel->pWin;
-            pSel->pWin = pExpr->y.pWin;
+          assert( pWin==pExpr->y.pWin );
+          if( IN_RENAME_OBJECT==0 ){
+            sqlite3WindowUpdate(pParse, pSel->pWinDefn, pWin, pDef);
           }
+          sqlite3WalkExprList(pWalker, pWin->pPartition);
+          sqlite3WalkExprList(pWalker, pWin->pOrderBy);
+          sqlite3WalkExpr(pWalker, pWin->pFilter);
+          sqlite3WindowLink(pSel, pWin);
           pNC->ncFlags |= NC_HasWin;
         }else
 #endif /* SQLITE_OMIT_WINDOWFUNC */
         {
           NameContext *pNC2 = pNC;
           pExpr->op = TK_AGG_FUNCTION;
           pExpr->op2 = 0;
+#ifndef SQLITE_OMIT_WINDOWFUNC
+          if( ExprHasProperty(pExpr, EP_WinFunc) ){
+            sqlite3WalkExpr(pWalker, pExpr->y.pWin->pFilter);
+          }
+#endif
           while( pNC2 && !sqlite3FunctionUsesThisSrc(pExpr, pNC2->pSrcList) ){
             pExpr->op2++;
             pNC2 = pNC2->pNext;
           }
-          assert( pDef!=0 );
-          if( pNC2 ){
+          assert( pDef!=0 || IN_RENAME_OBJECT );
+          if( pNC2 && pDef ){
             assert( SQLITE_FUNC_MINMAX==NC_MinMaxAgg );
             testcase( (pDef->funcFlags & SQLITE_FUNC_MINMAX)!=0 );
             pNC2->ncFlags |= NC_HasAgg | (pDef->funcFlags & SQLITE_FUNC_MINMAX);
 
           }
@@ -96037,15 +96670,15 @@
       notValid(pParse, pNC, "parameters", NC_IsCheck|NC_PartIdx|NC_IdxExpr);
       break;
     }
     case TK_IS:
     case TK_ISNOT: {
-      Expr *pRight;
+      Expr *pRight = sqlite3ExprSkipCollateAndLikely(pExpr->pRight);
       assert( !ExprHasProperty(pExpr, EP_Reduced) );
       /* Handle special cases of "x IS TRUE", "x IS FALSE", "x IS NOT TRUE",
       ** and "x IS NOT FALSE". */
-      if( (pRight = pExpr->pRight)->op==TK_ID ){
+      if( pRight->op==TK_ID ){
         int rc = resolveExprStep(pWalker, pRight);
         if( rc==WRC_Abort ) return WRC_Abort;
         if( pRight->op==TK_TRUEFALSE ){
           pExpr->op2 = pExpr->op;
           pExpr->op = TK_TRUTH;
@@ -96248,11 +96881,11 @@
     assert( pEList!=0 );
     for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){
       int iCol = -1;
       Expr *pE, *pDup;
       if( pItem->done ) continue;
-      pE = sqlite3ExprSkipCollate(pItem->pExpr);
+      pE = sqlite3ExprSkipCollateAndLikely(pItem->pExpr);
       if( sqlite3ExprIsInteger(pE, &iCol) ){
         if( iCol<=0 || iCol>pEList->nExpr ){
           resolveOutOfRangeError(pParse, "ORDER", i+1, pEList->nExpr);
           return 1;
         }
@@ -96342,11 +96975,11 @@
   int i;
   sqlite3 *db = pParse->db;
   ExprList *pEList;
   struct ExprList_item *pItem;
 
-  if( pOrderBy==0 || pParse->db->mallocFailed ) return 0;
+  if( pOrderBy==0 || pParse->db->mallocFailed || IN_RENAME_OBJECT ) return 0;
   if( pOrderBy->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){
     sqlite3ErrorMsg(pParse, "too many terms in %s BY clause", zType);
     return 1;
   }
   pEList = pSelect->pEList;
@@ -96364,39 +96997,37 @@
   return 0;
 }
 
 #ifndef SQLITE_OMIT_WINDOWFUNC
 /*
-** Walker callback for resolveRemoveWindows().
+** Walker callback for windowRemoveExprFromSelect().
 */
 static int resolveRemoveWindowsCb(Walker *pWalker, Expr *pExpr){
+  UNUSED_PARAMETER(pWalker);
   if( ExprHasProperty(pExpr, EP_WinFunc) ){
-    Window **pp;
-    for(pp=&pWalker->u.pSelect->pWin; *pp; pp=&(*pp)->pNextWin){
-      if( *pp==pExpr->y.pWin ){
-        *pp = (*pp)->pNextWin;
-        break;
-      }
-    }
+    Window *pWin = pExpr->y.pWin;
+    sqlite3WindowUnlinkFromSelect(pWin);
   }
   return WRC_Continue;
 }
 
 /*
 ** Remove any Window objects owned by the expression pExpr from the
 ** Select.pWin list of Select object pSelect.
 */
-static void resolveRemoveWindows(Select *pSelect, Expr *pExpr){
-  Walker sWalker;
-  memset(&sWalker, 0, sizeof(Walker));
-  sWalker.xExprCallback = resolveRemoveWindowsCb;
-  sWalker.u.pSelect = pSelect;
-  sqlite3WalkExpr(&sWalker, pExpr);
+static void windowRemoveExprFromSelect(Select *pSelect, Expr *pExpr){
+  if( pSelect->pWin ){
+    Walker sWalker;
+    memset(&sWalker, 0, sizeof(Walker));
+    sWalker.xExprCallback = resolveRemoveWindowsCb;
+    sWalker.u.pSelect = pSelect;
+    sqlite3WalkExpr(&sWalker, pExpr);
+  }
 }
 #else
-# define resolveRemoveWindows(x,y)
-#endif
+# define windowRemoveExprFromSelect(a, b)
+#endif /* SQLITE_OMIT_WINDOWFUNC */
 
 /*
 ** pOrderBy is an ORDER BY or GROUP BY clause in SELECT statement pSelect.
 ** The Name context of the SELECT statement is pNC.  zType is either
 ** "ORDER" or "GROUP" depending on which type of clause pOrderBy is.
@@ -96429,11 +97060,11 @@
   if( pOrderBy==0 ) return 0;
   nResult = pSelect->pEList->nExpr;
   pParse = pNC->pParse;
   for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){
     Expr *pE = pItem->pExpr;
-    Expr *pE2 = sqlite3ExprSkipCollate(pE);
+    Expr *pE2 = sqlite3ExprSkipCollateAndLikely(pE);
     if( zType[0]!='G' ){
       iCol = resolveAsName(pParse, pSelect->pEList, pE2);
       if( iCol>0 ){
         /* If an AS-name match is found, mark this ORDER BY column as being
         ** a copy of the iCol-th result-set column.  The subsequent call to
@@ -96463,11 +97094,11 @@
     for(j=0; j<pSelect->pEList->nExpr; j++){
       if( sqlite3ExprCompare(0, pE, pSelect->pEList->a[j].pExpr, -1)==0 ){
         /* Since this expresion is being changed into a reference
         ** to an identical expression in the result set, remove all Window
         ** objects belonging to the expression from the Select.pWin list. */
-        resolveRemoveWindows(pSelect, pE);
+        windowRemoveExprFromSelect(pSelect, pE);
         pItem->u.x.iOrderByCol = j+1;
       }
     }
   }
   return sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType);
@@ -96763,11 +97394,11 @@
 */
 SQLITE_PRIVATE int sqlite3ResolveExprNames(
   NameContext *pNC,       /* Namespace to resolve expressions in. */
   Expr *pExpr             /* The expression to be analyzed. */
 ){
-  u16 savedHasAgg;
+  int savedHasAgg;
   Walker w;
 
   if( pExpr==0 ) return SQLITE_OK;
   savedHasAgg = pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg|NC_HasWin);
   pNC->ncFlags &= ~(NC_HasAgg|NC_MinMaxAgg|NC_HasWin);
@@ -96877,11 +97508,11 @@
     sSrc.a[0].pTab = pTab;
     sSrc.a[0].iCursor = -1;
   }
   sNC.pParse = pParse;
   sNC.pSrcList = &sSrc;
-  sNC.ncFlags = type;
+  sNC.ncFlags = type | NC_IsDDL;
   if( (rc = sqlite3ResolveExprNames(&sNC, pExpr))!=SQLITE_OK ) return rc;
   if( pList ) rc = sqlite3ResolveExprListNames(&sNC, pList);
   return rc;
 }
 
@@ -96931,12 +97562,15 @@
 ** SELECT a AS b FROM t1 WHERE b;
 ** SELECT * FROM t1 WHERE (select a from t1);
 */
 SQLITE_PRIVATE char sqlite3ExprAffinity(Expr *pExpr){
   int op;
-  pExpr = sqlite3ExprSkipCollate(pExpr);
-  if( pExpr->flags & EP_Generic ) return 0;
+  while( ExprHasProperty(pExpr, EP_Skip) ){
+    assert( pExpr->op==TK_COLLATE );
+    pExpr = pExpr->pLeft;
+    assert( pExpr!=0 );
+  }
   op = pExpr->op;
   if( op==TK_SELECT ){
     assert( pExpr->flags&EP_xIsSelect );
     return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);
   }
@@ -96954,11 +97588,11 @@
     assert( pExpr->pLeft->flags&EP_xIsSelect );
     return sqlite3ExprAffinity(
         pExpr->pLeft->x.pSelect->pEList->a[pExpr->iColumn].pExpr
     );
   }
-  return pExpr->affinity;
+  return pExpr->affExpr;
 }
 
 /*
 ** Set the collating sequence for expression pExpr to be the collating
 ** sequence named by pToken.   Return a pointer to a new Expr node that
@@ -96989,15 +97623,27 @@
   sqlite3TokenInit(&s, (char*)zC);
   return sqlite3ExprAddCollateToken(pParse, pExpr, &s, 0);
 }
 
 /*
-** Skip over any TK_COLLATE operators and any unlikely()
-** or likelihood() function at the root of an expression.
+** Skip over any TK_COLLATE operators.
 */
 SQLITE_PRIVATE Expr *sqlite3ExprSkipCollate(Expr *pExpr){
   while( pExpr && ExprHasProperty(pExpr, EP_Skip) ){
+    assert( pExpr->op==TK_COLLATE );
+    pExpr = pExpr->pLeft;
+  }
+  return pExpr;
+}
+
+/*
+** Skip over any TK_COLLATE operators and/or any unlikely()
+** or likelihood() or likely() functions at the root of an
+** expression.
+*/
+SQLITE_PRIVATE Expr *sqlite3ExprSkipCollateAndLikely(Expr *pExpr){
+  while( pExpr && ExprHasProperty(pExpr, EP_Skip|EP_Unlikely) ){
     if( ExprHasProperty(pExpr, EP_Unlikely) ){
       assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
       assert( pExpr->x.pList->nExpr>0 );
       assert( pExpr->op==TK_FUNCTION );
       pExpr = pExpr->x.pList->a[0].pExpr;
@@ -97027,11 +97673,10 @@
   sqlite3 *db = pParse->db;
   CollSeq *pColl = 0;
   Expr *p = pExpr;
   while( p ){
     int op = p->op;
-    if( p->flags & EP_Generic ) break;
     if( op==TK_REGISTER ) op = p->op2;
     if( (op==TK_AGG_COLUMN || op==TK_COLUMN || op==TK_TRIGGER)
      && p->y.pTab!=0
     ){
       /* op==TK_REGISTER && p->y.pTab!=0 happens when pExpr was originally
@@ -97113,28 +97758,23 @@
 ** type affinity of the other operand.  This routine returns the
 ** type affinity that should be used for the comparison operator.
 */
 SQLITE_PRIVATE char sqlite3CompareAffinity(Expr *pExpr, char aff2){
   char aff1 = sqlite3ExprAffinity(pExpr);
-  if( aff1 && aff2 ){
+  if( aff1>SQLITE_AFF_NONE && aff2>SQLITE_AFF_NONE ){
     /* Both sides of the comparison are columns. If one has numeric
     ** affinity, use that. Otherwise use no affinity.
     */
     if( sqlite3IsNumericAffinity(aff1) || sqlite3IsNumericAffinity(aff2) ){
       return SQLITE_AFF_NUMERIC;
     }else{
       return SQLITE_AFF_BLOB;
     }
-  }else if( !aff1 && !aff2 ){
-    /* Neither side of the comparison is a column.  Compare the
-    ** results directly.
-    */
-    return SQLITE_AFF_BLOB;
   }else{
     /* One side is a column, the other is not. Use the columns affinity. */
-    assert( aff1==0 || aff2==0 );
-    return (aff1 + aff2);
+    assert( aff1<=SQLITE_AFF_NONE || aff2<=SQLITE_AFF_NONE );
+    return (aff1<=SQLITE_AFF_NONE ? aff2 : aff1) | SQLITE_AFF_NONE;
   }
 }
 
 /*
 ** pExpr is a comparison operator.  Return the type affinity that should
@@ -97163,18 +97803,17 @@
 ** if the index with affinity idx_affinity may be used to implement
 ** the comparison in pExpr.
 */
 SQLITE_PRIVATE int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity){
   char aff = comparisonAffinity(pExpr);
-  switch( aff ){
-    case SQLITE_AFF_BLOB:
-      return 1;
-    case SQLITE_AFF_TEXT:
-      return idx_affinity==SQLITE_AFF_TEXT;
-    default:
-      return sqlite3IsNumericAffinity(idx_affinity);
+  if( aff<SQLITE_AFF_TEXT ){
+    return 1;
+  }
+  if( aff==SQLITE_AFF_TEXT ){
+    return idx_affinity==SQLITE_AFF_TEXT;
   }
+  return sqlite3IsNumericAffinity(idx_affinity);
 }
 
 /*
 ** Return the P5 value that should be used for a binary comparison
 ** opcode (OP_Eq, OP_Ge etc.) used to compare pExpr1 and pExpr2.
@@ -97660,11 +98299,11 @@
     memset(pNew, 0, sizeof(Expr));
     pNew->op = (u8)op;
     pNew->iAgg = -1;
     if( pToken ){
       if( nExtra==0 ){
-        pNew->flags |= EP_IntValue|EP_Leaf;
+        pNew->flags |= EP_IntValue|EP_Leaf|(iValue?EP_IsTrue:EP_IsFalse);
         pNew->u.iValue = iValue;
       }else{
         pNew->u.zToken = (char*)&pNew[1];
         assert( pToken->z!=0 || pToken->n==0 );
         if( pToken->n ) memcpy(pNew->u.zToken, pToken->z, pToken->n);
@@ -97737,24 +98376,20 @@
   int op,                 /* Expression opcode */
   Expr *pLeft,            /* Left operand */
   Expr *pRight            /* Right operand */
 ){
   Expr *p;
-  if( op==TK_AND && pParse->nErr==0 && !IN_RENAME_OBJECT ){
-    /* Take advantage of short-circuit false optimization for AND */
-    p = sqlite3ExprAnd(pParse->db, pLeft, pRight);
-  }else{
-    p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr));
-    if( p ){
-      memset(p, 0, sizeof(Expr));
-      p->op = op & 0xff;
-      p->iAgg = -1;
-    }
+  p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr));
+  if( p ){
+    memset(p, 0, sizeof(Expr));
+    p->op = op & 0xff;
+    p->iAgg = -1;
     sqlite3ExprAttachSubtrees(pParse->db, p, pLeft, pRight);
-  }
-  if( p ) {
     sqlite3ExprCheckHeight(pParse, p->nHeight);
+  }else{
+    sqlite3ExprDelete(pParse->db, pLeft);
+    sqlite3ExprDelete(pParse->db, pRight);
   }
   return p;
 }
 
 /*
@@ -97771,58 +98406,30 @@
     sqlite3SelectDelete(pParse->db, pSelect);
   }
 }
 
 
-/*
-** If the expression is always either TRUE or FALSE (respectively),
-** then return 1.  If one cannot determine the truth value of the
-** expression at compile-time return 0.
-**
-** This is an optimization.  If is OK to return 0 here even if
-** the expression really is always false or false (a false negative).
-** But it is a bug to return 1 if the expression might have different
-** boolean values in different circumstances (a false positive.)
-**
-** Note that if the expression is part of conditional for a
-** LEFT JOIN, then we cannot determine at compile-time whether or not
-** is it true or false, so always return 0.
-*/
-static int exprAlwaysTrue(Expr *p){
-  int v = 0;
-  if( ExprHasProperty(p, EP_FromJoin) ) return 0;
-  if( !sqlite3ExprIsInteger(p, &v) ) return 0;
-  return v!=0;
-}
-static int exprAlwaysFalse(Expr *p){
-  int v = 0;
-  if( ExprHasProperty(p, EP_FromJoin) ) return 0;
-  if( !sqlite3ExprIsInteger(p, &v) ) return 0;
-  return v==0;
-}
-
 /*
 ** Join two expressions using an AND operator.  If either expression is
 ** NULL, then just return the other expression.
 **
 ** If one side or the other of the AND is known to be false, then instead
 ** of returning an AND expression, just return a constant expression with
 ** a value of false.
 */
-SQLITE_PRIVATE Expr *sqlite3ExprAnd(sqlite3 *db, Expr *pLeft, Expr *pRight){
-  if( pLeft==0 ){
+SQLITE_PRIVATE Expr *sqlite3ExprAnd(Parse *pParse, Expr *pLeft, Expr *pRight){
+  sqlite3 *db = pParse->db;
+  if( pLeft==0  ){
     return pRight;
   }else if( pRight==0 ){
     return pLeft;
-  }else if( exprAlwaysFalse(pLeft) || exprAlwaysFalse(pRight) ){
-    sqlite3ExprDelete(db, pLeft);
-    sqlite3ExprDelete(db, pRight);
-    return sqlite3ExprAlloc(db, TK_INTEGER, &sqlite3IntTokens[0], 0);
+  }else if( ExprAlwaysFalse(pLeft) || ExprAlwaysFalse(pRight) ){
+    sqlite3ExprUnmapAndDelete(pParse, pLeft);
+    sqlite3ExprUnmapAndDelete(pParse, pRight);
+    return sqlite3Expr(db, TK_INTEGER, "0");
   }else{
-    Expr *pNew = sqlite3ExprAlloc(db, TK_AND, 0, 0);
-    sqlite3ExprAttachSubtrees(db, pNew, pLeft, pRight);
-    return pNew;
+    return sqlite3PExpr(pParse, TK_AND, pLeft, pRight);
   }
 }
 
 /*
 ** Construct a new expression node for a function with multiple
@@ -97955,19 +98562,22 @@
   if( !ExprHasProperty(p, (EP_TokenOnly|EP_Leaf)) ){
     /* The Expr.x union is never used at the same time as Expr.pRight */
     assert( p->x.pList==0 || p->pRight==0 );
     if( p->pLeft && p->op!=TK_SELECT_COLUMN ) sqlite3ExprDeleteNN(db, p->pLeft);
     if( p->pRight ){
+      assert( !ExprHasProperty(p, EP_WinFunc) );
       sqlite3ExprDeleteNN(db, p->pRight);
     }else if( ExprHasProperty(p, EP_xIsSelect) ){
+      assert( !ExprHasProperty(p, EP_WinFunc) );
       sqlite3SelectDelete(db, p->x.pSelect);
     }else{
       sqlite3ExprListDelete(db, p->x.pList);
-    }
-    if( ExprHasProperty(p, EP_WinFunc) ){
-      assert( p->op==TK_FUNCTION );
-      sqlite3WindowDelete(db, p->y.pWin);
+#ifndef SQLITE_OMIT_WINDOWFUNC
+      if( ExprHasProperty(p, EP_WinFunc) ){
+        sqlite3WindowDelete(db, p->y.pWin);
+      }
+#endif
     }
   }
   if( ExprHasProperty(p, EP_MemToken) ) sqlite3DbFree(db, p->u.zToken);
   if( !ExprHasProperty(p, EP_Static) ){
     sqlite3DbFreeNN(db, p);
@@ -97975,10 +98585,22 @@
 }
 SQLITE_PRIVATE void sqlite3ExprDelete(sqlite3 *db, Expr *p){
   if( p ) sqlite3ExprDeleteNN(db, p);
 }
 
+/* Invoke sqlite3RenameExprUnmap() and sqlite3ExprDelete() on the
+** expression.
+*/
+SQLITE_PRIVATE void sqlite3ExprUnmapAndDelete(Parse *pParse, Expr *p){
+  if( p ){
+    if( IN_RENAME_OBJECT ){
+      sqlite3RenameExprUnmap(pParse, p);
+    }
+    sqlite3ExprDeleteNN(pParse->db, p);
+  }
+}
+
 /*
 ** Return the number of bytes allocated for the expression structure
 ** passed as the first argument. This is always one of EXPR_FULLSIZE,
 ** EXPR_REDUCEDSIZE or EXPR_TOKENONLYSIZE.
 */
@@ -97986,20 +98608,10 @@
   if( ExprHasProperty(p, EP_TokenOnly) ) return EXPR_TOKENONLYSIZE;
   if( ExprHasProperty(p, EP_Reduced) ) return EXPR_REDUCEDSIZE;
   return EXPR_FULLSIZE;
 }
 
-/*
-** Copy the complete content of an Expr node, taking care not to read
-** past the end of the structure for a reduced-size version of the source
-** Expr.
-*/
-static void exprNodeCopy(Expr *pDest, Expr *pSrc){
-  memset(pDest, 0, sizeof(Expr));
-  memcpy(pDest, pSrc, exprStructSize(pSrc));
-}
-
 /*
 ** The dupedExpr*Size() routines each return the number of bytes required
 ** to store a copy of an expression or expression tree.  They differ in
 ** how much of the tree is measured.
 **
@@ -98235,14 +98847,17 @@
 ** gatherSelectWindowsCallback() are used to scan all the expressions
 ** an a newly duplicated SELECT statement and gather all of the Window
 ** objects found there, assembling them onto the linked list at Select->pWin.
 */
 static int gatherSelectWindowsCallback(Walker *pWalker, Expr *pExpr){
-  if( pExpr->op==TK_FUNCTION && pExpr->y.pWin!=0 ){
-    assert( ExprHasProperty(pExpr, EP_WinFunc) );
-    pExpr->y.pWin->pNextWin = pWalker->u.pSelect->pWin;
-    pWalker->u.pSelect->pWin = pExpr->y.pWin;
+  if( pExpr->op==TK_FUNCTION && ExprHasProperty(pExpr, EP_WinFunc) ){
+    Select *pSelect = pWalker->u.pSelect;
+    Window *pWin = pExpr->y.pWin;
+    assert( pWin );
+    assert( IsWindowFunc(pExpr) );
+    assert( pWin->ppThis==0 );
+    sqlite3WindowLink(pSelect, pWin);
   }
   return WRC_Continue;
 }
 static int gatherSelectWindowsSelectCallback(Walker *pWalker, Select *p){
   return p==pWalker->u.pSelect ? WRC_Continue : WRC_Prune;
@@ -98312,12 +98927,13 @@
         pNewExpr->pLeft = pPriorSelectCol;
       }
     }
     pItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
     pItem->zSpan = sqlite3DbStrDup(db, pOldItem->zSpan);
-    pItem->sortOrder = pOldItem->sortOrder;
+    pItem->sortFlags = pOldItem->sortFlags;
     pItem->done = 0;
+    pItem->bNulls = pOldItem->bNulls;
     pItem->bSpanIsTab = pOldItem->bSpanIsTab;
     pItem->bSorterRef = pOldItem->bSorterRef;
     pItem->u = pOldItem->u;
   }
   return pNew;
@@ -98424,11 +99040,11 @@
     pNew->nSelectRow = p->nSelectRow;
     pNew->pWith = withDup(db, p->pWith);
 #ifndef SQLITE_OMIT_WINDOWFUNC
     pNew->pWin = 0;
     pNew->pWinDefn = sqlite3WindowListDup(db, p->pWinDefn);
-    if( p->pWin ) gatherSelectWindows(pNew);
+    if( p->pWin && db->mallocFailed==0 ) gatherSelectWindows(pNew);
 #endif
     pNew->selId = p->selId;
     *pp = pNew;
     pp = &pNew->pPrior;
     pNext = pNew;
@@ -98533,10 +99149,14 @@
     goto vector_append_error;
   }
 
   for(i=0; i<pColumns->nId; i++){
     Expr *pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, i);
+    assert( pSubExpr!=0 || db->mallocFailed );
+    assert( pSubExpr==0 || pSubExpr->iTable==0 );
+    if( pSubExpr==0 ) continue;
+    pSubExpr->iTable = pColumns->nId;
     pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);
     if( pList ){
       assert( pList->nExpr==iFirst+i+1 );
       pList->a[pList->nExpr-1].zName = pColumns->a[i].zName;
       pColumns->a[i].zName = 0;
@@ -98557,30 +99177,46 @@
     ** the RHS and LHS sizes match during code generation. */
     pFirst->iTable = pColumns->nId;
   }
 
 vector_append_error:
-  if( IN_RENAME_OBJECT ){
-    sqlite3RenameExprUnmap(pParse, pExpr);
-  }
-  sqlite3ExprDelete(db, pExpr);
+  sqlite3ExprUnmapAndDelete(pParse, pExpr);
   sqlite3IdListDelete(db, pColumns);
   return pList;
 }
 
 /*
 ** Set the sort order for the last element on the given ExprList.
 */
-SQLITE_PRIVATE void sqlite3ExprListSetSortOrder(ExprList *p, int iSortOrder){
+SQLITE_PRIVATE void sqlite3ExprListSetSortOrder(ExprList *p, int iSortOrder, int eNulls){
+  struct ExprList_item *pItem;
   if( p==0 ) return;
-  assert( SQLITE_SO_UNDEFINED<0 && SQLITE_SO_ASC>=0 && SQLITE_SO_DESC>0 );
   assert( p->nExpr>0 );
-  if( iSortOrder<0 ){
-    assert( p->a[p->nExpr-1].sortOrder==SQLITE_SO_ASC );
-    return;
+
+  assert( SQLITE_SO_UNDEFINED<0 && SQLITE_SO_ASC==0 && SQLITE_SO_DESC>0 );
+  assert( iSortOrder==SQLITE_SO_UNDEFINED
+       || iSortOrder==SQLITE_SO_ASC
+       || iSortOrder==SQLITE_SO_DESC
+  );
+  assert( eNulls==SQLITE_SO_UNDEFINED
+       || eNulls==SQLITE_SO_ASC
+       || eNulls==SQLITE_SO_DESC
+  );
+
+  pItem = &p->a[p->nExpr-1];
+  assert( pItem->bNulls==0 );
+  if( iSortOrder==SQLITE_SO_UNDEFINED ){
+    iSortOrder = SQLITE_SO_ASC;
+  }
+  pItem->sortFlags = (u8)iSortOrder;
+
+  if( eNulls!=SQLITE_SO_UNDEFINED ){
+    pItem->bNulls = 1;
+    if( iSortOrder!=eNulls ){
+      pItem->sortFlags |= KEYINFO_ORDER_BIGNULL;
+    }
   }
-  p->a[p->nExpr-1].sortOrder = (u8)iSortOrder;
 }
 
 /*
 ** Set the ExprList.a[].zName element of the most recently added item
 ** on the expression list.
@@ -98708,26 +99344,55 @@
   if( !ExprHasProperty(pExpr, EP_Quoted)
    && (sqlite3StrICmp(pExpr->u.zToken, "true")==0
        || sqlite3StrICmp(pExpr->u.zToken, "false")==0)
   ){
     pExpr->op = TK_TRUEFALSE;
+    ExprSetProperty(pExpr, pExpr->u.zToken[4]==0 ? EP_IsTrue : EP_IsFalse);
     return 1;
   }
   return 0;
 }
 
 /*
 ** The argument must be a TK_TRUEFALSE Expr node.  Return 1 if it is TRUE
 ** and 0 if it is FALSE.
 */
 SQLITE_PRIVATE int sqlite3ExprTruthValue(const Expr *pExpr){
+  pExpr = sqlite3ExprSkipCollate((Expr*)pExpr);
   assert( pExpr->op==TK_TRUEFALSE );
   assert( sqlite3StrICmp(pExpr->u.zToken,"true")==0
        || sqlite3StrICmp(pExpr->u.zToken,"false")==0 );
   return pExpr->u.zToken[4]==0;
 }
 
+/*
+** If pExpr is an AND or OR expression, try to simplify it by eliminating
+** terms that are always true or false.  Return the simplified expression.
+** Or return the original expression if no simplification is possible.
+**
+** Examples:
+**
+**     (x<10) AND true                =>   (x<10)
+**     (x<10) AND false               =>   false
+**     (x<10) AND (y=22 OR false)     =>   (x<10) AND (y=22)
+**     (x<10) AND (y=22 OR true)      =>   (x<10)
+**     (y=22) OR true                 =>   true
+*/
+SQLITE_PRIVATE Expr *sqlite3ExprSimplifiedAndOr(Expr *pExpr){
+  assert( pExpr!=0 );
+  if( pExpr->op==TK_AND || pExpr->op==TK_OR ){
+    Expr *pRight = sqlite3ExprSimplifiedAndOr(pExpr->pRight);
+    Expr *pLeft = sqlite3ExprSimplifiedAndOr(pExpr->pLeft);
+    if( ExprAlwaysTrue(pLeft) || ExprAlwaysFalse(pRight) ){
+      pExpr = pExpr->op==TK_AND ? pRight : pLeft;
+    }else if( ExprAlwaysTrue(pRight) || ExprAlwaysFalse(pLeft) ){
+      pExpr = pExpr->op==TK_AND ? pLeft : pRight;
+    }
+  }
+  return pExpr;
+}
+
 
 /*
 ** These routines are Walker callbacks used to check expressions to
 ** see if they are "constant" for some definition of constant.  The
 ** Walker.eCode value determines the type of "constant" we are looking
@@ -98968,11 +99633,11 @@
 ** in *pValue.  If the expression is not an integer or if it is too big
 ** to fit in a signed 32-bit integer, return 0 and leave *pValue unchanged.
 */
 SQLITE_PRIVATE int sqlite3ExprIsInteger(Expr *p, int *pValue){
   int rc = 0;
-  if( p==0 ) return 0;  /* Can only happen following on OOM */
+  if( NEVER(p==0) ) return 0;  /* Used to only happen following on OOM */
 
   /* If an expression is an integer literal that fits in a signed 32-bit
   ** integer, then the EP_IntValue flag will have already been set */
   assert( p->op!=TK_INTEGER || (p->flags & EP_IntValue)!=0
            || sqlite3GetInt32(p->u.zToken, &rc)==0 );
@@ -99046,31 +99711,34 @@
 ** is harmless.  A false positive, however, can result in the wrong
 ** answer.
 */
 SQLITE_PRIVATE int sqlite3ExprNeedsNoAffinityChange(const Expr *p, char aff){
   u8 op;
+  int unaryMinus = 0;
   if( aff==SQLITE_AFF_BLOB ) return 1;
-  while( p->op==TK_UPLUS || p->op==TK_UMINUS ){ p = p->pLeft; }
+  while( p->op==TK_UPLUS || p->op==TK_UMINUS ){
+    if( p->op==TK_UMINUS ) unaryMinus = 1;
+    p = p->pLeft;
+  }
   op = p->op;
   if( op==TK_REGISTER ) op = p->op2;
   switch( op ){
     case TK_INTEGER: {
-      return aff==SQLITE_AFF_INTEGER || aff==SQLITE_AFF_NUMERIC;
+      return aff>=SQLITE_AFF_NUMERIC;
     }
     case TK_FLOAT: {
-      return aff==SQLITE_AFF_REAL || aff==SQLITE_AFF_NUMERIC;
+      return aff>=SQLITE_AFF_NUMERIC;
     }
     case TK_STRING: {
-      return aff==SQLITE_AFF_TEXT;
+      return !unaryMinus && aff==SQLITE_AFF_TEXT;
     }
     case TK_BLOB: {
-      return 1;
+      return !unaryMinus;
     }
     case TK_COLUMN: {
       assert( p->iTable>=0 );  /* p cannot be part of a CHECK constraint */
-      return p->iColumn<0
-          && (aff==SQLITE_AFF_INTEGER || aff==SQLITE_AFF_NUMERIC);
+      return aff>=SQLITE_AFF_NUMERIC && p->iColumn<0;
     }
     default: {
       return 0;
     }
   }
@@ -99249,11 +99917,11 @@
 ** then aiMap[] is populated with {2, 0, 1}.
 */
 #ifndef SQLITE_OMIT_SUBQUERY
 SQLITE_PRIVATE int sqlite3FindInIndex(
   Parse *pParse,             /* Parsing context */
-  Expr *pX,                  /* The right-hand side (RHS) of the IN operator */
+  Expr *pX,                  /* The IN expression */
   u32 inFlags,               /* IN_INDEX_LOOP, _MEMBERSHIP, and/or _NOOP_OK */
   int *prRhsHasNull,         /* Register holding NULL status.  See notes */
   int *aiMap,                /* Mapping from Index fields to RHS fields */
   int *piTab                 /* OUT: index to use */
 ){
@@ -99674,13 +100342,13 @@
     */
     char affinity;            /* Affinity of the LHS of the IN */
     int i;
     ExprList *pList = pExpr->x.pList;
     struct ExprList_item *pItem;
-    int r1, r2, r3;
+    int r1, r2;
     affinity = sqlite3ExprAffinity(pLeft);
-    if( !affinity ){
+    if( affinity<=SQLITE_AFF_NONE ){
       affinity = SQLITE_AFF_BLOB;
     }
     if( pKeyInfo ){
       assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );
       pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
@@ -99697,17 +100365,18 @@
       ** this code only executes once.  Because for a non-constant
       ** expression we need to rerun this code each time.
       */
       if( addrOnce && !sqlite3ExprIsConstant(pE2) ){
         sqlite3VdbeChangeToNoop(v, addrOnce);
+        ExprClearProperty(pExpr, EP_Subrtn);
         addrOnce = 0;
       }
 
       /* Evaluate the expression and insert it into the temp table */
-      r3 = sqlite3ExprCodeTarget(pParse, pE2, r1);
-      sqlite3VdbeAddOp4(v, OP_MakeRecord, r3, 1, r2, &affinity, 1);
-      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iTab, r2, r3, 1);
+      sqlite3ExprCode(pParse, pE2, r1);
+      sqlite3VdbeAddOp4(v, OP_MakeRecord, r1, 1, r2, &affinity, 1);
+      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iTab, r2, r1, 1);
     }
     sqlite3ReleaseTempReg(pParse, r1);
     sqlite3ReleaseTempReg(pParse, r2);
   }
   if( pKeyInfo ){
@@ -99716,10 +100385,11 @@
   if( addrOnce ){
     sqlite3VdbeJumpHere(v, addrOnce);
     /* Subroutine return */
     sqlite3VdbeAddOp1(v, OP_Return, pExpr->y.sub.regReturn);
     sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr-1, sqlite3VdbeCurrentAddr(v)-1);
+    sqlite3ClearTempRegCache(pParse);
   }
 }
 #endif /* SQLITE_OMIT_SUBQUERY */
 
 /*
@@ -99729,11 +100399,11 @@
 **     (SELECT a FROM b)          -- subquery
 **     EXISTS (SELECT a FROM b)   -- EXISTS subquery
 **
 ** The pExpr parameter is the SELECT or EXISTS operator to be coded.
 **
-** The register that holds the result.  For a multi-column SELECT,
+** Return the register that holds the result.  For a multi-column SELECT,
 ** the result is stored in a contiguous array of registers and the
 ** return value is the register of the left-most result column.
 ** Return 0 if an error occurs.
 */
 #ifndef SQLITE_OMIT_SUBQUERY
@@ -99807,15 +100477,25 @@
   }else{
     dest.eDest = SRT_Exists;
     sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);
     VdbeComment((v, "Init EXISTS result"));
   }
-  pLimit = sqlite3ExprAlloc(pParse->db, TK_INTEGER,&sqlite3IntTokens[1], 0);
   if( pSel->pLimit ){
-    sqlite3ExprDelete(pParse->db, pSel->pLimit->pLeft);
+    /* The subquery already has a limit.  If the pre-existing limit is X
+    ** then make the new limit X<>0 so that the new limit is either 1 or 0 */
+    sqlite3 *db = pParse->db;
+    pLimit = sqlite3Expr(db, TK_INTEGER, "0");
+    if( pLimit ){
+      pLimit->affExpr = SQLITE_AFF_NUMERIC;
+      pLimit = sqlite3PExpr(pParse, TK_NE,
+                            sqlite3ExprDup(db, pSel->pLimit->pLeft, 0), pLimit);
+    }
+    sqlite3ExprDelete(db, pSel->pLimit->pLeft);
     pSel->pLimit->pLeft = pLimit;
   }else{
+    /* If there is no pre-existing limit add a limit of 1 */
+    pLimit = sqlite3Expr(pParse->db, TK_INTEGER, "1");
     pSel->pLimit = sqlite3PExpr(pParse, TK_LIMIT, pLimit, 0);
   }
   pSel->iLimit = 0;
   if( sqlite3Select(pParse, pSel, &dest) ){
     return 0;
@@ -99826,10 +100506,11 @@
     sqlite3VdbeJumpHere(v, addrOnce);
 
     /* Subroutine return */
     sqlite3VdbeAddOp1(v, OP_Return, pExpr->y.sub.regReturn);
     sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr-1, sqlite3VdbeCurrentAddr(v)-1);
+    sqlite3ClearTempRegCache(pParse);
   }
 
   return rReg;
 }
 #endif /* SQLITE_OMIT_SUBQUERY */
@@ -99973,17 +100654,25 @@
     CollSeq *pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
     int labelOk = sqlite3VdbeMakeLabel(pParse);
     int r2, regToFree;
     int regCkNull = 0;
     int ii;
+    int bLhsReal;  /* True if the LHS of the IN has REAL affinity */
     assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
     if( destIfNull!=destIfFalse ){
       regCkNull = sqlite3GetTempReg(pParse);
       sqlite3VdbeAddOp3(v, OP_BitAnd, rLhs, rLhs, regCkNull);
     }
+    bLhsReal = sqlite3ExprAffinity(pExpr->pLeft)==SQLITE_AFF_REAL;
     for(ii=0; ii<pList->nExpr; ii++){
-      r2 = sqlite3ExprCodeTemp(pParse, pList->a[ii].pExpr, &regToFree);
+      if( bLhsReal ){
+        r2 = regToFree = sqlite3GetTempReg(pParse);
+        sqlite3ExprCode(pParse, pList->a[ii].pExpr, r2);
+        sqlite3VdbeAddOp4(v, OP_Affinity, r2, 1, 0, "E", P4_STATIC);
+      }else{
+        r2 = sqlite3ExprCodeTemp(pParse, pList->a[ii].pExpr, &regToFree);
+      }
       if( regCkNull && sqlite3ExprCanBeNull(pList->a[ii].pExpr) ){
         sqlite3VdbeAddOp3(v, OP_BitAnd, regCkNull, r2, regCkNull);
       }
       if( ii<pList->nExpr-1 || destIfNull!=destIfFalse ){
         sqlite3VdbeAddOp4(v, OP_Eq, rLhs, labelOk, r2,
@@ -100263,11 +100952,12 @@
 /*
 ** Convert a scalar expression node to a TK_REGISTER referencing
 ** register iReg.  The caller must ensure that iReg already contains
 ** the correct value for the expression.
 */
-static void exprToRegister(Expr *p, int iReg){
+static void exprToRegister(Expr *pExpr, int iReg){
+  Expr *p = sqlite3ExprSkipCollateAndLikely(pExpr);
   p->op2 = p->op;
   p->op = TK_REGISTER;
   p->iTable = iReg;
   ExprClearProperty(p, EP_Skip);
 }
@@ -100364,11 +101054,11 @@
         ** datatype by applying the Affinity of the table column to the
         ** constant.
         */
         int iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft,target);
         int aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);
-        if( aff!=SQLITE_AFF_BLOB ){
+        if( aff>SQLITE_AFF_BLOB ){
           static const char zAff[] = "B\000C\000D\000E";
           assert( SQLITE_AFF_BLOB=='A' );
           assert( SQLITE_AFF_TEXT=='B' );
           if( iReg!=target ){
             sqlite3VdbeAddOp2(v, OP_SCopy, iReg, target);
@@ -100380,11 +101070,23 @@
         return iReg;
       }
       if( iTab<0 ){
         if( pParse->iSelfTab<0 ){
           /* Generating CHECK constraints or inserting into partial index */
-          return pExpr->iColumn - pParse->iSelfTab;
+          assert( pExpr->y.pTab!=0 );
+          assert( pExpr->iColumn>=XN_ROWID );
+          assert( pExpr->iColumn<pExpr->y.pTab->nCol );
+          if( pExpr->iColumn>=0
+            && pExpr->y.pTab->aCol[pExpr->iColumn].affinity==SQLITE_AFF_REAL
+          ){
+            sqlite3VdbeAddOp2(v, OP_SCopy, pExpr->iColumn - pParse->iSelfTab,
+                              target);
+            sqlite3VdbeAddOp1(v, OP_RealAffinity, target);
+            return target;
+          }else{
+            return pExpr->iColumn - pParse->iSelfTab;
+          }
         }else{
           /* Coding an expression that is part of an index where column names
           ** in the index refer to the table to which the index belongs */
           iTab = pParse->iSelfTab - 1;
         }
@@ -100667,11 +101369,11 @@
         const char *azAff[] = { "blob", "text", "numeric", "integer", "real" };
         char aff;
         assert( nFarg==1 );
         aff = sqlite3ExprAffinity(pFarg->a[0].pExpr);
         sqlite3VdbeLoadString(v, target,
-                              aff ? azAff[aff-SQLITE_AFF_BLOB] : "none");
+                (aff<=SQLITE_AFF_NONE) ? "none" : azAff[aff-SQLITE_AFF_BLOB]);
         return target;
       }
 #endif
 
       for(i=0; i<nFarg; i++){
@@ -100775,11 +101477,11 @@
       int n;
       if( pExpr->pLeft->iTable==0 ){
         pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);
       }
       assert( pExpr->iTable==0 || pExpr->pLeft->op==TK_SELECT );
-      if( pExpr->iTable
+      if( pExpr->iTable!=0
        && pExpr->iTable!=(n = sqlite3ExprVectorSize(pExpr->pLeft))
       ){
         sqlite3ErrorMsg(pParse, "%d columns assigned %d values",
                                 pExpr->iTable, n);
       }
@@ -100879,14 +101581,27 @@
     case TK_VECTOR: {
       sqlite3ErrorMsg(pParse, "row value misused");
       break;
     }
 
+    /* TK_IF_NULL_ROW Expr nodes are inserted ahead of expressions
+    ** that derive from the right-hand table of a LEFT JOIN.  The
+    ** Expr.iTable value is the table number for the right-hand table.
+    ** The expression is only evaluated if that table is not currently
+    ** on a LEFT JOIN NULL row.
+    */
     case TK_IF_NULL_ROW: {
       int addrINR;
+      u8 okConstFactor = pParse->okConstFactor;
       addrINR = sqlite3VdbeAddOp1(v, OP_IfNullRow, pExpr->iTable);
+      /* Temporarily disable factoring of constant expressions, since
+      ** even though expressions may appear to be constant, they are not
+      ** really constant because they originate from the right-hand side
+      ** of a LEFT JOIN. */
+      pParse->okConstFactor = 0;
       inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
+      pParse->okConstFactor = okConstFactor;
       sqlite3VdbeJumpHere(v, addrINR);
       sqlite3VdbeChangeP3(v, addrINR, inReg);
       break;
     }
 
@@ -100919,25 +101634,31 @@
       ExprList *pEList;                 /* List of WHEN terms */
       struct ExprList_item *aListelem;  /* Array of WHEN terms */
       Expr opCompare;                   /* The X==Ei expression */
       Expr *pX;                         /* The X expression */
       Expr *pTest = 0;                  /* X==Ei (form A) or just Ei (form B) */
+      Expr *pDel = 0;
+      sqlite3 *db = pParse->db;
 
       assert( !ExprHasProperty(pExpr, EP_xIsSelect) && pExpr->x.pList );
       assert(pExpr->x.pList->nExpr > 0);
       pEList = pExpr->x.pList;
       aListelem = pEList->a;
       nExpr = pEList->nExpr;
       endLabel = sqlite3VdbeMakeLabel(pParse);
       if( (pX = pExpr->pLeft)!=0 ){
-        exprNodeCopy(&tempX, pX);
+        pDel = sqlite3ExprDup(db, pX, 0);
+        if( db->mallocFailed ){
+          sqlite3ExprDelete(db, pDel);
+          break;
+        }
         testcase( pX->op==TK_COLUMN );
-        exprToRegister(&tempX, exprCodeVector(pParse, &tempX, &regFree1));
+        exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));
         testcase( regFree1==0 );
         memset(&opCompare, 0, sizeof(opCompare));
         opCompare.op = TK_EQ;
-        opCompare.pLeft = &tempX;
+        opCompare.pLeft = pDel;
         pTest = &opCompare;
         /* Ticket b351d95f9cd5ef17e9d9dbae18f5ca8611190001:
         ** The value in regFree1 might get SCopy-ed into the file result.
         ** So make sure that the regFree1 register is not reused for other
         ** purposes and possibly overwritten.  */
@@ -100961,36 +101682,37 @@
       if( (nExpr&1)!=0 ){
         sqlite3ExprCode(pParse, pEList->a[nExpr-1].pExpr, target);
       }else{
         sqlite3VdbeAddOp2(v, OP_Null, 0, target);
       }
+      sqlite3ExprDelete(db, pDel);
       sqlite3VdbeResolveLabel(v, endLabel);
       break;
     }
 #ifndef SQLITE_OMIT_TRIGGER
     case TK_RAISE: {
-      assert( pExpr->affinity==OE_Rollback
-           || pExpr->affinity==OE_Abort
-           || pExpr->affinity==OE_Fail
-           || pExpr->affinity==OE_Ignore
+      assert( pExpr->affExpr==OE_Rollback
+           || pExpr->affExpr==OE_Abort
+           || pExpr->affExpr==OE_Fail
+           || pExpr->affExpr==OE_Ignore
       );
       if( !pParse->pTriggerTab ){
         sqlite3ErrorMsg(pParse,
                        "RAISE() may only be used within a trigger-program");
         return 0;
       }
-      if( pExpr->affinity==OE_Abort ){
+      if( pExpr->affExpr==OE_Abort ){
         sqlite3MayAbort(pParse);
       }
       assert( !ExprHasProperty(pExpr, EP_IntValue) );
-      if( pExpr->affinity==OE_Ignore ){
+      if( pExpr->affExpr==OE_Ignore ){
         sqlite3VdbeAddOp4(
             v, OP_Halt, SQLITE_OK, OE_Ignore, 0, pExpr->u.zToken,0);
         VdbeCoverage(v);
       }else{
         sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_TRIGGER,
-                              pExpr->affinity, pExpr->u.zToken, 0, 0);
+                              pExpr->affExpr, pExpr->u.zToken, 0, 0);
       }
 
       break;
     }
 #endif
@@ -101051,11 +101773,11 @@
 ** code to fill the register in the initialization section of the
 ** VDBE program, in order to factor it out of the evaluation loop.
 */
 SQLITE_PRIVATE int sqlite3ExprCodeTemp(Parse *pParse, Expr *pExpr, int *pReg){
   int r2;
-  pExpr = sqlite3ExprSkipCollate(pExpr);
+  pExpr = sqlite3ExprSkipCollateAndLikely(pExpr);
   if( ConstFactorOk(pParse)
    && pExpr->op!=TK_REGISTER
    && sqlite3ExprIsConstantNotJoin(pExpr)
   ){
     *pReg  = 0;
@@ -101242,44 +101964,48 @@
   Expr *pExpr,      /* The BETWEEN expression */
   int dest,         /* Jump destination or storage location */
   void (*xJump)(Parse*,Expr*,int,int), /* Action to take */
   int jumpIfNull    /* Take the jump if the BETWEEN is NULL */
 ){
- Expr exprAnd;     /* The AND operator in  x>=y AND x<=z  */
+  Expr exprAnd;     /* The AND operator in  x>=y AND x<=z  */
   Expr compLeft;    /* The  x>=y  term */
   Expr compRight;   /* The  x<=z  term */
-  Expr exprX;       /* The  x  subexpression */
   int regFree1 = 0; /* Temporary use register */
+  Expr *pDel = 0;
+  sqlite3 *db = pParse->db;
 
   memset(&compLeft, 0, sizeof(Expr));
   memset(&compRight, 0, sizeof(Expr));
   memset(&exprAnd, 0, sizeof(Expr));
 
   assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
-  exprNodeCopy(&exprX, pExpr->pLeft);
-  exprAnd.op = TK_AND;
-  exprAnd.pLeft = &compLeft;
-  exprAnd.pRight = &compRight;
-  compLeft.op = TK_GE;
-  compLeft.pLeft = &exprX;
-  compLeft.pRight = pExpr->x.pList->a[0].pExpr;
-  compRight.op = TK_LE;
-  compRight.pLeft = &exprX;
-  compRight.pRight = pExpr->x.pList->a[1].pExpr;
-  exprToRegister(&exprX, exprCodeVector(pParse, &exprX, &regFree1));
-  if( xJump ){
-    xJump(pParse, &exprAnd, dest, jumpIfNull);
-  }else{
-    /* Mark the expression is being from the ON or USING clause of a join
-    ** so that the sqlite3ExprCodeTarget() routine will not attempt to move
-    ** it into the Parse.pConstExpr list.  We should use a new bit for this,
-    ** for clarity, but we are out of bits in the Expr.flags field so we
-    ** have to reuse the EP_FromJoin bit.  Bummer. */
-    exprX.flags |= EP_FromJoin;
-    sqlite3ExprCodeTarget(pParse, &exprAnd, dest);
+  pDel = sqlite3ExprDup(db, pExpr->pLeft, 0);
+  if( db->mallocFailed==0 ){
+    exprAnd.op = TK_AND;
+    exprAnd.pLeft = &compLeft;
+    exprAnd.pRight = &compRight;
+    compLeft.op = TK_GE;
+    compLeft.pLeft = pDel;
+    compLeft.pRight = pExpr->x.pList->a[0].pExpr;
+    compRight.op = TK_LE;
+    compRight.pLeft = pDel;
+    compRight.pRight = pExpr->x.pList->a[1].pExpr;
+    exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));
+    if( xJump ){
+      xJump(pParse, &exprAnd, dest, jumpIfNull);
+    }else{
+      /* Mark the expression is being from the ON or USING clause of a join
+      ** so that the sqlite3ExprCodeTarget() routine will not attempt to move
+      ** it into the Parse.pConstExpr list.  We should use a new bit for this,
+      ** for clarity, but we are out of bits in the Expr.flags field so we
+      ** have to reuse the EP_FromJoin bit.  Bummer. */
+      pDel->flags |= EP_FromJoin;
+      sqlite3ExprCodeTarget(pParse, &exprAnd, dest);
+    }
+    sqlite3ReleaseTempReg(pParse, regFree1);
   }
-  sqlite3ReleaseTempReg(pParse, regFree1);
+  sqlite3ExprDelete(db, pDel);
 
   /* Ensure adequate test coverage */
   testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull==0 && regFree1==0 );
   testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull==0 && regFree1!=0 );
   testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull!=0 && regFree1==0 );
@@ -101315,22 +102041,27 @@
   assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );
   if( NEVER(v==0) )     return;  /* Existence of VDBE checked by caller */
   if( NEVER(pExpr==0) ) return;  /* No way this can happen */
   op = pExpr->op;
   switch( op ){
-    case TK_AND: {
-      int d2 = sqlite3VdbeMakeLabel(pParse);
-      testcase( jumpIfNull==0 );
-      sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2,jumpIfNull^SQLITE_JUMPIFNULL);
-      sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
-      sqlite3VdbeResolveLabel(v, d2);
-      break;
-    }
+    case TK_AND:
     case TK_OR: {
-      testcase( jumpIfNull==0 );
-      sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
-      sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
+      Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
+      if( pAlt!=pExpr ){
+        sqlite3ExprIfTrue(pParse, pAlt, dest, jumpIfNull);
+      }else if( op==TK_AND ){
+        int d2 = sqlite3VdbeMakeLabel(pParse);
+        testcase( jumpIfNull==0 );
+        sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2,
+                           jumpIfNull^SQLITE_JUMPIFNULL);
+        sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
+        sqlite3VdbeResolveLabel(v, d2);
+      }else{
+        testcase( jumpIfNull==0 );
+        sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
+        sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
+      }
       break;
     }
     case TK_NOT: {
       testcase( jumpIfNull==0 );
       sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
@@ -101412,13 +102143,13 @@
       break;
     }
 #endif
     default: {
     default_expr:
-      if( exprAlwaysTrue(pExpr) ){
+      if( ExprAlwaysTrue(pExpr) ){
         sqlite3VdbeGoto(v, dest);
-      }else if( exprAlwaysFalse(pExpr) ){
+      }else if( ExprAlwaysFalse(pExpr) ){
         /* No-op */
       }else{
         r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);
         sqlite3VdbeAddOp3(v, OP_If, r1, dest, jumpIfNull!=0);
         VdbeCoverage(v);
@@ -101482,22 +102213,27 @@
   assert( pExpr->op!=TK_LE || op==OP_Gt );
   assert( pExpr->op!=TK_GT || op==OP_Le );
   assert( pExpr->op!=TK_GE || op==OP_Lt );
 
   switch( pExpr->op ){
-    case TK_AND: {
-      testcase( jumpIfNull==0 );
-      sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
-      sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
-      break;
-    }
+    case TK_AND:
     case TK_OR: {
-      int d2 = sqlite3VdbeMakeLabel(pParse);
-      testcase( jumpIfNull==0 );
-      sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2, jumpIfNull^SQLITE_JUMPIFNULL);
-      sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
-      sqlite3VdbeResolveLabel(v, d2);
+      Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
+      if( pAlt!=pExpr ){
+        sqlite3ExprIfFalse(pParse, pAlt, dest, jumpIfNull);
+      }else if( pExpr->op==TK_AND ){
+        testcase( jumpIfNull==0 );
+        sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
+        sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
+      }else{
+        int d2 = sqlite3VdbeMakeLabel(pParse);
+        testcase( jumpIfNull==0 );
+        sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2,
+                          jumpIfNull^SQLITE_JUMPIFNULL);
+        sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
+        sqlite3VdbeResolveLabel(v, d2);
+      }
       break;
     }
     case TK_NOT: {
       testcase( jumpIfNull==0 );
       sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
@@ -101582,13 +102318,13 @@
       break;
     }
 #endif
     default: {
     default_expr:
-      if( exprAlwaysFalse(pExpr) ){
+      if( ExprAlwaysFalse(pExpr) ){
         sqlite3VdbeGoto(v, dest);
-      }else if( exprAlwaysTrue(pExpr) ){
+      }else if( ExprAlwaysTrue(pExpr) ){
         /* no-op */
       }else{
         r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);
         sqlite3VdbeAddOp3(v, OP_IfNot, r1, dest, jumpIfNull!=0);
         VdbeCoverage(v);
@@ -101704,24 +102440,21 @@
       return 1;
     }
     return 2;
   }
   if( pA->op!=TK_COLUMN && pA->op!=TK_AGG_COLUMN && pA->u.zToken ){
-    if( pA->op==TK_FUNCTION ){
+    if( pA->op==TK_FUNCTION || pA->op==TK_AGG_FUNCTION ){
       if( sqlite3StrICmp(pA->u.zToken,pB->u.zToken)!=0 ) return 2;
 #ifndef SQLITE_OMIT_WINDOWFUNC
-      /* Justification for the assert():
-      ** window functions have p->op==TK_FUNCTION but aggregate functions
-      ** have p->op==TK_AGG_FUNCTION.  So any comparison between an aggregate
-      ** function and a window function should have failed before reaching
-      ** this point.  And, it is not possible to have a window function and
-      ** a scalar function with the same name and number of arguments.  So
-      ** if we reach this point, either A and B both window functions or
-      ** neither are a window functions. */
-      assert( ExprHasProperty(pA,EP_WinFunc)==ExprHasProperty(pB,EP_WinFunc) );
+      assert( pA->op==pB->op );
+      if( ExprHasProperty(pA,EP_WinFunc)!=ExprHasProperty(pB,EP_WinFunc) ){
+        return 2;
+      }
       if( ExprHasProperty(pA,EP_WinFunc) ){
-        if( sqlite3WindowCompare(pParse,pA->y.pWin,pB->y.pWin)!=0 ) return 2;
+        if( sqlite3WindowCompare(pParse, pA->y.pWin, pB->y.pWin, 1)!=0 ){
+          return 2;
+        }
       }
 #endif
     }else if( pA->op==TK_NULL ){
       return 0;
     }else if( pA->op==TK_COLLATE ){
@@ -101740,11 +102473,13 @@
     if( pA->op!=TK_STRING
      && pA->op!=TK_TRUEFALSE
      && (combinedFlags & EP_Reduced)==0
     ){
       if( pA->iColumn!=pB->iColumn ) return 2;
-      if( pA->iTable!=pB->iTable
+      if( pA->op2!=pB->op2 ) return 2;
+      if( pA->op!=TK_IN
+       && pA->iTable!=pB->iTable
        && (pA->iTable!=iTab || NEVER(pB->iTable>=0)) ) return 2;
     }
   }
   return 0;
 }
@@ -101770,11 +102505,11 @@
   if( pA==0 || pB==0 ) return 1;
   if( pA->nExpr!=pB->nExpr ) return 1;
   for(i=0; i<pA->nExpr; i++){
     Expr *pExprA = pA->a[i].pExpr;
     Expr *pExprB = pB->a[i].pExpr;
-    if( pA->a[i].sortOrder!=pB->a[i].sortOrder ) return 1;
+    if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;
     if( sqlite3ExprCompare(0, pExprA, pExprB, iTab) ) return 1;
   }
   return 0;
 }
 
@@ -101782,15 +102517,92 @@
 ** Like sqlite3ExprCompare() except COLLATE operators at the top-level
 ** are ignored.
 */
 SQLITE_PRIVATE int sqlite3ExprCompareSkip(Expr *pA, Expr *pB, int iTab){
   return sqlite3ExprCompare(0,
-             sqlite3ExprSkipCollate(pA),
-             sqlite3ExprSkipCollate(pB),
+             sqlite3ExprSkipCollateAndLikely(pA),
+             sqlite3ExprSkipCollateAndLikely(pB),
              iTab);
 }
 
+/*
+** Return non-zero if Expr p can only be true if pNN is not NULL.
+**
+** Or if seenNot is true, return non-zero if Expr p can only be
+** non-NULL if pNN is not NULL
+*/
+static int exprImpliesNotNull(
+  Parse *pParse,      /* Parsing context */
+  Expr *p,            /* The expression to be checked */
+  Expr *pNN,          /* The expression that is NOT NULL */
+  int iTab,           /* Table being evaluated */
+  int seenNot         /* Return true only if p can be any non-NULL value */
+){
+  assert( p );
+  assert( pNN );
+  if( sqlite3ExprCompare(pParse, p, pNN, iTab)==0 ){
+    return pNN->op!=TK_NULL;
+  }
+  switch( p->op ){
+    case TK_IN: {
+      if( seenNot && ExprHasProperty(p, EP_xIsSelect) ) return 0;
+      assert( ExprHasProperty(p,EP_xIsSelect)
+           || (p->x.pList!=0 && p->x.pList->nExpr>0) );
+      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
+    }
+    case TK_BETWEEN: {
+      ExprList *pList = p->x.pList;
+      assert( pList!=0 );
+      assert( pList->nExpr==2 );
+      if( seenNot ) return 0;
+      if( exprImpliesNotNull(pParse, pList->a[0].pExpr, pNN, iTab, 1)
+       || exprImpliesNotNull(pParse, pList->a[1].pExpr, pNN, iTab, 1)
+      ){
+        return 1;
+      }
+      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
+    }
+    case TK_EQ:
+    case TK_NE:
+    case TK_LT:
+    case TK_LE:
+    case TK_GT:
+    case TK_GE:
+    case TK_PLUS:
+    case TK_MINUS:
+    case TK_BITOR:
+    case TK_LSHIFT:
+    case TK_RSHIFT:
+    case TK_CONCAT:
+      seenNot = 1;
+      /* Fall thru */
+    case TK_STAR:
+    case TK_REM:
+    case TK_BITAND:
+    case TK_SLASH: {
+      if( exprImpliesNotNull(pParse, p->pRight, pNN, iTab, seenNot) ) return 1;
+      /* Fall thru into the next case */
+    }
+    case TK_SPAN:
+    case TK_COLLATE:
+    case TK_UPLUS:
+    case TK_UMINUS: {
+      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, seenNot);
+    }
+    case TK_TRUTH: {
+      if( seenNot ) return 0;
+      if( p->op2!=TK_IS ) return 0;
+      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
+    }
+    case TK_BITNOT:
+    case TK_NOT: {
+      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
+    }
+  }
+  return 0;
+}
+
 /*
 ** Return true if we can prove the pE2 will always be true if pE1 is
 ** true.  Return false if we cannot complete the proof or if pE2 might
 ** be false.  Examples:
 **
@@ -101822,14 +102634,14 @@
    && (sqlite3ExprImpliesExpr(pParse, pE1, pE2->pLeft, iTab)
              || sqlite3ExprImpliesExpr(pParse, pE1, pE2->pRight, iTab) )
   ){
     return 1;
   }
-  if( pE2->op==TK_NOTNULL && pE1->op!=TK_ISNULL && pE1->op!=TK_IS ){
-    Expr *pX = sqlite3ExprSkipCollate(pE1->pLeft);
-    testcase( pX!=pE1->pLeft );
-    if( sqlite3ExprCompare(pParse, pX, pE2->pLeft, iTab)==0 ) return 1;
+  if( pE2->op==TK_NOTNULL
+   && exprImpliesNotNull(pParse, pE1, pE2->pLeft, iTab, 0)
+  ){
+    return 1;
   }
   return 0;
 }
 
 /*
@@ -101845,35 +102657,47 @@
   testcase( pExpr->op==TK_AGG_COLUMN );
   testcase( pExpr->op==TK_AGG_FUNCTION );
   if( ExprHasProperty(pExpr, EP_FromJoin) ) return WRC_Prune;
   switch( pExpr->op ){
     case TK_ISNOT:
-    case TK_NOT:
     case TK_ISNULL:
     case TK_NOTNULL:
     case TK_IS:
     case TK_OR:
     case TK_CASE:
     case TK_IN:
     case TK_FUNCTION:
+    case TK_TRUTH:
       testcase( pExpr->op==TK_ISNOT );
-      testcase( pExpr->op==TK_NOT );
       testcase( pExpr->op==TK_ISNULL );
       testcase( pExpr->op==TK_NOTNULL );
       testcase( pExpr->op==TK_IS );
       testcase( pExpr->op==TK_OR );
       testcase( pExpr->op==TK_CASE );
       testcase( pExpr->op==TK_IN );
       testcase( pExpr->op==TK_FUNCTION );
+      testcase( pExpr->op==TK_TRUTH );
       return WRC_Prune;
     case TK_COLUMN:
       if( pWalker->u.iCur==pExpr->iTable ){
         pWalker->eCode = 1;
         return WRC_Abort;
       }
       return WRC_Prune;
 
+    case TK_AND:
+      if( sqlite3ExprImpliesNonNullRow(pExpr->pLeft, pWalker->u.iCur)
+       && sqlite3ExprImpliesNonNullRow(pExpr->pRight, pWalker->u.iCur)
+      ){
+        pWalker->eCode = 1;
+      }
+      return WRC_Prune;
+
+    case TK_BETWEEN:
+      sqlite3WalkExpr(pWalker, pExpr->pLeft);
+      return WRC_Prune;
+
     /* Virtual tables are allowed to use constraints like x=NULL.  So
     ** a term of the form x=y does not prove that y is not null if x
     ** is the column of a virtual table */
     case TK_EQ:
     case TK_NE:
@@ -101890,10 +102714,11 @@
       if( (pExpr->pLeft->op==TK_COLUMN && IsVirtual(pExpr->pLeft->y.pTab))
        || (pExpr->pRight->op==TK_COLUMN && IsVirtual(pExpr->pRight->y.pTab))
       ){
        return WRC_Prune;
       }
+
     default:
       return WRC_Continue;
   }
 }
 
@@ -101919,11 +102744,11 @@
 ** be non-NULL, then the LEFT JOIN can be safely converted into an
 ** ordinary join.
 */
 SQLITE_PRIVATE int sqlite3ExprImpliesNonNullRow(Expr *p, int iTab){
   Walker w;
-  p = sqlite3ExprSkipCollate(p);
+  p = sqlite3ExprSkipCollateAndLikely(p);
   while( p ){
     if( p->op==TK_NOTNULL ){
       p = p->pLeft;
     }else if( p->op==TK_AND ){
       if( sqlite3ExprImpliesNonNullRow(p->pLeft, iTab) ) return 1;
@@ -102025,11 +102850,14 @@
     for(i=0; i<nSrc; i++){
       if( pExpr->iTable==pSrc->a[i].iCursor ) break;
     }
     if( i<nSrc ){
       p->nThis++;
-    }else{
+    }else if( nSrc==0 || pExpr->iTable<pSrc->a[0].iCursor ){
+      /* In a well-formed parse tree (no name resolution errors),
+      ** TK_COLUMN nodes with smaller Expr.iTable values are in an
+      ** outer context.  Those are the only ones to count as "other" */
       p->nOther++;
     }
   }
   return WRC_Continue;
 }
@@ -102042,12 +102870,13 @@
 */
 SQLITE_PRIVATE int sqlite3FunctionUsesThisSrc(Expr *pExpr, SrcList *pSrcList){
   Walker w;
   struct SrcCount cnt;
   assert( pExpr->op==TK_AGG_FUNCTION );
+  memset(&w, 0, sizeof(w));
   w.xExprCallback = exprSrcCount;
-  w.xSelectCallback = 0;
+  w.xSelectCallback = sqlite3SelectWalkNoop;
   w.u.pSrcCount = &cnt;
   cnt.pSrc = pSrcList;
   cnt.nThis = 0;
   cnt.nOther = 0;
   sqlite3WalkExprList(&w, pExpr->x.pList);
@@ -102312,10 +103141,15 @@
   }
 }
 
 /*
 ** Mark all temporary registers as being unavailable for reuse.
+**
+** Always invoke this procedure after coding a subroutine or co-routine
+** that might be invoked from other parts of the code, to ensure that
+** the sub/co-routine does not use registers in common with the code that
+** invokes the sub/co-routine.
 */
 SQLITE_PRIVATE void sqlite3ClearTempRegCache(Parse *pParse){
   pParse->nTempReg = 0;
   pParse->nRangeReg = 0;
 }
@@ -102399,22 +103233,22 @@
 */
 static void renameTestSchema(Parse *pParse, const char *zDb, int bTemp){
   sqlite3NestedParse(pParse,
       "SELECT 1 "
       "FROM \"%w\".%s "
-      "WHERE name NOT LIKE 'sqlite_%%'"
+      "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
       " AND sql NOT LIKE 'create virtual%%'"
       " AND sqlite_rename_test(%Q, sql, type, name, %d)=NULL ",
       zDb, MASTER_NAME,
       zDb, bTemp
   );
 
   if( bTemp==0 ){
     sqlite3NestedParse(pParse,
         "SELECT 1 "
         "FROM temp.%s "
-        "WHERE name NOT LIKE 'sqlite_%%'"
+        "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
         " AND sql NOT LIKE 'create virtual%%'"
         " AND sqlite_rename_test(%Q, sql, type, name, 1)=NULL ",
         MASTER_NAME, zDb
     );
   }
@@ -102481,12 +103315,12 @@
   ** that the table is being renamed to.
   */
   if( SQLITE_OK!=isAlterableTable(pParse, pTab) ){
     goto exit_rename_table;
   }
-  if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){ goto
-    exit_rename_table;
+  if( SQLITE_OK!=sqlite3CheckObjectName(pParse,zName,"table",zName) ){
+    goto exit_rename_table;
   }
 
 #ifndef SQLITE_OMIT_VIEW
   if( pTab->pSelect ){
     sqlite3ErrorMsg(pParse, "view %s may not be altered", pTab->zName);
@@ -102531,22 +103365,23 @@
   ** the schema to use the new table name.  */
   sqlite3NestedParse(pParse,
       "UPDATE \"%w\".%s SET "
       "sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, %d) "
       "WHERE (type!='index' OR tbl_name=%Q COLLATE nocase)"
-      "AND   name NOT LIKE 'sqlite_%%'"
+      "AND   name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
       , zDb, MASTER_NAME, zDb, zTabName, zName, (iDb==1), zTabName
   );
 
   /* Update the tbl_name and name columns of the sqlite_master table
   ** as required.  */
   sqlite3NestedParse(pParse,
       "UPDATE %Q.%s SET "
           "tbl_name = %Q, "
           "name = CASE "
             "WHEN type='table' THEN %Q "
-            "WHEN name LIKE 'sqlite_autoindex%%' AND type='index' THEN "
+            "WHEN name LIKE 'sqliteX_autoindex%%' ESCAPE 'X' "
+            "     AND type='index' THEN "
              "'sqlite_autoindex_' || %Q || substr(name,%d+18) "
             "ELSE name END "
       "WHERE tbl_name=%Q COLLATE nocase AND "
           "(type='table' OR type='index' OR type='trigger');",
       zDb, MASTER_NAME,
@@ -102779,10 +103614,11 @@
   }
   if( SQLITE_OK!=isAlterableTable(pParse, pTab) ){
     goto exit_begin_add_column;
   }
 
+  sqlite3MayAbort(pParse);
   assert( pTab->addColOffset>0 );
   iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
 
   /* Put a copy of the Table struct in Parse.pNewTable for the
   ** sqlite3AddColumn() function and friends to modify.  But modify
@@ -102916,11 +103752,12 @@
   assert( pNew->n>0 );
   bQuote = sqlite3Isquote(pNew->z[0]);
   sqlite3NestedParse(pParse,
       "UPDATE \"%w\".%s SET "
       "sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, %d) "
-      "WHERE name NOT LIKE 'sqlite_%%' AND (type != 'index' OR tbl_name = %Q)"
+      "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' "
+      " AND (type != 'index' OR tbl_name = %Q)"
       " AND sql NOT LIKE 'create virtual%%'",
       zDb, MASTER_NAME,
       zDb, pTab->zName, iCol, zNew, bQuote, iSchema==1,
       pTab->zName
   );
@@ -103070,18 +103907,42 @@
   Parse *pParse = pWalker->pParse;
   sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);
   return WRC_Continue;
 }
 
+/*
+** Walker callback used by sqlite3RenameExprUnmap().
+*/
+static int renameUnmapSelectCb(Walker *pWalker, Select *p){
+  Parse *pParse = pWalker->pParse;
+  int i;
+  if( ALWAYS(p->pEList) ){
+    ExprList *pList = p->pEList;
+    for(i=0; i<pList->nExpr; i++){
+      if( pList->a[i].zName ){
+        sqlite3RenameTokenRemap(pParse, 0, (void*)pList->a[i].zName);
+      }
+    }
+  }
+  if( ALWAYS(p->pSrc) ){  /* Every Select as a SrcList, even if it is empty */
+    SrcList *pSrc = p->pSrc;
+    for(i=0; i<pSrc->nSrc; i++){
+      sqlite3RenameTokenRemap(pParse, 0, (void*)pSrc->a[i].zName);
+    }
+  }
+  return WRC_Continue;
+}
+
 /*
 ** Remove all nodes that are part of expression pExpr from the rename list.
 */
 SQLITE_PRIVATE void sqlite3RenameExprUnmap(Parse *pParse, Expr *pExpr){
   Walker sWalker;
   memset(&sWalker, 0, sizeof(Walker));
   sWalker.pParse = pParse;
   sWalker.xExprCallback = renameUnmapExprCb;
+  sWalker.xSelectCallback = renameUnmapSelectCb;
   sqlite3WalkExpr(&sWalker, pExpr);
 }
 
 /*
 ** Remove all nodes that are part of expression-list pEList from the
@@ -104017,17 +104878,17 @@
 ** Additional tables might be added in future releases of SQLite.
 ** The sqlite_stat2 table is not created or used unless the SQLite version
 ** is between 3.6.18 and 3.7.8, inclusive, and unless SQLite is compiled
 ** with SQLITE_ENABLE_STAT2.  The sqlite_stat2 table is deprecated.
 ** The sqlite_stat2 table is superseded by sqlite_stat3, which is only
-** created and used by SQLite versions 3.7.9 and later and with
+** created and used by SQLite versions 3.7.9 through 3.29.0 when
 ** SQLITE_ENABLE_STAT3 defined.  The functionality of sqlite_stat3
-** is a superset of sqlite_stat2.  The sqlite_stat4 is an enhanced
-** version of sqlite_stat3 and is only available when compiled with
-** SQLITE_ENABLE_STAT4 and in SQLite versions 3.8.1 and later.  It is
-** not possible to enable both STAT3 and STAT4 at the same time.  If they
-** are both enabled, then STAT4 takes precedence.
+** is a superset of sqlite_stat2 and is also now deprecated.  The
+** sqlite_stat4 is an enhanced version of sqlite_stat3 and is only
+** available when compiled with SQLITE_ENABLE_STAT4 and in SQLite
+** versions 3.8.1 and later.  STAT4 is the only variant that is still
+** supported.
 **
 ** For most applications, sqlite_stat1 provides all the statistics required
 ** for the query planner to make good choices.
 **
 ** Format of sqlite_stat1:
@@ -104134,21 +104995,15 @@
 #ifndef SQLITE_OMIT_ANALYZE
 /* #include "sqliteInt.h" */
 
 #if defined(SQLITE_ENABLE_STAT4)
 # define IsStat4     1
-# define IsStat3     0
-#elif defined(SQLITE_ENABLE_STAT3)
-# define IsStat4     0
-# define IsStat3     1
 #else
 # define IsStat4     0
-# define IsStat3     0
 # undef SQLITE_STAT4_SAMPLES
 # define SQLITE_STAT4_SAMPLES 1
 #endif
-#define IsStat34    (IsStat3+IsStat4)  /* 1 for STAT3 or STAT4. 0 otherwise */
 
 /*
 ** This routine generates code that opens the sqlite_statN tables.
 ** The sqlite_stat1 table is always relevant.  sqlite_stat2 is now
 ** obsolete.  sqlite_stat3 and sqlite_stat4 are only opened when
@@ -104173,18 +105028,14 @@
     const char *zCols;
   } aTable[] = {
     { "sqlite_stat1", "tbl,idx,stat" },
 #if defined(SQLITE_ENABLE_STAT4)
     { "sqlite_stat4", "tbl,idx,neq,nlt,ndlt,sample" },
-    { "sqlite_stat3", 0 },
-#elif defined(SQLITE_ENABLE_STAT3)
-    { "sqlite_stat3", "tbl,idx,neq,nlt,ndlt,sample" },
-    { "sqlite_stat4", 0 },
 #else
-    { "sqlite_stat3", 0 },
     { "sqlite_stat4", 0 },
 #endif
+    { "sqlite_stat3", 0 },
   };
   int i;
   sqlite3 *db = pParse->db;
   Db *pDb;
   Vdbe *v = sqlite3GetVdbe(pParse);
@@ -104261,11 +105112,11 @@
 typedef struct Stat4Accum Stat4Accum;
 typedef struct Stat4Sample Stat4Sample;
 struct Stat4Sample {
   tRowcnt *anEq;                  /* sqlite_stat4.nEq */
   tRowcnt *anDLt;                 /* sqlite_stat4.nDLt */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   tRowcnt *anLt;                  /* sqlite_stat4.nLt */
   union {
     i64 iRowid;                     /* Rowid in main table of the key */
     u8 *aRowid;                     /* Key for WITHOUT ROWID tables */
   } u;
@@ -104292,11 +105143,11 @@
   sqlite3 *db;              /* Database connection, for malloc() */
 };
 
 /* Reclaim memory used by a Stat4Sample
 */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
 static void sampleClear(sqlite3 *db, Stat4Sample *p){
   assert( db!=0 );
   if( p->nRowid ){
     sqlite3DbFree(db, p->u.aRowid);
     p->nRowid = 0;
@@ -104304,11 +105155,11 @@
 }
 #endif
 
 /* Initialize the BLOB value of a ROWID
 */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
 static void sampleSetRowid(sqlite3 *db, Stat4Sample *p, int n, const u8 *pData){
   assert( db!=0 );
   if( p->nRowid ) sqlite3DbFree(db, p->u.aRowid);
   p->u.aRowid = sqlite3DbMallocRawNN(db, n);
   if( p->u.aRowid ){
@@ -104320,11 +105171,11 @@
 }
 #endif
 
 /* Initialize the INTEGER value of a ROWID.
 */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
 static void sampleSetRowidInt64(sqlite3 *db, Stat4Sample *p, i64 iRowid){
   assert( db!=0 );
   if( p->nRowid ) sqlite3DbFree(db, p->u.aRowid);
   p->nRowid = 0;
   p->u.iRowid = iRowid;
@@ -104333,11 +105184,11 @@
 
 
 /*
 ** Copy the contents of object (*pFrom) into (*pTo).
 */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
 static void sampleCopy(Stat4Accum *p, Stat4Sample *pTo, Stat4Sample *pFrom){
   pTo->isPSample = pFrom->isPSample;
   pTo->iCol = pFrom->iCol;
   pTo->iHash = pFrom->iHash;
   memcpy(pTo->anEq, pFrom->anEq, sizeof(tRowcnt)*p->nCol);
@@ -104354,11 +105205,11 @@
 /*
 ** Reclaim all memory of a Stat4Accum structure.
 */
 static void stat4Destructor(void *pOld){
   Stat4Accum *p = (Stat4Accum*)pOld;
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   int i;
   for(i=0; i<p->nCol; i++) sampleClear(p->db, p->aBest+i);
   for(i=0; i<p->mxSample; i++) sampleClear(p->db, p->a+i);
   sampleClear(p->db, &p->current);
 #endif
@@ -104374,11 +105225,11 @@
 **
 ** Note 1:  In the special case of the covering index that implements a
 ** WITHOUT ROWID table, N is the number of PRIMARY KEY columns, not the
 ** total number of columns in the table.
 **
-** Note 2:  C is only used for STAT3 and STAT4.
+** Note 2:  C is only used for STAT4.
 **
 ** For indexes on ordinary rowid tables, N==K+1.  But for indexes on
 ** WITHOUT ROWID tables, N=K+P where P is the number of columns in the
 ** PRIMARY KEY of the table.  The covering index that implements the
 ** original WITHOUT ROWID table as N==K as a special case.
@@ -104397,11 +105248,11 @@
   int nCol;                       /* Number of columns in index being sampled */
   int nKeyCol;                    /* Number of key columns */
   int nColUp;                     /* nCol rounded up for alignment */
   int n;                          /* Bytes of space to allocate */
   sqlite3 *db;                    /* Database connection */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   int mxSample = SQLITE_STAT4_SAMPLES;
 #endif
 
   /* Decode the three function arguments */
   UNUSED_PARAMETER(argc);
@@ -104414,11 +105265,11 @@
 
   /* Allocate the space required for the Stat4Accum object */
   n = sizeof(*p)
     + sizeof(tRowcnt)*nColUp                  /* Stat4Accum.anEq */
     + sizeof(tRowcnt)*nColUp                  /* Stat4Accum.anDLt */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
     + sizeof(tRowcnt)*nColUp                  /* Stat4Accum.anLt */
     + sizeof(Stat4Sample)*(nCol+mxSample)     /* Stat4Accum.aBest[], a[] */
     + sizeof(tRowcnt)*3*nColUp*(nCol+mxSample)
 #endif
   ;
@@ -104434,11 +105285,11 @@
   p->nCol = nCol;
   p->nKeyCol = nKeyCol;
   p->current.anDLt = (tRowcnt*)&p[1];
   p->current.anEq = &p->current.anDLt[nColUp];
 
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   {
     u8 *pSpace;                     /* Allocated space not yet assigned */
     int i;                          /* Used to iterate through p->aSample[] */
 
     p->iGet = -1;
@@ -104469,11 +105320,11 @@
   ** (given by the 3rd parameter) is never used and can be any positive
   ** value. */
   sqlite3_result_blob(context, p, sizeof(*p), stat4Destructor);
 }
 static const FuncDef statInitFuncdef = {
-  2+IsStat34,      /* nArg */
+  2+IsStat4,       /* nArg */
   SQLITE_UTF8,     /* funcFlags */
   0,               /* pUserData */
   0,               /* pNext */
   statInit,        /* xSFunc */
   0,               /* xFinalize */
@@ -104509,11 +105360,11 @@
   if( pNew->iHash>pOld->iHash ) return 1;
   return 0;
 }
 #endif
 
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
 /*
 ** Return true if pNew is to be preferred over pOld.
 **
 ** This function assumes that for each argument sample, the contents of
 ** the anEq[] array from pSample->anEq[pSample->iCol] onwards are valid.
@@ -104528,19 +105379,15 @@
 
   assert( pOld->isPSample==0 && pNew->isPSample==0 );
   assert( IsStat4 || (pNew->iCol==0 && pOld->iCol==0) );
 
   if( (nEqNew>nEqOld) ) return 1;
-#ifdef SQLITE_ENABLE_STAT4
   if( nEqNew==nEqOld ){
     if( pNew->iCol<pOld->iCol ) return 1;
     return (pNew->iCol==pOld->iCol && sampleIsBetterPost(pAccum, pNew, pOld));
   }
   return 0;
-#else
-  return (nEqNew==nEqOld && pNew->iHash>pOld->iHash);
-#endif
 }
 
 /*
 ** Copy the contents of sample *pNew into the p->a[] array. If necessary,
 ** remove the least desirable sample from p->a[] to make room.
@@ -104549,11 +105396,10 @@
   Stat4Sample *pSample = 0;
   int i;
 
   assert( IsStat4 || nEqZero==0 );
 
-#ifdef SQLITE_ENABLE_STAT4
   /* Stat4Accum.nMaxEqZero is set to the maximum number of leading 0
   ** values in the anEq[] array of any sample in Stat4Accum.a[]. In
   ** other words, if nMaxEqZero is n, then it is guaranteed that there
   ** are no samples with Stat4Sample.anEq[m]==0 for (m>=n). */
   if( nEqZero>p->nMaxEqZero ){
@@ -104583,11 +105429,10 @@
       pUpgrade->iCol = pNew->iCol;
       pUpgrade->anEq[pUpgrade->iCol] = pNew->anEq[pUpgrade->iCol];
       goto find_new_min;
     }
   }
-#endif
 
   /* If necessary, remove sample iMin to make room for the new sample. */
   if( p->nSample>=p->mxSample ){
     Stat4Sample *pMin = &p->a[p->iMin];
     tRowcnt *anEq = pMin->anEq;
@@ -104604,26 +105449,22 @@
   }
 
   /* The "rows less-than" for the rowid column must be greater than that
   ** for the last sample in the p->a[] array. Otherwise, the samples would
   ** be out of order. */
-#ifdef SQLITE_ENABLE_STAT4
   assert( p->nSample==0
        || pNew->anLt[p->nCol-1] > p->a[p->nSample-1].anLt[p->nCol-1] );
-#endif
 
   /* Insert the new sample */
   pSample = &p->a[p->nSample];
   sampleCopy(p, pSample, pNew);
   p->nSample++;
 
   /* Zero the first nEqZero entries in the anEq[] array. */
   memset(pSample->anEq, 0, sizeof(tRowcnt)*nEqZero);
 
-#ifdef SQLITE_ENABLE_STAT4
- find_new_min:
-#endif
+find_new_min:
   if( p->nSample>=p->mxSample ){
     int iMin = -1;
     for(i=0; i<p->mxSample; i++){
       if( p->a[i].isPSample ) continue;
       if( iMin<0 || sampleIsBetter(p, &p->a[iMin], &p->a[i]) ){
@@ -104632,11 +105473,11 @@
     }
     assert( iMin>=0 );
     p->iMin = iMin;
   }
 }
-#endif /* SQLITE_ENABLE_STAT3_OR_STAT4 */
+#endif /* SQLITE_ENABLE_STAT4 */
 
 /*
 ** Field iChng of the index being scanned has changed. So at this point
 ** p->current contains a sample that reflects the previous row of the
 ** index. The value of anEq[iChng] and subsequent anEq[] elements are
@@ -104673,32 +105514,11 @@
     }
     p->nMaxEqZero = iChng;
   }
 #endif
 
-#if defined(SQLITE_ENABLE_STAT3) && !defined(SQLITE_ENABLE_STAT4)
-  if( iChng==0 ){
-    tRowcnt nLt = p->current.anLt[0];
-    tRowcnt nEq = p->current.anEq[0];
-
-    /* Check if this is to be a periodic sample. If so, add it. */
-    if( (nLt/p->nPSample)!=(nLt+nEq)/p->nPSample ){
-      p->current.isPSample = 1;
-      sampleInsert(p, &p->current, 0);
-      p->current.isPSample = 0;
-    }else
-
-    /* Or if it is a non-periodic sample. Add it in this case too. */
-    if( p->nSample<p->mxSample
-     || sampleIsBetter(p, &p->current, &p->a[p->iMin])
-    ){
-      sampleInsert(p, &p->current, 0);
-    }
-  }
-#endif
-
-#ifndef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifndef SQLITE_ENABLE_STAT4
   UNUSED_PARAMETER( p );
   UNUSED_PARAMETER( iChng );
 #endif
 }
 
@@ -104714,11 +105534,11 @@
 ** This SQL function always returns NULL.  It's purpose it to accumulate
 ** statistical data and/or samples in the Stat4Accum object about the
 ** index being analyzed.  The stat_get() SQL function will later be used to
 ** extract relevant information for constructing the sqlite_statN tables.
 **
-** The R parameter is only used for STAT3 and STAT4
+** The R parameter is only used for STAT4
 */
 static void statPush(
   sqlite3_context *context,
   int argc,
   sqlite3_value **argv
@@ -104746,18 +105566,18 @@
     for(i=0; i<iChng; i++){
       p->current.anEq[i]++;
     }
     for(i=iChng; i<p->nCol; i++){
       p->current.anDLt[i]++;
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
       p->current.anLt[i] += p->current.anEq[i];
 #endif
       p->current.anEq[i] = 1;
     }
   }
   p->nRow++;
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   if( sqlite3_value_type(argv[2])==SQLITE_INTEGER ){
     sampleSetRowidInt64(p->db, &p->current, sqlite3_value_int64(argv[2]));
   }else{
     sampleSetRowid(p->db, &p->current, sqlite3_value_bytes(argv[2]),
                                        sqlite3_value_blob(argv[2]));
@@ -104786,11 +105606,11 @@
     }
   }
 #endif
 }
 static const FuncDef statPushFuncdef = {
-  2+IsStat34,      /* nArg */
+  2+IsStat4,       /* nArg */
   SQLITE_UTF8,     /* funcFlags */
   0,               /* pUserData */
   0,               /* pNext */
   statPush,        /* xSFunc */
   0,               /* xFinalize */
@@ -104817,23 +105637,23 @@
 ** inserted as part of a manually constructed bytecode program.  (See
 ** the callStatGet() routine below.)  It is guaranteed that the P
 ** parameter will always be a poiner to a Stat4Accum object, never a
 ** NULL.
 **
-** If neither STAT3 nor STAT4 are enabled, then J is always
+** If STAT4 is not enabled, then J is always
 ** STAT_GET_STAT1 and is hence omitted and this routine becomes
 ** a one-parameter function, stat_get(P), that always returns the
 ** stat1 table entry information.
 */
 static void statGet(
   sqlite3_context *context,
   int argc,
   sqlite3_value **argv
 ){
   Stat4Accum *p = (Stat4Accum*)sqlite3_value_blob(argv[0]);
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
-  /* STAT3 and STAT4 have a parameter on this routine. */
+#ifdef SQLITE_ENABLE_STAT4
+  /* STAT4 has a parameter on this routine. */
   int eCall = sqlite3_value_int(argv[1]);
   assert( argc==2 );
   assert( eCall==STAT_GET_STAT1 || eCall==STAT_GET_NEQ
        || eCall==STAT_GET_ROWID || eCall==STAT_GET_NLT
        || eCall==STAT_GET_NDLT
@@ -104884,11 +105704,11 @@
     }
     assert( z[0]=='\0' && z>zRet );
 
     sqlite3_result_text(context, zRet, -1, sqlite3_free);
   }
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   else if( eCall==STAT_GET_ROWID ){
     if( p->iGet<0 ){
       samplePushPrevious(p, 0);
       p->iGet = 0;
     }
@@ -104913,13 +105733,11 @@
         p->iGet++;
         break;
       }
     }
 
-    if( IsStat3 ){
-      sqlite3_result_int64(context, (i64)aCnt[0]);
-    }else{
+    {
       char *zRet = sqlite3MallocZero(p->nCol * 25);
       if( zRet==0 ){
         sqlite3_result_error_nomem(context);
       }else{
         int i;
@@ -104932,17 +105750,17 @@
         z[-1] = '\0';
         sqlite3_result_text(context, zRet, -1, sqlite3_free);
       }
     }
   }
-#endif /* SQLITE_ENABLE_STAT3_OR_STAT4 */
+#endif /* SQLITE_ENABLE_STAT4 */
 #ifndef SQLITE_DEBUG
   UNUSED_PARAMETER( argc );
 #endif
 }
 static const FuncDef statGetFuncdef = {
-  1+IsStat34,      /* nArg */
+  1+IsStat4,       /* nArg */
   SQLITE_UTF8,     /* funcFlags */
   0,               /* pUserData */
   0,               /* pNext */
   statGet,         /* xSFunc */
   0,               /* xFinalize */
@@ -104951,20 +105769,20 @@
   {0}
 };
 
 static void callStatGet(Vdbe *v, int regStat4, int iParam, int regOut){
   assert( regOut!=regStat4 && regOut!=regStat4+1 );
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   sqlite3VdbeAddOp2(v, OP_Integer, iParam, regStat4+1);
 #elif SQLITE_DEBUG
   assert( iParam==STAT_GET_STAT1 );
 #else
   UNUSED_PARAMETER( iParam );
 #endif
   sqlite3VdbeAddOp4(v, OP_Function0, 0, regStat4, regOut,
                     (char*)&statGetFuncdef, P4_FUNCDEF);
-  sqlite3VdbeChangeP5(v, 1 + IsStat34);
+  sqlite3VdbeChangeP5(v, 1 + IsStat4);
 }
 
 /*
 ** Generate code to do an analysis of all indices associated with
 ** a single table.
@@ -104987,11 +105805,11 @@
   int iDb;                     /* Index of database containing pTab */
   u8 needTableCnt = 1;         /* True to count the table */
   int regNewRowid = iMem++;    /* Rowid for the inserted record */
   int regStat4 = iMem++;       /* Register to hold Stat4Accum object */
   int regChng = iMem++;        /* Index of changed index field */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   int regRowid = iMem++;       /* Rowid argument passed to stat_push() */
 #endif
   int regTemp = iMem++;        /* Temporary use register */
   int regTabname = iMem++;     /* Register containing table name */
   int regIdxname = iMem++;     /* Register containing index name */
@@ -105121,20 +105939,20 @@
     **        (or for a WITHOUT ROWID table, the number of PK columns),
     **    (2) the number of columns in the key without the rowid/pk
     **    (3) the number of rows in the index,
     **
     **
-    ** The third argument is only used for STAT3 and STAT4
+    ** The third argument is only used for STAT4
     */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
     sqlite3VdbeAddOp2(v, OP_Count, iIdxCur, regStat4+3);
 #endif
     sqlite3VdbeAddOp2(v, OP_Integer, nCol, regStat4+1);
     sqlite3VdbeAddOp2(v, OP_Integer, pIdx->nKeyCol, regStat4+2);
     sqlite3VdbeAddOp4(v, OP_Function0, 0, regStat4+1, regStat4,
                      (char*)&statInitFuncdef, P4_FUNCDEF);
-    sqlite3VdbeChangeP5(v, 2+IsStat34);
+    sqlite3VdbeChangeP5(v, 2+IsStat4);
 
     /* Implementation of the following:
     **
     **   Rewind csr
     **   if eof(csr) goto end_of_scan;
@@ -105201,16 +106019,16 @@
       sqlite3DbFree(db, aGotoChng);
     }
 
     /*
     **  chng_addr_N:
-    **   regRowid = idx(rowid)            // STAT34 only
-    **   stat_push(P, regChng, regRowid)  // 3rd parameter STAT34 only
+    **   regRowid = idx(rowid)            // STAT4 only
+    **   stat_push(P, regChng, regRowid)  // 3rd parameter STAT4 only
     **   Next csr
     **   if !eof(csr) goto next_row;
     */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
     assert( regRowid==(regStat4+2) );
     if( HasRowid(pTab) ){
       sqlite3VdbeAddOp2(v, OP_IdxRowid, iIdxCur, regRowid);
     }else{
       Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);
@@ -105227,11 +106045,11 @@
     }
 #endif
     assert( regChng==(regStat4+1) );
     sqlite3VdbeAddOp4(v, OP_Function0, 1, regStat4, regTemp,
                      (char*)&statPushFuncdef, P4_FUNCDEF);
-    sqlite3VdbeChangeP5(v, 2+IsStat34);
+    sqlite3VdbeChangeP5(v, 2+IsStat4);
     sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, addrNextRow); VdbeCoverage(v);
 
     /* Add the entry to the stat1 table. */
     callStatGet(v, regStat4, STAT_GET_STAT1, regStat1);
     assert( "BBB"[0]==SQLITE_AFF_TEXT );
@@ -105241,12 +106059,12 @@
 #ifdef SQLITE_ENABLE_PREUPDATE_HOOK
     sqlite3VdbeChangeP4(v, -1, (char*)pStat1, P4_TABLE);
 #endif
     sqlite3VdbeChangeP5(v, OPFLAG_APPEND);
 
-    /* Add the entries to the stat3 or stat4 table. */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+    /* Add the entries to the stat4 table. */
+#ifdef SQLITE_ENABLE_STAT4
     {
       int regEq = regStat1;
       int regLt = regStat1+1;
       int regDLt = regStat1+2;
       int regSample = regStat1+3;
@@ -105265,25 +106083,21 @@
       callStatGet(v, regStat4, STAT_GET_NEQ, regEq);
       callStatGet(v, regStat4, STAT_GET_NLT, regLt);
       callStatGet(v, regStat4, STAT_GET_NDLT, regDLt);
       sqlite3VdbeAddOp4Int(v, seekOp, iTabCur, addrNext, regSampleRowid, 0);
       VdbeCoverage(v);
-#ifdef SQLITE_ENABLE_STAT3
-      sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iTabCur, 0, regSample);
-#else
       for(i=0; i<nCol; i++){
         sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iTabCur, i, regCol+i);
       }
       sqlite3VdbeAddOp3(v, OP_MakeRecord, regCol, nCol, regSample);
-#endif
       sqlite3VdbeAddOp3(v, OP_MakeRecord, regTabname, 6, regTemp);
       sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur+1, regNewRowid);
       sqlite3VdbeAddOp3(v, OP_Insert, iStatCur+1, regTemp, regNewRowid);
       sqlite3VdbeAddOp2(v, OP_Goto, 1, addrNext); /* P1==1 for end-of-loop */
       sqlite3VdbeJumpHere(v, addrIsNull);
     }
-#endif /* SQLITE_ENABLE_STAT3_OR_STAT4 */
+#endif /* SQLITE_ENABLE_STAT4 */
 
     /* End of analysis */
     sqlite3VdbeJumpHere(v, addrRewind);
   }
 
@@ -105454,44 +106268,46 @@
   char *z = zIntArray;
   int c;
   int i;
   tRowcnt v;
 
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   if( z==0 ) z = "";
 #else
   assert( z!=0 );
 #endif
   for(i=0; *z && i<nOut; i++){
     v = 0;
     while( (c=z[0])>='0' && c<='9' ){
       v = v*10 + c - '0';
       z++;
     }
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
     if( aOut ) aOut[i] = v;
     if( aLog ) aLog[i] = sqlite3LogEst(v);
 #else
     assert( aOut==0 );
     UNUSED_PARAMETER(aOut);
     assert( aLog!=0 );
     aLog[i] = sqlite3LogEst(v);
 #endif
     if( *z==' ' ) z++;
   }
-#ifndef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifndef SQLITE_ENABLE_STAT4
   assert( pIndex!=0 ); {
 #else
   if( pIndex ){
 #endif
     pIndex->bUnordered = 0;
     pIndex->noSkipScan = 0;
     while( z[0] ){
       if( sqlite3_strglob("unordered*", z)==0 ){
         pIndex->bUnordered = 1;
       }else if( sqlite3_strglob("sz=[0-9]*", z)==0 ){
-        pIndex->szIdxRow = sqlite3LogEst(sqlite3Atoi(z+3));
+        int sz = sqlite3Atoi(z+3);
+        if( sz<2 ) sz = 2;
+        pIndex->szIdxRow = sqlite3LogEst(sz);
       }else if( sqlite3_strglob("noskipscan*", z)==0 ){
         pIndex->noSkipScan = 1;
       }
 #ifdef SQLITE_ENABLE_COSTMULT
       else if( sqlite3_strglob("costmult=[0-9]*",z)==0 ){
@@ -105541,11 +106357,11 @@
   z = argv[2];
 
   if( pIndex ){
     tRowcnt *aiRowEst = 0;
     int nCol = pIndex->nKeyCol+1;
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
     /* Index.aiRowEst may already be set here if there are duplicate
     ** sqlite_stat1 entries for this index. In that case just clobber
     ** the old data with the new instead of allocating a new array.  */
     if( pIndex->aiRowEst==0 ){
       pIndex->aiRowEst = (tRowcnt*)sqlite3MallocZero(sizeof(tRowcnt) * nCol);
@@ -105577,11 +106393,11 @@
 /*
 ** If the Index.aSample variable is not NULL, delete the aSample[] array
 ** and its contents.
 */
 SQLITE_PRIVATE void sqlite3DeleteIndexSamples(sqlite3 *db, Index *pIdx){
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   if( pIdx->aSample ){
     int j;
     for(j=0; j<pIdx->nSample; j++){
       IndexSample *p = &pIdx->aSample[j];
       sqlite3DbFree(db, p->p);
@@ -105593,14 +106409,14 @@
     pIdx->aSample = 0;
   }
 #else
   UNUSED_PARAMETER(db);
   UNUSED_PARAMETER(pIdx);
-#endif /* SQLITE_ENABLE_STAT3_OR_STAT4 */
+#endif /* SQLITE_ENABLE_STAT4 */
 }
 
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
 /*
 ** Populate the pIdx->aAvgEq[] array based on the samples currently
 ** stored in pIdx->aSample[].
 */
 static void initAvgEq(Index *pIdx){
@@ -105674,25 +106490,23 @@
   }
   return pIdx;
 }
 
 /*
-** Load the content from either the sqlite_stat4 or sqlite_stat3 table
+** Load the content from either the sqlite_stat4
 ** into the relevant Index.aSample[] arrays.
 **
 ** Arguments zSql1 and zSql2 must point to SQL statements that return
-** data equivalent to the following (statements are different for stat3,
-** see the caller of this function for details):
+** data equivalent to the following:
 **
 **    zSql1: SELECT idx,count(*) FROM %Q.sqlite_stat4 GROUP BY idx
 **    zSql2: SELECT idx,neq,nlt,ndlt,sample FROM %Q.sqlite_stat4
 **
 ** where %Q is replaced with the database name before the SQL is executed.
 */
 static int loadStatTbl(
   sqlite3 *db,                  /* Database handle */
-  int bStat3,                   /* Assume single column records only */
   const char *zSql1,            /* SQL statement 1 (see above) */
   const char *zSql2,            /* SQL statement 2 (see above) */
   const char *zDb               /* Database name (e.g. "main") */
 ){
   int rc;                       /* Result codes from subroutines */
@@ -105722,21 +106536,17 @@
 
     zIndex = (char *)sqlite3_column_text(pStmt, 0);
     if( zIndex==0 ) continue;
     nSample = sqlite3_column_int(pStmt, 1);
     pIdx = findIndexOrPrimaryKey(db, zIndex, zDb);
-    assert( pIdx==0 || bStat3 || pIdx->nSample==0 );
-    /* Index.nSample is non-zero at this point if data has already been
-    ** loaded from the stat4 table. In this case ignore stat3 data.  */
-    if( pIdx==0 || pIdx->nSample ) continue;
-    if( bStat3==0 ){
-      assert( !HasRowid(pIdx->pTable) || pIdx->nColumn==pIdx->nKeyCol+1 );
-      if( !HasRowid(pIdx->pTable) && IsPrimaryKeyIndex(pIdx) ){
-        nIdxCol = pIdx->nKeyCol;
-      }else{
-        nIdxCol = pIdx->nColumn;
-      }
+    assert( pIdx==0 || pIdx->nSample==0 );
+    if( pIdx==0 ) continue;
+    assert( !HasRowid(pIdx->pTable) || pIdx->nColumn==pIdx->nKeyCol+1 );
+    if( !HasRowid(pIdx->pTable) && IsPrimaryKeyIndex(pIdx) ){
+      nIdxCol = pIdx->nKeyCol;
+    }else{
+      nIdxCol = pIdx->nColumn;
     }
     pIdx->nSampleCol = nIdxCol;
     nByte = sizeof(IndexSample) * nSample;
     nByte += sizeof(tRowcnt) * nIdxCol * 3 * nSample;
     nByte += nIdxCol * sizeof(tRowcnt);     /* Space for Index.aAvgEq[] */
@@ -105774,13 +106584,12 @@
     zIndex = (char *)sqlite3_column_text(pStmt, 0);
     if( zIndex==0 ) continue;
     pIdx = findIndexOrPrimaryKey(db, zIndex, zDb);
     if( pIdx==0 ) continue;
     /* This next condition is true if data has already been loaded from
-    ** the sqlite_stat4 table. In this case ignore stat3 data.  */
+    ** the sqlite_stat4 table. */
     nCol = pIdx->nSampleCol;
-    if( bStat3 && nCol>1 ) continue;
     if( pIdx!=pPrevIdx ){
       initAvgEq(pPrevIdx);
       pPrevIdx = pIdx;
     }
     pSample = &pIdx->aSample[pIdx->nSample];
@@ -105809,49 +106618,40 @@
   if( rc==SQLITE_OK ) initAvgEq(pPrevIdx);
   return rc;
 }
 
 /*
-** Load content from the sqlite_stat4 and sqlite_stat3 tables into
+** Load content from the sqlite_stat4 table into
 ** the Index.aSample[] arrays of all indices.
 */
 static int loadStat4(sqlite3 *db, const char *zDb){
   int rc = SQLITE_OK;             /* Result codes from subroutines */
 
   assert( db->lookaside.bDisable );
   if( sqlite3FindTable(db, "sqlite_stat4", zDb) ){
-    rc = loadStatTbl(db, 0,
+    rc = loadStatTbl(db,
       "SELECT idx,count(*) FROM %Q.sqlite_stat4 GROUP BY idx",
       "SELECT idx,neq,nlt,ndlt,sample FROM %Q.sqlite_stat4",
       zDb
     );
   }
-
-  if( rc==SQLITE_OK && sqlite3FindTable(db, "sqlite_stat3", zDb) ){
-    rc = loadStatTbl(db, 1,
-      "SELECT idx,count(*) FROM %Q.sqlite_stat3 GROUP BY idx",
-      "SELECT idx,neq,nlt,ndlt,sqlite_record(sample) FROM %Q.sqlite_stat3",
-      zDb
-    );
-  }
-
   return rc;
 }
-#endif /* SQLITE_ENABLE_STAT3_OR_STAT4 */
+#endif /* SQLITE_ENABLE_STAT4 */
 
 /*
-** Load the content of the sqlite_stat1 and sqlite_stat3/4 tables. The
+** Load the content of the sqlite_stat1 and sqlite_stat4 tables. The
 ** contents of sqlite_stat1 are used to populate the Index.aiRowEst[]
-** arrays. The contents of sqlite_stat3/4 are used to populate the
+** arrays. The contents of sqlite_stat4 are used to populate the
 ** Index.aSample[] arrays.
 **
 ** If the sqlite_stat1 table is not present in the database, SQLITE_ERROR
-** is returned. In this case, even if SQLITE_ENABLE_STAT3/4 was defined
-** during compilation and the sqlite_stat3/4 table is present, no data is
+** is returned. In this case, even if SQLITE_ENABLE_STAT4 was defined
+** during compilation and the sqlite_stat4 table is present, no data is
 ** read from it.
 **
-** If SQLITE_ENABLE_STAT3/4 was defined during compilation and the
+** If SQLITE_ENABLE_STAT4 was defined during compilation and the
 ** sqlite_stat4 table is not present in the database, SQLITE_ERROR is
 ** returned. However, in this case, data is read from the sqlite_stat1
 ** table (if it is present) before returning.
 **
 ** If an OOM error occurs, this function always sets db->mallocFailed.
@@ -105875,11 +106675,11 @@
     pTab->tabFlags &= ~TF_HasStat1;
   }
   for(i=sqliteHashFirst(&pSchema->idxHash); i; i=sqliteHashNext(i)){
     Index *pIdx = sqliteHashData(i);
     pIdx->hasStat1 = 0;
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
     sqlite3DeleteIndexSamples(db, pIdx);
     pIdx->aSample = 0;
 #endif
   }
 
@@ -105903,11 +106703,11 @@
     Index *pIdx = sqliteHashData(i);
     if( !pIdx->hasStat1 ) sqlite3DefaultRowEst(pIdx);
   }
 
   /* Load the statistics from the sqlite_stat4 table. */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   if( rc==SQLITE_OK ){
     db->lookaside.bDisable++;
     rc = loadStat4(db, sInfo.zDatabase);
     db->lookaside.bDisable--;
   }
@@ -106228,10 +107028,11 @@
 ){
   const char *zName = (const char *)sqlite3_value_text(argv[0]);
   sqlite3 *db = sqlite3_context_db_handle(context);
   int i;
   Db *pDb = 0;
+  HashElem *pEntry;
   char zErr[128];
 
   UNUSED_PARAMETER(NotUsed);
 
   if( zName==0 ) zName = "";
@@ -106252,10 +107053,22 @@
   if( sqlite3BtreeIsInReadTrans(pDb->pBt) || sqlite3BtreeIsInBackup(pDb->pBt) ){
     sqlite3_snprintf(sizeof(zErr),zErr, "database %s is locked", zName);
     goto detach_error;
   }
 
+  /* If any TEMP triggers reference the schema being detached, move those
+  ** triggers to reference the TEMP schema itself. */
+  assert( db->aDb[1].pSchema );
+  pEntry = sqliteHashFirst(&db->aDb[1].pSchema->trigHash);
+  while( pEntry ){
+    Trigger *pTrig = (Trigger*)sqliteHashData(pEntry);
+    if( pTrig->pTabSchema==pDb->pSchema ){
+      pTrig->pTabSchema = pTrig->pSchema;
+    }
+    pEntry = sqliteHashNext(pEntry);
+  }
+
   sqlite3BtreeClose(pDb->pBt);
   pDb->pBt = 0;
   pDb->pSchema = 0;
   sqlite3CollapseDatabaseArray(db);
   return;
@@ -106489,10 +107302,11 @@
 SQLITE_PRIVATE int sqlite3FixExpr(
   DbFixer *pFix,     /* Context of the fixation */
   Expr *pExpr        /* The expression to be fixed to one database */
 ){
   while( pExpr ){
+    ExprSetProperty(pExpr, EP_Indirect);
     if( pExpr->op==TK_VARIABLE ){
       if( pFix->pParse->db->init.busy ){
         pExpr->op = TK_NULL;
       }else{
         sqlite3ErrorMsg(pFix->pParse, "%s cannot use variables", pFix->zType);
@@ -106641,11 +107455,11 @@
   if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
 #endif
   sqlite3_mutex_enter(db->mutex);
   db->xAuth = (sqlite3_xauth)xAuth;
   db->pAuthArg = pArg;
-  sqlite3ExpirePreparedStatements(db, 0);
+  if( db->xAuth ) sqlite3ExpirePreparedStatements(db, 1);
   sqlite3_mutex_leave(db->mutex);
   return SQLITE_OK;
 }
 
 /*
@@ -107295,11 +108109,11 @@
 #endif
   sqlite3ExprDelete(db, p->pPartIdxWhere);
   sqlite3ExprListDelete(db, p->aColExpr);
   sqlite3DbFree(db, p->zColAff);
   if( p->isResized ) sqlite3DbFree(db, (void *)p->azColl);
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   sqlite3_free(p->aiRowEst);
 #endif
   sqlite3DbFree(db, p);
 }
 
@@ -107457,14 +108271,18 @@
 static void SQLITE_NOINLINE deleteTable(sqlite3 *db, Table *pTable){
   Index *pIndex, *pNext;
 
 #ifdef SQLITE_DEBUG
   /* Record the number of outstanding lookaside allocations in schema Tables
-  ** prior to doing any free() operations.  Since schema Tables do not use
-  ** lookaside, this number should not change. */
+  ** prior to doing any free() operations. Since schema Tables do not use
+  ** lookaside, this number should not change.
+  **
+  ** If malloc has already failed, it may be that it failed while allocating
+  ** a Table object that was going to be marked ephemeral. So do not check
+  ** that no lookaside memory is used in this case either. */
   int nLookaside = 0;
-  if( db && (pTable->tabFlags & TF_Ephemeral)==0 ){
+  if( db && !db->mallocFailed && (pTable->tabFlags & TF_Ephemeral)==0 ){
     nLookaside = sqlite3LookasideUsed(db, 0);
   }
 #endif
 
   /* Delete all indices associated with this table. */
@@ -107664,17 +108482,44 @@
 ** This routine is used to check if the UTF-8 string zName is a legal
 ** unqualified name for a new schema object (table, index, view or
 ** trigger). All names are legal except those that begin with the string
 ** "sqlite_" (in upper, lower or mixed case). This portion of the namespace
 ** is reserved for internal use.
+**
+** When parsing the sqlite_master table, this routine also checks to
+** make sure the "type", "name", and "tbl_name" columns are consistent
+** with the SQL.
 */
-SQLITE_PRIVATE int sqlite3CheckObjectName(Parse *pParse, const char *zName){
-  if( !pParse->db->init.busy && pParse->nested==0
-          && sqlite3WritableSchema(pParse->db)==0
-          && 0==sqlite3StrNICmp(zName, "sqlite_", 7) ){
-    sqlite3ErrorMsg(pParse, "object name reserved for internal use: %s", zName);
-    return SQLITE_ERROR;
+SQLITE_PRIVATE int sqlite3CheckObjectName(
+  Parse *pParse,            /* Parsing context */
+  const char *zName,        /* Name of the object to check */
+  const char *zType,        /* Type of this object */
+  const char *zTblName      /* Parent table name for triggers and indexes */
+){
+  sqlite3 *db = pParse->db;
+  if( sqlite3WritableSchema(db) || db->init.imposterTable ){
+    /* Skip these error checks for writable_schema=ON */
+    return SQLITE_OK;
+  }
+  if( db->init.busy ){
+    if( sqlite3_stricmp(zType, db->init.azInit[0])
+     || sqlite3_stricmp(zName, db->init.azInit[1])
+     || sqlite3_stricmp(zTblName, db->init.azInit[2])
+    ){
+      if( sqlite3Config.bExtraSchemaChecks ){
+        sqlite3ErrorMsg(pParse, ""); /* corruptSchema() will supply the error */
+        return SQLITE_ERROR;
+      }
+    }
+  }else{
+    if( pParse->nested==0
+     && 0==sqlite3StrNICmp(zName, "sqlite_", 7)
+    ){
+      sqlite3ErrorMsg(pParse, "object name reserved for internal use: %s",
+                      zName);
+      return SQLITE_ERROR;
+    }
   }
   return SQLITE_OK;
 }
 
 /*
@@ -107751,11 +108596,11 @@
       sqlite3RenameTokenMap(pParse, (void*)zName, pName);
     }
   }
   pParse->sNameToken = *pName;
   if( zName==0 ) return;
-  if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){
+  if( sqlite3CheckObjectName(pParse, zName, isView?"view":"table", zName) ){
     goto begin_table_error;
   }
   if( db->init.iDb==1 ) isTemp = 1;
 #ifndef SQLITE_OMIT_AUTHORIZATION
   assert( isTemp==0 || isTemp==1 );
@@ -108168,11 +109013,11 @@
 **
 ** This is goofy.  But to preserve backwards compatibility we continue to
 ** accept it.  This routine does the necessary conversion.  It converts
 ** the expression given in its argument from a TK_STRING into a TK_ID
 ** if the expression is just a TK_STRING with an optional COLLATE clause.
-** If the epxression is anything other than TK_STRING, the expression is
+** If the expression is anything other than TK_STRING, the expression is
 ** unchanged.
 */
 static void sqlite3StringToId(Expr *p){
   if( p->op==TK_STRING ){
     p->op = TK_ID;
@@ -108251,11 +109096,11 @@
     }
     pTab->iPKey = iCol;
     pTab->keyConf = (u8)onError;
     assert( autoInc==0 || autoInc==1 );
     pTab->tabFlags |= autoInc*TF_Autoincrement;
-    if( pList ) pParse->iPkSortOrder = pList->a[0].sortOrder;
+    if( pList ) pParse->iPkSortOrder = pList->a[0].sortFlags;
   }else if( autoInc ){
 #ifndef SQLITE_OMIT_AUTOINCREMENT
     sqlite3ErrorMsg(pParse, "AUTOINCREMENT is only allowed on an "
        "INTEGER PRIMARY KEY");
 #endif
@@ -108565,14 +109410,55 @@
     wIndex += x<0 ? 1 : aCol[pIdx->aiColumn[i]].szEst;
   }
   pIdx->szIdxRow = sqlite3LogEst(wIndex*4);
 }
 
-/* Return true if value x is found any of the first nCol entries of aiCol[]
+/* Return true if column number x is any of the first nCol entries of aiCol[].
+** This is used to determine if the column number x appears in any of the
+** first nCol entries of an index.
 */
 static int hasColumn(const i16 *aiCol, int nCol, int x){
-  while( nCol-- > 0 ) if( x==*(aiCol++) ) return 1;
+  while( nCol-- > 0 ){
+    assert( aiCol[0]>=0 );
+    if( x==*(aiCol++) ){
+      return 1;
+    }
+  }
+  return 0;
+}
+
+/*
+** Return true if any of the first nKey entries of index pIdx exactly
+** match the iCol-th entry of pPk.  pPk is always a WITHOUT ROWID
+** PRIMARY KEY index.  pIdx is an index on the same table.  pIdx may
+** or may not be the same index as pPk.
+**
+** The first nKey entries of pIdx are guaranteed to be ordinary columns,
+** not a rowid or expression.
+**
+** This routine differs from hasColumn() in that both the column and the
+** collating sequence must match for this routine, but for hasColumn() only
+** the column name must match.
+*/
+static int isDupColumn(Index *pIdx, int nKey, Index *pPk, int iCol){
+  int i, j;
+  assert( nKey<=pIdx->nColumn );
+  assert( iCol<MAX(pPk->nColumn,pPk->nKeyCol) );
+  assert( pPk->idxType==SQLITE_IDXTYPE_PRIMARYKEY );
+  assert( pPk->pTable->tabFlags & TF_WithoutRowid );
+  assert( pPk->pTable==pIdx->pTable );
+  testcase( pPk==pIdx );
+  j = pPk->aiColumn[iCol];
+  assert( j!=XN_ROWID && j!=XN_EXPR );
+  for(i=0; i<nKey; i++){
+    assert( pIdx->aiColumn[i]>=0 || j>=0 );
+    if( pIdx->aiColumn[i]==j
+     && sqlite3StrICmp(pIdx->azColl[i], pPk->azColl[iCol])==0
+    ){
+      return 1;
+    }
+  }
   return 0;
 }
 
 /* Recompute the colNotIdxed field of the Index.
 **
@@ -108625,10 +109511,11 @@
 */
 static void convertToWithoutRowidTable(Parse *pParse, Table *pTab){
   Index *pIdx;
   Index *pPk;
   int nPk;
+  int nExtra;
   int i, j;
   sqlite3 *db = pParse->db;
   Vdbe *v = pParse->pVdbe;
 
   /* Mark every PRIMARY KEY column as NOT NULL (except for imposter tables)
@@ -108657,39 +109544,46 @@
     Token ipkToken;
     sqlite3TokenInit(&ipkToken, pTab->aCol[pTab->iPKey].zName);
     pList = sqlite3ExprListAppend(pParse, 0,
                   sqlite3ExprAlloc(db, TK_ID, &ipkToken, 0));
     if( pList==0 ) return;
-    pList->a[0].sortOrder = pParse->iPkSortOrder;
+    if( IN_RENAME_OBJECT ){
+      sqlite3RenameTokenRemap(pParse, pList->a[0].pExpr, &pTab->iPKey);
+    }
+    pList->a[0].sortFlags = pParse->iPkSortOrder;
     assert( pParse->pNewTable==pTab );
+    pTab->iPKey = -1;
     sqlite3CreateIndex(pParse, 0, 0, 0, pList, pTab->keyConf, 0, 0, 0, 0,
                        SQLITE_IDXTYPE_PRIMARYKEY);
     if( db->mallocFailed || pParse->nErr ) return;
     pPk = sqlite3PrimaryKeyIndex(pTab);
-    pTab->iPKey = -1;
+    assert( pPk->nKeyCol==1 );
   }else{
     pPk = sqlite3PrimaryKeyIndex(pTab);
     assert( pPk!=0 );
 
     /*
     ** Remove all redundant columns from the PRIMARY KEY.  For example, change
     ** "PRIMARY KEY(a,b,a,b,c,b,c,d)" into just "PRIMARY KEY(a,b,c,d)".  Later
     ** code assumes the PRIMARY KEY contains no repeated columns.
     */
     for(i=j=1; i<pPk->nKeyCol; i++){
-      if( hasColumn(pPk->aiColumn, j, pPk->aiColumn[i]) ){
+      if( isDupColumn(pPk, j, pPk, i) ){
         pPk->nColumn--;
       }else{
+        testcase( hasColumn(pPk->aiColumn, j, pPk->aiColumn[i]) );
+        pPk->azColl[j] = pPk->azColl[i];
+        pPk->aSortOrder[j] = pPk->aSortOrder[i];
         pPk->aiColumn[j++] = pPk->aiColumn[i];
       }
     }
     pPk->nKeyCol = j;
   }
   assert( pPk!=0 );
   pPk->isCovering = 1;
   if( !db->init.imposterTable ) pPk->uniqNotNull = 1;
-  nPk = pPk->nKeyCol;
+  nPk = pPk->nColumn = pPk->nKeyCol;
 
   /* Bypass the creation of the PRIMARY KEY btree and the sqlite_master
   ** table entry. This is only required if currently generating VDBE
   ** code for a CREATE TABLE (not when parsing one as part of reading
   ** a database schema).  */
@@ -108706,46 +109600,54 @@
   */
   for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
     int n;
     if( IsPrimaryKeyIndex(pIdx) ) continue;
     for(i=n=0; i<nPk; i++){
-      if( !hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) ) n++;
+      if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){
+        testcase( hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) );
+        n++;
+      }
     }
     if( n==0 ){
       /* This index is a superset of the primary key */
       pIdx->nColumn = pIdx->nKeyCol;
       continue;
     }
     if( resizeIndexObject(db, pIdx, pIdx->nKeyCol+n) ) return;
     for(i=0, j=pIdx->nKeyCol; i<nPk; i++){
-      if( !hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) ){
+      if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){
+        testcase( hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) );
         pIdx->aiColumn[j] = pPk->aiColumn[i];
         pIdx->azColl[j] = pPk->azColl[i];
+        if( pPk->aSortOrder[i] ){
+          /* See ticket https://www.sqlite.org/src/info/bba7b69f9849b5bf */
+          pIdx->bAscKeyBug = 1;
+        }
         j++;
       }
     }
     assert( pIdx->nColumn>=pIdx->nKeyCol+n );
     assert( pIdx->nColumn>=j );
   }
 
   /* Add all table columns to the PRIMARY KEY index
   */
-  if( nPk<pTab->nCol ){
-    if( resizeIndexObject(db, pPk, pTab->nCol) ) return;
-    for(i=0, j=nPk; i<pTab->nCol; i++){
-      if( !hasColumn(pPk->aiColumn, j, i) ){
-        assert( j<pPk->nColumn );
-        pPk->aiColumn[j] = i;
-        pPk->azColl[j] = sqlite3StrBINARY;
-        j++;
-      }
+  nExtra = 0;
+  for(i=0; i<pTab->nCol; i++){
+    if( !hasColumn(pPk->aiColumn, nPk, i) ) nExtra++;
+  }
+  if( resizeIndexObject(db, pPk, nPk+nExtra) ) return;
+  for(i=0, j=nPk; i<pTab->nCol; i++){
+    if( !hasColumn(pPk->aiColumn, j, i) ){
+      assert( j<pPk->nColumn );
+      pPk->aiColumn[j] = i;
+      pPk->azColl[j] = sqlite3StrBINARY;
+      j++;
     }
-    assert( pPk->nColumn==j );
-    assert( pTab->nCol==j );
-  }else{
-    pPk->nColumn = pTab->nCol;
   }
+  assert( pPk->nColumn==j );
+  assert( pTab->nCol<=j );
   recomputeColumnsNotIndexed(pPk);
 }
 
 #ifndef SQLITE_OMIT_VIRTUALTABLE
 /*
@@ -108938,11 +109840,11 @@
       sqlite3VdbeChangeP5(v, OPFLAG_P2ISREG);
       pParse->nTab = 2;
       addrTop = sqlite3VdbeCurrentAddr(v) + 1;
       sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, addrTop);
       if( pParse->nErr ) return;
-      pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect);
+      pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, SQLITE_AFF_BLOB);
       if( pSelTab==0 ) return;
       assert( p->aCol==0 );
       p->nCol = pSelTab->nCol;
       p->aCol = pSelTab->aCol;
       pSelTab->nCol = 0;
@@ -109202,14 +110104,14 @@
     pTable->nCol = -1;
     db->lookaside.bDisable++;
 #ifndef SQLITE_OMIT_AUTHORIZATION
     xAuth = db->xAuth;
     db->xAuth = 0;
-    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel);
+    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, SQLITE_AFF_NONE);
     db->xAuth = xAuth;
 #else
-    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel);
+    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, SQLITE_AFF_NONE);
 #endif
     pParse->nTab = n;
     if( pTable->pCheck ){
       /* CREATE VIEW name(arglist) AS ...
       ** The names of the columns in the table are taken from
@@ -109221,11 +110123,12 @@
                                  &pTable->nCol, &pTable->aCol);
       if( db->mallocFailed==0
        && pParse->nErr==0
        && pTable->nCol==pSel->pEList->nExpr
       ){
-        sqlite3SelectAddColumnTypeAndCollation(pParse, pTable, pSel);
+        sqlite3SelectAddColumnTypeAndCollation(pParse, pTable, pSel,
+                                               SQLITE_AFF_NONE);
       }
     }else if( pSelTab ){
       /* CREATE VIEW name AS...  without an argument list.  Construct
       ** the column names from the SELECT statement that defines the view.
       */
@@ -109566,11 +110469,12 @@
       goto exit_drop_table;
     }
   }
 #endif
   if( sqlite3StrNICmp(pTab->zName, "sqlite_", 7)==0
-    && sqlite3StrNICmp(pTab->zName, "sqlite_stat", 11)!=0 ){
+    && sqlite3StrNICmp(pTab->zName+7, "stat", 4)!=0
+    && sqlite3StrNICmp(pTab->zName+7, "parameters", 10)!=0 ){
     sqlite3ErrorMsg(pParse, "table %s may not be dropped", pTab->zName);
     goto exit_drop_table;
   }
 
 #ifndef SQLITE_OMIT_VIEW
@@ -109836,14 +110740,31 @@
     sqlite3VdbeAddOp4Int(v, OP_SorterCompare, iSorter, j2, regRecord,
                          pIndex->nKeyCol); VdbeCoverage(v);
     sqlite3UniqueConstraint(pParse, OE_Abort, pIndex);
     sqlite3VdbeJumpHere(v, j2);
   }else{
+    /* Most CREATE INDEX and REINDEX statements that are not UNIQUE can not
+    ** abort. The exception is if one of the indexed expressions contains a
+    ** user function that throws an exception when it is evaluated. But the
+    ** overhead of adding a statement journal to a CREATE INDEX statement is
+    ** very small (since most of the pages written do not contain content that
+    ** needs to be restored if the statement aborts), so we call
+    ** sqlite3MayAbort() for all CREATE INDEX statements.  */
+    sqlite3MayAbort(pParse);
     addr2 = sqlite3VdbeCurrentAddr(v);
   }
   sqlite3VdbeAddOp3(v, OP_SorterData, iSorter, regRecord, iIdx);
-  sqlite3VdbeAddOp1(v, OP_SeekEnd, iIdx);
+  if( !pIndex->bAscKeyBug ){
+    /* This OP_SeekEnd opcode makes index insert for a REINDEX go much
+    ** faster by avoiding unnecessary seeks.  But the optimization does
+    ** not work for UNIQUE constraint indexes on WITHOUT ROWID tables
+    ** with DESC primary keys, since those indexes have there keys in
+    ** a different order from the main table.
+    ** See ticket: https://www.sqlite.org/src/info/bba7b69f9849b5bf
+    */
+    sqlite3VdbeAddOp1(v, OP_SeekEnd, iIdx);
+  }
   sqlite3VdbeAddOp2(v, OP_IdxInsert, iIdx, regRecord);
   sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);
   sqlite3ReleaseTempReg(pParse, regRecord);
   sqlite3VdbeAddOp2(v, OP_SorterNext, iSorter, addr2); VdbeCoverage(v);
   sqlite3VdbeJumpHere(v, addr1);
@@ -109886,10 +110807,31 @@
     *ppExtra = ((char*)p) + nByte;
   }
   return p;
 }
 
+/*
+** If expression list pList contains an expression that was parsed with
+** an explicit "NULLS FIRST" or "NULLS LAST" clause, leave an error in
+** pParse and return non-zero. Otherwise, return zero.
+*/
+SQLITE_PRIVATE int sqlite3HasExplicitNulls(Parse *pParse, ExprList *pList){
+  if( pList ){
+    int i;
+    for(i=0; i<pList->nExpr; i++){
+      if( pList->a[i].bNulls ){
+        u8 sf = pList->a[i].sortFlags;
+        sqlite3ErrorMsg(pParse, "unsupported use of NULLS %s",
+            (sf==0 || sf==3) ? "FIRST" : "LAST"
+        );
+        return 1;
+      }
+    }
+  }
+  return 0;
+}
+
 /*
 ** Create a new index for an SQL table.  pName1.pName2 is the name of the index
 ** and pTblList is the name of the table that is to be indexed.  Both will
 ** be NULL for a primary key or an index that is created to satisfy a
 ** UNIQUE constraint.  If pTable and pIndex are NULL, use pParse->pNewTable
@@ -109937,10 +110879,13 @@
     goto exit_create_index;
   }
   if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){
     goto exit_create_index;
   }
+  if( sqlite3HasExplicitNulls(pParse, pList) ){
+    goto exit_create_index;
+  }
 
   /*
   ** Find the table that is to be indexed.  Return early if not found.
   */
   if( pTblName!=0 ){
@@ -110035,11 +110980,11 @@
   */
   if( pName ){
     zName = sqlite3NameFromToken(db, pName);
     if( zName==0 ) goto exit_create_index;
     assert( pName->z!=0 );
-    if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){
+    if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName,"index",pTab->zName) ){
       goto exit_create_index;
     }
     if( !IN_RENAME_OBJECT ){
       if( !db->init.busy ){
         if( sqlite3FindTable(db, zName, 0)!=0 ){
@@ -110101,11 +111046,11 @@
     sqlite3TokenInit(&prevCol, pCol->zName);
     pList = sqlite3ExprListAppend(pParse, 0,
               sqlite3ExprAlloc(db, TK_ID, &prevCol, 0));
     if( pList==0 ) goto exit_create_index;
     assert( pList->nExpr==1 );
-    sqlite3ExprListSetSortOrder(pList, sortOrder);
+    sqlite3ExprListSetSortOrder(pList, sortOrder, SQLITE_SO_UNDEFINED);
   }else{
     sqlite3ExprListCheckLength(pParse, pList, "index");
     if( pParse->nErr ) goto exit_create_index;
   }
 
@@ -110219,11 +111164,11 @@
     if( !zColl ) zColl = sqlite3StrBINARY;
     if( !db->init.busy && !sqlite3LocateCollSeq(pParse, zColl) ){
       goto exit_create_index;
     }
     pIndex->azColl[i] = zColl;
-    requestedSortOrder = pListItem->sortOrder & sortOrderMask;
+    requestedSortOrder = pListItem->sortFlags & sortOrderMask;
     pIndex->aSortOrder[i] = (u8)requestedSortOrder;
   }
 
   /* Append the table key to the end of the index.  For WITHOUT ROWID
   ** tables (when pPk!=0) this will be the declared PRIMARY KEY.  For
@@ -110231,13 +111176,14 @@
   */
   if( pPk ){
     for(j=0; j<pPk->nKeyCol; j++){
       int x = pPk->aiColumn[j];
       assert( x>=0 );
-      if( hasColumn(pIndex->aiColumn, pIndex->nKeyCol, x) ){
+      if( isDupColumn(pIndex, pIndex->nKeyCol, pPk, j) ){
         pIndex->nColumn--;
       }else{
+        testcase( hasColumn(pIndex->aiColumn,pIndex->nKeyCol,x) );
         pIndex->aiColumn[i] = x;
         pIndex->azColl[i] = pPk->azColl[j];
         pIndex->aSortOrder[i] = pPk->aSortOrder[j];
         i++;
       }
@@ -110393,10 +111339,11 @@
       sqlite3VdbeAddOp3(v, OP_CreateBtree, iDb, iMem, BTREE_BLOBKEY);
 
       /* Gather the complete text of the CREATE INDEX statement into
       ** the zStmt variable
       */
+      assert( pName!=0 || pStart==0 );
       if( pStart ){
         int n = (int)(pParse->sLastToken.z - pName->z) + pParse->sLastToken.n;
         if( pName->z[n-1]==';' ) n--;
         /* A named index with an explicit CREATE INDEX statement */
         zStmt = sqlite3MPrintf(db, "CREATE%s INDEX %.*s",
@@ -111435,11 +112382,12 @@
     assert( sqlite3KeyInfoIsWriteable(pKey) );
     for(i=0; i<nCol; i++){
       const char *zColl = pIdx->azColl[i];
       pKey->aColl[i] = zColl==sqlite3StrBINARY ? 0 :
                         sqlite3LocateCollSeq(pParse, zColl);
-      pKey->aSortOrder[i] = pIdx->aSortOrder[i];
+      pKey->aSortFlags[i] = pIdx->aSortOrder[i];
+      assert( 0==(pKey->aSortFlags[i] & KEYINFO_ORDER_BIGNULL) );
     }
     if( pParse->nErr ){
       assert( pParse->rc==SQLITE_ERROR_MISSING_COLLSEQ );
       if( pIdx->bNoQuery==0 ){
         /* Deactivate the index because it contains an unknown collating
@@ -113004,10 +113952,11 @@
 ** time functions, are implemented separately.)
 */
 /* #include "sqliteInt.h" */
 /* #include <stdlib.h> */
 /* #include <assert.h> */
+/* #include <math.h> */
 /* #include "vdbeInt.h" */
 
 /*
 ** Return the collating function associated with a function.
 */
@@ -113190,10 +114139,12 @@
   int nNeedle;
   int typeHaystack, typeNeedle;
   int N = 1;
   int isText;
   unsigned char firstChar;
+  sqlite3_value *pC1 = 0;
+  sqlite3_value *pC2 = 0;
 
   UNUSED_PARAMETER(argc);
   typeHaystack = sqlite3_value_type(argv[0]);
   typeNeedle = sqlite3_value_type(argv[1]);
   if( typeHaystack==SQLITE_NULL || typeNeedle==SQLITE_NULL ) return;
@@ -113202,16 +114153,26 @@
   if( nNeedle>0 ){
     if( typeHaystack==SQLITE_BLOB && typeNeedle==SQLITE_BLOB ){
       zHaystack = sqlite3_value_blob(argv[0]);
       zNeedle = sqlite3_value_blob(argv[1]);
       isText = 0;
-    }else{
+    }else if( typeHaystack!=SQLITE_BLOB && typeNeedle!=SQLITE_BLOB ){
       zHaystack = sqlite3_value_text(argv[0]);
       zNeedle = sqlite3_value_text(argv[1]);
       isText = 1;
+    }else{
+      pC1 = sqlite3_value_dup(argv[0]);
+      zHaystack = sqlite3_value_text(pC1);
+      if( zHaystack==0 ) goto endInstrOOM;
+      nHaystack = sqlite3_value_bytes(pC1);
+      pC2 = sqlite3_value_dup(argv[1]);
+      zNeedle = sqlite3_value_text(pC2);
+      if( zNeedle==0 ) goto endInstrOOM;
+      nNeedle = sqlite3_value_bytes(pC2);
+      isText = 1;
     }
-    if( zNeedle==0 || (nHaystack && zHaystack==0) ) return;
+    if( zNeedle==0 || (nHaystack && zHaystack==0) ) goto endInstrOOM;
     firstChar = zNeedle[0];
     while( nNeedle<=nHaystack
        && (zHaystack[0]!=firstChar || memcmp(zHaystack, zNeedle, nNeedle)!=0)
     ){
       N++;
@@ -113221,10 +114182,17 @@
       }while( isText && (zHaystack[0]&0xc0)==0x80 );
     }
     if( nNeedle>nHaystack ) N = 0;
   }
   sqlite3_result_int(context, N);
+endInstr:
+  sqlite3_value_free(pC1);
+  sqlite3_value_free(pC2);
+  return;
+endInstrOOM:
+  sqlite3_result_error_nomem(context);
+  goto endInstr;
 }
 
 /*
 ** Implementation of the printf() function.
 */
@@ -113374,14 +114342,14 @@
   r = sqlite3_value_double(argv[0]);
   /* If Y==0 and X will fit in a 64-bit int,
   ** handle the rounding directly,
   ** otherwise use printf.
   */
-  if( n==0 && r>=0 && r<LARGEST_INT64-1 ){
-    r = (double)((sqlite_int64)(r+0.5));
-  }else if( n==0 && r<0 && (-r)<LARGEST_INT64-1 ){
-    r = -(double)((sqlite_int64)((-r)+0.5));
+  if( r<-4503599627370496.0 || r>+4503599627370496.0 ){
+    /* The value has no fractional part so there is nothing to round */
+  }else if( n==0 ){
+    r = (double)((sqlite_int64)(r+(r<0?-0.5:+0.5)));
   }else{
     zBuf = sqlite3_mprintf("%.*f",n,r);
     if( zBuf==0 ){
       sqlite3_result_error_nomem(context);
       return;
@@ -113831,12 +114799,10 @@
 #endif
     sqlite3_result_int(context, 0);
     return;
   }
 #endif
-  zB = sqlite3_value_text(argv[0]);
-  zA = sqlite3_value_text(argv[1]);
 
   /* Limit the length of the LIKE or GLOB pattern to avoid problems
   ** of deep recursion and N*N behavior in patternCompare().
   */
   nPat = sqlite3_value_bytes(argv[0]);
@@ -113844,12 +114810,10 @@
   testcase( nPat==db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]+1 );
   if( nPat > db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] ){
     sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1);
     return;
   }
-  assert( zB==sqlite3_value_text(argv[0]) );  /* Encoding did not change */
-
   if( argc==3 ){
     /* The escape character string must consist of a single UTF-8 character.
     ** Otherwise, return an error.
     */
     const unsigned char *zEsc = sqlite3_value_text(argv[2]);
@@ -113861,10 +114825,12 @@
     }
     escape = sqlite3Utf8Read(&zEsc);
   }else{
     escape = pInfo->matchSet;
   }
+  zB = sqlite3_value_text(argv[0]);
+  zA = sqlite3_value_text(argv[1]);
   if( zA && zB ){
 #ifdef SQLITE_TEST
     sqlite3_like_count++;
 #endif
     sqlite3_result_int(context,
@@ -114786,43 +115752,28 @@
     sqlite3OomFault(db);
   }
 }
 
 /*
-** Set the LIKEOPT flag on the 2-argument function with the given name.
-*/
-static void setLikeOptFlag(sqlite3 *db, const char *zName, u8 flagVal){
-  FuncDef *pDef;
-  pDef = sqlite3FindFunction(db, zName, 2, SQLITE_UTF8, 0);
-  if( ALWAYS(pDef) ){
-    pDef->funcFlags |= flagVal;
-  }
-  pDef = sqlite3FindFunction(db, zName, 3, SQLITE_UTF8, 0);
-  if( pDef ){
-    pDef->funcFlags |= flagVal;
-  }
-}
-
-/*
-** Register the built-in LIKE and GLOB functions.  The caseSensitive
+** Re-register the built-in LIKE functions.  The caseSensitive
 ** parameter determines whether or not the LIKE operator is case
-** sensitive.  GLOB is always case sensitive.
+** sensitive.
 */
 SQLITE_PRIVATE void sqlite3RegisterLikeFunctions(sqlite3 *db, int caseSensitive){
   struct compareInfo *pInfo;
+  int flags;
   if( caseSensitive ){
     pInfo = (struct compareInfo*)&likeInfoAlt;
+    flags = SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE;
   }else{
     pInfo = (struct compareInfo*)&likeInfoNorm;
+    flags = SQLITE_FUNC_LIKE;
   }
   sqlite3CreateFunc(db, "like", 2, SQLITE_UTF8, pInfo, likeFunc, 0, 0, 0, 0, 0);
   sqlite3CreateFunc(db, "like", 3, SQLITE_UTF8, pInfo, likeFunc, 0, 0, 0, 0, 0);
-  sqlite3CreateFunc(db, "glob", 2, SQLITE_UTF8,
-      (struct compareInfo*)&globInfo, likeFunc, 0, 0, 0, 0, 0);
-  setLikeOptFlag(db, "glob", SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE);
-  setLikeOptFlag(db, "like",
-      caseSensitive ? (SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE) : SQLITE_FUNC_LIKE);
+  sqlite3FindFunction(db, "like", 2, SQLITE_UTF8, 0)->funcFlags |= flags;
+  sqlite3FindFunction(db, "like", 3, SQLITE_UTF8, 0)->funcFlags |= flags;
 }
 
 /*
 ** pExpr points to an expression which implements a function.  If
 ** it is appropriate to apply the LIKE optimization to that function
@@ -114990,13 +115941,10 @@
   };
 #ifndef SQLITE_OMIT_ALTERTABLE
   sqlite3AlterFunctions();
 #endif
   sqlite3WindowFunctions();
-#if defined(SQLITE_ENABLE_STAT3) || defined(SQLITE_ENABLE_STAT4)
-  sqlite3AnalyzeFunctions();
-#endif
   sqlite3RegisterDateTimeFunctions();
   sqlite3InsertBuiltinFuncs(aBuiltinFunc, ArraySize(aBuiltinFunc));
 
 #if 0  /* Enable to print out how the built-in functions are hashed */
   {
@@ -115495,17 +116443,17 @@
   pExpr = sqlite3Expr(db, TK_REGISTER, 0);
   if( pExpr ){
     if( iCol>=0 && iCol!=pTab->iPKey ){
       pCol = &pTab->aCol[iCol];
       pExpr->iTable = regBase + iCol + 1;
-      pExpr->affinity = pCol->affinity;
+      pExpr->affExpr = pCol->affinity;
       zColl = pCol->zColl;
       if( zColl==0 ) zColl = db->pDfltColl->zName;
       pExpr = sqlite3ExprAddCollateString(pParse, pExpr, zColl);
     }else{
       pExpr->iTable = regBase;
-      pExpr->affinity = SQLITE_AFF_INTEGER;
+      pExpr->affExpr = SQLITE_AFF_INTEGER;
     }
   }
   return pExpr;
 }
 
@@ -115608,11 +116556,11 @@
     iCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
     assert( iCol>=0 );
     zCol = pFKey->pFrom->aCol[iCol].zName;
     pRight = sqlite3Expr(db, TK_ID, zCol);
     pEq = sqlite3PExpr(pParse, TK_EQ, pLeft, pRight);
-    pWhere = sqlite3ExprAnd(db, pWhere, pEq);
+    pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);
   }
 
   /* If the child table is the same as the parent table, then add terms
   ** to the WHERE clause that prevent this entry from being scanned.
   ** The added WHERE clause terms are like this:
@@ -115642,15 +116590,15 @@
         i16 iCol = pIdx->aiColumn[i];
         assert( iCol>=0 );
         pLeft = exprTableRegister(pParse, pTab, regData, iCol);
         pRight = sqlite3Expr(db, TK_ID, pTab->aCol[iCol].zName);
         pEq = sqlite3PExpr(pParse, TK_IS, pLeft, pRight);
-        pAll = sqlite3ExprAnd(db, pAll, pEq);
+        pAll = sqlite3ExprAnd(pParse, pAll, pEq);
       }
       pNe = sqlite3PExpr(pParse, TK_NOT, pAll, 0);
     }
-    pWhere = sqlite3ExprAnd(db, pWhere, pNe);
+    pWhere = sqlite3ExprAnd(pParse, pWhere, pNe);
   }
 
   /* Resolve the references in the WHERE clause. */
   memset(&sNameContext, 0, sizeof(NameContext));
   sNameContext.pSrcList = pSrc;
@@ -116252,11 +117200,11 @@
           sqlite3PExpr(pParse, TK_DOT,
             sqlite3ExprAlloc(db, TK_ID, &tOld, 0),
             sqlite3ExprAlloc(db, TK_ID, &tToCol, 0)),
           sqlite3ExprAlloc(db, TK_ID, &tFromCol, 0)
       );
-      pWhere = sqlite3ExprAnd(db, pWhere, pEq);
+      pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);
 
       /* For ON UPDATE, construct the next term of the WHEN clause.
       ** The final WHEN clause will be like this:
       **
       **    WHEN NOT(old.col1 IS new.col1 AND ... AND old.colN IS new.colN)
@@ -116268,11 +117216,11 @@
               sqlite3ExprAlloc(db, TK_ID, &tToCol, 0)),
             sqlite3PExpr(pParse, TK_DOT,
               sqlite3ExprAlloc(db, TK_ID, &tNew, 0),
               sqlite3ExprAlloc(db, TK_ID, &tToCol, 0))
             );
-        pWhen = sqlite3ExprAnd(db, pWhen, pEq);
+        pWhen = sqlite3ExprAnd(pParse, pWhen, pEq);
       }
 
       if( action!=OE_Restrict && (action!=OE_Cascade || pChanges) ){
         Expr *pNew;
         if( action==OE_Cascade ){
@@ -116304,11 +117252,11 @@
 
       tFrom.z = zFrom;
       tFrom.n = nFrom;
       pRaise = sqlite3Expr(db, TK_RAISE, "FOREIGN KEY constraint failed");
       if( pRaise ){
-        pRaise->affinity = OE_Abort;
+        pRaise->affExpr = OE_Abort;
       }
       pSelect = sqlite3SelectNew(pParse,
           sqlite3ExprListAppend(pParse, 0, pRaise),
           sqlite3SrcListAppend(pParse, 0, &tFrom, 0),
           pWhere,
@@ -116349,10 +117297,11 @@
     if( db->mallocFailed==1 ){
       fkTriggerDelete(db, pTrigger);
       return 0;
     }
     assert( pStep!=0 );
+    assert( pTrigger!=0 );
 
     switch( action ){
       case OE_Restrict:
         pStep->op = TK_SELECT;
         break;
@@ -116539,22 +117488,23 @@
       sqlite3OomFault(db);
       return 0;
     }
     for(n=0; n<pIdx->nColumn; n++){
       i16 x = pIdx->aiColumn[n];
+      char aff;
       if( x>=0 ){
-        pIdx->zColAff[n] = pTab->aCol[x].affinity;
+        aff = pTab->aCol[x].affinity;
       }else if( x==XN_ROWID ){
-        pIdx->zColAff[n] = SQLITE_AFF_INTEGER;
+        aff = SQLITE_AFF_INTEGER;
       }else{
-        char aff;
         assert( x==XN_EXPR );
         assert( pIdx->aColExpr!=0 );
         aff = sqlite3ExprAffinity(pIdx->aColExpr->a[n].pExpr);
-        if( aff==0 ) aff = SQLITE_AFF_BLOB;
-        pIdx->zColAff[n] = aff;
       }
+      if( aff<SQLITE_AFF_BLOB ) aff = SQLITE_AFF_BLOB;
+      if( aff>SQLITE_AFF_NUMERIC) aff = SQLITE_AFF_NUMERIC;
+      pIdx->zColAff[n] = aff;
     }
     pIdx->zColAff[n] = 0;
   }
 
   return pIdx->zColAff;
@@ -116590,15 +117540,16 @@
       sqlite3OomFault(db);
       return;
     }
 
     for(i=0; i<pTab->nCol; i++){
+      assert( pTab->aCol[i].affinity!=0 );
       zColAff[i] = pTab->aCol[i].affinity;
     }
     do{
       zColAff[i--] = 0;
-    }while( i>=0 && zColAff[i]==SQLITE_AFF_BLOB );
+    }while( i>=0 && zColAff[i]<=SQLITE_AFF_BLOB );
     pTab->zColAff = zColAff;
   }
   assert( zColAff!=0 );
   i = sqlite3Strlen30NN(zColAff);
   if( i ){
@@ -117265,27 +118216,31 @@
   /* If this is not a view, open the table and and all indices */
   if( !isView ){
     int nIdx;
     nIdx = sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, 0, -1, 0,
                                       &iDataCur, &iIdxCur);
-    aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int)*(nIdx+1));
+    aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int)*(nIdx+2));
     if( aRegIdx==0 ){
       goto insert_cleanup;
     }
     for(i=0, pIdx=pTab->pIndex; i<nIdx; pIdx=pIdx->pNext, i++){
       assert( pIdx );
       aRegIdx[i] = ++pParse->nMem;
       pParse->nMem += pIdx->nColumn;
     }
+    aRegIdx[i] = ++pParse->nMem;  /* Register to store the table record */
   }
 #ifndef SQLITE_OMIT_UPSERT
   if( pUpsert ){
     if( IsVirtual(pTab) ){
       sqlite3ErrorMsg(pParse, "UPSERT not implemented for virtual table \"%s\"",
               pTab->zName);
       goto insert_cleanup;
     }
+    if( sqlite3HasExplicitNulls(pParse, pUpsert->pUpsertTarget) ){
+      goto insert_cleanup;
+    }
     pTabList->a[0].iCursor = iDataCur;
     pUpsert->pUpsertSrc = pTabList;
     pUpsert->regData = regData;
     pUpsert->iDataCur = iDataCur;
     pUpsert->iIdxCur = iIdxCur;
@@ -117677,10 +118632,18 @@
 ** registers identified by aRegIdx[].  No index entry is created for
 ** indices where aRegIdx[i]==0.  The order of indices in aRegIdx[] is
 ** the same as the order of indices on the linked list of indices
 ** at pTab->pIndex.
 **
+** (2019-05-07) The generated code also creates a new record for the
+** main table, if pTab is a rowid table, and stores that record in the
+** register identified by aRegIdx[nIdx] - in other words in the first
+** entry of aRegIdx[] past the last index.  It is important that the
+** record be generated during constraint checks to avoid affinity changes
+** to the register content that occur after constraint checks but before
+** the new record is inserted.
+**
 ** The caller must have already opened writeable cursors on the main
 ** table and all applicable indices (that is to say, all indices for which
 ** aRegIdx[] is not zero).  iDataCur is the cursor for the main table when
 ** inserting or updating a rowid table, or the cursor for the PRIMARY KEY
 ** index when operating on a WITHOUT ROWID table.  iIdxCur is the cursor
@@ -117867,11 +118830,11 @@
       if( onError==OE_Ignore ){
         sqlite3VdbeGoto(v, ignoreDest);
       }else{
         char *zName = pCheck->a[i].zName;
         if( zName==0 ) zName = pTab->zName;
-        if( onError==OE_Replace ) onError = OE_Abort; /* IMP: R-15569-63625 */
+        if( onError==OE_Replace ) onError = OE_Abort; /* IMP: R-26383-51744 */
         sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_CHECK,
                               onError, zName, P4_TRANSIENT,
                               P5_ConstraintCheck);
       }
       sqlite3VdbeResolveLabel(v, allOk);
@@ -118296,10 +119259,20 @@
     sqlite3VdbeGoto(v, ipkTop);
     VdbeComment((v, "Do IPK REPLACE"));
     sqlite3VdbeJumpHere(v, ipkBottom);
   }
 
+  /* Generate the table record */
+  if( HasRowid(pTab) ){
+    int regRec = aRegIdx[ix];
+    sqlite3VdbeAddOp3(v, OP_MakeRecord, regNewData+1, pTab->nCol, regRec);
+    sqlite3SetMakeRecordP5(v, pTab);
+    if( !bAffinityDone ){
+      sqlite3TableAffinity(v, pTab, 0);
+    }
+  }
+
   *pbMayReplace = seenReplace;
   VdbeModuleComment((v, "END: GenCnstCks(%d)", seenReplace));
 }
 
 #ifdef SQLITE_ENABLE_NULL_TRIM
@@ -118345,14 +119318,11 @@
   int useSeekResult   /* True to set the USESEEKRESULT flag on OP_[Idx]Insert */
 ){
   Vdbe *v;            /* Prepared statements under construction */
   Index *pIdx;        /* An index being inserted or updated */
   u8 pik_flags;       /* flag values passed to the btree insert */
-  int regData;        /* Content registers (after the rowid) */
-  int regRec;         /* Register holding assembled record for the table */
   int i;              /* Loop counter */
-  u8 bAffinityDone = 0; /* True if OP_Affinity has been run already */
 
   assert( update_flags==0
        || update_flags==OPFLAG_ISUPDATE
        || update_flags==(OPFLAG_ISUPDATE|OPFLAG_SAVEPOSITION)
   );
@@ -118360,11 +119330,10 @@
   v = sqlite3GetVdbe(pParse);
   assert( v!=0 );
   assert( pTab->pSelect==0 );  /* This table is not a VIEW */
   for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){
     if( aRegIdx[i]==0 ) continue;
-    bAffinityDone = 1;
     if( pIdx->pPartIdxWhere ){
       sqlite3VdbeAddOp2(v, OP_IsNull, aRegIdx[i], sqlite3VdbeCurrentAddr(v)+2);
       VdbeCoverage(v);
     }
     pik_flags = (useSeekResult ? OPFLAG_USESEEKRESULT : 0);
@@ -118388,17 +119357,10 @@
                          aRegIdx[i]+1,
                          pIdx->uniqNotNull ? pIdx->nKeyCol: pIdx->nColumn);
     sqlite3VdbeChangeP5(v, pik_flags);
   }
   if( !HasRowid(pTab) ) return;
-  regData = regNewData + 1;
-  regRec = sqlite3GetTempReg(pParse);
-  sqlite3VdbeAddOp3(v, OP_MakeRecord, regData, pTab->nCol, regRec);
-  sqlite3SetMakeRecordP5(v, pTab);
-  if( !bAffinityDone ){
-    sqlite3TableAffinity(v, pTab, 0);
-  }
   if( pParse->nested ){
     pik_flags = 0;
   }else{
     pik_flags = OPFLAG_NCHANGE;
     pik_flags |= (update_flags?update_flags:OPFLAG_LASTROWID);
@@ -118407,11 +119369,11 @@
     pik_flags |= OPFLAG_APPEND;
   }
   if( useSeekResult ){
     pik_flags |= OPFLAG_USESEEKRESULT;
   }
-  sqlite3VdbeAddOp3(v, OP_Insert, iDataCur, regRec, regNewData);
+  sqlite3VdbeAddOp3(v, OP_Insert, iDataCur, aRegIdx[i], regNewData);
   if( !pParse->nested ){
     sqlite3VdbeAppendP4(v, pTab, P4_TABLE);
   }
   sqlite3VdbeChangeP5(v, pik_flags);
 }
@@ -119388,10 +120350,12 @@
   /* Version 3.26.0 and later */
   const char *(*normalized_sql)(sqlite3_stmt*);
   /* Version 3.28.0 and later */
   int (*stmt_isexplain)(sqlite3_stmt*);
   int (*value_frombind)(sqlite3_value*);
+  /* Version 3.30.0 and later */
+  int (*drop_modules)(sqlite3*,const char**);
 };
 
 /*
 ** This is the function signature used for all extension entry points.  It
 ** is also defined in the file "loadext.c".
@@ -119680,10 +120644,12 @@
 /* Version 3.26.0 and later */
 #define sqlite3_normalized_sql         sqlite3_api->normalized_sql
 /* Version 3.28.0 and later */
 #define sqlite3_stmt_isexplain         sqlite3_api->isexplain
 #define sqlite3_value_frombind         sqlite3_api->frombind
+/* Version 3.30.0 and later */
+#define sqlite3_drop_modules           sqlite3_api->drop_modules
 #endif /* !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION) */
 
 #if !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION)
   /* This case when the file really is being compiled as a loadable
   ** extension */
@@ -120145,11 +121111,17 @@
 #else
   0,
 #endif
   /* Version 3.28.0 and later */
   sqlite3_stmt_isexplain,
-  sqlite3_value_frombind
+  sqlite3_value_frombind,
+  /* Version 3.30.0 and later */
+#ifndef SQLITE_OMIT_VIRTUALTABLE
+  sqlite3_drop_modules,
+#else
+  0,
+#endif
 };
 
 /*
 ** Attempt to load an SQLite extension library contained in the file
 ** zFile.  The entry point is zProc.  zProc may be 0 in which case a
@@ -120593,14 +121565,13 @@
 #define PragTyp_TEMP_STORE_DIRECTORY          36
 #define PragTyp_THREADS                       37
 #define PragTyp_WAL_AUTOCHECKPOINT            38
 #define PragTyp_WAL_CHECKPOINT                39
 #define PragTyp_ACTIVATE_EXTENSIONS           40
-#define PragTyp_HEXKEY                        41
-#define PragTyp_KEY                           42
-#define PragTyp_LOCK_STATUS                   43
-#define PragTyp_STATS                         44
+#define PragTyp_KEY                           41
+#define PragTyp_LOCK_STATUS                   42
+#define PragTyp_STATS                         43
 
 /* Property flags associated with various pragma. */
 #define PragFlg_NeedSchema 0x01 /* Force schema load before running */
 #define PragFlg_NoColumns  0x02 /* OP_ResultRow called with zero columns */
 #define PragFlg_NoColumns1 0x04 /* zero columns if RHS argument is present */
@@ -120725,15 +121696,17 @@
   /* ePragTyp:  */ PragTyp_CACHE_SPILL,
   /* ePragFlg:  */ PragFlg_Result0|PragFlg_SchemaReq|PragFlg_NoColumns1,
   /* ColNames:  */ 0, 0,
   /* iArg:      */ 0 },
 #endif
+#if !defined(SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA)
  {/* zName:     */ "case_sensitive_like",
   /* ePragTyp:  */ PragTyp_CASE_SENSITIVE_LIKE,
   /* ePragFlg:  */ PragFlg_NoColumns,
   /* ColNames:  */ 0, 0,
   /* iArg:      */ 0 },
+#endif
  {/* zName:     */ "cell_size_check",
   /* ePragTyp:  */ PragTyp_FLAG,
   /* ePragFlg:  */ PragFlg_Result0|PragFlg_NoColumns1,
   /* ColNames:  */ 0, 0,
   /* iArg:      */ SQLITE_CellSizeCk },
@@ -120857,26 +121830,26 @@
   /* ePragFlg:  */ PragFlg_Result0|PragFlg_NoColumns1,
   /* ColNames:  */ 0, 0,
   /* iArg:      */ SQLITE_FullFSync },
 #endif
 #if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS)
-#if defined(SQLITE_INTROSPECTION_PRAGMAS)
+#if !defined(SQLITE_OMIT_INTROSPECTION_PRAGMAS)
  {/* zName:     */ "function_list",
   /* ePragTyp:  */ PragTyp_FUNCTION_LIST,
   /* ePragFlg:  */ PragFlg_Result0,
   /* ColNames:  */ 41, 2,
   /* iArg:      */ 0 },
 #endif
 #endif
 #if defined(SQLITE_HAS_CODEC)
  {/* zName:     */ "hexkey",
-  /* ePragTyp:  */ PragTyp_HEXKEY,
+  /* ePragTyp:  */ PragTyp_KEY,
   /* ePragFlg:  */ 0,
   /* ColNames:  */ 0, 0,
   /* iArg:      */ 2 },
  {/* zName:     */ "hexrekey",
-  /* ePragTyp:  */ PragTyp_HEXKEY,
+  /* ePragTyp:  */ PragTyp_KEY,
   /* ePragFlg:  */ 0,
   /* ColNames:  */ 0, 0,
   /* iArg:      */ 3 },
 #endif
 #if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
@@ -120981,11 +121954,11 @@
   /* ColNames:  */ 0, 0,
   /* iArg:      */ 0 },
 #endif
 #if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS)
 #if !defined(SQLITE_OMIT_VIRTUALTABLE)
-#if defined(SQLITE_INTROSPECTION_PRAGMAS)
+#if !defined(SQLITE_OMIT_INTROSPECTION_PRAGMAS)
  {/* zName:     */ "module_list",
   /* ePragTyp:  */ PragTyp_MODULE_LIST,
   /* ePragFlg:  */ PragFlg_Result0,
   /* ColNames:  */ 9, 1,
   /* iArg:      */ 0 },
@@ -121016,11 +121989,11 @@
   /* ePragFlg:  */ PragFlg_Result0|PragFlg_NoColumns1,
   /* ColNames:  */ 0, 0,
   /* iArg:      */ SQLITE_ParserTrace },
 #endif
 #endif
-#if defined(SQLITE_INTROSPECTION_PRAGMAS)
+#if !defined(SQLITE_OMIT_INTROSPECTION_PRAGMAS)
  {/* zName:     */ "pragma_list",
   /* ePragTyp:  */ PragTyp_PRAGMA_LIST,
   /* ePragFlg:  */ PragFlg_Result0,
   /* ColNames:  */ 9, 1,
   /* iArg:      */ 0 },
@@ -121214,11 +122187,11 @@
   /* ePragFlg:  */ PragFlg_Result0|PragFlg_NoColumns1,
   /* ColNames:  */ 0, 0,
   /* iArg:      */ SQLITE_WriteSchema|SQLITE_NoSchemaError },
 #endif
 };
-/* Number of pragmas: 62 on by default, 81 total. */
+/* Number of pragmas: 65 on by default, 81 total. */
 
 /************** End of pragma.h **********************************************/
 /************** Continuing where we left off in pragma.c *********************/
 
 /*
@@ -121833,10 +122806,15 @@
       if( !zMode ){
         /* If the "=MODE" part does not match any known journal mode,
         ** then do a query */
         eMode = PAGER_JOURNALMODE_QUERY;
       }
+      if( eMode==PAGER_JOURNALMODE_OFF && (db->flags & SQLITE_Defensive)!=0 ){
+        /* Do not allow journal-mode "OFF" in defensive since the database
+        ** can become corrupted using ordinary SQL when the journal is off */
+        eMode = PAGER_JOURNALMODE_QUERY;
+      }
     }
     if( eMode==PAGER_JOURNALMODE_QUERY && pId2->n==0 ){
       /* Convert "PRAGMA journal_mode" into "PRAGMA main.journal_mode" */
       iDb = 0;
       pId2->n = 1;
@@ -122341,10 +123319,19 @@
 
   case PragTyp_INDEX_INFO: if( zRight ){
     Index *pIdx;
     Table *pTab;
     pIdx = sqlite3FindIndex(db, zRight, zDb);
+    if( pIdx==0 ){
+      /* If there is no index named zRight, check to see if there is a
+      ** WITHOUT ROWID table named zRight, and if there is, show the
+      ** structure of the PRIMARY KEY index for that table. */
+      pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);
+      if( pTab && !HasRowid(pTab) ){
+        pIdx = sqlite3PrimaryKeyIndex(pTab);
+      }
+    }
     if( pIdx ){
       int iIdxDb = sqlite3SchemaToIndex(db, pIdx->pSchema);
       int i;
       int mx;
       if( pPragma->iArg ){
@@ -122420,11 +123407,11 @@
       sqlite3VdbeMultiLoad(v, 1, "is", i++, pColl->zName);
     }
   }
   break;
 
-#ifdef SQLITE_INTROSPECTION_PRAGMAS
+#ifndef SQLITE_OMIT_INTROSPECTION_PRAGMAS
   case PragTyp_FUNCTION_LIST: {
     int i;
     HashElem *j;
     FuncDef *p;
     pParse->nMem = 2;
@@ -122610,19 +123597,21 @@
   }
   break;
 #endif /* !defined(SQLITE_OMIT_TRIGGER) */
 #endif /* !defined(SQLITE_OMIT_FOREIGN_KEY) */
 
+#ifndef SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA
   /* Reinstall the LIKE and GLOB functions.  The variant of LIKE
   ** used will be case sensitive or not depending on the RHS.
   */
   case PragTyp_CASE_SENSITIVE_LIKE: {
     if( zRight ){
       sqlite3RegisterLikeFunctions(db, sqlite3GetBoolean(zRight, 0));
     }
   }
   break;
+#endif /* SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA */
 
 #ifndef SQLITE_INTEGRITY_CHECK_ERROR_MAX
 # define SQLITE_INTEGRITY_CHECK_ERROR_MAX 100
 #endif
 
@@ -123312,32 +124301,34 @@
   **  textkey       4
   **  textrekey     5
   */
   case PragTyp_KEY: {
     if( zRight ){
-      int n = pPragma->iArg<4 ? sqlite3Strlen30(zRight) : -1;
-      if( (pPragma->iArg & 1)==0 ){
-        sqlite3_key_v2(db, zDb, zRight, n);
+      char zBuf[40];
+      const char *zKey = zRight;
+      int n;
+      if( pPragma->iArg==2 || pPragma->iArg==3 ){
+        u8 iByte;
+        int i;
+        for(i=0, iByte=0; i<sizeof(zBuf)*2 && sqlite3Isxdigit(zRight[i]); i++){
+          iByte = (iByte<<4) + sqlite3HexToInt(zRight[i]);
+          if( (i&1)!=0 ) zBuf[i/2] = iByte;
+        }
+        zKey = zBuf;
+        n = i/2;
       }else{
-        sqlite3_rekey_v2(db, zDb, zRight, n);
-      }
-    }
-    break;
-  }
-  case PragTyp_HEXKEY: {
-    if( zRight ){
-      u8 iByte;
-      int i;
-      char zKey[40];
-      for(i=0, iByte=0; i<sizeof(zKey)*2 && sqlite3Isxdigit(zRight[i]); i++){
-        iByte = (iByte<<4) + sqlite3HexToInt(zRight[i]);
-        if( (i&1)!=0 ) zKey[i/2] = iByte;
+        n = pPragma->iArg<4 ? sqlite3Strlen30(zRight) : -1;
       }
       if( (pPragma->iArg & 1)==0 ){
-        sqlite3_key_v2(db, zDb, zKey, i/2);
+        rc = sqlite3_key_v2(db, zDb, zKey, n);
       }else{
-        sqlite3_rekey_v2(db, zDb, zKey, i/2);
+        rc = sqlite3_rekey_v2(db, zDb, zKey, n);
+      }
+      if( rc==SQLITE_OK && n!=0 ){
+        sqlite3VdbeSetNumCols(v, 1);
+        sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "ok", SQLITE_STATIC);
+        returnSingleText(v, "ok");
       }
     }
     break;
   }
 #endif
@@ -123751,35 +124742,37 @@
 ** database.  See sqlite3Init() below for additional information.
 ** This routine is also called from the OP_ParseSchema opcode of the VDBE.
 **
 ** Each callback contains the following information:
 **
-**     argv[0] = name of thing being created
-**     argv[1] = root page number for table or index. 0 for trigger or view.
-**     argv[2] = SQL text for the CREATE statement.
+**     argv[0] = type of object: "table", "index", "trigger", or "view".
+**     argv[1] = name of thing being created
+**     argv[2] = associated table if an index or trigger
+**     argv[3] = root page number for table or index. 0 for trigger or view.
+**     argv[4] = SQL text for the CREATE statement.
 **
 */
 SQLITE_PRIVATE int sqlite3InitCallback(void *pInit, int argc, char **argv, char **NotUsed){
   InitData *pData = (InitData*)pInit;
   sqlite3 *db = pData->db;
   int iDb = pData->iDb;
 
-  assert( argc==3 );
+  assert( argc==5 );
   UNUSED_PARAMETER2(NotUsed, argc);
   assert( sqlite3_mutex_held(db->mutex) );
   DbClearProperty(db, iDb, DB_Empty);
   pData->nInitRow++;
   if( db->mallocFailed ){
-    corruptSchema(pData, argv[0], 0);
+    corruptSchema(pData, argv[1], 0);
     return 1;
   }
 
   assert( iDb>=0 && iDb<db->nDb );
   if( argv==0 ) return 0;   /* Might happen if EMPTY_RESULT_CALLBACKS are on */
-  if( argv[1]==0 ){
-    corruptSchema(pData, argv[0], 0);
-  }else if( sqlite3_strnicmp(argv[2],"create ",7)==0 ){
+  if( argv[3]==0 ){
+    corruptSchema(pData, argv[1], 0);
+  }else if( sqlite3_strnicmp(argv[4],"create ",7)==0 ){
     /* Call the parser to process a CREATE TABLE, INDEX or VIEW.
     ** But because db->init.busy is set to 1, no VDBE code is generated
     ** or executed.  All the parser does is build the internal data
     ** structures that describe the table, index, or view.
     */
@@ -123788,47 +124781,48 @@
     sqlite3_stmt *pStmt;
     TESTONLY(int rcp);            /* Return code from sqlite3_prepare() */
 
     assert( db->init.busy );
     db->init.iDb = iDb;
-    db->init.newTnum = sqlite3Atoi(argv[1]);
+    db->init.newTnum = sqlite3Atoi(argv[3]);
     db->init.orphanTrigger = 0;
-    TESTONLY(rcp = ) sqlite3_prepare(db, argv[2], -1, &pStmt, 0);
+    db->init.azInit = argv;
+    TESTONLY(rcp = ) sqlite3_prepare(db, argv[4], -1, &pStmt, 0);
     rc = db->errCode;
     assert( (rc&0xFF)==(rcp&0xFF) );
     db->init.iDb = saved_iDb;
     /* assert( saved_iDb==0 || (db->mDbFlags & DBFLAG_Vacuum)!=0 ); */
     if( SQLITE_OK!=rc ){
       if( db->init.orphanTrigger ){
         assert( iDb==1 );
       }else{
-        pData->rc = rc;
+        if( rc > pData->rc ) pData->rc = rc;
         if( rc==SQLITE_NOMEM ){
           sqlite3OomFault(db);
         }else if( rc!=SQLITE_INTERRUPT && (rc&0xFF)!=SQLITE_LOCKED ){
-          corruptSchema(pData, argv[0], sqlite3_errmsg(db));
+          corruptSchema(pData, argv[1], sqlite3_errmsg(db));
         }
       }
     }
     sqlite3_finalize(pStmt);
-  }else if( argv[0]==0 || (argv[2]!=0 && argv[2][0]!=0) ){
-    corruptSchema(pData, argv[0], 0);
+  }else if( argv[1]==0 || (argv[4]!=0 && argv[4][0]!=0) ){
+    corruptSchema(pData, argv[1], 0);
   }else{
     /* If the SQL column is blank it means this is an index that
     ** was created to be the PRIMARY KEY or to fulfill a UNIQUE
     ** constraint for a CREATE TABLE.  The index should have already
     ** been created when we processed the CREATE TABLE.  All we have
     ** to do here is record the root page number for that index.
     */
     Index *pIndex;
-    pIndex = sqlite3FindIndex(db, argv[0], db->aDb[iDb].zDbSName);
+    pIndex = sqlite3FindIndex(db, argv[1], db->aDb[iDb].zDbSName);
     if( pIndex==0
-     || sqlite3GetInt32(argv[1],&pIndex->tnum)==0
+     || sqlite3GetInt32(argv[3],&pIndex->tnum)==0
      || pIndex->tnum<2
      || sqlite3IndexHasDuplicateRootPage(pIndex)
     ){
-      corruptSchema(pData, argv[0], pIndex?"invalid rootpage":"orphan index");
+      corruptSchema(pData, argv[1], pIndex?"invalid rootpage":"orphan index");
     }
   }
   return 0;
 }
 
@@ -123845,11 +124839,11 @@
   int i;
 #ifndef SQLITE_OMIT_DEPRECATED
   int size;
 #endif
   Db *pDb;
-  char const *azArg[4];
+  char const *azArg[6];
   int meta[5];
   InitData initData;
   const char *zMasterName;
   int openedTransaction = 0;
 
@@ -123864,22 +124858,24 @@
   /* Construct the in-memory representation schema tables (sqlite_master or
   ** sqlite_temp_master) by invoking the parser directly.  The appropriate
   ** table name will be inserted automatically by the parser so we can just
   ** use the abbreviation "x" here.  The parser will also automatically tag
   ** the schema table as read-only. */
-  azArg[0] = zMasterName = SCHEMA_TABLE(iDb);
-  azArg[1] = "1";
-  azArg[2] = "CREATE TABLE x(type text,name text,tbl_name text,"
+  azArg[0] = "table";
+  azArg[1] = zMasterName = SCHEMA_TABLE(iDb);
+  azArg[2] = azArg[1];
+  azArg[3] = "1";
+  azArg[4] = "CREATE TABLE x(type text,name text,tbl_name text,"
                             "rootpage int,sql text)";
-  azArg[3] = 0;
+  azArg[5] = 0;
   initData.db = db;
   initData.iDb = iDb;
   initData.rc = SQLITE_OK;
   initData.pzErrMsg = pzErrMsg;
   initData.mInitFlags = mFlags;
   initData.nInitRow = 0;
-  sqlite3InitCallback(&initData, 3, (char **)azArg, 0);
+  sqlite3InitCallback(&initData, 5, (char **)azArg, 0);
   if( initData.rc ){
     rc = initData.rc;
     goto error_out;
   }
 
@@ -124001,11 +124997,11 @@
   */
   assert( db->init.busy );
   {
     char *zSql;
     zSql = sqlite3MPrintf(db,
-        "SELECT name, rootpage, sql FROM \"%w\".%s ORDER BY rowid",
+        "SELECT*FROM\"%w\".%s ORDER BY rowid",
         db->aDb[iDb].zDbSName, zMasterName);
 #ifndef SQLITE_OMIT_AUTHORIZATION
     {
       sqlite3_xauth xAuth;
       xAuth = db->xAuth;
@@ -124322,11 +125318,14 @@
     *pzTail = sParse.zTail;
   }
   rc = sParse.rc;
 
 #ifndef SQLITE_OMIT_EXPLAIN
-  if( rc==SQLITE_OK && sParse.pVdbe && sParse.explain ){
+  /* Justification for the ALWAYS(): The only way for rc to be SQLITE_OK and
+  ** sParse.pVdbe to be NULL is if the input SQL is an empty string, but in
+  ** that case, sParse.explain will be false. */
+  if( sParse.explain && rc==SQLITE_OK && ALWAYS(sParse.pVdbe) ){
     static const char * const azColName[] = {
        "addr", "opcode", "p1", "p2", "p3", "p4", "p5", "comment",
        "id", "parent", "notused", "detail"
     };
     int iFirst, mx;
@@ -124347,12 +125346,12 @@
 #endif
 
   if( db->init.busy==0 ){
     sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int)(sParse.zTail-zSql), prepFlags);
   }
-  if( sParse.pVdbe && (rc!=SQLITE_OK || db->mallocFailed) ){
-    sqlite3VdbeFinalize(sParse.pVdbe);
+  if( rc!=SQLITE_OK || db->mallocFailed ){
+    if( sParse.pVdbe ) sqlite3VdbeFinalize(sParse.pVdbe);
     assert(!(*ppStmt));
   }else{
     *ppStmt = (sqlite3_stmt*)sParse.pVdbe;
   }
 
@@ -124719,10 +125718,11 @@
     sqlite3ExprDelete(db, p->pLimit);
 #ifndef SQLITE_OMIT_WINDOWFUNC
     if( OK_IF_ALWAYS_TRUE(p->pWinDefn) ){
       sqlite3WindowListDelete(db, p->pWinDefn);
     }
+    assert( p->pWin==0 );
 #endif
     if( OK_IF_ALWAYS_TRUE(p->pWith) ) sqlite3WithDelete(db, p->pWith);
     if( bFree ) sqlite3DbFreeNN(db, p);
     p = pPrior;
     bFree = 1;
@@ -124974,11 +125974,11 @@
     ExprSetProperty(pEq, EP_FromJoin);
     assert( !ExprHasProperty(pEq, EP_TokenOnly|EP_Reduced) );
     ExprSetVVAProperty(pEq, EP_NoReduce);
     pEq->iRightJoinTable = (i16)pE2->iTable;
   }
-  *ppWhere = sqlite3ExprAnd(db, *ppWhere, pEq);
+  *ppWhere = sqlite3ExprAnd(pParse, *ppWhere, pEq);
 }
 
 /*
 ** Set the EP_FromJoin property on all terms of the given expression.
 ** And set the Expr.iRightJoinTable to iTable for every term in the
@@ -125108,11 +126108,11 @@
     /* Add the ON clause to the end of the WHERE clause, connected by
     ** an AND operator.
     */
     if( pRight->pOn ){
       if( isOuter ) setJoinExpr(pRight->pOn, pRight->iCursor);
-      p->pWhere = sqlite3ExprAnd(pParse->db, p->pWhere, pRight->pOn);
+      p->pWhere = sqlite3ExprAnd(pParse, p->pWhere, pRight->pOn);
       pRight->pOn = 0;
     }
 
     /* Create extra terms on the WHERE clause for each column named
     ** in the USING clause.  Example: If the two tables to be joined are
@@ -125282,11 +126282,11 @@
     sqlite3VdbeAddOp3(v, OP_Compare, regPrevKey, regBase, pSort->nOBSat);
     pOp = sqlite3VdbeGetOp(v, pSort->addrSortIndex);
     if( pParse->db->mallocFailed ) return;
     pOp->p2 = nKey + nData;
     pKI = pOp->p4.pKeyInfo;
-    memset(pKI->aSortOrder, 0, pKI->nKeyField); /* Makes OP_Jump testable */
+    memset(pKI->aSortFlags, 0, pKI->nKeyField); /* Makes OP_Jump testable */
     sqlite3VdbeChangeP4(v, -1, (char*)pKI, P4_KEYINFO);
     testcase( pKI->nAllField > pKI->nKeyField+2 );
     pOp->p4.pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pSort->pOrderBy,nOBSat,
                                            pKI->nAllField-pKI->nKeyField-1);
     addrJmp = sqlite3VdbeCurrentAddr(v);
@@ -125893,11 +126893,11 @@
 */
 SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X){
   int nExtra = (N+X)*(sizeof(CollSeq*)+1) - sizeof(CollSeq*);
   KeyInfo *p = sqlite3DbMallocRawNN(db, sizeof(KeyInfo) + nExtra);
   if( p ){
-    p->aSortOrder = (u8*)&p->aColl[N+X];
+    p->aSortFlags = (u8*)&p->aColl[N+X];
     p->nKeyField = (u16)N;
     p->nAllField = (u16)(N+X);
     p->enc = ENC(db);
     p->db = db;
     p->nRef = 1;
@@ -125970,11 +126970,11 @@
   pInfo = sqlite3KeyInfoAlloc(db, nExpr-iStart, nExtra+1);
   if( pInfo ){
     assert( sqlite3KeyInfoIsWriteable(pInfo) );
     for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++){
       pInfo->aColl[i-iStart] = sqlite3ExprNNCollSeq(pParse, pItem->pExpr);
-      pInfo->aSortOrder[i-iStart] = pItem->sortOrder;
+      pInfo->aSortFlags[i-iStart] = pItem->sortFlags;
     }
   }
   return pInfo;
 }
 
@@ -126262,12 +127262,10 @@
   char const *zOrigCol = 0;
 #endif
 
   assert( pExpr!=0 );
   assert( pNC->pSrcList!=0 );
-  assert( pExpr->op!=TK_AGG_COLUMN );  /* This routine runes before aggregates
-                                       ** are processed */
   switch( pExpr->op ){
     case TK_COLUMN: {
       /* The expression is a column. Locate the table the column is being
       ** extracted from in NameContext.pSrcList. This table may be real
       ** database table or a subquery.
@@ -126580,16 +127578,15 @@
     /* Get an appropriate name for the column
     */
     if( (zName = pEList->a[i].zName)!=0 ){
       /* If the column contains an "AS <name>" phrase, use <name> as the name */
     }else{
-      Expr *pColExpr = sqlite3ExprSkipCollate(pEList->a[i].pExpr);
+      Expr *pColExpr = sqlite3ExprSkipCollateAndLikely(pEList->a[i].pExpr);
       while( pColExpr->op==TK_DOT ){
         pColExpr = pColExpr->pRight;
         assert( pColExpr!=0 );
       }
-      assert( pColExpr->op!=TK_AGG_COLUMN );
       if( pColExpr->op==TK_COLUMN ){
         /* For columns use the column name name */
         int iCol = pColExpr->iColumn;
         Table *pTab = pColExpr->y.pTab;
         assert( pTab!=0 );
@@ -126653,11 +127650,12 @@
 ** statement be resolved.
 */
 SQLITE_PRIVATE void sqlite3SelectAddColumnTypeAndCollation(
   Parse *pParse,        /* Parsing contexts */
   Table *pTab,          /* Add column type information to this table */
-  Select *pSelect       /* SELECT used to determine types and collations */
+  Select *pSelect,      /* SELECT used to determine types and collations */
+  char aff              /* Default affinity for columns */
 ){
   sqlite3 *db = pParse->db;
   NameContext sNC;
   Column *pCol;
   CollSeq *pColl;
@@ -126686,11 +127684,11 @@
       if( pCol->zName ){
         memcpy(&pCol->zName[n+1], zType, m+1);
         pCol->colFlags |= COLFLAG_HASTYPE;
       }
     }
-    if( pCol->affinity==0 ) pCol->affinity = SQLITE_AFF_BLOB;
+    if( pCol->affinity<=SQLITE_AFF_NONE ) pCol->affinity = aff;
     pColl = sqlite3ExprCollSeq(pParse, p);
     if( pColl && pCol->zColl==0 ){
       pCol->zColl = sqlite3DbStrDup(db, pColl->zName);
     }
   }
@@ -126699,11 +127697,11 @@
 
 /*
 ** Given a SELECT statement, generate a Table structure that describes
 ** the result set of that SELECT.
 */
-SQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse *pParse, Select *pSelect){
+SQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse *pParse, Select *pSelect, char aff){
   Table *pTab;
   sqlite3 *db = pParse->db;
   u64 savedFlags;
 
   savedFlags = db->flags;
@@ -126715,18 +127713,15 @@
   while( pSelect->pPrior ) pSelect = pSelect->pPrior;
   pTab = sqlite3DbMallocZero(db, sizeof(Table) );
   if( pTab==0 ){
     return 0;
   }
-  /* The sqlite3ResultSetOfSelect() is only used n contexts where lookaside
-  ** is disabled */
-  assert( db->lookaside.bDisable );
   pTab->nTabRef = 1;
   pTab->zName = 0;
   pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );
   sqlite3ColumnsFromExprList(pParse, pSelect->pEList, &pTab->nCol, &pTab->aCol);
-  sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSelect);
+  sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSelect, aff);
   pTab->iPKey = -1;
   if( db->mallocFailed ){
     sqlite3DeleteTable(db, pTab);
     return 0;
   }
@@ -126876,11 +127871,11 @@
         pOrderBy->a[i].pExpr =
           sqlite3ExprAddCollateString(pParse, pTerm, pColl->zName);
       }
       assert( sqlite3KeyInfoIsWriteable(pRet) );
       pRet->aColl[i] = pColl;
-      pRet->aSortOrder[i] = pOrderBy->a[i].sortOrder;
+      pRet->aSortFlags[i] = pOrderBy->a[i].sortFlags;
     }
   }
 
   return pRet;
 }
@@ -127159,10 +128154,11 @@
   /* Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only
   ** the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.
   */
   assert( p && p->pPrior );  /* Calling function guarantees this much */
   assert( (p->selFlags & SF_Recursive)==0 || p->op==TK_ALL || p->op==TK_UNION );
+  assert( p->selFlags & SF_Compound );
   db = pParse->db;
   pPrior = p->pPrior;
   dest = *pDest;
   if( pPrior->pOrderBy || pPrior->pLimit ){
     sqlite3ErrorMsg(pParse,"%s clause should come after %s not before",
@@ -127586,15 +128582,18 @@
       break;
     }
 
     /* If this is a scalar select that is part of an expression, then
     ** store the results in the appropriate memory cell and break out
-    ** of the scan loop.
+    ** of the scan loop.  Note that the select might return multiple columns
+    ** if it is the RHS of a row-value IN operator.
     */
     case SRT_Mem: {
-      assert( pIn->nSdst==1 || pParse->nErr>0 );  testcase( pIn->nSdst!=1 );
-      sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSDParm, 1);
+      if( pParse->nErr==0 ){
+        testcase( pIn->nSdst>1 );
+        sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSDParm, pIn->nSdst);
+      }
       /* The LIMIT clause will jump out of the loop for us */
       break;
     }
 #endif /* #ifndef SQLITE_OMIT_SUBQUERY */
 
@@ -127847,11 +128846,11 @@
     pKeyDup = sqlite3KeyInfoAlloc(db, nExpr, 1);
     if( pKeyDup ){
       assert( sqlite3KeyInfoIsWriteable(pKeyDup) );
       for(i=0; i<nExpr; i++){
         pKeyDup->aColl[i] = multiSelectCollSeq(pParse, p, i);
-        pKeyDup->aSortOrder[i] = 0;
+        pKeyDup->aSortFlags[i] = 0;
       }
     }
   }
 
   /* Separate the left and the right query from one another
@@ -128097,10 +129096,22 @@
           pNew->iRightJoinTable = pExpr->iRightJoinTable;
           ExprSetProperty(pNew, EP_FromJoin);
         }
         sqlite3ExprDelete(db, pExpr);
         pExpr = pNew;
+
+        /* Ensure that the expression now has an implicit collation sequence,
+        ** just as it did when it was a column of a view or sub-query. */
+        if( pExpr ){
+          if( pExpr->op!=TK_COLUMN && pExpr->op!=TK_COLLATE ){
+            CollSeq *pColl = sqlite3ExprCollSeq(pSubst->pParse, pExpr);
+            pExpr = sqlite3ExprAddCollateString(pSubst->pParse, pExpr,
+                (pColl ? pColl->zName : "BINARY")
+            );
+          }
+          ExprClearProperty(pExpr, EP_Collate);
+        }
       }
     }
   }else{
     if( pExpr->op==TK_IF_NULL_ROW && pExpr->iTable==pSubst->iTable ){
       pExpr->iTable = pSubst->iNewTable;
@@ -128110,10 +129121,18 @@
     if( ExprHasProperty(pExpr, EP_xIsSelect) ){
       substSelect(pSubst, pExpr->x.pSelect, 1);
     }else{
       substExprList(pSubst, pExpr->x.pList);
     }
+#ifndef SQLITE_OMIT_WINDOWFUNC
+    if( ExprHasProperty(pExpr, EP_WinFunc) ){
+      Window *pWin = pExpr->y.pWin;
+      pWin->pFilter = substExpr(pSubst, pWin->pFilter);
+      substExprList(pSubst, pWin->pPartition);
+      substExprList(pSubst, pWin->pOrderBy);
+    }
+#endif
   }
   return pExpr;
 }
 static void substExprList(
   SubstContext *pSubst, /* Description of the substitution */
@@ -128570,10 +129589,11 @@
   ** elements we are now copying in.
   */
   for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){
     int nSubSrc;
     u8 jointype = 0;
+    assert( pSub!=0 );
     pSubSrc = pSub->pSrc;     /* FROM clause of subquery */
     nSubSrc = pSubSrc->nSrc;  /* Number of terms in subquery FROM clause */
     pSrc = pParent->pSrc;     /* FROM clause of the outer query */
 
     if( pSrc ){
@@ -128653,25 +129673,25 @@
     pWhere = pSub->pWhere;
     pSub->pWhere = 0;
     if( isLeftJoin>0 ){
       setJoinExpr(pWhere, iNewParent);
     }
-    pParent->pWhere = sqlite3ExprAnd(db, pWhere, pParent->pWhere);
+    pParent->pWhere = sqlite3ExprAnd(pParse, pWhere, pParent->pWhere);
     if( db->mallocFailed==0 ){
       SubstContext x;
       x.pParse = pParse;
       x.iTable = iParent;
       x.iNewTable = iNewParent;
       x.isLeftJoin = isLeftJoin;
       x.pEList = pSub->pEList;
       substSelect(&x, pParent, 0);
     }
 
-    /* The flattened query is distinct if either the inner or the
-    ** outer query is distinct.
-    */
-    pParent->selFlags |= pSub->selFlags & SF_Distinct;
+    /* The flattened query is a compound if either the inner or the
+    ** outer query is a compound. */
+    pParent->selFlags |= pSub->selFlags & SF_Compound;
+    assert( (pSub->selFlags & SF_Distinct)==0 ); /* restriction (17b) */
 
     /*
     ** SELECT ... FROM (SELECT ... LIMIT a OFFSET b) LIMIT x OFFSET y;
     **
     ** One is tempted to try to add a and b to combine the limits.  But this
@@ -128988,13 +130008,13 @@
       x.iNewTable = iCursor;
       x.isLeftJoin = 0;
       x.pEList = pSubq->pEList;
       pNew = substExpr(&x, pNew);
       if( pSubq->selFlags & SF_Aggregate ){
-        pSubq->pHaving = sqlite3ExprAnd(pParse->db, pSubq->pHaving, pNew);
+        pSubq->pHaving = sqlite3ExprAnd(pParse, pSubq->pHaving, pNew);
       }else{
-        pSubq->pWhere = sqlite3ExprAnd(pParse->db, pSubq->pWhere, pNew);
+        pSubq->pWhere = sqlite3ExprAnd(pParse, pSubq->pWhere, pNew);
       }
       pSubq = pSubq->pPrior;
     }
   }
   return nChng;
@@ -129020,28 +130040,31 @@
 static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax){
   int eRet = WHERE_ORDERBY_NORMAL;      /* Return value */
   ExprList *pEList = pFunc->x.pList;    /* Arguments to agg function */
   const char *zFunc;                    /* Name of aggregate function pFunc */
   ExprList *pOrderBy;
-  u8 sortOrder;
+  u8 sortFlags;
 
   assert( *ppMinMax==0 );
   assert( pFunc->op==TK_AGG_FUNCTION );
-  if( pEList==0 || pEList->nExpr!=1 ) return eRet;
+  assert( !IsWindowFunc(pFunc) );
+  if( pEList==0 || pEList->nExpr!=1 || ExprHasProperty(pFunc, EP_WinFunc) ){
+    return eRet;
+  }
   zFunc = pFunc->u.zToken;
   if( sqlite3StrICmp(zFunc, "min")==0 ){
     eRet = WHERE_ORDERBY_MIN;
-    sortOrder = SQLITE_SO_ASC;
+    sortFlags = KEYINFO_ORDER_BIGNULL;
   }else if( sqlite3StrICmp(zFunc, "max")==0 ){
     eRet = WHERE_ORDERBY_MAX;
-    sortOrder = SQLITE_SO_DESC;
+    sortFlags = KEYINFO_ORDER_DESC;
   }else{
     return eRet;
   }
   *ppMinMax = pOrderBy = sqlite3ExprListDup(db, pEList, 0);
   assert( pOrderBy!=0 || db->mallocFailed );
-  if( pOrderBy ) pOrderBy->a[0].sortOrder = sortOrder;
+  if( pOrderBy ) pOrderBy->a[0].sortFlags = sortFlags;
   return eRet;
 }
 
 /*
 ** The select statement passed as the first argument is an aggregate query.
@@ -129071,11 +130094,11 @@
 
   if( IsVirtual(pTab) ) return 0;
   if( pExpr->op!=TK_AGG_FUNCTION ) return 0;
   if( NEVER(pAggInfo->nFunc==0) ) return 0;
   if( (pAggInfo->aFunc[0].pFunc->funcFlags&SQLITE_FUNC_COUNT)==0 ) return 0;
-  if( pExpr->flags&EP_Distinct ) return 0;
+  if( ExprHasProperty(pExpr, EP_Distinct|EP_WinFunc) ) return 0;
 
   return pTab;
 }
 
 /*
@@ -129416,11 +130439,11 @@
   sqlite3ColumnsFromExprList(pParse, pSel->pEList,&pTab->nCol,&pTab->aCol);
   pTab->iPKey = -1;
   pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );
   pTab->tabFlags |= TF_Ephemeral;
 
-  return SQLITE_OK;
+  return pParse->nErr ? SQLITE_ERROR : SQLITE_OK;
 }
 
 /*
 ** This routine is a Walker callback for "expanding" a SELECT statement.
 ** "Expanding" means to do the following:
@@ -129462,10 +130485,14 @@
   }
   assert( p->pSrc!=0 );
   if( (selFlags & SF_Expanded)!=0 ){
     return WRC_Prune;
   }
+  if( pWalker->eCode ){
+    /* Renumber selId because it has been copied from a view */
+    p->selId = ++pParse->nSelect;
+  }
   pTabList = p->pSrc;
   pEList = p->pEList;
   sqlite3WithPush(pParse, p->pWith, 0);
 
   /* Make sure cursor numbers have been assigned to all entries in
@@ -129511,16 +130538,23 @@
         return WRC_Abort;
       }
 #if !defined(SQLITE_OMIT_VIEW) || !defined (SQLITE_OMIT_VIRTUALTABLE)
       if( IsVirtual(pTab) || pTab->pSelect ){
         i16 nCol;
+        u8 eCodeOrig = pWalker->eCode;
         if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;
         assert( pFrom->pSelect==0 );
+        if( pTab->pSelect && (db->flags & SQLITE_EnableView)==0 ){
+          sqlite3ErrorMsg(pParse, "access to view \"%s\" prohibited",
+              pTab->zName);
+        }
         pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);
         nCol = pTab->nCol;
         pTab->nCol = -1;
+        pWalker->eCode = 1;  /* Turn on Select.selId renumbering */
         sqlite3WalkSelect(pWalker, pFrom->pSelect);
+        pWalker->eCode = eCodeOrig;
         pTab->nCol = nCol;
       }
 #endif
     }
 
@@ -129766,10 +130800,11 @@
     w.xSelectCallback2 = 0;
     sqlite3WalkSelect(&w, pSelect);
   }
   w.xSelectCallback = selectExpander;
   w.xSelectCallback2 = selectPopWith;
+  w.eCode = 0;
   sqlite3WalkSelect(&w, pSelect);
 }
 
 
 #ifndef SQLITE_OMIT_SUBQUERY
@@ -129803,11 +130838,12 @@
     if( (pTab->tabFlags & TF_Ephemeral)!=0 ){
       /* A sub-query in the FROM clause of a SELECT */
       Select *pSel = pFrom->pSelect;
       if( pSel ){
         while( pSel->pPrior ) pSel = pSel->pPrior;
-        sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSel);
+        sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSel,
+                                               SQLITE_AFF_NONE);
       }
     }
   }
 }
 #endif
@@ -129943,20 +130979,41 @@
     int nArg;
     int addrNext = 0;
     int regAgg;
     ExprList *pList = pF->pExpr->x.pList;
     assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );
+    assert( !IsWindowFunc(pF->pExpr) );
+    if( ExprHasProperty(pF->pExpr, EP_WinFunc) ){
+      Expr *pFilter = pF->pExpr->y.pWin->pFilter;
+      if( pAggInfo->nAccumulator
+       && (pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL)
+      ){
+        if( regHit==0 ) regHit = ++pParse->nMem;
+        /* If this is the first row of the group (regAcc==0), clear the
+        ** "magnet" register regHit so that the accumulator registers
+        ** are populated if the FILTER clause jumps over the the
+        ** invocation of min() or max() altogether. Or, if this is not
+        ** the first row (regAcc==1), set the magnet register so that the
+        ** accumulators are not populated unless the min()/max() is invoked and
+        ** indicates that they should be.  */
+        sqlite3VdbeAddOp2(v, OP_Copy, regAcc, regHit);
+      }
+      addrNext = sqlite3VdbeMakeLabel(pParse);
+      sqlite3ExprIfFalse(pParse, pFilter, addrNext, SQLITE_JUMPIFNULL);
+    }
     if( pList ){
       nArg = pList->nExpr;
       regAgg = sqlite3GetTempRange(pParse, nArg);
       sqlite3ExprCodeExprList(pParse, pList, regAgg, 0, SQLITE_ECEL_DUP);
     }else{
       nArg = 0;
       regAgg = 0;
     }
     if( pF->iDistinct>=0 ){
-      addrNext = sqlite3VdbeMakeLabel(pParse);
+      if( addrNext==0 ){
+        addrNext = sqlite3VdbeMakeLabel(pParse);
+      }
       testcase( nArg==0 );  /* Error condition */
       testcase( nArg>1 );   /* Also an error */
       codeDistinct(pParse, pF->iDistinct, addrNext, 1, regAgg);
     }
     if( pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){
@@ -129988,10 +131045,11 @@
     addrHitTest = sqlite3VdbeAddOp1(v, OP_If, regHit); VdbeCoverage(v);
   }
   for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++){
     sqlite3ExprCode(pParse, pC->pExpr, pC->iMem);
   }
+
   pAggInfo->directMode = 0;
   if( addrHitTest ){
     sqlite3VdbeJumpHere(v, addrHitTest);
   }
 }
@@ -130033,15 +131091,15 @@
 static int havingToWhereExprCb(Walker *pWalker, Expr *pExpr){
   if( pExpr->op!=TK_AND ){
     Select *pS = pWalker->u.pSelect;
     if( sqlite3ExprIsConstantOrGroupBy(pWalker->pParse, pExpr, pS->pGroupBy) ){
       sqlite3 *db = pWalker->pParse->db;
-      Expr *pNew = sqlite3ExprAlloc(db, TK_INTEGER, &sqlite3IntTokens[1], 0);
+      Expr *pNew = sqlite3Expr(db, TK_INTEGER, "1");
       if( pNew ){
         Expr *pWhere = pS->pWhere;
         SWAP(Expr, *pNew, *pExpr);
-        pNew = sqlite3ExprAnd(db, pWhere, pNew);
+        pNew = sqlite3ExprAnd(pWalker->pParse, pWhere, pNew);
         pS->pWhere = pNew;
         pWalker->eCode = 1;
       }
     }
     return WRC_Prune;
@@ -130092,19 +131150,23 @@
   for(pItem = pTabList->a; pItem<pThis; pItem++){
     Select *pS1;
     if( pItem->pSelect==0 ) continue;
     if( pItem->fg.viaCoroutine ) continue;
     if( pItem->zName==0 ) continue;
-    if( sqlite3_stricmp(pItem->zDatabase, pThis->zDatabase)!=0 ) continue;
+    assert( pItem->pTab!=0 );
+    assert( pThis->pTab!=0 );
+    if( pItem->pTab->pSchema!=pThis->pTab->pSchema ) continue;
     if( sqlite3_stricmp(pItem->zName, pThis->zName)!=0 ) continue;
     pS1 = pItem->pSelect;
-    if( pThis->pSelect->selId!=pS1->selId ){
+    if( pItem->pTab->pSchema==0 && pThis->pSelect->selId!=pS1->selId ){
       /* The query flattener left two different CTE tables with identical
       ** names in the same FROM clause. */
       continue;
     }
-    if( sqlite3ExprCompare(0, pThis->pSelect->pWhere, pS1->pWhere, -1) ){
+    if( sqlite3ExprCompare(0, pThis->pSelect->pWhere, pS1->pWhere, -1)
+     || sqlite3ExprCompare(0, pThis->pSelect->pHaving, pS1->pHaving, -1)
+    ){
       /* The view was modified by some other optimization such as
       ** pushDownWhereTerms() */
       continue;
     }
     return pItem;
@@ -130125,21 +131187,24 @@
 ** The transformation only works if all of the following are true:
 **
 **   *  The subquery is a UNION ALL of two or more terms
 **   *  The subquery does not have a LIMIT clause
 **   *  There is no WHERE or GROUP BY or HAVING clauses on the subqueries
-**   *  The outer query is a simple count(*)
+**   *  The outer query is a simple count(*) with no WHERE clause or other
+**      extraneous syntax.
 **
 ** Return TRUE if the optimization is undertaken.
 */
 static int countOfViewOptimization(Parse *pParse, Select *p){
   Select *pSub, *pPrior;
   Expr *pExpr;
   Expr *pCount;
   sqlite3 *db;
   if( (p->selFlags & SF_Aggregate)==0 ) return 0;   /* This is an aggregate */
   if( p->pEList->nExpr!=1 ) return 0;               /* Single result column */
+  if( p->pWhere ) return 0;
+  if( p->pGroupBy ) return 0;
   pExpr = p->pEList->a[0].pExpr;
   if( pExpr->op!=TK_AGG_FUNCTION ) return 0;        /* Result is an aggregate */
   if( sqlite3_stricmp(pExpr->u.zToken,"count") ) return 0;  /* Is count() */
   if( pExpr->x.pList!=0 ) return 0;                 /* Must be count(*) */
   if( p->pSrc->nSrc!=1 ) return 0;                  /* One table in FROM  */
@@ -130448,11 +131513,11 @@
     ** "" column. The original design was for the fake column name to be a NULL,
     ** which would be unambiguous.  But legacy authorization callbacks might
     ** assume the column name is non-NULL and segfault.  The use of an empty
     ** string for the fake column name seems safer.
     */
-    if( pItem->colUsed==0 ){
+    if( pItem->colUsed==0 && pItem->zName!=0 ){
       sqlite3AuthCheck(pParse, SQLITE_READ, pItem->zName, "", pItem->zDatabase);
     }
 
 #if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
     /* Generate code for all sub-queries in the FROM clause
@@ -130462,12 +131527,19 @@
 
     /* The code for a subquery should only be generated once, though it is
     ** technically harmless for it to be generated multiple times. The
     ** following assert() will detect if something changes to cause
     ** the same subquery to be coded multiple times, as a signal to the
-    ** developers to try to optimize the situation. */
-    assert( pItem->addrFillSub==0 );
+    ** developers to try to optimize the situation.
+    **
+    ** Update 2019-07-24:
+    ** See ticket https://sqlite.org/src/tktview/c52b09c7f38903b1311cec40.
+    ** The dbsqlfuzz fuzzer found a case where the same subquery gets
+    ** coded twice.  So this assert() now becomes a testcase().  It should
+    ** be very rare, though.
+    */
+    testcase( pItem->addrFillSub!=0 );
 
     /* Increment Parse.nHeight by the height of the largest expression
     ** tree referred to by this, the parent select. The child select
     ** may contain expression trees of at most
     ** (SQLITE_MAX_EXPR_DEPTH-Parse.nHeight) height. This is a bit
@@ -130537,11 +131609,11 @@
       int topAddr;
       int onceAddr = 0;
       int retAddr;
       struct SrcList_item *pPrior;
 
-      assert( pItem->addrFillSub==0 );
+      testcase( pItem->addrFillSub==0 ); /* Ticket c52b09c7f38903b1311 */
       pItem->regReturn = ++pParse->nMem;
       topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);
       pItem->addrFillSub = topAddr+1;
       if( pItem->fg.isCorrelated==0 ){
         /* If the subquery is not correlated and if we are not inside of
@@ -130777,27 +131849,39 @@
       for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++){
         pItem->u.x.iAlias = 0;
       }
       assert( 66==sqlite3LogEst(100) );
       if( p->nSelectRow>66 ) p->nSelectRow = 66;
+
+      /* If there is both a GROUP BY and an ORDER BY clause and they are
+      ** identical, then it may be possible to disable the ORDER BY clause
+      ** on the grounds that the GROUP BY will cause elements to come out
+      ** in the correct order. It also may not - the GROUP BY might use a
+      ** database index that causes rows to be grouped together as required
+      ** but not actually sorted. Either way, record the fact that the
+      ** ORDER BY and GROUP BY clauses are the same by setting the orderByGrp
+      ** variable.  */
+      if( sSort.pOrderBy && pGroupBy->nExpr==sSort.pOrderBy->nExpr ){
+        int ii;
+        /* The GROUP BY processing doesn't care whether rows are delivered in
+        ** ASC or DESC order - only that each group is returned contiguously.
+        ** So set the ASC/DESC flags in the GROUP BY to match those in the
+        ** ORDER BY to maximize the chances of rows being delivered in an
+        ** order that makes the ORDER BY redundant.  */
+        for(ii=0; ii<pGroupBy->nExpr; ii++){
+          u8 sortFlags = sSort.pOrderBy->a[ii].sortFlags & KEYINFO_ORDER_DESC;
+          pGroupBy->a[ii].sortFlags = sortFlags;
+        }
+        if( sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1)==0 ){
+          orderByGrp = 1;
+        }
+      }
     }else{
       assert( 0==sqlite3LogEst(1) );
       p->nSelectRow = 0;
     }
 
-    /* If there is both a GROUP BY and an ORDER BY clause and they are
-    ** identical, then it may be possible to disable the ORDER BY clause
-    ** on the grounds that the GROUP BY will cause elements to come out
-    ** in the correct order. It also may not - the GROUP BY might use a
-    ** database index that causes rows to be grouped together as required
-    ** but not actually sorted. Either way, record the fact that the
-    ** ORDER BY and GROUP BY clauses are the same by setting the orderByGrp
-    ** variable.  */
-    if( sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1)==0 ){
-      orderByGrp = 1;
-    }
-
     /* Create a label to jump to when we want to abort the query */
     addrEnd = sqlite3VdbeMakeLabel(pParse);
 
     /* Convert TK_COLUMN nodes into TK_AGG_COLUMN and make entries in
     ** sAggInfo for all TK_AGG_FUNCTION nodes in expressions of the
@@ -130828,13 +131912,20 @@
       minMaxFlag = minMaxQuery(db, sAggInfo.aFunc[0].pExpr, &pMinMaxOrderBy);
     }else{
       minMaxFlag = WHERE_ORDERBY_NORMAL;
     }
     for(i=0; i<sAggInfo.nFunc; i++){
-      assert( !ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_xIsSelect) );
+      Expr *pExpr = sAggInfo.aFunc[i].pExpr;
+      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
       sNC.ncFlags |= NC_InAggFunc;
-      sqlite3ExprAnalyzeAggList(&sNC, sAggInfo.aFunc[i].pExpr->x.pList);
+      sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);
+#ifndef SQLITE_OMIT_WINDOWFUNC
+      assert( !IsWindowFunc(pExpr) );
+      if( ExprHasProperty(pExpr, EP_WinFunc) ){
+        sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);
+      }
+#endif
       sNC.ncFlags &= ~NC_InAggFunc;
     }
     sAggInfo.mxReg = pParse->nMem;
     if( db->mallocFailed ) goto select_end;
 #if SELECTTRACE_ENABLED
@@ -131142,17 +132233,22 @@
       }else
 #endif /* SQLITE_OMIT_BTREECOUNT */
       {
         int regAcc = 0;           /* "populate accumulators" flag */
 
-        /* If there are accumulator registers but no min() or max() functions,
-        ** allocate register regAcc. Register regAcc will contain 0 the first
-        ** time the inner loop runs, and 1 thereafter. The code generated
-        ** by updateAccumulator() only updates the accumulator registers if
-        ** regAcc contains 0.  */
+        /* If there are accumulator registers but no min() or max() functions
+        ** without FILTER clauses, allocate register regAcc. Register regAcc
+        ** will contain 0 the first time the inner loop runs, and 1 thereafter.
+        ** The code generated by updateAccumulator() uses this to ensure
+        ** that the accumulator registers are (a) updated only once if
+        ** there are no min() or max functions or (b) always updated for the
+        ** first row visited by the aggregate, so that they are updated at
+        ** least once even if the FILTER clause means the min() or max()
+        ** function visits zero rows.  */
         if( sAggInfo.nAccumulator ){
           for(i=0; i<sAggInfo.nFunc; i++){
+            if( ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_WinFunc) ) continue;
             if( sAggInfo.aFunc[i].pFunc->funcFlags&SQLITE_FUNC_NEEDCOLL ) break;
           }
           if( i==sAggInfo.nFunc ){
             regAcc = ++pParse->nMem;
             sqlite3VdbeAddOp2(v, OP_Integer, 0, regAcc);
@@ -131619,11 +132715,15 @@
   }
 
   /* Check that the trigger name is not reserved and that no trigger of the
   ** specified name exists */
   zName = sqlite3NameFromToken(db, pName);
-  if( !zName || SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){
+  if( zName==0 ){
+    assert( db->mallocFailed );
+    goto trigger_cleanup;
+  }
+  if( sqlite3CheckObjectName(pParse, zName, "trigger", pTab->zName) ){
     goto trigger_cleanup;
   }
   assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
   if( !IN_RENAME_OBJECT ){
     if( sqlite3HashFind(&(db->aDb[iDb].pSchema->trigHash),zName) ){
@@ -131782,10 +132882,11 @@
 
   if( db->init.busy ){
     Trigger *pLink = pTrig;
     Hash *pHash = &db->aDb[iDb].pSchema->trigHash;
     assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
+    assert( pLink!=0 );
     pTrig = sqlite3HashInsert(pHash, zName, pTrig);
     if( pTrig ){
       sqlite3OomFault(db);
     }else if( pLink->pSchema==pLink->pTabSchema ){
       Table *pTab;
@@ -131900,10 +133001,13 @@
       pTriggerStep->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);
     }
     pTriggerStep->pIdList = pColumn;
     pTriggerStep->pUpsert = pUpsert;
     pTriggerStep->orconf = orconf;
+    if( pUpsert ){
+      sqlite3HasExplicitNulls(pParse, pUpsert->pUpsertTarget);
+    }
   }else{
     testcase( pColumn );
     sqlite3IdListDelete(db, pColumn);
     testcase( pUpsert );
     sqlite3UpsertDelete(db, pUpsert);
@@ -132055,14 +133159,13 @@
   int iDb;
 
   iDb = sqlite3SchemaToIndex(pParse->db, pTrigger->pSchema);
   assert( iDb>=0 && iDb<db->nDb );
   pTable = tableOfTrigger(pTrigger);
-  assert( pTable );
-  assert( pTable->pSchema==pTrigger->pSchema || iDb==1 );
+  assert( (pTable && pTable->pSchema==pTrigger->pSchema) || iDb==1 );
 #ifndef SQLITE_OMIT_AUTHORIZATION
-  {
+  if( pTable ){
     int code = SQLITE_DROP_TRIGGER;
     const char *zDb = db->aDb[iDb].zDbSName;
     const char *zTab = SCHEMA_TABLE(iDb);
     if( iDb==1 ) code = SQLITE_DROP_TEMP_TRIGGER;
     if( sqlite3AuthCheck(pParse, code, pTrigger->zName, pTable->zName, zDb) ||
@@ -132072,11 +133175,10 @@
   }
 #endif
 
   /* Generate code to destroy the database record of the trigger.
   */
-  assert( pTable!=0 );
   if( (v = sqlite3GetVdbe(pParse))!=0 ){
     sqlite3NestedParse(pParse,
        "DELETE FROM %Q.%s WHERE name=%Q AND type='trigger'",
        db->aDb[iDb].zDbSName, MASTER_NAME, pTrigger->zName
     );
@@ -132096,13 +133198,15 @@
   pHash = &(db->aDb[iDb].pSchema->trigHash);
   pTrigger = sqlite3HashInsert(pHash, zName, 0);
   if( ALWAYS(pTrigger) ){
     if( pTrigger->pSchema==pTrigger->pTabSchema ){
       Table *pTab = tableOfTrigger(pTrigger);
-      Trigger **pp;
-      for(pp=&pTab->pTrigger; *pp!=pTrigger; pp=&((*pp)->pNext));
-      *pp = (*pp)->pNext;
+      if( pTab ){
+        Trigger **pp;
+        for(pp=&pTab->pTrigger; *pp!=pTrigger; pp=&((*pp)->pNext));
+        *pp = (*pp)->pNext;
+      }
     }
     sqlite3DeleteTrigger(db, pTrigger);
     db->mDbFlags |= DBFLAG_SchemaChange;
   }
 }
@@ -132786,15 +133890,16 @@
   WhereInfo *pWInfo;     /* Information about the WHERE clause */
   Vdbe *v;               /* The virtual database engine */
   Index *pIdx;           /* For looping over indices */
   Index *pPk;            /* The PRIMARY KEY index for WITHOUT ROWID tables */
   int nIdx;              /* Number of indices that need updating */
+  int nAllIdx;           /* Total number of indexes */
   int iBaseCur;          /* Base cursor number */
   int iDataCur;          /* Cursor for the canonical data btree */
   int iIdxCur;           /* Cursor for the first index */
   sqlite3 *db;           /* The database structure */
-  int *aRegIdx = 0;      /* First register in array assigned to each index */
+  int *aRegIdx = 0;      /* Registers for to each index and the main table */
   int *aXRef = 0;        /* aXRef[i] is the index in pChanges->a[] of the
                          ** an expression for the i-th column of the table.
                          ** aXRef[i]==-1 if the i-th column is not changed. */
   u8 *aToOpen;           /* 1 for tables and indices to be opened */
   u8 chngPk;             /* PRIMARY KEY changed in a WITHOUT ROWID table */
@@ -132904,14 +134009,14 @@
   pTabList->a[0].iCursor = iDataCur;
 
   /* Allocate space for aXRef[], aRegIdx[], and aToOpen[].
   ** Initialize aXRef[] and aToOpen[] to their default values.
   */
-  aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol+nIdx) + nIdx+2 );
+  aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol+nIdx+1) + nIdx+2 );
   if( aXRef==0 ) goto update_cleanup;
   aRegIdx = aXRef+pTab->nCol;
-  aToOpen = (u8*)(aRegIdx+nIdx);
+  aToOpen = (u8*)(aRegIdx+nIdx+1);
   memset(aToOpen, 1, nIdx+1);
   aToOpen[nIdx+1] = 0;
   for(i=0; i<pTab->nCol; i++) aXRef[i] = -1;
 
   /* Initialize the name-context */
@@ -132986,11 +134091,11 @@
   /* There is one entry in the aRegIdx[] array for each index on the table
   ** being updated.  Fill in aRegIdx[] with a register number that will hold
   ** the key for accessing each index.
   */
   if( onError==OE_Replace ) bReplace = 1;
-  for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
+  for(nAllIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nAllIdx++){
     int reg;
     if( chngKey || hasFK>1 || pIdx==pPk
      || indexWhereClauseMightChange(pIdx,aXRef,chngRowid)
     ){
       reg = ++pParse->nMem;
@@ -133006,13 +134111,14 @@
           }
           break;
         }
       }
     }
-    if( reg==0 ) aToOpen[j+1] = 0;
-    aRegIdx[j] = reg;
+    if( reg==0 ) aToOpen[nAllIdx+1] = 0;
+    aRegIdx[nAllIdx] = reg;
   }
+  aRegIdx[nAllIdx] = ++pParse->nMem;  /* Register storing the table record */
   if( bReplace ){
     /* If REPLACE conflict resolution might be invoked, open cursors on all
     ** indexes in case they are needed to delete records.  */
     memset(aToOpen, 1, nIdx+1);
   }
@@ -133023,11 +134129,17 @@
   if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);
   sqlite3BeginWriteOperation(pParse, pTrigger || hasFK, iDb);
 
   /* Allocate required registers. */
   if( !IsVirtual(pTab) ){
-    regRowSet = ++pParse->nMem;
+    /* For now, regRowSet and aRegIdx[nAllIdx] share the same register.
+    ** If regRowSet turns out to be needed, then aRegIdx[nAllIdx] will be
+    ** reallocated.  aRegIdx[nAllIdx] is the register in which the main
+    ** table record is written.  regRowSet holds the RowSet for the
+    ** two-pass update algorithm. */
+    assert( aRegIdx[nAllIdx]==pParse->nMem );
+    regRowSet = aRegIdx[nAllIdx];
     regOldRowid = regNewRowid = ++pParse->nMem;
     if( chngPk || pTrigger || hasFK ){
       regOld = pParse->nMem + 1;
       pParse->nMem += pTab->nCol;
     }
@@ -133153,10 +134265,12 @@
     /* Read the rowid of the current row of the WHERE scan. In ONEPASS_OFF
     ** mode, write the rowid into the FIFO. In either of the one-pass modes,
     ** leave it in register regOldRowid.  */
     sqlite3VdbeAddOp2(v, OP_Rowid, iDataCur, regOldRowid);
     if( eOnePass==ONEPASS_OFF ){
+      /* We need to use regRowSet, so reallocate aRegIdx[nAllIdx] */
+      aRegIdx[nAllIdx] = ++pParse->nMem;
       sqlite3VdbeAddOp2(v, OP_RowSetAdd, regRowSet, regOldRowid);
     }
   }else{
     /* Read the PK of the current row into an array of registers. In
     ** ONEPASS_OFF mode, serialize the array into a record and store it in
@@ -133336,32 +134450,34 @@
       }
     }
   }
 
   if( !isView ){
-    int addr1 = 0;        /* Address of jump instruction */
-
     /* Do constraint checks. */
     assert( regOldRowid>0 );
     sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur,
         regNewRowid, regOldRowid, chngKey, onError, labelContinue, &bReplace,
         aXRef, 0);
 
-    /* Do FK constraint checks. */
-    if( hasFK ){
-      sqlite3FkCheck(pParse, pTab, regOldRowid, 0, aXRef, chngKey);
-    }
-
-    /* Delete the index entries associated with the current record.  */
+    /* If REPLACE conflict handling may have been used, or if the PK of the
+    ** row is changing, then the GenerateConstraintChecks() above may have
+    ** moved cursor iDataCur. Reseek it. */
     if( bReplace || chngKey ){
       if( pPk ){
-        addr1 = sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, 0, regKey, nKey);
+        sqlite3VdbeAddOp4Int(v, OP_NotFound,iDataCur,labelContinue,regKey,nKey);
       }else{
-        addr1 = sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, 0, regOldRowid);
+        sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue,regOldRowid);
       }
       VdbeCoverageNeverTaken(v);
     }
+
+    /* Do FK constraint checks. */
+    if( hasFK ){
+      sqlite3FkCheck(pParse, pTab, regOldRowid, 0, aXRef, chngKey);
+    }
+
+    /* Delete the index entries associated with the current record.  */
     sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, aRegIdx, -1);
 
     /* If changing the rowid value, or if there are foreign key constraints
     ** to process, delete the old record. Otherwise, add a noop OP_Delete
     ** to invoke the pre-update hook.
@@ -133387,13 +134503,10 @@
 #else
     if( hasFK>1 || chngKey ){
       sqlite3VdbeAddOp2(v, OP_Delete, iDataCur, 0);
     }
 #endif
-    if( bReplace || chngKey ){
-      sqlite3VdbeJumpHere(v, addr1);
-    }
 
     if( hasFK ){
       sqlite3FkCheck(pParse, pTab, 0, regNewRowid, aXRef, chngKey);
     }
 
@@ -133828,10 +134941,11 @@
 ){
   Vdbe *v = pParse->pVdbe;
   sqlite3 *db = pParse->db;
   SrcList *pSrc;            /* FROM clause for the UPDATE */
   int iDataCur;
+  int i;
 
   assert( v!=0 );
   assert( pUpsert!=0 );
   VdbeNoopComment((v, "Begin DO UPDATE of UPSERT"));
   iDataCur = pUpsert->iDataCur;
@@ -133844,11 +134958,10 @@
       sqlite3ReleaseTempReg(pParse, regRowid);
     }else{
       Index *pPk = sqlite3PrimaryKeyIndex(pTab);
       int nPk = pPk->nKeyCol;
       int iPk = pParse->nMem+1;
-      int i;
       pParse->nMem += nPk;
       for(i=0; i<nPk; i++){
         int k;
         assert( pPk->aiColumn[i]>=0 );
         k = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[i]);
@@ -133865,10 +134978,16 @@
     }
   }
   /* pUpsert does not own pUpsertSrc - the outer INSERT statement does.  So
   ** we have to make a copy before passing it down into sqlite3Update() */
   pSrc = sqlite3SrcListDup(db, pUpsert->pUpsertSrc, 0);
+  /* excluded.* columns of type REAL need to be converted to a hard real */
+  for(i=0; i<pTab->nCol; i++){
+    if( pTab->aCol[i].affinity==SQLITE_AFF_REAL ){
+      sqlite3VdbeAddOp1(v, OP_RealAffinity, pUpsert->regData+i);
+    }
+  }
   sqlite3Update(pParse, pSrc, pUpsert->pUpsertSet,
       pUpsert->pUpsertWhere, OE_Abort, 0, 0, pUpsert);
   pUpsert->pUpsertSet = 0;    /* Will have been deleted by sqlite3Update() */
   pUpsert->pUpsertWhere = 0;  /* Will have been deleted by sqlite3Update() */
   VdbeNoopComment((v, "End DO UPDATE of UPSERT"));
@@ -133984,10 +135103,11 @@
 */
 SQLITE_PRIVATE void sqlite3Vacuum(Parse *pParse, Token *pNm, Expr *pInto){
   Vdbe *v = sqlite3GetVdbe(pParse);
   int iDb = 0;
   if( v==0 ) goto build_vacuum_end;
+  if( pParse->nErr ) goto build_vacuum_end;
   if( pNm ){
 #ifndef SQLITE_BUG_COMPATIBLE_20160819
     /* Default behavior:  Report an error if the argument to VACUUM is
     ** not recognized */
     iDb = sqlite3TwoPartName(pParse, pNm, pNm, &pNm);
@@ -134327,38 +135447,52 @@
 
 /*
 ** Construct and install a Module object for a virtual table.  When this
 ** routine is called, it is guaranteed that all appropriate locks are held
 ** and the module is not already part of the connection.
+**
+** If there already exists a module with zName, replace it with the new one.
+** If pModule==0, then delete the module zName if it exists.
 */
 SQLITE_PRIVATE Module *sqlite3VtabCreateModule(
   sqlite3 *db,                    /* Database in which module is registered */
   const char *zName,              /* Name assigned to this module */
   const sqlite3_module *pModule,  /* The definition of the module */
   void *pAux,                     /* Context pointer for xCreate/xConnect */
   void (*xDestroy)(void *)        /* Module destructor function */
 ){
   Module *pMod;
-  int nName = sqlite3Strlen30(zName);
-  pMod = (Module *)sqlite3Malloc(sizeof(Module) + nName + 1);
-  if( pMod==0 ){
-    sqlite3OomFault(db);
+  Module *pDel;
+  char *zCopy;
+  if( pModule==0 ){
+    zCopy = (char*)zName;
+    pMod = 0;
   }else{
-    Module *pDel;
-    char *zCopy = (char *)(&pMod[1]);
+    int nName = sqlite3Strlen30(zName);
+    pMod = (Module *)sqlite3Malloc(sizeof(Module) + nName + 1);
+    if( pMod==0 ){
+      sqlite3OomFault(db);
+      return 0;
+    }
+    zCopy = (char *)(&pMod[1]);
     memcpy(zCopy, zName, nName+1);
     pMod->zName = zCopy;
     pMod->pModule = pModule;
     pMod->pAux = pAux;
     pMod->xDestroy = xDestroy;
     pMod->pEpoTab = 0;
-    pDel = (Module *)sqlite3HashInsert(&db->aModule,zCopy,(void*)pMod);
-    assert( pDel==0 || pDel==pMod );
-    if( pDel ){
+    pMod->nRefModule = 1;
+  }
+  pDel = (Module *)sqlite3HashInsert(&db->aModule,zCopy,(void*)pMod);
+  if( pDel ){
+    if( pDel==pMod ){
       sqlite3OomFault(db);
       sqlite3DbFree(db, pDel);
       pMod = 0;
+    }else{
+      sqlite3VtabEponymousTableClear(db, pDel);
+      sqlite3VtabModuleUnref(db, pDel);
     }
   }
   return pMod;
 }
 
@@ -134375,15 +135509,11 @@
   void (*xDestroy)(void *)        /* Module destructor function */
 ){
   int rc = SQLITE_OK;
 
   sqlite3_mutex_enter(db->mutex);
-  if( sqlite3HashFind(&db->aModule, zName) ){
-    rc = SQLITE_MISUSE_BKPT;
-  }else{
-    (void)sqlite3VtabCreateModule(db, zName, pModule, pAux, xDestroy);
-  }
+  (void)sqlite3VtabCreateModule(db, zName, pModule, pAux, xDestroy);
   rc = sqlite3ApiExit(db, rc);
   if( rc!=SQLITE_OK && xDestroy ) xDestroy(pAux);
   sqlite3_mutex_leave(db->mutex);
   return rc;
 }
@@ -134418,10 +135548,48 @@
   if( !sqlite3SafetyCheckOk(db) || zName==0 ) return SQLITE_MISUSE_BKPT;
 #endif
   return createModule(db, zName, pModule, pAux, xDestroy);
 }
 
+/*
+** External API to drop all virtual-table modules, except those named
+** on the azNames list.
+*/
+SQLITE_API int sqlite3_drop_modules(sqlite3 *db, const char** azNames){
+  HashElem *pThis, *pNext;
+#ifdef SQLITE_ENABLE_API_ARMOR
+  if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
+#endif
+  for(pThis=sqliteHashFirst(&db->aModule); pThis; pThis=pNext){
+    Module *pMod = (Module*)sqliteHashData(pThis);
+    pNext = sqliteHashNext(pThis);
+    if( azNames ){
+      int ii;
+      for(ii=0; azNames[ii]!=0 && strcmp(azNames[ii],pMod->zName)!=0; ii++){}
+      if( azNames[ii]!=0 ) continue;
+    }
+    createModule(db, pMod->zName, 0, 0, 0);
+  }
+  return SQLITE_OK;
+}
+
+/*
+** Decrement the reference count on a Module object.  Destroy the
+** module when the reference count reaches zero.
+*/
+SQLITE_PRIVATE void sqlite3VtabModuleUnref(sqlite3 *db, Module *pMod){
+  assert( pMod->nRefModule>0 );
+  pMod->nRefModule--;
+  if( pMod->nRefModule==0 ){
+    if( pMod->xDestroy ){
+      pMod->xDestroy(pMod->pAux);
+    }
+    assert( pMod->pEpoTab==0 );
+    sqlite3DbFree(db, pMod);
+  }
+}
+
 /*
 ** Lock the virtual table so that it cannot be disconnected.
 ** Locks nest.  Every lock should have a corresponding unlock.
 ** If an unlock is omitted, resources leaks will occur.
 **
@@ -134457,10 +135625,11 @@
   assert( db->magic==SQLITE_MAGIC_OPEN || db->magic==SQLITE_MAGIC_ZOMBIE );
 
   pVTab->nRef--;
   if( pVTab->nRef==0 ){
     sqlite3_vtab *p = pVTab->pVtab;
+    sqlite3VtabModuleUnref(pVTab->db, pVTab->pMod);
     if( p ){
       p->pModule->xDisconnect(p);
     }
     sqlite3DbFree(db, pVTab);
   }
@@ -134861,10 +136030,11 @@
   }else if( ALWAYS(pVTable->pVtab) ){
     /* Justification of ALWAYS():  A correct vtab constructor must allocate
     ** the sqlite3_vtab object if successful.  */
     memset(pVTable->pVtab, 0, sizeof(pVTable->pVtab[0]));
     pVTable->pVtab->pModule = pMod->pModule;
+    pMod->nRefModule++;
     pVTable->nRef = 1;
     if( sCtx.bDeclared==0 ){
       const char *zFormat = "vtable constructor did not declare schema: %s";
       *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);
       sqlite3VtabUnlock(pVTable);
@@ -135136,18 +136306,20 @@
       }
     }
     p = vtabDisconnectAll(db, pTab);
     xDestroy = p->pMod->pModule->xDestroy;
     assert( xDestroy!=0 );  /* Checked before the virtual table is created */
+    pTab->nTabRef++;
     rc = xDestroy(p->pVtab);
     /* Remove the sqlite3_vtab* from the aVTrans[] array, if applicable */
     if( rc==SQLITE_OK ){
       assert( pTab->pVTable==p && p->pNext==0 );
       p->pVtab = 0;
       pTab->pVTable = 0;
       sqlite3VtabUnlock(p);
     }
+    sqlite3DeleteTable(db, pTab);
   }
 
   return rc;
 }
 
@@ -135586,10 +136758,12 @@
 **
 ** This file contains structure and macro definitions for the query
 ** planner logic in "where.c".  These definitions are broken out into
 ** a separate source file for easier editing.
 */
+#ifndef SQLITE_WHEREINT_H
+#define SQLITE_WHEREINT_H
 
 /*
 ** Trace output macros
 */
 #if defined(SQLITE_TEST) || defined(SQLITE_DEBUG)
@@ -135641,17 +136815,19 @@
   int addrNxt;          /* Jump here to start the next IN combination */
   int addrSkip;         /* Jump here for next iteration of skip-scan */
   int addrCont;         /* Jump here to continue with the next loop cycle */
   int addrFirst;        /* First instruction of interior of the loop */
   int addrBody;         /* Beginning of the body of this loop */
+  int regBignull;       /* big-null flag reg. True if a NULL-scan is needed */
+  int addrBignull;      /* Jump here for next part of big-null scan */
 #ifndef SQLITE_LIKE_DOESNT_MATCH_BLOBS
   u32 iLikeRepCntr;     /* LIKE range processing counter register (times 2) */
   int addrLikeRep;      /* LIKE range processing address */
 #endif
   u8 iFrom;             /* Which entry in the FROM clause */
   u8 op, p3, p5;        /* Opcode, P3 & P5 of the opcode that ends the loop */
-  int p1, p2;           /* Operands of the opcode used to ends the loop */
+  int p1, p2;           /* Operands of the opcode used to end the loop */
   union {               /* Information that depends on pWLoop->wsFlags */
     struct {
       int nIn;              /* Number of entries in aInLoop[] */
       struct InLoop {
         int iCur;              /* The VDBE cursor used by this IN operator */
@@ -135698,11 +136874,11 @@
   union {
     struct {               /* Information for internal btree tables */
       u16 nEq;               /* Number of equality constraints */
       u16 nBtm;              /* Size of BTM vector */
       u16 nTop;              /* Size of TOP vector */
-      u16 nIdxCol;           /* Index column used for ORDER BY */
+      u16 nDistinctCol;      /* Index columns used to sort for DISTINCT */
       Index *pIndex;         /* Index used, or NULL */
     } btree;
     struct {               /* Information for virtual tables */
       int idxNum;            /* Index number */
       u8 needFree;           /* True if sqlite3_free(idxStr) is needed */
@@ -135849,20 +137025,21 @@
 #define TERM_CODED      0x04   /* This term is already coded */
 #define TERM_COPIED     0x08   /* Has a child */
 #define TERM_ORINFO     0x10   /* Need to free the WhereTerm.u.pOrInfo object */
 #define TERM_ANDINFO    0x20   /* Need to free the WhereTerm.u.pAndInfo obj */
 #define TERM_OR_OK      0x40   /* Used during OR-clause processing */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
 #  define TERM_VNULL    0x80   /* Manufactured x>NULL or x<=NULL term */
 #else
-#  define TERM_VNULL    0x00   /* Disabled if not using stat3 */
+#  define TERM_VNULL    0x00   /* Disabled if not using stat4 */
 #endif
 #define TERM_LIKEOPT    0x100  /* Virtual terms from the LIKE optimization */
 #define TERM_LIKECOND   0x200  /* Conditionally this LIKE operator term */
 #define TERM_LIKE       0x400  /* The original LIKE operator */
 #define TERM_IS         0x800  /* Term.pExpr is an IS operator */
 #define TERM_VARSELECT  0x1000 /* Term.pExpr contains a correlated sub-query */
+#define TERM_NOPARTIDX  0x2000 /* Not for use to enable a partial index */
 
 /*
 ** An instance of the WhereScan object is used as an iterator for locating
 ** terms in the WHERE clause that are useful to the query planner.
 */
@@ -135969,11 +137146,11 @@
   WhereInfo *pWInfo;        /* Information about this WHERE */
   WhereClause *pWC;         /* WHERE clause terms */
   ExprList *pOrderBy;       /* ORDER BY clause */
   WhereLoop *pNew;          /* Template WhereLoop */
   WhereOrSet *pOrSet;       /* Record best loops here, if not NULL */
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   UnpackedRecord *pRec;     /* Probe for stat4 (if required) */
   int nRecValid;            /* Number of valid fields currently in pRec */
 #endif
   unsigned int bldFlags;    /* SQLITE_BLDF_* flags */
   unsigned int iPlanLimit;  /* Search limiter */
@@ -136156,10 +137333,13 @@
 #define WHERE_AUTO_INDEX   0x00004000  /* Uses an ephemeral index */
 #define WHERE_SKIPSCAN     0x00008000  /* Uses the skip-scan algorithm */
 #define WHERE_UNQ_WANTED   0x00010000  /* WHERE_ONEROW would have been helpful*/
 #define WHERE_PARTIALIDX   0x00020000  /* The automatic index is partial */
 #define WHERE_IN_EARLYOUT  0x00040000  /* Perhaps quit IN loops early */
+#define WHERE_BIGNULL_SORT 0x00080000  /* Column nEq of index is BIGNULL */
+
+#endif /* !defined(SQLITE_WHEREINT_H) */
 
 /************** End of whereInt.h ********************************************/
 /************** Continuing where we left off in wherecode.c ******************/
 
 #ifndef SQLITE_OMIT_EXPLAIN
@@ -136458,13 +137638,13 @@
 
 /*
 ** Code an OP_Affinity opcode to apply the column affinity string zAff
 ** to the n registers starting at base.
 **
-** As an optimization, SQLITE_AFF_BLOB entries (which are no-ops) at the
-** beginning and end of zAff are ignored.  If all entries in zAff are
-** SQLITE_AFF_BLOB, then no code gets generated.
+** As an optimization, SQLITE_AFF_BLOB and SQLITE_AFF_NONE entries (which
+** are no-ops) at the beginning and end of zAff are ignored.  If all entries
+** in zAff are SQLITE_AFF_BLOB or SQLITE_AFF_NONE, then no code gets generated.
 **
 ** This routine makes its own copy of zAff so that the caller is free
 ** to modify zAff after this routine returns.
 */
 static void codeApplyAffinity(Parse *pParse, int base, int n, char *zAff){
@@ -136473,19 +137653,20 @@
     assert( pParse->db->mallocFailed );
     return;
   }
   assert( v!=0 );
 
-  /* Adjust base and n to skip over SQLITE_AFF_BLOB entries at the beginning
-  ** and end of the affinity string.
+  /* Adjust base and n to skip over SQLITE_AFF_BLOB and SQLITE_AFF_NONE
+  ** entries at the beginning and end of the affinity string.
   */
-  while( n>0 && zAff[0]==SQLITE_AFF_BLOB ){
+  assert( SQLITE_AFF_NONE<SQLITE_AFF_BLOB );
+  while( n>0 && zAff[0]<=SQLITE_AFF_BLOB ){
     n--;
     base++;
     zAff++;
   }
-  while( n>1 && zAff[n-1]==SQLITE_AFF_BLOB ){
+  while( n>1 && zAff[n-1]<=SQLITE_AFF_BLOB ){
     n--;
   }
 
   /* Code the OP_Affinity opcode if there is anything left to do. */
   if( n>0 ){
@@ -137139,11 +138320,11 @@
       sqlite3WalkExpr(&sWalker, pTerm->pExpr);
       if( sWalker.eCode ) continue;
     }
 
     /* If we survive all prior tests, that means this term is worth hinting */
-    pExpr = sqlite3ExprAnd(db, pExpr, sqlite3ExprDup(db, pTerm->pExpr, 0));
+    pExpr = sqlite3ExprAnd(pParse, pExpr, sqlite3ExprDup(db, pTerm->pExpr, 0));
   }
   if( pExpr!=0 ){
     sWalker.xExprCallback = codeCursorHintFixExpr;
     sqlite3WalkExpr(&sWalker, pExpr);
     sqlite3VdbeAddOp4(v, OP_CursorHint,
@@ -137256,10 +138437,11 @@
 ** that contains the value of pExpr.
 */
 static int whereIndexExprTransNode(Walker *p, Expr *pExpr){
   IdxExprTrans *pX = p->u.pIdxTrans;
   if( sqlite3ExprCompare(0, pExpr, pX->pIdxExpr, pX->iTabCur)==0 ){
+    pExpr->affExpr = sqlite3ExprAffinity(pExpr);
     pExpr->op = TK_COLUMN;
     pExpr->iTable = pX->iIdxCur;
     pExpr->iColumn = pX->iIdxCol;
     pExpr->y.pTab = 0;
     return WRC_Prune;
@@ -137688,36 +138870,16 @@
     char *zStartAff;             /* Affinity for start of range constraint */
     char *zEndAff = 0;           /* Affinity for end of range constraint */
     u8 bSeekPastNull = 0;        /* True to seek past initial nulls */
     u8 bStopAtNull = 0;          /* Add condition to terminate at NULLs */
     int omitTable;               /* True if we use the index only */
-
+    int regBignull = 0;          /* big-null flag register */
 
     pIdx = pLoop->u.btree.pIndex;
     iIdxCur = pLevel->iIdxCur;
     assert( nEq>=pLoop->nSkip );
 
-    /* If this loop satisfies a sort order (pOrderBy) request that
-    ** was passed to this function to implement a "SELECT min(x) ..."
-    ** query, then the caller will only allow the loop to run for
-    ** a single iteration. This means that the first row returned
-    ** should not have a NULL value stored in 'x'. If column 'x' is
-    ** the first one after the nEq equality constraints in the index,
-    ** this requires some special handling.
-    */
-    assert( pWInfo->pOrderBy==0
-         || pWInfo->pOrderBy->nExpr==1
-         || (pWInfo->wctrlFlags&WHERE_ORDERBY_MIN)==0 );
-    if( (pWInfo->wctrlFlags&WHERE_ORDERBY_MIN)!=0
-     && pWInfo->nOBSat>0
-     && (pIdx->nKeyCol>nEq)
-    ){
-      assert( pLoop->nSkip==0 );
-      bSeekPastNull = 1;
-      nExtraReg = 1;
-    }
-
     /* Find any inequality constraint terms for the start and end
     ** of the range.
     */
     j = nEq;
     if( pLoop->wsFlags & WHERE_BTM_LIMIT ){
@@ -137754,10 +138916,29 @@
         }
       }
     }
     assert( pRangeEnd==0 || (pRangeEnd->wtFlags & TERM_VNULL)==0 );
 
+    /* If the WHERE_BIGNULL_SORT flag is set, then index column nEq uses
+    ** a non-default "big-null" sort (either ASC NULLS LAST or DESC NULLS
+    ** FIRST). In both cases separate ordered scans are made of those
+    ** index entries for which the column is null and for those for which
+    ** it is not. For an ASC sort, the non-NULL entries are scanned first.
+    ** For DESC, NULL entries are scanned first.
+    */
+    if( (pLoop->wsFlags & (WHERE_TOP_LIMIT|WHERE_BTM_LIMIT))==0
+     && (pLoop->wsFlags & WHERE_BIGNULL_SORT)!=0
+    ){
+      assert( bSeekPastNull==0 && nExtraReg==0 && nBtm==0 && nTop==0 );
+      assert( pRangeEnd==0 && pRangeStart==0 );
+      assert( pLoop->nSkip==0 );
+      nExtraReg = 1;
+      bSeekPastNull = 1;
+      pLevel->regBignull = regBignull = ++pParse->nMem;
+      pLevel->addrBignull = sqlite3VdbeMakeLabel(pParse);
+    }
+
     /* If we are doing a reverse order scan on an ascending index, or
     ** a forward order scan on a descending index, interchange the
     ** start and end terms (pRangeStart and pRangeEnd).
     */
     if( (nEq<pIdx->nKeyCol && bRev==(pIdx->aSortOrder[nEq]==SQLITE_SO_ASC))
@@ -137776,11 +138957,11 @@
     regBase = codeAllEqualityTerms(pParse,pLevel,bRev,nExtraReg,&zStartAff);
     assert( zStartAff==0 || sqlite3Strlen30(zStartAff)>=nEq );
     if( zStartAff && nTop ){
       zEndAff = sqlite3DbStrDup(db, &zStartAff[nEq]);
     }
-    addrNxt = pLevel->addrNxt;
+    addrNxt = (regBignull ? pLevel->addrBignull : pLevel->addrNxt);
 
     testcase( pRangeStart && (pRangeStart->eOperator & WO_LE)!=0 );
     testcase( pRangeStart && (pRangeStart->eOperator & WO_GE)!=0 );
     testcase( pRangeEnd && (pRangeEnd->eOperator & WO_LE)!=0 );
     testcase( pRangeEnd && (pRangeEnd->eOperator & WO_GE)!=0 );
@@ -137810,34 +138991,60 @@
       }else{
         startEq = 1;
       }
       bSeekPastNull = 0;
     }else if( bSeekPastNull ){
+      startEq = 0;
       sqlite3VdbeAddOp2(v, OP_Null, 0, regBase+nEq);
+      start_constraints = 1;
       nConstraint++;
-      startEq = 0;
+    }else if( regBignull ){
+      sqlite3VdbeAddOp2(v, OP_Null, 0, regBase+nEq);
       start_constraints = 1;
+      nConstraint++;
     }
     codeApplyAffinity(pParse, regBase, nConstraint - bSeekPastNull, zStartAff);
     if( pLoop->nSkip>0 && nConstraint==pLoop->nSkip ){
       /* The skip-scan logic inside the call to codeAllEqualityConstraints()
       ** above has already left the cursor sitting on the correct row,
       ** so no further seeking is needed */
     }else{
       if( pLoop->wsFlags & WHERE_IN_EARLYOUT ){
         sqlite3VdbeAddOp1(v, OP_SeekHit, iIdxCur);
       }
+      if( regBignull ){
+        sqlite3VdbeAddOp2(v, OP_Integer, 1, regBignull);
+        VdbeComment((v, "NULL-scan pass ctr"));
+      }
+
       op = aStartOp[(start_constraints<<2) + (startEq<<1) + bRev];
       assert( op!=0 );
       sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);
       VdbeCoverage(v);
       VdbeCoverageIf(v, op==OP_Rewind);  testcase( op==OP_Rewind );
       VdbeCoverageIf(v, op==OP_Last);    testcase( op==OP_Last );
       VdbeCoverageIf(v, op==OP_SeekGT);  testcase( op==OP_SeekGT );
       VdbeCoverageIf(v, op==OP_SeekGE);  testcase( op==OP_SeekGE );
       VdbeCoverageIf(v, op==OP_SeekLE);  testcase( op==OP_SeekLE );
       VdbeCoverageIf(v, op==OP_SeekLT);  testcase( op==OP_SeekLT );
+
+      assert( bSeekPastNull==0 || bStopAtNull==0 );
+      if( regBignull ){
+        assert( bSeekPastNull==1 || bStopAtNull==1 );
+        assert( bSeekPastNull==!bStopAtNull );
+        assert( bStopAtNull==startEq );
+        sqlite3VdbeAddOp2(v, OP_Goto, 0, sqlite3VdbeCurrentAddr(v)+2);
+        op = aStartOp[(nConstraint>1)*4 + 2 + bRev];
+        sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase,
+                             nConstraint-startEq);
+        VdbeCoverage(v);
+        VdbeCoverageIf(v, op==OP_Rewind);  testcase( op==OP_Rewind );
+        VdbeCoverageIf(v, op==OP_Last);    testcase( op==OP_Last );
+        VdbeCoverageIf(v, op==OP_SeekGE);  testcase( op==OP_SeekGE );
+        VdbeCoverageIf(v, op==OP_SeekLE);  testcase( op==OP_SeekLE );
+        assert( op==OP_Rewind || op==OP_Last || op==OP_SeekGE || op==OP_SeekLE);
+      }
     }
 
     /* Load the value for the inequality constraint at the end of the
     ** range (if any).
     */
@@ -137865,29 +139072,54 @@
         disableTerm(pLevel, pRangeEnd);
       }else{
         endEq = 1;
       }
     }else if( bStopAtNull ){
-      sqlite3VdbeAddOp2(v, OP_Null, 0, regBase+nEq);
-      endEq = 0;
+      if( regBignull==0 ){
+        sqlite3VdbeAddOp2(v, OP_Null, 0, regBase+nEq);
+        endEq = 0;
+      }
       nConstraint++;
     }
     sqlite3DbFree(db, zStartAff);
     sqlite3DbFree(db, zEndAff);
 
     /* Top of the loop body */
     pLevel->p2 = sqlite3VdbeCurrentAddr(v);
 
     /* Check if the index cursor is past the end of the range. */
     if( nConstraint ){
+      if( regBignull ){
+        /* Except, skip the end-of-range check while doing the NULL-scan */
+        sqlite3VdbeAddOp2(v, OP_IfNot, regBignull, sqlite3VdbeCurrentAddr(v)+3);
+        VdbeComment((v, "If NULL-scan 2nd pass"));
+        VdbeCoverage(v);
+      }
       op = aEndOp[bRev*2 + endEq];
       sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);
       testcase( op==OP_IdxGT );  VdbeCoverageIf(v, op==OP_IdxGT );
       testcase( op==OP_IdxGE );  VdbeCoverageIf(v, op==OP_IdxGE );
       testcase( op==OP_IdxLT );  VdbeCoverageIf(v, op==OP_IdxLT );
       testcase( op==OP_IdxLE );  VdbeCoverageIf(v, op==OP_IdxLE );
     }
+    if( regBignull ){
+      /* During a NULL-scan, check to see if we have reached the end of
+      ** the NULLs */
+      assert( bSeekPastNull==!bStopAtNull );
+      assert( bSeekPastNull+bStopAtNull==1 );
+      assert( nConstraint+bSeekPastNull>0 );
+      sqlite3VdbeAddOp2(v, OP_If, regBignull, sqlite3VdbeCurrentAddr(v)+2);
+      VdbeComment((v, "If NULL-scan 1st pass"));
+      VdbeCoverage(v);
+      op = aEndOp[bRev*2 + bSeekPastNull];
+      sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase,
+                           nConstraint+bSeekPastNull);
+      testcase( op==OP_IdxGT );  VdbeCoverageIf(v, op==OP_IdxGT );
+      testcase( op==OP_IdxGE );  VdbeCoverageIf(v, op==OP_IdxGE );
+      testcase( op==OP_IdxLT );  VdbeCoverageIf(v, op==OP_IdxLT );
+      testcase( op==OP_IdxLE );  VdbeCoverageIf(v, op==OP_IdxLE );
+    }
 
     if( pLoop->wsFlags & WHERE_IN_EARLYOUT ){
       sqlite3VdbeAddOp2(v, OP_SeekHit, iIdxCur, 1);
     }
 
@@ -138104,11 +139336,11 @@
         testcase( pWC->a[iTerm].wtFlags & TERM_CODED );
         if( (pWC->a[iTerm].wtFlags & (TERM_VIRTUAL|TERM_CODED))!=0 ) continue;
         if( (pWC->a[iTerm].eOperator & WO_ALL)==0 ) continue;
         testcase( pWC->a[iTerm].wtFlags & TERM_ORINFO );
         pExpr = sqlite3ExprDup(db, pExpr, 0);
-        pAndExpr = sqlite3ExprAnd(db, pAndExpr, pExpr);
+        pAndExpr = sqlite3ExprAnd(pParse, pAndExpr, pExpr);
       }
       if( pAndExpr ){
         /* The extra 0x10000 bit on the opcode is masked off and does not
         ** become part of the new Expr.op.  However, it does make the
         ** op==TK_AND comparison inside of sqlite3PExpr() false, and this
@@ -138255,11 +139487,11 @@
     }
     sqlite3VdbeChangeP1(v, iRetInit, sqlite3VdbeCurrentAddr(v));
     sqlite3VdbeGoto(v, pLevel->addrBrk);
     sqlite3VdbeResolveLabel(v, iLoopBody);
 
-    if( pWInfo->nLevel>1 ) sqlite3StackFree(db, pOrTab);
+    if( pWInfo->nLevel>1 ){ sqlite3StackFree(db, pOrTab); }
     if( !untestedTerms ) disableTerm(pLevel, pTerm);
   }else
 #endif /* SQLITE_OMIT_OR_OPTIMIZATION */
 
   {
@@ -138510,11 +139742,11 @@
   if( p && ExprHasProperty(p, EP_Unlikely) ){
     pTerm->truthProb = sqlite3LogEst(p->iTable) - 270;
   }else{
     pTerm->truthProb = 1;
   }
-  pTerm->pExpr = sqlite3ExprSkipCollate(p);
+  pTerm->pExpr = sqlite3ExprSkipCollateAndLikely(p);
   pTerm->wtFlags = wtFlags;
   pTerm->pWC = pWC;
   pTerm->iParent = -1;
   memset(&pTerm->eOperator, 0,
          sizeof(WhereTerm) - offsetof(WhereTerm,eOperator));
@@ -138543,26 +139775,34 @@
 ** that the collating sequence does not change.  For example:
 ** "Y collate NOCASE op X" becomes "X op Y" because any collation sequence on
 ** the left hand side of a comparison overrides any collation sequence
 ** attached to the right. For the same reason the EP_Collate flag
 ** is not commuted.
+**
+** The return value is extra flags that are added to the WhereTerm object
+** after it is commuted.  The only extra flag ever added is TERM_NOPARTIDX
+** which prevents the term from being used to enable a partial index if
+** COLLATE changes have been made.
 */
-static void exprCommute(Parse *pParse, Expr *pExpr){
+static u16 exprCommute(Parse *pParse, Expr *pExpr){
   u16 expRight = (pExpr->pRight->flags & EP_Collate);
   u16 expLeft = (pExpr->pLeft->flags & EP_Collate);
+  u16 wtFlags = 0;
   assert( allowedOp(pExpr->op) && pExpr->op!=TK_IN );
   if( expRight==expLeft ){
     /* Either X and Y both have COLLATE operator or neither do */
     if( expRight ){
       /* Both X and Y have COLLATE operators.  Make sure X is always
       ** used by clearing the EP_Collate flag from Y. */
       pExpr->pRight->flags &= ~EP_Collate;
+      wtFlags |= TERM_NOPARTIDX;
     }else if( sqlite3ExprCollSeq(pParse, pExpr->pLeft)!=0 ){
       /* Neither X nor Y have COLLATE operators, but X has a non-default
       ** collating sequence.  So add the EP_Collate marker on X to cause
       ** it to be searched first. */
       pExpr->pLeft->flags |= EP_Collate;
+      wtFlags |= TERM_NOPARTIDX;
     }
   }
   SWAP(Expr*,pExpr->pRight,pExpr->pLeft);
   if( pExpr->op>=TK_GT ){
     assert( TK_LT==TK_GT+2 );
@@ -138570,10 +139810,11 @@
     assert( TK_GT>TK_EQ );
     assert( TK_GT<TK_LE );
     assert( pExpr->op>=TK_GT && pExpr->op<=TK_GE );
     pExpr->op = ((pExpr->op-TK_GT)^2)+TK_GT;
   }
+  return wtFlags;
 }
 
 /*
 ** Translate from TK_xx operator to WO_xx bitmask.
 */
@@ -138688,31 +139929,42 @@
         for(iFrom=iTo=0; iFrom<cnt; iFrom++){
           if( zNew[iFrom]==wc[3] ) iFrom++;
           zNew[iTo++] = zNew[iFrom];
         }
         zNew[iTo] = 0;
+        assert( iTo>0 );
 
-        /* If the RHS begins with a digit or a minus sign, then the LHS must be
-        ** an ordinary column (not a virtual table column) with TEXT affinity.
-        ** Otherwise the LHS might be numeric and "lhs >= rhs" would be false
-        ** even though "lhs LIKE rhs" is true.  But if the RHS does not start
-        ** with a digit or '-', then "lhs LIKE rhs" will always be false if
-        ** the LHS is numeric and so the optimization still works.
+        /* If the LHS is not an ordinary column with TEXT affinity, then the
+        ** pattern prefix boundaries (both the start and end boundaries) must
+        ** not look like a number.  Otherwise the pattern might be treated as
+        ** a number, which will invalidate the LIKE optimization.
         **
-        ** 2018-09-10 ticket c94369cae9b561b1f996d0054bfab11389f9d033
-        ** The RHS pattern must not be '/%' because the termination condition
-        ** will then become "x<'0'" and if the affinity is numeric, will then
-        ** be converted into "x<0", which is incorrect.
+        ** Getting this right has been a persistent source of bugs in the
+        ** LIKE optimization.  See, for example:
+        **    2018-09-10 https://sqlite.org/src/info/c94369cae9b561b1
+        **    2019-05-02 https://sqlite.org/src/info/b043a54c3de54b28
+        **    2019-06-10 https://sqlite.org/src/info/fd76310a5e843e07
+        **    2019-06-14 https://sqlite.org/src/info/ce8717f0885af975
+        **    2019-09-03 https://sqlite.org/src/info/0f0428096f17252a
         */
-        if( sqlite3Isdigit(zNew[0])
-         || zNew[0]=='-'
-         || (zNew[0]+1=='0' && iTo==1)
+        if( pLeft->op!=TK_COLUMN
+         || sqlite3ExprAffinity(pLeft)!=SQLITE_AFF_TEXT
+         || IsVirtual(pLeft->y.pTab)  /* Value might be numeric */
         ){
-          if( pLeft->op!=TK_COLUMN
-           || sqlite3ExprAffinity(pLeft)!=SQLITE_AFF_TEXT
-           || IsVirtual(pLeft->y.pTab)  /* Value might be numeric */
-          ){
+          int isNum;
+          double rDummy;
+          isNum = sqlite3AtoF(zNew, &rDummy, iTo, SQLITE_UTF8);
+          if( isNum<=0 ){
+            if( iTo==1 && zNew[0]=='-' ){
+              isNum = +1;
+            }else{
+              zNew[iTo-1]++;
+              isNum = sqlite3AtoF(zNew, &rDummy, iTo, SQLITE_UTF8);
+              zNew[iTo-1]--;
+            }
+          }
+          if( isNum>0 ){
             sqlite3ExprDelete(db, pPrefix);
             sqlite3ValueFree(pVal);
             return 0;
           }
         }
@@ -139560,11 +140812,11 @@
         }
       }else{
         pDup = pExpr;
         pNew = pTerm;
       }
-      exprCommute(pParse, pDup);
+      pNew->wtFlags |= exprCommute(pParse, pDup);
       pNew->leftCursor = aiCurCol[0];
       pNew->u.leftColumn = aiCurCol[1];
       testcase( (prereqLeft | extraRight) != prereqLeft );
       pNew->prereqRight = prereqLeft | extraRight;
       pNew->prereqAll = prereqAll;
@@ -139801,23 +141053,23 @@
       exprAnalyze(pSrc, pWC, idxNew);
       markTermAsChild(pWC, idxNew, idxTerm);
     }
   }
 
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
-  /* When sqlite_stat3 histogram data is available an operator of the
+#ifdef SQLITE_ENABLE_STAT4
+  /* When sqlite_stat4 histogram data is available an operator of the
   ** form "x IS NOT NULL" can sometimes be evaluated more efficiently
   ** as "x>NULL" if x is not an INTEGER PRIMARY KEY.  So construct a
   ** virtual term of that form.
   **
   ** Note that the virtual term must be tagged with TERM_VNULL.
   */
   if( pExpr->op==TK_NOTNULL
    && pExpr->pLeft->op==TK_COLUMN
    && pExpr->pLeft->iColumn>=0
    && !ExprHasProperty(pExpr, EP_FromJoin)
-   && OptimizationEnabled(db, SQLITE_Stat34)
+   && OptimizationEnabled(db, SQLITE_Stat4)
   ){
     Expr *pNewExpr;
     Expr *pLeft = pExpr->pLeft;
     int idxNew;
     WhereTerm *pNewTerm;
@@ -139838,11 +141090,11 @@
       pTerm = &pWC->a[idxTerm];
       pTerm->wtFlags |= TERM_COPIED;
       pNewTerm->prereqAll = pTerm->prereqAll;
     }
   }
-#endif /* SQLITE_ENABLE_STAT3_OR_STAT4 */
+#endif /* SQLITE_ENABLE_STAT4 */
 
   /* Prevent ON clause terms of a LEFT JOIN from being used to drive
   ** an index for tables to the left of the join.
   */
   testcase( pTerm!=&pWC->a[idxTerm] );
@@ -139871,11 +141123,11 @@
 ** In the previous sentence and in the diagram, "slot[]" refers to
 ** the WhereClause.a[] array.  The slot[] array grows as needed to contain
 ** all terms of the WHERE clause.
 */
 SQLITE_PRIVATE void sqlite3WhereSplit(WhereClause *pWC, Expr *pExpr, u8 op){
-  Expr *pE2 = sqlite3ExprSkipCollate(pExpr);
+  Expr *pE2 = sqlite3ExprSkipCollateAndLikely(pExpr);
   pWC->op = op;
   if( pE2==0 ) return;
   if( pE2->op!=op ){
     whereClauseInsert(pWC, pExpr, 0);
   }else{
@@ -140286,11 +141538,12 @@
                                        pScan->pIdxExpr,iCur)==0)
          && (pScan->iEquiv<=1 || !ExprHasProperty(pTerm->pExpr, EP_FromJoin))
         ){
           if( (pTerm->eOperator & WO_EQUIV)!=0
            && pScan->nEquiv<ArraySize(pScan->aiCur)
-           && (pX = sqlite3ExprSkipCollate(pTerm->pExpr->pRight))->op==TK_COLUMN
+           && (pX = sqlite3ExprSkipCollateAndLikely(pTerm->pExpr->pRight))->op
+               ==TK_COLUMN
           ){
             int j;
             for(j=0; j<pScan->nEquiv; j++){
               if( pScan->aiCur[j]==pX->iTable
                && pScan->aiColumn[j]==pX->iColumn ){
@@ -140482,11 +141735,11 @@
 ){
   int i;
   const char *zColl = pIdx->azColl[iCol];
 
   for(i=0; i<pList->nExpr; i++){
-    Expr *p = sqlite3ExprSkipCollate(pList->a[i].pExpr);
+    Expr *p = sqlite3ExprSkipCollateAndLikely(pList->a[i].pExpr);
     if( p->op==TK_COLUMN
      && p->iColumn==pIdx->aiColumn[iCol]
      && p->iTable==iBase
     ){
       CollSeq *pColl = sqlite3ExprNNCollSeq(pParse, pList->a[i].pExpr);
@@ -140546,11 +141799,11 @@
   /* If any of the expressions is an IPK column on table iBase, then return
   ** true. Note: The (p->iTable==iBase) part of this test may be false if the
   ** current SELECT is a correlated sub-query.
   */
   for(i=0; i<pDistinct->nExpr; i++){
-    Expr *p = sqlite3ExprSkipCollate(pDistinct->a[i].pExpr);
+    Expr *p = sqlite3ExprSkipCollateAndLikely(pDistinct->a[i].pExpr);
     if( p->op==TK_COLUMN && p->iTable==iBase && p->iColumn<0 ) return 1;
   }
 
   /* Loop through all indices on the table, checking each to see if it makes
   ** the DISTINCT qualifier redundant. It does so if:
@@ -140595,21 +141848,21 @@
 **
 ** This routine runs over generated VDBE code and translates OP_Column
 ** opcodes into OP_Copy when the table is being accessed via co-routine
 ** instead of via table lookup.
 **
-** If the bIncrRowid parameter is 0, then any OP_Rowid instructions on
-** cursor iTabCur are transformed into OP_Null. Or, if bIncrRowid is non-zero,
-** then each OP_Rowid is transformed into an instruction to increment the
-** value stored in its output register.
+** If the iAutoidxCur is not zero, then any OP_Rowid instructions on
+** cursor iTabCur are transformed into OP_Sequence opcode for the
+** iAutoidxCur cursor, in order to generate unique rowids for the
+** automatic index being generated.
 */
 static void translateColumnToCopy(
   Parse *pParse,      /* Parsing context */
   int iStart,         /* Translate from this opcode to the end */
   int iTabCur,        /* OP_Column/OP_Rowid references to this table */
   int iRegister,      /* The first column is in this register */
-  int bIncrRowid      /* If non-zero, transform OP_rowid to OP_AddImm(1) */
+  int iAutoidxCur     /* If non-zero, cursor of autoindex being generated */
 ){
   Vdbe *v = pParse->pVdbe;
   VdbeOp *pOp = sqlite3VdbeGetOp(v, iStart);
   int iEnd = sqlite3VdbeCurrentAddr(v);
   if( pParse->db->mallocFailed ) return;
@@ -140619,15 +141872,13 @@
       pOp->opcode = OP_Copy;
       pOp->p1 = pOp->p2 + iRegister;
       pOp->p2 = pOp->p3;
       pOp->p3 = 0;
     }else if( pOp->opcode==OP_Rowid ){
-      if( bIncrRowid ){
-        /* Increment the value stored in the P2 operand of the OP_Rowid. */
-        pOp->opcode = OP_AddImm;
-        pOp->p1 = pOp->p2;
-        pOp->p2 = 1;
+      if( iAutoidxCur ){
+        pOp->opcode = OP_Sequence;
+        pOp->p1 = iAutoidxCur;
       }else{
         pOp->opcode = OP_Null;
         pOp->p1 = 0;
         pOp->p3 = 0;
       }
@@ -140770,11 +142021,11 @@
          || pLoop->prereq!=0 );                     /*   table of a LEFT JOIN */
     if( pLoop->prereq==0
      && (pTerm->wtFlags & TERM_VIRTUAL)==0
      && !ExprHasProperty(pExpr, EP_FromJoin)
      && sqlite3ExprIsTableConstant(pExpr, pSrc->iCursor) ){
-      pPartial = sqlite3ExprAnd(pParse->db, pPartial,
+      pPartial = sqlite3ExprAnd(pParse, pPartial,
                                 sqlite3ExprDup(pParse->db, pExpr, 0));
     }
     if( termCanDriveIndex(pTerm, pSrc, notReady) ){
       int iCol = pTerm->u.leftColumn;
       Bitmask cMask = iCol>=BMS ? MASKBIT(BMS-1) : MASKBIT(iCol);
@@ -140897,12 +142148,13 @@
   sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);
   if( pPartial ) sqlite3VdbeResolveLabel(v, iContinue);
   if( pTabItem->fg.viaCoroutine ){
     sqlite3VdbeChangeP2(v, addrCounter, regBase+n);
     testcase( pParse->db->mallocFailed );
+    assert( pLevel->iIdxCur>0 );
     translateColumnToCopy(pParse, addrTop, pLevel->iTabCur,
-                          pTabItem->regResult, 1);
+                          pTabItem->regResult, pLevel->iIdxCur);
     sqlite3VdbeGoto(v, addrTop);
     pTabItem->fg.viaCoroutine = 0;
   }else{
     sqlite3VdbeAddOp2(v, OP_Next, pLevel->iTabCur, addrTop+1); VdbeCoverage(v);
   }
@@ -140967,10 +142219,11 @@
   if( pOrderBy ){
     int n = pOrderBy->nExpr;
     for(i=0; i<n; i++){
       Expr *pExpr = pOrderBy->a[i].pExpr;
       if( pExpr->op!=TK_COLUMN || pExpr->iTable!=pSrc->iCursor ) break;
+      if( pOrderBy->a[i].sortFlags & KEYINFO_ORDER_BIGNULL ) break;
     }
     if( i==n){
       nOrderBy = n;
     }
   }
@@ -141065,11 +142318,11 @@
     j++;
   }
   for(i=0; i<nOrderBy; i++){
     Expr *pExpr = pOrderBy->a[i].pExpr;
     pIdxOrderBy[i].iColumn = pExpr->iColumn;
-    pIdxOrderBy[i].desc = pOrderBy->a[i].sortOrder;
+    pIdxOrderBy[i].desc = pOrderBy->a[i].sortFlags & KEYINFO_ORDER_DESC;
   }
 
   *pmNoOmit = mNoOmit;
   return pIdxInfo;
 }
@@ -141111,11 +142364,11 @@
   pVtab->zErrMsg = 0;
   return rc;
 }
 #endif /* !defined(SQLITE_OMIT_VIRTUALTABLE) */
 
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
 /*
 ** Estimate the location of a particular key among all keys in an
 ** index.  Store the results in aStat as follows:
 **
 **    aStat[0]      Est. number of rows less than pRec
@@ -141304,11 +142557,11 @@
 
   /* Restore the pRec->nField value before returning.  */
   pRec->nField = nField;
   return i;
 }
-#endif /* SQLITE_ENABLE_STAT3_OR_STAT4 */
+#endif /* SQLITE_ENABLE_STAT4 */
 
 /*
 ** If it is not NULL, pTerm is a term that provides an upper or lower
 ** bound on a range scan. Without considering pTerm, it is estimated
 ** that the scan will visit nNew rows. This function returns the number
@@ -141330,25 +142583,26 @@
   }
   return nRet;
 }
 
 
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
 /*
 ** Return the affinity for a single column of an index.
 */
 SQLITE_PRIVATE char sqlite3IndexColumnAffinity(sqlite3 *db, Index *pIdx, int iCol){
   assert( iCol>=0 && iCol<pIdx->nColumn );
   if( !pIdx->zColAff ){
     if( sqlite3IndexAffinityStr(db, pIdx)==0 ) return SQLITE_AFF_BLOB;
   }
+  assert( pIdx->zColAff[iCol]!=0 );
   return pIdx->zColAff[iCol];
 }
 #endif
 
 
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
 /*
 ** This function is called to estimate the number of rows visited by a
 ** range-scan on a skip-scan index. For example:
 **
 **   CREATE INDEX i1 ON t1(a, b, c);
@@ -141450,11 +142704,11 @@
   sqlite3ValueFree(p2);
   sqlite3ValueFree(pVal);
 
   return rc;
 }
-#endif /* SQLITE_ENABLE_STAT3_OR_STAT4 */
+#endif /* SQLITE_ENABLE_STAT4 */
 
 /*
 ** This function is used to estimate the number of rows that will be visited
 ** by scanning an index for a range of values. The range may have an upper
 ** bound, a lower bound, or both. The WHERE clause terms that set the upper
@@ -141503,16 +142757,16 @@
 ){
   int rc = SQLITE_OK;
   int nOut = pLoop->nOut;
   LogEst nNew;
 
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
   Index *p = pLoop->u.btree.pIndex;
   int nEq = pLoop->u.btree.nEq;
 
-  if( p->nSample>0 && nEq<p->nSampleCol
-   && OptimizationEnabled(pParse->db, SQLITE_Stat34)
+  if( p->nSample>0 && ALWAYS(nEq<p->nSampleCol)
+   && OptimizationEnabled(pParse->db, SQLITE_Stat4)
   ){
     if( nEq==pBuilder->nRecValid ){
       UnpackedRecord *pRec = pBuilder->pRec;
       tRowcnt a[2];
       int nBtm = pLoop->u.btree.nBtm;
@@ -141606,11 +142860,11 @@
         if( iUpper>iLower ){
           nNew = sqlite3LogEst(iUpper - iLower);
           /* TUNING:  If both iUpper and iLower are derived from the same
           ** sample, then assume they are 4x more selective.  This brings
           ** the estimated selectivity more in line with what it would be
-          ** if estimated without the use of STAT3/4 tables. */
+          ** if estimated without the use of STAT4 tables. */
           if( iLwrIdx==iUprIdx ) nNew -= 20;  assert( 20==sqlite3LogEst(4) );
         }else{
           nNew = 10;        assert( 10==sqlite3LogEst(2) );
         }
         if( nNew<nOut ){
@@ -141655,16 +142909,16 @@
 #endif
   pLoop->nOut = (LogEst)nOut;
   return rc;
 }
 
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
 /*
 ** Estimate the number of rows that will be returned based on
 ** an equality constraint x=VALUE and where that VALUE occurs in
 ** the histogram data.  This only works when x is the left-most
-** column of an index and sqlite_stat3 histogram data is available
+** column of an index and sqlite_stat4 histogram data is available
 ** for that index.  When pExpr==NULL that means the constraint is
 ** "x IS NULL" instead of "x=VALUE".
 **
 ** Write the estimated row count into *pnRow and return SQLITE_OK.
 ** If unable to make an estimate, leave *pnRow unchanged and return
@@ -141718,13 +142972,13 @@
                    p->zName, nEq-1, (int)a[1]));
   *pnRow = a[1];
 
   return rc;
 }
-#endif /* SQLITE_ENABLE_STAT3_OR_STAT4 */
+#endif /* SQLITE_ENABLE_STAT4 */
 
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
 /*
 ** Estimate the number of rows that will be returned based on
 ** an IN constraint where the right-hand side of the IN operator
 ** is a list of values.  Example:
 **
@@ -141767,11 +143021,11 @@
     WHERETRACE(0x10,("IN row estimate: est=%d\n", nRowEst));
   }
   assert( pBuilder->nRecValid==nRecValid );
   return rc;
 }
-#endif /* SQLITE_ENABLE_STAT3_OR_STAT4 */
+#endif /* SQLITE_ENABLE_STAT4 */
 
 
 #ifdef WHERETRACE_ENABLED
 /*
 ** Print the content of a WhereTerm object
@@ -142299,15 +143553,16 @@
   WhereLoop *pLoop,      /* The loop to adjust downward */
   LogEst nRow            /* Number of rows in the entire table */
 ){
   WhereTerm *pTerm, *pX;
   Bitmask notAllowed = ~(pLoop->prereq|pLoop->maskSelf);
-  int i, j, k;
+  int i, j;
   LogEst iReduce = 0;    /* pLoop->nOut should not exceed nRow-iReduce */
 
   assert( (pLoop->wsFlags & WHERE_AUTO_INDEX)==0 );
   for(i=pWC->nTerm, pTerm=pWC->a; i>0; i--, pTerm++){
+    assert( pTerm!=0 );
     if( (pTerm->wtFlags & TERM_VIRTUAL)!=0 ) break;
     if( (pTerm->prereqAll & pLoop->maskSelf)==0 ) continue;
     if( (pTerm->prereqAll & notAllowed)!=0 ) continue;
     for(j=pLoop->nLTerm-1; j>=0; j--){
       pX = pLoop->aLTerm[j];
@@ -142324,10 +143579,11 @@
         /* In the absence of explicit truth probabilities, use heuristics to
         ** guess a reasonable truth probability. */
         pLoop->nOut--;
         if( pTerm->eOperator&(WO_EQ|WO_IS) ){
           Expr *pRight = pTerm->pExpr->pRight;
+          int k = 0;
           testcase( pTerm->pExpr->op==TK_IS );
           if( sqlite3ExprIsInteger(pRight, &k) && k>=(-1) && k<=1 ){
             k = 10;
           }else{
             k = 20;
@@ -142487,11 +143743,11 @@
   for(; rc==SQLITE_OK && pTerm!=0; pTerm = whereScanNext(&scan)){
     u16 eOp = pTerm->eOperator;   /* Shorthand for pTerm->eOperator */
     LogEst rCostIdx;
     LogEst nOutUnadjusted;        /* nOut before IN() and WHERE adjustments */
     int nIn = 0;
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
     int nRecValid = pBuilder->nRecValid;
 #endif
     if( (eOp==WO_ISNULL || (pTerm->wtFlags&TERM_VNULL)!=0)
      && indexColumnNotNull(pProbe, saved_nEq)
     ){
@@ -142548,12 +143804,10 @@
           if( pNew->aLTerm[i] && pNew->aLTerm[i]->pExpr==pExpr ) nIn = 0;
         }
       }else if( ALWAYS(pExpr->x.pList && pExpr->x.pList->nExpr) ){
         /* "x IN (value, value, ...)" */
         nIn = sqlite3LogEst(pExpr->x.pList->nExpr);
-        assert( nIn>0 );  /* RHS always has 2 or more terms...  The parser
-                          ** changes "x IN (?)" into "x=?". */
       }
       if( pProbe->hasStat1 ){
         LogEst M, logK, safetyMargin;
         /* Let:
         **   N = the total number of rows in the table
@@ -142645,11 +143899,11 @@
     ** values of nIn and nInMul. In other words, assuming that all
     ** "x IN(...)" terms are replaced with "x = ?". This block updates
     ** the value of pNew->nOut to account for pTerm (but not nIn/nInMul).  */
     assert( pNew->nOut==saved_nOut );
     if( pNew->wsFlags & WHERE_COLUMN_RANGE ){
-      /* Adjust nOut using stat3/stat4 data. Or, if there is no stat3/stat4
+      /* Adjust nOut using stat4 data. Or, if there is no stat4
       ** data, using some other estimate.  */
       whereRangeScanEst(pParse, pBuilder, pBtm, pTop, pNew);
     }else{
       int nEq = ++pNew->u.btree.nEq;
       assert( eOp & (WO_ISNULL|WO_EQ|WO_IN|WO_IS) );
@@ -142659,17 +143913,17 @@
         assert( (eOp & WO_IN) || nIn==0 );
         testcase( eOp & WO_IN );
         pNew->nOut += pTerm->truthProb;
         pNew->nOut -= nIn;
       }else{
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
         tRowcnt nOut = 0;
         if( nInMul==0
          && pProbe->nSample
          && pNew->u.btree.nEq<=pProbe->nSampleCol
          && ((eOp & WO_IN)==0 || !ExprHasProperty(pTerm->pExpr, EP_xIsSelect))
-         && OptimizationEnabled(db, SQLITE_Stat34)
+         && OptimizationEnabled(db, SQLITE_Stat4)
         ){
           Expr *pExpr = pTerm->pExpr;
           if( (eOp & (WO_EQ|WO_ISNULL|WO_IS))!=0 ){
             testcase( eOp & WO_EQ );
             testcase( eOp & WO_IS );
@@ -142702,10 +143956,11 @@
 
     /* Set rCostIdx to the cost of visiting selected rows in index. Add
     ** it to pNew->rRun, which is currently set to the cost of the index
     ** seek only. Then, if this is a non-covering index, add the cost of
     ** visiting the rows in the main table.  */
+    assert( pSrc->pTab->szTabRow>0 );
     rCostIdx = pNew->nOut + 1 + (15*pProbe->szIdxRow)/pSrc->pTab->szTabRow;
     pNew->rRun = sqlite3LogEstAdd(rLogSize, rCostIdx);
     if( (pNew->wsFlags & (WHERE_IDX_ONLY|WHERE_IPK))==0 ){
       pNew->rRun = sqlite3LogEstAdd(pNew->rRun, pNew->nOut + 16);
     }
@@ -142727,11 +143982,11 @@
      && pNew->u.btree.nEq<pProbe->nColumn
     ){
       whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, nInMul+nIn);
     }
     pNew->nOut = saved_nOut;
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
     pBuilder->nRecValid = nRecValid;
 #endif
   }
   pNew->prereq = saved_prereq;
   pNew->u.btree.nEq = saved_nEq;
@@ -142800,11 +144055,11 @@
   int ii, jj;
 
   if( pIndex->bUnordered ) return 0;
   if( (pOB = pBuilder->pWInfo->pOrderBy)==0 ) return 0;
   for(ii=0; ii<pOB->nExpr; ii++){
-    Expr *pExpr = sqlite3ExprSkipCollate(pOB->a[ii].pExpr);
+    Expr *pExpr = sqlite3ExprSkipCollateAndLikely(pOB->a[ii].pExpr);
     if( pExpr->op==TK_COLUMN && pExpr->iTable==iCursor ){
       if( pExpr->iColumn<0 ) return 1;
       for(jj=0; jj<pIndex->nKeyCol; jj++){
         if( pExpr->iColumn==pIndex->aiColumn[jj] ) return 1;
       }
@@ -142831,11 +144086,13 @@
     if( !whereUsablePartialIndex(iTab,pWC,pWhere->pLeft) ) return 0;
     pWhere = pWhere->pRight;
   }
   if( pParse->db->flags & SQLITE_EnableQPSG ) pParse = 0;
   for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){
-    Expr *pExpr = pTerm->pExpr;
+    Expr *pExpr;
+    if( pTerm->wtFlags & TERM_NOPARTIDX ) continue;
+    pExpr = pTerm->pExpr;
     if( (!ExprHasProperty(pExpr, EP_FromJoin) || pExpr->iRightJoinTable==iTab)
      && sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, iTab)
     ){
       return 1;
     }
@@ -143100,11 +144357,11 @@
       ** unique index is used (making the index functionally non-unique)
       ** then the sqlite_stat1 data becomes important for scoring the
       ** plan */
       pTab->tabFlags |= TF_StatsUsed;
     }
-#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+#ifdef SQLITE_ENABLE_STAT4
     sqlite3Stat4ProbeFree(pBuilder->pRec);
     pBuilder->nRecValid = 0;
     pBuilder->pRec = 0;
 #endif
   }
@@ -143728,23 +144985,23 @@
       pLoop = pLast;
     }
     if( pLoop->wsFlags & WHERE_VIRTUALTABLE ){
       if( pLoop->u.vtab.isOrdered ) obSat = obDone;
       break;
-    }else{
-      pLoop->u.btree.nIdxCol = 0;
+    }else if( wctrlFlags & WHERE_DISTINCTBY ){
+      pLoop->u.btree.nDistinctCol = 0;
     }
     iCur = pWInfo->pTabList->a[pLoop->iTab].iCursor;
 
     /* Mark off any ORDER BY term X that is a column in the table of
     ** the current loop for which there is term in the WHERE
     ** clause of the form X IS NULL or X=? that reference only outer
     ** loops.
     */
     for(i=0; i<nOrderBy; i++){
       if( MASKBIT(i) & obSat ) continue;
-      pOBExpr = sqlite3ExprSkipCollate(pOrderBy->a[i].pExpr);
+      pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy->a[i].pExpr);
       if( pOBExpr->op!=TK_COLUMN ) continue;
       if( pOBExpr->iTable!=iCur ) continue;
       pTerm = sqlite3WhereFindTerm(&pWInfo->sWC, iCur, pOBExpr->iColumn,
                        ~ready, eqOpMask, 0);
       if( pTerm==0 ) continue;
@@ -143777,11 +145034,12 @@
         nKeyCol = pIndex->nKeyCol;
         nColumn = pIndex->nColumn;
         assert( nColumn==nKeyCol+1 || !HasRowid(pIndex->pTable) );
         assert( pIndex->aiColumn[nColumn-1]==XN_ROWID
                           || !HasRowid(pIndex->pTable));
-        isOrderDistinct = IsUniqueIndex(pIndex);
+        isOrderDistinct = IsUniqueIndex(pIndex)
+                          && (pLoop->wsFlags & WHERE_SKIPSCAN)==0;
       }
 
       /* Loop through all columns of the index and deal with the ones
       ** that are not constrained by == or IN.
       */
@@ -143795,19 +145053,25 @@
         );
         if( j<pLoop->u.btree.nEq && j>=pLoop->nSkip ){
           u16 eOp = pLoop->aLTerm[j]->eOperator;
 
           /* Skip over == and IS and ISNULL terms.  (Also skip IN terms when
-          ** doing WHERE_ORDERBY_LIMIT processing).
+          ** doing WHERE_ORDERBY_LIMIT processing).  Except, IS and ISNULL
+          ** terms imply that the index is not UNIQUE NOT NULL in which case
+          ** the loop need to be marked as not order-distinct because it can
+          ** have repeated NULL rows.
           **
           ** If the current term is a column of an ((?,?) IN (SELECT...))
           ** expression for which the SELECT returns more than one column,
           ** check that it is the only column used by this loop. Otherwise,
           ** if it is one of two or more, none of the columns can be
-          ** considered to match an ORDER BY term.  */
+          ** considered to match an ORDER BY term.
+          */
           if( (eOp & eqOpMask)!=0 ){
-            if( eOp & WO_ISNULL ){
+            if( eOp & (WO_ISNULL|WO_IS) ){
+              testcase( eOp & WO_ISNULL );
+              testcase( eOp & WO_IS );
               testcase( isOrderDistinct );
               isOrderDistinct = 0;
             }
             continue;
           }else if( ALWAYS(eOp & WO_IN) ){
@@ -143829,11 +145093,11 @@
         /* Get the column number in the table (iColumn) and sort order
         ** (revIdx) for the j-th column of the index.
         */
         if( pIndex ){
           iColumn = pIndex->aiColumn[j];
-          revIdx = pIndex->aSortOrder[j];
+          revIdx = pIndex->aSortOrder[j] & KEYINFO_ORDER_DESC;
           if( iColumn==pIndex->pTable->iPKey ) iColumn = XN_ROWID;
         }else{
           iColumn = XN_ROWID;
           revIdx = 0;
         }
@@ -143853,11 +145117,11 @@
         ** of the index and mark that ORDER BY term off
         */
         isMatch = 0;
         for(i=0; bOnce && i<nOrderBy; i++){
           if( MASKBIT(i) & obSat ) continue;
-          pOBExpr = sqlite3ExprSkipCollate(pOrderBy->a[i].pExpr);
+          pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy->a[i].pExpr);
           testcase( wctrlFlags & WHERE_GROUPBY );
           testcase( wctrlFlags & WHERE_DISTINCTBY );
           if( (wctrlFlags & (WHERE_GROUPBY|WHERE_DISTINCTBY))==0 ) bOnce = 0;
           if( iColumn>=XN_ROWID ){
             if( pOBExpr->op!=TK_COLUMN ) continue;
@@ -143871,25 +145135,36 @@
           }
           if( iColumn!=XN_ROWID ){
             pColl = sqlite3ExprNNCollSeq(pWInfo->pParse, pOrderBy->a[i].pExpr);
             if( sqlite3StrICmp(pColl->zName, pIndex->azColl[j])!=0 ) continue;
           }
-          pLoop->u.btree.nIdxCol = j+1;
+          if( wctrlFlags & WHERE_DISTINCTBY ){
+            pLoop->u.btree.nDistinctCol = j+1;
+          }
           isMatch = 1;
           break;
         }
         if( isMatch && (wctrlFlags & WHERE_GROUPBY)==0 ){
           /* Make sure the sort order is compatible in an ORDER BY clause.
           ** Sort order is irrelevant for a GROUP BY clause. */
           if( revSet ){
-            if( (rev ^ revIdx)!=pOrderBy->a[i].sortOrder ) isMatch = 0;
+            if( (rev ^ revIdx)!=(pOrderBy->a[i].sortFlags&KEYINFO_ORDER_DESC) ){
+              isMatch = 0;
+            }
           }else{
-            rev = revIdx ^ pOrderBy->a[i].sortOrder;
+            rev = revIdx ^ (pOrderBy->a[i].sortFlags & KEYINFO_ORDER_DESC);
             if( rev ) *pRevMask |= MASKBIT(iLoop);
             revSet = 1;
           }
         }
+        if( isMatch && (pOrderBy->a[i].sortFlags & KEYINFO_ORDER_BIGNULL) ){
+          if( j==pLoop->u.btree.nEq ){
+            pLoop->wsFlags |= WHERE_BIGNULL_SORT;
+          }else{
+            isMatch = 0;
+          }
+        }
         if( isMatch ){
           if( iColumn==XN_ROWID ){
             testcase( distinctColumns==0 );
             distinctColumns = 1;
           }
@@ -144799,10 +146074,20 @@
     sqlite3DebugPrintf("*** Optimizer Start *** (wctrlFlags: 0x%x",wctrlFlags);
     if( wctrlFlags & WHERE_USE_LIMIT ){
       sqlite3DebugPrintf(", limit: %d", iAuxArg);
     }
     sqlite3DebugPrintf(")\n");
+    if( sqlite3WhereTrace & 0x100 ){
+      Select sSelect;
+      memset(&sSelect, 0, sizeof(sSelect));
+      sSelect.selFlags = SF_WhereBegin;
+      sSelect.pSrc = pTabList;
+      sSelect.pWhere = pWhere;
+      sSelect.pOrderBy = pOrderBy;
+      sSelect.pEList = pResultSet;
+      sqlite3TreeViewSelect(0, &sSelect, 0);
+    }
   }
   if( sqlite3WhereTrace & 0x100 ){ /* Display all terms of the WHERE clause */
     sqlite3WhereClausePrint(sWLB.pWC);
   }
 #endif
@@ -145075,10 +146360,11 @@
       if( op ){
         sqlite3VdbeAddOp3(v, op, iIndexCur, pIx->tnum, iDb);
         sqlite3VdbeSetP4KeyInfo(pParse, pIx);
         if( (pLoop->wsFlags & WHERE_CONSTRAINT)!=0
          && (pLoop->wsFlags & (WHERE_COLUMN_RANGE|WHERE_SKIPSCAN))==0
+         && (pLoop->wsFlags & WHERE_BIGNULL_SORT)==0
          && (pWInfo->wctrlFlags&WHERE_ORDERBY_MIN)==0
          && pWInfo->eDistinct!=WHERE_DISTINCT_ORDERED
         ){
           sqlite3VdbeChangeP5(v, OPFLAG_SEEKEQ); /* Hint to COMDB2 */
         }
@@ -145192,11 +146478,11 @@
       int n;
       if( pWInfo->eDistinct==WHERE_DISTINCT_ORDERED
        && i==pWInfo->nLevel-1  /* Ticket [ef9318757b152e3] 2017-10-21 */
        && (pLoop->wsFlags & WHERE_INDEXED)!=0
        && (pIdx = pLoop->u.btree.pIndex)->hasStat1
-       && (n = pLoop->u.btree.nIdxCol)>0
+       && (n = pLoop->u.btree.nDistinctCol)>0
        && pIdx->aiRowLogEst[n]>=36
       ){
         int r1 = pParse->nMem+1;
         int j, op;
         for(j=0; j<n; j++){
@@ -145216,10 +146502,15 @@
       sqlite3VdbeChangeP5(v, pLevel->p5);
       VdbeCoverage(v);
       VdbeCoverageIf(v, pLevel->op==OP_Next);
       VdbeCoverageIf(v, pLevel->op==OP_Prev);
       VdbeCoverageIf(v, pLevel->op==OP_VNext);
+      if( pLevel->regBignull ){
+        sqlite3VdbeResolveLabel(v, pLevel->addrBignull);
+        sqlite3VdbeAddOp2(v, OP_DecrJumpZero, pLevel->regBignull, pLevel->p2-1);
+        VdbeCoverage(v);
+      }
 #ifndef SQLITE_DISABLE_SKIPAHEAD_DISTINCT
       if( addrSeek ) sqlite3VdbeJumpHere(v, addrSeek);
 #endif
     }else{
       sqlite3VdbeResolveLabel(v, pLevel->addrCont);
@@ -146143,10 +147434,11 @@
 typedef struct WindowRewrite WindowRewrite;
 struct WindowRewrite {
   Window *pWin;
   SrcList *pSrc;
   ExprList *pSub;
+  Table *pTab;
   Select *pSubSelect;             /* Current sub-select, if any */
 };
 
 /*
 ** Callback function used by selectWindowRewriteEList(). If necessary,
@@ -146154,10 +147446,12 @@
 ** expression (*ppExpr) in place.
 */
 static int selectWindowRewriteExprCb(Walker *pWalker, Expr *pExpr){
   struct WindowRewrite *p = pWalker->u.pRewrite;
   Parse *pParse = pWalker->pParse;
+  assert( p!=0 );
+  assert( p->pWin!=0 );
 
   /* If this function is being called from within a scalar sub-select
   ** that used by the SELECT statement being processed, only process
   ** TK_COLUMN expressions that refer to it (the outer SELECT). Do
   ** not process aggregates or window functions at all, as they belong
@@ -146203,10 +147497,11 @@
         memset(pExpr, 0, sizeof(Expr));
 
         pExpr->op = TK_COLUMN;
         pExpr->iColumn = p->pSub->nExpr-1;
         pExpr->iTable = p->pWin->iEphCsr;
+        pExpr->y.pTab = p->pTab;
       }
 
       break;
     }
 
@@ -146246,21 +147541,24 @@
 static void selectWindowRewriteEList(
   Parse *pParse,
   Window *pWin,
   SrcList *pSrc,
   ExprList *pEList,               /* Rewrite expressions in this list */
+  Table *pTab,
   ExprList **ppSub                /* IN/OUT: Sub-select expression-list */
 ){
   Walker sWalker;
   WindowRewrite sRewrite;
 
+  assert( pWin!=0 );
   memset(&sWalker, 0, sizeof(Walker));
   memset(&sRewrite, 0, sizeof(WindowRewrite));
 
   sRewrite.pSub = *ppSub;
   sRewrite.pWin = pWin;
   sRewrite.pSrc = pSrc;
+  sRewrite.pTab = pTab;
 
   sWalker.pParse = pParse;
   sWalker.xExprCallback = selectWindowRewriteExprCb;
   sWalker.xSelectCallback = selectWindowRewriteSelectCb;
   sWalker.u.pRewrite = &sRewrite;
@@ -146275,19 +147573,24 @@
 ** expression list pList. Return a pointer to the result list.
 */
 static ExprList *exprListAppendList(
   Parse *pParse,          /* Parsing context */
   ExprList *pList,        /* List to which to append. Might be NULL */
-  ExprList *pAppend       /* List of values to append. Might be NULL */
+  ExprList *pAppend,      /* List of values to append. Might be NULL */
+  int bIntToNull
 ){
   if( pAppend ){
     int i;
     int nInit = pList ? pList->nExpr : 0;
     for(i=0; i<pAppend->nExpr; i++){
       Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);
+      if( bIntToNull && pDup && pDup->op==TK_INTEGER ){
+        pDup->op = TK_NULL;
+        pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);
+      }
       pList = sqlite3ExprListAppend(pParse, pList, pDup);
-      if( pList ) pList->a[nInit+i].sortOrder = pAppend->a[i].sortOrder;
+      if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;
     }
   }
   return pList;
 }
 
@@ -146311,51 +147614,68 @@
     ExprList *pSort = 0;
 
     ExprList *pSublist = 0;       /* Expression list for sub-query */
     Window *pMWin = p->pWin;      /* Master window object */
     Window *pWin;                 /* Window object iterator */
+    Table *pTab;
+
+    pTab = sqlite3DbMallocZero(db, sizeof(Table));
+    if( pTab==0 ){
+      return SQLITE_NOMEM;
+    }
 
     p->pSrc = 0;
     p->pWhere = 0;
     p->pGroupBy = 0;
     p->pHaving = 0;
+    p->selFlags &= ~SF_Aggregate;
 
     /* Create the ORDER BY clause for the sub-select. This is the concatenation
     ** of the window PARTITION and ORDER BY clauses. Then, if this makes it
     ** redundant, remove the ORDER BY from the parent SELECT.  */
     pSort = sqlite3ExprListDup(db, pMWin->pPartition, 0);
-    pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy);
-    if( pSort && p->pOrderBy ){
+    pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);
+    if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){
+      int nSave = pSort->nExpr;
+      pSort->nExpr = p->pOrderBy->nExpr;
       if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){
         sqlite3ExprListDelete(db, p->pOrderBy);
         p->pOrderBy = 0;
       }
+      pSort->nExpr = nSave;
     }
 
     /* Assign a cursor number for the ephemeral table used to buffer rows.
     ** The OpenEphemeral instruction is coded later, after it is known how
     ** many columns the table will have.  */
     pMWin->iEphCsr = pParse->nTab++;
     pParse->nTab += 3;
 
-    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, &pSublist);
-    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, &pSublist);
+    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);
+    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);
     pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);
 
     /* Append the PARTITION BY and ORDER BY expressions to the to the
     ** sub-select expression list. They are required to figure out where
     ** boundaries for partitions and sets of peer rows lie.  */
-    pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition);
-    pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy);
+    pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);
+    pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);
 
     /* Append the arguments passed to each window function to the
     ** sub-select expression list. Also allocate two registers for each
     ** window function - one for the accumulator, another for interim
     ** results.  */
     for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
-      pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
-      pSublist = exprListAppendList(pParse, pSublist, pWin->pOwner->x.pList);
+      ExprList *pArgs = pWin->pOwner->x.pList;
+      if( pWin->pFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){
+        selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);
+        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
+        pWin->bExprArgs = 1;
+      }else{
+        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
+        pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);
+      }
       if( pWin->pFilter ){
         Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);
         pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);
       }
       pWin->regAccum = ++pParse->nMem;
@@ -146369,47 +147689,64 @@
     ** that pSublist is still NULL here. Add a constant expression here to
     ** keep everything legal in this case.
     */
     if( pSublist==0 ){
       pSublist = sqlite3ExprListAppend(pParse, 0,
-          sqlite3ExprAlloc(db, TK_INTEGER, &sqlite3IntTokens[0], 0)
+        sqlite3Expr(db, TK_INTEGER, "0")
       );
     }
 
     pSub = sqlite3SelectNew(
         pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0
     );
     p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
     if( p->pSrc ){
+      Table *pTab2;
       p->pSrc->a[0].pSelect = pSub;
       sqlite3SrcListAssignCursors(pParse, p->pSrc);
-      if( sqlite3ExpandSubquery(pParse, &p->pSrc->a[0]) ){
+      pSub->selFlags |= SF_Expanded;
+      pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE);
+      if( pTab2==0 ){
         rc = SQLITE_NOMEM;
       }else{
-        pSub->selFlags |= SF_Expanded;
-        p->selFlags &= ~SF_Aggregate;
-        sqlite3SelectPrep(pParse, pSub, 0);
+        memcpy(pTab, pTab2, sizeof(Table));
+        pTab->tabFlags |= TF_Ephemeral;
+        p->pSrc->a[0].pTab = pTab;
+        pTab = pTab2;
       }
-
       sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, pSublist->nExpr);
       sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+1, pMWin->iEphCsr);
       sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+2, pMWin->iEphCsr);
       sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+3, pMWin->iEphCsr);
     }else{
       sqlite3SelectDelete(db, pSub);
     }
     if( db->mallocFailed ) rc = SQLITE_NOMEM;
+    sqlite3DbFree(db, pTab);
   }
 
   return rc;
 }
 
+/*
+** Unlink the Window object from the Select to which it is attached,
+** if it is attached.
+*/
+SQLITE_PRIVATE void sqlite3WindowUnlinkFromSelect(Window *p){
+  if( p->ppThis ){
+    *p->ppThis = p->pNextWin;
+    if( p->pNextWin ) p->pNextWin->ppThis = p->ppThis;
+    p->ppThis = 0;
+  }
+}
+
 /*
 ** Free the Window object passed as the second argument.
 */
 SQLITE_PRIVATE void sqlite3WindowDelete(sqlite3 *db, Window *p){
   if( p ){
+    sqlite3WindowUnlinkFromSelect(p);
     sqlite3ExprDelete(db, p->pFilter);
     sqlite3ExprListDelete(db, p->pPartition);
     sqlite3ExprListDelete(db, p->pOrderBy);
     sqlite3ExprDelete(db, p->pEnd);
     sqlite3ExprDelete(db, p->pStart);
@@ -146583,40 +147920,59 @@
 ** Attach window object pWin to expression p.
 */
 SQLITE_PRIVATE void sqlite3WindowAttach(Parse *pParse, Expr *p, Window *pWin){
   if( p ){
     assert( p->op==TK_FUNCTION );
-    /* This routine is only called for the parser.  If pWin was not
-    ** allocated due to an OOM, then the parser would fail before ever
-    ** invoking this routine */
-    if( ALWAYS(pWin) ){
-      p->y.pWin = pWin;
-      ExprSetProperty(p, EP_WinFunc);
-      pWin->pOwner = p;
-      if( p->flags & EP_Distinct ){
-        sqlite3ErrorMsg(pParse,
-           "DISTINCT is not supported for window functions");
-      }
+    assert( pWin );
+    p->y.pWin = pWin;
+    ExprSetProperty(p, EP_WinFunc);
+    pWin->pOwner = p;
+    if( (p->flags & EP_Distinct) && pWin->eFrmType!=TK_FILTER ){
+      sqlite3ErrorMsg(pParse,
+          "DISTINCT is not supported for window functions"
+      );
     }
   }else{
     sqlite3WindowDelete(pParse->db, pWin);
   }
 }
 
+/*
+** Possibly link window pWin into the list at pSel->pWin (window functions
+** to be processed as part of SELECT statement pSel). The window is linked
+** in if either (a) there are no other windows already linked to this
+** SELECT, or (b) the windows already linked use a compatible window frame.
+*/
+SQLITE_PRIVATE void sqlite3WindowLink(Select *pSel, Window *pWin){
+  if( 0==pSel->pWin
+   || 0==sqlite3WindowCompare(0, pSel->pWin, pWin, 0)
+  ){
+    pWin->pNextWin = pSel->pWin;
+    if( pSel->pWin ){
+      pSel->pWin->ppThis = &pWin->pNextWin;
+    }
+    pSel->pWin = pWin;
+    pWin->ppThis = &pSel->pWin;
+  }
+}
+
 /*
 ** Return 0 if the two window objects are identical, or non-zero otherwise.
 ** Identical window objects can be processed in a single scan.
 */
-SQLITE_PRIVATE int sqlite3WindowCompare(Parse *pParse, Window *p1, Window *p2){
+SQLITE_PRIVATE int sqlite3WindowCompare(Parse *pParse, Window *p1, Window *p2, int bFilter){
   if( p1->eFrmType!=p2->eFrmType ) return 1;
   if( p1->eStart!=p2->eStart ) return 1;
   if( p1->eEnd!=p2->eEnd ) return 1;
   if( p1->eExclude!=p2->eExclude ) return 1;
   if( sqlite3ExprCompare(pParse, p1->pStart, p2->pStart, -1) ) return 1;
   if( sqlite3ExprCompare(pParse, p1->pEnd, p2->pEnd, -1) ) return 1;
   if( sqlite3ExprListCompare(p1->pPartition, p2->pPartition, -1) ) return 1;
   if( sqlite3ExprListCompare(p1->pOrderBy, p2->pOrderBy, -1) ) return 1;
+  if( bFilter ){
+    if( sqlite3ExprCompare(pParse, p1->pFilter, p2->pFilter, -1) ) return 1;
+  }
   return 0;
 }
 
 
 /*
@@ -146664,12 +148020,12 @@
       KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pList, 0, 0);
       pWin->csrApp = pParse->nTab++;
       pWin->regApp = pParse->nMem+1;
       pParse->nMem += 3;
       if( pKeyInfo && pWin->pFunc->zName[1]=='i' ){
-        assert( pKeyInfo->aSortOrder[0]==0 );
-        pKeyInfo->aSortOrder[0] = 1;
+        assert( pKeyInfo->aSortFlags[0]==0 );
+        pKeyInfo->aSortFlags[0] = KEYINFO_ORDER_DESC;
       }
       sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pWin->csrApp, 2);
       sqlite3VdbeAppendP4(v, pKeyInfo, P4_KEYINFO);
       sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp+1);
     }
@@ -146750,10 +148106,112 @@
 static int windowArgCount(Window *pWin){
   ExprList *pList = pWin->pOwner->x.pList;
   return (pList ? pList->nExpr : 0);
 }
 
+typedef struct WindowCodeArg WindowCodeArg;
+typedef struct WindowCsrAndReg WindowCsrAndReg;
+
+/*
+** See comments above struct WindowCodeArg.
+*/
+struct WindowCsrAndReg {
+  int csr;                        /* Cursor number */
+  int reg;                        /* First in array of peer values */
+};
+
+/*
+** A single instance of this structure is allocated on the stack by
+** sqlite3WindowCodeStep() and a pointer to it passed to the various helper
+** routines. This is to reduce the number of arguments required by each
+** helper function.
+**
+** regArg:
+**   Each window function requires an accumulator register (just as an
+**   ordinary aggregate function does). This variable is set to the first
+**   in an array of accumulator registers - one for each window function
+**   in the WindowCodeArg.pMWin list.
+**
+** eDelete:
+**   The window functions implementation sometimes caches the input rows
+**   that it processes in a temporary table. If it is not zero, this
+**   variable indicates when rows may be removed from the temp table (in
+**   order to reduce memory requirements - it would always be safe just
+**   to leave them there). Possible values for eDelete are:
+**
+**      WINDOW_RETURN_ROW:
+**        An input row can be discarded after it is returned to the caller.
+**
+**      WINDOW_AGGINVERSE:
+**        An input row can be discarded after the window functions xInverse()
+**        callbacks have been invoked in it.
+**
+**      WINDOW_AGGSTEP:
+**        An input row can be discarded after the window functions xStep()
+**        callbacks have been invoked in it.
+**
+** start,current,end
+**   Consider a window-frame similar to the following:
+**
+**     (ORDER BY a, b GROUPS BETWEEN 2 PRECEDING AND 2 FOLLOWING)
+**
+**   The windows functions implmentation caches the input rows in a temp
+**   table, sorted by "a, b" (it actually populates the cache lazily, and
+**   aggressively removes rows once they are no longer required, but that's
+**   a mere detail). It keeps three cursors open on the temp table. One
+**   (current) that points to the next row to return to the query engine
+**   once its window function values have been calculated. Another (end)
+**   points to the next row to call the xStep() method of each window function
+**   on (so that it is 2 groups ahead of current). And a third (start) that
+**   points to the next row to call the xInverse() method of each window
+**   function on.
+**
+**   Each cursor (start, current and end) consists of a VDBE cursor
+**   (WindowCsrAndReg.csr) and an array of registers (starting at
+**   WindowCodeArg.reg) that always contains a copy of the peer values
+**   read from the corresponding cursor.
+**
+**   Depending on the window-frame in question, all three cursors may not
+**   be required. In this case both WindowCodeArg.csr and reg are set to
+**   0.
+*/
+struct WindowCodeArg {
+  Parse *pParse;             /* Parse context */
+  Window *pMWin;             /* First in list of functions being processed */
+  Vdbe *pVdbe;               /* VDBE object */
+  int addrGosub;             /* OP_Gosub to this address to return one row */
+  int regGosub;              /* Register used with OP_Gosub(addrGosub) */
+  int regArg;                /* First in array of accumulator registers */
+  int eDelete;               /* See above */
+
+  WindowCsrAndReg start;
+  WindowCsrAndReg current;
+  WindowCsrAndReg end;
+};
+
+/*
+** Generate VM code to read the window frames peer values from cursor csr into
+** an array of registers starting at reg.
+*/
+static void windowReadPeerValues(
+  WindowCodeArg *p,
+  int csr,
+  int reg
+){
+  Window *pMWin = p->pMWin;
+  ExprList *pOrderBy = pMWin->pOrderBy;
+  if( pOrderBy ){
+    Vdbe *v = sqlite3GetVdbe(p->pParse);
+    ExprList *pPart = pMWin->pPartition;
+    int iColOff = pMWin->nBufferCol + (pPart ? pPart->nExpr : 0);
+    int i;
+    for(i=0; i<pOrderBy->nExpr; i++){
+      sqlite3VdbeAddOp3(v, OP_Column, csr, iColOff+i, reg+i);
+    }
+  }
+}
+
 /*
 ** Generate VM code to invoke either xStep() (if bInverse is 0) or
 ** xInverse (if bInverse is non-zero) for each window function in the
 ** linked list starting at pMWin. Or, for built-in window functions
 ** that do not use the standard function API, generate the required
@@ -146770,24 +148228,31 @@
 **
 ** If argument regPartSize is non-zero, then it is a register containing the
 ** number of rows in the current partition.
 */
 static void windowAggStep(
-  Parse *pParse,
+  WindowCodeArg *p,
   Window *pMWin,                  /* Linked list of window functions */
   int csr,                        /* Read arguments from this cursor */
   int bInverse,                   /* True to invoke xInverse instead of xStep */
   int reg                         /* Array of registers */
 ){
+  Parse *pParse = p->pParse;
   Vdbe *v = sqlite3GetVdbe(pParse);
   Window *pWin;
   for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
     FuncDef *pFunc = pWin->pFunc;
     int regArg;
-    int nArg = windowArgCount(pWin);
+    int nArg = pWin->bExprArgs ? 0 : windowArgCount(pWin);
     int i;
 
+    assert( bInverse==0 || pWin->eStart!=TK_UNBOUNDED );
+
+    /* All OVER clauses in the same window function aggregate step must
+    ** be the same. */
+    assert( pWin==pMWin || sqlite3WindowCompare(pParse,pWin,pMWin,0)==0 );
+
     for(i=0; i<nArg; i++){
       if( i!=1 || pFunc->zName!=nth_valueName ){
         sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol+i, reg+i);
       }else{
         sqlite3VdbeAddOp3(v, OP_Column, pMWin->iEphCsr, pWin->iArgCol+i, reg+i);
@@ -146821,83 +148286,59 @@
       sqlite3VdbeAddOp2(v, OP_AddImm, pWin->regApp+1-bInverse, 1);
     }else if( pFunc->xSFunc!=noopStepFunc ){
       int addrIf = 0;
       if( pWin->pFilter ){
         int regTmp;
-        assert( nArg==0 || nArg==pWin->pOwner->x.pList->nExpr );
-        assert( nArg || pWin->pOwner->x.pList==0 );
+        assert( pWin->bExprArgs || !nArg ||nArg==pWin->pOwner->x.pList->nExpr );
+        assert( pWin->bExprArgs || nArg  ||pWin->pOwner->x.pList==0 );
         regTmp = sqlite3GetTempReg(pParse);
         sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol+nArg,regTmp);
         addrIf = sqlite3VdbeAddOp3(v, OP_IfNot, regTmp, 0, 1);
         VdbeCoverage(v);
         sqlite3ReleaseTempReg(pParse, regTmp);
       }
+
+      if( pWin->bExprArgs ){
+        int iStart = sqlite3VdbeCurrentAddr(v);
+        VdbeOp *pOp, *pEnd;
+
+        nArg = pWin->pOwner->x.pList->nExpr;
+        regArg = sqlite3GetTempRange(pParse, nArg);
+        sqlite3ExprCodeExprList(pParse, pWin->pOwner->x.pList, regArg, 0, 0);
+
+        pEnd = sqlite3VdbeGetOp(v, -1);
+        for(pOp=sqlite3VdbeGetOp(v, iStart); pOp<=pEnd; pOp++){
+          if( pOp->opcode==OP_Column && pOp->p1==pWin->iEphCsr ){
+            pOp->p1 = csr;
+          }
+        }
+      }
       if( pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){
         CollSeq *pColl;
         assert( nArg>0 );
         pColl = sqlite3ExprNNCollSeq(pParse, pWin->pOwner->x.pList->a[0].pExpr);
         sqlite3VdbeAddOp4(v, OP_CollSeq, 0,0,0, (const char*)pColl, P4_COLLSEQ);
       }
       sqlite3VdbeAddOp3(v, bInverse? OP_AggInverse : OP_AggStep,
                         bInverse, regArg, pWin->regAccum);
       sqlite3VdbeAppendP4(v, pFunc, P4_FUNCDEF);
       sqlite3VdbeChangeP5(v, (u8)nArg);
+      if( pWin->bExprArgs ){
+        sqlite3ReleaseTempRange(pParse, regArg, nArg);
+      }
       if( addrIf ) sqlite3VdbeJumpHere(v, addrIf);
     }
   }
 }
 
-typedef struct WindowCodeArg WindowCodeArg;
-typedef struct WindowCsrAndReg WindowCsrAndReg;
-struct WindowCsrAndReg {
-  int csr;
-  int reg;
-};
-
-struct WindowCodeArg {
-  Parse *pParse;
-  Window *pMWin;
-  Vdbe *pVdbe;
-  int regGosub;
-  int addrGosub;
-  int regArg;
-  int eDelete;
-
-  WindowCsrAndReg start;
-  WindowCsrAndReg current;
-  WindowCsrAndReg end;
-};
-
 /*
 ** Values that may be passed as the second argument to windowCodeOp().
 */
 #define WINDOW_RETURN_ROW 1
 #define WINDOW_AGGINVERSE 2
 #define WINDOW_AGGSTEP    3
 
-/*
-** Generate VM code to read the window frames peer values from cursor csr into
-** an array of registers starting at reg.
-*/
-static void windowReadPeerValues(
-  WindowCodeArg *p,
-  int csr,
-  int reg
-){
-  Window *pMWin = p->pMWin;
-  ExprList *pOrderBy = pMWin->pOrderBy;
-  if( pOrderBy ){
-    Vdbe *v = sqlite3GetVdbe(p->pParse);
-    ExprList *pPart = pMWin->pPartition;
-    int iColOff = pMWin->nBufferCol + (pPart ? pPart->nExpr : 0);
-    int i;
-    for(i=0; i<pOrderBy->nExpr; i++){
-      sqlite3VdbeAddOp3(v, OP_Column, csr, iColOff+i, reg+i);
-    }
-  }
-}
-
 /*
 ** Generate VM code to invoke either xValue() (bFin==0) or xFinalize()
 ** (bFin==1) for each window function in the linked list starting at
 ** pMWin. Or, for built-in window-functions that do not use the standard
 ** API, generate the equivalent VM code.
@@ -146954,12 +148395,16 @@
 
   int nPeer;
   int lblNext;
   int lblBrk;
   int addrNext;
-  int csr = pMWin->csrApp;
+  int csr;
 
+  VdbeModuleComment((v, "windowFullScan begin"));
+
+  assert( pMWin!=0 );
+  csr = pMWin->csrApp;
   nPeer = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);
 
   lblNext = sqlite3VdbeMakeLabel(pParse);
   lblBrk = sqlite3VdbeMakeLabel(pParse);
 
@@ -147010,11 +148455,11 @@
       sqlite3VdbeAddOp2(v, OP_Goto, 0, lblNext);
     }
     if( addrEq ) sqlite3VdbeJumpHere(v, addrEq);
   }
 
-  windowAggStep(pParse, pMWin, csr, 0, p->regArg);
+  windowAggStep(p, pMWin, csr, 0, p->regArg);
 
   sqlite3VdbeResolveLabel(v, lblNext);
   sqlite3VdbeAddOp2(v, OP_Next, csr, addrNext);
   VdbeCoverage(v);
   sqlite3VdbeJumpHere(v, addrNext-1);
@@ -147025,10 +148470,11 @@
     sqlite3ReleaseTempRange(pParse, regPeer, nPeer);
     sqlite3ReleaseTempRange(pParse, regCPeer, nPeer);
   }
 
   windowAggFinal(p, 1);
+  VdbeModuleComment((v, "windowFullScan end"));
 }
 
 /*
 ** Invoke the sub-routine at regGosub (generated by code in select.c) to
 ** return the current row of Window.iEphCsr. If all window functions are
@@ -147199,67 +148645,147 @@
 }
 
 /*
 ** This function is called as part of generating VM programs for RANGE
 ** offset PRECEDING/FOLLOWING frame boundaries. Assuming "ASC" order for
-** the ORDER BY term in the window, it generates code equivalent to:
+** the ORDER BY term in the window, and that argument op is OP_Ge, it generates
+** code equivalent to:
 **
 **   if( csr1.peerVal + regVal >= csr2.peerVal ) goto lbl;
 **
-** A special type of arithmetic is used such that if csr.peerVal is not
-** a numeric type (real or integer), then the result of the addition is
-** a copy of csr1.peerVal.
+** The value of parameter op may also be OP_Gt or OP_Le. In these cases the
+** operator in the above pseudo-code is replaced with ">" or "<=", respectively.
+**
+** If the sort-order for the ORDER BY term in the window is DESC, then the
+** comparison is reversed. Instead of adding regVal to csr1.peerVal, it is
+** subtracted. And the comparison operator is inverted to - ">=" becomes "<=",
+** ">" becomes "<", and so on. So, with DESC sort order, if the argument op
+** is OP_Ge, the generated code is equivalent to:
+**
+**   if( csr1.peerVal - regVal <= csr2.peerVal ) goto lbl;
+**
+** A special type of arithmetic is used such that if csr1.peerVal is not
+** a numeric type (real or integer), then the result of the addition addition
+** or subtraction is a a copy of csr1.peerVal.
 */
 static void windowCodeRangeTest(
   WindowCodeArg *p,
-  int op,                          /* OP_Ge or OP_Gt */
-  int csr1,
-  int regVal,
-  int csr2,
-  int lbl
+  int op,                         /* OP_Ge, OP_Gt, or OP_Le */
+  int csr1,                       /* Cursor number for cursor 1 */
+  int regVal,                     /* Register containing non-negative number */
+  int csr2,                       /* Cursor number for cursor 2 */
+  int lbl                         /* Jump destination if condition is true */
 ){
   Parse *pParse = p->pParse;
   Vdbe *v = sqlite3GetVdbe(pParse);
-  int reg1 = sqlite3GetTempReg(pParse);
-  int reg2 = sqlite3GetTempReg(pParse);
-  int arith = OP_Add;
-  int addrGe;
-
-  int regString = ++pParse->nMem;
+  ExprList *pOrderBy = p->pMWin->pOrderBy;  /* ORDER BY clause for window */
+  int reg1 = sqlite3GetTempReg(pParse);     /* Reg. for csr1.peerVal+regVal */
+  int reg2 = sqlite3GetTempReg(pParse);     /* Reg. for csr2.peerVal */
+  int regString = ++pParse->nMem;           /* Reg. for constant value '' */
+  int arith = OP_Add;                       /* OP_Add or OP_Subtract */
+  int addrGe;                               /* Jump destination */
 
   assert( op==OP_Ge || op==OP_Gt || op==OP_Le );
-  assert( p->pMWin->pOrderBy && p->pMWin->pOrderBy->nExpr==1 );
-  if( p->pMWin->pOrderBy->a[0].sortOrder ){
+  assert( pOrderBy && pOrderBy->nExpr==1 );
+  if( pOrderBy->a[0].sortFlags & KEYINFO_ORDER_DESC ){
     switch( op ){
       case OP_Ge: op = OP_Le; break;
       case OP_Gt: op = OP_Lt; break;
       default: assert( op==OP_Le ); op = OP_Ge; break;
     }
     arith = OP_Subtract;
   }
 
+  /* Read the peer-value from each cursor into a register */
   windowReadPeerValues(p, csr1, reg1);
   windowReadPeerValues(p, csr2, reg2);
 
-  /* Check if the peer value for csr1 value is a text or blob by comparing
-  ** it to the smallest possible string - ''. If it is, jump over the
-  ** OP_Add or OP_Subtract operation and proceed directly to the comparison. */
+  VdbeModuleComment((v, "CodeRangeTest: if( R%d %s R%d %s R%d ) goto lbl",
+      reg1, (arith==OP_Add ? "+" : "-"), regVal,
+      ((op==OP_Ge) ? ">=" : (op==OP_Le) ? "<=" : (op==OP_Gt) ? ">" : "<"), reg2
+  ));
+
+  /* Register reg1 currently contains csr1.peerVal (the peer-value from csr1).
+  ** This block adds (or subtracts for DESC) the numeric value in regVal
+  ** from it. Or, if reg1 is not numeric (it is a NULL, a text value or a blob),
+  ** then leave reg1 as it is. In pseudo-code, this is implemented as:
+  **
+  **   if( reg1>='' ) goto addrGe;
+  **   reg1 = reg1 +/- regVal
+  **   addrGe:
+  **
+  ** Since all strings and blobs are greater-than-or-equal-to an empty string,
+  ** the add/subtract is skipped for these, as required. If reg1 is a NULL,
+  ** then the arithmetic is performed, but since adding or subtracting from
+  ** NULL is always NULL anyway, this case is handled as required too.  */
   sqlite3VdbeAddOp4(v, OP_String8, 0, regString, 0, "", P4_STATIC);
   addrGe = sqlite3VdbeAddOp3(v, OP_Ge, regString, 0, reg1);
   VdbeCoverage(v);
   sqlite3VdbeAddOp3(v, arith, regVal, reg1, reg1);
   sqlite3VdbeJumpHere(v, addrGe);
+
+  /* If the BIGNULL flag is set for the ORDER BY, then it is required to
+  ** consider NULL values to be larger than all other values, instead of
+  ** the usual smaller. The VDBE opcodes OP_Ge and so on do not handle this
+  ** (and adding that capability causes a performance regression), so
+  ** instead if the BIGNULL flag is set then cases where either reg1 or
+  ** reg2 are NULL are handled separately in the following block. The code
+  ** generated is equivalent to:
+  **
+  **   if( reg1 IS NULL ){
+  **     if( op==OP_Ge ) goto lbl;
+  **     if( op==OP_Gt && reg2 IS NOT NULL ) goto lbl;
+  **     if( op==OP_Le && reg2 IS NULL ) goto lbl;
+  **   }else if( reg2 IS NULL ){
+  **     if( op==OP_Le ) goto lbl;
+  **   }
+  **
+  ** Additionally, if either reg1 or reg2 are NULL but the jump to lbl is
+  ** not taken, control jumps over the comparison operator coded below this
+  ** block.  */
+  if( pOrderBy->a[0].sortFlags & KEYINFO_ORDER_BIGNULL ){
+    /* This block runs if reg1 contains a NULL. */
+    int addr = sqlite3VdbeAddOp1(v, OP_NotNull, reg1); VdbeCoverage(v);
+    switch( op ){
+      case OP_Ge:
+        sqlite3VdbeAddOp2(v, OP_Goto, 0, lbl);
+        break;
+      case OP_Gt:
+        sqlite3VdbeAddOp2(v, OP_NotNull, reg2, lbl);
+        VdbeCoverage(v);
+        break;
+      case OP_Le:
+        sqlite3VdbeAddOp2(v, OP_IsNull, reg2, lbl);
+        VdbeCoverage(v);
+        break;
+      default: assert( op==OP_Lt ); /* no-op */ break;
+    }
+    sqlite3VdbeAddOp2(v, OP_Goto, 0, sqlite3VdbeCurrentAddr(v)+3);
+
+    /* This block runs if reg1 is not NULL, but reg2 is. */
+    sqlite3VdbeJumpHere(v, addr);
+    sqlite3VdbeAddOp2(v, OP_IsNull, reg2, lbl); VdbeCoverage(v);
+    if( op==OP_Gt || op==OP_Ge ){
+      sqlite3VdbeChangeP2(v, -1, sqlite3VdbeCurrentAddr(v)+1);
+    }
+  }
+
+  /* Compare registers reg2 and reg1, taking the jump if required. Note that
+  ** control skips over this test if the BIGNULL flag is set and either
+  ** reg1 or reg2 contain a NULL value.  */
   sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1); VdbeCoverage(v);
   sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);
+
   assert( op==OP_Ge || op==OP_Gt || op==OP_Lt || op==OP_Le );
   testcase(op==OP_Ge); VdbeCoverageIf(v, op==OP_Ge);
   testcase(op==OP_Lt); VdbeCoverageIf(v, op==OP_Lt);
   testcase(op==OP_Le); VdbeCoverageIf(v, op==OP_Le);
   testcase(op==OP_Gt); VdbeCoverageIf(v, op==OP_Gt);
-
   sqlite3ReleaseTempReg(pParse, reg1);
   sqlite3ReleaseTempReg(pParse, reg2);
+
+  VdbeModuleComment((v, "CodeRangeTest: end"));
 }
 
 /*
 ** Helper function for sqlite3WindowCodeStep(). Each call to this function
 ** generates VM code for a single RETURN_ROW, AGGSTEP or AGGINVERSE
@@ -147275,13 +148801,11 @@
   int csr, reg;
   Parse *pParse = p->pParse;
   Window *pMWin = p->pMWin;
   int ret = 0;
   Vdbe *v = p->pVdbe;
-  int addrIf = 0;
   int addrContinue = 0;
-  int addrGoto = 0;
   int bPeer = (pMWin->eFrmType!=TK_ROWS);
 
   int lblDone = sqlite3VdbeMakeLabel(pParse);
   int addrNextRange = 0;
 
@@ -147310,19 +148834,38 @@
         windowCodeRangeTest(
             p, OP_Gt, p->end.csr, regCountdown, p->current.csr, lblDone
         );
       }
     }else{
-      addrIf = sqlite3VdbeAddOp3(v, OP_IfPos, regCountdown, 0, 1);
+      sqlite3VdbeAddOp3(v, OP_IfPos, regCountdown, lblDone, 1);
       VdbeCoverage(v);
     }
   }
 
   if( op==WINDOW_RETURN_ROW && pMWin->regStartRowid==0 ){
     windowAggFinal(p, 0);
   }
   addrContinue = sqlite3VdbeCurrentAddr(v);
+
+  /* If this is a (RANGE BETWEEN a FOLLOWING AND b FOLLOWING) or
+  ** (RANGE BETWEEN b PRECEDING AND a PRECEDING) frame, ensure the
+  ** start cursor does not advance past the end cursor within the
+  ** temporary table. It otherwise might, if (a>b).  */
+  if( pMWin->eStart==pMWin->eEnd && regCountdown
+   && pMWin->eFrmType==TK_RANGE && op==WINDOW_AGGINVERSE
+  ){
+    int regRowid1 = sqlite3GetTempReg(pParse);
+    int regRowid2 = sqlite3GetTempReg(pParse);
+    sqlite3VdbeAddOp2(v, OP_Rowid, p->start.csr, regRowid1);
+    sqlite3VdbeAddOp2(v, OP_Rowid, p->end.csr, regRowid2);
+    sqlite3VdbeAddOp3(v, OP_Ge, regRowid2, lblDone, regRowid1);
+    VdbeCoverage(v);
+    sqlite3ReleaseTempReg(pParse, regRowid1);
+    sqlite3ReleaseTempReg(pParse, regRowid2);
+    assert( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_FOLLOWING );
+  }
+
   switch( op ){
     case WINDOW_RETURN_ROW:
       csr = p->current.csr;
       reg = p->current.reg;
       windowReturnOneRow(p);
@@ -147333,11 +148876,11 @@
       reg = p->start.reg;
       if( pMWin->regStartRowid ){
         assert( pMWin->regEndRowid );
         sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regStartRowid, 1);
       }else{
-        windowAggStep(pParse, pMWin, csr, 1, p->regArg);
+        windowAggStep(p, pMWin, csr, 1, p->regArg);
       }
       break;
 
     default:
       assert( op==WINDOW_AGGSTEP );
@@ -147345,11 +148888,11 @@
       reg = p->end.reg;
       if( pMWin->regStartRowid ){
         assert( pMWin->regEndRowid );
         sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regEndRowid, 1);
       }else{
-        windowAggStep(pParse, pMWin, csr, 0, p->regArg);
+        windowAggStep(p, pMWin, csr, 0, p->regArg);
       }
       break;
   }
 
   if( op==p->eDelete ){
@@ -147363,11 +148906,11 @@
     ret = sqlite3VdbeAddOp0(v, OP_Goto);
   }else{
     sqlite3VdbeAddOp2(v, OP_Next, csr, sqlite3VdbeCurrentAddr(v)+1+bPeer);
     VdbeCoverage(v);
     if( bPeer ){
-      addrGoto = sqlite3VdbeAddOp0(v, OP_Goto);
+      sqlite3VdbeAddOp2(v, OP_Goto, 0, lblDone);
     }
   }
 
   if( bPeer ){
     int nReg = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);
@@ -147379,12 +148922,10 @@
 
   if( addrNextRange ){
     sqlite3VdbeAddOp2(v, OP_Goto, 0, addrNextRange);
   }
   sqlite3VdbeResolveLabel(v, lblDone);
-  if( addrGoto ) sqlite3VdbeJumpHere(v, addrGoto);
-  if( addrIf ) sqlite3VdbeJumpHere(v, addrIf);
   return ret;
 }
 
 
 /*
@@ -147396,21 +148937,24 @@
   Window *pNew = 0;
   if( ALWAYS(p) ){
     pNew = sqlite3DbMallocZero(db, sizeof(Window));
     if( pNew ){
       pNew->zName = sqlite3DbStrDup(db, p->zName);
+      pNew->zBase = sqlite3DbStrDup(db, p->zBase);
       pNew->pFilter = sqlite3ExprDup(db, p->pFilter, 0);
       pNew->pFunc = p->pFunc;
       pNew->pPartition = sqlite3ExprListDup(db, p->pPartition, 0);
       pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, 0);
       pNew->eFrmType = p->eFrmType;
       pNew->eEnd = p->eEnd;
       pNew->eStart = p->eStart;
       pNew->eExclude = p->eExclude;
+      pNew->regResult = p->regResult;
       pNew->pStart = sqlite3ExprDup(db, p->pStart, 0);
       pNew->pEnd = sqlite3ExprDup(db, p->pEnd, 0);
       pNew->pOwner = pOwner;
+      pNew->bImplicitFrame = p->bImplicitFrame;
     }
   }
   return pNew;
 }
 
@@ -147730,11 +149274,11 @@
 **       if( first row of partition ){
 **         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
 **         regEnd = <expr2>
 **         regStart = <expr1>
 **       }else{
-**         if( (csrEnd.key + regEnd) <= csrCurrent.key ){
+**         while( (csrEnd.key + regEnd) <= csrCurrent.key ){
 **           AGGSTEP
 **         }
 **         while( (csrStart.key + regStart) < csrCurrent.key ){
 **           AGGINVERSE
 **         }
@@ -147803,20 +149347,20 @@
   int iInput;                               /* To iterate through sub cols */
   int addrNe;                     /* Address of OP_Ne */
   int addrGosubFlush = 0;         /* Address of OP_Gosub to flush: */
   int addrInteger = 0;            /* Address of OP_Integer */
   int addrEmpty;                  /* Address of OP_Rewind in flush: */
-  int regStart = 0;               /* Value of <expr> PRECEDING */
-  int regEnd = 0;                 /* Value of <expr> FOLLOWING */
   int regNew;                     /* Array of registers holding new input row */
   int regRecord;                  /* regNew array in record form */
   int regRowid;                   /* Rowid for regRecord in eph table */
   int regNewPeer = 0;             /* Peer values for new row (part of regNew) */
   int regPeer = 0;                /* Peer values for current row */
   int regFlushPart = 0;           /* Register for "Gosub flush_partition" */
   WindowCodeArg s;                /* Context object for sub-routines */
   int lblWhereEnd;                /* Label just before sqlite3WhereEnd() code */
+  int regStart = 0;               /* Value of <expr> PRECEDING */
+  int regEnd = 0;                 /* Value of <expr> FOLLOWING */
 
   assert( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_CURRENT
        || pMWin->eStart==TK_FOLLOWING || pMWin->eStart==TK_UNBOUNDED
   );
   assert( pMWin->eEnd==TK_FOLLOWING || pMWin->eEnd==TK_CURRENT
@@ -147943,18 +149487,18 @@
   /* This block is run for the first row of each partition */
   s.regArg = windowInitAccum(pParse, pMWin);
 
   if( regStart ){
     sqlite3ExprCode(pParse, pMWin->pStart, regStart);
-    windowCheckValue(pParse, regStart, 0 + (pMWin->eFrmType==TK_RANGE ? 3 : 0));
+    windowCheckValue(pParse, regStart, 0 + (pMWin->eFrmType==TK_RANGE?3:0));
   }
   if( regEnd ){
     sqlite3ExprCode(pParse, pMWin->pEnd, regEnd);
-    windowCheckValue(pParse, regEnd, 1 + (pMWin->eFrmType==TK_RANGE ? 3 : 0));
+    windowCheckValue(pParse, regEnd, 1 + (pMWin->eFrmType==TK_RANGE?3:0));
   }
 
-  if( pMWin->eStart==pMWin->eEnd && regStart ){
+  if( pMWin->eFrmType!=TK_RANGE && pMWin->eStart==pMWin->eEnd && regStart ){
     int op = ((pMWin->eStart==TK_FOLLOWING) ? OP_Ge : OP_Le);
     int addrGe = sqlite3VdbeAddOp3(v, op, regStart, 0, regEnd);
     VdbeCoverageNeverNullIf(v, op==OP_Ge); /* NeverNull because bound <expr> */
     VdbeCoverageNeverNullIf(v, op==OP_Le); /*   values previously checked */
     windowAggFinal(&s, 0);
@@ -148210,10 +149754,11 @@
   ** For a compound SELECT statement, make sure p->pPrior->pNext==p for
   ** all elements in the list.  And make sure list length does not exceed
   ** SQLITE_LIMIT_COMPOUND_SELECT.
   */
   static void parserDoubleLinkSelect(Parse *pParse, Select *p){
+    assert( p!=0 );
     if( p->pPrior ){
       Select *pNext = 0, *pLoop;
       int mxSelect, cnt = 0;
       for(pLoop=p; pLoop; pNext=pLoop, pLoop=pLoop->pPrior, cnt++){
         pLoop->pNext = pNext;
@@ -148236,11 +149781,11 @@
   static Expr *tokenExpr(Parse *pParse, int op, Token t){
     Expr *p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr)+t.n+1);
     if( p ){
       /* memset(p, 0, sizeof(Expr)); */
       p->op = (u8)op;
-      p->affinity = 0;
+      p->affExpr = 0;
       p->flags = EP_Leaf;
       p->iAgg = -1;
       p->pLeft = p->pRight = 0;
       p->x.pList = 0;
       p->pAggInfo = 0;
@@ -148363,32 +149908,32 @@
 #ifndef INTERFACE
 # define INTERFACE 1
 #endif
 /************* Begin control #defines *****************************************/
 #define YYCODETYPE unsigned short int
-#define YYNOCODE 301
+#define YYNOCODE 307
 #define YYACTIONTYPE unsigned short int
-#define YYWILDCARD 95
+#define YYWILDCARD 98
 #define sqlite3ParserTOKENTYPE Token
 typedef union {
   int yyinit;
   sqlite3ParserTOKENTYPE yy0;
-  With* yy59;
-  IdList* yy62;
-  struct TrigEvent yy90;
-  Upsert* yy136;
-  struct FrameBound yy201;
-  u8 yy238;
-  const char* yy294;
-  Window* yy295;
-  struct {int value; int mask;} yy355;
-  ExprList* yy434;
-  TriggerStep* yy455;
-  Select* yy457;
-  SrcList* yy483;
-  int yy494;
-  Expr* yy524;
+  const char* yy8;
+  Select* yy25;
+  int yy32;
+  Expr* yy46;
+  struct FrameBound yy57;
+  u8 yy118;
+  ExprList* yy138;
+  Upsert* yy288;
+  With* yy297;
+  IdList* yy406;
+  Window* yy455;
+  struct {int value; int mask;} yy495;
+  TriggerStep* yy527;
+  struct TrigEvent yy572;
+  SrcList* yy609;
 } YYMINORTYPE;
 #ifndef YYSTACKDEPTH
 #define YYSTACKDEPTH 100
 #endif
 #define sqlite3ParserARG_SDECL
@@ -148400,21 +149945,21 @@
 #define sqlite3ParserCTX_PDECL ,Parse *pParse
 #define sqlite3ParserCTX_PARAM ,pParse
 #define sqlite3ParserCTX_FETCH Parse *pParse=yypParser->pParse;
 #define sqlite3ParserCTX_STORE yypParser->pParse=pParse;
 #define YYFALLBACK 1
-#define YYNSTATE             541
-#define YYNRULE              375
-#define YYNTOKEN             176
-#define YY_MAX_SHIFT         540
-#define YY_MIN_SHIFTREDUCE   784
-#define YY_MAX_SHIFTREDUCE   1158
-#define YY_ERROR_ACTION      1159
-#define YY_ACCEPT_ACTION     1160
-#define YY_NO_ACTION         1161
-#define YY_MIN_REDUCE        1162
-#define YY_MAX_REDUCE        1536
+#define YYNSTATE             543
+#define YYNRULE              381
+#define YYNTOKEN             179
+#define YY_MAX_SHIFT         542
+#define YY_MIN_SHIFTREDUCE   790
+#define YY_MAX_SHIFTREDUCE   1170
+#define YY_ERROR_ACTION      1171
+#define YY_ACCEPT_ACTION     1172
+#define YY_NO_ACTION         1173
+#define YY_MIN_REDUCE        1174
+#define YY_MAX_REDUCE        1554
 /************* End control #defines *******************************************/
 #define YY_NLOOKAHEAD ((int)(sizeof(yy_lookahead)/sizeof(yy_lookahead[0])))
 
 /* Define the yytestcase() macro to be a no-op if is not already defined
 ** otherwise.
@@ -148477,607 +150022,577 @@
 **  yy_reduce_ofst[]   For each state, the offset into yy_action for
 **                     shifting non-terminals after a reduce.
 **  yy_default[]       Default action for each state.
 **
 *********** Begin parsing tables **********************************************/
-#define YY_ACTTAB_COUNT (2142)
+#define YY_ACTTAB_COUNT (1913)
 static const YYACTIONTYPE yy_action[] = {
- /*     0 */   535, 1323,  112,  109,  209,  112,  109,  209, 1160,    1,
- /*    10 */     1,  540,    2, 1164,  535, 1292, 1228, 1207,  289,  384,
- /*    20 */   134,   42,   42, 1427,  382, 1228,    9, 1241,  242,  492,
- /*    30 */  1291,  915,  373,  379, 1026,   70,   70,  427, 1026,  916,
- /*    40 */   529,  529,  529,  119,  120,  110, 1136, 1136,  981,  984,
- /*    50 */   974,  974,  117,  117,  118,  118,  118,  118,  380,  264,
- /*    60 */   264,  264,  264, 1134,  264,  264,  112,  109,  209,  397,
- /*    70 */   454,  517,  532,  491,  532, 1233, 1233,  532,  239,  206,
- /*    80 */   493,  112,  109,  209,  464,  219,  118,  118,  118,  118,
- /*    90 */   111,  393,  440,  444,   16,   16,  116,  116,  116,  116,
- /*   100 */   115,  115,  114,  114,  114,  113,  415,  971,  971,  982,
- /*   110 */   985,  235, 1463,  351, 1134,  419,  384,  116,  116,  116,
- /*   120 */   116,  115,  115,  114,  114,  114,  113,  415,  116,  116,
- /*   130 */   116,  116,  115,  115,  114,  114,  114,  113,  415,  961,
- /*   140 */   119,  120,  110, 1136, 1136,  981,  984,  974,  974,  117,
- /*   150 */   117,  118,  118,  118,  118,  952,  415,  941,  298,  951,
- /*   160 */   941, 1480,  540,    2, 1164, 1115,  535, 1458,  160,  289,
- /*   170 */     6,  134, 1504,  389,  406,  975,  338, 1024, 1241,  337,
- /*   180 */  1089, 1476, 1089,  118,  118,  118,  118,   42,   42,  329,
- /*   190 */   951,  951,  953,  116,  116,  116,  116,  115,  115,  114,
- /*   200 */   114,  114,  113,  415,  311,  430,  299,  311,  881,  160,
- /*   210 */   264,  264,  401,  384,  324, 1115, 1116, 1117,  288,  526,
- /*   220 */    96,  159, 1441,  532,  141,  116,  116,  116,  116,  115,
- /*   230 */   115,  114,  114,  114,  113,  415,  219,  119,  120,  110,
- /*   240 */  1136, 1136,  981,  984,  974,  974,  117,  117,  118,  118,
- /*   250 */   118,  118,  115,  115,  114,  114,  114,  113,  415,  288,
- /*   260 */   526,  403,  533,  121,  870,  870,  419,  250,  267,  336,
- /*   270 */   475,  331,  474,  236,  160,  319, 1084,  322, 1465,  329,
- /*   280 */   350,   12,  535,  384,  502, 1115, 1084,  435,  312, 1084,
- /*   290 */   116,  116,  116,  116,  115,  115,  114,  114,  114,  113,
- /*   300 */   415,  535,  836,   42,   42,  138,  426,  119,  120,  110,
- /*   310 */  1136, 1136,  981,  984,  974,  974,  117,  117,  118,  118,
- /*   320 */   118,  118,   70,   70,  288,  526,  412,  411,  480, 1457,
- /*   330 */   335,   79,    6,  473, 1140, 1115, 1116, 1117,  501, 1142,
- /*   340 */   334,  837,  811, 1484,  512, 1164,  534, 1141,  123,  187,
- /*   350 */   289,  384,  134,  448,  434, 1115,   80,  349,  498, 1241,
- /*   360 */   116,  116,  116,  116,  115,  115,  114,  114,  114,  113,
- /*   370 */   415, 1143, 1115, 1143,  459,  119,  120,  110, 1136, 1136,
- /*   380 */   981,  984,  974,  974,  117,  117,  118,  118,  118,  118,
- /*   390 */   404,  264,  264,  811, 1463,  506,  368, 1156,  535,  114,
- /*   400 */   114,  114,  113,  415,  532, 1115, 1116, 1117,  231,  518,
- /*   410 */  1500,  472,  469,  468,  175,  497,  422,  219, 1202,   70,
- /*   420 */    70,  467, 1115, 1116, 1117,  176,  201,  200,  116,  116,
- /*   430 */   116,  116,  115,  115,  114,  114,  114,  113,  415,  535,
- /*   440 */  1115,  264,  264,  435,  312, 1115,  273,  419,  384,  513,
- /*   450 */  1450, 1115,  326, 1084,  532,  517,   82, 1084,  167,  388,
- /*   460 */    69,   69, 1115, 1084,  519,  509, 1084, 1084,   12, 1157,
- /*   470 */  1084,  420,  119,  120,  110, 1136, 1136,  981,  984,  974,
- /*   480 */   974,  117,  117,  118,  118,  118,  118,  258,  258,  535,
- /*   490 */  1115, 1116, 1117, 1045,  535, 1115, 1116, 1117, 1323,  535,
- /*   500 */   532, 1115, 1116, 1117,  296,  483, 1211,  818, 1046,  448,
- /*   510 */    70,   70, 1115, 1116, 1117,   50,   50,  448,  356,  500,
- /*   520 */    70,   70,  207, 1047,   32,  116,  116,  116,  116,  115,
- /*   530 */   115,  114,  114,  114,  113,  415,  453,  264,  264, 1115,
- /*   540 */   450,  449,  961,  508,  856,  384,  517,    5,  900,  822,
- /*   550 */   532,  484,  181, 1115,  857,  516,  517,  818,  952,  507,
- /*   560 */     3, 1115,  951, 1231, 1231,  482,  398, 1115, 1095,  119,
- /*   570 */   120,  110, 1136, 1136,  981,  984,  974,  974,  117,  117,
- /*   580 */   118,  118,  118,  118, 1115,  535,  238, 1115, 1391, 1115,
- /*   590 */  1116, 1117,  159,  951,  951,  953,  231, 1115,  259,  472,
- /*   600 */   469,  468,  310, 1115, 1116, 1117,   13,   13,  297,  467,
- /*   610 */   276, 1115, 1116, 1117,  412,  411, 1095, 1115, 1116, 1117,
- /*   620 */   395,  355,  116,  116,  116,  116,  115,  115,  114,  114,
- /*   630 */   114,  113,  415,  208, 1115, 1116, 1117, 1115, 1116, 1117,
- /*   640 */   264,  264,  384,  337,  902,  393,  815, 1115, 1116, 1117,
- /*   650 */   413,  413,  413,  532,  112,  109,  209,  309,  900, 1143,
- /*   660 */   535, 1143,  535,  393,  901, 1210,  119,  120,  110, 1136,
- /*   670 */  1136,  981,  984,  974,  974,  117,  117,  118,  118,  118,
- /*   680 */   118,   13,   13,   13,   13,  265,  265,  535,  143,  264,
- /*   690 */   264,  288,  526,  535, 1119,  400,  535,  402,  532,  510,
- /*   700 */  1457,  512,  532,    6,  113,  415, 1067, 1530,   70,   70,
- /*   710 */  1530,  535,  271,  535,   70,   70,  535,   13,   13,  116,
- /*   720 */   116,  116,  116,  115,  115,  114,  114,  114,  113,  415,
- /*   730 */   272,  277,   13,   13,   13,   13,  535,   13,   13,  384,
- /*   740 */   535,  304,  425, 1100,  284, 1119,  184,  801,  185,  338,
- /*   750 */   285,  514, 1532,  369, 1239, 1438, 1182,   70,   70,  425,
- /*   760 */   424,   70,   70,  119,  120,  110, 1136, 1136,  981,  984,
- /*   770 */   974,  974,  117,  117,  118,  118,  118,  118,  190, 1065,
- /*   780 */  1067, 1531,  442,  107, 1531,  408,  264,  264,  264,  264,
- /*   790 */   383, 1396,  261,  410,   95,  900,  485,  414,  421,  532,
- /*   800 */  1045,  532,  301, 1133,  303,  488,  433, 1451, 1396, 1398,
- /*   810 */   278,  535,  278,  520, 1435, 1046,  116,  116,  116,  116,
- /*   820 */   115,  115,  114,  114,  114,  113,  415,  425,  264,  264,
- /*   830 */  1047,  190,   54,   54,  535,  291,  384,  264,  264,  362,
- /*   840 */   962,  532, 1004,  376, 1084,  264,  264, 1029, 1029,  456,
- /*   850 */   532,  523,  270, 1065, 1084,   55,   55, 1084,  532,  442,
- /*   860 */   119,  120,  110, 1136, 1136,  981,  984,  974,  974,  117,
- /*   870 */   117,  118,  118,  118,  118,  535, 1396,  190,  302, 1383,
- /*   880 */   208,  535,  789,  790,  791,  535,  515,  535, 1323,  371,
- /*   890 */   337,  234,  233,  232,  459,  515,   15,   15,  459,  477,
- /*   900 */   459,  459,   44,   44,  136,  900,   56,   56,   57,   57,
- /*   910 */  1185,  390,  197,  116,  116,  116,  116,  115,  115,  114,
- /*   920 */   114,  114,  113,  415,  535,  876,  535,  442,  535,  274,
- /*   930 */   875, 1323,  357,  384,  353,  140, 1426,  946, 1455, 1323,
- /*   940 */  1390,    6, 1240, 1236,  292,   58,   58,   59,   59,   60,
- /*   950 */    60,  535, 1456,  384,  535,    6,  399,  119,  120,  110,
- /*   960 */  1136, 1136,  981,  984,  974,  974,  117,  117,  118,  118,
- /*   970 */   118,  118,   61,   61,  535,   45,   45,  119,  120,  110,
- /*   980 */  1136, 1136,  981,  984,  974,  974,  117,  117,  118,  118,
- /*   990 */   118,  118, 1477,  479,  202,   46,   46,  275,   95,  455,
- /*  1000 */   535,  212,  535,  337,  535, 1454,  535,  409,    6,  242,
- /*  1010 */   116,  116,  116,  116,  115,  115,  114,  114,  114,  113,
- /*  1020 */   415,   48,   48,   49,   49,   62,   62,   63,   63,  535,
- /*  1030 */   116,  116,  116,  116,  115,  115,  114,  114,  114,  113,
- /*  1040 */   415,  535,  459,  535, 1134,  535, 1151,  535,  142,  535,
- /*  1050 */    64,   64,  535, 1338,  535,  494,  535,  446,  535, 1264,
- /*  1060 */   535, 1337,   14,   14,   65,   65,  125,  125,   66,   66,
- /*  1070 */    51,   51,  535,   67,   67,   68,   68,   52,   52,  147,
- /*  1080 */   147,  148,  148, 1453,  317,   98,    6,  535, 1245,  481,
- /*  1090 */   535,  827,  535,   75,   75, 1134,  102,  481,  100,  535,
- /*  1100 */   532,  535,  368, 1066, 1503,  384,  535,  845,   53,   53,
- /*  1110 */    93,   71,   71,  126,  126,  295,  528,  390,  288,  526,
- /*  1120 */    72,   72,  127,  127,  139,  384,   38,  128,  128,  119,
- /*  1130 */   120,  110, 1136, 1136,  981,  984,  974,  974,  117,  117,
- /*  1140 */   118,  118,  118,  118,  535,  495,  535,  447,  535,  119,
- /*  1150 */   120,  110, 1136, 1136,  981,  984,  974,  974,  117,  117,
- /*  1160 */   118,  118,  118,  118,  235,  124,  124,  146,  146,  145,
- /*  1170 */   145,  287,  535, 1277,  535, 1157,  535,  391,  161,  263,
- /*  1180 */   206,  381,  116,  116,  116,  116,  115,  115,  114,  114,
- /*  1190 */   114,  113,  415,  132,  132,  131,  131,  129,  129,  535,
- /*  1200 */    30,  535,  116,  116,  116,  116,  115,  115,  114,  114,
- /*  1210 */   114,  113,  415,  535,  216, 1062, 1276,  535,  370,  535,
- /*  1220 */   130,  130,   74,   74,  535,  915,  389,  876,   17,  437,
- /*  1230 */   429,   31,  875,  916,   76,   76,  266,  101,   73,   73,
- /*  1240 */    43,   43,  835,  834,  308,   47,   47,   95,  825,  943,
- /*  1250 */   441,  938,  241,  241,  305,  443,  313,  384,  241,   95,
- /*  1260 */   842,  843,  193,  465, 1209,  327,  237,  436,   95, 1011,
- /*  1270 */  1007,  909,  873,  237,  241,  107, 1023,  384, 1023,  955,
- /*  1280 */  1415,  119,  120,  110, 1136, 1136,  981,  984,  974,  974,
- /*  1290 */   117,  117,  118,  118,  118,  118, 1022,  809, 1022,  825,
- /*  1300 */   137,  119,  108,  110, 1136, 1136,  981,  984,  974,  974,
- /*  1310 */   117,  117,  118,  118,  118,  118,  874, 1414,  451,  107,
- /*  1320 */  1011,  314, 1273,  318,  218,  321,  323,  325, 1224, 1208,
- /*  1330 */   955,  330,  339,  340,  116,  116,  116,  116,  115,  115,
- /*  1340 */   114,  114,  114,  113,  415, 1285, 1322, 1260, 1493, 1470,
- /*  1350 */  1271,  283,  521, 1328,  116,  116,  116,  116,  115,  115,
- /*  1360 */   114,  114,  114,  113,  415, 1191, 1184, 1173, 1172, 1174,
- /*  1370 */   522, 1487,  211,  460,  384,  256,  199,  367, 1257,  342,
- /*  1380 */   195,  470,  307,  344,   11,  333,  525,  445, 1307, 1315,
- /*  1390 */   375,  203, 1207, 1151,  384,  346, 1387,  188,  360,  120,
- /*  1400 */   110, 1136, 1136,  981,  984,  974,  974,  117,  117,  118,
- /*  1410 */   118,  118,  118, 1386,  428, 1490,  245,  300,  348, 1148,
- /*  1420 */   110, 1136, 1136,  981,  984,  974,  974,  117,  117,  118,
- /*  1430 */   118,  118,  118,  189,  198, 1434, 1432,   78,   81,  163,
- /*  1440 */    82,  392,  439, 1392,  173,  105,  527,   35,    4,  157,
- /*  1450 */  1312,  116,  116,  116,  116,  115,  115,  114,  114,  114,
- /*  1460 */   113,  415,  530,  165,   93, 1304,  431,  432,  168,  463,
- /*  1470 */   221,  116,  116,  116,  116,  115,  115,  114,  114,  114,
- /*  1480 */   113,  415,  169,  452,  170,  416,  171,  374,  372,  438,
- /*  1490 */    36, 1318,  177,  225, 1381,   87,  458,  524, 1403,  316,
- /*  1500 */   257,  105,  527,  227,    4,  182,  461,  160,  320,  228,
- /*  1510 */   377, 1175,  476,  229, 1227, 1226,  405, 1225,  530, 1218,
- /*  1520 */   961,  378, 1199, 1198,  827,  332,  103,  103, 1197,  407,
- /*  1530 */     8, 1217, 1502,  104,  487,  416,  537,  536,  281,  282,
- /*  1540 */   951,  416,  490, 1268,  496,   92,  341,  243, 1269,  343,
- /*  1550 */   244, 1267,  122,  524,  345, 1461,  515,  288,  526,   10,
- /*  1560 */   354, 1266, 1460,  352,  504, 1250,   99, 1367,   94,  503,
- /*  1570 */   499,  951,  951,  953,  954,   27,  961,  347, 1249,  194,
- /*  1580 */   251,  358,  103,  103,  359, 1181,   34,  538, 1110,  104,
- /*  1590 */   255,  416,  537,  536,  286,  252,  951,  254,  539,  149,
- /*  1600 */  1170, 1419, 1165, 1420, 1418,  150, 1417,  135,  279,  785,
- /*  1610 */   151,  417, 1195,  196,  290,  210,  386, 1194,  269,  387,
- /*  1620 */   162, 1021,  133,   77, 1192, 1019,  935,  951,  951,  953,
- /*  1630 */   954,   27, 1479, 1104,  418,  164,  153,  268,  217,  166,
- /*  1640 */   859,  306,  366,  366,  365,  253,  363,  220, 1035,  798,
- /*  1650 */   172,  939,  105,  527,  155,    4,  394,  174,  396,  156,
- /*  1660 */    83, 1038,  213,   84,  294,   85,   86,  223,  222,  530,
- /*  1670 */  1034,  144,  293,   18,  224,  315,  241, 1027, 1145,  178,
- /*  1680 */   457,  226,  179,   37,  800,  334,  462,  230,  328,  466,
- /*  1690 */   180,  471,  416,   88,   19,   20,   89,  280,  838,  158,
- /*  1700 */   191,   90,  215,  478,  524, 1097,  204,  192,  987,   91,
- /*  1710 */   152, 1070,   39,  154, 1071,  504,  486,   40,  489,  205,
- /*  1720 */   505,  260,  105,  527,  214,    4,  908,  961,  262,  183,
- /*  1730 */   240,   21,  903,  103,  103,  107,   22, 1086,   23,  530,
- /*  1740 */   104, 1088,  416,  537,  536,   24, 1093,  951,   25, 1074,
- /*  1750 */  1090, 1094,    7,   33,  511,  186,   26, 1002,  385,   95,
- /*  1760 */   988,  986,  416,  288,  526,  990, 1044,  246, 1043,  247,
- /*  1770 */   991,   28,   41,  106,  524,  956,  810,   29,  951,  951,
- /*  1780 */   953,  954,   27,  531,  361,  504,  423,  248,  869,  249,
- /*  1790 */   503, 1495,  364, 1105, 1161, 1494, 1161,  961, 1161, 1161,
- /*  1800 */  1161, 1161, 1161,  103,  103, 1161, 1161, 1161, 1161, 1161,
- /*  1810 */   104, 1161,  416,  537,  536, 1104,  418,  951, 1161,  268,
- /*  1820 */  1161, 1161, 1161, 1161,  366,  366,  365,  253,  363, 1161,
- /*  1830 */  1161,  798, 1161, 1161, 1161, 1161,  105,  527, 1161,    4,
- /*  1840 */  1161, 1161, 1161, 1161,  213, 1161,  294, 1161,  951,  951,
- /*  1850 */   953,  954,   27,  530,  293, 1161, 1161, 1161, 1161, 1161,
- /*  1860 */  1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161,
- /*  1870 */  1161, 1161, 1161, 1161, 1161, 1161,  416, 1161, 1161, 1161,
- /*  1880 */  1161, 1161, 1161, 1161,  215, 1161, 1161, 1161,  524, 1161,
- /*  1890 */  1161, 1161,  152, 1161, 1161,  154,  105,  527, 1161,    4,
- /*  1900 */  1161, 1161, 1161, 1161, 1161, 1161,  214, 1161, 1161, 1161,
- /*  1910 */  1161,  961, 1161,  530, 1161, 1161, 1161,  103,  103,  880,
- /*  1920 */  1161, 1161, 1161, 1161,  104, 1161,  416,  537,  536, 1161,
- /*  1930 */  1161,  951, 1161, 1161, 1161, 1161,  416, 1161, 1161, 1161,
- /*  1940 */   385, 1161, 1161, 1161, 1161,  288,  526, 1161,  524, 1161,
- /*  1950 */  1161, 1161, 1161, 1161, 1161, 1161,   97,  527, 1161,    4,
- /*  1960 */  1161, 1161,  951,  951,  953,  954,   27, 1161,  423, 1161,
- /*  1970 */  1161,  961, 1161,  530, 1161, 1161, 1161,  103,  103, 1161,
- /*  1980 */  1161, 1161, 1161, 1161,  104, 1161,  416,  537,  536, 1161,
- /*  1990 */  1161,  951,  268, 1161, 1161, 1161,  416,  366,  366,  365,
- /*  2000 */   253,  363, 1161, 1161,  798, 1161, 1161, 1161,  524, 1161,
- /*  2010 */  1161, 1161, 1161, 1161, 1161, 1161, 1161,  213, 1161,  294,
- /*  2020 */  1161, 1161,  951,  951,  953,  954,   27,  293, 1161, 1161,
- /*  2030 */  1161,  961, 1161, 1161, 1161, 1161, 1161,  103,  103, 1161,
- /*  2040 */  1161, 1161, 1161, 1161,  104, 1161,  416,  537,  536, 1161,
- /*  2050 */  1161,  951, 1161, 1161, 1161, 1161, 1161,  215, 1161, 1161,
- /*  2060 */  1161, 1161, 1161, 1161, 1161,  152, 1161, 1161,  154, 1161,
- /*  2070 */  1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161,  214,
- /*  2080 */  1161, 1161,  951,  951,  953,  954,   27, 1161, 1161, 1161,
- /*  2090 */  1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161,
- /*  2100 */  1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161,
- /*  2110 */  1161, 1161, 1161,  385, 1161, 1161, 1161, 1161,  288,  526,
- /*  2120 */  1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161,
- /*  2130 */  1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161, 1161,
- /*  2140 */  1161,  423,
+ /*     0 */   537,  339,  537, 1241, 1220,  537,   12,  537,  112,  109,
+ /*    10 */   209,  537, 1241,  537, 1205,  462,  112,  109,  209,  386,
+ /*    20 */   338,  462,   42,   42,   42,   42,  445,   42,   42,   70,
+ /*    30 */    70,  922, 1208,   70,   70,   70,   70, 1443,  403,  923,
+ /*    40 */   531,  531,  531,  119,  120,  110, 1148, 1148,  991,  994,
+ /*    50 */   984,  984,  117,  117,  118,  118,  118,  118,  425,  386,
+ /*    60 */  1498,  542,    2, 1176, 1442,  519,  141, 1518,  289,  519,
+ /*    70 */   134,  519,   95,  259,  495, 1215,  189, 1254,  518,  494,
+ /*    80 */   484,  437,  296,  119,  120,  110, 1148, 1148,  991,  994,
+ /*    90 */   984,  984,  117,  117,  118,  118,  118,  118,  270,  116,
+ /*   100 */   116,  116,  116,  115,  115,  114,  114,  114,  113,  418,
+ /*   110 */   264,  264,  264,  264,  423, 1479,  352, 1481,  123,  351,
+ /*   120 */  1479,  508, 1094,  534, 1034,  534, 1099,  386, 1099,  239,
+ /*   130 */   206,  112,  109,  209,   96, 1094,  376,  219, 1094,  116,
+ /*   140 */   116,  116,  116,  115,  115,  114,  114,  114,  113,  418,
+ /*   150 */   480,  119,  120,  110, 1148, 1148,  991,  994,  984,  984,
+ /*   160 */   117,  117,  118,  118,  118,  118,  353,  422, 1407,  264,
+ /*   170 */   264,  114,  114,  114,  113,  418,  883,  121,  416,  416,
+ /*   180 */   416,  882,  534,  116,  116,  116,  116,  115,  115,  114,
+ /*   190 */   114,  114,  113,  418,  212,  415,  414,  386,  443,  383,
+ /*   200 */   382,  118,  118,  118,  118,  111,  177,  116,  116,  116,
+ /*   210 */   116,  115,  115,  114,  114,  114,  113,  418,  112,  109,
+ /*   220 */   209,  119,  120,  110, 1148, 1148,  991,  994,  984,  984,
+ /*   230 */   117,  117,  118,  118,  118,  118,  386,  438,  312, 1163,
+ /*   240 */  1155,   80, 1155, 1127,  514,   79,  116,  116,  116,  116,
+ /*   250 */   115,  115,  114,  114,  114,  113,  418,  514,  428,  418,
+ /*   260 */   119,  120,  110, 1148, 1148,  991,  994,  984,  984,  117,
+ /*   270 */   117,  118,  118,  118,  118,  428,  427,  116,  116,  116,
+ /*   280 */   116,  115,  115,  114,  114,  114,  113,  418,  115,  115,
+ /*   290 */   114,  114,  114,  113,  418, 1127, 1127, 1128, 1129, 1094,
+ /*   300 */   258,  258,  192,  386,  408,  371, 1168,  326,  118,  118,
+ /*   310 */   118,  118, 1094,  534,  374, 1094,  116,  116,  116,  116,
+ /*   320 */   115,  115,  114,  114,  114,  113,  418,  119,  120,  110,
+ /*   330 */  1148, 1148,  991,  994,  984,  984,  117,  117,  118,  118,
+ /*   340 */   118,  118,  386,  354,  445,  428,  829,  238, 1127, 1128,
+ /*   350 */  1129,  515, 1466,  116,  116,  116,  116,  115,  115,  114,
+ /*   360 */   114,  114,  113,  418, 1127, 1467,  119,  120,  110, 1148,
+ /*   370 */  1148,  991,  994,  984,  984,  117,  117,  118,  118,  118,
+ /*   380 */   118, 1169,   82,  116,  116,  116,  116,  115,  115,  114,
+ /*   390 */   114,  114,  113,  418,  405,  112,  109,  209,  161,  445,
+ /*   400 */   250,  267,  336,  478,  331,  477,  236,  951, 1127,  386,
+ /*   410 */   888, 1521,  329,  822,  852,  162,  274, 1127, 1128, 1129,
+ /*   420 */   338,  169,  116,  116,  116,  116,  115,  115,  114,  114,
+ /*   430 */   114,  113,  418,  119,  120,  110, 1148, 1148,  991,  994,
+ /*   440 */   984,  984,  117,  117,  118,  118,  118,  118,  386,  438,
+ /*   450 */   312, 1502, 1112, 1176,  161,  288,  528,  311,  289,  883,
+ /*   460 */   134, 1127, 1128, 1129,  882,  537,  143, 1254,  288,  528,
+ /*   470 */   297,  275,  119,  120,  110, 1148, 1148,  991,  994,  984,
+ /*   480 */   984,  117,  117,  118,  118,  118,  118,   70,   70,  116,
+ /*   490 */   116,  116,  116,  115,  115,  114,  114,  114,  113,  418,
+ /*   500 */   264,  264,   12,  264,  264,  395, 1127,  483, 1473, 1094,
+ /*   510 */   204,  482,    6,  534, 1258,  386,  534, 1474,  825,  972,
+ /*   520 */   504,    6, 1094,  500,   95, 1094,  534,  219,  116,  116,
+ /*   530 */   116,  116,  115,  115,  114,  114,  114,  113,  418,  119,
+ /*   540 */   120,  110, 1148, 1148,  991,  994,  984,  984,  117,  117,
+ /*   550 */   118,  118,  118,  118,  386, 1339,  971,  422,  956, 1127,
+ /*   560 */  1128, 1129,  231,  512, 1473,  475,  472,  471,    6,  113,
+ /*   570 */   418,  825,  962,  298,  503,  470,  961,  452,  119,  120,
+ /*   580 */   110, 1148, 1148,  991,  994,  984,  984,  117,  117,  118,
+ /*   590 */   118,  118,  118,  395,  537,  116,  116,  116,  116,  115,
+ /*   600 */   115,  114,  114,  114,  113,  418,  202,  961,  961,  963,
+ /*   610 */   231,  971, 1127,  475,  472,  471,   13,   13,  951, 1127,
+ /*   620 */   834,  386, 1207,  470,  399,  183,  447,  962,  462,  162,
+ /*   630 */   397,  961, 1246, 1246,  116,  116,  116,  116,  115,  115,
+ /*   640 */   114,  114,  114,  113,  418,  119,  120,  110, 1148, 1148,
+ /*   650 */   991,  994,  984,  984,  117,  117,  118,  118,  118,  118,
+ /*   660 */   386,  271,  961,  961,  963, 1127, 1128, 1129,  311,  433,
+ /*   670 */   299, 1406, 1127, 1128, 1129,  178, 1471,  138,  162,   32,
+ /*   680 */     6, 1127,  288,  528,  119,  120,  110, 1148, 1148,  991,
+ /*   690 */   994,  984,  984,  117,  117,  118,  118,  118,  118,  909,
+ /*   700 */   390,  116,  116,  116,  116,  115,  115,  114,  114,  114,
+ /*   710 */   113,  418, 1127,  429,  817,  537, 1127,  265,  265,  981,
+ /*   720 */   981,  992,  995,  324, 1055,   93,  520,    5,  338,  537,
+ /*   730 */   534,  288,  528, 1522, 1127, 1128, 1129,   70,   70, 1056,
+ /*   740 */   116,  116,  116,  116,  115,  115,  114,  114,  114,  113,
+ /*   750 */   418,   70,   70, 1495, 1057,  537,   98, 1244, 1244,  264,
+ /*   760 */   264,  908,  371, 1076, 1127, 1127, 1128, 1129,  817, 1127,
+ /*   770 */  1128, 1129,  534,  519,  140,  863,  386,   13,   13,  456,
+ /*   780 */   192,  193,  521,  453,  319,  864,  322,  284,  365,  430,
+ /*   790 */   985,  402,  379, 1077, 1548,  101,  386, 1548,    3,  395,
+ /*   800 */   119,  120,  110, 1148, 1148,  991,  994,  984,  984,  117,
+ /*   810 */   117,  118,  118,  118,  118,  386,  451, 1127, 1128, 1129,
+ /*   820 */   119,  120,  110, 1148, 1148,  991,  994,  984,  984,  117,
+ /*   830 */   117,  118,  118,  118,  118, 1127, 1354, 1412, 1169,  119,
+ /*   840 */   108,  110, 1148, 1148,  991,  994,  984,  984,  117,  117,
+ /*   850 */   118,  118,  118,  118, 1412, 1414,  116,  116,  116,  116,
+ /*   860 */   115,  115,  114,  114,  114,  113,  418,  272,  535, 1075,
+ /*   870 */   877,  877,  337, 1492,  309,  462,  116,  116,  116,  116,
+ /*   880 */   115,  115,  114,  114,  114,  113,  418,  537, 1127, 1128,
+ /*   890 */  1129,  537,  360,  537,  356,  116,  116,  116,  116,  115,
+ /*   900 */   115,  114,  114,  114,  113,  418,  386,  264,  264,   13,
+ /*   910 */    13,  273, 1127,   13,   13,   13,   13,  304, 1253,  386,
+ /*   920 */   534, 1077, 1549,  404, 1412, 1549,  496,  277,  451,  186,
+ /*   930 */  1252,  120,  110, 1148, 1148,  991,  994,  984,  984,  117,
+ /*   940 */   117,  118,  118,  118,  118,  110, 1148, 1148,  991,  994,
+ /*   950 */   984,  984,  117,  117,  118,  118,  118,  118,  105,  529,
+ /*   960 */   537,    4, 1339,  264,  264, 1127, 1128, 1129, 1039, 1039,
+ /*   970 */   459,  795,  796,  797,  536,  532,  534,  242,  301,  807,
+ /*   980 */   303,  462,   69,   69,  451, 1353,  116,  116,  116,  116,
+ /*   990 */   115,  115,  114,  114,  114,  113,  418, 1075,  419,  116,
+ /*  1000 */   116,  116,  116,  115,  115,  114,  114,  114,  113,  418,
+ /*  1010 */   526,  537, 1146,  192,  350,  105,  529,  537,    4,  497,
+ /*  1020 */   162,  337, 1492,  310, 1249,  385, 1550,  372,    9,  462,
+ /*  1030 */   242,  400,  532,   13,   13,  499,  971,  843,  436,   70,
+ /*  1040 */    70,  359,  103,  103,    8,  339,  278,  187,  278,  104,
+ /*  1050 */  1127,  419,  539,  538, 1339,  419,  961,  302, 1339, 1172,
+ /*  1060 */     1,    1,  542,    2, 1176, 1146, 1146,  526,  476,  289,
+ /*  1070 */    30,  134,  317,  288,  528,  285,  844, 1014, 1254,  276,
+ /*  1080 */  1472,  506,  410, 1194,    6,  207,  505,  961,  961,  963,
+ /*  1090 */   964,   27,  449,  971,  415,  414,  234,  233,  232,  103,
+ /*  1100 */   103,   31, 1152, 1127, 1128, 1129,  104, 1154,  419,  539,
+ /*  1110 */   538,  264,  264,  961, 1399, 1153,  264,  264, 1470, 1146,
+ /*  1120 */   537,  216,    6,  401,  534, 1197,  392,  458,  406,  534,
+ /*  1130 */   537,  485,  358,  537,  261,  537, 1339,  907,  219, 1155,
+ /*  1140 */   467, 1155,   50,   50,  961,  961,  963,  964,   27, 1497,
+ /*  1150 */  1116,  421,   70,   70,  268,   70,   70,   13,   13,  369,
+ /*  1160 */   369,  368,  253,  366,  264,  264,  804,  235,  422,  105,
+ /*  1170 */   529,  516,    4,  287,  487,  510,  493,  534,  486,  213,
+ /*  1180 */  1055,  294,  490,  384, 1127,  450,  532,  338,  413,  293,
+ /*  1190 */   522,  417,  335, 1036,  509, 1056,  107, 1036,   16,   16,
+ /*  1200 */  1469, 1094,  334, 1105,    6,  411, 1145,  264,  264,  419,
+ /*  1210 */  1057,  102,  511,  100, 1094,  264,  264, 1094,  922,  215,
+ /*  1220 */   534,  526,  907,  264,  264,  208,  923,  154,  534,  457,
+ /*  1230 */   156,  525,  391,  142,  218,  506,  534, 1127, 1128, 1129,
+ /*  1240 */   507,  139, 1131,   38,  214,  530,  392,  971,  329, 1454,
+ /*  1250 */   907, 1105,  537,  103,  103,  105,  529,  537,    4,  537,
+ /*  1260 */   104,  424,  419,  539,  538,  537,  502,  961,  517,  537,
+ /*  1270 */  1072,  537,  532,  373,   54,   54,  288,  528,  387,   55,
+ /*  1280 */    55,   15,   15,  288,  528,   17,  136,   44,   44, 1451,
+ /*  1290 */   537,   56,   56,   57,   57,  419, 1131,  291,  961,  961,
+ /*  1300 */   963,  964,   27,  393,  163,  537,  426,  526,  263,  206,
+ /*  1310 */   208,  517,   58,   58,  235,  440,  842,  841,  197,  105,
+ /*  1320 */   529,  506,    4, 1033,  439, 1033,  505,   59,   59,  308,
+ /*  1330 */   849,  850,   95,  971,  537,  907,  532,  948,  832,  103,
+ /*  1340 */   103,  105,  529,  537,    4, 1021,  104,  537,  419,  539,
+ /*  1350 */   538, 1116,  421,  961,  537,  268,   60,   60,  532,  419,
+ /*  1360 */   369,  369,  368,  253,  366,   61,   61,  804,  965,   45,
+ /*  1370 */    45,  526,  537, 1032, 1277, 1032,   46,   46,  537,  391,
+ /*  1380 */   213,  419,  294,  266,  961,  961,  963,  964,   27,  292,
+ /*  1390 */   293,  295,  832,  526,   48,   48, 1290,  971, 1289, 1021,
+ /*  1400 */    49,   49,  432,  103,  103,  887,  953,  537, 1457,  241,
+ /*  1410 */   104,  305,  419,  539,  538,  925,  926,  961,  444,  971,
+ /*  1420 */   215,  241,  965, 1224,  537,  103,  103, 1431,  154,   62,
+ /*  1430 */    62,  156,  104, 1430,  419,  539,  538,   97,  529,  961,
+ /*  1440 */     4,  537,  454,  537,  314,  214,   63,   63,  961,  961,
+ /*  1450 */   963,  964,   27,  537,  532,  446, 1286,  318,  241,  537,
+ /*  1460 */   321,  323,  325,   64,   64,   14,   14, 1237,  537, 1223,
+ /*  1470 */   961,  961,  963,  964,   27,   65,   65,  419,  537,  387,
+ /*  1480 */   537,  125,  125,  537,  288,  528,  537, 1486,  537,  526,
+ /*  1490 */    66,   66,  313,  524,  537,   95,  468, 1221, 1511,  237,
+ /*  1500 */    51,   51,   67,   67,  330,   68,   68,  426,   52,   52,
+ /*  1510 */   149,  149, 1222,  340,  341,  971,  150,  150, 1298,  463,
+ /*  1520 */   327,  103,  103,   95,  537, 1338, 1273,  537,  104,  537,
+ /*  1530 */   419,  539,  538, 1284,  537,  961,  268,  283,  523, 1344,
+ /*  1540 */  1204,  369,  369,  368,  253,  366,   75,   75,  804,   53,
+ /*  1550 */    53,   71,   71,  537, 1196,  537,  126,  126,  537, 1017,
+ /*  1560 */   537,  213,  237,  294,  537, 1185,  961,  961,  963,  964,
+ /*  1570 */    27,  293,  537, 1184,  537,   72,   72,  127,  127, 1186,
+ /*  1580 */   128,  128,  124,  124, 1505,  537,  148,  148,  537,  256,
+ /*  1590 */   195,  537, 1270,  537,  147,  147,  132,  132,  537,   11,
+ /*  1600 */   537,  215,  537,  199,  343,  345,  347,  131,  131,  154,
+ /*  1610 */   129,  129,  156,  130,  130,   74,   74,  537,  370, 1323,
+ /*  1620 */    76,   76,   73,   73,   43,   43,  214,  431,  211, 1331,
+ /*  1630 */   300,  916,  880,  815,  241,  107,  137,  307,  881,   47,
+ /*  1640 */    47,  107,  473,  378,  203,  448,  333, 1403, 1220, 1402,
+ /*  1650 */   349,  190,  527,  191,  363,  198, 1508, 1163,  245,  165,
+ /*  1660 */   387, 1450, 1448, 1160,   78,  288,  528, 1408,   81,  394,
+ /*  1670 */    82,  442,  175,  159,  167,   93, 1328,   35, 1320,  434,
+ /*  1680 */   170,  171,  172,  173,  435,  466,  221,  375,  426,  377,
+ /*  1690 */  1334,  179,  455,  441, 1397,  225,   87,   36,  461, 1419,
+ /*  1700 */   316,  257,  227,  184,  320,  464,  228,  479, 1187,  229,
+ /*  1710 */   380, 1240, 1239,  407, 1238, 1212,  834,  332, 1231,  381,
+ /*  1720 */   409, 1211,  204, 1210, 1491,  498, 1520, 1281,   92,  281,
+ /*  1730 */  1230,  489,  282,  492,  342,  243, 1282,  344,  244, 1280,
+ /*  1740 */   346,  412, 1279, 1477,  348,  122, 1476,  517,   10,  357,
+ /*  1750 */   286, 1305, 1304,   99, 1383,   94,  501,  251, 1193,   34,
+ /*  1760 */  1263,  355,  540,  194, 1262,  361,  362, 1122,  252,  254,
+ /*  1770 */   255,  388,  541, 1182, 1177,  151, 1435,  389, 1436, 1434,
+ /*  1780 */  1433,  791,  152,  135,  279,  200,  201,  420,  196,   77,
+ /*  1790 */   153,  290,  269,  210, 1031,  133, 1029,  945,  166,  155,
+ /*  1800 */   217,  168,  866,  306,  220, 1045,  174,  949,  157,  396,
+ /*  1810 */    83,  398,  176,   84,   85,  164,   86,  158, 1048,  222,
+ /*  1820 */   223, 1044,  144,   18,  224,  315, 1037,  180,  241,  460,
+ /*  1830 */  1157,  226,  181,   37,  806,  465,  334,  230,  328,  469,
+ /*  1840 */   182,   88,  474,   19,   20,  160,   89,  280,  145,   90,
+ /*  1850 */   481,  845, 1110,  146,  997,  205, 1080,   39,   91,   40,
+ /*  1860 */   488, 1081,  915,  491,  260,  262,  185,  910,  240,  107,
+ /*  1870 */  1100, 1096, 1098, 1104,   21, 1084,   33,  513,  247,   22,
+ /*  1880 */    23,   24, 1103,   25,  188,   95, 1012,  998,  996,   26,
+ /*  1890 */  1000, 1054,    7, 1053, 1001,  246,   28,   41,  533,  966,
+ /*  1900 */   816,  106,   29,  367,  248,  249, 1513, 1512,  364, 1117,
+ /*  1910 */  1173, 1173,  876,
 };
 static const YYCODETYPE yy_lookahead[] = {
- /*     0 */   184,  184,  259,  260,  261,  259,  260,  261,  176,  177,
- /*    10 */   178,  179,  180,  181,  184,  208,  212,  213,  186,   19,
- /*    20 */   188,  205,  206,  280,  205,  221,   22,  195,   24,  195,
- /*    30 */   208,   31,  195,  205,   29,  205,  206,  255,   33,   39,
- /*    40 */   200,  201,  202,   43,   44,   45,   46,   47,   48,   49,
- /*    50 */    50,   51,   52,   53,   54,   55,   56,   57,  205,  227,
- /*    60 */   228,  227,  228,   59,  227,  228,  259,  260,  261,  252,
- /*    70 */    65,  241,  240,  184,  240,  223,  224,  240,  244,  245,
- /*    80 */   250,  259,  260,  261,   19,  253,   54,   55,   56,   57,
- /*    90 */    58,  184,  255,  184,  205,  206,   96,   97,   98,   99,
- /*   100 */   100,  101,  102,  103,  104,  105,  106,   46,   47,   48,
- /*   110 */    49,   46,  296,  297,  110,  283,   19,   96,   97,   98,
- /*   120 */    99,  100,  101,  102,  103,  104,  105,  106,   96,   97,
- /*   130 */    98,   99,  100,  101,  102,  103,  104,  105,  106,   94,
- /*   140 */    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
- /*   150 */    53,   54,   55,   56,   57,  110,  106,   73,  251,  114,
- /*   160 */    73,  178,  179,  180,  181,   59,  184,  292,   81,  186,
- /*   170 */   295,  188,  218,  108,   19,  114,  184,   11,  195,  184,
- /*   180 */    83,  184,   85,   54,   55,   56,   57,  205,  206,  124,
- /*   190 */   145,  146,  147,   96,   97,   98,   99,  100,  101,  102,
- /*   200 */   103,  104,  105,  106,  120,  121,  122,  120,  102,   81,
- /*   210 */   227,  228,  220,   19,   16,  109,  110,  111,  131,  132,
- /*   220 */    26,  184,  184,  240,  229,   96,   97,   98,   99,  100,
- /*   230 */   101,  102,  103,  104,  105,  106,  253,   43,   44,   45,
- /*   240 */    46,   47,   48,   49,   50,   51,   52,   53,   54,   55,
- /*   250 */    56,   57,  100,  101,  102,  103,  104,  105,  106,  131,
- /*   260 */   132,  106,  127,   69,  129,  130,  283,  112,  113,  114,
- /*   270 */   115,  116,  117,  118,   81,   77,   76,   79,  296,  124,
- /*   280 */   298,  203,  184,   19,   84,   59,   86,  121,  122,   89,
- /*   290 */    96,   97,   98,   99,  100,  101,  102,  103,  104,  105,
- /*   300 */   106,  184,   35,  205,  206,   22,  113,   43,   44,   45,
- /*   310 */    46,   47,   48,   49,   50,   51,   52,   53,   54,   55,
- /*   320 */    56,   57,  205,  206,  131,  132,  100,  101,  291,  292,
- /*   330 */   114,   67,  295,   66,  108,  109,  110,  111,  138,  113,
- /*   340 */   124,   74,   59,  179,  184,  181,  184,  121,   22,  271,
- /*   350 */   186,   19,  188,  184,  276,   59,   24,  184,  241,  195,
- /*   360 */    96,   97,   98,   99,  100,  101,  102,  103,  104,  105,
- /*   370 */   106,  145,   59,  147,  184,   43,   44,   45,   46,   47,
- /*   380 */    48,   49,   50,   51,   52,   53,   54,   55,   56,   57,
- /*   390 */   123,  227,  228,  110,  296,  297,   22,   23,  184,  102,
- /*   400 */   103,  104,  105,  106,  240,  109,  110,  111,  112,  195,
- /*   410 */   204,  115,  116,  117,   22,  184,  226,  253,  212,  205,
- /*   420 */   206,  125,  109,  110,  111,   22,  100,  101,   96,   97,
- /*   430 */    98,   99,  100,  101,  102,  103,  104,  105,  106,  184,
- /*   440 */    59,  227,  228,  121,  122,   59,  277,  283,   19,  289,
- /*   450 */   290,   59,   23,   76,  240,  241,  143,   76,   72,  189,
- /*   460 */   205,  206,   59,   86,  250,   84,   89,   86,  203,   95,
- /*   470 */    89,  281,   43,   44,   45,   46,   47,   48,   49,   50,
- /*   480 */    51,   52,   53,   54,   55,   56,   57,  227,  228,  184,
- /*   490 */   109,  110,  111,   12,  184,  109,  110,  111,  184,  184,
- /*   500 */   240,  109,  110,  111,  184,  195,  214,   59,   27,  184,
- /*   510 */   205,  206,  109,  110,  111,  205,  206,  184,  263,  138,
- /*   520 */   205,  206,  184,   42,   22,   96,   97,   98,   99,  100,
- /*   530 */   101,  102,  103,  104,  105,  106,  266,  227,  228,   59,
- /*   540 */   270,  276,   94,   66,   63,   19,  241,   22,   26,   23,
- /*   550 */   240,  241,   72,   59,   73,  250,  241,  109,  110,   82,
- /*   560 */    22,   59,  114,  223,  224,  250,  252,   59,   91,   43,
- /*   570 */    44,   45,   46,   47,   48,   49,   50,   51,   52,   53,
- /*   580 */    54,   55,   56,   57,   59,  184,   26,   59,  268,  109,
- /*   590 */   110,  111,  184,  145,  146,  147,  112,   59,  203,  115,
- /*   600 */   116,  117,  277,  109,  110,  111,  205,  206,  195,  125,
- /*   610 */   277,  109,  110,  111,  100,  101,  139,  109,  110,  111,
- /*   620 */   219,  184,   96,   97,   98,   99,  100,  101,  102,  103,
- /*   630 */   104,  105,  106,  111,  109,  110,  111,  109,  110,  111,
- /*   640 */   227,  228,   19,  184,  136,  184,   23,  109,  110,  111,
- /*   650 */   200,  201,  202,  240,  259,  260,  261,  195,  136,  145,
- /*   660 */   184,  147,  184,  184,  136,  214,   43,   44,   45,   46,
- /*   670 */    47,   48,   49,   50,   51,   52,   53,   54,   55,   56,
- /*   680 */    57,  205,  206,  205,  206,  227,  228,  184,  229,  227,
- /*   690 */   228,  131,  132,  184,   59,  219,  184,  219,  240,  291,
- /*   700 */   292,  184,  240,  295,  105,  106,   22,   23,  205,  206,
- /*   710 */    26,  184,  251,  184,  205,  206,  184,  205,  206,   96,
- /*   720 */    97,   98,   99,  100,  101,  102,  103,  104,  105,  106,
- /*   730 */   251,  219,  205,  206,  205,  206,  184,  205,  206,   19,
- /*   740 */   184,   16,  184,   23,  241,  110,  219,   21,  219,  184,
- /*   750 */   241,  219,  286,  287,  195,  184,  195,  205,  206,  201,
- /*   760 */   202,  205,  206,   43,   44,   45,   46,   47,   48,   49,
- /*   770 */    50,   51,   52,   53,   54,   55,   56,   57,  184,   95,
- /*   780 */    22,   23,  184,   26,   26,  220,  227,  228,  227,  228,
- /*   790 */   196,  184,   23,  241,   26,   26,  195,  241,  184,  240,
- /*   800 */    12,  240,   77,   26,   79,  195,   80,  290,  201,  202,
- /*   810 */   216,  184,  218,  195,  184,   27,   96,   97,   98,   99,
- /*   820 */   100,  101,  102,  103,  104,  105,  106,  269,  227,  228,
- /*   830 */    42,  184,  205,  206,  184,  184,   19,  227,  228,  192,
- /*   840 */    23,  240,  116,  196,   76,  227,  228,  120,  121,  122,
- /*   850 */   240,   63,  254,   95,   86,  205,  206,   89,  240,  184,
- /*   860 */    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
- /*   870 */    53,   54,   55,   56,   57,  184,  269,  184,  153,  153,
- /*   880 */   111,  184,    7,    8,    9,  184,  138,  184,  184,  196,
- /*   890 */   184,  120,  121,  122,  184,  138,  205,  206,  184,  102,
- /*   900 */   184,  184,  205,  206,  156,  136,  205,  206,  205,  206,
- /*   910 */   198,  199,  135,   96,   97,   98,   99,  100,  101,  102,
- /*   920 */   103,  104,  105,  106,  184,  128,  184,  184,  184,  254,
- /*   930 */   133,  184,  237,   19,  239,  229,  226,   23,  292,  184,
- /*   940 */   226,  295,  226,  226,  184,  205,  206,  205,  206,  205,
- /*   950 */   206,  184,  292,   19,  184,  295,  252,   43,   44,   45,
- /*   960 */    46,   47,   48,   49,   50,   51,   52,   53,   54,   55,
- /*   970 */    56,   57,  205,  206,  184,  205,  206,   43,   44,   45,
- /*   980 */    46,   47,   48,   49,   50,   51,   52,   53,   54,   55,
- /*   990 */    56,   57,  157,  158,   26,  205,  206,  254,   26,  252,
- /*  1000 */   184,   15,  184,  184,  184,  292,  184,  252,  295,   24,
- /*  1010 */    96,   97,   98,   99,  100,  101,  102,  103,  104,  105,
- /*  1020 */   106,  205,  206,  205,  206,  205,  206,  205,  206,  184,
- /*  1030 */    96,   97,   98,   99,  100,  101,  102,  103,  104,  105,
- /*  1040 */   106,  184,  184,  184,   59,  184,   60,  184,  229,  184,
- /*  1050 */   205,  206,  184,  258,  184,   19,  184,   19,  184,  246,
- /*  1060 */   184,  258,  205,  206,  205,  206,  205,  206,  205,  206,
- /*  1070 */   205,  206,  184,  205,  206,  205,  206,  205,  206,  205,
- /*  1080 */   206,  205,  206,  292,  226,  151,  295,  184,  228,  294,
- /*  1090 */   184,  119,  184,  205,  206,  110,  150,  294,  152,  184,
- /*  1100 */   240,  184,   22,   23,   23,   19,  184,   26,  205,  206,
- /*  1110 */   142,  205,  206,  205,  206,  184,  198,  199,  131,  132,
- /*  1120 */   205,  206,  205,  206,   22,   19,   24,  205,  206,   43,
- /*  1130 */    44,   45,   46,   47,   48,   49,   50,   51,   52,   53,
- /*  1140 */    54,   55,   56,   57,  184,  109,  184,  109,  184,   43,
- /*  1150 */    44,   45,   46,   47,   48,   49,   50,   51,   52,   53,
- /*  1160 */    54,   55,   56,   57,   46,  205,  206,  205,  206,  205,
- /*  1170 */   206,  232,  184,  184,  184,   95,  184,  284,  285,  244,
- /*  1180 */   245,  242,   96,   97,   98,   99,  100,  101,  102,  103,
- /*  1190 */   104,  105,  106,  205,  206,  205,  206,  205,  206,  184,
- /*  1200 */    22,  184,   96,   97,   98,   99,  100,  101,  102,  103,
- /*  1210 */   104,  105,  106,  184,   24,   23,  184,  184,   26,  184,
- /*  1220 */   205,  206,  205,  206,  184,   31,  108,  128,   22,  122,
- /*  1230 */   184,   53,  133,   39,  205,  206,   22,  151,  205,  206,
- /*  1240 */   205,  206,  113,  114,   23,  205,  206,   26,   59,   23,
- /*  1250 */    23,  144,   26,   26,  184,   23,   23,   19,   26,   26,
- /*  1260 */     7,    8,   24,   23,  214,   23,   26,   61,   26,   59,
- /*  1270 */    23,   23,   23,   26,   26,   26,  145,   19,  147,   59,
- /*  1280 */   184,   43,   44,   45,   46,   47,   48,   49,   50,   51,
- /*  1290 */    52,   53,   54,   55,   56,   57,  145,   23,  147,  110,
- /*  1300 */    26,   43,   44,   45,   46,   47,   48,   49,   50,   51,
- /*  1310 */    52,   53,   54,   55,   56,   57,   23,  184,  184,   26,
- /*  1320 */   110,  184,  184,  184,  134,  184,  184,  184,  184,  184,
- /*  1330 */   110,  184,  184,  184,   96,   97,   98,   99,  100,  101,
- /*  1340 */   102,  103,  104,  105,  106,  184,  184,  184,  134,  300,
- /*  1350 */   184,  243,  184,  184,   96,   97,   98,   99,  100,  101,
- /*  1360 */   102,  103,  104,  105,  106,  184,  184,  184,  184,  184,
- /*  1370 */   224,  184,  282,  273,   19,  272,  203,  182,  243,  243,
- /*  1380 */   230,  209,  278,  243,  231,  208,  265,  278,  234,  234,
- /*  1390 */   234,  217,  213,   60,   19,  243,  208,  237,  233,   44,
- /*  1400 */    45,   46,   47,   48,   49,   50,   51,   52,   53,   54,
- /*  1410 */    55,   56,   57,  208,  247,  187,  134,  247,  247,   38,
- /*  1420 */    45,   46,   47,   48,   49,   50,   51,   52,   53,   54,
- /*  1430 */    55,   56,   57,  237,  231,  191,  191,  279,  279,  282,
- /*  1440 */   143,  191,  108,  268,   22,   19,   20,  256,   22,   43,
- /*  1450 */   257,   96,   97,   98,   99,  100,  101,  102,  103,  104,
- /*  1460 */   105,  106,   36,  222,  142,  234,   18,  191,  225,   18,
- /*  1470 */   190,   96,   97,   98,   99,  100,  101,  102,  103,  104,
- /*  1480 */   105,  106,  225,  191,  225,   59,  225,  257,  234,  234,
- /*  1490 */   256,  222,  222,  190,  234,  150,   62,   71,  275,  274,
- /*  1500 */   191,   19,   20,  190,   22,   22,  210,   81,  191,  190,
- /*  1510 */   210,  191,  108,  190,  207,  207,   64,  207,   36,  215,
- /*  1520 */    94,  210,  207,  209,  119,  207,  100,  101,  207,  106,
- /*  1530 */    48,  215,  207,  107,  210,  109,  110,  111,  267,  267,
- /*  1540 */   114,   59,  210,  249,  137,  108,  248,  191,  249,  248,
- /*  1550 */    88,  249,  141,   71,  248,  299,  138,  131,  132,   22,
- /*  1560 */   191,  249,  299,  237,   82,  238,  150,  262,  140,   87,
- /*  1570 */   139,  145,  146,  147,  148,  149,   94,  248,  238,  236,
- /*  1580 */    25,  235,  100,  101,  234,  194,   26,  193,   13,  107,
- /*  1590 */     6,  109,  110,  111,  264,  185,  114,  185,  183,  197,
- /*  1600 */   183,  203,  183,  203,  203,  197,  203,  211,  211,    4,
- /*  1610 */   197,    3,  203,   22,  155,   15,  288,  203,   93,  288,
- /*  1620 */   285,   23,   16,  203,  203,   23,  132,  145,  146,  147,
- /*  1630 */   148,  149,    0,    1,    2,  143,  123,    5,   24,  135,
- /*  1640 */    20,   16,   10,   11,   12,   13,   14,  137,    1,   17,
- /*  1650 */   135,  144,   19,   20,  123,   22,   61,  143,   37,  123,
- /*  1660 */    53,  109,   30,   53,   32,   53,   53,  134,   34,   36,
- /*  1670 */     1,    5,   40,   22,  108,  153,   26,   68,   75,   68,
- /*  1680 */    41,  134,  108,   24,   20,  124,   19,  118,   23,   67,
- /*  1690 */    22,   67,   59,   22,   22,   22,   22,   67,   28,   37,
- /*  1700 */    23,  142,   70,   22,   71,   23,  157,   23,   23,   26,
- /*  1710 */    78,   23,   22,   81,   23,   82,   24,   22,   24,  134,
- /*  1720 */    87,   23,   19,   20,   92,   22,  109,   94,   23,   22,
- /*  1730 */    34,   34,  136,  100,  101,   26,   34,   85,   34,   36,
- /*  1740 */   107,   83,  109,  110,  111,   34,   90,  114,   34,   23,
- /*  1750 */    75,   75,   44,   22,   24,   26,   34,   23,  126,   26,
- /*  1760 */    23,   23,   59,  131,  132,   23,   23,   26,   23,   22,
- /*  1770 */    11,   22,   22,   22,   71,   23,   23,   22,  145,  146,
- /*  1780 */   147,  148,  149,   26,   23,   82,  154,  134,  128,  134,
- /*  1790 */    87,  134,   15,    1,  301,  134,  301,   94,  301,  301,
- /*  1800 */   301,  301,  301,  100,  101,  301,  301,  301,  301,  301,
- /*  1810 */   107,  301,  109,  110,  111,    1,    2,  114,  301,    5,
- /*  1820 */   301,  301,  301,  301,   10,   11,   12,   13,   14,  301,
- /*  1830 */   301,   17,  301,  301,  301,  301,   19,   20,  301,   22,
- /*  1840 */   301,  301,  301,  301,   30,  301,   32,  301,  145,  146,
- /*  1850 */   147,  148,  149,   36,   40,  301,  301,  301,  301,  301,
- /*  1860 */   301,  301,  301,  301,  301,  301,  301,  301,  301,  301,
- /*  1870 */   301,  301,  301,  301,  301,  301,   59,  301,  301,  301,
- /*  1880 */   301,  301,  301,  301,   70,  301,  301,  301,   71,  301,
- /*  1890 */   301,  301,   78,  301,  301,   81,   19,   20,  301,   22,
- /*  1900 */   301,  301,  301,  301,  301,  301,   92,  301,  301,  301,
- /*  1910 */   301,   94,  301,   36,  301,  301,  301,  100,  101,  102,
- /*  1920 */   301,  301,  301,  301,  107,  301,  109,  110,  111,  301,
- /*  1930 */   301,  114,  301,  301,  301,  301,   59,  301,  301,  301,
- /*  1940 */   126,  301,  301,  301,  301,  131,  132,  301,   71,  301,
- /*  1950 */   301,  301,  301,  301,  301,  301,   19,   20,  301,   22,
- /*  1960 */   301,  301,  145,  146,  147,  148,  149,  301,  154,  301,
- /*  1970 */   301,   94,  301,   36,  301,  301,  301,  100,  101,  301,
- /*  1980 */   301,  301,  301,  301,  107,  301,  109,  110,  111,  301,
- /*  1990 */   301,  114,    5,  301,  301,  301,   59,   10,   11,   12,
- /*  2000 */    13,   14,  301,  301,   17,  301,  301,  301,   71,  301,
- /*  2010 */   301,  301,  301,  301,  301,  301,  301,   30,  301,   32,
- /*  2020 */   301,  301,  145,  146,  147,  148,  149,   40,  301,  301,
- /*  2030 */   301,   94,  301,  301,  301,  301,  301,  100,  101,  301,
- /*  2040 */   301,  301,  301,  301,  107,  301,  109,  110,  111,  301,
- /*  2050 */   301,  114,  301,  301,  301,  301,  301,   70,  301,  301,
- /*  2060 */   301,  301,  301,  301,  301,   78,  301,  301,   81,  301,
- /*  2070 */   301,  301,  301,  301,  301,  301,  301,  301,  301,   92,
- /*  2080 */   301,  301,  145,  146,  147,  148,  149,  301,  301,  301,
- /*  2090 */   301,  301,  301,  301,  301,  301,  301,  301,  301,  301,
- /*  2100 */   301,  301,  301,  301,  301,  301,  301,  301,  301,  301,
- /*  2110 */   301,  301,  301,  126,  301,  301,  301,  301,  131,  132,
- /*  2120 */   301,  301,  301,  301,  301,  301,  301,  301,  301,  301,
- /*  2130 */   301,  301,  301,  301,  301,  301,  301,  301,  301,  301,
- /*  2140 */   301,  154,  301,  301,  301,  301,  301,  301,  301,  301,
- /*  2150 */   301,  301,  301,  301,  301,  301,  301,  301,  301,  301,
- /*  2160 */   301,  301,  301,  301,  301,  301,  301,  301,  301,
+ /*     0 */   187,  187,  187,  216,  217,  187,  206,  187,  264,  265,
+ /*    10 */   266,  187,  225,  187,  209,  187,  264,  265,  266,   19,
+ /*    20 */   187,  187,  209,  210,  209,  210,  187,  209,  210,  209,
+ /*    30 */   210,   31,  209,  209,  210,  209,  210,  285,  224,   39,
+ /*    40 */   203,  204,  205,   43,   44,   45,   46,   47,   48,   49,
+ /*    50 */    50,   51,   52,   53,   54,   55,   56,   57,  230,   19,
+ /*    60 */   181,  182,  183,  184,  230,  245,  233,  208,  189,  245,
+ /*    70 */   191,  245,   26,  206,  254,  216,  276,  198,  254,  198,
+ /*    80 */   254,  281,  187,   43,   44,   45,   46,   47,   48,   49,
+ /*    90 */    50,   51,   52,   53,   54,   55,   56,   57,  259,   99,
+ /*   100 */   100,  101,  102,  103,  104,  105,  106,  107,  108,  109,
+ /*   110 */   231,  232,  231,  232,  286,  302,  303,  302,   22,  304,
+ /*   120 */   302,  303,   76,  244,   11,  244,   86,   19,   88,  248,
+ /*   130 */   249,  264,  265,  266,   26,   89,  198,  258,   92,   99,
+ /*   140 */   100,  101,  102,  103,  104,  105,  106,  107,  108,  109,
+ /*   150 */   105,   43,   44,   45,   46,   47,   48,   49,   50,   51,
+ /*   160 */    52,   53,   54,   55,   56,   57,  212,  288,  273,  231,
+ /*   170 */   232,  105,  106,  107,  108,  109,  131,   69,  203,  204,
+ /*   180 */   205,  136,  244,   99,  100,  101,  102,  103,  104,  105,
+ /*   190 */   106,  107,  108,  109,   15,  103,  104,   19,  260,  103,
+ /*   200 */   104,   54,   55,   56,   57,   58,   22,   99,  100,  101,
+ /*   210 */   102,  103,  104,  105,  106,  107,  108,  109,  264,  265,
+ /*   220 */   266,   43,   44,   45,   46,   47,   48,   49,   50,   51,
+ /*   230 */    52,   53,   54,   55,   56,   57,   19,  124,  125,   60,
+ /*   240 */   148,   24,  150,   59,  187,   67,   99,  100,  101,  102,
+ /*   250 */   103,  104,  105,  106,  107,  108,  109,  187,  187,  109,
+ /*   260 */    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
+ /*   270 */    53,   54,   55,   56,   57,  204,  205,   99,  100,  101,
+ /*   280 */   102,  103,  104,  105,  106,  107,  108,  109,  103,  104,
+ /*   290 */   105,  106,  107,  108,  109,   59,  112,  113,  114,   76,
+ /*   300 */   231,  232,  187,   19,   19,   22,   23,   23,   54,   55,
+ /*   310 */    56,   57,   89,  244,  199,   92,   99,  100,  101,  102,
+ /*   320 */   103,  104,  105,  106,  107,  108,  109,   43,   44,   45,
+ /*   330 */    46,   47,   48,   49,   50,   51,   52,   53,   54,   55,
+ /*   340 */    56,   57,   19,  212,  187,  274,   23,   26,  112,  113,
+ /*   350 */   114,  294,  295,   99,  100,  101,  102,  103,  104,  105,
+ /*   360 */   106,  107,  108,  109,   59,  295,   43,   44,   45,   46,
+ /*   370 */    47,   48,   49,   50,   51,   52,   53,   54,   55,   56,
+ /*   380 */    57,   98,  146,   99,  100,  101,  102,  103,  104,  105,
+ /*   390 */   106,  107,  108,  109,  109,  264,  265,  266,  187,  187,
+ /*   400 */   115,  116,  117,  118,  119,  120,  121,   73,   59,   19,
+ /*   410 */   105,   23,  127,   23,   26,   81,  259,  112,  113,  114,
+ /*   420 */   187,   72,   99,  100,  101,  102,  103,  104,  105,  106,
+ /*   430 */   107,  108,  109,   43,   44,   45,   46,   47,   48,   49,
+ /*   440 */    50,   51,   52,   53,   54,   55,   56,   57,   19,  124,
+ /*   450 */   125,  182,   23,  184,  187,  134,  135,  123,  189,  131,
+ /*   460 */   191,  112,  113,  114,  136,  187,  233,  198,  134,  135,
+ /*   470 */   198,  259,   43,   44,   45,   46,   47,   48,   49,   50,
+ /*   480 */    51,   52,   53,   54,   55,   56,   57,  209,  210,   99,
+ /*   490 */   100,  101,  102,  103,  104,  105,  106,  107,  108,  109,
+ /*   500 */   231,  232,  206,  231,  232,  187,   59,  296,  297,   76,
+ /*   510 */   160,  161,  301,  244,  232,   19,  244,  297,   59,   23,
+ /*   520 */    87,  301,   89,  245,   26,   92,  244,  258,   99,  100,
+ /*   530 */   101,  102,  103,  104,  105,  106,  107,  108,  109,   43,
+ /*   540 */    44,   45,   46,   47,   48,   49,   50,   51,   52,   53,
+ /*   550 */    54,   55,   56,   57,   19,  187,   97,  288,   23,  112,
+ /*   560 */   113,  114,  115,  296,  297,  118,  119,  120,  301,  108,
+ /*   570 */   109,  112,  113,  255,  141,  128,  117,  281,   43,   44,
+ /*   580 */    45,   46,   47,   48,   49,   50,   51,   52,   53,   54,
+ /*   590 */    55,   56,   57,  187,  187,   99,  100,  101,  102,  103,
+ /*   600 */   104,  105,  106,  107,  108,  109,   26,  148,  149,  150,
+ /*   610 */   115,   97,   59,  118,  119,  120,  209,  210,   73,   59,
+ /*   620 */   122,   19,  209,  128,  256,   72,  187,  113,  187,   81,
+ /*   630 */   223,  117,  227,  228,   99,  100,  101,  102,  103,  104,
+ /*   640 */   105,  106,  107,  108,  109,   43,   44,   45,   46,   47,
+ /*   650 */    48,   49,   50,   51,   52,   53,   54,   55,   56,   57,
+ /*   660 */    19,  255,  148,  149,  150,  112,  113,  114,  123,  124,
+ /*   670 */   125,  230,  112,  113,  114,   22,  297,   22,   81,   22,
+ /*   680 */   301,   59,  134,  135,   43,   44,   45,   46,   47,   48,
+ /*   690 */    49,   50,   51,   52,   53,   54,   55,   56,   57,  139,
+ /*   700 */   192,   99,  100,  101,  102,  103,  104,  105,  106,  107,
+ /*   710 */   108,  109,   59,  116,   59,  187,   59,  231,  232,   46,
+ /*   720 */    47,   48,   49,   16,   12,  145,  198,   22,  187,  187,
+ /*   730 */   244,  134,  135,  222,  112,  113,  114,  209,  210,   27,
+ /*   740 */    99,  100,  101,  102,  103,  104,  105,  106,  107,  108,
+ /*   750 */   109,  209,  210,  187,   42,  187,  154,  227,  228,  231,
+ /*   760 */   232,  139,   22,   23,   59,  112,  113,  114,  113,  112,
+ /*   770 */   113,  114,  244,  245,  233,   63,   19,  209,  210,  271,
+ /*   780 */   187,   24,  254,  275,   77,   73,   79,  245,  195,  260,
+ /*   790 */   117,  223,  199,   22,   23,  154,   19,   26,   22,  187,
+ /*   800 */    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
+ /*   810 */    53,   54,   55,   56,   57,   19,  187,  112,  113,  114,
+ /*   820 */    43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
+ /*   830 */    53,   54,   55,   56,   57,   59,  263,  187,   98,   43,
+ /*   840 */    44,   45,   46,   47,   48,   49,   50,   51,   52,   53,
+ /*   850 */    54,   55,   56,   57,  204,  205,   99,  100,  101,  102,
+ /*   860 */   103,  104,  105,  106,  107,  108,  109,  255,  130,   98,
+ /*   870 */   132,  133,  299,  300,  198,  187,   99,  100,  101,  102,
+ /*   880 */   103,  104,  105,  106,  107,  108,  109,  187,  112,  113,
+ /*   890 */   114,  187,  241,  187,  243,   99,  100,  101,  102,  103,
+ /*   900 */   104,  105,  106,  107,  108,  109,   19,  231,  232,  209,
+ /*   910 */   210,  282,   59,  209,  210,  209,  210,   16,  230,   19,
+ /*   920 */   244,   22,   23,  223,  274,   26,   19,  223,  187,  223,
+ /*   930 */   198,   44,   45,   46,   47,   48,   49,   50,   51,   52,
+ /*   940 */    53,   54,   55,   56,   57,   45,   46,   47,   48,   49,
+ /*   950 */    50,   51,   52,   53,   54,   55,   56,   57,   19,   20,
+ /*   960 */   187,   22,  187,  231,  232,  112,  113,  114,  123,  124,
+ /*   970 */   125,    7,    8,    9,  187,   36,  244,   24,   77,   21,
+ /*   980 */    79,  187,  209,  210,  187,  263,   99,  100,  101,  102,
+ /*   990 */   103,  104,  105,  106,  107,  108,  109,   98,   59,   99,
+ /*  1000 */   100,  101,  102,  103,  104,  105,  106,  107,  108,  109,
+ /*  1010 */    71,  187,   59,  187,  187,   19,   20,  187,   22,  112,
+ /*  1020 */    81,  299,  300,  282,  230,  199,  291,  292,   22,  187,
+ /*  1030 */    24,  256,   36,  209,  210,  187,   97,   35,   80,  209,
+ /*  1040 */   210,  268,  103,  104,   48,  187,  220,  223,  222,  110,
+ /*  1050 */    59,  112,  113,  114,  187,   59,  117,  156,  187,  179,
+ /*  1060 */   180,  181,  182,  183,  184,   59,  113,   71,   66,  189,
+ /*  1070 */    22,  191,  230,  134,  135,  245,   74,  119,  198,  282,
+ /*  1080 */   297,   85,  224,  198,  301,  187,   90,  148,  149,  150,
+ /*  1090 */   151,  152,   19,   97,  103,  104,  123,  124,  125,  103,
+ /*  1100 */   104,   53,  111,  112,  113,  114,  110,  116,  112,  113,
+ /*  1110 */   114,  231,  232,  117,  156,  124,  231,  232,  297,  113,
+ /*  1120 */   187,   24,  301,  256,  244,  201,  202,  256,  126,  244,
+ /*  1130 */   187,  198,  187,  187,   23,  187,  187,   26,  258,  148,
+ /*  1140 */    19,  150,  209,  210,  148,  149,  150,  151,  152,    0,
+ /*  1150 */     1,    2,  209,  210,    5,  209,  210,  209,  210,   10,
+ /*  1160 */    11,   12,   13,   14,  231,  232,   17,   46,  288,   19,
+ /*  1170 */    20,  223,   22,  236,  198,   66,  187,  244,  245,   30,
+ /*  1180 */    12,   32,  198,  246,   59,  112,   36,  187,  245,   40,
+ /*  1190 */   198,  245,  117,   29,   85,   27,   26,   33,  209,  210,
+ /*  1200 */   297,   76,  127,   94,  301,  256,   26,  231,  232,   59,
+ /*  1210 */    42,  153,   87,  155,   89,  231,  232,   92,   31,   70,
+ /*  1220 */   244,   71,   26,  231,  232,  114,   39,   78,  244,   65,
+ /*  1230 */    81,   63,  111,  233,  137,   85,  244,  112,  113,  114,
+ /*  1240 */    90,   22,   59,   24,   95,  201,  202,   97,  127,  187,
+ /*  1250 */   139,  142,  187,  103,  104,   19,   20,  187,   22,  187,
+ /*  1260 */   110,  187,  112,  113,  114,  187,  141,  117,  141,  187,
+ /*  1270 */    23,  187,   36,   26,  209,  210,  134,  135,  129,  209,
+ /*  1280 */   210,  209,  210,  134,  135,   22,  159,  209,  210,  187,
+ /*  1290 */   187,  209,  210,  209,  210,   59,  113,  187,  148,  149,
+ /*  1300 */   150,  151,  152,  289,  290,  187,  157,   71,  248,  249,
+ /*  1310 */   114,  141,  209,  210,   46,  125,  116,  117,  138,   19,
+ /*  1320 */    20,   85,   22,  148,   61,  150,   90,  209,  210,   23,
+ /*  1330 */     7,    8,   26,   97,  187,  139,   36,  147,   59,  103,
+ /*  1340 */   104,   19,   20,  187,   22,   59,  110,  187,  112,  113,
+ /*  1350 */   114,    1,    2,  117,  187,    5,  209,  210,   36,   59,
+ /*  1360 */    10,   11,   12,   13,   14,  209,  210,   17,   59,  209,
+ /*  1370 */   210,   71,  187,  148,  250,  150,  209,  210,  187,  111,
+ /*  1380 */    30,   59,   32,   22,  148,  149,  150,  151,  152,  187,
+ /*  1390 */    40,  187,  113,   71,  209,  210,  187,   97,  187,  113,
+ /*  1400 */   209,  210,  187,  103,  104,  105,   23,  187,  187,   26,
+ /*  1410 */   110,  187,  112,  113,  114,   83,   84,  117,   23,   97,
+ /*  1420 */    70,   26,  113,  218,  187,  103,  104,  187,   78,  209,
+ /*  1430 */   210,   81,  110,  187,  112,  113,  114,   19,   20,  117,
+ /*  1440 */    22,  187,  187,  187,  187,   95,  209,  210,  148,  149,
+ /*  1450 */   150,  151,  152,  187,   36,   23,  187,  187,   26,  187,
+ /*  1460 */   187,  187,  187,  209,  210,  209,  210,  187,  187,  218,
+ /*  1470 */   148,  149,  150,  151,  152,  209,  210,   59,  187,  129,
+ /*  1480 */   187,  209,  210,  187,  134,  135,  187,  306,  187,   71,
+ /*  1490 */   209,  210,   23,  228,  187,   26,   23,  187,  137,   26,
+ /*  1500 */   209,  210,  209,  210,  187,  209,  210,  157,  209,  210,
+ /*  1510 */   209,  210,  218,  187,  187,   97,  209,  210,  187,  278,
+ /*  1520 */    23,  103,  104,   26,  187,  187,  187,  187,  110,  187,
+ /*  1530 */   112,  113,  114,  187,  187,  117,    5,  247,  187,  187,
+ /*  1540 */   187,   10,   11,   12,   13,   14,  209,  210,   17,  209,
+ /*  1550 */   210,  209,  210,  187,  187,  187,  209,  210,  187,   23,
+ /*  1560 */   187,   30,   26,   32,  187,  187,  148,  149,  150,  151,
+ /*  1570 */   152,   40,  187,  187,  187,  209,  210,  209,  210,  187,
+ /*  1580 */   209,  210,  209,  210,  187,  187,  209,  210,  187,  277,
+ /*  1590 */   234,  187,  247,  187,  209,  210,  209,  210,  187,  235,
+ /*  1600 */   187,   70,  187,  207,  247,  247,  247,  209,  210,   78,
+ /*  1610 */   209,  210,   81,  209,  210,  209,  210,  187,  185,  238,
+ /*  1620 */   209,  210,  209,  210,  209,  210,   95,  251,  287,  238,
+ /*  1630 */   251,   23,   23,   23,   26,   26,   26,  283,   23,  209,
+ /*  1640 */   210,   26,  213,  238,  221,  283,  212,  212,  217,  212,
+ /*  1650 */   251,  241,  270,  241,  237,  235,  190,   60,  137,  287,
+ /*  1660 */   129,  194,  194,   38,  284,  134,  135,  273,  284,  194,
+ /*  1670 */   146,  111,   22,   43,  226,  145,  262,  261,  238,   18,
+ /*  1680 */   229,  229,  229,  229,  194,   18,  193,  238,  157,  262,
+ /*  1690 */   226,  226,  194,  238,  238,  193,  153,  261,   62,  280,
+ /*  1700 */   279,  194,  193,   22,  194,  214,  193,  111,  194,  193,
+ /*  1710 */   214,  211,  211,   64,  211,  211,  122,  211,  219,  214,
+ /*  1720 */   109,  213,  160,  211,  300,  140,  211,  253,  111,  272,
+ /*  1730 */   219,  214,  272,  214,  252,  194,  253,  252,   91,  253,
+ /*  1740 */   252,   82,  253,  305,  252,  144,  305,  141,   22,  194,
+ /*  1750 */   269,  257,  257,  153,  267,  143,  142,   25,  197,   26,
+ /*  1760 */   242,  241,  196,  240,  242,  239,  238,   13,  188,  188,
+ /*  1770 */     6,  293,  186,  186,  186,  200,  206,  293,  206,  206,
+ /*  1780 */   206,    4,  200,  215,  215,  207,  207,    3,   22,  206,
+ /*  1790 */   200,  158,   96,   15,   23,   16,   23,  135,  146,  126,
+ /*  1800 */    24,  138,   20,   16,  140,    1,  138,  147,  126,   61,
+ /*  1810 */    53,   37,  146,   53,   53,  290,   53,  126,  112,   34,
+ /*  1820 */   137,    1,    5,   22,  111,  156,   68,   68,   26,   41,
+ /*  1830 */    75,  137,  111,   24,   20,   19,  127,  121,   23,   67,
+ /*  1840 */    22,   22,   67,   22,   22,   37,   22,   67,   23,  145,
+ /*  1850 */    22,   28,   23,   23,   23,  137,   23,   22,   26,   22,
+ /*  1860 */    24,   23,  112,   24,   23,   23,   22,  139,   34,   26,
+ /*  1870 */    75,   88,   86,   75,   34,   23,   22,   24,   22,   34,
+ /*  1880 */    34,   34,   93,   34,   26,   26,   23,   23,   23,   34,
+ /*  1890 */    23,   23,   44,   23,   11,   26,   22,   22,   26,   23,
+ /*  1900 */    23,   22,   22,   15,  137,  137,  137,  137,   23,    1,
+ /*  1910 */   307,  307,  131,  307,  307,  307,  307,  307,  307,  307,
+ /*  1920 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  1930 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  1940 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  1950 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  1960 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  1970 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  1980 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  1990 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  2000 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  2010 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  2020 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  2030 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  2040 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  2050 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  2060 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  2070 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  2080 */   307,  307,  307,  307,  307,  307,  307,  307,  307,  307,
+ /*  2090 */   307,  307,
 };
-#define YY_SHIFT_COUNT    (540)
+#define YY_SHIFT_COUNT    (542)
 #define YY_SHIFT_MIN      (0)
-#define YY_SHIFT_MAX      (1987)
+#define YY_SHIFT_MAX      (1908)
 static const unsigned short int yy_shift_ofst[] = {
- /*     0 */  1814, 1632, 1987, 1426, 1426,  128, 1482, 1633, 1703, 1877,
- /*    10 */  1877, 1877,   87,    0,    0,  264, 1106, 1877, 1877, 1877,
- /*    20 */  1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877,
- /*    30 */   226,  226,  381,  381,  296,  193,  128,  128,  128,  128,
- /*    40 */   128,  128,   97,  194,  332,  429,  526,  623,  720,  817,
- /*    50 */   914,  934, 1086, 1238, 1106, 1106, 1106, 1106, 1106, 1106,
- /*    60 */  1106, 1106, 1106, 1106, 1106, 1106, 1106, 1106, 1106, 1106,
- /*    70 */  1106, 1106, 1258, 1106, 1355, 1375, 1375, 1817, 1877, 1877,
- /*    80 */  1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877,
- /*    90 */  1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877,
- /*   100 */  1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877,
- /*   110 */  1937, 1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877,
- /*   120 */  1877, 1877, 1877, 1877,   32,  129,  129,  129,  129,  129,
- /*   130 */    21,  152,  297,  494,  726,   65,  494,  514,  514,  494,
- /*   140 */   560,  560,  560,  560,  322,  599,   50, 2142, 2142,  155,
- /*   150 */   155,  155,  313,  392,  386,  392,  392,  481,  481,  200,
- /*   160 */   480,  684,  758,  494,  494,  494,  494,  494,  494,  494,
- /*   170 */   494,  494,  494,  494,  494,  494,  494,  494,  494,  494,
- /*   180 */   494,  494,  494,  494,  768,  768,  494,  166,  377,  377,
- /*   190 */   635,  835,  835,  635,  748,  987, 2142, 2142, 2142,  448,
- /*   200 */    45,   45,  403,  484,  502,  106,  525,  508,  528,  538,
- /*   210 */   494,  494,  494,  494,  494,  494,  494,  494,  494,   84,
- /*   220 */   494,  494,  494,  494,  494,  494,  494,  494,  494,  494,
- /*   230 */   494,  494,  267,  267,  267,  494,  494,  494,  494,  769,
- /*   240 */   494,  494,  494,    4,  477,  494,  494,  788,  494,  494,
- /*   250 */   494,  494,  494,  494,  494,  494,  727,    5,  135,  985,
- /*   260 */   985,  985,  985,  522,  135,  135,  797,  326,  875,  986,
- /*   270 */   968, 1036, 1036, 1038,  968,  968, 1038,  972, 1081, 1118,
- /*   280 */  1194, 1194, 1194, 1036,  757,  757,  946,  777, 1099, 1102,
- /*   290 */  1333, 1282, 1282, 1381, 1381, 1282, 1297, 1334, 1422, 1406,
- /*   300 */  1322, 1448, 1448, 1448, 1448, 1282, 1451, 1322, 1322, 1334,
- /*   310 */  1422, 1406, 1406, 1322, 1282, 1451, 1345, 1434, 1282, 1451,
- /*   320 */  1483, 1282, 1451, 1282, 1451, 1483, 1404, 1404, 1404, 1452,
- /*   330 */  1483, 1404, 1405, 1404, 1452, 1404, 1404, 1483, 1423, 1423,
- /*   340 */  1483, 1407, 1437, 1407, 1437, 1407, 1437, 1407, 1437, 1282,
- /*   350 */  1462, 1462, 1411, 1418, 1537, 1282, 1416, 1411, 1428, 1431,
- /*   360 */  1322, 1555, 1560, 1575, 1575, 1584, 1584, 1584, 2142, 2142,
- /*   370 */  2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
- /*   380 */  2142, 2142, 2142, 2142,   61,  725,  374, 1080,  198,  771,
- /*   390 */   283, 1192, 1178, 1190, 1107, 1221, 1206, 1226, 1227, 1232,
- /*   400 */  1233, 1240, 1242, 1189, 1129, 1253,  216, 1210, 1247, 1248,
- /*   410 */  1249, 1131, 1151, 1274, 1293, 1220, 1214, 1605, 1608, 1591,
- /*   420 */  1459, 1600, 1525, 1606, 1598, 1602, 1494, 1492, 1513, 1614,
- /*   430 */  1504, 1620, 1510, 1625, 1647, 1515, 1507, 1531, 1595, 1621,
- /*   440 */  1514, 1607, 1610, 1612, 1613, 1536, 1552, 1634, 1533, 1669,
- /*   450 */  1666, 1651, 1566, 1522, 1609, 1650, 1611, 1603, 1639, 1547,
- /*   460 */  1574, 1659, 1664, 1667, 1561, 1569, 1668, 1622, 1671, 1672,
- /*   470 */  1665, 1673, 1624, 1670, 1674, 1630, 1662, 1677, 1559, 1681,
- /*   480 */  1682, 1549, 1684, 1685, 1683, 1688, 1690, 1692, 1691, 1695,
- /*   490 */  1694, 1585, 1698, 1705, 1617, 1696, 1707, 1596, 1709, 1697,
- /*   500 */  1702, 1704, 1711, 1652, 1675, 1658, 1708, 1676, 1656, 1714,
- /*   510 */  1726, 1731, 1730, 1729, 1733, 1722, 1734, 1709, 1737, 1738,
- /*   520 */  1742, 1743, 1741, 1745, 1747, 1759, 1749, 1750, 1752, 1753,
- /*   530 */  1751, 1755, 1757, 1660, 1653, 1655, 1657, 1661, 1761, 1777,
- /*   540 */  1792,
+ /*     0 */  1350, 1149, 1531,  939,  939,  548,  996, 1150, 1236, 1322,
+ /*    10 */  1322, 1322,  334,    0,    0,  178,  777, 1322, 1322, 1322,
+ /*    20 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*    30 */   991,  991, 1125, 1125,  447,  597,  548,  548,  548,  548,
+ /*    40 */   548,  548,   40,  108,  217,  284,  323,  390,  429,  496,
+ /*    50 */   535,  602,  641,  757,  777,  777,  777,  777,  777,  777,
+ /*    60 */   777,  777,  777,  777,  777,  777,  777,  777,  777,  777,
+ /*    70 */   777,  777,  796,  777,  887,  900,  900, 1300, 1322, 1322,
+ /*    80 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*    90 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*   100 */  1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*   110 */  1418, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
+ /*   120 */  1322, 1322, 1322, 1322,  147,  254,  254,  254,  254,  254,
+ /*   130 */    84,  185,   66,  853,  958, 1121,  853,   92,   92,  853,
+ /*   140 */   321,  321,  321,  321,  325,  350,  350,  461,  150, 1913,
+ /*   150 */  1913,  285,  285,  285,  236,  184,  349,  184,  184,  712,
+ /*   160 */   712,  433,  553,  771,  899,  853,  853,  853,  853,  853,
+ /*   170 */   853,  853,  853,  853,  853,  853,  853,  853,  853,  853,
+ /*   180 */   853,  853,  853,  853,  853,  853,   46,   46,  853,  113,
+ /*   190 */   223,  223, 1183, 1183, 1127, 1142, 1913, 1913, 1913,  459,
+ /*   200 */   514,  514,  653,  495,  657,  305,  705,  560,  622,  776,
+ /*   210 */   853,  853,  853,  853,  853,  853,  853,  853,  853,  545,
+ /*   220 */   853,  853,  853,  853,  853,  853,  853,  853,  853,  853,
+ /*   230 */   853,  853, 1002, 1002, 1002,  853,  853,  853,  853, 1111,
+ /*   240 */   853,  853,  853, 1006, 1109,  853,  853, 1168,  853,  853,
+ /*   250 */   853,  853,  853,  853,  853,  853,  845, 1164,  738,  953,
+ /*   260 */   953,  953,  953, 1196,  738,  738,   45,   96,  964,  179,
+ /*   270 */   580,  907,  907, 1073,  580,  580, 1073,  498,  388, 1268,
+ /*   280 */  1187, 1187, 1187,  907, 1170, 1170, 1058, 1180,  328, 1219,
+ /*   290 */  1597, 1521, 1521, 1625, 1625, 1521, 1524, 1560, 1650, 1630,
+ /*   300 */  1530, 1661, 1661, 1661, 1661, 1521, 1667, 1530, 1530, 1560,
+ /*   310 */  1650, 1630, 1630, 1530, 1521, 1667, 1543, 1636, 1521, 1667,
+ /*   320 */  1681, 1521, 1667, 1521, 1667, 1681, 1596, 1596, 1596, 1649,
+ /*   330 */  1681, 1596, 1594, 1596, 1649, 1596, 1596, 1562, 1681, 1611,
+ /*   340 */  1611, 1681, 1585, 1617, 1585, 1617, 1585, 1617, 1585, 1617,
+ /*   350 */  1521, 1647, 1647, 1659, 1659, 1601, 1606, 1726, 1521, 1600,
+ /*   360 */  1601, 1612, 1614, 1530, 1732, 1733, 1754, 1754, 1764, 1764,
+ /*   370 */  1764, 1913, 1913, 1913, 1913, 1913, 1913, 1913, 1913, 1913,
+ /*   380 */  1913, 1913, 1913, 1913, 1913, 1913,  673,  901,  283,  740,
+ /*   390 */   707,  973,  655, 1247, 1048, 1097, 1190, 1306, 1263, 1383,
+ /*   400 */  1395, 1432, 1469, 1473, 1497, 1279, 1200, 1323, 1075, 1286,
+ /*   410 */  1536, 1608, 1332, 1609, 1175, 1225, 1610, 1615, 1309, 1361,
+ /*   420 */  1777, 1784, 1766, 1633, 1778, 1696, 1779, 1771, 1773, 1662,
+ /*   430 */  1652, 1673, 1776, 1663, 1782, 1664, 1787, 1804, 1668, 1660,
+ /*   440 */  1682, 1748, 1774, 1666, 1757, 1760, 1761, 1763, 1691, 1706,
+ /*   450 */  1785, 1683, 1820, 1817, 1801, 1713, 1669, 1758, 1802, 1759,
+ /*   460 */  1755, 1788, 1694, 1721, 1809, 1814, 1816, 1709, 1716, 1818,
+ /*   470 */  1772, 1819, 1821, 1815, 1822, 1775, 1823, 1824, 1780, 1808,
+ /*   480 */  1825, 1704, 1828, 1829, 1830, 1831, 1832, 1833, 1835, 1836,
+ /*   490 */  1838, 1837, 1839, 1718, 1841, 1842, 1750, 1834, 1844, 1728,
+ /*   500 */  1843, 1840, 1845, 1846, 1847, 1783, 1795, 1786, 1848, 1798,
+ /*   510 */  1789, 1849, 1852, 1854, 1853, 1858, 1859, 1855, 1863, 1843,
+ /*   520 */  1864, 1865, 1867, 1868, 1869, 1870, 1856, 1883, 1874, 1875,
+ /*   530 */  1876, 1877, 1879, 1880, 1872, 1781, 1767, 1768, 1769, 1770,
+ /*   540 */  1885, 1888, 1908,
 };
-#define YY_REDUCE_COUNT (383)
-#define YY_REDUCE_MIN   (-257)
-#define YY_REDUCE_MAX   (1421)
+#define YY_REDUCE_COUNT (385)
+#define YY_REDUCE_MIN   (-256)
+#define YY_REDUCE_MAX   (1590)
 static const short yy_reduce_ofst[] = {
- /*     0 */  -168,  -17,  164,  214,  310, -166, -184,  -18,   98, -170,
- /*    10 */   305,  315, -163, -193, -178, -257,  395,  401,  476,  478,
- /*    20 */   512,  117,  527,  529,  503,  509,  532,  255,  552,  556,
- /*    30 */   558,  607,   37,  408,  594,  413,  462,  559,  561,  601,
- /*    40 */   610,  618, -254, -254, -254, -254, -254, -254, -254, -254,
- /*    50 */  -254, -254, -254, -254, -254, -254, -254, -254, -254, -254,
- /*    60 */  -254, -254, -254, -254, -254, -254, -254, -254, -254, -254,
- /*    70 */  -254, -254, -254, -254, -254, -254, -254, -111,  627,  650,
- /*    80 */   691,  697,  701,  703,  740,  742,  744,  767,  770,  790,
- /*    90 */   816,  818,  820,  822,  845,  857,  859,  861,  863,  865,
- /*   100 */   868,  870,  872,  874,  876,  888,  903,  906,  908,  915,
- /*   110 */   917,  922,  960,  962,  964,  988,  990,  992, 1015, 1017,
- /*   120 */  1029, 1033, 1035, 1040, -254, -254, -254, -254, -254, -254,
- /*   130 */  -254, -254, -254,  190,  270, -196,  160, -160,  450,  647,
- /*   140 */   260,  458,  260,  458,   78, -254, -254, -254, -254,  206,
- /*   150 */   206,  206,  320,  598,   -5,  675,  743, -148,  340, -125,
- /*   160 */   459,  466,  466,  693,  -93,  461,  479,  706,  710,  714,
- /*   170 */   716,  717,  169, -183,  325,  314,  704,  333,  747,  858,
- /*   180 */    -8,  819,  565,  755,  646,  660,  517,  265,  713,  791,
- /*   190 */   712,  795,  803,  918,  695,  860,  893,  935,  939, -181,
- /*   200 */  -172, -147,  -91,  -46,   -3,  162,  173,  231,  338,  437,
- /*   210 */   571,  614,  630,  651,  760,  931,  989, 1032, 1046, -218,
- /*   220 */    38, 1070, 1096, 1133, 1134, 1137, 1138, 1139, 1141, 1142,
- /*   230 */  1143, 1144,  292,  451, 1050, 1145, 1147, 1148, 1149,  813,
- /*   240 */  1161, 1162, 1163, 1108, 1049, 1166, 1168, 1146, 1169,  162,
- /*   250 */  1181, 1182, 1183, 1184, 1185, 1187, 1100, 1103, 1150, 1135,
- /*   260 */  1136, 1140, 1152,  813, 1150, 1150, 1153, 1173, 1195, 1090,
- /*   270 */  1154, 1167, 1170, 1104, 1155, 1156, 1109, 1172, 1174, 1179,
- /*   280 */  1177, 1188, 1205, 1171, 1160, 1196, 1121, 1165, 1203, 1228,
- /*   290 */  1157, 1244, 1245, 1158, 1159, 1250, 1175, 1193, 1191, 1241,
- /*   300 */  1231, 1243, 1257, 1259, 1261, 1276, 1280, 1254, 1255, 1230,
- /*   310 */  1234, 1269, 1270, 1260, 1292, 1303, 1223, 1225, 1309, 1313,
- /*   320 */  1296, 1317, 1319, 1320, 1323, 1300, 1307, 1308, 1310, 1304,
- /*   330 */  1311, 1315, 1314, 1318, 1316, 1321, 1325, 1324, 1271, 1272,
- /*   340 */  1332, 1294, 1298, 1299, 1301, 1302, 1306, 1312, 1329, 1356,
- /*   350 */  1256, 1263, 1327, 1326, 1305, 1369, 1330, 1340, 1343, 1346,
- /*   360 */  1350, 1391, 1394, 1410, 1412, 1415, 1417, 1419, 1328, 1331,
- /*   370 */  1335, 1402, 1398, 1400, 1401, 1403, 1408, 1396, 1397, 1409,
- /*   380 */  1414, 1420, 1421, 1413,
+ /*     0 */   880, -121,  269,  528,  933, -119, -187, -185, -182, -180,
+ /*    10 */  -176, -174,  -62,  -46,  131, -248, -133,  407,  568,  700,
+ /*    20 */   704,  278,  706,  824,  542,  830,  948,  773,  943,  946,
+ /*    30 */    71,  650,  211,  267,  826,  272,  676,  732,  885,  976,
+ /*    40 */   984,  992, -256, -256, -256, -256, -256, -256, -256, -256,
+ /*    50 */  -256, -256, -256, -256, -256, -256, -256, -256, -256, -256,
+ /*    60 */  -256, -256, -256, -256, -256, -256, -256, -256, -256, -256,
+ /*    70 */  -256, -256, -256, -256, -256, -256, -256,  989, 1065, 1070,
+ /*    80 */  1072, 1078, 1082, 1084, 1103, 1118, 1147, 1156, 1160, 1167,
+ /*    90 */  1185, 1191, 1220, 1237, 1254, 1256, 1266, 1272, 1281, 1291,
+ /*   100 */  1293, 1296, 1299, 1301, 1307, 1337, 1340, 1342, 1347, 1366,
+ /*   110 */  1368, 1371, 1373, 1377, 1385, 1387, 1398, 1401, 1404, 1406,
+ /*   120 */  1411, 1413, 1415, 1430, -256, -256, -256, -256, -256, -256,
+ /*   130 */  -256, -256, -256, -172,  508, -213,   57, -163,  -25,  593,
+ /*   140 */    69,  486,   69,  486, -200,  573,  722, -256, -256, -256,
+ /*   150 */  -256, -141, -141, -141, -105, -161, -167,  157,  212,  405,
+ /*   160 */   530,  220,  233,  735,  735,  115,  318,  406,  612,  541,
+ /*   170 */  -166,  441,  688,  794,  629,  368,  741,  775,  867,  797,
+ /*   180 */   871,  842, -186, 1000,  858,  949,  379,  783,   70,  296,
+ /*   190 */   821,  903,  924, 1044,  651,  282, 1014, 1060,  937, -195,
+ /*   200 */  -177,  413,  439,  511,  566,  787,  827,  848,  898,  945,
+ /*   210 */  1062, 1074, 1102, 1110, 1202, 1204, 1209, 1211, 1215,  529,
+ /*   220 */  1221, 1224, 1240, 1246, 1255, 1257, 1269, 1270, 1273, 1274,
+ /*   230 */  1275, 1280, 1205, 1251, 1294, 1310, 1317, 1326, 1327, 1124,
+ /*   240 */  1331, 1338, 1339, 1290, 1181, 1346, 1351, 1265, 1352,  787,
+ /*   250 */  1353, 1367, 1378, 1386, 1392, 1397, 1241, 1312, 1356, 1345,
+ /*   260 */  1357, 1358, 1359, 1124, 1356, 1356, 1364, 1396, 1433, 1341,
+ /*   270 */  1381, 1376, 1379, 1354, 1391, 1405, 1362, 1429, 1423, 1431,
+ /*   280 */  1434, 1435, 1437, 1399, 1410, 1412, 1382, 1417, 1420, 1466,
+ /*   290 */  1372, 1467, 1468, 1380, 1384, 1475, 1394, 1414, 1416, 1448,
+ /*   300 */  1440, 1451, 1452, 1453, 1454, 1490, 1493, 1449, 1455, 1427,
+ /*   310 */  1436, 1464, 1465, 1456, 1498, 1502, 1419, 1421, 1507, 1509,
+ /*   320 */  1491, 1510, 1513, 1514, 1516, 1496, 1500, 1501, 1503, 1499,
+ /*   330 */  1505, 1504, 1508, 1506, 1511, 1512, 1515, 1424, 1517, 1457,
+ /*   340 */  1460, 1519, 1474, 1482, 1483, 1485, 1486, 1488, 1489, 1492,
+ /*   350 */  1541, 1438, 1441, 1494, 1495, 1518, 1520, 1487, 1555, 1481,
+ /*   360 */  1522, 1523, 1526, 1528, 1561, 1566, 1580, 1581, 1586, 1587,
+ /*   370 */  1588, 1478, 1484, 1525, 1575, 1570, 1572, 1573, 1574, 1582,
+ /*   380 */  1568, 1569, 1578, 1579, 1583, 1590,
 };
 static const YYACTIONTYPE yy_default[] = {
- /*     0 */  1536, 1536, 1536, 1376, 1159, 1265, 1159, 1159, 1159, 1376,
- /*    10 */  1376, 1376, 1159, 1295, 1295, 1429, 1190, 1159, 1159, 1159,
- /*    20 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1375, 1159, 1159,
- /*    30 */  1159, 1159, 1459, 1459, 1159, 1159, 1159, 1159, 1159, 1159,
- /*    40 */  1159, 1159, 1159, 1301, 1159, 1159, 1159, 1159, 1159, 1377,
- /*    50 */  1378, 1159, 1159, 1159, 1428, 1430, 1393, 1311, 1310, 1309,
- /*    60 */  1308, 1411, 1282, 1306, 1299, 1303, 1371, 1372, 1370, 1374,
- /*    70 */  1378, 1377, 1159, 1302, 1342, 1356, 1341, 1159, 1159, 1159,
- /*    80 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*    90 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   100 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   110 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   120 */  1159, 1159, 1159, 1159, 1350, 1355, 1361, 1354, 1351, 1344,
- /*   130 */  1343, 1345, 1346, 1159, 1180, 1229, 1159, 1159, 1159, 1159,
- /*   140 */  1447, 1446, 1159, 1159, 1190, 1347, 1348, 1358, 1357, 1436,
- /*   150 */  1492, 1491, 1394, 1159, 1159, 1159, 1159, 1159, 1159, 1459,
- /*   160 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   170 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   180 */  1159, 1159, 1159, 1159, 1459, 1459, 1159, 1190, 1459, 1459,
- /*   190 */  1186, 1336, 1335, 1186, 1289, 1159, 1442, 1265, 1256, 1159,
- /*   200 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   210 */  1159, 1159, 1159, 1433, 1431, 1159, 1159, 1159, 1159, 1159,
- /*   220 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   230 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   240 */  1159, 1159, 1159, 1261, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   250 */  1159, 1159, 1159, 1159, 1159, 1486, 1159, 1406, 1243, 1261,
- /*   260 */  1261, 1261, 1261, 1263, 1244, 1242, 1255, 1190, 1166, 1528,
- /*   270 */  1305, 1284, 1284, 1525, 1305, 1305, 1525, 1204, 1506, 1201,
- /*   280 */  1295, 1295, 1295, 1284, 1289, 1289, 1373, 1262, 1255, 1159,
- /*   290 */  1528, 1270, 1270, 1527, 1527, 1270, 1394, 1314, 1320, 1232,
- /*   300 */  1305, 1238, 1238, 1238, 1238, 1270, 1177, 1305, 1305, 1314,
- /*   310 */  1320, 1232, 1232, 1305, 1270, 1177, 1410, 1522, 1270, 1177,
- /*   320 */  1384, 1270, 1177, 1270, 1177, 1384, 1230, 1230, 1230, 1219,
- /*   330 */  1384, 1230, 1204, 1230, 1219, 1230, 1230, 1384, 1388, 1388,
- /*   340 */  1384, 1288, 1283, 1288, 1283, 1288, 1283, 1288, 1283, 1270,
- /*   350 */  1469, 1469, 1300, 1289, 1379, 1270, 1159, 1300, 1298, 1296,
- /*   360 */  1305, 1183, 1222, 1489, 1489, 1485, 1485, 1485, 1533, 1533,
- /*   370 */  1442, 1501, 1190, 1190, 1190, 1190, 1501, 1206, 1206, 1190,
- /*   380 */  1190, 1190, 1190, 1501, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   390 */  1496, 1159, 1395, 1274, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   400 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   410 */  1159, 1159, 1159, 1159, 1159, 1159, 1325, 1159, 1162, 1439,
- /*   420 */  1159, 1159, 1437, 1159, 1159, 1159, 1159, 1159, 1159, 1275,
- /*   430 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   440 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1524, 1159,
- /*   450 */  1159, 1159, 1159, 1159, 1159, 1409, 1408, 1159, 1159, 1272,
- /*   460 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   470 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   480 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   490 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1297, 1159,
- /*   500 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   510 */  1159, 1159, 1159, 1474, 1290, 1159, 1159, 1515, 1159, 1159,
- /*   520 */  1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1159,
- /*   530 */  1159, 1159, 1510, 1246, 1327, 1159, 1326, 1330, 1159, 1171,
- /*   540 */  1159,
+ /*     0 */  1554, 1554, 1554, 1392, 1171, 1278, 1171, 1171, 1171, 1392,
+ /*    10 */  1392, 1392, 1171, 1308, 1308, 1445, 1202, 1171, 1171, 1171,
+ /*    20 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1391, 1171, 1171,
+ /*    30 */  1171, 1171, 1475, 1475, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*    40 */  1171, 1171, 1171, 1317, 1171, 1171, 1171, 1171, 1171, 1393,
+ /*    50 */  1394, 1171, 1171, 1171, 1444, 1446, 1409, 1327, 1326, 1325,
+ /*    60 */  1324, 1427, 1295, 1322, 1315, 1319, 1387, 1388, 1386, 1390,
+ /*    70 */  1394, 1393, 1171, 1318, 1358, 1372, 1357, 1171, 1171, 1171,
+ /*    80 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*    90 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   100 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   110 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   120 */  1171, 1171, 1171, 1171, 1366, 1371, 1377, 1370, 1367, 1360,
+ /*   130 */  1359, 1361, 1362, 1171, 1192, 1242, 1171, 1171, 1171, 1171,
+ /*   140 */  1463, 1462, 1171, 1171, 1202, 1352, 1351, 1363, 1364, 1374,
+ /*   150 */  1373, 1452, 1510, 1509, 1410, 1171, 1171, 1171, 1171, 1171,
+ /*   160 */  1171, 1475, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   170 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   180 */  1171, 1171, 1171, 1171, 1171, 1171, 1475, 1475, 1171, 1202,
+ /*   190 */  1475, 1475, 1198, 1198, 1302, 1171, 1458, 1278, 1269, 1171,
+ /*   200 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   210 */  1171, 1171, 1171, 1449, 1447, 1171, 1171, 1171, 1171, 1171,
+ /*   220 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   230 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   240 */  1171, 1171, 1171, 1274, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   250 */  1171, 1171, 1171, 1171, 1171, 1504, 1171, 1422, 1256, 1274,
+ /*   260 */  1274, 1274, 1274, 1276, 1257, 1255, 1268, 1203, 1178, 1546,
+ /*   270 */  1321, 1297, 1297, 1543, 1321, 1321, 1543, 1217, 1524, 1214,
+ /*   280 */  1308, 1308, 1308, 1297, 1302, 1302, 1389, 1275, 1268, 1171,
+ /*   290 */  1546, 1283, 1283, 1545, 1545, 1283, 1410, 1330, 1336, 1245,
+ /*   300 */  1321, 1251, 1251, 1251, 1251, 1283, 1189, 1321, 1321, 1330,
+ /*   310 */  1336, 1245, 1245, 1321, 1283, 1189, 1426, 1540, 1283, 1189,
+ /*   320 */  1400, 1283, 1189, 1283, 1189, 1400, 1243, 1243, 1243, 1232,
+ /*   330 */  1400, 1243, 1217, 1243, 1232, 1243, 1243, 1493, 1400, 1404,
+ /*   340 */  1404, 1400, 1301, 1296, 1301, 1296, 1301, 1296, 1301, 1296,
+ /*   350 */  1283, 1485, 1485, 1311, 1311, 1316, 1302, 1395, 1283, 1171,
+ /*   360 */  1316, 1314, 1312, 1321, 1195, 1235, 1507, 1507, 1503, 1503,
+ /*   370 */  1503, 1551, 1551, 1458, 1519, 1202, 1202, 1202, 1202, 1519,
+ /*   380 */  1219, 1219, 1203, 1203, 1202, 1519, 1171, 1171, 1171, 1171,
+ /*   390 */  1171, 1171, 1514, 1171, 1411, 1287, 1171, 1171, 1171, 1171,
+ /*   400 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   410 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1341,
+ /*   420 */  1171, 1174, 1455, 1171, 1171, 1453, 1171, 1171, 1171, 1171,
+ /*   430 */  1171, 1171, 1288, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   440 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   450 */  1171, 1542, 1171, 1171, 1171, 1171, 1171, 1171, 1425, 1424,
+ /*   460 */  1171, 1171, 1285, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   470 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   480 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   490 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   500 */  1313, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   510 */  1171, 1171, 1171, 1171, 1171, 1490, 1303, 1171, 1171, 1533,
+ /*   520 */  1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
+ /*   530 */  1171, 1171, 1171, 1171, 1528, 1259, 1343, 1171, 1342, 1346,
+ /*   540 */  1171, 1183, 1171,
 };
 /********** End of lemon-generated parsing tables *****************************/
 
 /* The next table maps tokens (terminal symbols) into fallback tokens.
 ** If a construct like the following:
@@ -149175,10 +150690,13 @@
    59,  /*    TRIGGER => ID */
    59,  /*     VACUUM => ID */
    59,  /*       VIEW => ID */
    59,  /*    VIRTUAL => ID */
    59,  /*       WITH => ID */
+   59,  /*      NULLS => ID */
+   59,  /*      FIRST => ID */
+   59,  /*       LAST => ID */
    59,  /*    CURRENT => ID */
    59,  /*  FOLLOWING => ID */
    59,  /*  PARTITION => ID */
    59,  /*  PRECEDING => ID */
    59,  /*      RANGE => ID */
@@ -149188,10 +150706,91 @@
    59,  /*     OTHERS => ID */
    59,  /*       TIES => ID */
    59,  /*    REINDEX => ID */
    59,  /*     RENAME => ID */
    59,  /*   CTIME_KW => ID */
+    0,  /*        ANY => nothing */
+    0,  /*     BITAND => nothing */
+    0,  /*      BITOR => nothing */
+    0,  /*     LSHIFT => nothing */
+    0,  /*     RSHIFT => nothing */
+    0,  /*       PLUS => nothing */
+    0,  /*      MINUS => nothing */
+    0,  /*       STAR => nothing */
+    0,  /*      SLASH => nothing */
+    0,  /*        REM => nothing */
+    0,  /*     CONCAT => nothing */
+    0,  /*    COLLATE => nothing */
+    0,  /*     BITNOT => nothing */
+    0,  /*         ON => nothing */
+    0,  /*    INDEXED => nothing */
+    0,  /*     STRING => nothing */
+    0,  /*    JOIN_KW => nothing */
+    0,  /* CONSTRAINT => nothing */
+    0,  /*    DEFAULT => nothing */
+    0,  /*       NULL => nothing */
+    0,  /*    PRIMARY => nothing */
+    0,  /*     UNIQUE => nothing */
+    0,  /*      CHECK => nothing */
+    0,  /* REFERENCES => nothing */
+    0,  /*   AUTOINCR => nothing */
+    0,  /*     INSERT => nothing */
+    0,  /*     DELETE => nothing */
+    0,  /*     UPDATE => nothing */
+    0,  /*        SET => nothing */
+    0,  /* DEFERRABLE => nothing */
+    0,  /*    FOREIGN => nothing */
+    0,  /*       DROP => nothing */
+    0,  /*      UNION => nothing */
+    0,  /*        ALL => nothing */
+    0,  /*     EXCEPT => nothing */
+    0,  /*  INTERSECT => nothing */
+    0,  /*     SELECT => nothing */
+    0,  /*     VALUES => nothing */
+    0,  /*   DISTINCT => nothing */
+    0,  /*        DOT => nothing */
+    0,  /*       FROM => nothing */
+    0,  /*       JOIN => nothing */
+    0,  /*      USING => nothing */
+    0,  /*      ORDER => nothing */
+    0,  /*      GROUP => nothing */
+    0,  /*     HAVING => nothing */
+    0,  /*      LIMIT => nothing */
+    0,  /*      WHERE => nothing */
+    0,  /*       INTO => nothing */
+    0,  /*    NOTHING => nothing */
+    0,  /*      FLOAT => nothing */
+    0,  /*       BLOB => nothing */
+    0,  /*    INTEGER => nothing */
+    0,  /*   VARIABLE => nothing */
+    0,  /*       CASE => nothing */
+    0,  /*       WHEN => nothing */
+    0,  /*       THEN => nothing */
+    0,  /*       ELSE => nothing */
+    0,  /*      INDEX => nothing */
+    0,  /*      ALTER => nothing */
+    0,  /*        ADD => nothing */
+    0,  /*     WINDOW => nothing */
+    0,  /*       OVER => nothing */
+    0,  /*     FILTER => nothing */
+    0,  /*     COLUMN => nothing */
+    0,  /* AGG_FUNCTION => nothing */
+    0,  /* AGG_COLUMN => nothing */
+    0,  /*  TRUEFALSE => nothing */
+    0,  /*      ISNOT => nothing */
+    0,  /*   FUNCTION => nothing */
+    0,  /*     UMINUS => nothing */
+    0,  /*      UPLUS => nothing */
+    0,  /*      TRUTH => nothing */
+    0,  /*   REGISTER => nothing */
+    0,  /*     VECTOR => nothing */
+    0,  /* SELECT_COLUMN => nothing */
+    0,  /* IF_NULL_ROW => nothing */
+    0,  /*   ASTERISK => nothing */
+    0,  /*       SPAN => nothing */
+    0,  /*      SPACE => nothing */
+    0,  /*    ILLEGAL => nothing */
 };
 #endif /* YYFALLBACK */
 
 /* The following structure represents a single element of the
 ** parser's stack.  Information stored includes:
@@ -149357,229 +150956,235 @@
   /*   77 */ "TRIGGER",
   /*   78 */ "VACUUM",
   /*   79 */ "VIEW",
   /*   80 */ "VIRTUAL",
   /*   81 */ "WITH",
-  /*   82 */ "CURRENT",
-  /*   83 */ "FOLLOWING",
-  /*   84 */ "PARTITION",
-  /*   85 */ "PRECEDING",
-  /*   86 */ "RANGE",
-  /*   87 */ "UNBOUNDED",
-  /*   88 */ "EXCLUDE",
-  /*   89 */ "GROUPS",
-  /*   90 */ "OTHERS",
-  /*   91 */ "TIES",
-  /*   92 */ "REINDEX",
-  /*   93 */ "RENAME",
-  /*   94 */ "CTIME_KW",
-  /*   95 */ "ANY",
-  /*   96 */ "BITAND",
-  /*   97 */ "BITOR",
-  /*   98 */ "LSHIFT",
-  /*   99 */ "RSHIFT",
-  /*  100 */ "PLUS",
-  /*  101 */ "MINUS",
-  /*  102 */ "STAR",
-  /*  103 */ "SLASH",
-  /*  104 */ "REM",
-  /*  105 */ "CONCAT",
-  /*  106 */ "COLLATE",
-  /*  107 */ "BITNOT",
-  /*  108 */ "ON",
-  /*  109 */ "INDEXED",
-  /*  110 */ "STRING",
-  /*  111 */ "JOIN_KW",
-  /*  112 */ "CONSTRAINT",
-  /*  113 */ "DEFAULT",
-  /*  114 */ "NULL",
-  /*  115 */ "PRIMARY",
-  /*  116 */ "UNIQUE",
-  /*  117 */ "CHECK",
-  /*  118 */ "REFERENCES",
-  /*  119 */ "AUTOINCR",
-  /*  120 */ "INSERT",
-  /*  121 */ "DELETE",
-  /*  122 */ "UPDATE",
-  /*  123 */ "SET",
-  /*  124 */ "DEFERRABLE",
-  /*  125 */ "FOREIGN",
-  /*  126 */ "DROP",
-  /*  127 */ "UNION",
-  /*  128 */ "ALL",
-  /*  129 */ "EXCEPT",
-  /*  130 */ "INTERSECT",
-  /*  131 */ "SELECT",
-  /*  132 */ "VALUES",
-  /*  133 */ "DISTINCT",
-  /*  134 */ "DOT",
-  /*  135 */ "FROM",
-  /*  136 */ "JOIN",
-  /*  137 */ "USING",
-  /*  138 */ "ORDER",
-  /*  139 */ "GROUP",
-  /*  140 */ "HAVING",
-  /*  141 */ "LIMIT",
-  /*  142 */ "WHERE",
-  /*  143 */ "INTO",
-  /*  144 */ "NOTHING",
-  /*  145 */ "FLOAT",
-  /*  146 */ "BLOB",
-  /*  147 */ "INTEGER",
-  /*  148 */ "VARIABLE",
-  /*  149 */ "CASE",
-  /*  150 */ "WHEN",
-  /*  151 */ "THEN",
-  /*  152 */ "ELSE",
-  /*  153 */ "INDEX",
-  /*  154 */ "ALTER",
-  /*  155 */ "ADD",
-  /*  156 */ "WINDOW",
-  /*  157 */ "OVER",
-  /*  158 */ "FILTER",
-  /*  159 */ "TRUEFALSE",
-  /*  160 */ "ISNOT",
-  /*  161 */ "FUNCTION",
+  /*   82 */ "NULLS",
+  /*   83 */ "FIRST",
+  /*   84 */ "LAST",
+  /*   85 */ "CURRENT",
+  /*   86 */ "FOLLOWING",
+  /*   87 */ "PARTITION",
+  /*   88 */ "PRECEDING",
+  /*   89 */ "RANGE",
+  /*   90 */ "UNBOUNDED",
+  /*   91 */ "EXCLUDE",
+  /*   92 */ "GROUPS",
+  /*   93 */ "OTHERS",
+  /*   94 */ "TIES",
+  /*   95 */ "REINDEX",
+  /*   96 */ "RENAME",
+  /*   97 */ "CTIME_KW",
+  /*   98 */ "ANY",
+  /*   99 */ "BITAND",
+  /*  100 */ "BITOR",
+  /*  101 */ "LSHIFT",
+  /*  102 */ "RSHIFT",
+  /*  103 */ "PLUS",
+  /*  104 */ "MINUS",
+  /*  105 */ "STAR",
+  /*  106 */ "SLASH",
+  /*  107 */ "REM",
+  /*  108 */ "CONCAT",
+  /*  109 */ "COLLATE",
+  /*  110 */ "BITNOT",
+  /*  111 */ "ON",
+  /*  112 */ "INDEXED",
+  /*  113 */ "STRING",
+  /*  114 */ "JOIN_KW",
+  /*  115 */ "CONSTRAINT",
+  /*  116 */ "DEFAULT",
+  /*  117 */ "NULL",
+  /*  118 */ "PRIMARY",
+  /*  119 */ "UNIQUE",
+  /*  120 */ "CHECK",
+  /*  121 */ "REFERENCES",
+  /*  122 */ "AUTOINCR",
+  /*  123 */ "INSERT",
+  /*  124 */ "DELETE",
+  /*  125 */ "UPDATE",
+  /*  126 */ "SET",
+  /*  127 */ "DEFERRABLE",
+  /*  128 */ "FOREIGN",
+  /*  129 */ "DROP",
+  /*  130 */ "UNION",
+  /*  131 */ "ALL",
+  /*  132 */ "EXCEPT",
+  /*  133 */ "INTERSECT",
+  /*  134 */ "SELECT",
+  /*  135 */ "VALUES",
+  /*  136 */ "DISTINCT",
+  /*  137 */ "DOT",
+  /*  138 */ "FROM",
+  /*  139 */ "JOIN",
+  /*  140 */ "USING",
+  /*  141 */ "ORDER",
+  /*  142 */ "GROUP",
+  /*  143 */ "HAVING",
+  /*  144 */ "LIMIT",
+  /*  145 */ "WHERE",
+  /*  146 */ "INTO",
+  /*  147 */ "NOTHING",
+  /*  148 */ "FLOAT",
+  /*  149 */ "BLOB",
+  /*  150 */ "INTEGER",
+  /*  151 */ "VARIABLE",
+  /*  152 */ "CASE",
+  /*  153 */ "WHEN",
+  /*  154 */ "THEN",
+  /*  155 */ "ELSE",
+  /*  156 */ "INDEX",
+  /*  157 */ "ALTER",
+  /*  158 */ "ADD",
+  /*  159 */ "WINDOW",
+  /*  160 */ "OVER",
+  /*  161 */ "FILTER",
   /*  162 */ "COLUMN",
   /*  163 */ "AGG_FUNCTION",
   /*  164 */ "AGG_COLUMN",
-  /*  165 */ "UMINUS",
-  /*  166 */ "UPLUS",
-  /*  167 */ "TRUTH",
-  /*  168 */ "REGISTER",
-  /*  169 */ "VECTOR",
-  /*  170 */ "SELECT_COLUMN",
-  /*  171 */ "IF_NULL_ROW",
-  /*  172 */ "ASTERISK",
-  /*  173 */ "SPAN",
-  /*  174 */ "SPACE",
-  /*  175 */ "ILLEGAL",
-  /*  176 */ "input",
-  /*  177 */ "cmdlist",
-  /*  178 */ "ecmd",
-  /*  179 */ "cmdx",
-  /*  180 */ "explain",
-  /*  181 */ "cmd",
-  /*  182 */ "transtype",
-  /*  183 */ "trans_opt",
-  /*  184 */ "nm",
-  /*  185 */ "savepoint_opt",
-  /*  186 */ "create_table",
-  /*  187 */ "create_table_args",
-  /*  188 */ "createkw",
-  /*  189 */ "temp",
-  /*  190 */ "ifnotexists",
-  /*  191 */ "dbnm",
-  /*  192 */ "columnlist",
-  /*  193 */ "conslist_opt",
-  /*  194 */ "table_options",
-  /*  195 */ "select",
-  /*  196 */ "columnname",
-  /*  197 */ "carglist",
-  /*  198 */ "typetoken",
-  /*  199 */ "typename",
-  /*  200 */ "signed",
-  /*  201 */ "plus_num",
-  /*  202 */ "minus_num",
-  /*  203 */ "scanpt",
-  /*  204 */ "ccons",
-  /*  205 */ "term",
-  /*  206 */ "expr",
-  /*  207 */ "onconf",
-  /*  208 */ "sortorder",
-  /*  209 */ "autoinc",
-  /*  210 */ "eidlist_opt",
-  /*  211 */ "refargs",
-  /*  212 */ "defer_subclause",
-  /*  213 */ "refarg",
-  /*  214 */ "refact",
-  /*  215 */ "init_deferred_pred_opt",
-  /*  216 */ "conslist",
-  /*  217 */ "tconscomma",
-  /*  218 */ "tcons",
-  /*  219 */ "sortlist",
-  /*  220 */ "eidlist",
-  /*  221 */ "defer_subclause_opt",
-  /*  222 */ "orconf",
-  /*  223 */ "resolvetype",
-  /*  224 */ "raisetype",
-  /*  225 */ "ifexists",
-  /*  226 */ "fullname",
-  /*  227 */ "selectnowith",
-  /*  228 */ "oneselect",
-  /*  229 */ "wqlist",
-  /*  230 */ "multiselect_op",
-  /*  231 */ "distinct",
-  /*  232 */ "selcollist",
-  /*  233 */ "from",
-  /*  234 */ "where_opt",
-  /*  235 */ "groupby_opt",
-  /*  236 */ "having_opt",
-  /*  237 */ "orderby_opt",
-  /*  238 */ "limit_opt",
-  /*  239 */ "window_clause",
-  /*  240 */ "values",
-  /*  241 */ "nexprlist",
-  /*  242 */ "sclp",
-  /*  243 */ "as",
-  /*  244 */ "seltablist",
-  /*  245 */ "stl_prefix",
-  /*  246 */ "joinop",
-  /*  247 */ "indexed_opt",
-  /*  248 */ "on_opt",
-  /*  249 */ "using_opt",
-  /*  250 */ "exprlist",
-  /*  251 */ "xfullname",
-  /*  252 */ "idlist",
-  /*  253 */ "with",
-  /*  254 */ "setlist",
-  /*  255 */ "insert_cmd",
-  /*  256 */ "idlist_opt",
-  /*  257 */ "upsert",
-  /*  258 */ "over_clause",
-  /*  259 */ "likeop",
-  /*  260 */ "between_op",
-  /*  261 */ "in_op",
-  /*  262 */ "paren_exprlist",
-  /*  263 */ "case_operand",
-  /*  264 */ "case_exprlist",
-  /*  265 */ "case_else",
-  /*  266 */ "uniqueflag",
-  /*  267 */ "collate",
-  /*  268 */ "vinto",
-  /*  269 */ "nmnum",
-  /*  270 */ "trigger_decl",
-  /*  271 */ "trigger_cmd_list",
-  /*  272 */ "trigger_time",
-  /*  273 */ "trigger_event",
-  /*  274 */ "foreach_clause",
-  /*  275 */ "when_clause",
-  /*  276 */ "trigger_cmd",
-  /*  277 */ "trnm",
-  /*  278 */ "tridxby",
-  /*  279 */ "database_kw_opt",
-  /*  280 */ "key_opt",
-  /*  281 */ "add_column_fullname",
-  /*  282 */ "kwcolumn_opt",
-  /*  283 */ "create_vtab",
-  /*  284 */ "vtabarglist",
-  /*  285 */ "vtabarg",
-  /*  286 */ "vtabargtoken",
-  /*  287 */ "lp",
-  /*  288 */ "anylist",
-  /*  289 */ "windowdefn_list",
-  /*  290 */ "windowdefn",
-  /*  291 */ "window",
-  /*  292 */ "frame_opt",
-  /*  293 */ "part_opt",
-  /*  294 */ "filter_opt",
-  /*  295 */ "range_or_rows",
-  /*  296 */ "frame_bound",
-  /*  297 */ "frame_bound_s",
-  /*  298 */ "frame_bound_e",
-  /*  299 */ "frame_exclude_opt",
-  /*  300 */ "frame_exclude",
+  /*  165 */ "TRUEFALSE",
+  /*  166 */ "ISNOT",
+  /*  167 */ "FUNCTION",
+  /*  168 */ "UMINUS",
+  /*  169 */ "UPLUS",
+  /*  170 */ "TRUTH",
+  /*  171 */ "REGISTER",
+  /*  172 */ "VECTOR",
+  /*  173 */ "SELECT_COLUMN",
+  /*  174 */ "IF_NULL_ROW",
+  /*  175 */ "ASTERISK",
+  /*  176 */ "SPAN",
+  /*  177 */ "SPACE",
+  /*  178 */ "ILLEGAL",
+  /*  179 */ "input",
+  /*  180 */ "cmdlist",
+  /*  181 */ "ecmd",
+  /*  182 */ "cmdx",
+  /*  183 */ "explain",
+  /*  184 */ "cmd",
+  /*  185 */ "transtype",
+  /*  186 */ "trans_opt",
+  /*  187 */ "nm",
+  /*  188 */ "savepoint_opt",
+  /*  189 */ "create_table",
+  /*  190 */ "create_table_args",
+  /*  191 */ "createkw",
+  /*  192 */ "temp",
+  /*  193 */ "ifnotexists",
+  /*  194 */ "dbnm",
+  /*  195 */ "columnlist",
+  /*  196 */ "conslist_opt",
+  /*  197 */ "table_options",
+  /*  198 */ "select",
+  /*  199 */ "columnname",
+  /*  200 */ "carglist",
+  /*  201 */ "typetoken",
+  /*  202 */ "typename",
+  /*  203 */ "signed",
+  /*  204 */ "plus_num",
+  /*  205 */ "minus_num",
+  /*  206 */ "scanpt",
+  /*  207 */ "scantok",
+  /*  208 */ "ccons",
+  /*  209 */ "term",
+  /*  210 */ "expr",
+  /*  211 */ "onconf",
+  /*  212 */ "sortorder",
+  /*  213 */ "autoinc",
+  /*  214 */ "eidlist_opt",
+  /*  215 */ "refargs",
+  /*  216 */ "defer_subclause",
+  /*  217 */ "refarg",
+  /*  218 */ "refact",
+  /*  219 */ "init_deferred_pred_opt",
+  /*  220 */ "conslist",
+  /*  221 */ "tconscomma",
+  /*  222 */ "tcons",
+  /*  223 */ "sortlist",
+  /*  224 */ "eidlist",
+  /*  225 */ "defer_subclause_opt",
+  /*  226 */ "orconf",
+  /*  227 */ "resolvetype",
+  /*  228 */ "raisetype",
+  /*  229 */ "ifexists",
+  /*  230 */ "fullname",
+  /*  231 */ "selectnowith",
+  /*  232 */ "oneselect",
+  /*  233 */ "wqlist",
+  /*  234 */ "multiselect_op",
+  /*  235 */ "distinct",
+  /*  236 */ "selcollist",
+  /*  237 */ "from",
+  /*  238 */ "where_opt",
+  /*  239 */ "groupby_opt",
+  /*  240 */ "having_opt",
+  /*  241 */ "orderby_opt",
+  /*  242 */ "limit_opt",
+  /*  243 */ "window_clause",
+  /*  244 */ "values",
+  /*  245 */ "nexprlist",
+  /*  246 */ "sclp",
+  /*  247 */ "as",
+  /*  248 */ "seltablist",
+  /*  249 */ "stl_prefix",
+  /*  250 */ "joinop",
+  /*  251 */ "indexed_opt",
+  /*  252 */ "on_opt",
+  /*  253 */ "using_opt",
+  /*  254 */ "exprlist",
+  /*  255 */ "xfullname",
+  /*  256 */ "idlist",
+  /*  257 */ "nulls",
+  /*  258 */ "with",
+  /*  259 */ "setlist",
+  /*  260 */ "insert_cmd",
+  /*  261 */ "idlist_opt",
+  /*  262 */ "upsert",
+  /*  263 */ "filter_over",
+  /*  264 */ "likeop",
+  /*  265 */ "between_op",
+  /*  266 */ "in_op",
+  /*  267 */ "paren_exprlist",
+  /*  268 */ "case_operand",
+  /*  269 */ "case_exprlist",
+  /*  270 */ "case_else",
+  /*  271 */ "uniqueflag",
+  /*  272 */ "collate",
+  /*  273 */ "vinto",
+  /*  274 */ "nmnum",
+  /*  275 */ "trigger_decl",
+  /*  276 */ "trigger_cmd_list",
+  /*  277 */ "trigger_time",
+  /*  278 */ "trigger_event",
+  /*  279 */ "foreach_clause",
+  /*  280 */ "when_clause",
+  /*  281 */ "trigger_cmd",
+  /*  282 */ "trnm",
+  /*  283 */ "tridxby",
+  /*  284 */ "database_kw_opt",
+  /*  285 */ "key_opt",
+  /*  286 */ "add_column_fullname",
+  /*  287 */ "kwcolumn_opt",
+  /*  288 */ "create_vtab",
+  /*  289 */ "vtabarglist",
+  /*  290 */ "vtabarg",
+  /*  291 */ "vtabargtoken",
+  /*  292 */ "lp",
+  /*  293 */ "anylist",
+  /*  294 */ "windowdefn_list",
+  /*  295 */ "windowdefn",
+  /*  296 */ "window",
+  /*  297 */ "frame_opt",
+  /*  298 */ "part_opt",
+  /*  299 */ "filter_clause",
+  /*  300 */ "over_clause",
+  /*  301 */ "range_or_rows",
+  /*  302 */ "frame_bound",
+  /*  303 */ "frame_bound_s",
+  /*  304 */ "frame_bound_e",
+  /*  305 */ "frame_exclude_opt",
+  /*  306 */ "frame_exclude",
 };
 #endif /* defined(YYCOVERAGE) || !defined(NDEBUG) */
 
 #ifndef NDEBUG
 /* For tracing reduce actions, the names of all rules are required.
@@ -149612,356 +151217,362 @@
  /*  24 */ "typetoken ::=",
  /*  25 */ "typetoken ::= typename LP signed RP",
  /*  26 */ "typetoken ::= typename LP signed COMMA signed RP",
  /*  27 */ "typename ::= typename ID|STRING",
  /*  28 */ "scanpt ::=",
- /*  29 */ "ccons ::= CONSTRAINT nm",
- /*  30 */ "ccons ::= DEFAULT scanpt term scanpt",
- /*  31 */ "ccons ::= DEFAULT LP expr RP",
- /*  32 */ "ccons ::= DEFAULT PLUS term scanpt",
- /*  33 */ "ccons ::= DEFAULT MINUS term scanpt",
- /*  34 */ "ccons ::= DEFAULT scanpt ID|INDEXED",
- /*  35 */ "ccons ::= NOT NULL onconf",
- /*  36 */ "ccons ::= PRIMARY KEY sortorder onconf autoinc",
- /*  37 */ "ccons ::= UNIQUE onconf",
- /*  38 */ "ccons ::= CHECK LP expr RP",
- /*  39 */ "ccons ::= REFERENCES nm eidlist_opt refargs",
- /*  40 */ "ccons ::= defer_subclause",
- /*  41 */ "ccons ::= COLLATE ID|STRING",
- /*  42 */ "autoinc ::=",
- /*  43 */ "autoinc ::= AUTOINCR",
- /*  44 */ "refargs ::=",
- /*  45 */ "refargs ::= refargs refarg",
- /*  46 */ "refarg ::= MATCH nm",
- /*  47 */ "refarg ::= ON INSERT refact",
- /*  48 */ "refarg ::= ON DELETE refact",
- /*  49 */ "refarg ::= ON UPDATE refact",
- /*  50 */ "refact ::= SET NULL",
- /*  51 */ "refact ::= SET DEFAULT",
- /*  52 */ "refact ::= CASCADE",
- /*  53 */ "refact ::= RESTRICT",
- /*  54 */ "refact ::= NO ACTION",
- /*  55 */ "defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt",
- /*  56 */ "defer_subclause ::= DEFERRABLE init_deferred_pred_opt",
- /*  57 */ "init_deferred_pred_opt ::=",
- /*  58 */ "init_deferred_pred_opt ::= INITIALLY DEFERRED",
- /*  59 */ "init_deferred_pred_opt ::= INITIALLY IMMEDIATE",
- /*  60 */ "conslist_opt ::=",
- /*  61 */ "tconscomma ::= COMMA",
- /*  62 */ "tcons ::= CONSTRAINT nm",
- /*  63 */ "tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf",
- /*  64 */ "tcons ::= UNIQUE LP sortlist RP onconf",
- /*  65 */ "tcons ::= CHECK LP expr RP onconf",
- /*  66 */ "tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt",
- /*  67 */ "defer_subclause_opt ::=",
- /*  68 */ "onconf ::=",
- /*  69 */ "onconf ::= ON CONFLICT resolvetype",
- /*  70 */ "orconf ::=",
- /*  71 */ "orconf ::= OR resolvetype",
- /*  72 */ "resolvetype ::= IGNORE",
- /*  73 */ "resolvetype ::= REPLACE",
- /*  74 */ "cmd ::= DROP TABLE ifexists fullname",
- /*  75 */ "ifexists ::= IF EXISTS",
- /*  76 */ "ifexists ::=",
- /*  77 */ "cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select",
- /*  78 */ "cmd ::= DROP VIEW ifexists fullname",
- /*  79 */ "cmd ::= select",
- /*  80 */ "select ::= WITH wqlist selectnowith",
- /*  81 */ "select ::= WITH RECURSIVE wqlist selectnowith",
- /*  82 */ "select ::= selectnowith",
- /*  83 */ "selectnowith ::= selectnowith multiselect_op oneselect",
- /*  84 */ "multiselect_op ::= UNION",
- /*  85 */ "multiselect_op ::= UNION ALL",
- /*  86 */ "multiselect_op ::= EXCEPT|INTERSECT",
- /*  87 */ "oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt",
- /*  88 */ "oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt",
- /*  89 */ "values ::= VALUES LP nexprlist RP",
- /*  90 */ "values ::= values COMMA LP nexprlist RP",
- /*  91 */ "distinct ::= DISTINCT",
- /*  92 */ "distinct ::= ALL",
- /*  93 */ "distinct ::=",
- /*  94 */ "sclp ::=",
- /*  95 */ "selcollist ::= sclp scanpt expr scanpt as",
- /*  96 */ "selcollist ::= sclp scanpt STAR",
- /*  97 */ "selcollist ::= sclp scanpt nm DOT STAR",
- /*  98 */ "as ::= AS nm",
- /*  99 */ "as ::=",
- /* 100 */ "from ::=",
- /* 101 */ "from ::= FROM seltablist",
- /* 102 */ "stl_prefix ::= seltablist joinop",
- /* 103 */ "stl_prefix ::=",
- /* 104 */ "seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt",
- /* 105 */ "seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt",
- /* 106 */ "seltablist ::= stl_prefix LP select RP as on_opt using_opt",
- /* 107 */ "seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt",
- /* 108 */ "dbnm ::=",
- /* 109 */ "dbnm ::= DOT nm",
- /* 110 */ "fullname ::= nm",
- /* 111 */ "fullname ::= nm DOT nm",
- /* 112 */ "xfullname ::= nm",
- /* 113 */ "xfullname ::= nm DOT nm",
- /* 114 */ "xfullname ::= nm DOT nm AS nm",
- /* 115 */ "xfullname ::= nm AS nm",
- /* 116 */ "joinop ::= COMMA|JOIN",
- /* 117 */ "joinop ::= JOIN_KW JOIN",
- /* 118 */ "joinop ::= JOIN_KW nm JOIN",
- /* 119 */ "joinop ::= JOIN_KW nm nm JOIN",
- /* 120 */ "on_opt ::= ON expr",
- /* 121 */ "on_opt ::=",
- /* 122 */ "indexed_opt ::=",
- /* 123 */ "indexed_opt ::= INDEXED BY nm",
- /* 124 */ "indexed_opt ::= NOT INDEXED",
- /* 125 */ "using_opt ::= USING LP idlist RP",
- /* 126 */ "using_opt ::=",
- /* 127 */ "orderby_opt ::=",
- /* 128 */ "orderby_opt ::= ORDER BY sortlist",
- /* 129 */ "sortlist ::= sortlist COMMA expr sortorder",
- /* 130 */ "sortlist ::= expr sortorder",
- /* 131 */ "sortorder ::= ASC",
- /* 132 */ "sortorder ::= DESC",
- /* 133 */ "sortorder ::=",
- /* 134 */ "groupby_opt ::=",
- /* 135 */ "groupby_opt ::= GROUP BY nexprlist",
- /* 136 */ "having_opt ::=",
- /* 137 */ "having_opt ::= HAVING expr",
- /* 138 */ "limit_opt ::=",
- /* 139 */ "limit_opt ::= LIMIT expr",
- /* 140 */ "limit_opt ::= LIMIT expr OFFSET expr",
- /* 141 */ "limit_opt ::= LIMIT expr COMMA expr",
- /* 142 */ "cmd ::= with DELETE FROM xfullname indexed_opt where_opt",
- /* 143 */ "where_opt ::=",
- /* 144 */ "where_opt ::= WHERE expr",
- /* 145 */ "cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt",
- /* 146 */ "setlist ::= setlist COMMA nm EQ expr",
- /* 147 */ "setlist ::= setlist COMMA LP idlist RP EQ expr",
- /* 148 */ "setlist ::= nm EQ expr",
- /* 149 */ "setlist ::= LP idlist RP EQ expr",
- /* 150 */ "cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert",
- /* 151 */ "cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES",
- /* 152 */ "upsert ::=",
- /* 153 */ "upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt",
- /* 154 */ "upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING",
- /* 155 */ "upsert ::= ON CONFLICT DO NOTHING",
- /* 156 */ "insert_cmd ::= INSERT orconf",
- /* 157 */ "insert_cmd ::= REPLACE",
- /* 158 */ "idlist_opt ::=",
- /* 159 */ "idlist_opt ::= LP idlist RP",
- /* 160 */ "idlist ::= idlist COMMA nm",
- /* 161 */ "idlist ::= nm",
- /* 162 */ "expr ::= LP expr RP",
- /* 163 */ "expr ::= ID|INDEXED",
- /* 164 */ "expr ::= JOIN_KW",
- /* 165 */ "expr ::= nm DOT nm",
- /* 166 */ "expr ::= nm DOT nm DOT nm",
- /* 167 */ "term ::= NULL|FLOAT|BLOB",
- /* 168 */ "term ::= STRING",
- /* 169 */ "term ::= INTEGER",
- /* 170 */ "expr ::= VARIABLE",
- /* 171 */ "expr ::= expr COLLATE ID|STRING",
- /* 172 */ "expr ::= CAST LP expr AS typetoken RP",
- /* 173 */ "expr ::= ID|INDEXED LP distinct exprlist RP",
- /* 174 */ "expr ::= ID|INDEXED LP STAR RP",
- /* 175 */ "expr ::= ID|INDEXED LP distinct exprlist RP over_clause",
- /* 176 */ "expr ::= ID|INDEXED LP STAR RP over_clause",
- /* 177 */ "term ::= CTIME_KW",
- /* 178 */ "expr ::= LP nexprlist COMMA expr RP",
- /* 179 */ "expr ::= expr AND expr",
- /* 180 */ "expr ::= expr OR expr",
- /* 181 */ "expr ::= expr LT|GT|GE|LE expr",
- /* 182 */ "expr ::= expr EQ|NE expr",
- /* 183 */ "expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr",
- /* 184 */ "expr ::= expr PLUS|MINUS expr",
- /* 185 */ "expr ::= expr STAR|SLASH|REM expr",
- /* 186 */ "expr ::= expr CONCAT expr",
- /* 187 */ "likeop ::= NOT LIKE_KW|MATCH",
- /* 188 */ "expr ::= expr likeop expr",
- /* 189 */ "expr ::= expr likeop expr ESCAPE expr",
- /* 190 */ "expr ::= expr ISNULL|NOTNULL",
- /* 191 */ "expr ::= expr NOT NULL",
- /* 192 */ "expr ::= expr IS expr",
- /* 193 */ "expr ::= expr IS NOT expr",
- /* 194 */ "expr ::= NOT expr",
- /* 195 */ "expr ::= BITNOT expr",
- /* 196 */ "expr ::= PLUS|MINUS expr",
- /* 197 */ "between_op ::= BETWEEN",
- /* 198 */ "between_op ::= NOT BETWEEN",
- /* 199 */ "expr ::= expr between_op expr AND expr",
- /* 200 */ "in_op ::= IN",
- /* 201 */ "in_op ::= NOT IN",
- /* 202 */ "expr ::= expr in_op LP exprlist RP",
- /* 203 */ "expr ::= LP select RP",
- /* 204 */ "expr ::= expr in_op LP select RP",
- /* 205 */ "expr ::= expr in_op nm dbnm paren_exprlist",
- /* 206 */ "expr ::= EXISTS LP select RP",
- /* 207 */ "expr ::= CASE case_operand case_exprlist case_else END",
- /* 208 */ "case_exprlist ::= case_exprlist WHEN expr THEN expr",
- /* 209 */ "case_exprlist ::= WHEN expr THEN expr",
- /* 210 */ "case_else ::= ELSE expr",
- /* 211 */ "case_else ::=",
- /* 212 */ "case_operand ::= expr",
- /* 213 */ "case_operand ::=",
- /* 214 */ "exprlist ::=",
- /* 215 */ "nexprlist ::= nexprlist COMMA expr",
- /* 216 */ "nexprlist ::= expr",
- /* 217 */ "paren_exprlist ::=",
- /* 218 */ "paren_exprlist ::= LP exprlist RP",
- /* 219 */ "cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt",
- /* 220 */ "uniqueflag ::= UNIQUE",
- /* 221 */ "uniqueflag ::=",
- /* 222 */ "eidlist_opt ::=",
- /* 223 */ "eidlist_opt ::= LP eidlist RP",
- /* 224 */ "eidlist ::= eidlist COMMA nm collate sortorder",
- /* 225 */ "eidlist ::= nm collate sortorder",
- /* 226 */ "collate ::=",
- /* 227 */ "collate ::= COLLATE ID|STRING",
- /* 228 */ "cmd ::= DROP INDEX ifexists fullname",
- /* 229 */ "cmd ::= VACUUM vinto",
- /* 230 */ "cmd ::= VACUUM nm vinto",
- /* 231 */ "vinto ::= INTO expr",
- /* 232 */ "vinto ::=",
- /* 233 */ "cmd ::= PRAGMA nm dbnm",
- /* 234 */ "cmd ::= PRAGMA nm dbnm EQ nmnum",
- /* 235 */ "cmd ::= PRAGMA nm dbnm LP nmnum RP",
- /* 236 */ "cmd ::= PRAGMA nm dbnm EQ minus_num",
- /* 237 */ "cmd ::= PRAGMA nm dbnm LP minus_num RP",
- /* 238 */ "plus_num ::= PLUS INTEGER|FLOAT",
- /* 239 */ "minus_num ::= MINUS INTEGER|FLOAT",
- /* 240 */ "cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END",
- /* 241 */ "trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause",
- /* 242 */ "trigger_time ::= BEFORE|AFTER",
- /* 243 */ "trigger_time ::= INSTEAD OF",
- /* 244 */ "trigger_time ::=",
- /* 245 */ "trigger_event ::= DELETE|INSERT",
- /* 246 */ "trigger_event ::= UPDATE",
- /* 247 */ "trigger_event ::= UPDATE OF idlist",
- /* 248 */ "when_clause ::=",
- /* 249 */ "when_clause ::= WHEN expr",
- /* 250 */ "trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI",
- /* 251 */ "trigger_cmd_list ::= trigger_cmd SEMI",
- /* 252 */ "trnm ::= nm DOT nm",
- /* 253 */ "tridxby ::= INDEXED BY nm",
- /* 254 */ "tridxby ::= NOT INDEXED",
- /* 255 */ "trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt",
- /* 256 */ "trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt",
- /* 257 */ "trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt",
- /* 258 */ "trigger_cmd ::= scanpt select scanpt",
- /* 259 */ "expr ::= RAISE LP IGNORE RP",
- /* 260 */ "expr ::= RAISE LP raisetype COMMA nm RP",
- /* 261 */ "raisetype ::= ROLLBACK",
- /* 262 */ "raisetype ::= ABORT",
- /* 263 */ "raisetype ::= FAIL",
- /* 264 */ "cmd ::= DROP TRIGGER ifexists fullname",
- /* 265 */ "cmd ::= ATTACH database_kw_opt expr AS expr key_opt",
- /* 266 */ "cmd ::= DETACH database_kw_opt expr",
- /* 267 */ "key_opt ::=",
- /* 268 */ "key_opt ::= KEY expr",
- /* 269 */ "cmd ::= REINDEX",
- /* 270 */ "cmd ::= REINDEX nm dbnm",
- /* 271 */ "cmd ::= ANALYZE",
- /* 272 */ "cmd ::= ANALYZE nm dbnm",
- /* 273 */ "cmd ::= ALTER TABLE fullname RENAME TO nm",
- /* 274 */ "cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist",
- /* 275 */ "add_column_fullname ::= fullname",
- /* 276 */ "cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm",
- /* 277 */ "cmd ::= create_vtab",
- /* 278 */ "cmd ::= create_vtab LP vtabarglist RP",
- /* 279 */ "create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm",
- /* 280 */ "vtabarg ::=",
- /* 281 */ "vtabargtoken ::= ANY",
- /* 282 */ "vtabargtoken ::= lp anylist RP",
- /* 283 */ "lp ::= LP",
- /* 284 */ "with ::= WITH wqlist",
- /* 285 */ "with ::= WITH RECURSIVE wqlist",
- /* 286 */ "wqlist ::= nm eidlist_opt AS LP select RP",
- /* 287 */ "wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP",
- /* 288 */ "windowdefn_list ::= windowdefn",
- /* 289 */ "windowdefn_list ::= windowdefn_list COMMA windowdefn",
- /* 290 */ "windowdefn ::= nm AS LP window RP",
- /* 291 */ "window ::= PARTITION BY nexprlist orderby_opt frame_opt",
- /* 292 */ "window ::= nm PARTITION BY nexprlist orderby_opt frame_opt",
- /* 293 */ "window ::= ORDER BY sortlist frame_opt",
- /* 294 */ "window ::= nm ORDER BY sortlist frame_opt",
- /* 295 */ "window ::= frame_opt",
- /* 296 */ "window ::= nm frame_opt",
- /* 297 */ "frame_opt ::=",
- /* 298 */ "frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt",
- /* 299 */ "frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt",
- /* 300 */ "range_or_rows ::= RANGE|ROWS|GROUPS",
- /* 301 */ "frame_bound_s ::= frame_bound",
- /* 302 */ "frame_bound_s ::= UNBOUNDED PRECEDING",
- /* 303 */ "frame_bound_e ::= frame_bound",
- /* 304 */ "frame_bound_e ::= UNBOUNDED FOLLOWING",
- /* 305 */ "frame_bound ::= expr PRECEDING|FOLLOWING",
- /* 306 */ "frame_bound ::= CURRENT ROW",
- /* 307 */ "frame_exclude_opt ::=",
- /* 308 */ "frame_exclude_opt ::= EXCLUDE frame_exclude",
- /* 309 */ "frame_exclude ::= NO OTHERS",
- /* 310 */ "frame_exclude ::= CURRENT ROW",
- /* 311 */ "frame_exclude ::= GROUP|TIES",
- /* 312 */ "window_clause ::= WINDOW windowdefn_list",
- /* 313 */ "over_clause ::= filter_opt OVER LP window RP",
- /* 314 */ "over_clause ::= filter_opt OVER nm",
- /* 315 */ "filter_opt ::=",
- /* 316 */ "filter_opt ::= FILTER LP WHERE expr RP",
- /* 317 */ "input ::= cmdlist",
- /* 318 */ "cmdlist ::= cmdlist ecmd",
- /* 319 */ "cmdlist ::= ecmd",
- /* 320 */ "ecmd ::= SEMI",
- /* 321 */ "ecmd ::= cmdx SEMI",
- /* 322 */ "ecmd ::= explain cmdx",
- /* 323 */ "trans_opt ::=",
- /* 324 */ "trans_opt ::= TRANSACTION",
- /* 325 */ "trans_opt ::= TRANSACTION nm",
- /* 326 */ "savepoint_opt ::= SAVEPOINT",
- /* 327 */ "savepoint_opt ::=",
- /* 328 */ "cmd ::= create_table create_table_args",
- /* 329 */ "columnlist ::= columnlist COMMA columnname carglist",
- /* 330 */ "columnlist ::= columnname carglist",
- /* 331 */ "nm ::= ID|INDEXED",
- /* 332 */ "nm ::= STRING",
- /* 333 */ "nm ::= JOIN_KW",
- /* 334 */ "typetoken ::= typename",
- /* 335 */ "typename ::= ID|STRING",
- /* 336 */ "signed ::= plus_num",
- /* 337 */ "signed ::= minus_num",
- /* 338 */ "carglist ::= carglist ccons",
- /* 339 */ "carglist ::=",
- /* 340 */ "ccons ::= NULL onconf",
- /* 341 */ "conslist_opt ::= COMMA conslist",
- /* 342 */ "conslist ::= conslist tconscomma tcons",
- /* 343 */ "conslist ::= tcons",
- /* 344 */ "tconscomma ::=",
- /* 345 */ "defer_subclause_opt ::= defer_subclause",
- /* 346 */ "resolvetype ::= raisetype",
- /* 347 */ "selectnowith ::= oneselect",
- /* 348 */ "oneselect ::= values",
- /* 349 */ "sclp ::= selcollist COMMA",
- /* 350 */ "as ::= ID|STRING",
- /* 351 */ "expr ::= term",
- /* 352 */ "likeop ::= LIKE_KW|MATCH",
- /* 353 */ "exprlist ::= nexprlist",
- /* 354 */ "nmnum ::= plus_num",
- /* 355 */ "nmnum ::= nm",
- /* 356 */ "nmnum ::= ON",
- /* 357 */ "nmnum ::= DELETE",
- /* 358 */ "nmnum ::= DEFAULT",
- /* 359 */ "plus_num ::= INTEGER|FLOAT",
- /* 360 */ "foreach_clause ::=",
- /* 361 */ "foreach_clause ::= FOR EACH ROW",
- /* 362 */ "trnm ::= nm",
- /* 363 */ "tridxby ::=",
- /* 364 */ "database_kw_opt ::= DATABASE",
- /* 365 */ "database_kw_opt ::=",
- /* 366 */ "kwcolumn_opt ::=",
- /* 367 */ "kwcolumn_opt ::= COLUMNKW",
- /* 368 */ "vtabarglist ::= vtabarg",
- /* 369 */ "vtabarglist ::= vtabarglist COMMA vtabarg",
- /* 370 */ "vtabarg ::= vtabarg vtabargtoken",
- /* 371 */ "anylist ::=",
- /* 372 */ "anylist ::= anylist LP anylist RP",
- /* 373 */ "anylist ::= anylist ANY",
- /* 374 */ "with ::=",
+ /*  29 */ "scantok ::=",
+ /*  30 */ "ccons ::= CONSTRAINT nm",
+ /*  31 */ "ccons ::= DEFAULT scantok term",
+ /*  32 */ "ccons ::= DEFAULT LP expr RP",
+ /*  33 */ "ccons ::= DEFAULT PLUS scantok term",
+ /*  34 */ "ccons ::= DEFAULT MINUS scantok term",
+ /*  35 */ "ccons ::= DEFAULT scantok ID|INDEXED",
+ /*  36 */ "ccons ::= NOT NULL onconf",
+ /*  37 */ "ccons ::= PRIMARY KEY sortorder onconf autoinc",
+ /*  38 */ "ccons ::= UNIQUE onconf",
+ /*  39 */ "ccons ::= CHECK LP expr RP",
+ /*  40 */ "ccons ::= REFERENCES nm eidlist_opt refargs",
+ /*  41 */ "ccons ::= defer_subclause",
+ /*  42 */ "ccons ::= COLLATE ID|STRING",
+ /*  43 */ "autoinc ::=",
+ /*  44 */ "autoinc ::= AUTOINCR",
+ /*  45 */ "refargs ::=",
+ /*  46 */ "refargs ::= refargs refarg",
+ /*  47 */ "refarg ::= MATCH nm",
+ /*  48 */ "refarg ::= ON INSERT refact",
+ /*  49 */ "refarg ::= ON DELETE refact",
+ /*  50 */ "refarg ::= ON UPDATE refact",
+ /*  51 */ "refact ::= SET NULL",
+ /*  52 */ "refact ::= SET DEFAULT",
+ /*  53 */ "refact ::= CASCADE",
+ /*  54 */ "refact ::= RESTRICT",
+ /*  55 */ "refact ::= NO ACTION",
+ /*  56 */ "defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt",
+ /*  57 */ "defer_subclause ::= DEFERRABLE init_deferred_pred_opt",
+ /*  58 */ "init_deferred_pred_opt ::=",
+ /*  59 */ "init_deferred_pred_opt ::= INITIALLY DEFERRED",
+ /*  60 */ "init_deferred_pred_opt ::= INITIALLY IMMEDIATE",
+ /*  61 */ "conslist_opt ::=",
+ /*  62 */ "tconscomma ::= COMMA",
+ /*  63 */ "tcons ::= CONSTRAINT nm",
+ /*  64 */ "tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf",
+ /*  65 */ "tcons ::= UNIQUE LP sortlist RP onconf",
+ /*  66 */ "tcons ::= CHECK LP expr RP onconf",
+ /*  67 */ "tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt",
+ /*  68 */ "defer_subclause_opt ::=",
+ /*  69 */ "onconf ::=",
+ /*  70 */ "onconf ::= ON CONFLICT resolvetype",
+ /*  71 */ "orconf ::=",
+ /*  72 */ "orconf ::= OR resolvetype",
+ /*  73 */ "resolvetype ::= IGNORE",
+ /*  74 */ "resolvetype ::= REPLACE",
+ /*  75 */ "cmd ::= DROP TABLE ifexists fullname",
+ /*  76 */ "ifexists ::= IF EXISTS",
+ /*  77 */ "ifexists ::=",
+ /*  78 */ "cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select",
+ /*  79 */ "cmd ::= DROP VIEW ifexists fullname",
+ /*  80 */ "cmd ::= select",
+ /*  81 */ "select ::= WITH wqlist selectnowith",
+ /*  82 */ "select ::= WITH RECURSIVE wqlist selectnowith",
+ /*  83 */ "select ::= selectnowith",
+ /*  84 */ "selectnowith ::= selectnowith multiselect_op oneselect",
+ /*  85 */ "multiselect_op ::= UNION",
+ /*  86 */ "multiselect_op ::= UNION ALL",
+ /*  87 */ "multiselect_op ::= EXCEPT|INTERSECT",
+ /*  88 */ "oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt",
+ /*  89 */ "oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt",
+ /*  90 */ "values ::= VALUES LP nexprlist RP",
+ /*  91 */ "values ::= values COMMA LP nexprlist RP",
+ /*  92 */ "distinct ::= DISTINCT",
+ /*  93 */ "distinct ::= ALL",
+ /*  94 */ "distinct ::=",
+ /*  95 */ "sclp ::=",
+ /*  96 */ "selcollist ::= sclp scanpt expr scanpt as",
+ /*  97 */ "selcollist ::= sclp scanpt STAR",
+ /*  98 */ "selcollist ::= sclp scanpt nm DOT STAR",
+ /*  99 */ "as ::= AS nm",
+ /* 100 */ "as ::=",
+ /* 101 */ "from ::=",
+ /* 102 */ "from ::= FROM seltablist",
+ /* 103 */ "stl_prefix ::= seltablist joinop",
+ /* 104 */ "stl_prefix ::=",
+ /* 105 */ "seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt",
+ /* 106 */ "seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt",
+ /* 107 */ "seltablist ::= stl_prefix LP select RP as on_opt using_opt",
+ /* 108 */ "seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt",
+ /* 109 */ "dbnm ::=",
+ /* 110 */ "dbnm ::= DOT nm",
+ /* 111 */ "fullname ::= nm",
+ /* 112 */ "fullname ::= nm DOT nm",
+ /* 113 */ "xfullname ::= nm",
+ /* 114 */ "xfullname ::= nm DOT nm",
+ /* 115 */ "xfullname ::= nm DOT nm AS nm",
+ /* 116 */ "xfullname ::= nm AS nm",
+ /* 117 */ "joinop ::= COMMA|JOIN",
+ /* 118 */ "joinop ::= JOIN_KW JOIN",
+ /* 119 */ "joinop ::= JOIN_KW nm JOIN",
+ /* 120 */ "joinop ::= JOIN_KW nm nm JOIN",
+ /* 121 */ "on_opt ::= ON expr",
+ /* 122 */ "on_opt ::=",
+ /* 123 */ "indexed_opt ::=",
+ /* 124 */ "indexed_opt ::= INDEXED BY nm",
+ /* 125 */ "indexed_opt ::= NOT INDEXED",
+ /* 126 */ "using_opt ::= USING LP idlist RP",
+ /* 127 */ "using_opt ::=",
+ /* 128 */ "orderby_opt ::=",
+ /* 129 */ "orderby_opt ::= ORDER BY sortlist",
+ /* 130 */ "sortlist ::= sortlist COMMA expr sortorder nulls",
+ /* 131 */ "sortlist ::= expr sortorder nulls",
+ /* 132 */ "sortorder ::= ASC",
+ /* 133 */ "sortorder ::= DESC",
+ /* 134 */ "sortorder ::=",
+ /* 135 */ "nulls ::= NULLS FIRST",
+ /* 136 */ "nulls ::= NULLS LAST",
+ /* 137 */ "nulls ::=",
+ /* 138 */ "groupby_opt ::=",
+ /* 139 */ "groupby_opt ::= GROUP BY nexprlist",
+ /* 140 */ "having_opt ::=",
+ /* 141 */ "having_opt ::= HAVING expr",
+ /* 142 */ "limit_opt ::=",
+ /* 143 */ "limit_opt ::= LIMIT expr",
+ /* 144 */ "limit_opt ::= LIMIT expr OFFSET expr",
+ /* 145 */ "limit_opt ::= LIMIT expr COMMA expr",
+ /* 146 */ "cmd ::= with DELETE FROM xfullname indexed_opt where_opt",
+ /* 147 */ "where_opt ::=",
+ /* 148 */ "where_opt ::= WHERE expr",
+ /* 149 */ "cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt",
+ /* 150 */ "setlist ::= setlist COMMA nm EQ expr",
+ /* 151 */ "setlist ::= setlist COMMA LP idlist RP EQ expr",
+ /* 152 */ "setlist ::= nm EQ expr",
+ /* 153 */ "setlist ::= LP idlist RP EQ expr",
+ /* 154 */ "cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert",
+ /* 155 */ "cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES",
+ /* 156 */ "upsert ::=",
+ /* 157 */ "upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt",
+ /* 158 */ "upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING",
+ /* 159 */ "upsert ::= ON CONFLICT DO NOTHING",
+ /* 160 */ "insert_cmd ::= INSERT orconf",
+ /* 161 */ "insert_cmd ::= REPLACE",
+ /* 162 */ "idlist_opt ::=",
+ /* 163 */ "idlist_opt ::= LP idlist RP",
+ /* 164 */ "idlist ::= idlist COMMA nm",
+ /* 165 */ "idlist ::= nm",
+ /* 166 */ "expr ::= LP expr RP",
+ /* 167 */ "expr ::= ID|INDEXED",
+ /* 168 */ "expr ::= JOIN_KW",
+ /* 169 */ "expr ::= nm DOT nm",
+ /* 170 */ "expr ::= nm DOT nm DOT nm",
+ /* 171 */ "term ::= NULL|FLOAT|BLOB",
+ /* 172 */ "term ::= STRING",
+ /* 173 */ "term ::= INTEGER",
+ /* 174 */ "expr ::= VARIABLE",
+ /* 175 */ "expr ::= expr COLLATE ID|STRING",
+ /* 176 */ "expr ::= CAST LP expr AS typetoken RP",
+ /* 177 */ "expr ::= ID|INDEXED LP distinct exprlist RP",
+ /* 178 */ "expr ::= ID|INDEXED LP STAR RP",
+ /* 179 */ "expr ::= ID|INDEXED LP distinct exprlist RP filter_over",
+ /* 180 */ "expr ::= ID|INDEXED LP STAR RP filter_over",
+ /* 181 */ "term ::= CTIME_KW",
+ /* 182 */ "expr ::= LP nexprlist COMMA expr RP",
+ /* 183 */ "expr ::= expr AND expr",
+ /* 184 */ "expr ::= expr OR expr",
+ /* 185 */ "expr ::= expr LT|GT|GE|LE expr",
+ /* 186 */ "expr ::= expr EQ|NE expr",
+ /* 187 */ "expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr",
+ /* 188 */ "expr ::= expr PLUS|MINUS expr",
+ /* 189 */ "expr ::= expr STAR|SLASH|REM expr",
+ /* 190 */ "expr ::= expr CONCAT expr",
+ /* 191 */ "likeop ::= NOT LIKE_KW|MATCH",
+ /* 192 */ "expr ::= expr likeop expr",
+ /* 193 */ "expr ::= expr likeop expr ESCAPE expr",
+ /* 194 */ "expr ::= expr ISNULL|NOTNULL",
+ /* 195 */ "expr ::= expr NOT NULL",
+ /* 196 */ "expr ::= expr IS expr",
+ /* 197 */ "expr ::= expr IS NOT expr",
+ /* 198 */ "expr ::= NOT expr",
+ /* 199 */ "expr ::= BITNOT expr",
+ /* 200 */ "expr ::= PLUS|MINUS expr",
+ /* 201 */ "between_op ::= BETWEEN",
+ /* 202 */ "between_op ::= NOT BETWEEN",
+ /* 203 */ "expr ::= expr between_op expr AND expr",
+ /* 204 */ "in_op ::= IN",
+ /* 205 */ "in_op ::= NOT IN",
+ /* 206 */ "expr ::= expr in_op LP exprlist RP",
+ /* 207 */ "expr ::= LP select RP",
+ /* 208 */ "expr ::= expr in_op LP select RP",
+ /* 209 */ "expr ::= expr in_op nm dbnm paren_exprlist",
+ /* 210 */ "expr ::= EXISTS LP select RP",
+ /* 211 */ "expr ::= CASE case_operand case_exprlist case_else END",
+ /* 212 */ "case_exprlist ::= case_exprlist WHEN expr THEN expr",
+ /* 213 */ "case_exprlist ::= WHEN expr THEN expr",
+ /* 214 */ "case_else ::= ELSE expr",
+ /* 215 */ "case_else ::=",
+ /* 216 */ "case_operand ::= expr",
+ /* 217 */ "case_operand ::=",
+ /* 218 */ "exprlist ::=",
+ /* 219 */ "nexprlist ::= nexprlist COMMA expr",
+ /* 220 */ "nexprlist ::= expr",
+ /* 221 */ "paren_exprlist ::=",
+ /* 222 */ "paren_exprlist ::= LP exprlist RP",
+ /* 223 */ "cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt",
+ /* 224 */ "uniqueflag ::= UNIQUE",
+ /* 225 */ "uniqueflag ::=",
+ /* 226 */ "eidlist_opt ::=",
+ /* 227 */ "eidlist_opt ::= LP eidlist RP",
+ /* 228 */ "eidlist ::= eidlist COMMA nm collate sortorder",
+ /* 229 */ "eidlist ::= nm collate sortorder",
+ /* 230 */ "collate ::=",
+ /* 231 */ "collate ::= COLLATE ID|STRING",
+ /* 232 */ "cmd ::= DROP INDEX ifexists fullname",
+ /* 233 */ "cmd ::= VACUUM vinto",
+ /* 234 */ "cmd ::= VACUUM nm vinto",
+ /* 235 */ "vinto ::= INTO expr",
+ /* 236 */ "vinto ::=",
+ /* 237 */ "cmd ::= PRAGMA nm dbnm",
+ /* 238 */ "cmd ::= PRAGMA nm dbnm EQ nmnum",
+ /* 239 */ "cmd ::= PRAGMA nm dbnm LP nmnum RP",
+ /* 240 */ "cmd ::= PRAGMA nm dbnm EQ minus_num",
+ /* 241 */ "cmd ::= PRAGMA nm dbnm LP minus_num RP",
+ /* 242 */ "plus_num ::= PLUS INTEGER|FLOAT",
+ /* 243 */ "minus_num ::= MINUS INTEGER|FLOAT",
+ /* 244 */ "cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END",
+ /* 245 */ "trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause",
+ /* 246 */ "trigger_time ::= BEFORE|AFTER",
+ /* 247 */ "trigger_time ::= INSTEAD OF",
+ /* 248 */ "trigger_time ::=",
+ /* 249 */ "trigger_event ::= DELETE|INSERT",
+ /* 250 */ "trigger_event ::= UPDATE",
+ /* 251 */ "trigger_event ::= UPDATE OF idlist",
+ /* 252 */ "when_clause ::=",
+ /* 253 */ "when_clause ::= WHEN expr",
+ /* 254 */ "trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI",
+ /* 255 */ "trigger_cmd_list ::= trigger_cmd SEMI",
+ /* 256 */ "trnm ::= nm DOT nm",
+ /* 257 */ "tridxby ::= INDEXED BY nm",
+ /* 258 */ "tridxby ::= NOT INDEXED",
+ /* 259 */ "trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt",
+ /* 260 */ "trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt",
+ /* 261 */ "trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt",
+ /* 262 */ "trigger_cmd ::= scanpt select scanpt",
+ /* 263 */ "expr ::= RAISE LP IGNORE RP",
+ /* 264 */ "expr ::= RAISE LP raisetype COMMA nm RP",
+ /* 265 */ "raisetype ::= ROLLBACK",
+ /* 266 */ "raisetype ::= ABORT",
+ /* 267 */ "raisetype ::= FAIL",
+ /* 268 */ "cmd ::= DROP TRIGGER ifexists fullname",
+ /* 269 */ "cmd ::= ATTACH database_kw_opt expr AS expr key_opt",
+ /* 270 */ "cmd ::= DETACH database_kw_opt expr",
+ /* 271 */ "key_opt ::=",
+ /* 272 */ "key_opt ::= KEY expr",
+ /* 273 */ "cmd ::= REINDEX",
+ /* 274 */ "cmd ::= REINDEX nm dbnm",
+ /* 275 */ "cmd ::= ANALYZE",
+ /* 276 */ "cmd ::= ANALYZE nm dbnm",
+ /* 277 */ "cmd ::= ALTER TABLE fullname RENAME TO nm",
+ /* 278 */ "cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist",
+ /* 279 */ "add_column_fullname ::= fullname",
+ /* 280 */ "cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm",
+ /* 281 */ "cmd ::= create_vtab",
+ /* 282 */ "cmd ::= create_vtab LP vtabarglist RP",
+ /* 283 */ "create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm",
+ /* 284 */ "vtabarg ::=",
+ /* 285 */ "vtabargtoken ::= ANY",
+ /* 286 */ "vtabargtoken ::= lp anylist RP",
+ /* 287 */ "lp ::= LP",
+ /* 288 */ "with ::= WITH wqlist",
+ /* 289 */ "with ::= WITH RECURSIVE wqlist",
+ /* 290 */ "wqlist ::= nm eidlist_opt AS LP select RP",
+ /* 291 */ "wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP",
+ /* 292 */ "windowdefn_list ::= windowdefn",
+ /* 293 */ "windowdefn_list ::= windowdefn_list COMMA windowdefn",
+ /* 294 */ "windowdefn ::= nm AS LP window RP",
+ /* 295 */ "window ::= PARTITION BY nexprlist orderby_opt frame_opt",
+ /* 296 */ "window ::= nm PARTITION BY nexprlist orderby_opt frame_opt",
+ /* 297 */ "window ::= ORDER BY sortlist frame_opt",
+ /* 298 */ "window ::= nm ORDER BY sortlist frame_opt",
+ /* 299 */ "window ::= frame_opt",
+ /* 300 */ "window ::= nm frame_opt",
+ /* 301 */ "frame_opt ::=",
+ /* 302 */ "frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt",
+ /* 303 */ "frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt",
+ /* 304 */ "range_or_rows ::= RANGE|ROWS|GROUPS",
+ /* 305 */ "frame_bound_s ::= frame_bound",
+ /* 306 */ "frame_bound_s ::= UNBOUNDED PRECEDING",
+ /* 307 */ "frame_bound_e ::= frame_bound",
+ /* 308 */ "frame_bound_e ::= UNBOUNDED FOLLOWING",
+ /* 309 */ "frame_bound ::= expr PRECEDING|FOLLOWING",
+ /* 310 */ "frame_bound ::= CURRENT ROW",
+ /* 311 */ "frame_exclude_opt ::=",
+ /* 312 */ "frame_exclude_opt ::= EXCLUDE frame_exclude",
+ /* 313 */ "frame_exclude ::= NO OTHERS",
+ /* 314 */ "frame_exclude ::= CURRENT ROW",
+ /* 315 */ "frame_exclude ::= GROUP|TIES",
+ /* 316 */ "window_clause ::= WINDOW windowdefn_list",
+ /* 317 */ "filter_over ::= filter_clause over_clause",
+ /* 318 */ "filter_over ::= over_clause",
+ /* 319 */ "filter_over ::= filter_clause",
+ /* 320 */ "over_clause ::= OVER LP window RP",
+ /* 321 */ "over_clause ::= OVER nm",
+ /* 322 */ "filter_clause ::= FILTER LP WHERE expr RP",
+ /* 323 */ "input ::= cmdlist",
+ /* 324 */ "cmdlist ::= cmdlist ecmd",
+ /* 325 */ "cmdlist ::= ecmd",
+ /* 326 */ "ecmd ::= SEMI",
+ /* 327 */ "ecmd ::= cmdx SEMI",
+ /* 328 */ "ecmd ::= explain cmdx",
+ /* 329 */ "trans_opt ::=",
+ /* 330 */ "trans_opt ::= TRANSACTION",
+ /* 331 */ "trans_opt ::= TRANSACTION nm",
+ /* 332 */ "savepoint_opt ::= SAVEPOINT",
+ /* 333 */ "savepoint_opt ::=",
+ /* 334 */ "cmd ::= create_table create_table_args",
+ /* 335 */ "columnlist ::= columnlist COMMA columnname carglist",
+ /* 336 */ "columnlist ::= columnname carglist",
+ /* 337 */ "nm ::= ID|INDEXED",
+ /* 338 */ "nm ::= STRING",
+ /* 339 */ "nm ::= JOIN_KW",
+ /* 340 */ "typetoken ::= typename",
+ /* 341 */ "typename ::= ID|STRING",
+ /* 342 */ "signed ::= plus_num",
+ /* 343 */ "signed ::= minus_num",
+ /* 344 */ "carglist ::= carglist ccons",
+ /* 345 */ "carglist ::=",
+ /* 346 */ "ccons ::= NULL onconf",
+ /* 347 */ "conslist_opt ::= COMMA conslist",
+ /* 348 */ "conslist ::= conslist tconscomma tcons",
+ /* 349 */ "conslist ::= tcons",
+ /* 350 */ "tconscomma ::=",
+ /* 351 */ "defer_subclause_opt ::= defer_subclause",
+ /* 352 */ "resolvetype ::= raisetype",
+ /* 353 */ "selectnowith ::= oneselect",
+ /* 354 */ "oneselect ::= values",
+ /* 355 */ "sclp ::= selcollist COMMA",
+ /* 356 */ "as ::= ID|STRING",
+ /* 357 */ "expr ::= term",
+ /* 358 */ "likeop ::= LIKE_KW|MATCH",
+ /* 359 */ "exprlist ::= nexprlist",
+ /* 360 */ "nmnum ::= plus_num",
+ /* 361 */ "nmnum ::= nm",
+ /* 362 */ "nmnum ::= ON",
+ /* 363 */ "nmnum ::= DELETE",
+ /* 364 */ "nmnum ::= DEFAULT",
+ /* 365 */ "plus_num ::= INTEGER|FLOAT",
+ /* 366 */ "foreach_clause ::=",
+ /* 367 */ "foreach_clause ::= FOR EACH ROW",
+ /* 368 */ "trnm ::= nm",
+ /* 369 */ "tridxby ::=",
+ /* 370 */ "database_kw_opt ::= DATABASE",
+ /* 371 */ "database_kw_opt ::=",
+ /* 372 */ "kwcolumn_opt ::=",
+ /* 373 */ "kwcolumn_opt ::= COLUMNKW",
+ /* 374 */ "vtabarglist ::= vtabarg",
+ /* 375 */ "vtabarglist ::= vtabarglist COMMA vtabarg",
+ /* 376 */ "vtabarg ::= vtabarg vtabargtoken",
+ /* 377 */ "anylist ::=",
+ /* 378 */ "anylist ::= anylist LP anylist RP",
+ /* 379 */ "anylist ::= anylist ANY",
+ /* 380 */ "with ::=",
 };
 #endif /* NDEBUG */
 
 
 #if YYSTACKDEPTH<=0
@@ -150083,101 +151694,102 @@
     ** Note: during a reduce, the only symbols destroyed are those
     ** which appear on the RHS of the rule, but which are *not* used
     ** inside the C code.
     */
 /********* Begin destructor definitions ***************************************/
-    case 195: /* select */
-    case 227: /* selectnowith */
-    case 228: /* oneselect */
-    case 240: /* values */
+    case 198: /* select */
+    case 231: /* selectnowith */
+    case 232: /* oneselect */
+    case 244: /* values */
 {
-sqlite3SelectDelete(pParse->db, (yypminor->yy457));
+sqlite3SelectDelete(pParse->db, (yypminor->yy25));
 }
       break;
-    case 205: /* term */
-    case 206: /* expr */
-    case 234: /* where_opt */
-    case 236: /* having_opt */
-    case 248: /* on_opt */
-    case 263: /* case_operand */
-    case 265: /* case_else */
-    case 268: /* vinto */
-    case 275: /* when_clause */
-    case 280: /* key_opt */
-    case 294: /* filter_opt */
+    case 209: /* term */
+    case 210: /* expr */
+    case 238: /* where_opt */
+    case 240: /* having_opt */
+    case 252: /* on_opt */
+    case 268: /* case_operand */
+    case 270: /* case_else */
+    case 273: /* vinto */
+    case 280: /* when_clause */
+    case 285: /* key_opt */
+    case 299: /* filter_clause */
 {
-sqlite3ExprDelete(pParse->db, (yypminor->yy524));
+sqlite3ExprDelete(pParse->db, (yypminor->yy46));
 }
       break;
-    case 210: /* eidlist_opt */
-    case 219: /* sortlist */
-    case 220: /* eidlist */
-    case 232: /* selcollist */
-    case 235: /* groupby_opt */
-    case 237: /* orderby_opt */
-    case 241: /* nexprlist */
-    case 242: /* sclp */
-    case 250: /* exprlist */
-    case 254: /* setlist */
-    case 262: /* paren_exprlist */
-    case 264: /* case_exprlist */
-    case 293: /* part_opt */
+    case 214: /* eidlist_opt */
+    case 223: /* sortlist */
+    case 224: /* eidlist */
+    case 236: /* selcollist */
+    case 239: /* groupby_opt */
+    case 241: /* orderby_opt */
+    case 245: /* nexprlist */
+    case 246: /* sclp */
+    case 254: /* exprlist */
+    case 259: /* setlist */
+    case 267: /* paren_exprlist */
+    case 269: /* case_exprlist */
+    case 298: /* part_opt */
 {
-sqlite3ExprListDelete(pParse->db, (yypminor->yy434));
+sqlite3ExprListDelete(pParse->db, (yypminor->yy138));
 }
       break;
-    case 226: /* fullname */
-    case 233: /* from */
-    case 244: /* seltablist */
-    case 245: /* stl_prefix */
-    case 251: /* xfullname */
+    case 230: /* fullname */
+    case 237: /* from */
+    case 248: /* seltablist */
+    case 249: /* stl_prefix */
+    case 255: /* xfullname */
 {
-sqlite3SrcListDelete(pParse->db, (yypminor->yy483));
+sqlite3SrcListDelete(pParse->db, (yypminor->yy609));
 }
       break;
-    case 229: /* wqlist */
+    case 233: /* wqlist */
 {
-sqlite3WithDelete(pParse->db, (yypminor->yy59));
+sqlite3WithDelete(pParse->db, (yypminor->yy297));
 }
       break;
-    case 239: /* window_clause */
-    case 289: /* windowdefn_list */
+    case 243: /* window_clause */
+    case 294: /* windowdefn_list */
 {
-sqlite3WindowListDelete(pParse->db, (yypminor->yy295));
+sqlite3WindowListDelete(pParse->db, (yypminor->yy455));
 }
       break;
-    case 249: /* using_opt */
-    case 252: /* idlist */
-    case 256: /* idlist_opt */
+    case 253: /* using_opt */
+    case 256: /* idlist */
+    case 261: /* idlist_opt */
 {
-sqlite3IdListDelete(pParse->db, (yypminor->yy62));
+sqlite3IdListDelete(pParse->db, (yypminor->yy406));
 }
       break;
-    case 258: /* over_clause */
-    case 290: /* windowdefn */
-    case 291: /* window */
-    case 292: /* frame_opt */
+    case 263: /* filter_over */
+    case 295: /* windowdefn */
+    case 296: /* window */
+    case 297: /* frame_opt */
+    case 300: /* over_clause */
 {
-sqlite3WindowDelete(pParse->db, (yypminor->yy295));
+sqlite3WindowDelete(pParse->db, (yypminor->yy455));
 }
       break;
-    case 271: /* trigger_cmd_list */
-    case 276: /* trigger_cmd */
+    case 276: /* trigger_cmd_list */
+    case 281: /* trigger_cmd */
 {
-sqlite3DeleteTriggerStep(pParse->db, (yypminor->yy455));
+sqlite3DeleteTriggerStep(pParse->db, (yypminor->yy527));
 }
       break;
-    case 273: /* trigger_event */
+    case 278: /* trigger_event */
 {
-sqlite3IdListDelete(pParse->db, (yypminor->yy90).b);
+sqlite3IdListDelete(pParse->db, (yypminor->yy572).b);
 }
       break;
-    case 296: /* frame_bound */
-    case 297: /* frame_bound_s */
-    case 298: /* frame_bound_e */
+    case 302: /* frame_bound */
+    case 303: /* frame_bound_s */
+    case 304: /* frame_bound_e */
 {
-sqlite3ExprDelete(pParse->db, (yypminor->yy201).pExpr);
+sqlite3ExprDelete(pParse->db, (yypminor->yy57).pExpr);
 }
       break;
 /********* End destructor definitions *****************************************/
     default:  break;   /* If no destructor action specified: do nothing */
   }
@@ -150299,19 +151911,22 @@
   yycoverage[stateno][iLookAhead] = 1;
 #endif
   do{
     i = yy_shift_ofst[stateno];
     assert( i>=0 );
-    /* assert( i+YYNTOKEN<=(int)YY_NLOOKAHEAD ); */
+    assert( i<=YY_ACTTAB_COUNT );
+    assert( i+YYNTOKEN<=(int)YY_NLOOKAHEAD );
     assert( iLookAhead!=YYNOCODE );
     assert( iLookAhead < YYNTOKEN );
     i += iLookAhead;
-    if( i>=YY_NLOOKAHEAD || yy_lookahead[i]!=iLookAhead ){
+    assert( i<(int)YY_NLOOKAHEAD );
+    if( yy_lookahead[i]!=iLookAhead ){
 #ifdef YYFALLBACK
       YYCODETYPE iFallback;            /* Fallback token */
-      if( iLookAhead<sizeof(yyFallback)/sizeof(yyFallback[0])
-             && (iFallback = yyFallback[iLookAhead])!=0 ){
+      assert( iLookAhead<sizeof(yyFallback)/sizeof(yyFallback[0]) );
+      iFallback = yyFallback[iLookAhead];
+      if( iFallback!=0 ){
 #ifndef NDEBUG
         if( yyTraceFILE ){
           fprintf(yyTraceFILE, "%sFALLBACK %s => %s\n",
              yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[iFallback]);
         }
@@ -150322,20 +151937,12 @@
       }
 #endif
 #ifdef YYWILDCARD
       {
         int j = i - iLookAhead + YYWILDCARD;
-        if(
-#if YY_SHIFT_MIN+YYWILDCARD<0
-          j>=0 &&
-#endif
-#if YY_SHIFT_MAX+YYWILDCARD>=YY_ACTTAB_COUNT
-          j<YY_ACTTAB_COUNT &&
-#endif
-          j<(int)(sizeof(yy_lookahead)/sizeof(yy_lookahead[0])) &&
-          yy_lookahead[j]==YYWILDCARD && iLookAhead>0
-        ){
+        assert( j<(int)(sizeof(yy_lookahead)/sizeof(yy_lookahead[0])) );
+        if( yy_lookahead[j]==YYWILDCARD && iLookAhead>0 ){
 #ifndef NDEBUG
           if( yyTraceFILE ){
             fprintf(yyTraceFILE, "%sWILDCARD %s => %s\n",
                yyTracePrompt, yyTokenName[iLookAhead],
                yyTokenName[YYWILDCARD]);
@@ -150345,10 +151952,11 @@
         }
       }
 #endif /* YYWILDCARD */
       return yy_default[stateno];
     }else{
+      assert( i>=0 && i<sizeof(yy_action)/sizeof(yy_action[0]) );
       return yy_action[i];
     }
   }while(1);
 }
 
@@ -150468,385 +152076,391 @@
 }
 
 /* For rule J, yyRuleInfoLhs[J] contains the symbol on the left-hand side
 ** of that rule */
 static const YYCODETYPE yyRuleInfoLhs[] = {
-   180,  /* (0) explain ::= EXPLAIN */
-   180,  /* (1) explain ::= EXPLAIN QUERY PLAN */
-   179,  /* (2) cmdx ::= cmd */
-   181,  /* (3) cmd ::= BEGIN transtype trans_opt */
-   182,  /* (4) transtype ::= */
-   182,  /* (5) transtype ::= DEFERRED */
-   182,  /* (6) transtype ::= IMMEDIATE */
-   182,  /* (7) transtype ::= EXCLUSIVE */
-   181,  /* (8) cmd ::= COMMIT|END trans_opt */
-   181,  /* (9) cmd ::= ROLLBACK trans_opt */
-   181,  /* (10) cmd ::= SAVEPOINT nm */
-   181,  /* (11) cmd ::= RELEASE savepoint_opt nm */
-   181,  /* (12) cmd ::= ROLLBACK trans_opt TO savepoint_opt nm */
-   186,  /* (13) create_table ::= createkw temp TABLE ifnotexists nm dbnm */
-   188,  /* (14) createkw ::= CREATE */
-   190,  /* (15) ifnotexists ::= */
-   190,  /* (16) ifnotexists ::= IF NOT EXISTS */
-   189,  /* (17) temp ::= TEMP */
-   189,  /* (18) temp ::= */
-   187,  /* (19) create_table_args ::= LP columnlist conslist_opt RP table_options */
-   187,  /* (20) create_table_args ::= AS select */
-   194,  /* (21) table_options ::= */
-   194,  /* (22) table_options ::= WITHOUT nm */
-   196,  /* (23) columnname ::= nm typetoken */
-   198,  /* (24) typetoken ::= */
-   198,  /* (25) typetoken ::= typename LP signed RP */
-   198,  /* (26) typetoken ::= typename LP signed COMMA signed RP */
-   199,  /* (27) typename ::= typename ID|STRING */
-   203,  /* (28) scanpt ::= */
-   204,  /* (29) ccons ::= CONSTRAINT nm */
-   204,  /* (30) ccons ::= DEFAULT scanpt term scanpt */
-   204,  /* (31) ccons ::= DEFAULT LP expr RP */
-   204,  /* (32) ccons ::= DEFAULT PLUS term scanpt */
-   204,  /* (33) ccons ::= DEFAULT MINUS term scanpt */
-   204,  /* (34) ccons ::= DEFAULT scanpt ID|INDEXED */
-   204,  /* (35) ccons ::= NOT NULL onconf */
-   204,  /* (36) ccons ::= PRIMARY KEY sortorder onconf autoinc */
-   204,  /* (37) ccons ::= UNIQUE onconf */
-   204,  /* (38) ccons ::= CHECK LP expr RP */
-   204,  /* (39) ccons ::= REFERENCES nm eidlist_opt refargs */
-   204,  /* (40) ccons ::= defer_subclause */
-   204,  /* (41) ccons ::= COLLATE ID|STRING */
-   209,  /* (42) autoinc ::= */
-   209,  /* (43) autoinc ::= AUTOINCR */
-   211,  /* (44) refargs ::= */
-   211,  /* (45) refargs ::= refargs refarg */
-   213,  /* (46) refarg ::= MATCH nm */
-   213,  /* (47) refarg ::= ON INSERT refact */
-   213,  /* (48) refarg ::= ON DELETE refact */
-   213,  /* (49) refarg ::= ON UPDATE refact */
-   214,  /* (50) refact ::= SET NULL */
-   214,  /* (51) refact ::= SET DEFAULT */
-   214,  /* (52) refact ::= CASCADE */
-   214,  /* (53) refact ::= RESTRICT */
-   214,  /* (54) refact ::= NO ACTION */
-   212,  /* (55) defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt */
-   212,  /* (56) defer_subclause ::= DEFERRABLE init_deferred_pred_opt */
-   215,  /* (57) init_deferred_pred_opt ::= */
-   215,  /* (58) init_deferred_pred_opt ::= INITIALLY DEFERRED */
-   215,  /* (59) init_deferred_pred_opt ::= INITIALLY IMMEDIATE */
-   193,  /* (60) conslist_opt ::= */
-   217,  /* (61) tconscomma ::= COMMA */
-   218,  /* (62) tcons ::= CONSTRAINT nm */
-   218,  /* (63) tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf */
-   218,  /* (64) tcons ::= UNIQUE LP sortlist RP onconf */
-   218,  /* (65) tcons ::= CHECK LP expr RP onconf */
-   218,  /* (66) tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt */
-   221,  /* (67) defer_subclause_opt ::= */
-   207,  /* (68) onconf ::= */
-   207,  /* (69) onconf ::= ON CONFLICT resolvetype */
-   222,  /* (70) orconf ::= */
-   222,  /* (71) orconf ::= OR resolvetype */
-   223,  /* (72) resolvetype ::= IGNORE */
-   223,  /* (73) resolvetype ::= REPLACE */
-   181,  /* (74) cmd ::= DROP TABLE ifexists fullname */
-   225,  /* (75) ifexists ::= IF EXISTS */
-   225,  /* (76) ifexists ::= */
-   181,  /* (77) cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select */
-   181,  /* (78) cmd ::= DROP VIEW ifexists fullname */
-   181,  /* (79) cmd ::= select */
-   195,  /* (80) select ::= WITH wqlist selectnowith */
-   195,  /* (81) select ::= WITH RECURSIVE wqlist selectnowith */
-   195,  /* (82) select ::= selectnowith */
-   227,  /* (83) selectnowith ::= selectnowith multiselect_op oneselect */
-   230,  /* (84) multiselect_op ::= UNION */
-   230,  /* (85) multiselect_op ::= UNION ALL */
-   230,  /* (86) multiselect_op ::= EXCEPT|INTERSECT */
-   228,  /* (87) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt */
-   228,  /* (88) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt */
-   240,  /* (89) values ::= VALUES LP nexprlist RP */
-   240,  /* (90) values ::= values COMMA LP nexprlist RP */
-   231,  /* (91) distinct ::= DISTINCT */
-   231,  /* (92) distinct ::= ALL */
-   231,  /* (93) distinct ::= */
-   242,  /* (94) sclp ::= */
-   232,  /* (95) selcollist ::= sclp scanpt expr scanpt as */
-   232,  /* (96) selcollist ::= sclp scanpt STAR */
-   232,  /* (97) selcollist ::= sclp scanpt nm DOT STAR */
-   243,  /* (98) as ::= AS nm */
-   243,  /* (99) as ::= */
-   233,  /* (100) from ::= */
-   233,  /* (101) from ::= FROM seltablist */
-   245,  /* (102) stl_prefix ::= seltablist joinop */
-   245,  /* (103) stl_prefix ::= */
-   244,  /* (104) seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt */
-   244,  /* (105) seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt */
-   244,  /* (106) seltablist ::= stl_prefix LP select RP as on_opt using_opt */
-   244,  /* (107) seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt */
-   191,  /* (108) dbnm ::= */
-   191,  /* (109) dbnm ::= DOT nm */
-   226,  /* (110) fullname ::= nm */
-   226,  /* (111) fullname ::= nm DOT nm */
-   251,  /* (112) xfullname ::= nm */
-   251,  /* (113) xfullname ::= nm DOT nm */
-   251,  /* (114) xfullname ::= nm DOT nm AS nm */
-   251,  /* (115) xfullname ::= nm AS nm */
-   246,  /* (116) joinop ::= COMMA|JOIN */
-   246,  /* (117) joinop ::= JOIN_KW JOIN */
-   246,  /* (118) joinop ::= JOIN_KW nm JOIN */
-   246,  /* (119) joinop ::= JOIN_KW nm nm JOIN */
-   248,  /* (120) on_opt ::= ON expr */
-   248,  /* (121) on_opt ::= */
-   247,  /* (122) indexed_opt ::= */
-   247,  /* (123) indexed_opt ::= INDEXED BY nm */
-   247,  /* (124) indexed_opt ::= NOT INDEXED */
-   249,  /* (125) using_opt ::= USING LP idlist RP */
-   249,  /* (126) using_opt ::= */
-   237,  /* (127) orderby_opt ::= */
-   237,  /* (128) orderby_opt ::= ORDER BY sortlist */
-   219,  /* (129) sortlist ::= sortlist COMMA expr sortorder */
-   219,  /* (130) sortlist ::= expr sortorder */
-   208,  /* (131) sortorder ::= ASC */
-   208,  /* (132) sortorder ::= DESC */
-   208,  /* (133) sortorder ::= */
-   235,  /* (134) groupby_opt ::= */
-   235,  /* (135) groupby_opt ::= GROUP BY nexprlist */
-   236,  /* (136) having_opt ::= */
-   236,  /* (137) having_opt ::= HAVING expr */
-   238,  /* (138) limit_opt ::= */
-   238,  /* (139) limit_opt ::= LIMIT expr */
-   238,  /* (140) limit_opt ::= LIMIT expr OFFSET expr */
-   238,  /* (141) limit_opt ::= LIMIT expr COMMA expr */
-   181,  /* (142) cmd ::= with DELETE FROM xfullname indexed_opt where_opt */
-   234,  /* (143) where_opt ::= */
-   234,  /* (144) where_opt ::= WHERE expr */
-   181,  /* (145) cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt */
-   254,  /* (146) setlist ::= setlist COMMA nm EQ expr */
-   254,  /* (147) setlist ::= setlist COMMA LP idlist RP EQ expr */
-   254,  /* (148) setlist ::= nm EQ expr */
-   254,  /* (149) setlist ::= LP idlist RP EQ expr */
-   181,  /* (150) cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert */
-   181,  /* (151) cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES */
-   257,  /* (152) upsert ::= */
-   257,  /* (153) upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt */
-   257,  /* (154) upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING */
-   257,  /* (155) upsert ::= ON CONFLICT DO NOTHING */
-   255,  /* (156) insert_cmd ::= INSERT orconf */
-   255,  /* (157) insert_cmd ::= REPLACE */
-   256,  /* (158) idlist_opt ::= */
-   256,  /* (159) idlist_opt ::= LP idlist RP */
-   252,  /* (160) idlist ::= idlist COMMA nm */
-   252,  /* (161) idlist ::= nm */
-   206,  /* (162) expr ::= LP expr RP */
-   206,  /* (163) expr ::= ID|INDEXED */
-   206,  /* (164) expr ::= JOIN_KW */
-   206,  /* (165) expr ::= nm DOT nm */
-   206,  /* (166) expr ::= nm DOT nm DOT nm */
-   205,  /* (167) term ::= NULL|FLOAT|BLOB */
-   205,  /* (168) term ::= STRING */
-   205,  /* (169) term ::= INTEGER */
-   206,  /* (170) expr ::= VARIABLE */
-   206,  /* (171) expr ::= expr COLLATE ID|STRING */
-   206,  /* (172) expr ::= CAST LP expr AS typetoken RP */
-   206,  /* (173) expr ::= ID|INDEXED LP distinct exprlist RP */
-   206,  /* (174) expr ::= ID|INDEXED LP STAR RP */
-   206,  /* (175) expr ::= ID|INDEXED LP distinct exprlist RP over_clause */
-   206,  /* (176) expr ::= ID|INDEXED LP STAR RP over_clause */
-   205,  /* (177) term ::= CTIME_KW */
-   206,  /* (178) expr ::= LP nexprlist COMMA expr RP */
-   206,  /* (179) expr ::= expr AND expr */
-   206,  /* (180) expr ::= expr OR expr */
-   206,  /* (181) expr ::= expr LT|GT|GE|LE expr */
-   206,  /* (182) expr ::= expr EQ|NE expr */
-   206,  /* (183) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr */
-   206,  /* (184) expr ::= expr PLUS|MINUS expr */
-   206,  /* (185) expr ::= expr STAR|SLASH|REM expr */
-   206,  /* (186) expr ::= expr CONCAT expr */
-   259,  /* (187) likeop ::= NOT LIKE_KW|MATCH */
-   206,  /* (188) expr ::= expr likeop expr */
-   206,  /* (189) expr ::= expr likeop expr ESCAPE expr */
-   206,  /* (190) expr ::= expr ISNULL|NOTNULL */
-   206,  /* (191) expr ::= expr NOT NULL */
-   206,  /* (192) expr ::= expr IS expr */
-   206,  /* (193) expr ::= expr IS NOT expr */
-   206,  /* (194) expr ::= NOT expr */
-   206,  /* (195) expr ::= BITNOT expr */
-   206,  /* (196) expr ::= PLUS|MINUS expr */
-   260,  /* (197) between_op ::= BETWEEN */
-   260,  /* (198) between_op ::= NOT BETWEEN */
-   206,  /* (199) expr ::= expr between_op expr AND expr */
-   261,  /* (200) in_op ::= IN */
-   261,  /* (201) in_op ::= NOT IN */
-   206,  /* (202) expr ::= expr in_op LP exprlist RP */
-   206,  /* (203) expr ::= LP select RP */
-   206,  /* (204) expr ::= expr in_op LP select RP */
-   206,  /* (205) expr ::= expr in_op nm dbnm paren_exprlist */
-   206,  /* (206) expr ::= EXISTS LP select RP */
-   206,  /* (207) expr ::= CASE case_operand case_exprlist case_else END */
-   264,  /* (208) case_exprlist ::= case_exprlist WHEN expr THEN expr */
-   264,  /* (209) case_exprlist ::= WHEN expr THEN expr */
-   265,  /* (210) case_else ::= ELSE expr */
-   265,  /* (211) case_else ::= */
-   263,  /* (212) case_operand ::= expr */
-   263,  /* (213) case_operand ::= */
-   250,  /* (214) exprlist ::= */
-   241,  /* (215) nexprlist ::= nexprlist COMMA expr */
-   241,  /* (216) nexprlist ::= expr */
-   262,  /* (217) paren_exprlist ::= */
-   262,  /* (218) paren_exprlist ::= LP exprlist RP */
-   181,  /* (219) cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt */
-   266,  /* (220) uniqueflag ::= UNIQUE */
-   266,  /* (221) uniqueflag ::= */
-   210,  /* (222) eidlist_opt ::= */
-   210,  /* (223) eidlist_opt ::= LP eidlist RP */
-   220,  /* (224) eidlist ::= eidlist COMMA nm collate sortorder */
-   220,  /* (225) eidlist ::= nm collate sortorder */
-   267,  /* (226) collate ::= */
-   267,  /* (227) collate ::= COLLATE ID|STRING */
-   181,  /* (228) cmd ::= DROP INDEX ifexists fullname */
-   181,  /* (229) cmd ::= VACUUM vinto */
-   181,  /* (230) cmd ::= VACUUM nm vinto */
-   268,  /* (231) vinto ::= INTO expr */
-   268,  /* (232) vinto ::= */
-   181,  /* (233) cmd ::= PRAGMA nm dbnm */
-   181,  /* (234) cmd ::= PRAGMA nm dbnm EQ nmnum */
-   181,  /* (235) cmd ::= PRAGMA nm dbnm LP nmnum RP */
-   181,  /* (236) cmd ::= PRAGMA nm dbnm EQ minus_num */
-   181,  /* (237) cmd ::= PRAGMA nm dbnm LP minus_num RP */
-   201,  /* (238) plus_num ::= PLUS INTEGER|FLOAT */
-   202,  /* (239) minus_num ::= MINUS INTEGER|FLOAT */
-   181,  /* (240) cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END */
-   270,  /* (241) trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause */
-   272,  /* (242) trigger_time ::= BEFORE|AFTER */
-   272,  /* (243) trigger_time ::= INSTEAD OF */
-   272,  /* (244) trigger_time ::= */
-   273,  /* (245) trigger_event ::= DELETE|INSERT */
-   273,  /* (246) trigger_event ::= UPDATE */
-   273,  /* (247) trigger_event ::= UPDATE OF idlist */
-   275,  /* (248) when_clause ::= */
-   275,  /* (249) when_clause ::= WHEN expr */
-   271,  /* (250) trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI */
-   271,  /* (251) trigger_cmd_list ::= trigger_cmd SEMI */
-   277,  /* (252) trnm ::= nm DOT nm */
-   278,  /* (253) tridxby ::= INDEXED BY nm */
-   278,  /* (254) tridxby ::= NOT INDEXED */
-   276,  /* (255) trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt */
-   276,  /* (256) trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt */
-   276,  /* (257) trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt */
-   276,  /* (258) trigger_cmd ::= scanpt select scanpt */
-   206,  /* (259) expr ::= RAISE LP IGNORE RP */
-   206,  /* (260) expr ::= RAISE LP raisetype COMMA nm RP */
-   224,  /* (261) raisetype ::= ROLLBACK */
-   224,  /* (262) raisetype ::= ABORT */
-   224,  /* (263) raisetype ::= FAIL */
-   181,  /* (264) cmd ::= DROP TRIGGER ifexists fullname */
-   181,  /* (265) cmd ::= ATTACH database_kw_opt expr AS expr key_opt */
-   181,  /* (266) cmd ::= DETACH database_kw_opt expr */
-   280,  /* (267) key_opt ::= */
-   280,  /* (268) key_opt ::= KEY expr */
-   181,  /* (269) cmd ::= REINDEX */
-   181,  /* (270) cmd ::= REINDEX nm dbnm */
-   181,  /* (271) cmd ::= ANALYZE */
-   181,  /* (272) cmd ::= ANALYZE nm dbnm */
-   181,  /* (273) cmd ::= ALTER TABLE fullname RENAME TO nm */
-   181,  /* (274) cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist */
-   281,  /* (275) add_column_fullname ::= fullname */
-   181,  /* (276) cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm */
-   181,  /* (277) cmd ::= create_vtab */
-   181,  /* (278) cmd ::= create_vtab LP vtabarglist RP */
-   283,  /* (279) create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm */
-   285,  /* (280) vtabarg ::= */
-   286,  /* (281) vtabargtoken ::= ANY */
-   286,  /* (282) vtabargtoken ::= lp anylist RP */
-   287,  /* (283) lp ::= LP */
-   253,  /* (284) with ::= WITH wqlist */
-   253,  /* (285) with ::= WITH RECURSIVE wqlist */
-   229,  /* (286) wqlist ::= nm eidlist_opt AS LP select RP */
-   229,  /* (287) wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP */
-   289,  /* (288) windowdefn_list ::= windowdefn */
-   289,  /* (289) windowdefn_list ::= windowdefn_list COMMA windowdefn */
-   290,  /* (290) windowdefn ::= nm AS LP window RP */
-   291,  /* (291) window ::= PARTITION BY nexprlist orderby_opt frame_opt */
-   291,  /* (292) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt */
-   291,  /* (293) window ::= ORDER BY sortlist frame_opt */
-   291,  /* (294) window ::= nm ORDER BY sortlist frame_opt */
-   291,  /* (295) window ::= frame_opt */
-   291,  /* (296) window ::= nm frame_opt */
-   292,  /* (297) frame_opt ::= */
-   292,  /* (298) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt */
-   292,  /* (299) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt */
-   295,  /* (300) range_or_rows ::= RANGE|ROWS|GROUPS */
-   297,  /* (301) frame_bound_s ::= frame_bound */
-   297,  /* (302) frame_bound_s ::= UNBOUNDED PRECEDING */
-   298,  /* (303) frame_bound_e ::= frame_bound */
-   298,  /* (304) frame_bound_e ::= UNBOUNDED FOLLOWING */
-   296,  /* (305) frame_bound ::= expr PRECEDING|FOLLOWING */
-   296,  /* (306) frame_bound ::= CURRENT ROW */
-   299,  /* (307) frame_exclude_opt ::= */
-   299,  /* (308) frame_exclude_opt ::= EXCLUDE frame_exclude */
-   300,  /* (309) frame_exclude ::= NO OTHERS */
-   300,  /* (310) frame_exclude ::= CURRENT ROW */
-   300,  /* (311) frame_exclude ::= GROUP|TIES */
-   239,  /* (312) window_clause ::= WINDOW windowdefn_list */
-   258,  /* (313) over_clause ::= filter_opt OVER LP window RP */
-   258,  /* (314) over_clause ::= filter_opt OVER nm */
-   294,  /* (315) filter_opt ::= */
-   294,  /* (316) filter_opt ::= FILTER LP WHERE expr RP */
-   176,  /* (317) input ::= cmdlist */
-   177,  /* (318) cmdlist ::= cmdlist ecmd */
-   177,  /* (319) cmdlist ::= ecmd */
-   178,  /* (320) ecmd ::= SEMI */
-   178,  /* (321) ecmd ::= cmdx SEMI */
-   178,  /* (322) ecmd ::= explain cmdx */
-   183,  /* (323) trans_opt ::= */
-   183,  /* (324) trans_opt ::= TRANSACTION */
-   183,  /* (325) trans_opt ::= TRANSACTION nm */
-   185,  /* (326) savepoint_opt ::= SAVEPOINT */
-   185,  /* (327) savepoint_opt ::= */
-   181,  /* (328) cmd ::= create_table create_table_args */
-   192,  /* (329) columnlist ::= columnlist COMMA columnname carglist */
-   192,  /* (330) columnlist ::= columnname carglist */
-   184,  /* (331) nm ::= ID|INDEXED */
-   184,  /* (332) nm ::= STRING */
-   184,  /* (333) nm ::= JOIN_KW */
-   198,  /* (334) typetoken ::= typename */
-   199,  /* (335) typename ::= ID|STRING */
-   200,  /* (336) signed ::= plus_num */
-   200,  /* (337) signed ::= minus_num */
-   197,  /* (338) carglist ::= carglist ccons */
-   197,  /* (339) carglist ::= */
-   204,  /* (340) ccons ::= NULL onconf */
-   193,  /* (341) conslist_opt ::= COMMA conslist */
-   216,  /* (342) conslist ::= conslist tconscomma tcons */
-   216,  /* (343) conslist ::= tcons */
-   217,  /* (344) tconscomma ::= */
-   221,  /* (345) defer_subclause_opt ::= defer_subclause */
-   223,  /* (346) resolvetype ::= raisetype */
-   227,  /* (347) selectnowith ::= oneselect */
-   228,  /* (348) oneselect ::= values */
-   242,  /* (349) sclp ::= selcollist COMMA */
-   243,  /* (350) as ::= ID|STRING */
-   206,  /* (351) expr ::= term */
-   259,  /* (352) likeop ::= LIKE_KW|MATCH */
-   250,  /* (353) exprlist ::= nexprlist */
-   269,  /* (354) nmnum ::= plus_num */
-   269,  /* (355) nmnum ::= nm */
-   269,  /* (356) nmnum ::= ON */
-   269,  /* (357) nmnum ::= DELETE */
-   269,  /* (358) nmnum ::= DEFAULT */
-   201,  /* (359) plus_num ::= INTEGER|FLOAT */
-   274,  /* (360) foreach_clause ::= */
-   274,  /* (361) foreach_clause ::= FOR EACH ROW */
-   277,  /* (362) trnm ::= nm */
-   278,  /* (363) tridxby ::= */
-   279,  /* (364) database_kw_opt ::= DATABASE */
-   279,  /* (365) database_kw_opt ::= */
-   282,  /* (366) kwcolumn_opt ::= */
-   282,  /* (367) kwcolumn_opt ::= COLUMNKW */
-   284,  /* (368) vtabarglist ::= vtabarg */
-   284,  /* (369) vtabarglist ::= vtabarglist COMMA vtabarg */
-   285,  /* (370) vtabarg ::= vtabarg vtabargtoken */
-   288,  /* (371) anylist ::= */
-   288,  /* (372) anylist ::= anylist LP anylist RP */
-   288,  /* (373) anylist ::= anylist ANY */
-   253,  /* (374) with ::= */
+   183,  /* (0) explain ::= EXPLAIN */
+   183,  /* (1) explain ::= EXPLAIN QUERY PLAN */
+   182,  /* (2) cmdx ::= cmd */
+   184,  /* (3) cmd ::= BEGIN transtype trans_opt */
+   185,  /* (4) transtype ::= */
+   185,  /* (5) transtype ::= DEFERRED */
+   185,  /* (6) transtype ::= IMMEDIATE */
+   185,  /* (7) transtype ::= EXCLUSIVE */
+   184,  /* (8) cmd ::= COMMIT|END trans_opt */
+   184,  /* (9) cmd ::= ROLLBACK trans_opt */
+   184,  /* (10) cmd ::= SAVEPOINT nm */
+   184,  /* (11) cmd ::= RELEASE savepoint_opt nm */
+   184,  /* (12) cmd ::= ROLLBACK trans_opt TO savepoint_opt nm */
+   189,  /* (13) create_table ::= createkw temp TABLE ifnotexists nm dbnm */
+   191,  /* (14) createkw ::= CREATE */
+   193,  /* (15) ifnotexists ::= */
+   193,  /* (16) ifnotexists ::= IF NOT EXISTS */
+   192,  /* (17) temp ::= TEMP */
+   192,  /* (18) temp ::= */
+   190,  /* (19) create_table_args ::= LP columnlist conslist_opt RP table_options */
+   190,  /* (20) create_table_args ::= AS select */
+   197,  /* (21) table_options ::= */
+   197,  /* (22) table_options ::= WITHOUT nm */
+   199,  /* (23) columnname ::= nm typetoken */
+   201,  /* (24) typetoken ::= */
+   201,  /* (25) typetoken ::= typename LP signed RP */
+   201,  /* (26) typetoken ::= typename LP signed COMMA signed RP */
+   202,  /* (27) typename ::= typename ID|STRING */
+   206,  /* (28) scanpt ::= */
+   207,  /* (29) scantok ::= */
+   208,  /* (30) ccons ::= CONSTRAINT nm */
+   208,  /* (31) ccons ::= DEFAULT scantok term */
+   208,  /* (32) ccons ::= DEFAULT LP expr RP */
+   208,  /* (33) ccons ::= DEFAULT PLUS scantok term */
+   208,  /* (34) ccons ::= DEFAULT MINUS scantok term */
+   208,  /* (35) ccons ::= DEFAULT scantok ID|INDEXED */
+   208,  /* (36) ccons ::= NOT NULL onconf */
+   208,  /* (37) ccons ::= PRIMARY KEY sortorder onconf autoinc */
+   208,  /* (38) ccons ::= UNIQUE onconf */
+   208,  /* (39) ccons ::= CHECK LP expr RP */
+   208,  /* (40) ccons ::= REFERENCES nm eidlist_opt refargs */
+   208,  /* (41) ccons ::= defer_subclause */
+   208,  /* (42) ccons ::= COLLATE ID|STRING */
+   213,  /* (43) autoinc ::= */
+   213,  /* (44) autoinc ::= AUTOINCR */
+   215,  /* (45) refargs ::= */
+   215,  /* (46) refargs ::= refargs refarg */
+   217,  /* (47) refarg ::= MATCH nm */
+   217,  /* (48) refarg ::= ON INSERT refact */
+   217,  /* (49) refarg ::= ON DELETE refact */
+   217,  /* (50) refarg ::= ON UPDATE refact */
+   218,  /* (51) refact ::= SET NULL */
+   218,  /* (52) refact ::= SET DEFAULT */
+   218,  /* (53) refact ::= CASCADE */
+   218,  /* (54) refact ::= RESTRICT */
+   218,  /* (55) refact ::= NO ACTION */
+   216,  /* (56) defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt */
+   216,  /* (57) defer_subclause ::= DEFERRABLE init_deferred_pred_opt */
+   219,  /* (58) init_deferred_pred_opt ::= */
+   219,  /* (59) init_deferred_pred_opt ::= INITIALLY DEFERRED */
+   219,  /* (60) init_deferred_pred_opt ::= INITIALLY IMMEDIATE */
+   196,  /* (61) conslist_opt ::= */
+   221,  /* (62) tconscomma ::= COMMA */
+   222,  /* (63) tcons ::= CONSTRAINT nm */
+   222,  /* (64) tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf */
+   222,  /* (65) tcons ::= UNIQUE LP sortlist RP onconf */
+   222,  /* (66) tcons ::= CHECK LP expr RP onconf */
+   222,  /* (67) tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt */
+   225,  /* (68) defer_subclause_opt ::= */
+   211,  /* (69) onconf ::= */
+   211,  /* (70) onconf ::= ON CONFLICT resolvetype */
+   226,  /* (71) orconf ::= */
+   226,  /* (72) orconf ::= OR resolvetype */
+   227,  /* (73) resolvetype ::= IGNORE */
+   227,  /* (74) resolvetype ::= REPLACE */
+   184,  /* (75) cmd ::= DROP TABLE ifexists fullname */
+   229,  /* (76) ifexists ::= IF EXISTS */
+   229,  /* (77) ifexists ::= */
+   184,  /* (78) cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select */
+   184,  /* (79) cmd ::= DROP VIEW ifexists fullname */
+   184,  /* (80) cmd ::= select */
+   198,  /* (81) select ::= WITH wqlist selectnowith */
+   198,  /* (82) select ::= WITH RECURSIVE wqlist selectnowith */
+   198,  /* (83) select ::= selectnowith */
+   231,  /* (84) selectnowith ::= selectnowith multiselect_op oneselect */
+   234,  /* (85) multiselect_op ::= UNION */
+   234,  /* (86) multiselect_op ::= UNION ALL */
+   234,  /* (87) multiselect_op ::= EXCEPT|INTERSECT */
+   232,  /* (88) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt */
+   232,  /* (89) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt */
+   244,  /* (90) values ::= VALUES LP nexprlist RP */
+   244,  /* (91) values ::= values COMMA LP nexprlist RP */
+   235,  /* (92) distinct ::= DISTINCT */
+   235,  /* (93) distinct ::= ALL */
+   235,  /* (94) distinct ::= */
+   246,  /* (95) sclp ::= */
+   236,  /* (96) selcollist ::= sclp scanpt expr scanpt as */
+   236,  /* (97) selcollist ::= sclp scanpt STAR */
+   236,  /* (98) selcollist ::= sclp scanpt nm DOT STAR */
+   247,  /* (99) as ::= AS nm */
+   247,  /* (100) as ::= */
+   237,  /* (101) from ::= */
+   237,  /* (102) from ::= FROM seltablist */
+   249,  /* (103) stl_prefix ::= seltablist joinop */
+   249,  /* (104) stl_prefix ::= */
+   248,  /* (105) seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt */
+   248,  /* (106) seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt */
+   248,  /* (107) seltablist ::= stl_prefix LP select RP as on_opt using_opt */
+   248,  /* (108) seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt */
+   194,  /* (109) dbnm ::= */
+   194,  /* (110) dbnm ::= DOT nm */
+   230,  /* (111) fullname ::= nm */
+   230,  /* (112) fullname ::= nm DOT nm */
+   255,  /* (113) xfullname ::= nm */
+   255,  /* (114) xfullname ::= nm DOT nm */
+   255,  /* (115) xfullname ::= nm DOT nm AS nm */
+   255,  /* (116) xfullname ::= nm AS nm */
+   250,  /* (117) joinop ::= COMMA|JOIN */
+   250,  /* (118) joinop ::= JOIN_KW JOIN */
+   250,  /* (119) joinop ::= JOIN_KW nm JOIN */
+   250,  /* (120) joinop ::= JOIN_KW nm nm JOIN */
+   252,  /* (121) on_opt ::= ON expr */
+   252,  /* (122) on_opt ::= */
+   251,  /* (123) indexed_opt ::= */
+   251,  /* (124) indexed_opt ::= INDEXED BY nm */
+   251,  /* (125) indexed_opt ::= NOT INDEXED */
+   253,  /* (126) using_opt ::= USING LP idlist RP */
+   253,  /* (127) using_opt ::= */
+   241,  /* (128) orderby_opt ::= */
+   241,  /* (129) orderby_opt ::= ORDER BY sortlist */
+   223,  /* (130) sortlist ::= sortlist COMMA expr sortorder nulls */
+   223,  /* (131) sortlist ::= expr sortorder nulls */
+   212,  /* (132) sortorder ::= ASC */
+   212,  /* (133) sortorder ::= DESC */
+   212,  /* (134) sortorder ::= */
+   257,  /* (135) nulls ::= NULLS FIRST */
+   257,  /* (136) nulls ::= NULLS LAST */
+   257,  /* (137) nulls ::= */
+   239,  /* (138) groupby_opt ::= */
+   239,  /* (139) groupby_opt ::= GROUP BY nexprlist */
+   240,  /* (140) having_opt ::= */
+   240,  /* (141) having_opt ::= HAVING expr */
+   242,  /* (142) limit_opt ::= */
+   242,  /* (143) limit_opt ::= LIMIT expr */
+   242,  /* (144) limit_opt ::= LIMIT expr OFFSET expr */
+   242,  /* (145) limit_opt ::= LIMIT expr COMMA expr */
+   184,  /* (146) cmd ::= with DELETE FROM xfullname indexed_opt where_opt */
+   238,  /* (147) where_opt ::= */
+   238,  /* (148) where_opt ::= WHERE expr */
+   184,  /* (149) cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt */
+   259,  /* (150) setlist ::= setlist COMMA nm EQ expr */
+   259,  /* (151) setlist ::= setlist COMMA LP idlist RP EQ expr */
+   259,  /* (152) setlist ::= nm EQ expr */
+   259,  /* (153) setlist ::= LP idlist RP EQ expr */
+   184,  /* (154) cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert */
+   184,  /* (155) cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES */
+   262,  /* (156) upsert ::= */
+   262,  /* (157) upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt */
+   262,  /* (158) upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING */
+   262,  /* (159) upsert ::= ON CONFLICT DO NOTHING */
+   260,  /* (160) insert_cmd ::= INSERT orconf */
+   260,  /* (161) insert_cmd ::= REPLACE */
+   261,  /* (162) idlist_opt ::= */
+   261,  /* (163) idlist_opt ::= LP idlist RP */
+   256,  /* (164) idlist ::= idlist COMMA nm */
+   256,  /* (165) idlist ::= nm */
+   210,  /* (166) expr ::= LP expr RP */
+   210,  /* (167) expr ::= ID|INDEXED */
+   210,  /* (168) expr ::= JOIN_KW */
+   210,  /* (169) expr ::= nm DOT nm */
+   210,  /* (170) expr ::= nm DOT nm DOT nm */
+   209,  /* (171) term ::= NULL|FLOAT|BLOB */
+   209,  /* (172) term ::= STRING */
+   209,  /* (173) term ::= INTEGER */
+   210,  /* (174) expr ::= VARIABLE */
+   210,  /* (175) expr ::= expr COLLATE ID|STRING */
+   210,  /* (176) expr ::= CAST LP expr AS typetoken RP */
+   210,  /* (177) expr ::= ID|INDEXED LP distinct exprlist RP */
+   210,  /* (178) expr ::= ID|INDEXED LP STAR RP */
+   210,  /* (179) expr ::= ID|INDEXED LP distinct exprlist RP filter_over */
+   210,  /* (180) expr ::= ID|INDEXED LP STAR RP filter_over */
+   209,  /* (181) term ::= CTIME_KW */
+   210,  /* (182) expr ::= LP nexprlist COMMA expr RP */
+   210,  /* (183) expr ::= expr AND expr */
+   210,  /* (184) expr ::= expr OR expr */
+   210,  /* (185) expr ::= expr LT|GT|GE|LE expr */
+   210,  /* (186) expr ::= expr EQ|NE expr */
+   210,  /* (187) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr */
+   210,  /* (188) expr ::= expr PLUS|MINUS expr */
+   210,  /* (189) expr ::= expr STAR|SLASH|REM expr */
+   210,  /* (190) expr ::= expr CONCAT expr */
+   264,  /* (191) likeop ::= NOT LIKE_KW|MATCH */
+   210,  /* (192) expr ::= expr likeop expr */
+   210,  /* (193) expr ::= expr likeop expr ESCAPE expr */
+   210,  /* (194) expr ::= expr ISNULL|NOTNULL */
+   210,  /* (195) expr ::= expr NOT NULL */
+   210,  /* (196) expr ::= expr IS expr */
+   210,  /* (197) expr ::= expr IS NOT expr */
+   210,  /* (198) expr ::= NOT expr */
+   210,  /* (199) expr ::= BITNOT expr */
+   210,  /* (200) expr ::= PLUS|MINUS expr */
+   265,  /* (201) between_op ::= BETWEEN */
+   265,  /* (202) between_op ::= NOT BETWEEN */
+   210,  /* (203) expr ::= expr between_op expr AND expr */
+   266,  /* (204) in_op ::= IN */
+   266,  /* (205) in_op ::= NOT IN */
+   210,  /* (206) expr ::= expr in_op LP exprlist RP */
+   210,  /* (207) expr ::= LP select RP */
+   210,  /* (208) expr ::= expr in_op LP select RP */
+   210,  /* (209) expr ::= expr in_op nm dbnm paren_exprlist */
+   210,  /* (210) expr ::= EXISTS LP select RP */
+   210,  /* (211) expr ::= CASE case_operand case_exprlist case_else END */
+   269,  /* (212) case_exprlist ::= case_exprlist WHEN expr THEN expr */
+   269,  /* (213) case_exprlist ::= WHEN expr THEN expr */
+   270,  /* (214) case_else ::= ELSE expr */
+   270,  /* (215) case_else ::= */
+   268,  /* (216) case_operand ::= expr */
+   268,  /* (217) case_operand ::= */
+   254,  /* (218) exprlist ::= */
+   245,  /* (219) nexprlist ::= nexprlist COMMA expr */
+   245,  /* (220) nexprlist ::= expr */
+   267,  /* (221) paren_exprlist ::= */
+   267,  /* (222) paren_exprlist ::= LP exprlist RP */
+   184,  /* (223) cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt */
+   271,  /* (224) uniqueflag ::= UNIQUE */
+   271,  /* (225) uniqueflag ::= */
+   214,  /* (226) eidlist_opt ::= */
+   214,  /* (227) eidlist_opt ::= LP eidlist RP */
+   224,  /* (228) eidlist ::= eidlist COMMA nm collate sortorder */
+   224,  /* (229) eidlist ::= nm collate sortorder */
+   272,  /* (230) collate ::= */
+   272,  /* (231) collate ::= COLLATE ID|STRING */
+   184,  /* (232) cmd ::= DROP INDEX ifexists fullname */
+   184,  /* (233) cmd ::= VACUUM vinto */
+   184,  /* (234) cmd ::= VACUUM nm vinto */
+   273,  /* (235) vinto ::= INTO expr */
+   273,  /* (236) vinto ::= */
+   184,  /* (237) cmd ::= PRAGMA nm dbnm */
+   184,  /* (238) cmd ::= PRAGMA nm dbnm EQ nmnum */
+   184,  /* (239) cmd ::= PRAGMA nm dbnm LP nmnum RP */
+   184,  /* (240) cmd ::= PRAGMA nm dbnm EQ minus_num */
+   184,  /* (241) cmd ::= PRAGMA nm dbnm LP minus_num RP */
+   204,  /* (242) plus_num ::= PLUS INTEGER|FLOAT */
+   205,  /* (243) minus_num ::= MINUS INTEGER|FLOAT */
+   184,  /* (244) cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END */
+   275,  /* (245) trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause */
+   277,  /* (246) trigger_time ::= BEFORE|AFTER */
+   277,  /* (247) trigger_time ::= INSTEAD OF */
+   277,  /* (248) trigger_time ::= */
+   278,  /* (249) trigger_event ::= DELETE|INSERT */
+   278,  /* (250) trigger_event ::= UPDATE */
+   278,  /* (251) trigger_event ::= UPDATE OF idlist */
+   280,  /* (252) when_clause ::= */
+   280,  /* (253) when_clause ::= WHEN expr */
+   276,  /* (254) trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI */
+   276,  /* (255) trigger_cmd_list ::= trigger_cmd SEMI */
+   282,  /* (256) trnm ::= nm DOT nm */
+   283,  /* (257) tridxby ::= INDEXED BY nm */
+   283,  /* (258) tridxby ::= NOT INDEXED */
+   281,  /* (259) trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt */
+   281,  /* (260) trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt */
+   281,  /* (261) trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt */
+   281,  /* (262) trigger_cmd ::= scanpt select scanpt */
+   210,  /* (263) expr ::= RAISE LP IGNORE RP */
+   210,  /* (264) expr ::= RAISE LP raisetype COMMA nm RP */
+   228,  /* (265) raisetype ::= ROLLBACK */
+   228,  /* (266) raisetype ::= ABORT */
+   228,  /* (267) raisetype ::= FAIL */
+   184,  /* (268) cmd ::= DROP TRIGGER ifexists fullname */
+   184,  /* (269) cmd ::= ATTACH database_kw_opt expr AS expr key_opt */
+   184,  /* (270) cmd ::= DETACH database_kw_opt expr */
+   285,  /* (271) key_opt ::= */
+   285,  /* (272) key_opt ::= KEY expr */
+   184,  /* (273) cmd ::= REINDEX */
+   184,  /* (274) cmd ::= REINDEX nm dbnm */
+   184,  /* (275) cmd ::= ANALYZE */
+   184,  /* (276) cmd ::= ANALYZE nm dbnm */
+   184,  /* (277) cmd ::= ALTER TABLE fullname RENAME TO nm */
+   184,  /* (278) cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist */
+   286,  /* (279) add_column_fullname ::= fullname */
+   184,  /* (280) cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm */
+   184,  /* (281) cmd ::= create_vtab */
+   184,  /* (282) cmd ::= create_vtab LP vtabarglist RP */
+   288,  /* (283) create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm */
+   290,  /* (284) vtabarg ::= */
+   291,  /* (285) vtabargtoken ::= ANY */
+   291,  /* (286) vtabargtoken ::= lp anylist RP */
+   292,  /* (287) lp ::= LP */
+   258,  /* (288) with ::= WITH wqlist */
+   258,  /* (289) with ::= WITH RECURSIVE wqlist */
+   233,  /* (290) wqlist ::= nm eidlist_opt AS LP select RP */
+   233,  /* (291) wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP */
+   294,  /* (292) windowdefn_list ::= windowdefn */
+   294,  /* (293) windowdefn_list ::= windowdefn_list COMMA windowdefn */
+   295,  /* (294) windowdefn ::= nm AS LP window RP */
+   296,  /* (295) window ::= PARTITION BY nexprlist orderby_opt frame_opt */
+   296,  /* (296) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt */
+   296,  /* (297) window ::= ORDER BY sortlist frame_opt */
+   296,  /* (298) window ::= nm ORDER BY sortlist frame_opt */
+   296,  /* (299) window ::= frame_opt */
+   296,  /* (300) window ::= nm frame_opt */
+   297,  /* (301) frame_opt ::= */
+   297,  /* (302) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt */
+   297,  /* (303) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt */
+   301,  /* (304) range_or_rows ::= RANGE|ROWS|GROUPS */
+   303,  /* (305) frame_bound_s ::= frame_bound */
+   303,  /* (306) frame_bound_s ::= UNBOUNDED PRECEDING */
+   304,  /* (307) frame_bound_e ::= frame_bound */
+   304,  /* (308) frame_bound_e ::= UNBOUNDED FOLLOWING */
+   302,  /* (309) frame_bound ::= expr PRECEDING|FOLLOWING */
+   302,  /* (310) frame_bound ::= CURRENT ROW */
+   305,  /* (311) frame_exclude_opt ::= */
+   305,  /* (312) frame_exclude_opt ::= EXCLUDE frame_exclude */
+   306,  /* (313) frame_exclude ::= NO OTHERS */
+   306,  /* (314) frame_exclude ::= CURRENT ROW */
+   306,  /* (315) frame_exclude ::= GROUP|TIES */
+   243,  /* (316) window_clause ::= WINDOW windowdefn_list */
+   263,  /* (317) filter_over ::= filter_clause over_clause */
+   263,  /* (318) filter_over ::= over_clause */
+   263,  /* (319) filter_over ::= filter_clause */
+   300,  /* (320) over_clause ::= OVER LP window RP */
+   300,  /* (321) over_clause ::= OVER nm */
+   299,  /* (322) filter_clause ::= FILTER LP WHERE expr RP */
+   179,  /* (323) input ::= cmdlist */
+   180,  /* (324) cmdlist ::= cmdlist ecmd */
+   180,  /* (325) cmdlist ::= ecmd */
+   181,  /* (326) ecmd ::= SEMI */
+   181,  /* (327) ecmd ::= cmdx SEMI */
+   181,  /* (328) ecmd ::= explain cmdx */
+   186,  /* (329) trans_opt ::= */
+   186,  /* (330) trans_opt ::= TRANSACTION */
+   186,  /* (331) trans_opt ::= TRANSACTION nm */
+   188,  /* (332) savepoint_opt ::= SAVEPOINT */
+   188,  /* (333) savepoint_opt ::= */
+   184,  /* (334) cmd ::= create_table create_table_args */
+   195,  /* (335) columnlist ::= columnlist COMMA columnname carglist */
+   195,  /* (336) columnlist ::= columnname carglist */
+   187,  /* (337) nm ::= ID|INDEXED */
+   187,  /* (338) nm ::= STRING */
+   187,  /* (339) nm ::= JOIN_KW */
+   201,  /* (340) typetoken ::= typename */
+   202,  /* (341) typename ::= ID|STRING */
+   203,  /* (342) signed ::= plus_num */
+   203,  /* (343) signed ::= minus_num */
+   200,  /* (344) carglist ::= carglist ccons */
+   200,  /* (345) carglist ::= */
+   208,  /* (346) ccons ::= NULL onconf */
+   196,  /* (347) conslist_opt ::= COMMA conslist */
+   220,  /* (348) conslist ::= conslist tconscomma tcons */
+   220,  /* (349) conslist ::= tcons */
+   221,  /* (350) tconscomma ::= */
+   225,  /* (351) defer_subclause_opt ::= defer_subclause */
+   227,  /* (352) resolvetype ::= raisetype */
+   231,  /* (353) selectnowith ::= oneselect */
+   232,  /* (354) oneselect ::= values */
+   246,  /* (355) sclp ::= selcollist COMMA */
+   247,  /* (356) as ::= ID|STRING */
+   210,  /* (357) expr ::= term */
+   264,  /* (358) likeop ::= LIKE_KW|MATCH */
+   254,  /* (359) exprlist ::= nexprlist */
+   274,  /* (360) nmnum ::= plus_num */
+   274,  /* (361) nmnum ::= nm */
+   274,  /* (362) nmnum ::= ON */
+   274,  /* (363) nmnum ::= DELETE */
+   274,  /* (364) nmnum ::= DEFAULT */
+   204,  /* (365) plus_num ::= INTEGER|FLOAT */
+   279,  /* (366) foreach_clause ::= */
+   279,  /* (367) foreach_clause ::= FOR EACH ROW */
+   282,  /* (368) trnm ::= nm */
+   283,  /* (369) tridxby ::= */
+   284,  /* (370) database_kw_opt ::= DATABASE */
+   284,  /* (371) database_kw_opt ::= */
+   287,  /* (372) kwcolumn_opt ::= */
+   287,  /* (373) kwcolumn_opt ::= COLUMNKW */
+   289,  /* (374) vtabarglist ::= vtabarg */
+   289,  /* (375) vtabarglist ::= vtabarglist COMMA vtabarg */
+   290,  /* (376) vtabarg ::= vtabarg vtabargtoken */
+   293,  /* (377) anylist ::= */
+   293,  /* (378) anylist ::= anylist LP anylist RP */
+   293,  /* (379) anylist ::= anylist ANY */
+   258,  /* (380) with ::= */
 };
 
 /* For rule J, yyRuleInfoNRhs[J] contains the negative of the number
 ** of symbols on the right-hand side of that rule. */
 static const signed char yyRuleInfoNRhs[] = {
@@ -150877,356 +152491,362 @@
     0,  /* (24) typetoken ::= */
    -4,  /* (25) typetoken ::= typename LP signed RP */
    -6,  /* (26) typetoken ::= typename LP signed COMMA signed RP */
    -2,  /* (27) typename ::= typename ID|STRING */
     0,  /* (28) scanpt ::= */
-   -2,  /* (29) ccons ::= CONSTRAINT nm */
-   -4,  /* (30) ccons ::= DEFAULT scanpt term scanpt */
-   -4,  /* (31) ccons ::= DEFAULT LP expr RP */
-   -4,  /* (32) ccons ::= DEFAULT PLUS term scanpt */
-   -4,  /* (33) ccons ::= DEFAULT MINUS term scanpt */
-   -3,  /* (34) ccons ::= DEFAULT scanpt ID|INDEXED */
-   -3,  /* (35) ccons ::= NOT NULL onconf */
-   -5,  /* (36) ccons ::= PRIMARY KEY sortorder onconf autoinc */
-   -2,  /* (37) ccons ::= UNIQUE onconf */
-   -4,  /* (38) ccons ::= CHECK LP expr RP */
-   -4,  /* (39) ccons ::= REFERENCES nm eidlist_opt refargs */
-   -1,  /* (40) ccons ::= defer_subclause */
-   -2,  /* (41) ccons ::= COLLATE ID|STRING */
-    0,  /* (42) autoinc ::= */
-   -1,  /* (43) autoinc ::= AUTOINCR */
-    0,  /* (44) refargs ::= */
-   -2,  /* (45) refargs ::= refargs refarg */
-   -2,  /* (46) refarg ::= MATCH nm */
-   -3,  /* (47) refarg ::= ON INSERT refact */
-   -3,  /* (48) refarg ::= ON DELETE refact */
-   -3,  /* (49) refarg ::= ON UPDATE refact */
-   -2,  /* (50) refact ::= SET NULL */
-   -2,  /* (51) refact ::= SET DEFAULT */
-   -1,  /* (52) refact ::= CASCADE */
-   -1,  /* (53) refact ::= RESTRICT */
-   -2,  /* (54) refact ::= NO ACTION */
-   -3,  /* (55) defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt */
-   -2,  /* (56) defer_subclause ::= DEFERRABLE init_deferred_pred_opt */
-    0,  /* (57) init_deferred_pred_opt ::= */
-   -2,  /* (58) init_deferred_pred_opt ::= INITIALLY DEFERRED */
-   -2,  /* (59) init_deferred_pred_opt ::= INITIALLY IMMEDIATE */
-    0,  /* (60) conslist_opt ::= */
-   -1,  /* (61) tconscomma ::= COMMA */
-   -2,  /* (62) tcons ::= CONSTRAINT nm */
-   -7,  /* (63) tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf */
-   -5,  /* (64) tcons ::= UNIQUE LP sortlist RP onconf */
-   -5,  /* (65) tcons ::= CHECK LP expr RP onconf */
-  -10,  /* (66) tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt */
-    0,  /* (67) defer_subclause_opt ::= */
-    0,  /* (68) onconf ::= */
-   -3,  /* (69) onconf ::= ON CONFLICT resolvetype */
-    0,  /* (70) orconf ::= */
-   -2,  /* (71) orconf ::= OR resolvetype */
-   -1,  /* (72) resolvetype ::= IGNORE */
-   -1,  /* (73) resolvetype ::= REPLACE */
-   -4,  /* (74) cmd ::= DROP TABLE ifexists fullname */
-   -2,  /* (75) ifexists ::= IF EXISTS */
-    0,  /* (76) ifexists ::= */
-   -9,  /* (77) cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select */
-   -4,  /* (78) cmd ::= DROP VIEW ifexists fullname */
-   -1,  /* (79) cmd ::= select */
-   -3,  /* (80) select ::= WITH wqlist selectnowith */
-   -4,  /* (81) select ::= WITH RECURSIVE wqlist selectnowith */
-   -1,  /* (82) select ::= selectnowith */
-   -3,  /* (83) selectnowith ::= selectnowith multiselect_op oneselect */
-   -1,  /* (84) multiselect_op ::= UNION */
-   -2,  /* (85) multiselect_op ::= UNION ALL */
-   -1,  /* (86) multiselect_op ::= EXCEPT|INTERSECT */
-   -9,  /* (87) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt */
-  -10,  /* (88) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt */
-   -4,  /* (89) values ::= VALUES LP nexprlist RP */
-   -5,  /* (90) values ::= values COMMA LP nexprlist RP */
-   -1,  /* (91) distinct ::= DISTINCT */
-   -1,  /* (92) distinct ::= ALL */
-    0,  /* (93) distinct ::= */
-    0,  /* (94) sclp ::= */
-   -5,  /* (95) selcollist ::= sclp scanpt expr scanpt as */
-   -3,  /* (96) selcollist ::= sclp scanpt STAR */
-   -5,  /* (97) selcollist ::= sclp scanpt nm DOT STAR */
-   -2,  /* (98) as ::= AS nm */
-    0,  /* (99) as ::= */
-    0,  /* (100) from ::= */
-   -2,  /* (101) from ::= FROM seltablist */
-   -2,  /* (102) stl_prefix ::= seltablist joinop */
-    0,  /* (103) stl_prefix ::= */
-   -7,  /* (104) seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt */
-   -9,  /* (105) seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt */
-   -7,  /* (106) seltablist ::= stl_prefix LP select RP as on_opt using_opt */
-   -7,  /* (107) seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt */
-    0,  /* (108) dbnm ::= */
-   -2,  /* (109) dbnm ::= DOT nm */
-   -1,  /* (110) fullname ::= nm */
-   -3,  /* (111) fullname ::= nm DOT nm */
-   -1,  /* (112) xfullname ::= nm */
-   -3,  /* (113) xfullname ::= nm DOT nm */
-   -5,  /* (114) xfullname ::= nm DOT nm AS nm */
-   -3,  /* (115) xfullname ::= nm AS nm */
-   -1,  /* (116) joinop ::= COMMA|JOIN */
-   -2,  /* (117) joinop ::= JOIN_KW JOIN */
-   -3,  /* (118) joinop ::= JOIN_KW nm JOIN */
-   -4,  /* (119) joinop ::= JOIN_KW nm nm JOIN */
-   -2,  /* (120) on_opt ::= ON expr */
-    0,  /* (121) on_opt ::= */
-    0,  /* (122) indexed_opt ::= */
-   -3,  /* (123) indexed_opt ::= INDEXED BY nm */
-   -2,  /* (124) indexed_opt ::= NOT INDEXED */
-   -4,  /* (125) using_opt ::= USING LP idlist RP */
-    0,  /* (126) using_opt ::= */
-    0,  /* (127) orderby_opt ::= */
-   -3,  /* (128) orderby_opt ::= ORDER BY sortlist */
-   -4,  /* (129) sortlist ::= sortlist COMMA expr sortorder */
-   -2,  /* (130) sortlist ::= expr sortorder */
-   -1,  /* (131) sortorder ::= ASC */
-   -1,  /* (132) sortorder ::= DESC */
-    0,  /* (133) sortorder ::= */
-    0,  /* (134) groupby_opt ::= */
-   -3,  /* (135) groupby_opt ::= GROUP BY nexprlist */
-    0,  /* (136) having_opt ::= */
-   -2,  /* (137) having_opt ::= HAVING expr */
-    0,  /* (138) limit_opt ::= */
-   -2,  /* (139) limit_opt ::= LIMIT expr */
-   -4,  /* (140) limit_opt ::= LIMIT expr OFFSET expr */
-   -4,  /* (141) limit_opt ::= LIMIT expr COMMA expr */
-   -6,  /* (142) cmd ::= with DELETE FROM xfullname indexed_opt where_opt */
-    0,  /* (143) where_opt ::= */
-   -2,  /* (144) where_opt ::= WHERE expr */
-   -8,  /* (145) cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt */
-   -5,  /* (146) setlist ::= setlist COMMA nm EQ expr */
-   -7,  /* (147) setlist ::= setlist COMMA LP idlist RP EQ expr */
-   -3,  /* (148) setlist ::= nm EQ expr */
-   -5,  /* (149) setlist ::= LP idlist RP EQ expr */
-   -7,  /* (150) cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert */
-   -7,  /* (151) cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES */
-    0,  /* (152) upsert ::= */
-  -11,  /* (153) upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt */
-   -8,  /* (154) upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING */
-   -4,  /* (155) upsert ::= ON CONFLICT DO NOTHING */
-   -2,  /* (156) insert_cmd ::= INSERT orconf */
-   -1,  /* (157) insert_cmd ::= REPLACE */
-    0,  /* (158) idlist_opt ::= */
-   -3,  /* (159) idlist_opt ::= LP idlist RP */
-   -3,  /* (160) idlist ::= idlist COMMA nm */
-   -1,  /* (161) idlist ::= nm */
-   -3,  /* (162) expr ::= LP expr RP */
-   -1,  /* (163) expr ::= ID|INDEXED */
-   -1,  /* (164) expr ::= JOIN_KW */
-   -3,  /* (165) expr ::= nm DOT nm */
-   -5,  /* (166) expr ::= nm DOT nm DOT nm */
-   -1,  /* (167) term ::= NULL|FLOAT|BLOB */
-   -1,  /* (168) term ::= STRING */
-   -1,  /* (169) term ::= INTEGER */
-   -1,  /* (170) expr ::= VARIABLE */
-   -3,  /* (171) expr ::= expr COLLATE ID|STRING */
-   -6,  /* (172) expr ::= CAST LP expr AS typetoken RP */
-   -5,  /* (173) expr ::= ID|INDEXED LP distinct exprlist RP */
-   -4,  /* (174) expr ::= ID|INDEXED LP STAR RP */
-   -6,  /* (175) expr ::= ID|INDEXED LP distinct exprlist RP over_clause */
-   -5,  /* (176) expr ::= ID|INDEXED LP STAR RP over_clause */
-   -1,  /* (177) term ::= CTIME_KW */
-   -5,  /* (178) expr ::= LP nexprlist COMMA expr RP */
-   -3,  /* (179) expr ::= expr AND expr */
-   -3,  /* (180) expr ::= expr OR expr */
-   -3,  /* (181) expr ::= expr LT|GT|GE|LE expr */
-   -3,  /* (182) expr ::= expr EQ|NE expr */
-   -3,  /* (183) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr */
-   -3,  /* (184) expr ::= expr PLUS|MINUS expr */
-   -3,  /* (185) expr ::= expr STAR|SLASH|REM expr */
-   -3,  /* (186) expr ::= expr CONCAT expr */
-   -2,  /* (187) likeop ::= NOT LIKE_KW|MATCH */
-   -3,  /* (188) expr ::= expr likeop expr */
-   -5,  /* (189) expr ::= expr likeop expr ESCAPE expr */
-   -2,  /* (190) expr ::= expr ISNULL|NOTNULL */
-   -3,  /* (191) expr ::= expr NOT NULL */
-   -3,  /* (192) expr ::= expr IS expr */
-   -4,  /* (193) expr ::= expr IS NOT expr */
-   -2,  /* (194) expr ::= NOT expr */
-   -2,  /* (195) expr ::= BITNOT expr */
-   -2,  /* (196) expr ::= PLUS|MINUS expr */
-   -1,  /* (197) between_op ::= BETWEEN */
-   -2,  /* (198) between_op ::= NOT BETWEEN */
-   -5,  /* (199) expr ::= expr between_op expr AND expr */
-   -1,  /* (200) in_op ::= IN */
-   -2,  /* (201) in_op ::= NOT IN */
-   -5,  /* (202) expr ::= expr in_op LP exprlist RP */
-   -3,  /* (203) expr ::= LP select RP */
-   -5,  /* (204) expr ::= expr in_op LP select RP */
-   -5,  /* (205) expr ::= expr in_op nm dbnm paren_exprlist */
-   -4,  /* (206) expr ::= EXISTS LP select RP */
-   -5,  /* (207) expr ::= CASE case_operand case_exprlist case_else END */
-   -5,  /* (208) case_exprlist ::= case_exprlist WHEN expr THEN expr */
-   -4,  /* (209) case_exprlist ::= WHEN expr THEN expr */
-   -2,  /* (210) case_else ::= ELSE expr */
-    0,  /* (211) case_else ::= */
-   -1,  /* (212) case_operand ::= expr */
-    0,  /* (213) case_operand ::= */
-    0,  /* (214) exprlist ::= */
-   -3,  /* (215) nexprlist ::= nexprlist COMMA expr */
-   -1,  /* (216) nexprlist ::= expr */
-    0,  /* (217) paren_exprlist ::= */
-   -3,  /* (218) paren_exprlist ::= LP exprlist RP */
-  -12,  /* (219) cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt */
-   -1,  /* (220) uniqueflag ::= UNIQUE */
-    0,  /* (221) uniqueflag ::= */
-    0,  /* (222) eidlist_opt ::= */
-   -3,  /* (223) eidlist_opt ::= LP eidlist RP */
-   -5,  /* (224) eidlist ::= eidlist COMMA nm collate sortorder */
-   -3,  /* (225) eidlist ::= nm collate sortorder */
-    0,  /* (226) collate ::= */
-   -2,  /* (227) collate ::= COLLATE ID|STRING */
-   -4,  /* (228) cmd ::= DROP INDEX ifexists fullname */
-   -2,  /* (229) cmd ::= VACUUM vinto */
-   -3,  /* (230) cmd ::= VACUUM nm vinto */
-   -2,  /* (231) vinto ::= INTO expr */
-    0,  /* (232) vinto ::= */
-   -3,  /* (233) cmd ::= PRAGMA nm dbnm */
-   -5,  /* (234) cmd ::= PRAGMA nm dbnm EQ nmnum */
-   -6,  /* (235) cmd ::= PRAGMA nm dbnm LP nmnum RP */
-   -5,  /* (236) cmd ::= PRAGMA nm dbnm EQ minus_num */
-   -6,  /* (237) cmd ::= PRAGMA nm dbnm LP minus_num RP */
-   -2,  /* (238) plus_num ::= PLUS INTEGER|FLOAT */
-   -2,  /* (239) minus_num ::= MINUS INTEGER|FLOAT */
-   -5,  /* (240) cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END */
-  -11,  /* (241) trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause */
-   -1,  /* (242) trigger_time ::= BEFORE|AFTER */
-   -2,  /* (243) trigger_time ::= INSTEAD OF */
-    0,  /* (244) trigger_time ::= */
-   -1,  /* (245) trigger_event ::= DELETE|INSERT */
-   -1,  /* (246) trigger_event ::= UPDATE */
-   -3,  /* (247) trigger_event ::= UPDATE OF idlist */
-    0,  /* (248) when_clause ::= */
-   -2,  /* (249) when_clause ::= WHEN expr */
-   -3,  /* (250) trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI */
-   -2,  /* (251) trigger_cmd_list ::= trigger_cmd SEMI */
-   -3,  /* (252) trnm ::= nm DOT nm */
-   -3,  /* (253) tridxby ::= INDEXED BY nm */
-   -2,  /* (254) tridxby ::= NOT INDEXED */
-   -8,  /* (255) trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt */
-   -8,  /* (256) trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt */
-   -6,  /* (257) trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt */
-   -3,  /* (258) trigger_cmd ::= scanpt select scanpt */
-   -4,  /* (259) expr ::= RAISE LP IGNORE RP */
-   -6,  /* (260) expr ::= RAISE LP raisetype COMMA nm RP */
-   -1,  /* (261) raisetype ::= ROLLBACK */
-   -1,  /* (262) raisetype ::= ABORT */
-   -1,  /* (263) raisetype ::= FAIL */
-   -4,  /* (264) cmd ::= DROP TRIGGER ifexists fullname */
-   -6,  /* (265) cmd ::= ATTACH database_kw_opt expr AS expr key_opt */
-   -3,  /* (266) cmd ::= DETACH database_kw_opt expr */
-    0,  /* (267) key_opt ::= */
-   -2,  /* (268) key_opt ::= KEY expr */
-   -1,  /* (269) cmd ::= REINDEX */
-   -3,  /* (270) cmd ::= REINDEX nm dbnm */
-   -1,  /* (271) cmd ::= ANALYZE */
-   -3,  /* (272) cmd ::= ANALYZE nm dbnm */
-   -6,  /* (273) cmd ::= ALTER TABLE fullname RENAME TO nm */
-   -7,  /* (274) cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist */
-   -1,  /* (275) add_column_fullname ::= fullname */
-   -8,  /* (276) cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm */
-   -1,  /* (277) cmd ::= create_vtab */
-   -4,  /* (278) cmd ::= create_vtab LP vtabarglist RP */
-   -8,  /* (279) create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm */
-    0,  /* (280) vtabarg ::= */
-   -1,  /* (281) vtabargtoken ::= ANY */
-   -3,  /* (282) vtabargtoken ::= lp anylist RP */
-   -1,  /* (283) lp ::= LP */
-   -2,  /* (284) with ::= WITH wqlist */
-   -3,  /* (285) with ::= WITH RECURSIVE wqlist */
-   -6,  /* (286) wqlist ::= nm eidlist_opt AS LP select RP */
-   -8,  /* (287) wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP */
-   -1,  /* (288) windowdefn_list ::= windowdefn */
-   -3,  /* (289) windowdefn_list ::= windowdefn_list COMMA windowdefn */
-   -5,  /* (290) windowdefn ::= nm AS LP window RP */
-   -5,  /* (291) window ::= PARTITION BY nexprlist orderby_opt frame_opt */
-   -6,  /* (292) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt */
-   -4,  /* (293) window ::= ORDER BY sortlist frame_opt */
-   -5,  /* (294) window ::= nm ORDER BY sortlist frame_opt */
-   -1,  /* (295) window ::= frame_opt */
-   -2,  /* (296) window ::= nm frame_opt */
-    0,  /* (297) frame_opt ::= */
-   -3,  /* (298) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt */
-   -6,  /* (299) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt */
-   -1,  /* (300) range_or_rows ::= RANGE|ROWS|GROUPS */
-   -1,  /* (301) frame_bound_s ::= frame_bound */
-   -2,  /* (302) frame_bound_s ::= UNBOUNDED PRECEDING */
-   -1,  /* (303) frame_bound_e ::= frame_bound */
-   -2,  /* (304) frame_bound_e ::= UNBOUNDED FOLLOWING */
-   -2,  /* (305) frame_bound ::= expr PRECEDING|FOLLOWING */
-   -2,  /* (306) frame_bound ::= CURRENT ROW */
-    0,  /* (307) frame_exclude_opt ::= */
-   -2,  /* (308) frame_exclude_opt ::= EXCLUDE frame_exclude */
-   -2,  /* (309) frame_exclude ::= NO OTHERS */
-   -2,  /* (310) frame_exclude ::= CURRENT ROW */
-   -1,  /* (311) frame_exclude ::= GROUP|TIES */
-   -2,  /* (312) window_clause ::= WINDOW windowdefn_list */
-   -5,  /* (313) over_clause ::= filter_opt OVER LP window RP */
-   -3,  /* (314) over_clause ::= filter_opt OVER nm */
-    0,  /* (315) filter_opt ::= */
-   -5,  /* (316) filter_opt ::= FILTER LP WHERE expr RP */
-   -1,  /* (317) input ::= cmdlist */
-   -2,  /* (318) cmdlist ::= cmdlist ecmd */
-   -1,  /* (319) cmdlist ::= ecmd */
-   -1,  /* (320) ecmd ::= SEMI */
-   -2,  /* (321) ecmd ::= cmdx SEMI */
-   -2,  /* (322) ecmd ::= explain cmdx */
-    0,  /* (323) trans_opt ::= */
-   -1,  /* (324) trans_opt ::= TRANSACTION */
-   -2,  /* (325) trans_opt ::= TRANSACTION nm */
-   -1,  /* (326) savepoint_opt ::= SAVEPOINT */
-    0,  /* (327) savepoint_opt ::= */
-   -2,  /* (328) cmd ::= create_table create_table_args */
-   -4,  /* (329) columnlist ::= columnlist COMMA columnname carglist */
-   -2,  /* (330) columnlist ::= columnname carglist */
-   -1,  /* (331) nm ::= ID|INDEXED */
-   -1,  /* (332) nm ::= STRING */
-   -1,  /* (333) nm ::= JOIN_KW */
-   -1,  /* (334) typetoken ::= typename */
-   -1,  /* (335) typename ::= ID|STRING */
-   -1,  /* (336) signed ::= plus_num */
-   -1,  /* (337) signed ::= minus_num */
-   -2,  /* (338) carglist ::= carglist ccons */
-    0,  /* (339) carglist ::= */
-   -2,  /* (340) ccons ::= NULL onconf */
-   -2,  /* (341) conslist_opt ::= COMMA conslist */
-   -3,  /* (342) conslist ::= conslist tconscomma tcons */
-   -1,  /* (343) conslist ::= tcons */
-    0,  /* (344) tconscomma ::= */
-   -1,  /* (345) defer_subclause_opt ::= defer_subclause */
-   -1,  /* (346) resolvetype ::= raisetype */
-   -1,  /* (347) selectnowith ::= oneselect */
-   -1,  /* (348) oneselect ::= values */
-   -2,  /* (349) sclp ::= selcollist COMMA */
-   -1,  /* (350) as ::= ID|STRING */
-   -1,  /* (351) expr ::= term */
-   -1,  /* (352) likeop ::= LIKE_KW|MATCH */
-   -1,  /* (353) exprlist ::= nexprlist */
-   -1,  /* (354) nmnum ::= plus_num */
-   -1,  /* (355) nmnum ::= nm */
-   -1,  /* (356) nmnum ::= ON */
-   -1,  /* (357) nmnum ::= DELETE */
-   -1,  /* (358) nmnum ::= DEFAULT */
-   -1,  /* (359) plus_num ::= INTEGER|FLOAT */
-    0,  /* (360) foreach_clause ::= */
-   -3,  /* (361) foreach_clause ::= FOR EACH ROW */
-   -1,  /* (362) trnm ::= nm */
-    0,  /* (363) tridxby ::= */
-   -1,  /* (364) database_kw_opt ::= DATABASE */
-    0,  /* (365) database_kw_opt ::= */
-    0,  /* (366) kwcolumn_opt ::= */
-   -1,  /* (367) kwcolumn_opt ::= COLUMNKW */
-   -1,  /* (368) vtabarglist ::= vtabarg */
-   -3,  /* (369) vtabarglist ::= vtabarglist COMMA vtabarg */
-   -2,  /* (370) vtabarg ::= vtabarg vtabargtoken */
-    0,  /* (371) anylist ::= */
-   -4,  /* (372) anylist ::= anylist LP anylist RP */
-   -2,  /* (373) anylist ::= anylist ANY */
-    0,  /* (374) with ::= */
+    0,  /* (29) scantok ::= */
+   -2,  /* (30) ccons ::= CONSTRAINT nm */
+   -3,  /* (31) ccons ::= DEFAULT scantok term */
+   -4,  /* (32) ccons ::= DEFAULT LP expr RP */
+   -4,  /* (33) ccons ::= DEFAULT PLUS scantok term */
+   -4,  /* (34) ccons ::= DEFAULT MINUS scantok term */
+   -3,  /* (35) ccons ::= DEFAULT scantok ID|INDEXED */
+   -3,  /* (36) ccons ::= NOT NULL onconf */
+   -5,  /* (37) ccons ::= PRIMARY KEY sortorder onconf autoinc */
+   -2,  /* (38) ccons ::= UNIQUE onconf */
+   -4,  /* (39) ccons ::= CHECK LP expr RP */
+   -4,  /* (40) ccons ::= REFERENCES nm eidlist_opt refargs */
+   -1,  /* (41) ccons ::= defer_subclause */
+   -2,  /* (42) ccons ::= COLLATE ID|STRING */
+    0,  /* (43) autoinc ::= */
+   -1,  /* (44) autoinc ::= AUTOINCR */
+    0,  /* (45) refargs ::= */
+   -2,  /* (46) refargs ::= refargs refarg */
+   -2,  /* (47) refarg ::= MATCH nm */
+   -3,  /* (48) refarg ::= ON INSERT refact */
+   -3,  /* (49) refarg ::= ON DELETE refact */
+   -3,  /* (50) refarg ::= ON UPDATE refact */
+   -2,  /* (51) refact ::= SET NULL */
+   -2,  /* (52) refact ::= SET DEFAULT */
+   -1,  /* (53) refact ::= CASCADE */
+   -1,  /* (54) refact ::= RESTRICT */
+   -2,  /* (55) refact ::= NO ACTION */
+   -3,  /* (56) defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt */
+   -2,  /* (57) defer_subclause ::= DEFERRABLE init_deferred_pred_opt */
+    0,  /* (58) init_deferred_pred_opt ::= */
+   -2,  /* (59) init_deferred_pred_opt ::= INITIALLY DEFERRED */
+   -2,  /* (60) init_deferred_pred_opt ::= INITIALLY IMMEDIATE */
+    0,  /* (61) conslist_opt ::= */
+   -1,  /* (62) tconscomma ::= COMMA */
+   -2,  /* (63) tcons ::= CONSTRAINT nm */
+   -7,  /* (64) tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf */
+   -5,  /* (65) tcons ::= UNIQUE LP sortlist RP onconf */
+   -5,  /* (66) tcons ::= CHECK LP expr RP onconf */
+  -10,  /* (67) tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt */
+    0,  /* (68) defer_subclause_opt ::= */
+    0,  /* (69) onconf ::= */
+   -3,  /* (70) onconf ::= ON CONFLICT resolvetype */
+    0,  /* (71) orconf ::= */
+   -2,  /* (72) orconf ::= OR resolvetype */
+   -1,  /* (73) resolvetype ::= IGNORE */
+   -1,  /* (74) resolvetype ::= REPLACE */
+   -4,  /* (75) cmd ::= DROP TABLE ifexists fullname */
+   -2,  /* (76) ifexists ::= IF EXISTS */
+    0,  /* (77) ifexists ::= */
+   -9,  /* (78) cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select */
+   -4,  /* (79) cmd ::= DROP VIEW ifexists fullname */
+   -1,  /* (80) cmd ::= select */
+   -3,  /* (81) select ::= WITH wqlist selectnowith */
+   -4,  /* (82) select ::= WITH RECURSIVE wqlist selectnowith */
+   -1,  /* (83) select ::= selectnowith */
+   -3,  /* (84) selectnowith ::= selectnowith multiselect_op oneselect */
+   -1,  /* (85) multiselect_op ::= UNION */
+   -2,  /* (86) multiselect_op ::= UNION ALL */
+   -1,  /* (87) multiselect_op ::= EXCEPT|INTERSECT */
+   -9,  /* (88) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt */
+  -10,  /* (89) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt */
+   -4,  /* (90) values ::= VALUES LP nexprlist RP */
+   -5,  /* (91) values ::= values COMMA LP nexprlist RP */
+   -1,  /* (92) distinct ::= DISTINCT */
+   -1,  /* (93) distinct ::= ALL */
+    0,  /* (94) distinct ::= */
+    0,  /* (95) sclp ::= */
+   -5,  /* (96) selcollist ::= sclp scanpt expr scanpt as */
+   -3,  /* (97) selcollist ::= sclp scanpt STAR */
+   -5,  /* (98) selcollist ::= sclp scanpt nm DOT STAR */
+   -2,  /* (99) as ::= AS nm */
+    0,  /* (100) as ::= */
+    0,  /* (101) from ::= */
+   -2,  /* (102) from ::= FROM seltablist */
+   -2,  /* (103) stl_prefix ::= seltablist joinop */
+    0,  /* (104) stl_prefix ::= */
+   -7,  /* (105) seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt */
+   -9,  /* (106) seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt */
+   -7,  /* (107) seltablist ::= stl_prefix LP select RP as on_opt using_opt */
+   -7,  /* (108) seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt */
+    0,  /* (109) dbnm ::= */
+   -2,  /* (110) dbnm ::= DOT nm */
+   -1,  /* (111) fullname ::= nm */
+   -3,  /* (112) fullname ::= nm DOT nm */
+   -1,  /* (113) xfullname ::= nm */
+   -3,  /* (114) xfullname ::= nm DOT nm */
+   -5,  /* (115) xfullname ::= nm DOT nm AS nm */
+   -3,  /* (116) xfullname ::= nm AS nm */
+   -1,  /* (117) joinop ::= COMMA|JOIN */
+   -2,  /* (118) joinop ::= JOIN_KW JOIN */
+   -3,  /* (119) joinop ::= JOIN_KW nm JOIN */
+   -4,  /* (120) joinop ::= JOIN_KW nm nm JOIN */
+   -2,  /* (121) on_opt ::= ON expr */
+    0,  /* (122) on_opt ::= */
+    0,  /* (123) indexed_opt ::= */
+   -3,  /* (124) indexed_opt ::= INDEXED BY nm */
+   -2,  /* (125) indexed_opt ::= NOT INDEXED */
+   -4,  /* (126) using_opt ::= USING LP idlist RP */
+    0,  /* (127) using_opt ::= */
+    0,  /* (128) orderby_opt ::= */
+   -3,  /* (129) orderby_opt ::= ORDER BY sortlist */
+   -5,  /* (130) sortlist ::= sortlist COMMA expr sortorder nulls */
+   -3,  /* (131) sortlist ::= expr sortorder nulls */
+   -1,  /* (132) sortorder ::= ASC */
+   -1,  /* (133) sortorder ::= DESC */
+    0,  /* (134) sortorder ::= */
+   -2,  /* (135) nulls ::= NULLS FIRST */
+   -2,  /* (136) nulls ::= NULLS LAST */
+    0,  /* (137) nulls ::= */
+    0,  /* (138) groupby_opt ::= */
+   -3,  /* (139) groupby_opt ::= GROUP BY nexprlist */
+    0,  /* (140) having_opt ::= */
+   -2,  /* (141) having_opt ::= HAVING expr */
+    0,  /* (142) limit_opt ::= */
+   -2,  /* (143) limit_opt ::= LIMIT expr */
+   -4,  /* (144) limit_opt ::= LIMIT expr OFFSET expr */
+   -4,  /* (145) limit_opt ::= LIMIT expr COMMA expr */
+   -6,  /* (146) cmd ::= with DELETE FROM xfullname indexed_opt where_opt */
+    0,  /* (147) where_opt ::= */
+   -2,  /* (148) where_opt ::= WHERE expr */
+   -8,  /* (149) cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt */
+   -5,  /* (150) setlist ::= setlist COMMA nm EQ expr */
+   -7,  /* (151) setlist ::= setlist COMMA LP idlist RP EQ expr */
+   -3,  /* (152) setlist ::= nm EQ expr */
+   -5,  /* (153) setlist ::= LP idlist RP EQ expr */
+   -7,  /* (154) cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert */
+   -7,  /* (155) cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES */
+    0,  /* (156) upsert ::= */
+  -11,  /* (157) upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt */
+   -8,  /* (158) upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING */
+   -4,  /* (159) upsert ::= ON CONFLICT DO NOTHING */
+   -2,  /* (160) insert_cmd ::= INSERT orconf */
+   -1,  /* (161) insert_cmd ::= REPLACE */
+    0,  /* (162) idlist_opt ::= */
+   -3,  /* (163) idlist_opt ::= LP idlist RP */
+   -3,  /* (164) idlist ::= idlist COMMA nm */
+   -1,  /* (165) idlist ::= nm */
+   -3,  /* (166) expr ::= LP expr RP */
+   -1,  /* (167) expr ::= ID|INDEXED */
+   -1,  /* (168) expr ::= JOIN_KW */
+   -3,  /* (169) expr ::= nm DOT nm */
+   -5,  /* (170) expr ::= nm DOT nm DOT nm */
+   -1,  /* (171) term ::= NULL|FLOAT|BLOB */
+   -1,  /* (172) term ::= STRING */
+   -1,  /* (173) term ::= INTEGER */
+   -1,  /* (174) expr ::= VARIABLE */
+   -3,  /* (175) expr ::= expr COLLATE ID|STRING */
+   -6,  /* (176) expr ::= CAST LP expr AS typetoken RP */
+   -5,  /* (177) expr ::= ID|INDEXED LP distinct exprlist RP */
+   -4,  /* (178) expr ::= ID|INDEXED LP STAR RP */
+   -6,  /* (179) expr ::= ID|INDEXED LP distinct exprlist RP filter_over */
+   -5,  /* (180) expr ::= ID|INDEXED LP STAR RP filter_over */
+   -1,  /* (181) term ::= CTIME_KW */
+   -5,  /* (182) expr ::= LP nexprlist COMMA expr RP */
+   -3,  /* (183) expr ::= expr AND expr */
+   -3,  /* (184) expr ::= expr OR expr */
+   -3,  /* (185) expr ::= expr LT|GT|GE|LE expr */
+   -3,  /* (186) expr ::= expr EQ|NE expr */
+   -3,  /* (187) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr */
+   -3,  /* (188) expr ::= expr PLUS|MINUS expr */
+   -3,  /* (189) expr ::= expr STAR|SLASH|REM expr */
+   -3,  /* (190) expr ::= expr CONCAT expr */
+   -2,  /* (191) likeop ::= NOT LIKE_KW|MATCH */
+   -3,  /* (192) expr ::= expr likeop expr */
+   -5,  /* (193) expr ::= expr likeop expr ESCAPE expr */
+   -2,  /* (194) expr ::= expr ISNULL|NOTNULL */
+   -3,  /* (195) expr ::= expr NOT NULL */
+   -3,  /* (196) expr ::= expr IS expr */
+   -4,  /* (197) expr ::= expr IS NOT expr */
+   -2,  /* (198) expr ::= NOT expr */
+   -2,  /* (199) expr ::= BITNOT expr */
+   -2,  /* (200) expr ::= PLUS|MINUS expr */
+   -1,  /* (201) between_op ::= BETWEEN */
+   -2,  /* (202) between_op ::= NOT BETWEEN */
+   -5,  /* (203) expr ::= expr between_op expr AND expr */
+   -1,  /* (204) in_op ::= IN */
+   -2,  /* (205) in_op ::= NOT IN */
+   -5,  /* (206) expr ::= expr in_op LP exprlist RP */
+   -3,  /* (207) expr ::= LP select RP */
+   -5,  /* (208) expr ::= expr in_op LP select RP */
+   -5,  /* (209) expr ::= expr in_op nm dbnm paren_exprlist */
+   -4,  /* (210) expr ::= EXISTS LP select RP */
+   -5,  /* (211) expr ::= CASE case_operand case_exprlist case_else END */
+   -5,  /* (212) case_exprlist ::= case_exprlist WHEN expr THEN expr */
+   -4,  /* (213) case_exprlist ::= WHEN expr THEN expr */
+   -2,  /* (214) case_else ::= ELSE expr */
+    0,  /* (215) case_else ::= */
+   -1,  /* (216) case_operand ::= expr */
+    0,  /* (217) case_operand ::= */
+    0,  /* (218) exprlist ::= */
+   -3,  /* (219) nexprlist ::= nexprlist COMMA expr */
+   -1,  /* (220) nexprlist ::= expr */
+    0,  /* (221) paren_exprlist ::= */
+   -3,  /* (222) paren_exprlist ::= LP exprlist RP */
+  -12,  /* (223) cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt */
+   -1,  /* (224) uniqueflag ::= UNIQUE */
+    0,  /* (225) uniqueflag ::= */
+    0,  /* (226) eidlist_opt ::= */
+   -3,  /* (227) eidlist_opt ::= LP eidlist RP */
+   -5,  /* (228) eidlist ::= eidlist COMMA nm collate sortorder */
+   -3,  /* (229) eidlist ::= nm collate sortorder */
+    0,  /* (230) collate ::= */
+   -2,  /* (231) collate ::= COLLATE ID|STRING */
+   -4,  /* (232) cmd ::= DROP INDEX ifexists fullname */
+   -2,  /* (233) cmd ::= VACUUM vinto */
+   -3,  /* (234) cmd ::= VACUUM nm vinto */
+   -2,  /* (235) vinto ::= INTO expr */
+    0,  /* (236) vinto ::= */
+   -3,  /* (237) cmd ::= PRAGMA nm dbnm */
+   -5,  /* (238) cmd ::= PRAGMA nm dbnm EQ nmnum */
+   -6,  /* (239) cmd ::= PRAGMA nm dbnm LP nmnum RP */
+   -5,  /* (240) cmd ::= PRAGMA nm dbnm EQ minus_num */
+   -6,  /* (241) cmd ::= PRAGMA nm dbnm LP minus_num RP */
+   -2,  /* (242) plus_num ::= PLUS INTEGER|FLOAT */
+   -2,  /* (243) minus_num ::= MINUS INTEGER|FLOAT */
+   -5,  /* (244) cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END */
+  -11,  /* (245) trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause */
+   -1,  /* (246) trigger_time ::= BEFORE|AFTER */
+   -2,  /* (247) trigger_time ::= INSTEAD OF */
+    0,  /* (248) trigger_time ::= */
+   -1,  /* (249) trigger_event ::= DELETE|INSERT */
+   -1,  /* (250) trigger_event ::= UPDATE */
+   -3,  /* (251) trigger_event ::= UPDATE OF idlist */
+    0,  /* (252) when_clause ::= */
+   -2,  /* (253) when_clause ::= WHEN expr */
+   -3,  /* (254) trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI */
+   -2,  /* (255) trigger_cmd_list ::= trigger_cmd SEMI */
+   -3,  /* (256) trnm ::= nm DOT nm */
+   -3,  /* (257) tridxby ::= INDEXED BY nm */
+   -2,  /* (258) tridxby ::= NOT INDEXED */
+   -8,  /* (259) trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt */
+   -8,  /* (260) trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt */
+   -6,  /* (261) trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt */
+   -3,  /* (262) trigger_cmd ::= scanpt select scanpt */
+   -4,  /* (263) expr ::= RAISE LP IGNORE RP */
+   -6,  /* (264) expr ::= RAISE LP raisetype COMMA nm RP */
+   -1,  /* (265) raisetype ::= ROLLBACK */
+   -1,  /* (266) raisetype ::= ABORT */
+   -1,  /* (267) raisetype ::= FAIL */
+   -4,  /* (268) cmd ::= DROP TRIGGER ifexists fullname */
+   -6,  /* (269) cmd ::= ATTACH database_kw_opt expr AS expr key_opt */
+   -3,  /* (270) cmd ::= DETACH database_kw_opt expr */
+    0,  /* (271) key_opt ::= */
+   -2,  /* (272) key_opt ::= KEY expr */
+   -1,  /* (273) cmd ::= REINDEX */
+   -3,  /* (274) cmd ::= REINDEX nm dbnm */
+   -1,  /* (275) cmd ::= ANALYZE */
+   -3,  /* (276) cmd ::= ANALYZE nm dbnm */
+   -6,  /* (277) cmd ::= ALTER TABLE fullname RENAME TO nm */
+   -7,  /* (278) cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist */
+   -1,  /* (279) add_column_fullname ::= fullname */
+   -8,  /* (280) cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm */
+   -1,  /* (281) cmd ::= create_vtab */
+   -4,  /* (282) cmd ::= create_vtab LP vtabarglist RP */
+   -8,  /* (283) create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm */
+    0,  /* (284) vtabarg ::= */
+   -1,  /* (285) vtabargtoken ::= ANY */
+   -3,  /* (286) vtabargtoken ::= lp anylist RP */
+   -1,  /* (287) lp ::= LP */
+   -2,  /* (288) with ::= WITH wqlist */
+   -3,  /* (289) with ::= WITH RECURSIVE wqlist */
+   -6,  /* (290) wqlist ::= nm eidlist_opt AS LP select RP */
+   -8,  /* (291) wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP */
+   -1,  /* (292) windowdefn_list ::= windowdefn */
+   -3,  /* (293) windowdefn_list ::= windowdefn_list COMMA windowdefn */
+   -5,  /* (294) windowdefn ::= nm AS LP window RP */
+   -5,  /* (295) window ::= PARTITION BY nexprlist orderby_opt frame_opt */
+   -6,  /* (296) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt */
+   -4,  /* (297) window ::= ORDER BY sortlist frame_opt */
+   -5,  /* (298) window ::= nm ORDER BY sortlist frame_opt */
+   -1,  /* (299) window ::= frame_opt */
+   -2,  /* (300) window ::= nm frame_opt */
+    0,  /* (301) frame_opt ::= */
+   -3,  /* (302) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt */
+   -6,  /* (303) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt */
+   -1,  /* (304) range_or_rows ::= RANGE|ROWS|GROUPS */
+   -1,  /* (305) frame_bound_s ::= frame_bound */
+   -2,  /* (306) frame_bound_s ::= UNBOUNDED PRECEDING */
+   -1,  /* (307) frame_bound_e ::= frame_bound */
+   -2,  /* (308) frame_bound_e ::= UNBOUNDED FOLLOWING */
+   -2,  /* (309) frame_bound ::= expr PRECEDING|FOLLOWING */
+   -2,  /* (310) frame_bound ::= CURRENT ROW */
+    0,  /* (311) frame_exclude_opt ::= */
+   -2,  /* (312) frame_exclude_opt ::= EXCLUDE frame_exclude */
+   -2,  /* (313) frame_exclude ::= NO OTHERS */
+   -2,  /* (314) frame_exclude ::= CURRENT ROW */
+   -1,  /* (315) frame_exclude ::= GROUP|TIES */
+   -2,  /* (316) window_clause ::= WINDOW windowdefn_list */
+   -2,  /* (317) filter_over ::= filter_clause over_clause */
+   -1,  /* (318) filter_over ::= over_clause */
+   -1,  /* (319) filter_over ::= filter_clause */
+   -4,  /* (320) over_clause ::= OVER LP window RP */
+   -2,  /* (321) over_clause ::= OVER nm */
+   -5,  /* (322) filter_clause ::= FILTER LP WHERE expr RP */
+   -1,  /* (323) input ::= cmdlist */
+   -2,  /* (324) cmdlist ::= cmdlist ecmd */
+   -1,  /* (325) cmdlist ::= ecmd */
+   -1,  /* (326) ecmd ::= SEMI */
+   -2,  /* (327) ecmd ::= cmdx SEMI */
+   -2,  /* (328) ecmd ::= explain cmdx */
+    0,  /* (329) trans_opt ::= */
+   -1,  /* (330) trans_opt ::= TRANSACTION */
+   -2,  /* (331) trans_opt ::= TRANSACTION nm */
+   -1,  /* (332) savepoint_opt ::= SAVEPOINT */
+    0,  /* (333) savepoint_opt ::= */
+   -2,  /* (334) cmd ::= create_table create_table_args */
+   -4,  /* (335) columnlist ::= columnlist COMMA columnname carglist */
+   -2,  /* (336) columnlist ::= columnname carglist */
+   -1,  /* (337) nm ::= ID|INDEXED */
+   -1,  /* (338) nm ::= STRING */
+   -1,  /* (339) nm ::= JOIN_KW */
+   -1,  /* (340) typetoken ::= typename */
+   -1,  /* (341) typename ::= ID|STRING */
+   -1,  /* (342) signed ::= plus_num */
+   -1,  /* (343) signed ::= minus_num */
+   -2,  /* (344) carglist ::= carglist ccons */
+    0,  /* (345) carglist ::= */
+   -2,  /* (346) ccons ::= NULL onconf */
+   -2,  /* (347) conslist_opt ::= COMMA conslist */
+   -3,  /* (348) conslist ::= conslist tconscomma tcons */
+   -1,  /* (349) conslist ::= tcons */
+    0,  /* (350) tconscomma ::= */
+   -1,  /* (351) defer_subclause_opt ::= defer_subclause */
+   -1,  /* (352) resolvetype ::= raisetype */
+   -1,  /* (353) selectnowith ::= oneselect */
+   -1,  /* (354) oneselect ::= values */
+   -2,  /* (355) sclp ::= selcollist COMMA */
+   -1,  /* (356) as ::= ID|STRING */
+   -1,  /* (357) expr ::= term */
+   -1,  /* (358) likeop ::= LIKE_KW|MATCH */
+   -1,  /* (359) exprlist ::= nexprlist */
+   -1,  /* (360) nmnum ::= plus_num */
+   -1,  /* (361) nmnum ::= nm */
+   -1,  /* (362) nmnum ::= ON */
+   -1,  /* (363) nmnum ::= DELETE */
+   -1,  /* (364) nmnum ::= DEFAULT */
+   -1,  /* (365) plus_num ::= INTEGER|FLOAT */
+    0,  /* (366) foreach_clause ::= */
+   -3,  /* (367) foreach_clause ::= FOR EACH ROW */
+   -1,  /* (368) trnm ::= nm */
+    0,  /* (369) tridxby ::= */
+   -1,  /* (370) database_kw_opt ::= DATABASE */
+    0,  /* (371) database_kw_opt ::= */
+    0,  /* (372) kwcolumn_opt ::= */
+   -1,  /* (373) kwcolumn_opt ::= COLUMNKW */
+   -1,  /* (374) vtabarglist ::= vtabarg */
+   -3,  /* (375) vtabarglist ::= vtabarglist COMMA vtabarg */
+   -2,  /* (376) vtabarg ::= vtabarg vtabargtoken */
+    0,  /* (377) anylist ::= */
+   -4,  /* (378) anylist ::= anylist LP anylist RP */
+   -2,  /* (379) anylist ::= anylist ANY */
+    0,  /* (380) with ::= */
 };
 
 static void yy_accept(yyParser*);  /* Forward Declaration */
 
 /*
@@ -151319,20 +152939,20 @@
         break;
       case 2: /* cmdx ::= cmd */
 { sqlite3FinishCoding(pParse); }
         break;
       case 3: /* cmd ::= BEGIN transtype trans_opt */
-{sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy494);}
+{sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy32);}
         break;
       case 4: /* transtype ::= */
-{yymsp[1].minor.yy494 = TK_DEFERRED;}
+{yymsp[1].minor.yy32 = TK_DEFERRED;}
         break;
       case 5: /* transtype ::= DEFERRED */
       case 6: /* transtype ::= IMMEDIATE */ yytestcase(yyruleno==6);
       case 7: /* transtype ::= EXCLUSIVE */ yytestcase(yyruleno==7);
-      case 300: /* range_or_rows ::= RANGE|ROWS|GROUPS */ yytestcase(yyruleno==300);
-{yymsp[0].minor.yy494 = yymsp[0].major; /*A-overwrites-X*/}
+      case 304: /* range_or_rows ::= RANGE|ROWS|GROUPS */ yytestcase(yyruleno==304);
+{yymsp[0].minor.yy32 = yymsp[0].major; /*A-overwrites-X*/}
         break;
       case 8: /* cmd ::= COMMIT|END trans_opt */
       case 9: /* cmd ::= ROLLBACK trans_opt */ yytestcase(yyruleno==9);
 {sqlite3EndTransaction(pParse,yymsp[-1].major);}
         break;
@@ -151351,61 +152971,61 @@
   sqlite3Savepoint(pParse, SAVEPOINT_ROLLBACK, &yymsp[0].minor.yy0);
 }
         break;
       case 13: /* create_table ::= createkw temp TABLE ifnotexists nm dbnm */
 {
-   sqlite3StartTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,yymsp[-4].minor.yy494,0,0,yymsp[-2].minor.yy494);
+   sqlite3StartTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,yymsp[-4].minor.yy32,0,0,yymsp[-2].minor.yy32);
 }
         break;
       case 14: /* createkw ::= CREATE */
 {disableLookaside(pParse);}
         break;
       case 15: /* ifnotexists ::= */
       case 18: /* temp ::= */ yytestcase(yyruleno==18);
       case 21: /* table_options ::= */ yytestcase(yyruleno==21);
-      case 42: /* autoinc ::= */ yytestcase(yyruleno==42);
-      case 57: /* init_deferred_pred_opt ::= */ yytestcase(yyruleno==57);
-      case 67: /* defer_subclause_opt ::= */ yytestcase(yyruleno==67);
-      case 76: /* ifexists ::= */ yytestcase(yyruleno==76);
-      case 93: /* distinct ::= */ yytestcase(yyruleno==93);
-      case 226: /* collate ::= */ yytestcase(yyruleno==226);
-{yymsp[1].minor.yy494 = 0;}
+      case 43: /* autoinc ::= */ yytestcase(yyruleno==43);
+      case 58: /* init_deferred_pred_opt ::= */ yytestcase(yyruleno==58);
+      case 68: /* defer_subclause_opt ::= */ yytestcase(yyruleno==68);
+      case 77: /* ifexists ::= */ yytestcase(yyruleno==77);
+      case 94: /* distinct ::= */ yytestcase(yyruleno==94);
+      case 230: /* collate ::= */ yytestcase(yyruleno==230);
+{yymsp[1].minor.yy32 = 0;}
         break;
       case 16: /* ifnotexists ::= IF NOT EXISTS */
-{yymsp[-2].minor.yy494 = 1;}
+{yymsp[-2].minor.yy32 = 1;}
         break;
       case 17: /* temp ::= TEMP */
-      case 43: /* autoinc ::= AUTOINCR */ yytestcase(yyruleno==43);
-{yymsp[0].minor.yy494 = 1;}
+      case 44: /* autoinc ::= AUTOINCR */ yytestcase(yyruleno==44);
+{yymsp[0].minor.yy32 = 1;}
         break;
       case 19: /* create_table_args ::= LP columnlist conslist_opt RP table_options */
 {
-  sqlite3EndTable(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,yymsp[0].minor.yy494,0);
+  sqlite3EndTable(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,yymsp[0].minor.yy32,0);
 }
         break;
       case 20: /* create_table_args ::= AS select */
 {
-  sqlite3EndTable(pParse,0,0,0,yymsp[0].minor.yy457);
-  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy457);
+  sqlite3EndTable(pParse,0,0,0,yymsp[0].minor.yy25);
+  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy25);
 }
         break;
       case 22: /* table_options ::= WITHOUT nm */
 {
   if( yymsp[0].minor.yy0.n==5 && sqlite3_strnicmp(yymsp[0].minor.yy0.z,"rowid",5)==0 ){
-    yymsp[-1].minor.yy494 = TF_WithoutRowid | TF_NoVisibleRowid;
+    yymsp[-1].minor.yy32 = TF_WithoutRowid | TF_NoVisibleRowid;
   }else{
-    yymsp[-1].minor.yy494 = 0;
+    yymsp[-1].minor.yy32 = 0;
     sqlite3ErrorMsg(pParse, "unknown table option: %.*s", yymsp[0].minor.yy0.n, yymsp[0].minor.yy0.z);
   }
 }
         break;
       case 23: /* columnname ::= nm typetoken */
 {sqlite3AddColumn(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0);}
         break;
       case 24: /* typetoken ::= */
-      case 60: /* conslist_opt ::= */ yytestcase(yyruleno==60);
-      case 99: /* as ::= */ yytestcase(yyruleno==99);
+      case 61: /* conslist_opt ::= */ yytestcase(yyruleno==61);
+      case 100: /* as ::= */ yytestcase(yyruleno==100);
 {yymsp[1].minor.yy0.n = 0; yymsp[1].minor.yy0.z = 0;}
         break;
       case 25: /* typetoken ::= typename LP signed RP */
 {
   yymsp[-3].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-3].minor.yy0.z);
@@ -151420,352 +153040,358 @@
 {yymsp[-1].minor.yy0.n=yymsp[0].minor.yy0.n+(int)(yymsp[0].minor.yy0.z-yymsp[-1].minor.yy0.z);}
         break;
       case 28: /* scanpt ::= */
 {
   assert( yyLookahead!=YYNOCODE );
-  yymsp[1].minor.yy294 = yyLookaheadToken.z;
+  yymsp[1].minor.yy8 = yyLookaheadToken.z;
+}
+        break;
+      case 29: /* scantok ::= */
+{
+  assert( yyLookahead!=YYNOCODE );
+  yymsp[1].minor.yy0 = yyLookaheadToken;
 }
         break;
-      case 29: /* ccons ::= CONSTRAINT nm */
-      case 62: /* tcons ::= CONSTRAINT nm */ yytestcase(yyruleno==62);
+      case 30: /* ccons ::= CONSTRAINT nm */
+      case 63: /* tcons ::= CONSTRAINT nm */ yytestcase(yyruleno==63);
 {pParse->constraintName = yymsp[0].minor.yy0;}
         break;
-      case 30: /* ccons ::= DEFAULT scanpt term scanpt */
-{sqlite3AddDefaultValue(pParse,yymsp[-1].minor.yy524,yymsp[-2].minor.yy294,yymsp[0].minor.yy294);}
+      case 31: /* ccons ::= DEFAULT scantok term */
+{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy46,yymsp[-1].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}
         break;
-      case 31: /* ccons ::= DEFAULT LP expr RP */
-{sqlite3AddDefaultValue(pParse,yymsp[-1].minor.yy524,yymsp[-2].minor.yy0.z+1,yymsp[0].minor.yy0.z);}
+      case 32: /* ccons ::= DEFAULT LP expr RP */
+{sqlite3AddDefaultValue(pParse,yymsp[-1].minor.yy46,yymsp[-2].minor.yy0.z+1,yymsp[0].minor.yy0.z);}
         break;
-      case 32: /* ccons ::= DEFAULT PLUS term scanpt */
-{sqlite3AddDefaultValue(pParse,yymsp[-1].minor.yy524,yymsp[-2].minor.yy0.z,yymsp[0].minor.yy294);}
+      case 33: /* ccons ::= DEFAULT PLUS scantok term */
+{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy46,yymsp[-2].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}
         break;
-      case 33: /* ccons ::= DEFAULT MINUS term scanpt */
+      case 34: /* ccons ::= DEFAULT MINUS scantok term */
 {
-  Expr *p = sqlite3PExpr(pParse, TK_UMINUS, yymsp[-1].minor.yy524, 0);
-  sqlite3AddDefaultValue(pParse,p,yymsp[-2].minor.yy0.z,yymsp[0].minor.yy294);
+  Expr *p = sqlite3PExpr(pParse, TK_UMINUS, yymsp[0].minor.yy46, 0);
+  sqlite3AddDefaultValue(pParse,p,yymsp[-2].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);
 }
         break;
-      case 34: /* ccons ::= DEFAULT scanpt ID|INDEXED */
+      case 35: /* ccons ::= DEFAULT scantok ID|INDEXED */
 {
   Expr *p = tokenExpr(pParse, TK_STRING, yymsp[0].minor.yy0);
   if( p ){
     sqlite3ExprIdToTrueFalse(p);
     testcase( p->op==TK_TRUEFALSE && sqlite3ExprTruthValue(p) );
   }
     sqlite3AddDefaultValue(pParse,p,yymsp[0].minor.yy0.z,yymsp[0].minor.yy0.z+yymsp[0].minor.yy0.n);
 }
         break;
-      case 35: /* ccons ::= NOT NULL onconf */
-{sqlite3AddNotNull(pParse, yymsp[0].minor.yy494);}
+      case 36: /* ccons ::= NOT NULL onconf */
+{sqlite3AddNotNull(pParse, yymsp[0].minor.yy32);}
         break;
-      case 36: /* ccons ::= PRIMARY KEY sortorder onconf autoinc */
-{sqlite3AddPrimaryKey(pParse,0,yymsp[-1].minor.yy494,yymsp[0].minor.yy494,yymsp[-2].minor.yy494);}
+      case 37: /* ccons ::= PRIMARY KEY sortorder onconf autoinc */
+{sqlite3AddPrimaryKey(pParse,0,yymsp[-1].minor.yy32,yymsp[0].minor.yy32,yymsp[-2].minor.yy32);}
         break;
-      case 37: /* ccons ::= UNIQUE onconf */
-{sqlite3CreateIndex(pParse,0,0,0,0,yymsp[0].minor.yy494,0,0,0,0,
+      case 38: /* ccons ::= UNIQUE onconf */
+{sqlite3CreateIndex(pParse,0,0,0,0,yymsp[0].minor.yy32,0,0,0,0,
                                    SQLITE_IDXTYPE_UNIQUE);}
         break;
-      case 38: /* ccons ::= CHECK LP expr RP */
-{sqlite3AddCheckConstraint(pParse,yymsp[-1].minor.yy524);}
+      case 39: /* ccons ::= CHECK LP expr RP */
+{sqlite3AddCheckConstraint(pParse,yymsp[-1].minor.yy46);}
         break;
-      case 39: /* ccons ::= REFERENCES nm eidlist_opt refargs */
-{sqlite3CreateForeignKey(pParse,0,&yymsp[-2].minor.yy0,yymsp[-1].minor.yy434,yymsp[0].minor.yy494);}
+      case 40: /* ccons ::= REFERENCES nm eidlist_opt refargs */
+{sqlite3CreateForeignKey(pParse,0,&yymsp[-2].minor.yy0,yymsp[-1].minor.yy138,yymsp[0].minor.yy32);}
         break;
-      case 40: /* ccons ::= defer_subclause */
-{sqlite3DeferForeignKey(pParse,yymsp[0].minor.yy494);}
+      case 41: /* ccons ::= defer_subclause */
+{sqlite3DeferForeignKey(pParse,yymsp[0].minor.yy32);}
         break;
-      case 41: /* ccons ::= COLLATE ID|STRING */
+      case 42: /* ccons ::= COLLATE ID|STRING */
 {sqlite3AddCollateType(pParse, &yymsp[0].minor.yy0);}
         break;
-      case 44: /* refargs ::= */
-{ yymsp[1].minor.yy494 = OE_None*0x0101; /* EV: R-19803-45884 */}
+      case 45: /* refargs ::= */
+{ yymsp[1].minor.yy32 = OE_None*0x0101; /* EV: R-19803-45884 */}
         break;
-      case 45: /* refargs ::= refargs refarg */
-{ yymsp[-1].minor.yy494 = (yymsp[-1].minor.yy494 & ~yymsp[0].minor.yy355.mask) | yymsp[0].minor.yy355.value; }
+      case 46: /* refargs ::= refargs refarg */
+{ yymsp[-1].minor.yy32 = (yymsp[-1].minor.yy32 & ~yymsp[0].minor.yy495.mask) | yymsp[0].minor.yy495.value; }
         break;
-      case 46: /* refarg ::= MATCH nm */
-{ yymsp[-1].minor.yy355.value = 0;     yymsp[-1].minor.yy355.mask = 0x000000; }
+      case 47: /* refarg ::= MATCH nm */
+{ yymsp[-1].minor.yy495.value = 0;     yymsp[-1].minor.yy495.mask = 0x000000; }
         break;
-      case 47: /* refarg ::= ON INSERT refact */
-{ yymsp[-2].minor.yy355.value = 0;     yymsp[-2].minor.yy355.mask = 0x000000; }
+      case 48: /* refarg ::= ON INSERT refact */
+{ yymsp[-2].minor.yy495.value = 0;     yymsp[-2].minor.yy495.mask = 0x000000; }
         break;
-      case 48: /* refarg ::= ON DELETE refact */
-{ yymsp[-2].minor.yy355.value = yymsp[0].minor.yy494;     yymsp[-2].minor.yy355.mask = 0x0000ff; }
+      case 49: /* refarg ::= ON DELETE refact */
+{ yymsp[-2].minor.yy495.value = yymsp[0].minor.yy32;     yymsp[-2].minor.yy495.mask = 0x0000ff; }
         break;
-      case 49: /* refarg ::= ON UPDATE refact */
-{ yymsp[-2].minor.yy355.value = yymsp[0].minor.yy494<<8;  yymsp[-2].minor.yy355.mask = 0x00ff00; }
+      case 50: /* refarg ::= ON UPDATE refact */
+{ yymsp[-2].minor.yy495.value = yymsp[0].minor.yy32<<8;  yymsp[-2].minor.yy495.mask = 0x00ff00; }
         break;
-      case 50: /* refact ::= SET NULL */
-{ yymsp[-1].minor.yy494 = OE_SetNull;  /* EV: R-33326-45252 */}
+      case 51: /* refact ::= SET NULL */
+{ yymsp[-1].minor.yy32 = OE_SetNull;  /* EV: R-33326-45252 */}
         break;
-      case 51: /* refact ::= SET DEFAULT */
-{ yymsp[-1].minor.yy494 = OE_SetDflt;  /* EV: R-33326-45252 */}
+      case 52: /* refact ::= SET DEFAULT */
+{ yymsp[-1].minor.yy32 = OE_SetDflt;  /* EV: R-33326-45252 */}
         break;
-      case 52: /* refact ::= CASCADE */
-{ yymsp[0].minor.yy494 = OE_Cascade;  /* EV: R-33326-45252 */}
+      case 53: /* refact ::= CASCADE */
+{ yymsp[0].minor.yy32 = OE_Cascade;  /* EV: R-33326-45252 */}
         break;
-      case 53: /* refact ::= RESTRICT */
-{ yymsp[0].minor.yy494 = OE_Restrict; /* EV: R-33326-45252 */}
+      case 54: /* refact ::= RESTRICT */
+{ yymsp[0].minor.yy32 = OE_Restrict; /* EV: R-33326-45252 */}
         break;
-      case 54: /* refact ::= NO ACTION */
-{ yymsp[-1].minor.yy494 = OE_None;     /* EV: R-33326-45252 */}
+      case 55: /* refact ::= NO ACTION */
+{ yymsp[-1].minor.yy32 = OE_None;     /* EV: R-33326-45252 */}
         break;
-      case 55: /* defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt */
-{yymsp[-2].minor.yy494 = 0;}
+      case 56: /* defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt */
+{yymsp[-2].minor.yy32 = 0;}
         break;
-      case 56: /* defer_subclause ::= DEFERRABLE init_deferred_pred_opt */
-      case 71: /* orconf ::= OR resolvetype */ yytestcase(yyruleno==71);
-      case 156: /* insert_cmd ::= INSERT orconf */ yytestcase(yyruleno==156);
-{yymsp[-1].minor.yy494 = yymsp[0].minor.yy494;}
+      case 57: /* defer_subclause ::= DEFERRABLE init_deferred_pred_opt */
+      case 72: /* orconf ::= OR resolvetype */ yytestcase(yyruleno==72);
+      case 160: /* insert_cmd ::= INSERT orconf */ yytestcase(yyruleno==160);
+{yymsp[-1].minor.yy32 = yymsp[0].minor.yy32;}
         break;
-      case 58: /* init_deferred_pred_opt ::= INITIALLY DEFERRED */
-      case 75: /* ifexists ::= IF EXISTS */ yytestcase(yyruleno==75);
-      case 198: /* between_op ::= NOT BETWEEN */ yytestcase(yyruleno==198);
-      case 201: /* in_op ::= NOT IN */ yytestcase(yyruleno==201);
-      case 227: /* collate ::= COLLATE ID|STRING */ yytestcase(yyruleno==227);
-{yymsp[-1].minor.yy494 = 1;}
+      case 59: /* init_deferred_pred_opt ::= INITIALLY DEFERRED */
+      case 76: /* ifexists ::= IF EXISTS */ yytestcase(yyruleno==76);
+      case 202: /* between_op ::= NOT BETWEEN */ yytestcase(yyruleno==202);
+      case 205: /* in_op ::= NOT IN */ yytestcase(yyruleno==205);
+      case 231: /* collate ::= COLLATE ID|STRING */ yytestcase(yyruleno==231);
+{yymsp[-1].minor.yy32 = 1;}
         break;
-      case 59: /* init_deferred_pred_opt ::= INITIALLY IMMEDIATE */
-{yymsp[-1].minor.yy494 = 0;}
+      case 60: /* init_deferred_pred_opt ::= INITIALLY IMMEDIATE */
+{yymsp[-1].minor.yy32 = 0;}
         break;
-      case 61: /* tconscomma ::= COMMA */
+      case 62: /* tconscomma ::= COMMA */
 {pParse->constraintName.n = 0;}
         break;
-      case 63: /* tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf */
-{sqlite3AddPrimaryKey(pParse,yymsp[-3].minor.yy434,yymsp[0].minor.yy494,yymsp[-2].minor.yy494,0);}
+      case 64: /* tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf */
+{sqlite3AddPrimaryKey(pParse,yymsp[-3].minor.yy138,yymsp[0].minor.yy32,yymsp[-2].minor.yy32,0);}
         break;
-      case 64: /* tcons ::= UNIQUE LP sortlist RP onconf */
-{sqlite3CreateIndex(pParse,0,0,0,yymsp[-2].minor.yy434,yymsp[0].minor.yy494,0,0,0,0,
+      case 65: /* tcons ::= UNIQUE LP sortlist RP onconf */
+{sqlite3CreateIndex(pParse,0,0,0,yymsp[-2].minor.yy138,yymsp[0].minor.yy32,0,0,0,0,
                                        SQLITE_IDXTYPE_UNIQUE);}
         break;
-      case 65: /* tcons ::= CHECK LP expr RP onconf */
-{sqlite3AddCheckConstraint(pParse,yymsp[-2].minor.yy524);}
+      case 66: /* tcons ::= CHECK LP expr RP onconf */
+{sqlite3AddCheckConstraint(pParse,yymsp[-2].minor.yy46);}
         break;
-      case 66: /* tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt */
+      case 67: /* tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt */
 {
-    sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy434, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy434, yymsp[-1].minor.yy494);
-    sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy494);
+    sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy138, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy138, yymsp[-1].minor.yy32);
+    sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy32);
 }
         break;
-      case 68: /* onconf ::= */
-      case 70: /* orconf ::= */ yytestcase(yyruleno==70);
-{yymsp[1].minor.yy494 = OE_Default;}
+      case 69: /* onconf ::= */
+      case 71: /* orconf ::= */ yytestcase(yyruleno==71);
+{yymsp[1].minor.yy32 = OE_Default;}
         break;
-      case 69: /* onconf ::= ON CONFLICT resolvetype */
-{yymsp[-2].minor.yy494 = yymsp[0].minor.yy494;}
+      case 70: /* onconf ::= ON CONFLICT resolvetype */
+{yymsp[-2].minor.yy32 = yymsp[0].minor.yy32;}
         break;
-      case 72: /* resolvetype ::= IGNORE */
-{yymsp[0].minor.yy494 = OE_Ignore;}
+      case 73: /* resolvetype ::= IGNORE */
+{yymsp[0].minor.yy32 = OE_Ignore;}
         break;
-      case 73: /* resolvetype ::= REPLACE */
-      case 157: /* insert_cmd ::= REPLACE */ yytestcase(yyruleno==157);
-{yymsp[0].minor.yy494 = OE_Replace;}
+      case 74: /* resolvetype ::= REPLACE */
+      case 161: /* insert_cmd ::= REPLACE */ yytestcase(yyruleno==161);
+{yymsp[0].minor.yy32 = OE_Replace;}
         break;
-      case 74: /* cmd ::= DROP TABLE ifexists fullname */
+      case 75: /* cmd ::= DROP TABLE ifexists fullname */
 {
-  sqlite3DropTable(pParse, yymsp[0].minor.yy483, 0, yymsp[-1].minor.yy494);
+  sqlite3DropTable(pParse, yymsp[0].minor.yy609, 0, yymsp[-1].minor.yy32);
 }
         break;
-      case 77: /* cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select */
+      case 78: /* cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select */
 {
-  sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy434, yymsp[0].minor.yy457, yymsp[-7].minor.yy494, yymsp[-5].minor.yy494);
+  sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy138, yymsp[0].minor.yy25, yymsp[-7].minor.yy32, yymsp[-5].minor.yy32);
 }
         break;
-      case 78: /* cmd ::= DROP VIEW ifexists fullname */
+      case 79: /* cmd ::= DROP VIEW ifexists fullname */
 {
-  sqlite3DropTable(pParse, yymsp[0].minor.yy483, 1, yymsp[-1].minor.yy494);
+  sqlite3DropTable(pParse, yymsp[0].minor.yy609, 1, yymsp[-1].minor.yy32);
 }
         break;
-      case 79: /* cmd ::= select */
+      case 80: /* cmd ::= select */
 {
   SelectDest dest = {SRT_Output, 0, 0, 0, 0, 0};
-  sqlite3Select(pParse, yymsp[0].minor.yy457, &dest);
-  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy457);
+  sqlite3Select(pParse, yymsp[0].minor.yy25, &dest);
+  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy25);
 }
         break;
-      case 80: /* select ::= WITH wqlist selectnowith */
+      case 81: /* select ::= WITH wqlist selectnowith */
 {
-  Select *p = yymsp[0].minor.yy457;
+  Select *p = yymsp[0].minor.yy25;
   if( p ){
-    p->pWith = yymsp[-1].minor.yy59;
+    p->pWith = yymsp[-1].minor.yy297;
     parserDoubleLinkSelect(pParse, p);
   }else{
-    sqlite3WithDelete(pParse->db, yymsp[-1].minor.yy59);
+    sqlite3WithDelete(pParse->db, yymsp[-1].minor.yy297);
   }
-  yymsp[-2].minor.yy457 = p;
+  yymsp[-2].minor.yy25 = p;
 }
         break;
-      case 81: /* select ::= WITH RECURSIVE wqlist selectnowith */
+      case 82: /* select ::= WITH RECURSIVE wqlist selectnowith */
 {
-  Select *p = yymsp[0].minor.yy457;
+  Select *p = yymsp[0].minor.yy25;
   if( p ){
-    p->pWith = yymsp[-1].minor.yy59;
+    p->pWith = yymsp[-1].minor.yy297;
     parserDoubleLinkSelect(pParse, p);
   }else{
-    sqlite3WithDelete(pParse->db, yymsp[-1].minor.yy59);
+    sqlite3WithDelete(pParse->db, yymsp[-1].minor.yy297);
   }
-  yymsp[-3].minor.yy457 = p;
+  yymsp[-3].minor.yy25 = p;
 }
         break;
-      case 82: /* select ::= selectnowith */
+      case 83: /* select ::= selectnowith */
 {
-  Select *p = yymsp[0].minor.yy457;
+  Select *p = yymsp[0].minor.yy25;
   if( p ){
     parserDoubleLinkSelect(pParse, p);
   }
-  yymsp[0].minor.yy457 = p; /*A-overwrites-X*/
+  yymsp[0].minor.yy25 = p; /*A-overwrites-X*/
 }
         break;
-      case 83: /* selectnowith ::= selectnowith multiselect_op oneselect */
+      case 84: /* selectnowith ::= selectnowith multiselect_op oneselect */
 {
-  Select *pRhs = yymsp[0].minor.yy457;
-  Select *pLhs = yymsp[-2].minor.yy457;
+  Select *pRhs = yymsp[0].minor.yy25;
+  Select *pLhs = yymsp[-2].minor.yy25;
   if( pRhs && pRhs->pPrior ){
     SrcList *pFrom;
     Token x;
     x.n = 0;
     parserDoubleLinkSelect(pParse, pRhs);
     pFrom = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&x,pRhs,0,0);
     pRhs = sqlite3SelectNew(pParse,0,pFrom,0,0,0,0,0,0);
   }
   if( pRhs ){
-    pRhs->op = (u8)yymsp[-1].minor.yy494;
+    pRhs->op = (u8)yymsp[-1].minor.yy32;
     pRhs->pPrior = pLhs;
     if( ALWAYS(pLhs) ) pLhs->selFlags &= ~SF_MultiValue;
     pRhs->selFlags &= ~SF_MultiValue;
-    if( yymsp[-1].minor.yy494!=TK_ALL ) pParse->hasCompound = 1;
+    if( yymsp[-1].minor.yy32!=TK_ALL ) pParse->hasCompound = 1;
   }else{
     sqlite3SelectDelete(pParse->db, pLhs);
   }
-  yymsp[-2].minor.yy457 = pRhs;
+  yymsp[-2].minor.yy25 = pRhs;
 }
         break;
-      case 84: /* multiselect_op ::= UNION */
-      case 86: /* multiselect_op ::= EXCEPT|INTERSECT */ yytestcase(yyruleno==86);
-{yymsp[0].minor.yy494 = yymsp[0].major; /*A-overwrites-OP*/}
+      case 85: /* multiselect_op ::= UNION */
+      case 87: /* multiselect_op ::= EXCEPT|INTERSECT */ yytestcase(yyruleno==87);
+{yymsp[0].minor.yy32 = yymsp[0].major; /*A-overwrites-OP*/}
         break;
-      case 85: /* multiselect_op ::= UNION ALL */
-{yymsp[-1].minor.yy494 = TK_ALL;}
+      case 86: /* multiselect_op ::= UNION ALL */
+{yymsp[-1].minor.yy32 = TK_ALL;}
         break;
-      case 87: /* oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt */
+      case 88: /* oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt */
 {
-  yymsp[-8].minor.yy457 = sqlite3SelectNew(pParse,yymsp[-6].minor.yy434,yymsp[-5].minor.yy483,yymsp[-4].minor.yy524,yymsp[-3].minor.yy434,yymsp[-2].minor.yy524,yymsp[-1].minor.yy434,yymsp[-7].minor.yy494,yymsp[0].minor.yy524);
+  yymsp[-8].minor.yy25 = sqlite3SelectNew(pParse,yymsp[-6].minor.yy138,yymsp[-5].minor.yy609,yymsp[-4].minor.yy46,yymsp[-3].minor.yy138,yymsp[-2].minor.yy46,yymsp[-1].minor.yy138,yymsp[-7].minor.yy32,yymsp[0].minor.yy46);
 }
         break;
-      case 88: /* oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt */
+      case 89: /* oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt */
 {
-  yymsp[-9].minor.yy457 = sqlite3SelectNew(pParse,yymsp[-7].minor.yy434,yymsp[-6].minor.yy483,yymsp[-5].minor.yy524,yymsp[-4].minor.yy434,yymsp[-3].minor.yy524,yymsp[-1].minor.yy434,yymsp[-8].minor.yy494,yymsp[0].minor.yy524);
-  if( yymsp[-9].minor.yy457 ){
-    yymsp[-9].minor.yy457->pWinDefn = yymsp[-2].minor.yy295;
+  yymsp[-9].minor.yy25 = sqlite3SelectNew(pParse,yymsp[-7].minor.yy138,yymsp[-6].minor.yy609,yymsp[-5].minor.yy46,yymsp[-4].minor.yy138,yymsp[-3].minor.yy46,yymsp[-1].minor.yy138,yymsp[-8].minor.yy32,yymsp[0].minor.yy46);
+  if( yymsp[-9].minor.yy25 ){
+    yymsp[-9].minor.yy25->pWinDefn = yymsp[-2].minor.yy455;
   }else{
-    sqlite3WindowListDelete(pParse->db, yymsp[-2].minor.yy295);
+    sqlite3WindowListDelete(pParse->db, yymsp[-2].minor.yy455);
   }
 }
         break;
-      case 89: /* values ::= VALUES LP nexprlist RP */
+      case 90: /* values ::= VALUES LP nexprlist RP */
 {
-  yymsp[-3].minor.yy457 = sqlite3SelectNew(pParse,yymsp[-1].minor.yy434,0,0,0,0,0,SF_Values,0);
+  yymsp[-3].minor.yy25 = sqlite3SelectNew(pParse,yymsp[-1].minor.yy138,0,0,0,0,0,SF_Values,0);
 }
         break;
-      case 90: /* values ::= values COMMA LP nexprlist RP */
+      case 91: /* values ::= values COMMA LP nexprlist RP */
 {
-  Select *pRight, *pLeft = yymsp[-4].minor.yy457;
-  pRight = sqlite3SelectNew(pParse,yymsp[-1].minor.yy434,0,0,0,0,0,SF_Values|SF_MultiValue,0);
+  Select *pRight, *pLeft = yymsp[-4].minor.yy25;
+  pRight = sqlite3SelectNew(pParse,yymsp[-1].minor.yy138,0,0,0,0,0,SF_Values|SF_MultiValue,0);
   if( ALWAYS(pLeft) ) pLeft->selFlags &= ~SF_MultiValue;
   if( pRight ){
     pRight->op = TK_ALL;
     pRight->pPrior = pLeft;
-    yymsp[-4].minor.yy457 = pRight;
+    yymsp[-4].minor.yy25 = pRight;
   }else{
-    yymsp[-4].minor.yy457 = pLeft;
+    yymsp[-4].minor.yy25 = pLeft;
   }
 }
         break;
-      case 91: /* distinct ::= DISTINCT */
-{yymsp[0].minor.yy494 = SF_Distinct;}
+      case 92: /* distinct ::= DISTINCT */
+{yymsp[0].minor.yy32 = SF_Distinct;}
         break;
-      case 92: /* distinct ::= ALL */
-{yymsp[0].minor.yy494 = SF_All;}
+      case 93: /* distinct ::= ALL */
+{yymsp[0].minor.yy32 = SF_All;}
         break;
-      case 94: /* sclp ::= */
-      case 127: /* orderby_opt ::= */ yytestcase(yyruleno==127);
-      case 134: /* groupby_opt ::= */ yytestcase(yyruleno==134);
-      case 214: /* exprlist ::= */ yytestcase(yyruleno==214);
-      case 217: /* paren_exprlist ::= */ yytestcase(yyruleno==217);
-      case 222: /* eidlist_opt ::= */ yytestcase(yyruleno==222);
-{yymsp[1].minor.yy434 = 0;}
+      case 95: /* sclp ::= */
+      case 128: /* orderby_opt ::= */ yytestcase(yyruleno==128);
+      case 138: /* groupby_opt ::= */ yytestcase(yyruleno==138);
+      case 218: /* exprlist ::= */ yytestcase(yyruleno==218);
+      case 221: /* paren_exprlist ::= */ yytestcase(yyruleno==221);
+      case 226: /* eidlist_opt ::= */ yytestcase(yyruleno==226);
+{yymsp[1].minor.yy138 = 0;}
         break;
-      case 95: /* selcollist ::= sclp scanpt expr scanpt as */
+      case 96: /* selcollist ::= sclp scanpt expr scanpt as */
 {
-   yymsp[-4].minor.yy434 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy434, yymsp[-2].minor.yy524);
-   if( yymsp[0].minor.yy0.n>0 ) sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy434, &yymsp[0].minor.yy0, 1);
-   sqlite3ExprListSetSpan(pParse,yymsp[-4].minor.yy434,yymsp[-3].minor.yy294,yymsp[-1].minor.yy294);
+   yymsp[-4].minor.yy138 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy138, yymsp[-2].minor.yy46);
+   if( yymsp[0].minor.yy0.n>0 ) sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy138, &yymsp[0].minor.yy0, 1);
+   sqlite3ExprListSetSpan(pParse,yymsp[-4].minor.yy138,yymsp[-3].minor.yy8,yymsp[-1].minor.yy8);
 }
         break;
-      case 96: /* selcollist ::= sclp scanpt STAR */
+      case 97: /* selcollist ::= sclp scanpt STAR */
 {
   Expr *p = sqlite3Expr(pParse->db, TK_ASTERISK, 0);
-  yymsp[-2].minor.yy434 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy434, p);
+  yymsp[-2].minor.yy138 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy138, p);
 }
         break;
-      case 97: /* selcollist ::= sclp scanpt nm DOT STAR */
+      case 98: /* selcollist ::= sclp scanpt nm DOT STAR */
 {
   Expr *pRight = sqlite3PExpr(pParse, TK_ASTERISK, 0, 0);
   Expr *pLeft = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[-2].minor.yy0, 1);
   Expr *pDot = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);
-  yymsp[-4].minor.yy434 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy434, pDot);
+  yymsp[-4].minor.yy138 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy138, pDot);
 }
         break;
-      case 98: /* as ::= AS nm */
-      case 109: /* dbnm ::= DOT nm */ yytestcase(yyruleno==109);
-      case 238: /* plus_num ::= PLUS INTEGER|FLOAT */ yytestcase(yyruleno==238);
-      case 239: /* minus_num ::= MINUS INTEGER|FLOAT */ yytestcase(yyruleno==239);
+      case 99: /* as ::= AS nm */
+      case 110: /* dbnm ::= DOT nm */ yytestcase(yyruleno==110);
+      case 242: /* plus_num ::= PLUS INTEGER|FLOAT */ yytestcase(yyruleno==242);
+      case 243: /* minus_num ::= MINUS INTEGER|FLOAT */ yytestcase(yyruleno==243);
 {yymsp[-1].minor.yy0 = yymsp[0].minor.yy0;}
         break;
-      case 100: /* from ::= */
-{yymsp[1].minor.yy483 = sqlite3DbMallocZero(pParse->db, sizeof(*yymsp[1].minor.yy483));}
+      case 101: /* from ::= */
+{yymsp[1].minor.yy609 = sqlite3DbMallocZero(pParse->db, sizeof(*yymsp[1].minor.yy609));}
         break;
-      case 101: /* from ::= FROM seltablist */
+      case 102: /* from ::= FROM seltablist */
 {
-  yymsp[-1].minor.yy483 = yymsp[0].minor.yy483;
-  sqlite3SrcListShiftJoinType(yymsp[-1].minor.yy483);
+  yymsp[-1].minor.yy609 = yymsp[0].minor.yy609;
+  sqlite3SrcListShiftJoinType(yymsp[-1].minor.yy609);
 }
         break;
-      case 102: /* stl_prefix ::= seltablist joinop */
+      case 103: /* stl_prefix ::= seltablist joinop */
 {
-   if( ALWAYS(yymsp[-1].minor.yy483 && yymsp[-1].minor.yy483->nSrc>0) ) yymsp[-1].minor.yy483->a[yymsp[-1].minor.yy483->nSrc-1].fg.jointype = (u8)yymsp[0].minor.yy494;
+   if( ALWAYS(yymsp[-1].minor.yy609 && yymsp[-1].minor.yy609->nSrc>0) ) yymsp[-1].minor.yy609->a[yymsp[-1].minor.yy609->nSrc-1].fg.jointype = (u8)yymsp[0].minor.yy32;
 }
         break;
-      case 103: /* stl_prefix ::= */
-{yymsp[1].minor.yy483 = 0;}
+      case 104: /* stl_prefix ::= */
+{yymsp[1].minor.yy609 = 0;}
         break;
-      case 104: /* seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt */
+      case 105: /* seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt */
 {
-  yymsp[-6].minor.yy483 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy483,&yymsp[-5].minor.yy0,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,0,yymsp[-1].minor.yy524,yymsp[0].minor.yy62);
-  sqlite3SrcListIndexedBy(pParse, yymsp[-6].minor.yy483, &yymsp[-2].minor.yy0);
+  yymsp[-6].minor.yy609 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy609,&yymsp[-5].minor.yy0,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,0,yymsp[-1].minor.yy46,yymsp[0].minor.yy406);
+  sqlite3SrcListIndexedBy(pParse, yymsp[-6].minor.yy609, &yymsp[-2].minor.yy0);
 }
         break;
-      case 105: /* seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt */
+      case 106: /* seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt */
 {
-  yymsp[-8].minor.yy483 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-8].minor.yy483,&yymsp[-7].minor.yy0,&yymsp[-6].minor.yy0,&yymsp[-2].minor.yy0,0,yymsp[-1].minor.yy524,yymsp[0].minor.yy62);
-  sqlite3SrcListFuncArgs(pParse, yymsp[-8].minor.yy483, yymsp[-4].minor.yy434);
+  yymsp[-8].minor.yy609 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-8].minor.yy609,&yymsp[-7].minor.yy0,&yymsp[-6].minor.yy0,&yymsp[-2].minor.yy0,0,yymsp[-1].minor.yy46,yymsp[0].minor.yy406);
+  sqlite3SrcListFuncArgs(pParse, yymsp[-8].minor.yy609, yymsp[-4].minor.yy138);
 }
         break;
-      case 106: /* seltablist ::= stl_prefix LP select RP as on_opt using_opt */
+      case 107: /* seltablist ::= stl_prefix LP select RP as on_opt using_opt */
 {
-    yymsp[-6].minor.yy483 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy483,0,0,&yymsp[-2].minor.yy0,yymsp[-4].minor.yy457,yymsp[-1].minor.yy524,yymsp[0].minor.yy62);
+    yymsp[-6].minor.yy609 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy609,0,0,&yymsp[-2].minor.yy0,yymsp[-4].minor.yy25,yymsp[-1].minor.yy46,yymsp[0].minor.yy406);
   }
         break;
-      case 107: /* seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt */
+      case 108: /* seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt */
 {
-    if( yymsp[-6].minor.yy483==0 && yymsp[-2].minor.yy0.n==0 && yymsp[-1].minor.yy524==0 && yymsp[0].minor.yy62==0 ){
-      yymsp[-6].minor.yy483 = yymsp[-4].minor.yy483;
-    }else if( yymsp[-4].minor.yy483->nSrc==1 ){
-      yymsp[-6].minor.yy483 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy483,0,0,&yymsp[-2].minor.yy0,0,yymsp[-1].minor.yy524,yymsp[0].minor.yy62);
-      if( yymsp[-6].minor.yy483 ){
-        struct SrcList_item *pNew = &yymsp[-6].minor.yy483->a[yymsp[-6].minor.yy483->nSrc-1];
-        struct SrcList_item *pOld = yymsp[-4].minor.yy483->a;
+    if( yymsp[-6].minor.yy609==0 && yymsp[-2].minor.yy0.n==0 && yymsp[-1].minor.yy46==0 && yymsp[0].minor.yy406==0 ){
+      yymsp[-6].minor.yy609 = yymsp[-4].minor.yy609;
+    }else if( yymsp[-4].minor.yy609->nSrc==1 ){
+      yymsp[-6].minor.yy609 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy609,0,0,&yymsp[-2].minor.yy0,0,yymsp[-1].minor.yy46,yymsp[0].minor.yy406);
+      if( yymsp[-6].minor.yy609 ){
+        struct SrcList_item *pNew = &yymsp[-6].minor.yy609->a[yymsp[-6].minor.yy609->nSrc-1];
+        struct SrcList_item *pOld = yymsp[-4].minor.yy609->a;
         pNew->zName = pOld->zName;
         pNew->zDatabase = pOld->zDatabase;
         pNew->pSelect = pOld->pSelect;
         if( pOld->fg.isTabFunc ){
           pNew->u1.pFuncArg = pOld->u1.pFuncArg;
@@ -151774,953 +153400,946 @@
           pNew->fg.isTabFunc = 1;
         }
         pOld->zName = pOld->zDatabase = 0;
         pOld->pSelect = 0;
       }
-      sqlite3SrcListDelete(pParse->db, yymsp[-4].minor.yy483);
+      sqlite3SrcListDelete(pParse->db, yymsp[-4].minor.yy609);
     }else{
       Select *pSubquery;
-      sqlite3SrcListShiftJoinType(yymsp[-4].minor.yy483);
-      pSubquery = sqlite3SelectNew(pParse,0,yymsp[-4].minor.yy483,0,0,0,0,SF_NestedFrom,0);
-      yymsp[-6].minor.yy483 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy483,0,0,&yymsp[-2].minor.yy0,pSubquery,yymsp[-1].minor.yy524,yymsp[0].minor.yy62);
+      sqlite3SrcListShiftJoinType(yymsp[-4].minor.yy609);
+      pSubquery = sqlite3SelectNew(pParse,0,yymsp[-4].minor.yy609,0,0,0,0,SF_NestedFrom,0);
+      yymsp[-6].minor.yy609 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy609,0,0,&yymsp[-2].minor.yy0,pSubquery,yymsp[-1].minor.yy46,yymsp[0].minor.yy406);
     }
   }
         break;
-      case 108: /* dbnm ::= */
-      case 122: /* indexed_opt ::= */ yytestcase(yyruleno==122);
+      case 109: /* dbnm ::= */
+      case 123: /* indexed_opt ::= */ yytestcase(yyruleno==123);
 {yymsp[1].minor.yy0.z=0; yymsp[1].minor.yy0.n=0;}
         break;
-      case 110: /* fullname ::= nm */
+      case 111: /* fullname ::= nm */
 {
-  yylhsminor.yy483 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0);
-  if( IN_RENAME_OBJECT && yylhsminor.yy483 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy483->a[0].zName, &yymsp[0].minor.yy0);
+  yylhsminor.yy609 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0);
+  if( IN_RENAME_OBJECT && yylhsminor.yy609 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy609->a[0].zName, &yymsp[0].minor.yy0);
 }
-  yymsp[0].minor.yy483 = yylhsminor.yy483;
+  yymsp[0].minor.yy609 = yylhsminor.yy609;
         break;
-      case 111: /* fullname ::= nm DOT nm */
+      case 112: /* fullname ::= nm DOT nm */
 {
-  yylhsminor.yy483 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);
-  if( IN_RENAME_OBJECT && yylhsminor.yy483 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy483->a[0].zName, &yymsp[0].minor.yy0);
+  yylhsminor.yy609 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);
+  if( IN_RENAME_OBJECT && yylhsminor.yy609 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy609->a[0].zName, &yymsp[0].minor.yy0);
 }
-  yymsp[-2].minor.yy483 = yylhsminor.yy483;
+  yymsp[-2].minor.yy609 = yylhsminor.yy609;
         break;
-      case 112: /* xfullname ::= nm */
-{yymsp[0].minor.yy483 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0); /*A-overwrites-X*/}
+      case 113: /* xfullname ::= nm */
+{yymsp[0].minor.yy609 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0); /*A-overwrites-X*/}
         break;
-      case 113: /* xfullname ::= nm DOT nm */
-{yymsp[-2].minor.yy483 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0); /*A-overwrites-X*/}
+      case 114: /* xfullname ::= nm DOT nm */
+{yymsp[-2].minor.yy609 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0); /*A-overwrites-X*/}
         break;
-      case 114: /* xfullname ::= nm DOT nm AS nm */
+      case 115: /* xfullname ::= nm DOT nm AS nm */
 {
-   yymsp[-4].minor.yy483 = sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,&yymsp[-2].minor.yy0); /*A-overwrites-X*/
-   if( yymsp[-4].minor.yy483 ) yymsp[-4].minor.yy483->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);
+   yymsp[-4].minor.yy609 = sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,&yymsp[-2].minor.yy0); /*A-overwrites-X*/
+   if( yymsp[-4].minor.yy609 ) yymsp[-4].minor.yy609->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);
 }
         break;
-      case 115: /* xfullname ::= nm AS nm */
+      case 116: /* xfullname ::= nm AS nm */
 {
-   yymsp[-2].minor.yy483 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,0); /*A-overwrites-X*/
-   if( yymsp[-2].minor.yy483 ) yymsp[-2].minor.yy483->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);
+   yymsp[-2].minor.yy609 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,0); /*A-overwrites-X*/
+   if( yymsp[-2].minor.yy609 ) yymsp[-2].minor.yy609->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);
 }
         break;
-      case 116: /* joinop ::= COMMA|JOIN */
-{ yymsp[0].minor.yy494 = JT_INNER; }
+      case 117: /* joinop ::= COMMA|JOIN */
+{ yymsp[0].minor.yy32 = JT_INNER; }
         break;
-      case 117: /* joinop ::= JOIN_KW JOIN */
-{yymsp[-1].minor.yy494 = sqlite3JoinType(pParse,&yymsp[-1].minor.yy0,0,0);  /*X-overwrites-A*/}
+      case 118: /* joinop ::= JOIN_KW JOIN */
+{yymsp[-1].minor.yy32 = sqlite3JoinType(pParse,&yymsp[-1].minor.yy0,0,0);  /*X-overwrites-A*/}
         break;
-      case 118: /* joinop ::= JOIN_KW nm JOIN */
-{yymsp[-2].minor.yy494 = sqlite3JoinType(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0); /*X-overwrites-A*/}
+      case 119: /* joinop ::= JOIN_KW nm JOIN */
+{yymsp[-2].minor.yy32 = sqlite3JoinType(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0); /*X-overwrites-A*/}
         break;
-      case 119: /* joinop ::= JOIN_KW nm nm JOIN */
-{yymsp[-3].minor.yy494 = sqlite3JoinType(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0);/*X-overwrites-A*/}
+      case 120: /* joinop ::= JOIN_KW nm nm JOIN */
+{yymsp[-3].minor.yy32 = sqlite3JoinType(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0);/*X-overwrites-A*/}
         break;
-      case 120: /* on_opt ::= ON expr */
-      case 137: /* having_opt ::= HAVING expr */ yytestcase(yyruleno==137);
-      case 144: /* where_opt ::= WHERE expr */ yytestcase(yyruleno==144);
-      case 210: /* case_else ::= ELSE expr */ yytestcase(yyruleno==210);
-      case 231: /* vinto ::= INTO expr */ yytestcase(yyruleno==231);
-{yymsp[-1].minor.yy524 = yymsp[0].minor.yy524;}
+      case 121: /* on_opt ::= ON expr */
+      case 141: /* having_opt ::= HAVING expr */ yytestcase(yyruleno==141);
+      case 148: /* where_opt ::= WHERE expr */ yytestcase(yyruleno==148);
+      case 214: /* case_else ::= ELSE expr */ yytestcase(yyruleno==214);
+      case 235: /* vinto ::= INTO expr */ yytestcase(yyruleno==235);
+{yymsp[-1].minor.yy46 = yymsp[0].minor.yy46;}
         break;
-      case 121: /* on_opt ::= */
-      case 136: /* having_opt ::= */ yytestcase(yyruleno==136);
-      case 138: /* limit_opt ::= */ yytestcase(yyruleno==138);
-      case 143: /* where_opt ::= */ yytestcase(yyruleno==143);
-      case 211: /* case_else ::= */ yytestcase(yyruleno==211);
-      case 213: /* case_operand ::= */ yytestcase(yyruleno==213);
-      case 232: /* vinto ::= */ yytestcase(yyruleno==232);
-{yymsp[1].minor.yy524 = 0;}
+      case 122: /* on_opt ::= */
+      case 140: /* having_opt ::= */ yytestcase(yyruleno==140);
+      case 142: /* limit_opt ::= */ yytestcase(yyruleno==142);
+      case 147: /* where_opt ::= */ yytestcase(yyruleno==147);
+      case 215: /* case_else ::= */ yytestcase(yyruleno==215);
+      case 217: /* case_operand ::= */ yytestcase(yyruleno==217);
+      case 236: /* vinto ::= */ yytestcase(yyruleno==236);
+{yymsp[1].minor.yy46 = 0;}
         break;
-      case 123: /* indexed_opt ::= INDEXED BY nm */
+      case 124: /* indexed_opt ::= INDEXED BY nm */
 {yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;}
         break;
-      case 124: /* indexed_opt ::= NOT INDEXED */
+      case 125: /* indexed_opt ::= NOT INDEXED */
 {yymsp[-1].minor.yy0.z=0; yymsp[-1].minor.yy0.n=1;}
         break;
-      case 125: /* using_opt ::= USING LP idlist RP */
-{yymsp[-3].minor.yy62 = yymsp[-1].minor.yy62;}
+      case 126: /* using_opt ::= USING LP idlist RP */
+{yymsp[-3].minor.yy406 = yymsp[-1].minor.yy406;}
         break;
-      case 126: /* using_opt ::= */
-      case 158: /* idlist_opt ::= */ yytestcase(yyruleno==158);
-{yymsp[1].minor.yy62 = 0;}
+      case 127: /* using_opt ::= */
+      case 162: /* idlist_opt ::= */ yytestcase(yyruleno==162);
+{yymsp[1].minor.yy406 = 0;}
         break;
-      case 128: /* orderby_opt ::= ORDER BY sortlist */
-      case 135: /* groupby_opt ::= GROUP BY nexprlist */ yytestcase(yyruleno==135);
-{yymsp[-2].minor.yy434 = yymsp[0].minor.yy434;}
+      case 129: /* orderby_opt ::= ORDER BY sortlist */
+      case 139: /* groupby_opt ::= GROUP BY nexprlist */ yytestcase(yyruleno==139);
+{yymsp[-2].minor.yy138 = yymsp[0].minor.yy138;}
         break;
-      case 129: /* sortlist ::= sortlist COMMA expr sortorder */
+      case 130: /* sortlist ::= sortlist COMMA expr sortorder nulls */
 {
-  yymsp[-3].minor.yy434 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy434,yymsp[-1].minor.yy524);
-  sqlite3ExprListSetSortOrder(yymsp[-3].minor.yy434,yymsp[0].minor.yy494);
+  yymsp[-4].minor.yy138 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy138,yymsp[-2].minor.yy46);
+  sqlite3ExprListSetSortOrder(yymsp[-4].minor.yy138,yymsp[-1].minor.yy32,yymsp[0].minor.yy32);
 }
         break;
-      case 130: /* sortlist ::= expr sortorder */
+      case 131: /* sortlist ::= expr sortorder nulls */
 {
-  yymsp[-1].minor.yy434 = sqlite3ExprListAppend(pParse,0,yymsp[-1].minor.yy524); /*A-overwrites-Y*/
-  sqlite3ExprListSetSortOrder(yymsp[-1].minor.yy434,yymsp[0].minor.yy494);
+  yymsp[-2].minor.yy138 = sqlite3ExprListAppend(pParse,0,yymsp[-2].minor.yy46); /*A-overwrites-Y*/
+  sqlite3ExprListSetSortOrder(yymsp[-2].minor.yy138,yymsp[-1].minor.yy32,yymsp[0].minor.yy32);
 }
         break;
-      case 131: /* sortorder ::= ASC */
-{yymsp[0].minor.yy494 = SQLITE_SO_ASC;}
+      case 132: /* sortorder ::= ASC */
+{yymsp[0].minor.yy32 = SQLITE_SO_ASC;}
+        break;
+      case 133: /* sortorder ::= DESC */
+{yymsp[0].minor.yy32 = SQLITE_SO_DESC;}
+        break;
+      case 134: /* sortorder ::= */
+      case 137: /* nulls ::= */ yytestcase(yyruleno==137);
+{yymsp[1].minor.yy32 = SQLITE_SO_UNDEFINED;}
         break;
-      case 132: /* sortorder ::= DESC */
-{yymsp[0].minor.yy494 = SQLITE_SO_DESC;}
+      case 135: /* nulls ::= NULLS FIRST */
+{yymsp[-1].minor.yy32 = SQLITE_SO_ASC;}
         break;
-      case 133: /* sortorder ::= */
-{yymsp[1].minor.yy494 = SQLITE_SO_UNDEFINED;}
+      case 136: /* nulls ::= NULLS LAST */
+{yymsp[-1].minor.yy32 = SQLITE_SO_DESC;}
         break;
-      case 139: /* limit_opt ::= LIMIT expr */
-{yymsp[-1].minor.yy524 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy524,0);}
+      case 143: /* limit_opt ::= LIMIT expr */
+{yymsp[-1].minor.yy46 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy46,0);}
         break;
-      case 140: /* limit_opt ::= LIMIT expr OFFSET expr */
-{yymsp[-3].minor.yy524 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[-2].minor.yy524,yymsp[0].minor.yy524);}
+      case 144: /* limit_opt ::= LIMIT expr OFFSET expr */
+{yymsp[-3].minor.yy46 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[-2].minor.yy46,yymsp[0].minor.yy46);}
         break;
-      case 141: /* limit_opt ::= LIMIT expr COMMA expr */
-{yymsp[-3].minor.yy524 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy524,yymsp[-2].minor.yy524);}
+      case 145: /* limit_opt ::= LIMIT expr COMMA expr */
+{yymsp[-3].minor.yy46 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy46,yymsp[-2].minor.yy46);}
         break;
-      case 142: /* cmd ::= with DELETE FROM xfullname indexed_opt where_opt */
+      case 146: /* cmd ::= with DELETE FROM xfullname indexed_opt where_opt */
 {
-  sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy483, &yymsp[-1].minor.yy0);
-  sqlite3DeleteFrom(pParse,yymsp[-2].minor.yy483,yymsp[0].minor.yy524,0,0);
+  sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy609, &yymsp[-1].minor.yy0);
+  sqlite3DeleteFrom(pParse,yymsp[-2].minor.yy609,yymsp[0].minor.yy46,0,0);
 }
         break;
-      case 145: /* cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt */
+      case 149: /* cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist where_opt */
 {
-  sqlite3SrcListIndexedBy(pParse, yymsp[-4].minor.yy483, &yymsp[-3].minor.yy0);
-  sqlite3ExprListCheckLength(pParse,yymsp[-1].minor.yy434,"set list");
-  sqlite3Update(pParse,yymsp[-4].minor.yy483,yymsp[-1].minor.yy434,yymsp[0].minor.yy524,yymsp[-5].minor.yy494,0,0,0);
+  sqlite3SrcListIndexedBy(pParse, yymsp[-4].minor.yy609, &yymsp[-3].minor.yy0);
+  sqlite3ExprListCheckLength(pParse,yymsp[-1].minor.yy138,"set list");
+  sqlite3Update(pParse,yymsp[-4].minor.yy609,yymsp[-1].minor.yy138,yymsp[0].minor.yy46,yymsp[-5].minor.yy32,0,0,0);
 }
         break;
-      case 146: /* setlist ::= setlist COMMA nm EQ expr */
+      case 150: /* setlist ::= setlist COMMA nm EQ expr */
 {
-  yymsp[-4].minor.yy434 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy434, yymsp[0].minor.yy524);
-  sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy434, &yymsp[-2].minor.yy0, 1);
+  yymsp[-4].minor.yy138 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy138, yymsp[0].minor.yy46);
+  sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy138, &yymsp[-2].minor.yy0, 1);
 }
         break;
-      case 147: /* setlist ::= setlist COMMA LP idlist RP EQ expr */
+      case 151: /* setlist ::= setlist COMMA LP idlist RP EQ expr */
 {
-  yymsp[-6].minor.yy434 = sqlite3ExprListAppendVector(pParse, yymsp[-6].minor.yy434, yymsp[-3].minor.yy62, yymsp[0].minor.yy524);
+  yymsp[-6].minor.yy138 = sqlite3ExprListAppendVector(pParse, yymsp[-6].minor.yy138, yymsp[-3].minor.yy406, yymsp[0].minor.yy46);
 }
         break;
-      case 148: /* setlist ::= nm EQ expr */
+      case 152: /* setlist ::= nm EQ expr */
 {
-  yylhsminor.yy434 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy524);
-  sqlite3ExprListSetName(pParse, yylhsminor.yy434, &yymsp[-2].minor.yy0, 1);
+  yylhsminor.yy138 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy46);
+  sqlite3ExprListSetName(pParse, yylhsminor.yy138, &yymsp[-2].minor.yy0, 1);
 }
-  yymsp[-2].minor.yy434 = yylhsminor.yy434;
+  yymsp[-2].minor.yy138 = yylhsminor.yy138;
         break;
-      case 149: /* setlist ::= LP idlist RP EQ expr */
+      case 153: /* setlist ::= LP idlist RP EQ expr */
 {
-  yymsp[-4].minor.yy434 = sqlite3ExprListAppendVector(pParse, 0, yymsp[-3].minor.yy62, yymsp[0].minor.yy524);
+  yymsp[-4].minor.yy138 = sqlite3ExprListAppendVector(pParse, 0, yymsp[-3].minor.yy406, yymsp[0].minor.yy46);
 }
         break;
-      case 150: /* cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert */
+      case 154: /* cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert */
 {
-  sqlite3Insert(pParse, yymsp[-3].minor.yy483, yymsp[-1].minor.yy457, yymsp[-2].minor.yy62, yymsp[-5].minor.yy494, yymsp[0].minor.yy136);
+  sqlite3Insert(pParse, yymsp[-3].minor.yy609, yymsp[-1].minor.yy25, yymsp[-2].minor.yy406, yymsp[-5].minor.yy32, yymsp[0].minor.yy288);
 }
         break;
-      case 151: /* cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES */
+      case 155: /* cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES */
 {
-  sqlite3Insert(pParse, yymsp[-3].minor.yy483, 0, yymsp[-2].minor.yy62, yymsp[-5].minor.yy494, 0);
+  sqlite3Insert(pParse, yymsp[-3].minor.yy609, 0, yymsp[-2].minor.yy406, yymsp[-5].minor.yy32, 0);
 }
         break;
-      case 152: /* upsert ::= */
-{ yymsp[1].minor.yy136 = 0; }
+      case 156: /* upsert ::= */
+{ yymsp[1].minor.yy288 = 0; }
         break;
-      case 153: /* upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt */
-{ yymsp[-10].minor.yy136 = sqlite3UpsertNew(pParse->db,yymsp[-7].minor.yy434,yymsp[-5].minor.yy524,yymsp[-1].minor.yy434,yymsp[0].minor.yy524);}
+      case 157: /* upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt */
+{ yymsp[-10].minor.yy288 = sqlite3UpsertNew(pParse->db,yymsp[-7].minor.yy138,yymsp[-5].minor.yy46,yymsp[-1].minor.yy138,yymsp[0].minor.yy46);}
         break;
-      case 154: /* upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING */
-{ yymsp[-7].minor.yy136 = sqlite3UpsertNew(pParse->db,yymsp[-4].minor.yy434,yymsp[-2].minor.yy524,0,0); }
+      case 158: /* upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING */
+{ yymsp[-7].minor.yy288 = sqlite3UpsertNew(pParse->db,yymsp[-4].minor.yy138,yymsp[-2].minor.yy46,0,0); }
         break;
-      case 155: /* upsert ::= ON CONFLICT DO NOTHING */
-{ yymsp[-3].minor.yy136 = sqlite3UpsertNew(pParse->db,0,0,0,0); }
+      case 159: /* upsert ::= ON CONFLICT DO NOTHING */
+{ yymsp[-3].minor.yy288 = sqlite3UpsertNew(pParse->db,0,0,0,0); }
         break;
-      case 159: /* idlist_opt ::= LP idlist RP */
-{yymsp[-2].minor.yy62 = yymsp[-1].minor.yy62;}
+      case 163: /* idlist_opt ::= LP idlist RP */
+{yymsp[-2].minor.yy406 = yymsp[-1].minor.yy406;}
         break;
-      case 160: /* idlist ::= idlist COMMA nm */
-{yymsp[-2].minor.yy62 = sqlite3IdListAppend(pParse,yymsp[-2].minor.yy62,&yymsp[0].minor.yy0);}
+      case 164: /* idlist ::= idlist COMMA nm */
+{yymsp[-2].minor.yy406 = sqlite3IdListAppend(pParse,yymsp[-2].minor.yy406,&yymsp[0].minor.yy0);}
         break;
-      case 161: /* idlist ::= nm */
-{yymsp[0].minor.yy62 = sqlite3IdListAppend(pParse,0,&yymsp[0].minor.yy0); /*A-overwrites-Y*/}
+      case 165: /* idlist ::= nm */
+{yymsp[0].minor.yy406 = sqlite3IdListAppend(pParse,0,&yymsp[0].minor.yy0); /*A-overwrites-Y*/}
         break;
-      case 162: /* expr ::= LP expr RP */
-{yymsp[-2].minor.yy524 = yymsp[-1].minor.yy524;}
+      case 166: /* expr ::= LP expr RP */
+{yymsp[-2].minor.yy46 = yymsp[-1].minor.yy46;}
         break;
-      case 163: /* expr ::= ID|INDEXED */
-      case 164: /* expr ::= JOIN_KW */ yytestcase(yyruleno==164);
-{yymsp[0].minor.yy524=tokenExpr(pParse,TK_ID,yymsp[0].minor.yy0); /*A-overwrites-X*/}
+      case 167: /* expr ::= ID|INDEXED */
+      case 168: /* expr ::= JOIN_KW */ yytestcase(yyruleno==168);
+{yymsp[0].minor.yy46=tokenExpr(pParse,TK_ID,yymsp[0].minor.yy0); /*A-overwrites-X*/}
         break;
-      case 165: /* expr ::= nm DOT nm */
+      case 169: /* expr ::= nm DOT nm */
 {
   Expr *temp1 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[-2].minor.yy0, 1);
   Expr *temp2 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[0].minor.yy0, 1);
   if( IN_RENAME_OBJECT ){
     sqlite3RenameTokenMap(pParse, (void*)temp2, &yymsp[0].minor.yy0);
     sqlite3RenameTokenMap(pParse, (void*)temp1, &yymsp[-2].minor.yy0);
   }
-  yylhsminor.yy524 = sqlite3PExpr(pParse, TK_DOT, temp1, temp2);
+  yylhsminor.yy46 = sqlite3PExpr(pParse, TK_DOT, temp1, temp2);
 }
-  yymsp[-2].minor.yy524 = yylhsminor.yy524;
+  yymsp[-2].minor.yy46 = yylhsminor.yy46;
         break;
-      case 166: /* expr ::= nm DOT nm DOT nm */
+      case 170: /* expr ::= nm DOT nm DOT nm */
 {
   Expr *temp1 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[-4].minor.yy0, 1);
   Expr *temp2 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[-2].minor.yy0, 1);
   Expr *temp3 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[0].minor.yy0, 1);
   Expr *temp4 = sqlite3PExpr(pParse, TK_DOT, temp2, temp3);
   if( IN_RENAME_OBJECT ){
     sqlite3RenameTokenMap(pParse, (void*)temp3, &yymsp[0].minor.yy0);
     sqlite3RenameTokenMap(pParse, (void*)temp2, &yymsp[-2].minor.yy0);
   }
-  yylhsminor.yy524 = sqlite3PExpr(pParse, TK_DOT, temp1, temp4);
+  yylhsminor.yy46 = sqlite3PExpr(pParse, TK_DOT, temp1, temp4);
 }
-  yymsp[-4].minor.yy524 = yylhsminor.yy524;
+  yymsp[-4].minor.yy46 = yylhsminor.yy46;
         break;
-      case 167: /* term ::= NULL|FLOAT|BLOB */
-      case 168: /* term ::= STRING */ yytestcase(yyruleno==168);
-{yymsp[0].minor.yy524=tokenExpr(pParse,yymsp[0].major,yymsp[0].minor.yy0); /*A-overwrites-X*/}
+      case 171: /* term ::= NULL|FLOAT|BLOB */
+      case 172: /* term ::= STRING */ yytestcase(yyruleno==172);
+{yymsp[0].minor.yy46=tokenExpr(pParse,yymsp[0].major,yymsp[0].minor.yy0); /*A-overwrites-X*/}
         break;
-      case 169: /* term ::= INTEGER */
+      case 173: /* term ::= INTEGER */
 {
-  yylhsminor.yy524 = sqlite3ExprAlloc(pParse->db, TK_INTEGER, &yymsp[0].minor.yy0, 1);
+  yylhsminor.yy46 = sqlite3ExprAlloc(pParse->db, TK_INTEGER, &yymsp[0].minor.yy0, 1);
 }
-  yymsp[0].minor.yy524 = yylhsminor.yy524;
+  yymsp[0].minor.yy46 = yylhsminor.yy46;
         break;
-      case 170: /* expr ::= VARIABLE */
+      case 174: /* expr ::= VARIABLE */
 {
   if( !(yymsp[0].minor.yy0.z[0]=='#' && sqlite3Isdigit(yymsp[0].minor.yy0.z[1])) ){
     u32 n = yymsp[0].minor.yy0.n;
-    yymsp[0].minor.yy524 = tokenExpr(pParse, TK_VARIABLE, yymsp[0].minor.yy0);
-    sqlite3ExprAssignVarNumber(pParse, yymsp[0].minor.yy524, n);
+    yymsp[0].minor.yy46 = tokenExpr(pParse, TK_VARIABLE, yymsp[0].minor.yy0);
+    sqlite3ExprAssignVarNumber(pParse, yymsp[0].minor.yy46, n);
   }else{
     /* When doing a nested parse, one can include terms in an expression
     ** that look like this:   #1 #2 ...  These terms refer to registers
     ** in the virtual machine.  #N is the N-th register. */
     Token t = yymsp[0].minor.yy0; /*A-overwrites-X*/
     assert( t.n>=2 );
     if( pParse->nested==0 ){
       sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", &t);
-      yymsp[0].minor.yy524 = 0;
+      yymsp[0].minor.yy46 = 0;
     }else{
-      yymsp[0].minor.yy524 = sqlite3PExpr(pParse, TK_REGISTER, 0, 0);
-      if( yymsp[0].minor.yy524 ) sqlite3GetInt32(&t.z[1], &yymsp[0].minor.yy524->iTable);
+      yymsp[0].minor.yy46 = sqlite3PExpr(pParse, TK_REGISTER, 0, 0);
+      if( yymsp[0].minor.yy46 ) sqlite3GetInt32(&t.z[1], &yymsp[0].minor.yy46->iTable);
     }
   }
 }
         break;
-      case 171: /* expr ::= expr COLLATE ID|STRING */
+      case 175: /* expr ::= expr COLLATE ID|STRING */
 {
-  yymsp[-2].minor.yy524 = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy524, &yymsp[0].minor.yy0, 1);
+  yymsp[-2].minor.yy46 = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy46, &yymsp[0].minor.yy0, 1);
 }
         break;
-      case 172: /* expr ::= CAST LP expr AS typetoken RP */
+      case 176: /* expr ::= CAST LP expr AS typetoken RP */
 {
-  yymsp[-5].minor.yy524 = sqlite3ExprAlloc(pParse->db, TK_CAST, &yymsp[-1].minor.yy0, 1);
-  sqlite3ExprAttachSubtrees(pParse->db, yymsp[-5].minor.yy524, yymsp[-3].minor.yy524, 0);
+  yymsp[-5].minor.yy46 = sqlite3ExprAlloc(pParse->db, TK_CAST, &yymsp[-1].minor.yy0, 1);
+  sqlite3ExprAttachSubtrees(pParse->db, yymsp[-5].minor.yy46, yymsp[-3].minor.yy46, 0);
 }
         break;
-      case 173: /* expr ::= ID|INDEXED LP distinct exprlist RP */
+      case 177: /* expr ::= ID|INDEXED LP distinct exprlist RP */
 {
-  yylhsminor.yy524 = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy434, &yymsp[-4].minor.yy0, yymsp[-2].minor.yy494);
+  yylhsminor.yy46 = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy138, &yymsp[-4].minor.yy0, yymsp[-2].minor.yy32);
 }
-  yymsp[-4].minor.yy524 = yylhsminor.yy524;
+  yymsp[-4].minor.yy46 = yylhsminor.yy46;
         break;
-      case 174: /* expr ::= ID|INDEXED LP STAR RP */
+      case 178: /* expr ::= ID|INDEXED LP STAR RP */
 {
-  yylhsminor.yy524 = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0, 0);
+  yylhsminor.yy46 = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0, 0);
 }
-  yymsp[-3].minor.yy524 = yylhsminor.yy524;
+  yymsp[-3].minor.yy46 = yylhsminor.yy46;
         break;
-      case 175: /* expr ::= ID|INDEXED LP distinct exprlist RP over_clause */
+      case 179: /* expr ::= ID|INDEXED LP distinct exprlist RP filter_over */
 {
-  yylhsminor.yy524 = sqlite3ExprFunction(pParse, yymsp[-2].minor.yy434, &yymsp[-5].minor.yy0, yymsp[-3].minor.yy494);
-  sqlite3WindowAttach(pParse, yylhsminor.yy524, yymsp[0].minor.yy295);
+  yylhsminor.yy46 = sqlite3ExprFunction(pParse, yymsp[-2].minor.yy138, &yymsp[-5].minor.yy0, yymsp[-3].minor.yy32);
+  sqlite3WindowAttach(pParse, yylhsminor.yy46, yymsp[0].minor.yy455);
 }
-  yymsp[-5].minor.yy524 = yylhsminor.yy524;
+  yymsp[-5].minor.yy46 = yylhsminor.yy46;
         break;
-      case 176: /* expr ::= ID|INDEXED LP STAR RP over_clause */
+      case 180: /* expr ::= ID|INDEXED LP STAR RP filter_over */
 {
-  yylhsminor.yy524 = sqlite3ExprFunction(pParse, 0, &yymsp[-4].minor.yy0, 0);
-  sqlite3WindowAttach(pParse, yylhsminor.yy524, yymsp[0].minor.yy295);
+  yylhsminor.yy46 = sqlite3ExprFunction(pParse, 0, &yymsp[-4].minor.yy0, 0);
+  sqlite3WindowAttach(pParse, yylhsminor.yy46, yymsp[0].minor.yy455);
 }
-  yymsp[-4].minor.yy524 = yylhsminor.yy524;
+  yymsp[-4].minor.yy46 = yylhsminor.yy46;
         break;
-      case 177: /* term ::= CTIME_KW */
+      case 181: /* term ::= CTIME_KW */
 {
-  yylhsminor.yy524 = sqlite3ExprFunction(pParse, 0, &yymsp[0].minor.yy0, 0);
+  yylhsminor.yy46 = sqlite3ExprFunction(pParse, 0, &yymsp[0].minor.yy0, 0);
 }
-  yymsp[0].minor.yy524 = yylhsminor.yy524;
+  yymsp[0].minor.yy46 = yylhsminor.yy46;
         break;
-      case 178: /* expr ::= LP nexprlist COMMA expr RP */
+      case 182: /* expr ::= LP nexprlist COMMA expr RP */
 {
-  ExprList *pList = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy434, yymsp[-1].minor.yy524);
-  yymsp[-4].minor.yy524 = sqlite3PExpr(pParse, TK_VECTOR, 0, 0);
-  if( yymsp[-4].minor.yy524 ){
-    yymsp[-4].minor.yy524->x.pList = pList;
+  ExprList *pList = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy138, yymsp[-1].minor.yy46);
+  yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, TK_VECTOR, 0, 0);
+  if( yymsp[-4].minor.yy46 ){
+    yymsp[-4].minor.yy46->x.pList = pList;
   }else{
     sqlite3ExprListDelete(pParse->db, pList);
   }
 }
         break;
-      case 179: /* expr ::= expr AND expr */
-      case 180: /* expr ::= expr OR expr */ yytestcase(yyruleno==180);
-      case 181: /* expr ::= expr LT|GT|GE|LE expr */ yytestcase(yyruleno==181);
-      case 182: /* expr ::= expr EQ|NE expr */ yytestcase(yyruleno==182);
-      case 183: /* expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr */ yytestcase(yyruleno==183);
-      case 184: /* expr ::= expr PLUS|MINUS expr */ yytestcase(yyruleno==184);
-      case 185: /* expr ::= expr STAR|SLASH|REM expr */ yytestcase(yyruleno==185);
-      case 186: /* expr ::= expr CONCAT expr */ yytestcase(yyruleno==186);
-{yymsp[-2].minor.yy524=sqlite3PExpr(pParse,yymsp[-1].major,yymsp[-2].minor.yy524,yymsp[0].minor.yy524);}
+      case 183: /* expr ::= expr AND expr */
+{yymsp[-2].minor.yy46=sqlite3ExprAnd(pParse,yymsp[-2].minor.yy46,yymsp[0].minor.yy46);}
         break;
-      case 187: /* likeop ::= NOT LIKE_KW|MATCH */
+      case 184: /* expr ::= expr OR expr */
+      case 185: /* expr ::= expr LT|GT|GE|LE expr */ yytestcase(yyruleno==185);
+      case 186: /* expr ::= expr EQ|NE expr */ yytestcase(yyruleno==186);
+      case 187: /* expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr */ yytestcase(yyruleno==187);
+      case 188: /* expr ::= expr PLUS|MINUS expr */ yytestcase(yyruleno==188);
+      case 189: /* expr ::= expr STAR|SLASH|REM expr */ yytestcase(yyruleno==189);
+      case 190: /* expr ::= expr CONCAT expr */ yytestcase(yyruleno==190);
+{yymsp[-2].minor.yy46=sqlite3PExpr(pParse,yymsp[-1].major,yymsp[-2].minor.yy46,yymsp[0].minor.yy46);}
+        break;
+      case 191: /* likeop ::= NOT LIKE_KW|MATCH */
 {yymsp[-1].minor.yy0=yymsp[0].minor.yy0; yymsp[-1].minor.yy0.n|=0x80000000; /*yymsp[-1].minor.yy0-overwrite-yymsp[0].minor.yy0*/}
         break;
-      case 188: /* expr ::= expr likeop expr */
+      case 192: /* expr ::= expr likeop expr */
 {
   ExprList *pList;
   int bNot = yymsp[-1].minor.yy0.n & 0x80000000;
   yymsp[-1].minor.yy0.n &= 0x7fffffff;
-  pList = sqlite3ExprListAppend(pParse,0, yymsp[0].minor.yy524);
-  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-2].minor.yy524);
-  yymsp[-2].minor.yy524 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);
-  if( bNot ) yymsp[-2].minor.yy524 = sqlite3PExpr(pParse, TK_NOT, yymsp[-2].minor.yy524, 0);
-  if( yymsp[-2].minor.yy524 ) yymsp[-2].minor.yy524->flags |= EP_InfixFunc;
+  pList = sqlite3ExprListAppend(pParse,0, yymsp[0].minor.yy46);
+  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-2].minor.yy46);
+  yymsp[-2].minor.yy46 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);
+  if( bNot ) yymsp[-2].minor.yy46 = sqlite3PExpr(pParse, TK_NOT, yymsp[-2].minor.yy46, 0);
+  if( yymsp[-2].minor.yy46 ) yymsp[-2].minor.yy46->flags |= EP_InfixFunc;
 }
         break;
-      case 189: /* expr ::= expr likeop expr ESCAPE expr */
+      case 193: /* expr ::= expr likeop expr ESCAPE expr */
 {
   ExprList *pList;
   int bNot = yymsp[-3].minor.yy0.n & 0x80000000;
   yymsp[-3].minor.yy0.n &= 0x7fffffff;
-  pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy524);
-  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-4].minor.yy524);
-  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy524);
-  yymsp[-4].minor.yy524 = sqlite3ExprFunction(pParse, pList, &yymsp[-3].minor.yy0, 0);
-  if( bNot ) yymsp[-4].minor.yy524 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy524, 0);
-  if( yymsp[-4].minor.yy524 ) yymsp[-4].minor.yy524->flags |= EP_InfixFunc;
+  pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy46);
+  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-4].minor.yy46);
+  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy46);
+  yymsp[-4].minor.yy46 = sqlite3ExprFunction(pParse, pList, &yymsp[-3].minor.yy0, 0);
+  if( bNot ) yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy46, 0);
+  if( yymsp[-4].minor.yy46 ) yymsp[-4].minor.yy46->flags |= EP_InfixFunc;
 }
         break;
-      case 190: /* expr ::= expr ISNULL|NOTNULL */
-{yymsp[-1].minor.yy524 = sqlite3PExpr(pParse,yymsp[0].major,yymsp[-1].minor.yy524,0);}
+      case 194: /* expr ::= expr ISNULL|NOTNULL */
+{yymsp[-1].minor.yy46 = sqlite3PExpr(pParse,yymsp[0].major,yymsp[-1].minor.yy46,0);}
         break;
-      case 191: /* expr ::= expr NOT NULL */
-{yymsp[-2].minor.yy524 = sqlite3PExpr(pParse,TK_NOTNULL,yymsp[-2].minor.yy524,0);}
+      case 195: /* expr ::= expr NOT NULL */
+{yymsp[-2].minor.yy46 = sqlite3PExpr(pParse,TK_NOTNULL,yymsp[-2].minor.yy46,0);}
         break;
-      case 192: /* expr ::= expr IS expr */
+      case 196: /* expr ::= expr IS expr */
 {
-  yymsp[-2].minor.yy524 = sqlite3PExpr(pParse,TK_IS,yymsp[-2].minor.yy524,yymsp[0].minor.yy524);
-  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy524, yymsp[-2].minor.yy524, TK_ISNULL);
+  yymsp[-2].minor.yy46 = sqlite3PExpr(pParse,TK_IS,yymsp[-2].minor.yy46,yymsp[0].minor.yy46);
+  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy46, yymsp[-2].minor.yy46, TK_ISNULL);
 }
         break;
-      case 193: /* expr ::= expr IS NOT expr */
+      case 197: /* expr ::= expr IS NOT expr */
 {
-  yymsp[-3].minor.yy524 = sqlite3PExpr(pParse,TK_ISNOT,yymsp[-3].minor.yy524,yymsp[0].minor.yy524);
-  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy524, yymsp[-3].minor.yy524, TK_NOTNULL);
+  yymsp[-3].minor.yy46 = sqlite3PExpr(pParse,TK_ISNOT,yymsp[-3].minor.yy46,yymsp[0].minor.yy46);
+  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy46, yymsp[-3].minor.yy46, TK_NOTNULL);
 }
         break;
-      case 194: /* expr ::= NOT expr */
-      case 195: /* expr ::= BITNOT expr */ yytestcase(yyruleno==195);
-{yymsp[-1].minor.yy524 = sqlite3PExpr(pParse, yymsp[-1].major, yymsp[0].minor.yy524, 0);/*A-overwrites-B*/}
+      case 198: /* expr ::= NOT expr */
+      case 199: /* expr ::= BITNOT expr */ yytestcase(yyruleno==199);
+{yymsp[-1].minor.yy46 = sqlite3PExpr(pParse, yymsp[-1].major, yymsp[0].minor.yy46, 0);/*A-overwrites-B*/}
         break;
-      case 196: /* expr ::= PLUS|MINUS expr */
+      case 200: /* expr ::= PLUS|MINUS expr */
 {
-  yymsp[-1].minor.yy524 = sqlite3PExpr(pParse, yymsp[-1].major==TK_PLUS ? TK_UPLUS : TK_UMINUS, yymsp[0].minor.yy524, 0);
+  yymsp[-1].minor.yy46 = sqlite3PExpr(pParse, yymsp[-1].major==TK_PLUS ? TK_UPLUS : TK_UMINUS, yymsp[0].minor.yy46, 0);
   /*A-overwrites-B*/
 }
         break;
-      case 197: /* between_op ::= BETWEEN */
-      case 200: /* in_op ::= IN */ yytestcase(yyruleno==200);
-{yymsp[0].minor.yy494 = 0;}
+      case 201: /* between_op ::= BETWEEN */
+      case 204: /* in_op ::= IN */ yytestcase(yyruleno==204);
+{yymsp[0].minor.yy32 = 0;}
         break;
-      case 199: /* expr ::= expr between_op expr AND expr */
+      case 203: /* expr ::= expr between_op expr AND expr */
 {
-  ExprList *pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy524);
-  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy524);
-  yymsp[-4].minor.yy524 = sqlite3PExpr(pParse, TK_BETWEEN, yymsp[-4].minor.yy524, 0);
-  if( yymsp[-4].minor.yy524 ){
-    yymsp[-4].minor.yy524->x.pList = pList;
+  ExprList *pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy46);
+  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy46);
+  yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, TK_BETWEEN, yymsp[-4].minor.yy46, 0);
+  if( yymsp[-4].minor.yy46 ){
+    yymsp[-4].minor.yy46->x.pList = pList;
   }else{
     sqlite3ExprListDelete(pParse->db, pList);
   }
-  if( yymsp[-3].minor.yy494 ) yymsp[-4].minor.yy524 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy524, 0);
+  if( yymsp[-3].minor.yy32 ) yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy46, 0);
 }
         break;
-      case 202: /* expr ::= expr in_op LP exprlist RP */
+      case 206: /* expr ::= expr in_op LP exprlist RP */
 {
-    if( yymsp[-1].minor.yy434==0 ){
+    if( yymsp[-1].minor.yy138==0 ){
       /* Expressions of the form
       **
       **      expr1 IN ()
       **      expr1 NOT IN ()
       **
       ** simplify to constants 0 (false) and 1 (true), respectively,
       ** regardless of the value of expr1.
       */
-      if( IN_RENAME_OBJECT==0 ){
-        sqlite3ExprDelete(pParse->db, yymsp[-4].minor.yy524);
-        yymsp[-4].minor.yy524 = sqlite3ExprAlloc(pParse->db, TK_INTEGER,&sqlite3IntTokens[yymsp[-3].minor.yy494],1);
-      }
-    }else if( yymsp[-1].minor.yy434->nExpr==1 ){
-      /* Expressions of the form:
-      **
-      **      expr1 IN (?1)
-      **      expr1 NOT IN (?2)
-      **
-      ** with exactly one value on the RHS can be simplified to something
-      ** like this:
-      **
-      **      expr1 == ?1
-      **      expr1 <> ?2
-      **
-      ** But, the RHS of the == or <> is marked with the EP_Generic flag
-      ** so that it may not contribute to the computation of comparison
-      ** affinity or the collating sequence to use for comparison.  Otherwise,
-      ** the semantics would be subtly different from IN or NOT IN.
-      */
-      Expr *pRHS = yymsp[-1].minor.yy434->a[0].pExpr;
-      yymsp[-1].minor.yy434->a[0].pExpr = 0;
-      sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy434);
-      /* pRHS cannot be NULL because a malloc error would have been detected
-      ** before now and control would have never reached this point */
-      if( ALWAYS(pRHS) ){
-        pRHS->flags &= ~EP_Collate;
-        pRHS->flags |= EP_Generic;
-      }
-      yymsp[-4].minor.yy524 = sqlite3PExpr(pParse, yymsp[-3].minor.yy494 ? TK_NE : TK_EQ, yymsp[-4].minor.yy524, pRHS);
-    }else{
-      yymsp[-4].minor.yy524 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy524, 0);
-      if( yymsp[-4].minor.yy524 ){
-        yymsp[-4].minor.yy524->x.pList = yymsp[-1].minor.yy434;
-        sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy524);
+      sqlite3ExprUnmapAndDelete(pParse, yymsp[-4].minor.yy46);
+      yymsp[-4].minor.yy46 = sqlite3Expr(pParse->db, TK_INTEGER, yymsp[-3].minor.yy32 ? "1" : "0");
+    }else{
+      yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy46, 0);
+      if( yymsp[-4].minor.yy46 ){
+        yymsp[-4].minor.yy46->x.pList = yymsp[-1].minor.yy138;
+        sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy46);
       }else{
-        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy434);
+        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy138);
       }
-      if( yymsp[-3].minor.yy494 ) yymsp[-4].minor.yy524 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy524, 0);
+      if( yymsp[-3].minor.yy32 ) yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy46, 0);
     }
   }
         break;
-      case 203: /* expr ::= LP select RP */
+      case 207: /* expr ::= LP select RP */
 {
-    yymsp[-2].minor.yy524 = sqlite3PExpr(pParse, TK_SELECT, 0, 0);
-    sqlite3PExprAddSelect(pParse, yymsp[-2].minor.yy524, yymsp[-1].minor.yy457);
+    yymsp[-2].minor.yy46 = sqlite3PExpr(pParse, TK_SELECT, 0, 0);
+    sqlite3PExprAddSelect(pParse, yymsp[-2].minor.yy46, yymsp[-1].minor.yy25);
   }
         break;
-      case 204: /* expr ::= expr in_op LP select RP */
+      case 208: /* expr ::= expr in_op LP select RP */
 {
-    yymsp[-4].minor.yy524 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy524, 0);
-    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy524, yymsp[-1].minor.yy457);
-    if( yymsp[-3].minor.yy494 ) yymsp[-4].minor.yy524 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy524, 0);
+    yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy46, 0);
+    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy46, yymsp[-1].minor.yy25);
+    if( yymsp[-3].minor.yy32 ) yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy46, 0);
   }
         break;
-      case 205: /* expr ::= expr in_op nm dbnm paren_exprlist */
+      case 209: /* expr ::= expr in_op nm dbnm paren_exprlist */
 {
     SrcList *pSrc = sqlite3SrcListAppend(pParse, 0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0);
     Select *pSelect = sqlite3SelectNew(pParse, 0,pSrc,0,0,0,0,0,0);
-    if( yymsp[0].minor.yy434 )  sqlite3SrcListFuncArgs(pParse, pSelect ? pSrc : 0, yymsp[0].minor.yy434);
-    yymsp[-4].minor.yy524 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy524, 0);
-    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy524, pSelect);
-    if( yymsp[-3].minor.yy494 ) yymsp[-4].minor.yy524 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy524, 0);
+    if( yymsp[0].minor.yy138 )  sqlite3SrcListFuncArgs(pParse, pSelect ? pSrc : 0, yymsp[0].minor.yy138);
+    yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy46, 0);
+    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy46, pSelect);
+    if( yymsp[-3].minor.yy32 ) yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy46, 0);
   }
         break;
-      case 206: /* expr ::= EXISTS LP select RP */
+      case 210: /* expr ::= EXISTS LP select RP */
 {
     Expr *p;
-    p = yymsp[-3].minor.yy524 = sqlite3PExpr(pParse, TK_EXISTS, 0, 0);
-    sqlite3PExprAddSelect(pParse, p, yymsp[-1].minor.yy457);
+    p = yymsp[-3].minor.yy46 = sqlite3PExpr(pParse, TK_EXISTS, 0, 0);
+    sqlite3PExprAddSelect(pParse, p, yymsp[-1].minor.yy25);
   }
         break;
-      case 207: /* expr ::= CASE case_operand case_exprlist case_else END */
+      case 211: /* expr ::= CASE case_operand case_exprlist case_else END */
 {
-  yymsp[-4].minor.yy524 = sqlite3PExpr(pParse, TK_CASE, yymsp[-3].minor.yy524, 0);
-  if( yymsp[-4].minor.yy524 ){
-    yymsp[-4].minor.yy524->x.pList = yymsp[-1].minor.yy524 ? sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy434,yymsp[-1].minor.yy524) : yymsp[-2].minor.yy434;
-    sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy524);
+  yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, TK_CASE, yymsp[-3].minor.yy46, 0);
+  if( yymsp[-4].minor.yy46 ){
+    yymsp[-4].minor.yy46->x.pList = yymsp[-1].minor.yy46 ? sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy138,yymsp[-1].minor.yy46) : yymsp[-2].minor.yy138;
+    sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy46);
   }else{
-    sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy434);
-    sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy524);
+    sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy138);
+    sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy46);
   }
 }
         break;
-      case 208: /* case_exprlist ::= case_exprlist WHEN expr THEN expr */
+      case 212: /* case_exprlist ::= case_exprlist WHEN expr THEN expr */
 {
-  yymsp[-4].minor.yy434 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy434, yymsp[-2].minor.yy524);
-  yymsp[-4].minor.yy434 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy434, yymsp[0].minor.yy524);
+  yymsp[-4].minor.yy138 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy138, yymsp[-2].minor.yy46);
+  yymsp[-4].minor.yy138 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy138, yymsp[0].minor.yy46);
 }
         break;
-      case 209: /* case_exprlist ::= WHEN expr THEN expr */
+      case 213: /* case_exprlist ::= WHEN expr THEN expr */
 {
-  yymsp[-3].minor.yy434 = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy524);
-  yymsp[-3].minor.yy434 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy434, yymsp[0].minor.yy524);
+  yymsp[-3].minor.yy138 = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy46);
+  yymsp[-3].minor.yy138 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy138, yymsp[0].minor.yy46);
 }
         break;
-      case 212: /* case_operand ::= expr */
-{yymsp[0].minor.yy524 = yymsp[0].minor.yy524; /*A-overwrites-X*/}
+      case 216: /* case_operand ::= expr */
+{yymsp[0].minor.yy46 = yymsp[0].minor.yy46; /*A-overwrites-X*/}
         break;
-      case 215: /* nexprlist ::= nexprlist COMMA expr */
-{yymsp[-2].minor.yy434 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy434,yymsp[0].minor.yy524);}
+      case 219: /* nexprlist ::= nexprlist COMMA expr */
+{yymsp[-2].minor.yy138 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy138,yymsp[0].minor.yy46);}
         break;
-      case 216: /* nexprlist ::= expr */
-{yymsp[0].minor.yy434 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy524); /*A-overwrites-Y*/}
+      case 220: /* nexprlist ::= expr */
+{yymsp[0].minor.yy138 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy46); /*A-overwrites-Y*/}
         break;
-      case 218: /* paren_exprlist ::= LP exprlist RP */
-      case 223: /* eidlist_opt ::= LP eidlist RP */ yytestcase(yyruleno==223);
-{yymsp[-2].minor.yy434 = yymsp[-1].minor.yy434;}
+      case 222: /* paren_exprlist ::= LP exprlist RP */
+      case 227: /* eidlist_opt ::= LP eidlist RP */ yytestcase(yyruleno==227);
+{yymsp[-2].minor.yy138 = yymsp[-1].minor.yy138;}
         break;
-      case 219: /* cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt */
+      case 223: /* cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt */
 {
   sqlite3CreateIndex(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0,
-                     sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,0), yymsp[-2].minor.yy434, yymsp[-10].minor.yy494,
-                      &yymsp[-11].minor.yy0, yymsp[0].minor.yy524, SQLITE_SO_ASC, yymsp[-8].minor.yy494, SQLITE_IDXTYPE_APPDEF);
+                     sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,0), yymsp[-2].minor.yy138, yymsp[-10].minor.yy32,
+                      &yymsp[-11].minor.yy0, yymsp[0].minor.yy46, SQLITE_SO_ASC, yymsp[-8].minor.yy32, SQLITE_IDXTYPE_APPDEF);
   if( IN_RENAME_OBJECT && pParse->pNewIndex ){
     sqlite3RenameTokenMap(pParse, pParse->pNewIndex->zName, &yymsp[-4].minor.yy0);
   }
 }
         break;
-      case 220: /* uniqueflag ::= UNIQUE */
-      case 262: /* raisetype ::= ABORT */ yytestcase(yyruleno==262);
-{yymsp[0].minor.yy494 = OE_Abort;}
+      case 224: /* uniqueflag ::= UNIQUE */
+      case 266: /* raisetype ::= ABORT */ yytestcase(yyruleno==266);
+{yymsp[0].minor.yy32 = OE_Abort;}
         break;
-      case 221: /* uniqueflag ::= */
-{yymsp[1].minor.yy494 = OE_None;}
+      case 225: /* uniqueflag ::= */
+{yymsp[1].minor.yy32 = OE_None;}
         break;
-      case 224: /* eidlist ::= eidlist COMMA nm collate sortorder */
+      case 228: /* eidlist ::= eidlist COMMA nm collate sortorder */
 {
-  yymsp[-4].minor.yy434 = parserAddExprIdListTerm(pParse, yymsp[-4].minor.yy434, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy494, yymsp[0].minor.yy494);
+  yymsp[-4].minor.yy138 = parserAddExprIdListTerm(pParse, yymsp[-4].minor.yy138, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy32, yymsp[0].minor.yy32);
 }
         break;
-      case 225: /* eidlist ::= nm collate sortorder */
+      case 229: /* eidlist ::= nm collate sortorder */
 {
-  yymsp[-2].minor.yy434 = parserAddExprIdListTerm(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy494, yymsp[0].minor.yy494); /*A-overwrites-Y*/
+  yymsp[-2].minor.yy138 = parserAddExprIdListTerm(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy32, yymsp[0].minor.yy32); /*A-overwrites-Y*/
 }
         break;
-      case 228: /* cmd ::= DROP INDEX ifexists fullname */
-{sqlite3DropIndex(pParse, yymsp[0].minor.yy483, yymsp[-1].minor.yy494);}
+      case 232: /* cmd ::= DROP INDEX ifexists fullname */
+{sqlite3DropIndex(pParse, yymsp[0].minor.yy609, yymsp[-1].minor.yy32);}
         break;
-      case 229: /* cmd ::= VACUUM vinto */
-{sqlite3Vacuum(pParse,0,yymsp[0].minor.yy524);}
+      case 233: /* cmd ::= VACUUM vinto */
+{sqlite3Vacuum(pParse,0,yymsp[0].minor.yy46);}
         break;
-      case 230: /* cmd ::= VACUUM nm vinto */
-{sqlite3Vacuum(pParse,&yymsp[-1].minor.yy0,yymsp[0].minor.yy524);}
+      case 234: /* cmd ::= VACUUM nm vinto */
+{sqlite3Vacuum(pParse,&yymsp[-1].minor.yy0,yymsp[0].minor.yy46);}
         break;
-      case 233: /* cmd ::= PRAGMA nm dbnm */
+      case 237: /* cmd ::= PRAGMA nm dbnm */
 {sqlite3Pragma(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,0,0);}
         break;
-      case 234: /* cmd ::= PRAGMA nm dbnm EQ nmnum */
+      case 238: /* cmd ::= PRAGMA nm dbnm EQ nmnum */
 {sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,0);}
         break;
-      case 235: /* cmd ::= PRAGMA nm dbnm LP nmnum RP */
+      case 239: /* cmd ::= PRAGMA nm dbnm LP nmnum RP */
 {sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,0);}
         break;
-      case 236: /* cmd ::= PRAGMA nm dbnm EQ minus_num */
+      case 240: /* cmd ::= PRAGMA nm dbnm EQ minus_num */
 {sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,1);}
         break;
-      case 237: /* cmd ::= PRAGMA nm dbnm LP minus_num RP */
+      case 241: /* cmd ::= PRAGMA nm dbnm LP minus_num RP */
 {sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,1);}
         break;
-      case 240: /* cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END */
+      case 244: /* cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END */
 {
   Token all;
   all.z = yymsp[-3].minor.yy0.z;
   all.n = (int)(yymsp[0].minor.yy0.z - yymsp[-3].minor.yy0.z) + yymsp[0].minor.yy0.n;
-  sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy455, &all);
+  sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy527, &all);
 }
         break;
-      case 241: /* trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause */
+      case 245: /* trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause */
 {
-  sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy494, yymsp[-4].minor.yy90.a, yymsp[-4].minor.yy90.b, yymsp[-2].minor.yy483, yymsp[0].minor.yy524, yymsp[-10].minor.yy494, yymsp[-8].minor.yy494);
+  sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy32, yymsp[-4].minor.yy572.a, yymsp[-4].minor.yy572.b, yymsp[-2].minor.yy609, yymsp[0].minor.yy46, yymsp[-10].minor.yy32, yymsp[-8].minor.yy32);
   yymsp[-10].minor.yy0 = (yymsp[-6].minor.yy0.n==0?yymsp[-7].minor.yy0:yymsp[-6].minor.yy0); /*A-overwrites-T*/
 }
         break;
-      case 242: /* trigger_time ::= BEFORE|AFTER */
-{ yymsp[0].minor.yy494 = yymsp[0].major; /*A-overwrites-X*/ }
+      case 246: /* trigger_time ::= BEFORE|AFTER */
+{ yymsp[0].minor.yy32 = yymsp[0].major; /*A-overwrites-X*/ }
         break;
-      case 243: /* trigger_time ::= INSTEAD OF */
-{ yymsp[-1].minor.yy494 = TK_INSTEAD;}
+      case 247: /* trigger_time ::= INSTEAD OF */
+{ yymsp[-1].minor.yy32 = TK_INSTEAD;}
         break;
-      case 244: /* trigger_time ::= */
-{ yymsp[1].minor.yy494 = TK_BEFORE; }
+      case 248: /* trigger_time ::= */
+{ yymsp[1].minor.yy32 = TK_BEFORE; }
         break;
-      case 245: /* trigger_event ::= DELETE|INSERT */
-      case 246: /* trigger_event ::= UPDATE */ yytestcase(yyruleno==246);
-{yymsp[0].minor.yy90.a = yymsp[0].major; /*A-overwrites-X*/ yymsp[0].minor.yy90.b = 0;}
+      case 249: /* trigger_event ::= DELETE|INSERT */
+      case 250: /* trigger_event ::= UPDATE */ yytestcase(yyruleno==250);
+{yymsp[0].minor.yy572.a = yymsp[0].major; /*A-overwrites-X*/ yymsp[0].minor.yy572.b = 0;}
         break;
-      case 247: /* trigger_event ::= UPDATE OF idlist */
-{yymsp[-2].minor.yy90.a = TK_UPDATE; yymsp[-2].minor.yy90.b = yymsp[0].minor.yy62;}
+      case 251: /* trigger_event ::= UPDATE OF idlist */
+{yymsp[-2].minor.yy572.a = TK_UPDATE; yymsp[-2].minor.yy572.b = yymsp[0].minor.yy406;}
         break;
-      case 248: /* when_clause ::= */
-      case 267: /* key_opt ::= */ yytestcase(yyruleno==267);
-      case 315: /* filter_opt ::= */ yytestcase(yyruleno==315);
-{ yymsp[1].minor.yy524 = 0; }
+      case 252: /* when_clause ::= */
+      case 271: /* key_opt ::= */ yytestcase(yyruleno==271);
+{ yymsp[1].minor.yy46 = 0; }
         break;
-      case 249: /* when_clause ::= WHEN expr */
-      case 268: /* key_opt ::= KEY expr */ yytestcase(yyruleno==268);
-{ yymsp[-1].minor.yy524 = yymsp[0].minor.yy524; }
+      case 253: /* when_clause ::= WHEN expr */
+      case 272: /* key_opt ::= KEY expr */ yytestcase(yyruleno==272);
+{ yymsp[-1].minor.yy46 = yymsp[0].minor.yy46; }
         break;
-      case 250: /* trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI */
+      case 254: /* trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI */
 {
-  assert( yymsp[-2].minor.yy455!=0 );
-  yymsp[-2].minor.yy455->pLast->pNext = yymsp[-1].minor.yy455;
-  yymsp[-2].minor.yy455->pLast = yymsp[-1].minor.yy455;
+  assert( yymsp[-2].minor.yy527!=0 );
+  yymsp[-2].minor.yy527->pLast->pNext = yymsp[-1].minor.yy527;
+  yymsp[-2].minor.yy527->pLast = yymsp[-1].minor.yy527;
 }
         break;
-      case 251: /* trigger_cmd_list ::= trigger_cmd SEMI */
+      case 255: /* trigger_cmd_list ::= trigger_cmd SEMI */
 {
-  assert( yymsp[-1].minor.yy455!=0 );
-  yymsp[-1].minor.yy455->pLast = yymsp[-1].minor.yy455;
+  assert( yymsp[-1].minor.yy527!=0 );
+  yymsp[-1].minor.yy527->pLast = yymsp[-1].minor.yy527;
 }
         break;
-      case 252: /* trnm ::= nm DOT nm */
+      case 256: /* trnm ::= nm DOT nm */
 {
   yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;
   sqlite3ErrorMsg(pParse,
         "qualified table names are not allowed on INSERT, UPDATE, and DELETE "
         "statements within triggers");
 }
         break;
-      case 253: /* tridxby ::= INDEXED BY nm */
+      case 257: /* tridxby ::= INDEXED BY nm */
 {
   sqlite3ErrorMsg(pParse,
         "the INDEXED BY clause is not allowed on UPDATE or DELETE statements "
         "within triggers");
 }
         break;
-      case 254: /* tridxby ::= NOT INDEXED */
+      case 258: /* tridxby ::= NOT INDEXED */
 {
   sqlite3ErrorMsg(pParse,
         "the NOT INDEXED clause is not allowed on UPDATE or DELETE statements "
         "within triggers");
 }
         break;
-      case 255: /* trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt */
-{yylhsminor.yy455 = sqlite3TriggerUpdateStep(pParse, &yymsp[-5].minor.yy0, yymsp[-2].minor.yy434, yymsp[-1].minor.yy524, yymsp[-6].minor.yy494, yymsp[-7].minor.yy0.z, yymsp[0].minor.yy294);}
-  yymsp[-7].minor.yy455 = yylhsminor.yy455;
+      case 259: /* trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt scanpt */
+{yylhsminor.yy527 = sqlite3TriggerUpdateStep(pParse, &yymsp[-5].minor.yy0, yymsp[-2].minor.yy138, yymsp[-1].minor.yy46, yymsp[-6].minor.yy32, yymsp[-7].minor.yy0.z, yymsp[0].minor.yy8);}
+  yymsp[-7].minor.yy527 = yylhsminor.yy527;
         break;
-      case 256: /* trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt */
+      case 260: /* trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt */
 {
-   yylhsminor.yy455 = sqlite3TriggerInsertStep(pParse,&yymsp[-4].minor.yy0,yymsp[-3].minor.yy62,yymsp[-2].minor.yy457,yymsp[-6].minor.yy494,yymsp[-1].minor.yy136,yymsp[-7].minor.yy294,yymsp[0].minor.yy294);/*yylhsminor.yy455-overwrites-yymsp[-6].minor.yy494*/
+   yylhsminor.yy527 = sqlite3TriggerInsertStep(pParse,&yymsp[-4].minor.yy0,yymsp[-3].minor.yy406,yymsp[-2].minor.yy25,yymsp[-6].minor.yy32,yymsp[-1].minor.yy288,yymsp[-7].minor.yy8,yymsp[0].minor.yy8);/*yylhsminor.yy527-overwrites-yymsp[-6].minor.yy32*/
 }
-  yymsp[-7].minor.yy455 = yylhsminor.yy455;
+  yymsp[-7].minor.yy527 = yylhsminor.yy527;
         break;
-      case 257: /* trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt */
-{yylhsminor.yy455 = sqlite3TriggerDeleteStep(pParse, &yymsp[-3].minor.yy0, yymsp[-1].minor.yy524, yymsp[-5].minor.yy0.z, yymsp[0].minor.yy294);}
-  yymsp[-5].minor.yy455 = yylhsminor.yy455;
+      case 261: /* trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt */
+{yylhsminor.yy527 = sqlite3TriggerDeleteStep(pParse, &yymsp[-3].minor.yy0, yymsp[-1].minor.yy46, yymsp[-5].minor.yy0.z, yymsp[0].minor.yy8);}
+  yymsp[-5].minor.yy527 = yylhsminor.yy527;
         break;
-      case 258: /* trigger_cmd ::= scanpt select scanpt */
-{yylhsminor.yy455 = sqlite3TriggerSelectStep(pParse->db, yymsp[-1].minor.yy457, yymsp[-2].minor.yy294, yymsp[0].minor.yy294); /*yylhsminor.yy455-overwrites-yymsp[-1].minor.yy457*/}
-  yymsp[-2].minor.yy455 = yylhsminor.yy455;
+      case 262: /* trigger_cmd ::= scanpt select scanpt */
+{yylhsminor.yy527 = sqlite3TriggerSelectStep(pParse->db, yymsp[-1].minor.yy25, yymsp[-2].minor.yy8, yymsp[0].minor.yy8); /*yylhsminor.yy527-overwrites-yymsp[-1].minor.yy25*/}
+  yymsp[-2].minor.yy527 = yylhsminor.yy527;
         break;
-      case 259: /* expr ::= RAISE LP IGNORE RP */
+      case 263: /* expr ::= RAISE LP IGNORE RP */
 {
-  yymsp[-3].minor.yy524 = sqlite3PExpr(pParse, TK_RAISE, 0, 0);
-  if( yymsp[-3].minor.yy524 ){
-    yymsp[-3].minor.yy524->affinity = OE_Ignore;
+  yymsp[-3].minor.yy46 = sqlite3PExpr(pParse, TK_RAISE, 0, 0);
+  if( yymsp[-3].minor.yy46 ){
+    yymsp[-3].minor.yy46->affExpr = OE_Ignore;
   }
 }
         break;
-      case 260: /* expr ::= RAISE LP raisetype COMMA nm RP */
+      case 264: /* expr ::= RAISE LP raisetype COMMA nm RP */
 {
-  yymsp[-5].minor.yy524 = sqlite3ExprAlloc(pParse->db, TK_RAISE, &yymsp[-1].minor.yy0, 1);
-  if( yymsp[-5].minor.yy524 ) {
-    yymsp[-5].minor.yy524->affinity = (char)yymsp[-3].minor.yy494;
+  yymsp[-5].minor.yy46 = sqlite3ExprAlloc(pParse->db, TK_RAISE, &yymsp[-1].minor.yy0, 1);
+  if( yymsp[-5].minor.yy46 ) {
+    yymsp[-5].minor.yy46->affExpr = (char)yymsp[-3].minor.yy32;
   }
 }
         break;
-      case 261: /* raisetype ::= ROLLBACK */
-{yymsp[0].minor.yy494 = OE_Rollback;}
+      case 265: /* raisetype ::= ROLLBACK */
+{yymsp[0].minor.yy32 = OE_Rollback;}
         break;
-      case 263: /* raisetype ::= FAIL */
-{yymsp[0].minor.yy494 = OE_Fail;}
+      case 267: /* raisetype ::= FAIL */
+{yymsp[0].minor.yy32 = OE_Fail;}
         break;
-      case 264: /* cmd ::= DROP TRIGGER ifexists fullname */
+      case 268: /* cmd ::= DROP TRIGGER ifexists fullname */
 {
-  sqlite3DropTrigger(pParse,yymsp[0].minor.yy483,yymsp[-1].minor.yy494);
+  sqlite3DropTrigger(pParse,yymsp[0].minor.yy609,yymsp[-1].minor.yy32);
 }
         break;
-      case 265: /* cmd ::= ATTACH database_kw_opt expr AS expr key_opt */
+      case 269: /* cmd ::= ATTACH database_kw_opt expr AS expr key_opt */
 {
-  sqlite3Attach(pParse, yymsp[-3].minor.yy524, yymsp[-1].minor.yy524, yymsp[0].minor.yy524);
+  sqlite3Attach(pParse, yymsp[-3].minor.yy46, yymsp[-1].minor.yy46, yymsp[0].minor.yy46);
 }
         break;
-      case 266: /* cmd ::= DETACH database_kw_opt expr */
+      case 270: /* cmd ::= DETACH database_kw_opt expr */
 {
-  sqlite3Detach(pParse, yymsp[0].minor.yy524);
+  sqlite3Detach(pParse, yymsp[0].minor.yy46);
 }
         break;
-      case 269: /* cmd ::= REINDEX */
+      case 273: /* cmd ::= REINDEX */
 {sqlite3Reindex(pParse, 0, 0);}
         break;
-      case 270: /* cmd ::= REINDEX nm dbnm */
+      case 274: /* cmd ::= REINDEX nm dbnm */
 {sqlite3Reindex(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}
         break;
-      case 271: /* cmd ::= ANALYZE */
+      case 275: /* cmd ::= ANALYZE */
 {sqlite3Analyze(pParse, 0, 0);}
         break;
-      case 272: /* cmd ::= ANALYZE nm dbnm */
+      case 276: /* cmd ::= ANALYZE nm dbnm */
 {sqlite3Analyze(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}
         break;
-      case 273: /* cmd ::= ALTER TABLE fullname RENAME TO nm */
+      case 277: /* cmd ::= ALTER TABLE fullname RENAME TO nm */
 {
-  sqlite3AlterRenameTable(pParse,yymsp[-3].minor.yy483,&yymsp[0].minor.yy0);
+  sqlite3AlterRenameTable(pParse,yymsp[-3].minor.yy609,&yymsp[0].minor.yy0);
 }
         break;
-      case 274: /* cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist */
+      case 278: /* cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist */
 {
   yymsp[-1].minor.yy0.n = (int)(pParse->sLastToken.z-yymsp[-1].minor.yy0.z) + pParse->sLastToken.n;
   sqlite3AlterFinishAddColumn(pParse, &yymsp[-1].minor.yy0);
 }
         break;
-      case 275: /* add_column_fullname ::= fullname */
+      case 279: /* add_column_fullname ::= fullname */
 {
   disableLookaside(pParse);
-  sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy483);
+  sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy609);
 }
         break;
-      case 276: /* cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm */
+      case 280: /* cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm */
 {
-  sqlite3AlterRenameColumn(pParse, yymsp[-5].minor.yy483, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);
+  sqlite3AlterRenameColumn(pParse, yymsp[-5].minor.yy609, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);
 }
         break;
-      case 277: /* cmd ::= create_vtab */
+      case 281: /* cmd ::= create_vtab */
 {sqlite3VtabFinishParse(pParse,0);}
         break;
-      case 278: /* cmd ::= create_vtab LP vtabarglist RP */
+      case 282: /* cmd ::= create_vtab LP vtabarglist RP */
 {sqlite3VtabFinishParse(pParse,&yymsp[0].minor.yy0);}
         break;
-      case 279: /* create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm */
+      case 283: /* create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm */
 {
-    sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy494);
+    sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy32);
 }
         break;
-      case 280: /* vtabarg ::= */
+      case 284: /* vtabarg ::= */
 {sqlite3VtabArgInit(pParse);}
         break;
-      case 281: /* vtabargtoken ::= ANY */
-      case 282: /* vtabargtoken ::= lp anylist RP */ yytestcase(yyruleno==282);
-      case 283: /* lp ::= LP */ yytestcase(yyruleno==283);
+      case 285: /* vtabargtoken ::= ANY */
+      case 286: /* vtabargtoken ::= lp anylist RP */ yytestcase(yyruleno==286);
+      case 287: /* lp ::= LP */ yytestcase(yyruleno==287);
 {sqlite3VtabArgExtend(pParse,&yymsp[0].minor.yy0);}
         break;
-      case 284: /* with ::= WITH wqlist */
-      case 285: /* with ::= WITH RECURSIVE wqlist */ yytestcase(yyruleno==285);
-{ sqlite3WithPush(pParse, yymsp[0].minor.yy59, 1); }
+      case 288: /* with ::= WITH wqlist */
+      case 289: /* with ::= WITH RECURSIVE wqlist */ yytestcase(yyruleno==289);
+{ sqlite3WithPush(pParse, yymsp[0].minor.yy297, 1); }
         break;
-      case 286: /* wqlist ::= nm eidlist_opt AS LP select RP */
+      case 290: /* wqlist ::= nm eidlist_opt AS LP select RP */
 {
-  yymsp[-5].minor.yy59 = sqlite3WithAdd(pParse, 0, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy434, yymsp[-1].minor.yy457); /*A-overwrites-X*/
+  yymsp[-5].minor.yy297 = sqlite3WithAdd(pParse, 0, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy138, yymsp[-1].minor.yy25); /*A-overwrites-X*/
 }
         break;
-      case 287: /* wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP */
+      case 291: /* wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP */
 {
-  yymsp[-7].minor.yy59 = sqlite3WithAdd(pParse, yymsp[-7].minor.yy59, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy434, yymsp[-1].minor.yy457);
+  yymsp[-7].minor.yy297 = sqlite3WithAdd(pParse, yymsp[-7].minor.yy297, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy138, yymsp[-1].minor.yy25);
 }
         break;
-      case 288: /* windowdefn_list ::= windowdefn */
-{ yylhsminor.yy295 = yymsp[0].minor.yy295; }
-  yymsp[0].minor.yy295 = yylhsminor.yy295;
+      case 292: /* windowdefn_list ::= windowdefn */
+{ yylhsminor.yy455 = yymsp[0].minor.yy455; }
+  yymsp[0].minor.yy455 = yylhsminor.yy455;
         break;
-      case 289: /* windowdefn_list ::= windowdefn_list COMMA windowdefn */
+      case 293: /* windowdefn_list ::= windowdefn_list COMMA windowdefn */
 {
-  assert( yymsp[0].minor.yy295!=0 );
-  sqlite3WindowChain(pParse, yymsp[0].minor.yy295, yymsp[-2].minor.yy295);
-  yymsp[0].minor.yy295->pNextWin = yymsp[-2].minor.yy295;
-  yylhsminor.yy295 = yymsp[0].minor.yy295;
+  assert( yymsp[0].minor.yy455!=0 );
+  sqlite3WindowChain(pParse, yymsp[0].minor.yy455, yymsp[-2].minor.yy455);
+  yymsp[0].minor.yy455->pNextWin = yymsp[-2].minor.yy455;
+  yylhsminor.yy455 = yymsp[0].minor.yy455;
 }
-  yymsp[-2].minor.yy295 = yylhsminor.yy295;
+  yymsp[-2].minor.yy455 = yylhsminor.yy455;
         break;
-      case 290: /* windowdefn ::= nm AS LP window RP */
+      case 294: /* windowdefn ::= nm AS LP window RP */
 {
-  if( ALWAYS(yymsp[-1].minor.yy295) ){
-    yymsp[-1].minor.yy295->zName = sqlite3DbStrNDup(pParse->db, yymsp[-4].minor.yy0.z, yymsp[-4].minor.yy0.n);
+  if( ALWAYS(yymsp[-1].minor.yy455) ){
+    yymsp[-1].minor.yy455->zName = sqlite3DbStrNDup(pParse->db, yymsp[-4].minor.yy0.z, yymsp[-4].minor.yy0.n);
   }
-  yylhsminor.yy295 = yymsp[-1].minor.yy295;
+  yylhsminor.yy455 = yymsp[-1].minor.yy455;
 }
-  yymsp[-4].minor.yy295 = yylhsminor.yy295;
+  yymsp[-4].minor.yy455 = yylhsminor.yy455;
         break;
-      case 291: /* window ::= PARTITION BY nexprlist orderby_opt frame_opt */
+      case 295: /* window ::= PARTITION BY nexprlist orderby_opt frame_opt */
 {
-  yymsp[-4].minor.yy295 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy295, yymsp[-2].minor.yy434, yymsp[-1].minor.yy434, 0);
+  yymsp[-4].minor.yy455 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy455, yymsp[-2].minor.yy138, yymsp[-1].minor.yy138, 0);
 }
         break;
-      case 292: /* window ::= nm PARTITION BY nexprlist orderby_opt frame_opt */
+      case 296: /* window ::= nm PARTITION BY nexprlist orderby_opt frame_opt */
 {
-  yylhsminor.yy295 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy295, yymsp[-2].minor.yy434, yymsp[-1].minor.yy434, &yymsp[-5].minor.yy0);
+  yylhsminor.yy455 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy455, yymsp[-2].minor.yy138, yymsp[-1].minor.yy138, &yymsp[-5].minor.yy0);
 }
-  yymsp[-5].minor.yy295 = yylhsminor.yy295;
+  yymsp[-5].minor.yy455 = yylhsminor.yy455;
         break;
-      case 293: /* window ::= ORDER BY sortlist frame_opt */
+      case 297: /* window ::= ORDER BY sortlist frame_opt */
 {
-  yymsp[-3].minor.yy295 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy295, 0, yymsp[-1].minor.yy434, 0);
+  yymsp[-3].minor.yy455 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy455, 0, yymsp[-1].minor.yy138, 0);
 }
         break;
-      case 294: /* window ::= nm ORDER BY sortlist frame_opt */
+      case 298: /* window ::= nm ORDER BY sortlist frame_opt */
 {
-  yylhsminor.yy295 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy295, 0, yymsp[-1].minor.yy434, &yymsp[-4].minor.yy0);
+  yylhsminor.yy455 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy455, 0, yymsp[-1].minor.yy138, &yymsp[-4].minor.yy0);
 }
-  yymsp[-4].minor.yy295 = yylhsminor.yy295;
+  yymsp[-4].minor.yy455 = yylhsminor.yy455;
         break;
-      case 295: /* window ::= frame_opt */
+      case 299: /* window ::= frame_opt */
+      case 318: /* filter_over ::= over_clause */ yytestcase(yyruleno==318);
 {
-  yylhsminor.yy295 = yymsp[0].minor.yy295;
+  yylhsminor.yy455 = yymsp[0].minor.yy455;
 }
-  yymsp[0].minor.yy295 = yylhsminor.yy295;
+  yymsp[0].minor.yy455 = yylhsminor.yy455;
         break;
-      case 296: /* window ::= nm frame_opt */
+      case 300: /* window ::= nm frame_opt */
 {
-  yylhsminor.yy295 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy295, 0, 0, &yymsp[-1].minor.yy0);
+  yylhsminor.yy455 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy455, 0, 0, &yymsp[-1].minor.yy0);
 }
-  yymsp[-1].minor.yy295 = yylhsminor.yy295;
+  yymsp[-1].minor.yy455 = yylhsminor.yy455;
         break;
-      case 297: /* frame_opt ::= */
+      case 301: /* frame_opt ::= */
 {
-  yymsp[1].minor.yy295 = sqlite3WindowAlloc(pParse, 0, TK_UNBOUNDED, 0, TK_CURRENT, 0, 0);
+  yymsp[1].minor.yy455 = sqlite3WindowAlloc(pParse, 0, TK_UNBOUNDED, 0, TK_CURRENT, 0, 0);
 }
         break;
-      case 298: /* frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt */
+      case 302: /* frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt */
 {
-  yylhsminor.yy295 = sqlite3WindowAlloc(pParse, yymsp[-2].minor.yy494, yymsp[-1].minor.yy201.eType, yymsp[-1].minor.yy201.pExpr, TK_CURRENT, 0, yymsp[0].minor.yy238);
+  yylhsminor.yy455 = sqlite3WindowAlloc(pParse, yymsp[-2].minor.yy32, yymsp[-1].minor.yy57.eType, yymsp[-1].minor.yy57.pExpr, TK_CURRENT, 0, yymsp[0].minor.yy118);
 }
-  yymsp[-2].minor.yy295 = yylhsminor.yy295;
+  yymsp[-2].minor.yy455 = yylhsminor.yy455;
         break;
-      case 299: /* frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt */
+      case 303: /* frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt */
 {
-  yylhsminor.yy295 = sqlite3WindowAlloc(pParse, yymsp[-5].minor.yy494, yymsp[-3].minor.yy201.eType, yymsp[-3].minor.yy201.pExpr, yymsp[-1].minor.yy201.eType, yymsp[-1].minor.yy201.pExpr, yymsp[0].minor.yy238);
+  yylhsminor.yy455 = sqlite3WindowAlloc(pParse, yymsp[-5].minor.yy32, yymsp[-3].minor.yy57.eType, yymsp[-3].minor.yy57.pExpr, yymsp[-1].minor.yy57.eType, yymsp[-1].minor.yy57.pExpr, yymsp[0].minor.yy118);
 }
-  yymsp[-5].minor.yy295 = yylhsminor.yy295;
+  yymsp[-5].minor.yy455 = yylhsminor.yy455;
         break;
-      case 301: /* frame_bound_s ::= frame_bound */
-      case 303: /* frame_bound_e ::= frame_bound */ yytestcase(yyruleno==303);
-{yylhsminor.yy201 = yymsp[0].minor.yy201;}
-  yymsp[0].minor.yy201 = yylhsminor.yy201;
+      case 305: /* frame_bound_s ::= frame_bound */
+      case 307: /* frame_bound_e ::= frame_bound */ yytestcase(yyruleno==307);
+{yylhsminor.yy57 = yymsp[0].minor.yy57;}
+  yymsp[0].minor.yy57 = yylhsminor.yy57;
         break;
-      case 302: /* frame_bound_s ::= UNBOUNDED PRECEDING */
-      case 304: /* frame_bound_e ::= UNBOUNDED FOLLOWING */ yytestcase(yyruleno==304);
-      case 306: /* frame_bound ::= CURRENT ROW */ yytestcase(yyruleno==306);
-{yylhsminor.yy201.eType = yymsp[-1].major; yylhsminor.yy201.pExpr = 0;}
-  yymsp[-1].minor.yy201 = yylhsminor.yy201;
+      case 306: /* frame_bound_s ::= UNBOUNDED PRECEDING */
+      case 308: /* frame_bound_e ::= UNBOUNDED FOLLOWING */ yytestcase(yyruleno==308);
+      case 310: /* frame_bound ::= CURRENT ROW */ yytestcase(yyruleno==310);
+{yylhsminor.yy57.eType = yymsp[-1].major; yylhsminor.yy57.pExpr = 0;}
+  yymsp[-1].minor.yy57 = yylhsminor.yy57;
         break;
-      case 305: /* frame_bound ::= expr PRECEDING|FOLLOWING */
-{yylhsminor.yy201.eType = yymsp[0].major; yylhsminor.yy201.pExpr = yymsp[-1].minor.yy524;}
-  yymsp[-1].minor.yy201 = yylhsminor.yy201;
+      case 309: /* frame_bound ::= expr PRECEDING|FOLLOWING */
+{yylhsminor.yy57.eType = yymsp[0].major; yylhsminor.yy57.pExpr = yymsp[-1].minor.yy46;}
+  yymsp[-1].minor.yy57 = yylhsminor.yy57;
         break;
-      case 307: /* frame_exclude_opt ::= */
-{yymsp[1].minor.yy238 = 0;}
+      case 311: /* frame_exclude_opt ::= */
+{yymsp[1].minor.yy118 = 0;}
         break;
-      case 308: /* frame_exclude_opt ::= EXCLUDE frame_exclude */
-{yymsp[-1].minor.yy238 = yymsp[0].minor.yy238;}
+      case 312: /* frame_exclude_opt ::= EXCLUDE frame_exclude */
+{yymsp[-1].minor.yy118 = yymsp[0].minor.yy118;}
         break;
-      case 309: /* frame_exclude ::= NO OTHERS */
-      case 310: /* frame_exclude ::= CURRENT ROW */ yytestcase(yyruleno==310);
-{yymsp[-1].minor.yy238 = yymsp[-1].major; /*A-overwrites-X*/}
+      case 313: /* frame_exclude ::= NO OTHERS */
+      case 314: /* frame_exclude ::= CURRENT ROW */ yytestcase(yyruleno==314);
+{yymsp[-1].minor.yy118 = yymsp[-1].major; /*A-overwrites-X*/}
         break;
-      case 311: /* frame_exclude ::= GROUP|TIES */
-{yymsp[0].minor.yy238 = yymsp[0].major; /*A-overwrites-X*/}
+      case 315: /* frame_exclude ::= GROUP|TIES */
+{yymsp[0].minor.yy118 = yymsp[0].major; /*A-overwrites-X*/}
         break;
-      case 312: /* window_clause ::= WINDOW windowdefn_list */
-{ yymsp[-1].minor.yy295 = yymsp[0].minor.yy295; }
+      case 316: /* window_clause ::= WINDOW windowdefn_list */
+{ yymsp[-1].minor.yy455 = yymsp[0].minor.yy455; }
         break;
-      case 313: /* over_clause ::= filter_opt OVER LP window RP */
+      case 317: /* filter_over ::= filter_clause over_clause */
 {
-  yylhsminor.yy295 = yymsp[-1].minor.yy295;
-  assert( yylhsminor.yy295!=0 );
-  yylhsminor.yy295->pFilter = yymsp[-4].minor.yy524;
+  yymsp[0].minor.yy455->pFilter = yymsp[-1].minor.yy46;
+  yylhsminor.yy455 = yymsp[0].minor.yy455;
 }
-  yymsp[-4].minor.yy295 = yylhsminor.yy295;
+  yymsp[-1].minor.yy455 = yylhsminor.yy455;
         break;
-      case 314: /* over_clause ::= filter_opt OVER nm */
+      case 319: /* filter_over ::= filter_clause */
 {
-  yylhsminor.yy295 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));
-  if( yylhsminor.yy295 ){
-    yylhsminor.yy295->zName = sqlite3DbStrNDup(pParse->db, yymsp[0].minor.yy0.z, yymsp[0].minor.yy0.n);
-    yylhsminor.yy295->pFilter = yymsp[-2].minor.yy524;
+  yylhsminor.yy455 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));
+  if( yylhsminor.yy455 ){
+    yylhsminor.yy455->eFrmType = TK_FILTER;
+    yylhsminor.yy455->pFilter = yymsp[0].minor.yy46;
   }else{
-    sqlite3ExprDelete(pParse->db, yymsp[-2].minor.yy524);
+    sqlite3ExprDelete(pParse->db, yymsp[0].minor.yy46);
+  }
+}
+  yymsp[0].minor.yy455 = yylhsminor.yy455;
+        break;
+      case 320: /* over_clause ::= OVER LP window RP */
+{
+  yymsp[-3].minor.yy455 = yymsp[-1].minor.yy455;
+  assert( yymsp[-3].minor.yy455!=0 );
+}
+        break;
+      case 321: /* over_clause ::= OVER nm */
+{
+  yymsp[-1].minor.yy455 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));
+  if( yymsp[-1].minor.yy455 ){
+    yymsp[-1].minor.yy455->zName = sqlite3DbStrNDup(pParse->db, yymsp[0].minor.yy0.z, yymsp[0].minor.yy0.n);
   }
 }
-  yymsp[-2].minor.yy295 = yylhsminor.yy295;
         break;
-      case 316: /* filter_opt ::= FILTER LP WHERE expr RP */
-{ yymsp[-4].minor.yy524 = yymsp[-1].minor.yy524; }
+      case 322: /* filter_clause ::= FILTER LP WHERE expr RP */
+{ yymsp[-4].minor.yy46 = yymsp[-1].minor.yy46; }
         break;
       default:
-      /* (317) input ::= cmdlist */ yytestcase(yyruleno==317);
-      /* (318) cmdlist ::= cmdlist ecmd */ yytestcase(yyruleno==318);
-      /* (319) cmdlist ::= ecmd (OPTIMIZED OUT) */ assert(yyruleno!=319);
-      /* (320) ecmd ::= SEMI */ yytestcase(yyruleno==320);
-      /* (321) ecmd ::= cmdx SEMI */ yytestcase(yyruleno==321);
-      /* (322) ecmd ::= explain cmdx */ yytestcase(yyruleno==322);
-      /* (323) trans_opt ::= */ yytestcase(yyruleno==323);
-      /* (324) trans_opt ::= TRANSACTION */ yytestcase(yyruleno==324);
-      /* (325) trans_opt ::= TRANSACTION nm */ yytestcase(yyruleno==325);
-      /* (326) savepoint_opt ::= SAVEPOINT */ yytestcase(yyruleno==326);
-      /* (327) savepoint_opt ::= */ yytestcase(yyruleno==327);
-      /* (328) cmd ::= create_table create_table_args */ yytestcase(yyruleno==328);
-      /* (329) columnlist ::= columnlist COMMA columnname carglist */ yytestcase(yyruleno==329);
-      /* (330) columnlist ::= columnname carglist */ yytestcase(yyruleno==330);
-      /* (331) nm ::= ID|INDEXED */ yytestcase(yyruleno==331);
-      /* (332) nm ::= STRING */ yytestcase(yyruleno==332);
-      /* (333) nm ::= JOIN_KW */ yytestcase(yyruleno==333);
-      /* (334) typetoken ::= typename */ yytestcase(yyruleno==334);
-      /* (335) typename ::= ID|STRING */ yytestcase(yyruleno==335);
-      /* (336) signed ::= plus_num (OPTIMIZED OUT) */ assert(yyruleno!=336);
-      /* (337) signed ::= minus_num (OPTIMIZED OUT) */ assert(yyruleno!=337);
-      /* (338) carglist ::= carglist ccons */ yytestcase(yyruleno==338);
-      /* (339) carglist ::= */ yytestcase(yyruleno==339);
-      /* (340) ccons ::= NULL onconf */ yytestcase(yyruleno==340);
-      /* (341) conslist_opt ::= COMMA conslist */ yytestcase(yyruleno==341);
-      /* (342) conslist ::= conslist tconscomma tcons */ yytestcase(yyruleno==342);
-      /* (343) conslist ::= tcons (OPTIMIZED OUT) */ assert(yyruleno!=343);
-      /* (344) tconscomma ::= */ yytestcase(yyruleno==344);
-      /* (345) defer_subclause_opt ::= defer_subclause (OPTIMIZED OUT) */ assert(yyruleno!=345);
-      /* (346) resolvetype ::= raisetype (OPTIMIZED OUT) */ assert(yyruleno!=346);
-      /* (347) selectnowith ::= oneselect (OPTIMIZED OUT) */ assert(yyruleno!=347);
-      /* (348) oneselect ::= values */ yytestcase(yyruleno==348);
-      /* (349) sclp ::= selcollist COMMA */ yytestcase(yyruleno==349);
-      /* (350) as ::= ID|STRING */ yytestcase(yyruleno==350);
-      /* (351) expr ::= term (OPTIMIZED OUT) */ assert(yyruleno!=351);
-      /* (352) likeop ::= LIKE_KW|MATCH */ yytestcase(yyruleno==352);
-      /* (353) exprlist ::= nexprlist */ yytestcase(yyruleno==353);
-      /* (354) nmnum ::= plus_num (OPTIMIZED OUT) */ assert(yyruleno!=354);
-      /* (355) nmnum ::= nm (OPTIMIZED OUT) */ assert(yyruleno!=355);
-      /* (356) nmnum ::= ON */ yytestcase(yyruleno==356);
-      /* (357) nmnum ::= DELETE */ yytestcase(yyruleno==357);
-      /* (358) nmnum ::= DEFAULT */ yytestcase(yyruleno==358);
-      /* (359) plus_num ::= INTEGER|FLOAT */ yytestcase(yyruleno==359);
-      /* (360) foreach_clause ::= */ yytestcase(yyruleno==360);
-      /* (361) foreach_clause ::= FOR EACH ROW */ yytestcase(yyruleno==361);
-      /* (362) trnm ::= nm */ yytestcase(yyruleno==362);
-      /* (363) tridxby ::= */ yytestcase(yyruleno==363);
-      /* (364) database_kw_opt ::= DATABASE */ yytestcase(yyruleno==364);
-      /* (365) database_kw_opt ::= */ yytestcase(yyruleno==365);
-      /* (366) kwcolumn_opt ::= */ yytestcase(yyruleno==366);
-      /* (367) kwcolumn_opt ::= COLUMNKW */ yytestcase(yyruleno==367);
-      /* (368) vtabarglist ::= vtabarg */ yytestcase(yyruleno==368);
-      /* (369) vtabarglist ::= vtabarglist COMMA vtabarg */ yytestcase(yyruleno==369);
-      /* (370) vtabarg ::= vtabarg vtabargtoken */ yytestcase(yyruleno==370);
-      /* (371) anylist ::= */ yytestcase(yyruleno==371);
-      /* (372) anylist ::= anylist LP anylist RP */ yytestcase(yyruleno==372);
-      /* (373) anylist ::= anylist ANY */ yytestcase(yyruleno==373);
-      /* (374) with ::= */ yytestcase(yyruleno==374);
+      /* (323) input ::= cmdlist */ yytestcase(yyruleno==323);
+      /* (324) cmdlist ::= cmdlist ecmd */ yytestcase(yyruleno==324);
+      /* (325) cmdlist ::= ecmd (OPTIMIZED OUT) */ assert(yyruleno!=325);
+      /* (326) ecmd ::= SEMI */ yytestcase(yyruleno==326);
+      /* (327) ecmd ::= cmdx SEMI */ yytestcase(yyruleno==327);
+      /* (328) ecmd ::= explain cmdx */ yytestcase(yyruleno==328);
+      /* (329) trans_opt ::= */ yytestcase(yyruleno==329);
+      /* (330) trans_opt ::= TRANSACTION */ yytestcase(yyruleno==330);
+      /* (331) trans_opt ::= TRANSACTION nm */ yytestcase(yyruleno==331);
+      /* (332) savepoint_opt ::= SAVEPOINT */ yytestcase(yyruleno==332);
+      /* (333) savepoint_opt ::= */ yytestcase(yyruleno==333);
+      /* (334) cmd ::= create_table create_table_args */ yytestcase(yyruleno==334);
+      /* (335) columnlist ::= columnlist COMMA columnname carglist */ yytestcase(yyruleno==335);
+      /* (336) columnlist ::= columnname carglist */ yytestcase(yyruleno==336);
+      /* (337) nm ::= ID|INDEXED */ yytestcase(yyruleno==337);
+      /* (338) nm ::= STRING */ yytestcase(yyruleno==338);
+      /* (339) nm ::= JOIN_KW */ yytestcase(yyruleno==339);
+      /* (340) typetoken ::= typename */ yytestcase(yyruleno==340);
+      /* (341) typename ::= ID|STRING */ yytestcase(yyruleno==341);
+      /* (342) signed ::= plus_num (OPTIMIZED OUT) */ assert(yyruleno!=342);
+      /* (343) signed ::= minus_num (OPTIMIZED OUT) */ assert(yyruleno!=343);
+      /* (344) carglist ::= carglist ccons */ yytestcase(yyruleno==344);
+      /* (345) carglist ::= */ yytestcase(yyruleno==345);
+      /* (346) ccons ::= NULL onconf */ yytestcase(yyruleno==346);
+      /* (347) conslist_opt ::= COMMA conslist */ yytestcase(yyruleno==347);
+      /* (348) conslist ::= conslist tconscomma tcons */ yytestcase(yyruleno==348);
+      /* (349) conslist ::= tcons (OPTIMIZED OUT) */ assert(yyruleno!=349);
+      /* (350) tconscomma ::= */ yytestcase(yyruleno==350);
+      /* (351) defer_subclause_opt ::= defer_subclause (OPTIMIZED OUT) */ assert(yyruleno!=351);
+      /* (352) resolvetype ::= raisetype (OPTIMIZED OUT) */ assert(yyruleno!=352);
+      /* (353) selectnowith ::= oneselect (OPTIMIZED OUT) */ assert(yyruleno!=353);
+      /* (354) oneselect ::= values */ yytestcase(yyruleno==354);
+      /* (355) sclp ::= selcollist COMMA */ yytestcase(yyruleno==355);
+      /* (356) as ::= ID|STRING */ yytestcase(yyruleno==356);
+      /* (357) expr ::= term (OPTIMIZED OUT) */ assert(yyruleno!=357);
+      /* (358) likeop ::= LIKE_KW|MATCH */ yytestcase(yyruleno==358);
+      /* (359) exprlist ::= nexprlist */ yytestcase(yyruleno==359);
+      /* (360) nmnum ::= plus_num (OPTIMIZED OUT) */ assert(yyruleno!=360);
+      /* (361) nmnum ::= nm (OPTIMIZED OUT) */ assert(yyruleno!=361);
+      /* (362) nmnum ::= ON */ yytestcase(yyruleno==362);
+      /* (363) nmnum ::= DELETE */ yytestcase(yyruleno==363);
+      /* (364) nmnum ::= DEFAULT */ yytestcase(yyruleno==364);
+      /* (365) plus_num ::= INTEGER|FLOAT */ yytestcase(yyruleno==365);
+      /* (366) foreach_clause ::= */ yytestcase(yyruleno==366);
+      /* (367) foreach_clause ::= FOR EACH ROW */ yytestcase(yyruleno==367);
+      /* (368) trnm ::= nm */ yytestcase(yyruleno==368);
+      /* (369) tridxby ::= */ yytestcase(yyruleno==369);
+      /* (370) database_kw_opt ::= DATABASE */ yytestcase(yyruleno==370);
+      /* (371) database_kw_opt ::= */ yytestcase(yyruleno==371);
+      /* (372) kwcolumn_opt ::= */ yytestcase(yyruleno==372);
+      /* (373) kwcolumn_opt ::= COLUMNKW */ yytestcase(yyruleno==373);
+      /* (374) vtabarglist ::= vtabarg */ yytestcase(yyruleno==374);
+      /* (375) vtabarglist ::= vtabarglist COMMA vtabarg */ yytestcase(yyruleno==375);
+      /* (376) vtabarg ::= vtabarg vtabargtoken */ yytestcase(yyruleno==376);
+      /* (377) anylist ::= */ yytestcase(yyruleno==377);
+      /* (378) anylist ::= anylist LP anylist RP */ yytestcase(yyruleno==378);
+      /* (379) anylist ::= anylist ANY */ yytestcase(yyruleno==379);
+      /* (380) with ::= */ yytestcase(yyruleno==380);
         break;
 /********** End reduce actions ************************************************/
   };
   assert( yyruleno<sizeof(yyRuleInfoLhs)/sizeof(yyRuleInfoLhs[0]) );
   yygoto = yyRuleInfoLhs[yyruleno];
@@ -153008,13 +154627,12 @@
 ** Return the fallback token corresponding to canonical token iToken, or
 ** 0 if iToken has no fallback.
 */
 SQLITE_PRIVATE int sqlite3ParserFallback(int iToken){
 #ifdef YYFALLBACK
-  if( iToken<(int)(sizeof(yyFallback)/sizeof(yyFallback[0])) ){
-    return yyFallback[iToken];
-  }
+  assert( iToken<(int)(sizeof(yyFallback)/sizeof(yyFallback[0])) );
+  return yyFallback[iToken];
 #else
   (void)iToken;
 #endif
   return 0;
 }
@@ -153179,148 +154797,150 @@
 ** might be implemented more directly using a hand-written hash table.
 ** But by using this automatically generated code, the size of the code
 ** is substantially reduced.  This is important for embedded applications
 ** on platforms with limited memory.
 */
-/* Hash score: 214 */
-/* zKWText[] encodes 950 bytes of keyword text in 629 bytes */
+/* Hash score: 221 */
+/* zKWText[] encodes 967 bytes of keyword text in 638 bytes */
 /*   REINDEXEDESCAPEACHECKEYBEFOREIGNOREGEXPLAINSTEADDATABASELECT       */
-/*   ABLEFTHENDEFERRABLELSEXCLUDELETEMPORARYCONSTRAINTERSECTIES         */
-/*   AVEPOINTOFFSETRANSACTIONATURALTERAISEXCEPTRIGGEREFERENCES          */
-/*   UNIQUERYWITHOUTERELEASEXCLUSIVEXISTSATTACHAVINGLOBEGINNERANGE      */
-/*   BETWEENOTHINGROUPSCASCADETACHCASECOLLATECREATECURRENT_DATE         */
-/*   IMMEDIATEJOINSERTLIKEMATCHPLANALYZEPRAGMABORTUPDATEVALUES          */
-/*   VIRTUALIMITWHENOTNULLWHERECURSIVEAFTERENAMEANDEFAULT               */
+/*   ABLEFTHENDEFERRABLELSEXCLUDELETEMPORARYISNULLSAVEPOINTERSECT       */
+/*   IESNOTNULLIKEXCEPTRANSACTIONATURALTERAISEXCLUSIVEXISTS             */
+/*   CONSTRAINTOFFSETRIGGEREFERENCESUNIQUERYWITHOUTERELEASEATTACH       */
+/*   AVINGLOBEGINNERANGEBETWEENOTHINGROUPSCASCADETACHCASECOLLATE        */
+/*   CREATECURRENT_DATEIMMEDIATEJOINSERTMATCHPLANALYZEPRAGMABORT        */
+/*   UPDATEVALUESVIRTUALASTWHENWHERECURSIVEAFTERENAMEANDEFAULT          */
 /*   AUTOINCREMENTCASTCOLUMNCOMMITCONFLICTCROSSCURRENT_TIMESTAMP        */
-/*   ARTITIONDEFERREDISTINCTDROPRECEDINGFAILFILTEREPLACEFOLLOWING       */
-/*   FROMFULLIFISNULLORDERESTRICTOTHERSOVERIGHTROLLBACKROWS             */
+/*   ARTITIONDEFERREDISTINCTDROPRECEDINGFAILIMITFILTEREPLACEFIRST       */
+/*   FOLLOWINGFROMFULLIFORDERESTRICTOTHERSOVERIGHTROLLBACKROWS          */
 /*   UNBOUNDEDUNIONUSINGVACUUMVIEWINDOWBYINITIALLYPRIMARY               */
-static const char zKWText[628] = {
+static const char zKWText[637] = {
   'R','E','I','N','D','E','X','E','D','E','S','C','A','P','E','A','C','H',
   'E','C','K','E','Y','B','E','F','O','R','E','I','G','N','O','R','E','G',
   'E','X','P','L','A','I','N','S','T','E','A','D','D','A','T','A','B','A',
   'S','E','L','E','C','T','A','B','L','E','F','T','H','E','N','D','E','F',
   'E','R','R','A','B','L','E','L','S','E','X','C','L','U','D','E','L','E',
-  'T','E','M','P','O','R','A','R','Y','C','O','N','S','T','R','A','I','N',
-  'T','E','R','S','E','C','T','I','E','S','A','V','E','P','O','I','N','T',
-  'O','F','F','S','E','T','R','A','N','S','A','C','T','I','O','N','A','T',
-  'U','R','A','L','T','E','R','A','I','S','E','X','C','E','P','T','R','I',
-  'G','G','E','R','E','F','E','R','E','N','C','E','S','U','N','I','Q','U',
-  'E','R','Y','W','I','T','H','O','U','T','E','R','E','L','E','A','S','E',
-  'X','C','L','U','S','I','V','E','X','I','S','T','S','A','T','T','A','C',
-  'H','A','V','I','N','G','L','O','B','E','G','I','N','N','E','R','A','N',
-  'G','E','B','E','T','W','E','E','N','O','T','H','I','N','G','R','O','U',
-  'P','S','C','A','S','C','A','D','E','T','A','C','H','C','A','S','E','C',
-  'O','L','L','A','T','E','C','R','E','A','T','E','C','U','R','R','E','N',
-  'T','_','D','A','T','E','I','M','M','E','D','I','A','T','E','J','O','I',
-  'N','S','E','R','T','L','I','K','E','M','A','T','C','H','P','L','A','N',
-  'A','L','Y','Z','E','P','R','A','G','M','A','B','O','R','T','U','P','D',
-  'A','T','E','V','A','L','U','E','S','V','I','R','T','U','A','L','I','M',
-  'I','T','W','H','E','N','O','T','N','U','L','L','W','H','E','R','E','C',
-  'U','R','S','I','V','E','A','F','T','E','R','E','N','A','M','E','A','N',
-  'D','E','F','A','U','L','T','A','U','T','O','I','N','C','R','E','M','E',
-  'N','T','C','A','S','T','C','O','L','U','M','N','C','O','M','M','I','T',
-  'C','O','N','F','L','I','C','T','C','R','O','S','S','C','U','R','R','E',
-  'N','T','_','T','I','M','E','S','T','A','M','P','A','R','T','I','T','I',
-  'O','N','D','E','F','E','R','R','E','D','I','S','T','I','N','C','T','D',
-  'R','O','P','R','E','C','E','D','I','N','G','F','A','I','L','F','I','L',
-  'T','E','R','E','P','L','A','C','E','F','O','L','L','O','W','I','N','G',
-  'F','R','O','M','F','U','L','L','I','F','I','S','N','U','L','L','O','R',
-  'D','E','R','E','S','T','R','I','C','T','O','T','H','E','R','S','O','V',
-  'E','R','I','G','H','T','R','O','L','L','B','A','C','K','R','O','W','S',
-  'U','N','B','O','U','N','D','E','D','U','N','I','O','N','U','S','I','N',
-  'G','V','A','C','U','U','M','V','I','E','W','I','N','D','O','W','B','Y',
-  'I','N','I','T','I','A','L','L','Y','P','R','I','M','A','R','Y',
+  'T','E','M','P','O','R','A','R','Y','I','S','N','U','L','L','S','A','V',
+  'E','P','O','I','N','T','E','R','S','E','C','T','I','E','S','N','O','T',
+  'N','U','L','L','I','K','E','X','C','E','P','T','R','A','N','S','A','C',
+  'T','I','O','N','A','T','U','R','A','L','T','E','R','A','I','S','E','X',
+  'C','L','U','S','I','V','E','X','I','S','T','S','C','O','N','S','T','R',
+  'A','I','N','T','O','F','F','S','E','T','R','I','G','G','E','R','E','F',
+  'E','R','E','N','C','E','S','U','N','I','Q','U','E','R','Y','W','I','T',
+  'H','O','U','T','E','R','E','L','E','A','S','E','A','T','T','A','C','H',
+  'A','V','I','N','G','L','O','B','E','G','I','N','N','E','R','A','N','G',
+  'E','B','E','T','W','E','E','N','O','T','H','I','N','G','R','O','U','P',
+  'S','C','A','S','C','A','D','E','T','A','C','H','C','A','S','E','C','O',
+  'L','L','A','T','E','C','R','E','A','T','E','C','U','R','R','E','N','T',
+  '_','D','A','T','E','I','M','M','E','D','I','A','T','E','J','O','I','N',
+  'S','E','R','T','M','A','T','C','H','P','L','A','N','A','L','Y','Z','E',
+  'P','R','A','G','M','A','B','O','R','T','U','P','D','A','T','E','V','A',
+  'L','U','E','S','V','I','R','T','U','A','L','A','S','T','W','H','E','N',
+  'W','H','E','R','E','C','U','R','S','I','V','E','A','F','T','E','R','E',
+  'N','A','M','E','A','N','D','E','F','A','U','L','T','A','U','T','O','I',
+  'N','C','R','E','M','E','N','T','C','A','S','T','C','O','L','U','M','N',
+  'C','O','M','M','I','T','C','O','N','F','L','I','C','T','C','R','O','S',
+  'S','C','U','R','R','E','N','T','_','T','I','M','E','S','T','A','M','P',
+  'A','R','T','I','T','I','O','N','D','E','F','E','R','R','E','D','I','S',
+  'T','I','N','C','T','D','R','O','P','R','E','C','E','D','I','N','G','F',
+  'A','I','L','I','M','I','T','F','I','L','T','E','R','E','P','L','A','C',
+  'E','F','I','R','S','T','F','O','L','L','O','W','I','N','G','F','R','O',
+  'M','F','U','L','L','I','F','O','R','D','E','R','E','S','T','R','I','C',
+  'T','O','T','H','E','R','S','O','V','E','R','I','G','H','T','R','O','L',
+  'L','B','A','C','K','R','O','W','S','U','N','B','O','U','N','D','E','D',
+  'U','N','I','O','N','U','S','I','N','G','V','A','C','U','U','M','V','I',
+  'E','W','I','N','D','O','W','B','Y','I','N','I','T','I','A','L','L','Y',
+  'P','R','I','M','A','R','Y',
 };
 /* aKWHash[i] is the hash value for the i-th keyword */
 static const unsigned char aKWHash[127] = {
-    75, 111, 127,  73, 108,  29,   0,   0,  83,   0,  77,  63,   0,
-    37,  33,  78,  15,   0, 126,  86,  57, 120, 128,  19,   0,   0,
-   133,   0, 131, 123,   0,  22,  98,   0,   9,   0,   0, 117,  71,
-     0,  69,   6,   0,  49,  95, 140,   0, 129, 106,   0,   0,  54,
-     0, 109,  24,   0,  17,   0, 134,  56,  23,  26,   5,  58, 135,
-   101,   0,   0, 139, 112,  62, 138,  59, 115,  65,   0,  96,   0,
-   105,  45,   0, 104,   0,   0,   0, 100,  97, 102, 107, 119,  14,
-    31, 118,   0,  81,   0, 136, 116, 137,  61, 124, 132,  80, 121,
-    88,  30,  85,   0,   0,  99,  35, 125, 122,   0, 130,   0,   0,
-    41,   0,  91,  89,  90,   0,  20,  87, 113,  82,
+    82, 113, 130,  80, 110,  29,   0,   0,  89,   0,  83,  70,   0,
+    53,  35,  84,  15,   0, 129,  92,  64, 124, 131,  19,   0,   0,
+   136,   0, 134, 126,   0,  22, 100,   0,   9,   0,   0, 121,  78,
+     0,  76,   6,   0,  58,  97, 143,   0, 132, 108,   0,   0,  48,
+     0, 111,  24,   0,  17,   0, 137,  63,  23,  26,   5,  65, 138,
+   103, 120,   0, 142, 114,  69, 141,  66, 118,  72,   0,  98,   0,
+   107,  41,   0, 106,   0,   0,   0, 102,  99, 104, 109, 123,  14,
+    50, 122,   0,  87,   0, 139, 119, 140,  68, 127, 135,  86,  81,
+    37,  91, 117,   0,   0, 101,  51, 128, 125,   0, 133,   0,   0,
+    44,   0,  93,  67,  39,   0,  20,  45, 115,  88,
 };
 /* aKWNext[] forms the hash collision chain.  If aKWHash[i]==0
 ** then the i-th keyword has no more hash collisions.  Otherwise,
 ** the next keyword with the same hash is aKWHash[i]-1. */
-static const unsigned char aKWNext[140] = {
+static const unsigned char aKWNext[143] = {
      0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   2,   0,   0,   0,   0,   0,   0,  13,   0,   0,   0,   0,
-     0,   0,   0,  21,   0,   0,  12,   0,   0,   0,   0,   0,   0,
-     7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
-    51,  28,   0,   0,  38,   0,   0,   0,  44,   0,   0,   0,   3,
-     0,   0,  67,   1,  66,   0,   0,   0,  36,   0,  47,   0,   0,
-     0,   0,   0,  48,  50,  76,   0,   0,  42,   0,  60,   0,   0,
-     0,  43,   0,  16,  55,  10,   0,   0,   0,   0,   0,   0,   0,
-    11,  72,  93,   0,   0,   8,   0, 110,   0, 103,  40,  53,  70,
-     0, 114,   0,  74,  52,   0,   0,  92,  39,  46,   0,  68,  32,
-    84,   0,  34,  27,  25,  18,  94,   0,  64,  79,
+     0,   0,   0,  21,   0,   0,   0,   0,  12,   0,   0,   0,   0,
+     0,   0,   0,   7,   0,  36,   0,   0,  28,   0,   0,   0,  31,
+     0,   0,   0,  40,   0,   0,   0,   0,   0,  60,   0,  54,   0,
+     0,  38,  47,   0,   0,   0,   3,   0,   0,  74,   1,  73,   0,
+     0,   0,  52,   0,   0,   0,   0,   0,   0,  57,  59,  56,  30,
+     0,   0,   0,  46,   0,  16,  49,  10,   0,   0,   0,   0,   0,
+     0,   0,  11,  79,  95,   0,   0,   8,   0, 112,   0, 105,   0,
+    43,  62,   0,  77,   0, 116,   0,  61,   0,   0,  94,  42,  55,
+     0,  75,  34,  90,  32,  33,  27,  25,  18,  96,   0,  71,  85,
 };
 /* aKWLen[i] is the length (in bytes) of the i-th keyword */
-static const unsigned char aKWLen[140] = {
+static const unsigned char aKWLen[143] = {
      7,   7,   5,   4,   6,   4,   5,   3,   6,   7,   3,   6,   6,
      7,   7,   3,   8,   2,   6,   5,   4,   4,   3,  10,   4,   7,
-     6,   9,   4,   2,  10,   9,   4,   9,   4,   6,   2,   3,  11,
-     6,   2,   7,   5,   5,   6,   7,  10,   6,   5,   7,   4,   5,
-     7,   9,   6,   6,   6,   4,   5,   5,   5,   7,   7,   6,   5,
-     7,   3,   6,   4,   7,   6,  12,   9,   4,   6,   4,   5,   4,
-     7,   6,   5,   6,   6,   7,   5,   4,   7,   3,   2,   4,   5,
-     9,   5,   6,   3,   7,  13,   2,   2,   4,   6,   6,   8,   5,
-    17,  12,   7,   9,   8,   8,   2,   4,   9,   4,   6,   7,   9,
-     4,   4,   2,   6,   5,   8,   6,   4,   5,   8,   4,   3,   9,
-     5,   5,   6,   4,   6,   2,   2,   9,   3,   7,
+     6,   9,   4,   2,   6,   5,   9,   9,   4,   7,   3,   2,   4,
+     4,   6,  11,   6,   2,   7,   5,   5,   9,   6,  10,   4,   6,
+     2,   3,   7,  10,   6,   5,   7,   4,   5,   7,   6,   6,   4,
+     5,   5,   5,   7,   7,   6,   5,   7,   3,   6,   4,   7,   6,
+    12,   9,   4,   6,   5,   4,   7,   6,   5,   6,   6,   7,   4,
+     4,   5,   9,   5,   6,   3,   7,  13,   2,   2,   4,   6,   6,
+     8,   5,  17,  12,   7,   9,   8,   8,   2,   4,   9,   4,   5,
+     6,   7,   5,   9,   4,   4,   2,   5,   8,   6,   4,   5,   8,
+     4,   3,   9,   5,   5,   6,   4,   6,   2,   2,   9,   3,   7,
 };
 /* aKWOffset[i] is the index into zKWText[] of the start of
 ** the text for the i-th keyword. */
-static const unsigned short int aKWOffset[140] = {
+static const unsigned short int aKWOffset[143] = {
      0,   2,   2,   8,   9,  14,  16,  20,  23,  25,  25,  29,  33,
     36,  41,  46,  48,  53,  54,  59,  62,  65,  67,  69,  78,  81,
-    86,  90,  90,  94,  99, 106, 114, 117, 123, 126, 126, 129, 131,
-   136, 140, 141, 146, 150, 154, 159, 165, 175, 178, 183, 183, 187,
-   191, 197, 205, 211, 216, 221, 224, 227, 231, 236, 242, 248, 248,
-   254, 255, 259, 265, 269, 276, 282, 294, 303, 305, 311, 315, 320,
-   322, 329, 334, 339, 345, 351, 357, 362, 365, 365, 365, 368, 372,
-   375, 384, 388, 394, 396, 403, 405, 407, 416, 420, 426, 432, 440,
-   445, 445, 445, 461, 470, 477, 478, 485, 488, 497, 501, 506, 513,
-   522, 526, 530, 532, 538, 542, 550, 556, 559, 564, 572, 572, 576,
-   585, 590, 595, 601, 604, 607, 610, 612, 617, 621,
+    86,  90,  90,  94,  99, 101, 105, 111, 119, 123, 123, 123, 126,
+   129, 132, 137, 142, 146, 147, 152, 156, 160, 168, 174, 181, 184,
+   184, 187, 189, 195, 205, 208, 213, 213, 217, 221, 228, 233, 238,
+   241, 244, 248, 253, 259, 265, 265, 271, 272, 276, 282, 286, 293,
+   299, 311, 320, 322, 328, 333, 335, 342, 347, 352, 358, 364, 370,
+   374, 378, 381, 390, 394, 400, 402, 409, 411, 413, 422, 426, 432,
+   438, 446, 451, 451, 451, 467, 476, 483, 484, 491, 494, 503, 506,
+   511, 516, 523, 528, 537, 541, 545, 547, 551, 559, 565, 568, 573,
+   581, 581, 585, 594, 599, 604, 610, 613, 616, 619, 621, 626, 630,
 };
 /* aKWCode[i] is the parser symbol code for the i-th keyword */
-static const unsigned char aKWCode[140] = {
+static const unsigned char aKWCode[143] = {
   TK_REINDEX,    TK_INDEXED,    TK_INDEX,      TK_DESC,       TK_ESCAPE,
   TK_EACH,       TK_CHECK,      TK_KEY,        TK_BEFORE,     TK_FOREIGN,
   TK_FOR,        TK_IGNORE,     TK_LIKE_KW,    TK_EXPLAIN,    TK_INSTEAD,
   TK_ADD,        TK_DATABASE,   TK_AS,         TK_SELECT,     TK_TABLE,
   TK_JOIN_KW,    TK_THEN,       TK_END,        TK_DEFERRABLE, TK_ELSE,
   TK_EXCLUDE,    TK_DELETE,     TK_TEMP,       TK_TEMP,       TK_OR,
-  TK_CONSTRAINT, TK_INTERSECT,  TK_TIES,       TK_SAVEPOINT,  TK_INTO,
-  TK_OFFSET,     TK_OF,         TK_SET,        TK_TRANSACTION,TK_ACTION,
-  TK_ON,         TK_JOIN_KW,    TK_ALTER,      TK_RAISE,      TK_EXCEPT,
-  TK_TRIGGER,    TK_REFERENCES, TK_UNIQUE,     TK_QUERY,      TK_WITHOUT,
-  TK_WITH,       TK_JOIN_KW,    TK_RELEASE,    TK_EXCLUSIVE,  TK_EXISTS,
-  TK_ATTACH,     TK_HAVING,     TK_LIKE_KW,    TK_BEGIN,      TK_JOIN_KW,
-  TK_RANGE,      TK_BETWEEN,    TK_NOTHING,    TK_GROUPS,     TK_GROUP,
-  TK_CASCADE,    TK_ASC,        TK_DETACH,     TK_CASE,       TK_COLLATE,
-  TK_CREATE,     TK_CTIME_KW,   TK_IMMEDIATE,  TK_JOIN,       TK_INSERT,
-  TK_LIKE_KW,    TK_MATCH,      TK_PLAN,       TK_ANALYZE,    TK_PRAGMA,
-  TK_ABORT,      TK_UPDATE,     TK_VALUES,     TK_VIRTUAL,    TK_LIMIT,
-  TK_WHEN,       TK_NOTNULL,    TK_NOT,        TK_NO,         TK_NULL,
-  TK_WHERE,      TK_RECURSIVE,  TK_AFTER,      TK_RENAME,     TK_AND,
-  TK_DEFAULT,    TK_AUTOINCR,   TK_TO,         TK_IN,         TK_CAST,
-  TK_COLUMNKW,   TK_COMMIT,     TK_CONFLICT,   TK_JOIN_KW,    TK_CTIME_KW,
-  TK_CTIME_KW,   TK_CURRENT,    TK_PARTITION,  TK_DEFERRED,   TK_DISTINCT,
-  TK_IS,         TK_DROP,       TK_PRECEDING,  TK_FAIL,       TK_FILTER,
-  TK_REPLACE,    TK_FOLLOWING,  TK_FROM,       TK_JOIN_KW,    TK_IF,
-  TK_ISNULL,     TK_ORDER,      TK_RESTRICT,   TK_OTHERS,     TK_OVER,
-  TK_JOIN_KW,    TK_ROLLBACK,   TK_ROWS,       TK_ROW,        TK_UNBOUNDED,
-  TK_UNION,      TK_USING,      TK_VACUUM,     TK_VIEW,       TK_WINDOW,
-  TK_DO,         TK_BY,         TK_INITIALLY,  TK_ALL,        TK_PRIMARY,
+  TK_ISNULL,     TK_NULLS,      TK_SAVEPOINT,  TK_INTERSECT,  TK_TIES,
+  TK_NOTNULL,    TK_NOT,        TK_NO,         TK_NULL,       TK_LIKE_KW,
+  TK_EXCEPT,     TK_TRANSACTION,TK_ACTION,     TK_ON,         TK_JOIN_KW,
+  TK_ALTER,      TK_RAISE,      TK_EXCLUSIVE,  TK_EXISTS,     TK_CONSTRAINT,
+  TK_INTO,       TK_OFFSET,     TK_OF,         TK_SET,        TK_TRIGGER,
+  TK_REFERENCES, TK_UNIQUE,     TK_QUERY,      TK_WITHOUT,    TK_WITH,
+  TK_JOIN_KW,    TK_RELEASE,    TK_ATTACH,     TK_HAVING,     TK_LIKE_KW,
+  TK_BEGIN,      TK_JOIN_KW,    TK_RANGE,      TK_BETWEEN,    TK_NOTHING,
+  TK_GROUPS,     TK_GROUP,      TK_CASCADE,    TK_ASC,        TK_DETACH,
+  TK_CASE,       TK_COLLATE,    TK_CREATE,     TK_CTIME_KW,   TK_IMMEDIATE,
+  TK_JOIN,       TK_INSERT,     TK_MATCH,      TK_PLAN,       TK_ANALYZE,
+  TK_PRAGMA,     TK_ABORT,      TK_UPDATE,     TK_VALUES,     TK_VIRTUAL,
+  TK_LAST,       TK_WHEN,       TK_WHERE,      TK_RECURSIVE,  TK_AFTER,
+  TK_RENAME,     TK_AND,        TK_DEFAULT,    TK_AUTOINCR,   TK_TO,
+  TK_IN,         TK_CAST,       TK_COLUMNKW,   TK_COMMIT,     TK_CONFLICT,
+  TK_JOIN_KW,    TK_CTIME_KW,   TK_CTIME_KW,   TK_CURRENT,    TK_PARTITION,
+  TK_DEFERRED,   TK_DISTINCT,   TK_IS,         TK_DROP,       TK_PRECEDING,
+  TK_FAIL,       TK_LIMIT,      TK_FILTER,     TK_REPLACE,    TK_FIRST,
+  TK_FOLLOWING,  TK_FROM,       TK_JOIN_KW,    TK_IF,         TK_ORDER,
+  TK_RESTRICT,   TK_OTHERS,     TK_OVER,       TK_JOIN_KW,    TK_ROLLBACK,
+  TK_ROWS,       TK_ROW,        TK_UNBOUNDED,  TK_UNION,      TK_USING,
+  TK_VACUUM,     TK_VIEW,       TK_WINDOW,     TK_DO,         TK_BY,
+  TK_INITIALLY,  TK_ALL,        TK_PRIMARY,
 };
 /* Check to see if z[0..n-1] is a keyword. If it is, write the
 ** parser symbol code for that keyword into *pType.  Always
 ** return the integer n (the length of the token). */
 static int keywordCode(const char *z, int n, int *pType){
@@ -153367,120 +154987,123 @@
       testcase( i==25 ); /* EXCLUDE */
       testcase( i==26 ); /* DELETE */
       testcase( i==27 ); /* TEMPORARY */
       testcase( i==28 ); /* TEMP */
       testcase( i==29 ); /* OR */
-      testcase( i==30 ); /* CONSTRAINT */
-      testcase( i==31 ); /* INTERSECT */
-      testcase( i==32 ); /* TIES */
-      testcase( i==33 ); /* SAVEPOINT */
-      testcase( i==34 ); /* INTO */
-      testcase( i==35 ); /* OFFSET */
-      testcase( i==36 ); /* OF */
-      testcase( i==37 ); /* SET */
-      testcase( i==38 ); /* TRANSACTION */
-      testcase( i==39 ); /* ACTION */
-      testcase( i==40 ); /* ON */
-      testcase( i==41 ); /* NATURAL */
-      testcase( i==42 ); /* ALTER */
-      testcase( i==43 ); /* RAISE */
-      testcase( i==44 ); /* EXCEPT */
-      testcase( i==45 ); /* TRIGGER */
-      testcase( i==46 ); /* REFERENCES */
-      testcase( i==47 ); /* UNIQUE */
-      testcase( i==48 ); /* QUERY */
-      testcase( i==49 ); /* WITHOUT */
-      testcase( i==50 ); /* WITH */
-      testcase( i==51 ); /* OUTER */
-      testcase( i==52 ); /* RELEASE */
-      testcase( i==53 ); /* EXCLUSIVE */
-      testcase( i==54 ); /* EXISTS */
-      testcase( i==55 ); /* ATTACH */
-      testcase( i==56 ); /* HAVING */
-      testcase( i==57 ); /* GLOB */
-      testcase( i==58 ); /* BEGIN */
-      testcase( i==59 ); /* INNER */
-      testcase( i==60 ); /* RANGE */
-      testcase( i==61 ); /* BETWEEN */
-      testcase( i==62 ); /* NOTHING */
-      testcase( i==63 ); /* GROUPS */
-      testcase( i==64 ); /* GROUP */
-      testcase( i==65 ); /* CASCADE */
-      testcase( i==66 ); /* ASC */
-      testcase( i==67 ); /* DETACH */
-      testcase( i==68 ); /* CASE */
-      testcase( i==69 ); /* COLLATE */
-      testcase( i==70 ); /* CREATE */
-      testcase( i==71 ); /* CURRENT_DATE */
-      testcase( i==72 ); /* IMMEDIATE */
-      testcase( i==73 ); /* JOIN */
-      testcase( i==74 ); /* INSERT */
-      testcase( i==75 ); /* LIKE */
-      testcase( i==76 ); /* MATCH */
-      testcase( i==77 ); /* PLAN */
-      testcase( i==78 ); /* ANALYZE */
-      testcase( i==79 ); /* PRAGMA */
-      testcase( i==80 ); /* ABORT */
-      testcase( i==81 ); /* UPDATE */
-      testcase( i==82 ); /* VALUES */
-      testcase( i==83 ); /* VIRTUAL */
-      testcase( i==84 ); /* LIMIT */
-      testcase( i==85 ); /* WHEN */
-      testcase( i==86 ); /* NOTNULL */
-      testcase( i==87 ); /* NOT */
-      testcase( i==88 ); /* NO */
-      testcase( i==89 ); /* NULL */
-      testcase( i==90 ); /* WHERE */
-      testcase( i==91 ); /* RECURSIVE */
-      testcase( i==92 ); /* AFTER */
-      testcase( i==93 ); /* RENAME */
-      testcase( i==94 ); /* AND */
-      testcase( i==95 ); /* DEFAULT */
-      testcase( i==96 ); /* AUTOINCREMENT */
-      testcase( i==97 ); /* TO */
-      testcase( i==98 ); /* IN */
-      testcase( i==99 ); /* CAST */
-      testcase( i==100 ); /* COLUMN */
-      testcase( i==101 ); /* COMMIT */
-      testcase( i==102 ); /* CONFLICT */
-      testcase( i==103 ); /* CROSS */
-      testcase( i==104 ); /* CURRENT_TIMESTAMP */
-      testcase( i==105 ); /* CURRENT_TIME */
-      testcase( i==106 ); /* CURRENT */
-      testcase( i==107 ); /* PARTITION */
-      testcase( i==108 ); /* DEFERRED */
-      testcase( i==109 ); /* DISTINCT */
-      testcase( i==110 ); /* IS */
-      testcase( i==111 ); /* DROP */
-      testcase( i==112 ); /* PRECEDING */
-      testcase( i==113 ); /* FAIL */
-      testcase( i==114 ); /* FILTER */
-      testcase( i==115 ); /* REPLACE */
-      testcase( i==116 ); /* FOLLOWING */
-      testcase( i==117 ); /* FROM */
-      testcase( i==118 ); /* FULL */
-      testcase( i==119 ); /* IF */
-      testcase( i==120 ); /* ISNULL */
-      testcase( i==121 ); /* ORDER */
-      testcase( i==122 ); /* RESTRICT */
-      testcase( i==123 ); /* OTHERS */
-      testcase( i==124 ); /* OVER */
-      testcase( i==125 ); /* RIGHT */
-      testcase( i==126 ); /* ROLLBACK */
-      testcase( i==127 ); /* ROWS */
-      testcase( i==128 ); /* ROW */
-      testcase( i==129 ); /* UNBOUNDED */
-      testcase( i==130 ); /* UNION */
-      testcase( i==131 ); /* USING */
-      testcase( i==132 ); /* VACUUM */
-      testcase( i==133 ); /* VIEW */
-      testcase( i==134 ); /* WINDOW */
-      testcase( i==135 ); /* DO */
-      testcase( i==136 ); /* BY */
-      testcase( i==137 ); /* INITIALLY */
-      testcase( i==138 ); /* ALL */
-      testcase( i==139 ); /* PRIMARY */
+      testcase( i==30 ); /* ISNULL */
+      testcase( i==31 ); /* NULLS */
+      testcase( i==32 ); /* SAVEPOINT */
+      testcase( i==33 ); /* INTERSECT */
+      testcase( i==34 ); /* TIES */
+      testcase( i==35 ); /* NOTNULL */
+      testcase( i==36 ); /* NOT */
+      testcase( i==37 ); /* NO */
+      testcase( i==38 ); /* NULL */
+      testcase( i==39 ); /* LIKE */
+      testcase( i==40 ); /* EXCEPT */
+      testcase( i==41 ); /* TRANSACTION */
+      testcase( i==42 ); /* ACTION */
+      testcase( i==43 ); /* ON */
+      testcase( i==44 ); /* NATURAL */
+      testcase( i==45 ); /* ALTER */
+      testcase( i==46 ); /* RAISE */
+      testcase( i==47 ); /* EXCLUSIVE */
+      testcase( i==48 ); /* EXISTS */
+      testcase( i==49 ); /* CONSTRAINT */
+      testcase( i==50 ); /* INTO */
+      testcase( i==51 ); /* OFFSET */
+      testcase( i==52 ); /* OF */
+      testcase( i==53 ); /* SET */
+      testcase( i==54 ); /* TRIGGER */
+      testcase( i==55 ); /* REFERENCES */
+      testcase( i==56 ); /* UNIQUE */
+      testcase( i==57 ); /* QUERY */
+      testcase( i==58 ); /* WITHOUT */
+      testcase( i==59 ); /* WITH */
+      testcase( i==60 ); /* OUTER */
+      testcase( i==61 ); /* RELEASE */
+      testcase( i==62 ); /* ATTACH */
+      testcase( i==63 ); /* HAVING */
+      testcase( i==64 ); /* GLOB */
+      testcase( i==65 ); /* BEGIN */
+      testcase( i==66 ); /* INNER */
+      testcase( i==67 ); /* RANGE */
+      testcase( i==68 ); /* BETWEEN */
+      testcase( i==69 ); /* NOTHING */
+      testcase( i==70 ); /* GROUPS */
+      testcase( i==71 ); /* GROUP */
+      testcase( i==72 ); /* CASCADE */
+      testcase( i==73 ); /* ASC */
+      testcase( i==74 ); /* DETACH */
+      testcase( i==75 ); /* CASE */
+      testcase( i==76 ); /* COLLATE */
+      testcase( i==77 ); /* CREATE */
+      testcase( i==78 ); /* CURRENT_DATE */
+      testcase( i==79 ); /* IMMEDIATE */
+      testcase( i==80 ); /* JOIN */
+      testcase( i==81 ); /* INSERT */
+      testcase( i==82 ); /* MATCH */
+      testcase( i==83 ); /* PLAN */
+      testcase( i==84 ); /* ANALYZE */
+      testcase( i==85 ); /* PRAGMA */
+      testcase( i==86 ); /* ABORT */
+      testcase( i==87 ); /* UPDATE */
+      testcase( i==88 ); /* VALUES */
+      testcase( i==89 ); /* VIRTUAL */
+      testcase( i==90 ); /* LAST */
+      testcase( i==91 ); /* WHEN */
+      testcase( i==92 ); /* WHERE */
+      testcase( i==93 ); /* RECURSIVE */
+      testcase( i==94 ); /* AFTER */
+      testcase( i==95 ); /* RENAME */
+      testcase( i==96 ); /* AND */
+      testcase( i==97 ); /* DEFAULT */
+      testcase( i==98 ); /* AUTOINCREMENT */
+      testcase( i==99 ); /* TO */
+      testcase( i==100 ); /* IN */
+      testcase( i==101 ); /* CAST */
+      testcase( i==102 ); /* COLUMN */
+      testcase( i==103 ); /* COMMIT */
+      testcase( i==104 ); /* CONFLICT */
+      testcase( i==105 ); /* CROSS */
+      testcase( i==106 ); /* CURRENT_TIMESTAMP */
+      testcase( i==107 ); /* CURRENT_TIME */
+      testcase( i==108 ); /* CURRENT */
+      testcase( i==109 ); /* PARTITION */
+      testcase( i==110 ); /* DEFERRED */
+      testcase( i==111 ); /* DISTINCT */
+      testcase( i==112 ); /* IS */
+      testcase( i==113 ); /* DROP */
+      testcase( i==114 ); /* PRECEDING */
+      testcase( i==115 ); /* FAIL */
+      testcase( i==116 ); /* LIMIT */
+      testcase( i==117 ); /* FILTER */
+      testcase( i==118 ); /* REPLACE */
+      testcase( i==119 ); /* FIRST */
+      testcase( i==120 ); /* FOLLOWING */
+      testcase( i==121 ); /* FROM */
+      testcase( i==122 ); /* FULL */
+      testcase( i==123 ); /* IF */
+      testcase( i==124 ); /* ORDER */
+      testcase( i==125 ); /* RESTRICT */
+      testcase( i==126 ); /* OTHERS */
+      testcase( i==127 ); /* OVER */
+      testcase( i==128 ); /* RIGHT */
+      testcase( i==129 ); /* ROLLBACK */
+      testcase( i==130 ); /* ROWS */
+      testcase( i==131 ); /* ROW */
+      testcase( i==132 ); /* UNBOUNDED */
+      testcase( i==133 ); /* UNION */
+      testcase( i==134 ); /* USING */
+      testcase( i==135 ); /* VACUUM */
+      testcase( i==136 ); /* VIEW */
+      testcase( i==137 ); /* WINDOW */
+      testcase( i==138 ); /* DO */
+      testcase( i==139 ); /* BY */
+      testcase( i==140 ); /* INITIALLY */
+      testcase( i==141 ); /* ALL */
+      testcase( i==142 ); /* PRIMARY */
       *pType = aKWCode[i];
       break;
     }
   }
   return n;
@@ -153488,11 +155111,11 @@
 SQLITE_PRIVATE int sqlite3KeywordCode(const unsigned char *z, int n){
   int id = TK_ID;
   keywordCode((char*)z, n, &id);
   return id;
 }
-#define SQLITE_N_KEYWORD 140
+#define SQLITE_N_KEYWORD 143
 SQLITE_API int sqlite3_keyword_name(int i,const char **pzName,int *pnName){
   if( i<0 || i>=SQLITE_N_KEYWORD ) return SQLITE_ERROR;
   *pzName = zKWText + aKWOffset[i];
   *pnName = aKWLen[i];
   return SQLITE_OK;
@@ -155449,19 +157072,23 @@
         int op;      /* The opcode */
         u32 mask;    /* Mask of the bit in sqlite3.flags to set/clear */
       } aFlagOp[] = {
         { SQLITE_DBCONFIG_ENABLE_FKEY,           SQLITE_ForeignKeys    },
         { SQLITE_DBCONFIG_ENABLE_TRIGGER,        SQLITE_EnableTrigger  },
+        { SQLITE_DBCONFIG_ENABLE_VIEW,           SQLITE_EnableView     },
         { SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER, SQLITE_Fts3Tokenizer  },
         { SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION, SQLITE_LoadExtension  },
         { SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE,      SQLITE_NoCkptOnClose  },
         { SQLITE_DBCONFIG_ENABLE_QPSG,           SQLITE_EnableQPSG     },
         { SQLITE_DBCONFIG_TRIGGER_EQP,           SQLITE_TriggerEQP     },
         { SQLITE_DBCONFIG_RESET_DATABASE,        SQLITE_ResetDatabase  },
         { SQLITE_DBCONFIG_DEFENSIVE,             SQLITE_Defensive      },
         { SQLITE_DBCONFIG_WRITABLE_SCHEMA,       SQLITE_WriteSchema|
                                                  SQLITE_NoSchemaError  },
+        { SQLITE_DBCONFIG_LEGACY_ALTER_TABLE,    SQLITE_LegacyAlter    },
+        { SQLITE_DBCONFIG_DQS_DDL,               SQLITE_DqsDDL         },
+        { SQLITE_DBCONFIG_DQS_DML,               SQLITE_DqsDML         },
       };
       unsigned int i;
       rc = SQLITE_ERROR; /* IMP: R-42790-23372 */
       for(i=0; i<ArraySize(aFlagOp); i++){
         if( aFlagOp[i].op==op ){
@@ -155488,62 +157115,55 @@
   }
   va_end(ap);
   return rc;
 }
 
-
-/*
-** Return true if the buffer z[0..n-1] contains all spaces.
-*/
-static int allSpaces(const char *z, int n){
-  while( n>0 && z[n-1]==' ' ){ n--; }
-  return n==0;
-}
-
 /*
 ** This is the default collating function named "BINARY" which is always
 ** available.
-**
-** If the padFlag argument is not NULL then space padding at the end
-** of strings is ignored.  This implements the RTRIM collation.
 */
 static int binCollFunc(
-  void *padFlag,
+  void *NotUsed,
   int nKey1, const void *pKey1,
   int nKey2, const void *pKey2
 ){
   int rc, n;
+  UNUSED_PARAMETER(NotUsed);
   n = nKey1<nKey2 ? nKey1 : nKey2;
   /* EVIDENCE-OF: R-65033-28449 The built-in BINARY collation compares
   ** strings byte by byte using the memcmp() function from the standard C
   ** library. */
   assert( pKey1 && pKey2 );
   rc = memcmp(pKey1, pKey2, n);
   if( rc==0 ){
-    if( padFlag
-     && allSpaces(((char*)pKey1)+n, nKey1-n)
-     && allSpaces(((char*)pKey2)+n, nKey2-n)
-    ){
-      /* EVIDENCE-OF: R-31624-24737 RTRIM is like BINARY except that extra
-      ** spaces at the end of either string do not change the result. In other
-      ** words, strings will compare equal to one another as long as they
-      ** differ only in the number of spaces at the end.
-      */
-    }else{
-      rc = nKey1 - nKey2;
-    }
+    rc = nKey1 - nKey2;
   }
   return rc;
 }
 
+/*
+** This is the collating function named "RTRIM" which is always
+** available.  Ignore trailing spaces.
+*/
+static int rtrimCollFunc(
+  void *pUser,
+  int nKey1, const void *pKey1,
+  int nKey2, const void *pKey2
+){
+  const u8 *pK1 = (const u8*)pKey1;
+  const u8 *pK2 = (const u8*)pKey2;
+  while( nKey1 && pK1[nKey1-1]==' ' ) nKey1--;
+  while( nKey2 && pK2[nKey2-1]==' ' ) nKey2--;
+  return binCollFunc(pUser, nKey1, pKey1, nKey2, pKey2);
+}
+
 /*
 ** Return true if CollSeq is the default built-in BINARY.
 */
 SQLITE_PRIVATE int sqlite3IsBinary(const CollSeq *p){
-  assert( p==0 || p->xCmp!=binCollFunc || p->pUser!=0
-            || strcmp(p->zName,"BINARY")==0 );
-  return p==0 || (p->xCmp==binCollFunc && p->pUser==0);
+  assert( p==0 || p->xCmp!=binCollFunc || strcmp(p->zName,"BINARY")==0 );
+  return p==0 || p->xCmp==binCollFunc;
 }
 
 /*
 ** Another built-in collating sequence: NOCASE.
 **
@@ -155852,15 +157472,12 @@
   }
   sqlite3HashClear(&db->aCollSeq);
 #ifndef SQLITE_OMIT_VIRTUALTABLE
   for(i=sqliteHashFirst(&db->aModule); i; i=sqliteHashNext(i)){
     Module *pMod = (Module *)sqliteHashData(i);
-    if( pMod->xDestroy ){
-      pMod->xDestroy(pMod->pAux);
-    }
     sqlite3VtabEponymousTableClear(db, pMod);
-    sqlite3DbFree(db, pMod);
+    sqlite3VtabModuleUnref(db, pMod);
   }
   sqlite3HashClear(&db->aModule);
 #endif
 
   sqlite3Error(db, SQLITE_OK); /* Deallocates any cached error strings. */
@@ -156337,11 +157954,12 @@
   ){
     return SQLITE_MISUSE_BKPT;
   }
 
   assert( SQLITE_FUNC_CONSTANT==SQLITE_DETERMINISTIC );
-  extraFlags = enc &  SQLITE_DETERMINISTIC;
+  assert( SQLITE_FUNC_DIRECT==SQLITE_DIRECTONLY );
+  extraFlags = enc &  (SQLITE_DETERMINISTIC|SQLITE_DIRECTONLY|SQLITE_SUBTYPE);
   enc &= (SQLITE_FUNC_ENCMASK|SQLITE_ANY);
 
 #ifndef SQLITE_OMIT_UTF16
   /* If SQLITE_UTF16 is specified as the encoding type, transform this
   ** to one of SQLITE_UTF16LE or SQLITE_UTF16BE using the
@@ -156400,10 +158018,11 @@
     pDestructor->nRef++;
   }
   p->u.pDestructor = pDestructor;
   p->funcFlags = (p->funcFlags & SQLITE_FUNC_ENCMASK) | extraFlags;
   testcase( p->funcFlags & SQLITE_DETERMINISTIC );
+  testcase( p->funcFlags & SQLITE_DIRECTONLY );
   p->xSFunc = xSFunc ? xSFunc : xStep;
   p->xFinalize = xFinal;
   p->xValue = xValue;
   p->xInverse = xInverse;
   p->pUserData = pUserData;
@@ -157690,11 +159309,40 @@
   db->autoCommit = 1;
   db->nextAutovac = -1;
   db->szMmap = sqlite3GlobalConfig.szMmap;
   db->nextPagesize = 0;
   db->nMaxSorterMmap = 0x7FFFFFFF;
-  db->flags |= SQLITE_ShortColNames | SQLITE_EnableTrigger | SQLITE_CacheSpill
+  db->flags |= SQLITE_ShortColNames
+                 | SQLITE_EnableTrigger
+                 | SQLITE_EnableView
+                 | SQLITE_CacheSpill
+
+/* The SQLITE_DQS compile-time option determines the default settings
+** for SQLITE_DBCONFIG_DQS_DDL and SQLITE_DBCONFIG_DQS_DML.
+**
+**    SQLITE_DQS     SQLITE_DBCONFIG_DQS_DDL    SQLITE_DBCONFIG_DQS_DML
+**    ----------     -----------------------    -----------------------
+**     undefined               on                          on
+**         3                   on                          on
+**         2                   on                         off
+**         1                  off                          on
+**         0                  off                         off
+**
+** Legacy behavior is 3 (double-quoted string literals are allowed anywhere)
+** and so that is the default.  But developers are encouranged to use
+** -DSQLITE_DQS=0 (best) or -DSQLITE_DQS=1 (second choice) if possible.
+*/
+#if !defined(SQLITE_DQS)
+# define SQLITE_DQS 3
+#endif
+#if (SQLITE_DQS&1)==1
+                 | SQLITE_DqsDML
+#endif
+#if (SQLITE_DQS&2)==2
+                 | SQLITE_DqsDDL
+#endif
+
 #if !defined(SQLITE_DEFAULT_AUTOMATIC_INDEX) || SQLITE_DEFAULT_AUTOMATIC_INDEX
                  | SQLITE_AutoIndex
 #endif
 #if SQLITE_DEFAULT_CKPTFULLFSYNC
                  | SQLITE_CkptFullFSync
@@ -157741,11 +159389,11 @@
   */
   createCollation(db, sqlite3StrBINARY, SQLITE_UTF8, 0, binCollFunc, 0);
   createCollation(db, sqlite3StrBINARY, SQLITE_UTF16BE, 0, binCollFunc, 0);
   createCollation(db, sqlite3StrBINARY, SQLITE_UTF16LE, 0, binCollFunc, 0);
   createCollation(db, "NOCASE", SQLITE_UTF8, 0, nocaseCollatingFunc, 0);
-  createCollation(db, "RTRIM", SQLITE_UTF8, (void*)1, binCollFunc, 0);
+  createCollation(db, "RTRIM", SQLITE_UTF8, 0, rtrimCollFunc, 0);
   if( db->mallocFailed ){
     goto opendb_out;
   }
   /* EVIDENCE-OF: R-08308-17224 The default collating function for all
   ** strings is BINARY.
@@ -158413,16 +160061,37 @@
     case SQLITE_TESTCTRL_PRNG_RESTORE: {
       sqlite3PrngRestoreState();
       break;
     }
 
-    /*
-    ** Reset the PRNG back to its uninitialized state.  The next call
-    ** to sqlite3_randomness() will reseed the PRNG using a single call
-    ** to the xRandomness method of the default VFS.
+    /*  sqlite3_test_control(SQLITE_TESTCTRL_PRNG_SEED, int x, sqlite3 *db);
+    **
+    ** Control the seed for the pseudo-random number generator (PRNG) that
+    ** is built into SQLite.  Cases:
+    **
+    **    x!=0 && db!=0       Seed the PRNG to the current value of the
+    **                        schema cookie in the main database for db, or
+    **                        x if the schema cookie is zero.  This case
+    **                        is convenient to use with database fuzzers
+    **                        as it allows the fuzzer some control over the
+    **                        the PRNG seed.
+    **
+    **    x!=0 && db==0       Seed the PRNG to the value of x.
+    **
+    **    x==0 && db==0       Revert to default behavior of using the
+    **                        xRandomness method on the primary VFS.
+    **
+    ** This test-control also resets the PRNG so that the new seed will
+    ** be used for the next call to sqlite3_randomness().
     */
-    case SQLITE_TESTCTRL_PRNG_RESET: {
+    case SQLITE_TESTCTRL_PRNG_SEED: {
+      int x = va_arg(ap, int);
+      int y;
+      sqlite3 *db = va_arg(ap, sqlite3*);
+      assert( db==0 || db->aDb[0].pSchema!=0 );
+      if( db && (y = db->aDb[0].pSchema->schema_cookie)!=0 ){ x = y; }
+      sqlite3Config.iPrngSeed = x;
       sqlite3_randomness(0,0);
       break;
     }
 
     /*
@@ -158631,10 +160300,21 @@
     case SQLITE_TESTCTRL_NEVER_CORRUPT: {
       sqlite3GlobalConfig.neverCorrupt = va_arg(ap, int);
       break;
     }
 
+    /*   sqlite3_test_control(SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS, int);
+    **
+    ** Set or clear a flag that causes SQLite to verify that type, name,
+    ** and tbl_name fields of the sqlite_master table.  This is normally
+    ** on, but it is sometimes useful to turn it off for testing.
+    */
+    case SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS: {
+      sqlite3GlobalConfig.bExtraSchemaChecks = va_arg(ap, int);
+      break;
+    }
+
     /* Set the threshold at which OP_Once counters reset back to zero.
     ** By default this is 0x7ffffffe (over 2 billion), but that value is
     ** too big to test in a reasonable amount of time, so this control is
     ** provided to set a small and easily reachable reset value.
     */
@@ -158717,10 +160397,26 @@
       FILE *out = va_arg(ap, FILE*);
       if( sqlite3ParserCoverage(out) ) rc = SQLITE_ERROR;
       break;
     }
 #endif /* defined(YYCOVERAGE) */
+
+    /*  sqlite3_test_control(SQLITE_TESTCTRL_RESULT_INTREAL, sqlite3_context*);
+    **
+    ** This test-control causes the most recent sqlite3_result_int64() value
+    ** to be interpreted as a MEM_IntReal instead of as an MEM_Int.  Normally,
+    ** MEM_IntReal values only arise during an INSERT operation of integer
+    ** values into a REAL column, so they can be challenging to test.  This
+    ** test-control enables us to write an intreal() SQL function that can
+    ** inject an intreal() value at arbitrary places in an SQL statement,
+    ** for testing purposes.
+    */
+    case SQLITE_TESTCTRL_RESULT_INTREAL: {
+      sqlite3_context *pCtx = va_arg(ap, sqlite3_context*);
+      sqlite3ResultIntReal(pCtx);
+      break;
+    }
   }
   va_end(ap);
 #endif /* SQLITE_UNTESTABLE */
   return rc;
 }
@@ -160561,10 +162257,22 @@
 #ifndef SQLITE_CORE
 /* # include "sqlite3ext.h" */
   SQLITE_EXTENSION_INIT1
 #endif
 
+/*
+** The following are copied from sqliteInt.h.
+**
+** Constants for the largest and smallest possible 64-bit signed integers.
+** These macros are designed to work correctly on both 32-bit and 64-bit
+** compilers.
+*/
+#ifndef SQLITE_AMALGAMATION
+# define LARGEST_INT64  (0xffffffff|(((sqlite3_int64)0x7fffffff)<<32))
+# define SMALLEST_INT64 (((sqlite3_int64)-1) - LARGEST_INT64)
+#endif
+
 static int fts3EvalNext(Fts3Cursor *pCsr);
 static int fts3EvalStart(Fts3Cursor *pCsr);
 static int fts3TermSegReaderCursor(
     Fts3Cursor *, const char *, int, int, Fts3MultiSegReader **);
 
@@ -162339,14 +164047,15 @@
   }
   *ppPoslist = pEnd;
 }
 
 /*
-** Value used to signify the end of an position-list. This is safe because
-** it is not possible to have a document with 2^31 terms.
+** Value used to signify the end of an position-list. This must be
+** as large or larger than any value that might appear on the
+** position-list, even a position list that has been corrupted.
 */
-#define POSITION_LIST_END 0x7fffffff
+#define POSITION_LIST_END LARGEST_INT64
 
 /*
 ** This function is used to help parse position-lists. When this function is
 ** called, *pp may point to the start of the next varint in the position-list
 ** being parsed, or it may point to 1 byte past the end of the position-list
@@ -162418,18 +164127,18 @@
 
     if( *p1==POS_COLUMN ){
       fts3GetVarint32(&p1[1], &iCol1);
       if( iCol1==0 ) return FTS_CORRUPT_VTAB;
     }
-    else if( *p1==POS_END ) iCol1 = POSITION_LIST_END;
+    else if( *p1==POS_END ) iCol1 = 0x7fffffff;
     else iCol1 = 0;
 
     if( *p2==POS_COLUMN ){
       fts3GetVarint32(&p2[1], &iCol2);
       if( iCol2==0 ) return FTS_CORRUPT_VTAB;
     }
-    else if( *p2==POS_END ) iCol2 = POSITION_LIST_END;
+    else if( *p2==POS_END ) iCol2 = 0x7fffffff;
     else iCol2 = 0;
 
     if( iCol1==iCol2 ){
       sqlite3_int64 i1 = 0;       /* Last position from pp1 */
       sqlite3_int64 i2 = 0;       /* Last position from pp2 */
@@ -162727,11 +164436,12 @@
     iWrite = iVal - *piPrev;
   }else{
     iWrite = *piPrev - iVal;
   }
   assert( *pbFirst || *piPrev==0 );
-  assert( *pbFirst==0 || iWrite>0 );
+  assert_fts3_nc( *pbFirst==0 || iWrite>0 );
+  assert( *pbFirst==0 || iWrite>=0 );
   *pp += sqlite3Fts3PutVarint(*pp, iWrite);
   *piPrev = iVal;
   *pbFirst = 1;
 }
 
@@ -162833,10 +164543,12 @@
     }else{
       fts3PutDeltaVarint3(&p, bDescDoclist, &iPrev, &bFirstOut, i2);
       fts3PoslistCopy(&p, &p2);
       fts3GetDeltaVarint3(&p2, pEnd2, bDescDoclist, &i2);
     }
+
+    assert( (p-aOut)<=((p1?(p1-a1):n1)+(p2?(p2-a2):n2)+FTS3_VARINT_MAX-1) );
   }
 
   if( rc!=SQLITE_OK ){
     sqlite3_free(aOut);
     p = aOut = 0;
@@ -163432,22 +165144,10 @@
   }
   assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );
   return rc;
 }
 
-/*
-** The following are copied from sqliteInt.h.
-**
-** Constants for the largest and smallest possible 64-bit signed integers.
-** These macros are designed to work correctly on both 32-bit and 64-bit
-** compilers.
-*/
-#ifndef SQLITE_AMALGAMATION
-# define LARGEST_INT64  (0xffffffff|(((sqlite3_int64)0x7fffffff)<<32))
-# define SMALLEST_INT64 (((sqlite3_int64)-1) - LARGEST_INT64)
-#endif
-
 /*
 ** If the numeric type of argument pVal is "integer", then return it
 ** converted to a 64-bit signed integer. Otherwise, return a copy of
 ** the second parameter, iDefault.
 */
@@ -172995,18 +174695,18 @@
       break;
     }
 
     nList -= (int)(p - pList);
     pList = p;
-    if( nList==0 ){
+    if( nList<=0 ){
       break;
     }
     p = &pList[1];
     p += fts3GetVarint32(p, &iCurrent);
   }
 
-  if( bZero && &pList[nList]!=pEnd ){
+  if( bZero && (pEnd - &pList[nList])>0){
     memset(&pList[nList], 0, pEnd - &pList[nList]);
   }
   *ppList = pList;
   *pnList = nList;
 }
@@ -174130,11 +175830,11 @@
     if( bFirst==0 ){
       p->iOff += fts3GetVarint32(&p->aNode[p->iOff], &nPrefix);
     }
     p->iOff += fts3GetVarint32(&p->aNode[p->iOff], &nSuffix);
 
-    if( nPrefix>p->iOff || nSuffix>p->nNode-p->iOff ){
+    if( nPrefix>p->term.n || nSuffix>p->nNode-p->iOff || nSuffix==0 ){
       return FTS_CORRUPT_VTAB;
     }
     blobGrowBuffer(&p->term, nPrefix+nSuffix, &rc);
     if( rc==SQLITE_OK ){
       memcpy(&p->term.a[nPrefix], &p->aNode[p->iOff], nSuffix);
@@ -174149,11 +175849,11 @@
         p->iOff += p->nDoclist;
       }
     }
   }
 
-  assert( p->iOff<=p->nNode );
+  assert_fts3_nc( p->iOff<=p->nNode );
   return rc;
 }
 
 /*
 ** Release all dynamic resources held by node-reader object *p.
@@ -174173,18 +175873,18 @@
   memset(p, 0, sizeof(NodeReader));
   p->aNode = aNode;
   p->nNode = nNode;
 
   /* Figure out if this is a leaf or an internal node. */
-  if( p->aNode[0] ){
+  if( aNode && aNode[0] ){
     /* An internal node. */
     p->iOff = 1 + sqlite3Fts3GetVarint(&p->aNode[1], &p->iChild);
   }else{
     p->iOff = 1;
   }
 
-  return nodeReaderNext(p);
+  return aNode ? nodeReaderNext(p) : SQLITE_OK;
 }
 
 /*
 ** This function is called while writing an FTS segment each time a leaf o
 ** node is finished and written to disk. The key (zTerm/nTerm) is guaranteed
@@ -174310,17 +176010,18 @@
   int nSuffix;                    /* Size of term suffix in bytes */
 
   /* Node must have already been started. There must be a doclist for a
   ** leaf node, and there must not be a doclist for an internal node.  */
   assert( pNode->n>0 );
-  assert( (pNode->a[0]=='\0')==(aDoclist!=0) );
+  assert_fts3_nc( (pNode->a[0]=='\0')==(aDoclist!=0) );
 
   blobGrowBuffer(pPrev, nTerm, &rc);
   if( rc!=SQLITE_OK ) return rc;
 
   nPrefix = fts3PrefixCompress(pPrev->a, pPrev->n, zTerm, nTerm);
   nSuffix = nTerm - nPrefix;
+  if( nSuffix<=0 ) return FTS_CORRUPT_VTAB;
   memcpy(pPrev->a, zTerm, nTerm);
   pPrev->n = nTerm;
 
   if( bFirst==0 ){
     pNode->n += sqlite3Fts3PutVarint(&pNode->a[pNode->n], nPrefix);
@@ -174526,11 +176227,11 @@
   const char *zRhs, int nRhs      /* RHS of comparison */
 ){
   int nCmp = MIN(nLhs, nRhs);
   int res;
 
-  res = memcmp(zLhs, zRhs, nCmp);
+  res = (nCmp ? memcmp(zLhs, zRhs, nCmp) : 0);
   if( res==0 ) res = nLhs - nRhs;
 
   return res;
 }
 
@@ -174658,38 +176359,46 @@
         pWriter->aNodeWriter[i].iBlock = pWriter->iStart + i*pWriter->nLeafEst;
       }
 
       pNode = &pWriter->aNodeWriter[nHeight];
       pNode->iBlock = pWriter->iStart + pWriter->nLeafEst*nHeight;
-      blobGrowBuffer(&pNode->block, MAX(nRoot, p->nNodeSize), &rc);
+      blobGrowBuffer(&pNode->block,
+          MAX(nRoot, p->nNodeSize)+FTS3_NODE_PADDING, &rc
+      );
       if( rc==SQLITE_OK ){
         memcpy(pNode->block.a, aRoot, nRoot);
         pNode->block.n = nRoot;
+        memset(&pNode->block.a[nRoot], 0, FTS3_NODE_PADDING);
       }
 
       for(i=nHeight; i>=0 && rc==SQLITE_OK; i--){
         NodeReader reader;
         pNode = &pWriter->aNodeWriter[i];
 
-        rc = nodeReaderInit(&reader, pNode->block.a, pNode->block.n);
-        while( reader.aNode && rc==SQLITE_OK ) rc = nodeReaderNext(&reader);
-        blobGrowBuffer(&pNode->key, reader.term.n, &rc);
-        if( rc==SQLITE_OK ){
-          memcpy(pNode->key.a, reader.term.a, reader.term.n);
-          pNode->key.n = reader.term.n;
-          if( i>0 ){
-            char *aBlock = 0;
-            int nBlock = 0;
-            pNode = &pWriter->aNodeWriter[i-1];
-            pNode->iBlock = reader.iChild;
-            rc = sqlite3Fts3ReadBlock(p, reader.iChild, &aBlock, &nBlock, 0);
-            blobGrowBuffer(&pNode->block, MAX(nBlock, p->nNodeSize), &rc);
-            if( rc==SQLITE_OK ){
-              memcpy(pNode->block.a, aBlock, nBlock);
-              pNode->block.n = nBlock;
+        if( pNode->block.a){
+          rc = nodeReaderInit(&reader, pNode->block.a, pNode->block.n);
+          while( reader.aNode && rc==SQLITE_OK ) rc = nodeReaderNext(&reader);
+          blobGrowBuffer(&pNode->key, reader.term.n, &rc);
+          if( rc==SQLITE_OK ){
+            memcpy(pNode->key.a, reader.term.a, reader.term.n);
+            pNode->key.n = reader.term.n;
+            if( i>0 ){
+              char *aBlock = 0;
+              int nBlock = 0;
+              pNode = &pWriter->aNodeWriter[i-1];
+              pNode->iBlock = reader.iChild;
+              rc = sqlite3Fts3ReadBlock(p, reader.iChild, &aBlock, &nBlock, 0);
+              blobGrowBuffer(&pNode->block,
+                  MAX(nBlock, p->nNodeSize)+FTS3_NODE_PADDING, &rc
+              );
+              if( rc==SQLITE_OK ){
+                memcpy(pNode->block.a, aBlock, nBlock);
+                pNode->block.n = nBlock;
+                memset(&pNode->block.a[nBlock], 0, FTS3_NODE_PADDING);
+              }
+              sqlite3_free(aBlock);
             }
-            sqlite3_free(aBlock);
           }
         }
         nodeReaderRelease(&reader);
       }
     }
@@ -174928,11 +176637,14 @@
   sqlite3_int64 *piBlock          /* OUT: Block number in next layer down */
 ){
   NodeReader reader;              /* Reader object */
   Blob prev = {0, 0, 0};          /* Previous term written to new node */
   int rc = SQLITE_OK;             /* Return code */
-  int bLeaf = aNode[0]=='\0';     /* True for a leaf node */
+  int bLeaf;                       /* True for a leaf node */
+
+  if( nNode<1 ) return FTS_CORRUPT_VTAB;
+  bLeaf = aNode[0]=='\0';
 
   /* Allocate required output space */
   blobGrowBuffer(pNew, nNode, &rc);
   if( rc!=SQLITE_OK ) return rc;
   pNew->n = 0;
@@ -176526,14 +178238,14 @@
       char *pCsr = pPhrase->pTail;
       int iCsr = pPhrase->iTail;
 
       while( iCsr<(iStart+pIter->nSnippet) && iCsr>=iStart ){
         int j;
-        u64 mPhrase = (u64)1 << i;
+        u64 mPhrase = (u64)1 << (i%64);
         u64 mPos = (u64)1 << (iCsr - iStart);
         assert( iCsr>=iStart && (iCsr - iStart)<=64 );
-        assert( i>=0 && i<=64 );
+        assert( i>=0 );
         if( (mCover|mCovered)&mPhrase ){
           iScore++;
         }else{
           iScore += 1000;
         }
@@ -179690,10 +181402,11 @@
 ){
   u32 i, j, nKey;
   const char *zKey;
   JsonNode *pRoot = &pParse->aNode[iRoot];
   if( zPath[0]==0 ) return pRoot;
+  if( pRoot->jnFlags & JNODE_REPLACE ) return 0;
   if( zPath[0]=='.' ){
     if( pRoot->eType!=JSON_OBJECT ) return 0;
     zPath++;
     if( zPath[0]=='"' ){
       zKey = zPath + 1;
@@ -179730,11 +181443,11 @@
     }
     if( pApnd ){
       u32 iStart, iLabel;
       JsonNode *pNode;
       iStart = jsonParseAddNode(pParse, JSON_OBJECT, 2, 0);
-      iLabel = jsonParseAddNode(pParse, JSON_STRING, i, zPath);
+      iLabel = jsonParseAddNode(pParse, JSON_STRING, nKey, zKey);
       zPath += i;
       pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);
       if( pParse->oom ) return 0;
       if( pNode ){
         pRoot = &pParse->aNode[iRoot];
@@ -180426,11 +182139,11 @@
   pStr = (JsonString*)sqlite3_aggregate_context(ctx, sizeof(*pStr));
   if( pStr ){
     if( pStr->zBuf==0 ){
       jsonInit(pStr, ctx);
       jsonAppendChar(pStr, '[');
-    }else{
+    }else if( pStr->nUsed>1 ){
       jsonAppendChar(pStr, ',');
       pStr->pCtx = ctx;
     }
     jsonAppendValue(pStr, argv[0]);
   }
@@ -180474,29 +182187,37 @@
 static void jsonGroupInverse(
   sqlite3_context *ctx,
   int argc,
   sqlite3_value **argv
 ){
-  int i;
+  unsigned int i;
   int inStr = 0;
+  int nNest = 0;
   char *z;
+  char c;
   JsonString *pStr;
   UNUSED_PARAM(argc);
   UNUSED_PARAM(argv);
   pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);
 #ifdef NEVER
   /* pStr is always non-NULL since jsonArrayStep() or jsonObjectStep() will
   ** always have been called to initalize it */
   if( NEVER(!pStr) ) return;
 #endif
   z = pStr->zBuf;
-  for(i=1; z[i]!=',' || inStr; i++){
-    assert( i<pStr->nUsed );
-    if( z[i]=='"' ){
+  for(i=1; (c = z[i])!=',' || inStr || nNest; i++){
+    if( i>=pStr->nUsed ){
+      pStr->nUsed = 1;
+      return;
+    }
+    if( c=='"' ){
       inStr = !inStr;
-    }else if( z[i]=='\\' ){
+    }else if( c=='\\' ){
       i++;
+    }else if( !inStr ){
+      if( c=='{' || c=='[' ) nNest++;
+      if( c=='}' || c==']' ) nNest--;
     }
   }
   pStr->nUsed -= i;
   memmove(&z[1], &z[i+1], (size_t)pStr->nUsed-1);
 }
@@ -180522,11 +182243,11 @@
   pStr = (JsonString*)sqlite3_aggregate_context(ctx, sizeof(*pStr));
   if( pStr ){
     if( pStr->zBuf==0 ){
       jsonInit(pStr, ctx);
       jsonAppendChar(pStr, '{');
-    }else{
+    }else if( pStr->nUsed>1 ){
       jsonAppendChar(pStr, ',');
       pStr->pCtx = ctx;
     }
     z = (const char*)sqlite3_value_text(argv[0]);
     n = (u32)sqlite3_value_bytes(argv[0]);
@@ -181117,11 +182838,11 @@
                                  aFunc[i].xFunc, 0, 0);
   }
 #ifndef SQLITE_OMIT_WINDOWFUNC
   for(i=0; i<sizeof(aAgg)/sizeof(aAgg[0]) && rc==SQLITE_OK; i++){
     rc = sqlite3_create_window_function(db, aAgg[i].zName, aAgg[i].nArg,
-                                 SQLITE_UTF8 | SQLITE_DETERMINISTIC, 0,
+                SQLITE_SUBTYPE | SQLITE_UTF8 | SQLITE_DETERMINISTIC, 0,
                                  aAgg[i].xStep, aAgg[i].xFinal,
                                  aAgg[i].xValue, jsonGroupInverse, 0);
   }
 #endif
 #ifndef SQLITE_OMIT_VIRTUALTABLE
@@ -181214,22 +182935,28 @@
   SQLITE_EXTENSION_INIT1
 #else
 /*   #include "sqlite3.h" */
 #endif
 
-/* #include <string.h> */
-/* #include <assert.h> */
-/* #include <stdio.h> */
-
 #ifndef SQLITE_AMALGAMATION
 #include "sqlite3rtree.h"
 typedef sqlite3_int64 i64;
 typedef sqlite3_uint64 u64;
 typedef unsigned char u8;
 typedef unsigned short u16;
 typedef unsigned int u32;
+#if !defined(NDEBUG) && !defined(SQLITE_DEBUG)
+# define NDEBUG 1
 #endif
+#if defined(NDEBUG) && defined(SQLITE_DEBUG)
+# undef NDEBUG
+#endif
+#endif
+
+/* #include <string.h> */
+/* #include <stdio.h> */
+/* #include <assert.h> */
 
 /*  The following macro is used to suppress compiler warnings.
 */
 #ifndef UNUSED_PARAMETER
 # define UNUSED_PARAMETER(x) (void)(x)
@@ -181814,18 +183541,20 @@
 
   /* Check if the requested node is already in the hash table. If so,
   ** increase its reference count and return it.
   */
   if( (pNode = nodeHashLookup(pRtree, iNode))!=0 ){
-    assert( !pParent || !pNode->pParent || pNode->pParent==pParent );
     if( pParent && !pNode->pParent ){
       if( nodeInParentChain(pNode, pParent) ){
         RTREE_IS_CORRUPT(pRtree);
         return SQLITE_CORRUPT_VTAB;
       }
       pParent->nRef++;
       pNode->pParent = pParent;
+    }else if( pParent && pNode->pParent && pParent!=pNode->pParent ){
+      RTREE_IS_CORRUPT(pRtree);
+      return SQLITE_CORRUPT_VTAB;
     }
     pNode->nRef++;
     *ppNode = pNode;
     return SQLITE_OK;
   }
@@ -182709,17 +184438,18 @@
   int eInt;
   RtreeSearchPoint x;
 
   eInt = pRtree->eCoordType==RTREE_COORD_INT32;
   while( (p = rtreeSearchPointFirst(pCur))!=0 && p->iLevel>0 ){
+    u8 *pCellData;
     pNode = rtreeNodeOfFirstSearchPoint(pCur, &rc);
     if( rc ) return rc;
     nCell = NCELL(pNode);
     assert( nCell<200 );
+    pCellData = pNode->zData + (4+pRtree->nBytesPerCell*p->iCell);
     while( p->iCell<nCell ){
       sqlite3_rtree_dbl rScore = (sqlite3_rtree_dbl)-1;
-      u8 *pCellData = pNode->zData + (4+pRtree->nBytesPerCell*p->iCell);
       eWithin = FULLY_WITHIN;
       for(ii=0; ii<nConstraint; ii++){
         RtreeConstraint *pConstraint = pCur->aConstraint + ii;
         if( pConstraint->op>=RTREE_MATCH ){
           rc = rtreeCallbackConstraint(pConstraint, eInt, pCellData, p,
@@ -182728,17 +184458,27 @@
         }else if( p->iLevel==1 ){
           rtreeLeafConstraint(pConstraint, eInt, pCellData, &eWithin);
         }else{
           rtreeNonleafConstraint(pConstraint, eInt, pCellData, &eWithin);
         }
-        if( eWithin==NOT_WITHIN ) break;
+        if( eWithin==NOT_WITHIN ){
+          p->iCell++;
+          pCellData += pRtree->nBytesPerCell;
+          break;
+        }
       }
-      p->iCell++;
       if( eWithin==NOT_WITHIN ) continue;
+      p->iCell++;
       x.iLevel = p->iLevel - 1;
       if( x.iLevel ){
         x.id = readInt64(pCellData);
+        for(ii=0; ii<pCur->nPoint; ii++){
+          if( pCur->aPoint[ii].id==x.id ){
+            RTREE_IS_CORRUPT(pRtree);
+            return SQLITE_CORRUPT_VTAB;
+          }
+        }
         x.iCell = 0;
       }else{
         x.id = p->id;
         x.iCell = p->iCell - 1;
       }
@@ -189042,10 +190782,11 @@
   "CREATE TABLE IF NOT EXISTS %s.rbu_state(k INTEGER PRIMARY KEY, v)"
 
 typedef struct RbuFrame RbuFrame;
 typedef struct RbuObjIter RbuObjIter;
 typedef struct RbuState RbuState;
+typedef struct RbuSpan RbuSpan;
 typedef struct rbu_vfs rbu_vfs;
 typedef struct rbu_file rbu_file;
 typedef struct RbuUpdateStmt RbuUpdateStmt;
 
 #if !defined(SQLITE_AMALGAMATION)
@@ -189086,10 +190827,15 @@
   char *zMask;                    /* Copy of update mask used with pUpdate */
   sqlite3_stmt *pUpdate;          /* Last update statement (or NULL) */
   RbuUpdateStmt *pNext;
 };
 
+struct RbuSpan {
+  const char *zSpan;
+  int nSpan;
+};
+
 /*
 ** An iterator of this type is used to iterate through all objects in
 ** the target database that require updating. For each such table, the
 ** iterator visits, in order:
 **
@@ -189135,10 +190881,13 @@
   int nCol;                       /* Number of columns in current object */
   sqlite3_stmt *pSelect;          /* Source data */
   sqlite3_stmt *pInsert;          /* Statement for INSERT operations */
   sqlite3_stmt *pDelete;          /* Statement for DELETE ops */
   sqlite3_stmt *pTmpInsert;       /* Insert into rbu_tmp_$zDataTbl */
+  int nIdxCol;
+  RbuSpan *aIdxCol;
+  char *zIdxSql;
 
   /* Last UPDATE used (for PK b-tree updates only), or NULL. */
   RbuUpdateStmt *pRbuUpdate;
 };
 
@@ -189669,17 +191418,22 @@
     RbuUpdateStmt *pTmp = pUp->pNext;
     sqlite3_finalize(pUp->pUpdate);
     sqlite3_free(pUp);
     pUp = pTmp;
   }
+  sqlite3_free(pIter->aIdxCol);
+  sqlite3_free(pIter->zIdxSql);
 
   pIter->pSelect = 0;
   pIter->pInsert = 0;
   pIter->pDelete = 0;
   pIter->pRbuUpdate = 0;
   pIter->pTmpInsert = 0;
   pIter->nCol = 0;
+  pIter->nIdxCol = 0;
+  pIter->aIdxCol = 0;
+  pIter->zIdxSql = 0;
 }
 
 /*
 ** Clean up any resources allocated as part of the iterator object passed
 ** as the only argument.
@@ -189790,10 +191544,11 @@
   assert( argc==1 || argc==2 );
 
   zIn = (const char*)sqlite3_value_text(argv[0]);
   if( zIn ){
     if( rbuIsVacuum(p) ){
+      assert( argc==2 || argc==1 );
       if( argc==1 || 0==sqlite3_value_int(argv[1]) ){
         sqlite3_result_text(pCtx, zIn, -1, SQLITE_STATIC);
       }
     }else{
       if( strlen(zIn)>4 && memcmp("data", zIn, 4)==0 ){
@@ -189948,18 +191703,19 @@
 ** if the allocation succeeds, (*pRc) is left unchanged.
 */
 static char *rbuStrndup(const char *zStr, int *pRc){
   char *zRet = 0;
 
-  assert( *pRc==SQLITE_OK );
-  if( zStr ){
-    size_t nCopy = strlen(zStr) + 1;
-    zRet = (char*)sqlite3_malloc64(nCopy);
-    if( zRet ){
-      memcpy(zRet, zStr, nCopy);
-    }else{
-      *pRc = SQLITE_NOMEM;
+  if( *pRc==SQLITE_OK ){
+    if( zStr ){
+      size_t nCopy = strlen(zStr) + 1;
+      zRet = (char*)sqlite3_malloc64(nCopy);
+      if( zRet ){
+        memcpy(zRet, zStr, nCopy);
+      }else{
+        *pRc = SQLITE_NOMEM;
+      }
     }
   }
 
   return zRet;
 }
@@ -190127,10 +191883,13 @@
         sqlite3_mprintf("PRAGMA main.index_xinfo = %Q", zIdx)
     );
     while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pXInfo) ){
       int iCid = sqlite3_column_int(pXInfo, 1);
       if( iCid>=0 ) pIter->abIndexed[iCid] = 1;
+      if( iCid==-2 ){
+        memset(pIter->abIndexed, 0x01, sizeof(u8)*pIter->nTblCol);
+      }
     }
     rbuFinalize(p, pXInfo);
     bIndex = 1;
     pIter->nIndex++;
   }
@@ -190241,11 +192000,12 @@
           SWAP(int, pIter->aiSrcOrder[i], pIter->aiSrcOrder[iOrder]);
           SWAP(char*, pIter->azTblCol[i], pIter->azTblCol[iOrder]);
         }
 
         pIter->azTblType[iOrder] = rbuStrndup(zType, &p->rc);
-        pIter->abTblPk[iOrder] = (iPk!=0);
+        assert( iPk>=0 );
+        pIter->abTblPk[iOrder] = (u8)iPk;
         pIter->abNotNull[iOrder] = (u8)bNotNull || (iPk!=0);
         iOrder++;
       }
     }
 
@@ -190276,10 +192036,217 @@
     zSep = ", ";
   }
   return zList;
 }
 
+/*
+** Return a comma separated list of the quoted PRIMARY KEY column names,
+** in order, for the current table. Before each column name, add the text
+** zPre. After each column name, add the zPost text. Use zSeparator as
+** the separator text (usually ", ").
+*/
+static char *rbuObjIterGetPkList(
+  sqlite3rbu *p,                  /* RBU object */
+  RbuObjIter *pIter,              /* Object iterator for column names */
+  const char *zPre,               /* Before each quoted column name */
+  const char *zSeparator,         /* Separator to use between columns */
+  const char *zPost               /* After each quoted column name */
+){
+  int iPk = 1;
+  char *zRet = 0;
+  const char *zSep = "";
+  while( 1 ){
+    int i;
+    for(i=0; i<pIter->nTblCol; i++){
+      if( (int)pIter->abTblPk[i]==iPk ){
+        const char *zCol = pIter->azTblCol[i];
+        zRet = rbuMPrintf(p, "%z%s%s\"%w\"%s", zRet, zSep, zPre, zCol, zPost);
+        zSep = zSeparator;
+        break;
+      }
+    }
+    if( i==pIter->nTblCol ) break;
+    iPk++;
+  }
+  return zRet;
+}
+
+/*
+** This function is called as part of restarting an RBU vacuum within
+** stage 1 of the process (while the *-oal file is being built) while
+** updating a table (not an index). The table may be a rowid table or
+** a WITHOUT ROWID table. It queries the target database to find the
+** largest key that has already been written to the target table and
+** constructs a WHERE clause that can be used to extract the remaining
+** rows from the source table. For a rowid table, the WHERE clause
+** is of the form:
+**
+**     "WHERE _rowid_ > ?"
+**
+** and for WITHOUT ROWID tables:
+**
+**     "WHERE (key1, key2) > (?, ?)"
+**
+** Instead of "?" placeholders, the actual WHERE clauses created by
+** this function contain literal SQL values.
+*/
+static char *rbuVacuumTableStart(
+  sqlite3rbu *p,                  /* RBU handle */
+  RbuObjIter *pIter,              /* RBU iterator object */
+  int bRowid,                     /* True for a rowid table */
+  const char *zWrite              /* Target table name prefix */
+){
+  sqlite3_stmt *pMax = 0;
+  char *zRet = 0;
+  if( bRowid ){
+    p->rc = prepareFreeAndCollectError(p->dbMain, &pMax, &p->zErrmsg,
+        sqlite3_mprintf(
+          "SELECT max(_rowid_) FROM \"%s%w\"", zWrite, pIter->zTbl
+        )
+    );
+    if( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pMax) ){
+      sqlite3_int64 iMax = sqlite3_column_int64(pMax, 0);
+      zRet = rbuMPrintf(p, " WHERE _rowid_ > %lld ", iMax);
+    }
+    rbuFinalize(p, pMax);
+  }else{
+    char *zOrder = rbuObjIterGetPkList(p, pIter, "", ", ", " DESC");
+    char *zSelect = rbuObjIterGetPkList(p, pIter, "quote(", "||','||", ")");
+    char *zList = rbuObjIterGetPkList(p, pIter, "", ", ", "");
+
+    if( p->rc==SQLITE_OK ){
+      p->rc = prepareFreeAndCollectError(p->dbMain, &pMax, &p->zErrmsg,
+          sqlite3_mprintf(
+            "SELECT %s FROM \"%s%w\" ORDER BY %s LIMIT 1",
+                zSelect, zWrite, pIter->zTbl, zOrder
+          )
+      );
+      if( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pMax) ){
+        const char *zVal = (const char*)sqlite3_column_text(pMax, 0);
+        zRet = rbuMPrintf(p, " WHERE (%s) > (%s) ", zList, zVal);
+      }
+      rbuFinalize(p, pMax);
+    }
+
+    sqlite3_free(zOrder);
+    sqlite3_free(zSelect);
+    sqlite3_free(zList);
+  }
+  return zRet;
+}
+
+/*
+** This function is called as part of restating an RBU vacuum when the
+** current operation is writing content to an index. If possible, it
+** queries the target index b-tree for the largest key already written to
+** it, then composes and returns an expression that can be used in a WHERE
+** clause to select the remaining required rows from the source table.
+** It is only possible to return such an expression if:
+**
+**   * The index contains no DESC columns, and
+**   * The last key written to the index before the operation was
+**     suspended does not contain any NULL values.
+**
+** The expression is of the form:
+**
+**   (index-field1, index-field2, ...) > (?, ?, ...)
+**
+** except that the "?" placeholders are replaced with literal values.
+**
+** If the expression cannot be created, NULL is returned. In this case,
+** the caller has to use an OFFSET clause to extract only the required
+** rows from the sourct table, just as it does for an RBU update operation.
+*/
+char *rbuVacuumIndexStart(
+  sqlite3rbu *p,                  /* RBU handle */
+  RbuObjIter *pIter               /* RBU iterator object */
+){
+  char *zOrder = 0;
+  char *zLhs = 0;
+  char *zSelect = 0;
+  char *zVector = 0;
+  char *zRet = 0;
+  int bFailed = 0;
+  const char *zSep = "";
+  int iCol = 0;
+  sqlite3_stmt *pXInfo = 0;
+
+  p->rc = prepareFreeAndCollectError(p->dbMain, &pXInfo, &p->zErrmsg,
+      sqlite3_mprintf("PRAGMA main.index_xinfo = %Q", pIter->zIdx)
+  );
+  while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pXInfo) ){
+    int iCid = sqlite3_column_int(pXInfo, 1);
+    const char *zCollate = (const char*)sqlite3_column_text(pXInfo, 4);
+    const char *zCol;
+    if( sqlite3_column_int(pXInfo, 3) ){
+      bFailed = 1;
+      break;
+    }
+
+    if( iCid<0 ){
+      if( pIter->eType==RBU_PK_IPK ){
+        int i;
+        for(i=0; pIter->abTblPk[i]==0; i++);
+        assert( i<pIter->nTblCol );
+        zCol = pIter->azTblCol[i];
+      }else{
+        zCol = "_rowid_";
+      }
+    }else{
+      zCol = pIter->azTblCol[iCid];
+    }
+
+    zLhs = rbuMPrintf(p, "%z%s \"%w\" COLLATE %Q",
+        zLhs, zSep, zCol, zCollate
+        );
+    zOrder = rbuMPrintf(p, "%z%s \"rbu_imp_%d%w\" COLLATE %Q DESC",
+        zOrder, zSep, iCol, zCol, zCollate
+        );
+    zSelect = rbuMPrintf(p, "%z%s quote(\"rbu_imp_%d%w\")",
+        zSelect, zSep, iCol, zCol
+        );
+    zSep = ", ";
+    iCol++;
+  }
+  rbuFinalize(p, pXInfo);
+  if( bFailed ) goto index_start_out;
+
+  if( p->rc==SQLITE_OK ){
+    sqlite3_stmt *pSel = 0;
+
+    p->rc = prepareFreeAndCollectError(p->dbMain, &pSel, &p->zErrmsg,
+        sqlite3_mprintf("SELECT %s FROM \"rbu_imp_%w\" ORDER BY %s LIMIT 1",
+          zSelect, pIter->zTbl, zOrder
+        )
+    );
+    if( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSel) ){
+      zSep = "";
+      for(iCol=0; iCol<pIter->nCol; iCol++){
+        const char *zQuoted = (const char*)sqlite3_column_text(pSel, iCol);
+        if( zQuoted[0]=='N' ){
+          bFailed = 1;
+          break;
+        }
+        zVector = rbuMPrintf(p, "%z%s%s", zVector, zSep, zQuoted);
+        zSep = ", ";
+      }
+
+      if( !bFailed ){
+        zRet = rbuMPrintf(p, "(%s) > (%s)", zLhs, zVector);
+      }
+    }
+    rbuFinalize(p, pSel);
+  }
+
+ index_start_out:
+  sqlite3_free(zOrder);
+  sqlite3_free(zSelect);
+  sqlite3_free(zVector);
+  sqlite3_free(zLhs);
+  return zRet;
+}
+
 /*
 ** This function is used to create a SELECT list (the list of SQL
 ** expressions that follows a SELECT keyword) for a SELECT statement
 ** used to read from an data_xxx or rbu_tmp_xxx table while updating the
 ** index object currently indicated by the iterator object passed as the
@@ -190330,33 +192297,41 @@
 
   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pXInfo) ){
     int iCid = sqlite3_column_int(pXInfo, 1);
     int bDesc = sqlite3_column_int(pXInfo, 3);
     const char *zCollate = (const char*)sqlite3_column_text(pXInfo, 4);
-    const char *zCol;
+    const char *zCol = 0;
     const char *zType;
 
-    if( iCid<0 ){
-      /* An integer primary key. If the table has an explicit IPK, use
-      ** its name. Otherwise, use "rbu_rowid".  */
-      if( pIter->eType==RBU_PK_IPK ){
-        int i;
-        for(i=0; pIter->abTblPk[i]==0; i++);
-        assert( i<pIter->nTblCol );
-        zCol = pIter->azTblCol[i];
-      }else if( rbuIsVacuum(p) ){
-        zCol = "_rowid_";
+    if( iCid==-2 ){
+      int iSeq = sqlite3_column_int(pXInfo, 0);
+      zRet = sqlite3_mprintf("%z%s(%.*s) COLLATE %Q", zRet, zCom,
+          pIter->aIdxCol[iSeq].nSpan, pIter->aIdxCol[iSeq].zSpan, zCollate
+      );
+      zType = "";
+    }else {
+      if( iCid<0 ){
+        /* An integer primary key. If the table has an explicit IPK, use
+        ** its name. Otherwise, use "rbu_rowid".  */
+        if( pIter->eType==RBU_PK_IPK ){
+          int i;
+          for(i=0; pIter->abTblPk[i]==0; i++);
+          assert( i<pIter->nTblCol );
+          zCol = pIter->azTblCol[i];
+        }else if( rbuIsVacuum(p) ){
+          zCol = "_rowid_";
+        }else{
+          zCol = "rbu_rowid";
+        }
+        zType = "INTEGER";
       }else{
-        zCol = "rbu_rowid";
+        zCol = pIter->azTblCol[iCid];
+        zType = pIter->azTblType[iCid];
       }
-      zType = "INTEGER";
-    }else{
-      zCol = pIter->azTblCol[iCid];
-      zType = pIter->azTblType[iCid];
+      zRet = sqlite3_mprintf("%z%s\"%w\" COLLATE %Q", zRet, zCom,zCol,zCollate);
     }
 
-    zRet = sqlite3_mprintf("%z%s\"%w\" COLLATE %Q", zRet, zCom, zCol, zCollate);
     if( pIter->bUnique==0 || sqlite3_column_int(pXInfo, 5) ){
       const char *zOrder = (bDesc ? " DESC" : "");
       zImpPK = sqlite3_mprintf("%z%s\"rbu_imp_%d%w\"%s",
           zImpPK, zCom, nBind, zCol, zOrder
       );
@@ -190832,34 +192807,65 @@
 static char *rbuObjIterGetIndexWhere(sqlite3rbu *p, RbuObjIter *pIter){
   sqlite3_stmt *pStmt = 0;
   int rc = p->rc;
   char *zRet = 0;
 
+  assert( pIter->zIdxSql==0 && pIter->nIdxCol==0 && pIter->aIdxCol==0 );
+
   if( rc==SQLITE_OK ){
     rc = prepareAndCollectError(p->dbMain, &pStmt, &p->zErrmsg,
         "SELECT trim(sql) FROM sqlite_master WHERE type='index' AND name=?"
     );
   }
   if( rc==SQLITE_OK ){
     int rc2;
     rc = sqlite3_bind_text(pStmt, 1, pIter->zIdx, -1, SQLITE_STATIC);
     if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){
-      const char *zSql = (const char*)sqlite3_column_text(pStmt, 0);
+      char *zSql = (char*)sqlite3_column_text(pStmt, 0);
+      if( zSql ){
+        pIter->zIdxSql = zSql = rbuStrndup(zSql, &rc);
+      }
       if( zSql ){
         int nParen = 0;           /* Number of open parenthesis */
         int i;
+        int iIdxCol = 0;
+        int nIdxAlloc = 0;
         for(i=0; zSql[i]; i++){
           char c = zSql[i];
+
+          /* If necessary, grow the pIter->aIdxCol[] array */
+          if( iIdxCol==nIdxAlloc ){
+            RbuSpan *aIdxCol = (RbuSpan*)sqlite3_realloc(
+                pIter->aIdxCol, (nIdxAlloc+16)*sizeof(RbuSpan)
+            );
+            if( aIdxCol==0 ){
+              rc = SQLITE_NOMEM;
+              break;
+            }
+            pIter->aIdxCol = aIdxCol;
+            nIdxAlloc += 16;
+          }
+
           if( c=='(' ){
+            if( nParen==0 ){
+              assert( iIdxCol==0 );
+              pIter->aIdxCol[0].zSpan = &zSql[i+1];
+            }
             nParen++;
           }
           else if( c==')' ){
             nParen--;
             if( nParen==0 ){
+              int nSpan = &zSql[i] - pIter->aIdxCol[iIdxCol].zSpan;
+              pIter->aIdxCol[iIdxCol++].nSpan = nSpan;
               i++;
               break;
             }
+          }else if( c==',' && nParen==1 ){
+            int nSpan = &zSql[i] - pIter->aIdxCol[iIdxCol].zSpan;
+            pIter->aIdxCol[iIdxCol++].nSpan = nSpan;
+            pIter->aIdxCol[iIdxCol].zSpan = &zSql[i+1];
           }else if( c=='"' || c=='\'' || c=='`' ){
             for(i++; 1; i++){
               if( zSql[i]==c ){
                 if( zSql[i+1]!=c ) break;
                 i++;
@@ -190867,15 +192873,23 @@
             }
           }else if( c=='[' ){
             for(i++; 1; i++){
               if( zSql[i]==']' ) break;
             }
+          }else if( c=='-' && zSql[i+1]=='-' ){
+            for(i=i+2; zSql[i] && zSql[i]!='\n'; i++);
+            if( zSql[i]=='\0' ) break;
+          }else if( c=='/' && zSql[i+1]=='*' ){
+            for(i=i+2; zSql[i] && (zSql[i]!='*' || zSql[i+1]!='/'); i++);
+            if( zSql[i]=='\0' ) break;
+            i++;
           }
         }
         if( zSql[i] ){
           zRet = rbuStrndup(&zSql[i], &rc);
         }
+        pIter->nIdxCol = iIdxCol;
       }
     }
 
     rc2 = sqlite3_finalize(pStmt);
     if( rc==SQLITE_OK ) rc = rc2;
@@ -190916,15 +192930,15 @@
       char *zBind = 0;
       char *zPart = 0;
       int nBind = 0;
 
       assert( pIter->eType!=RBU_PK_VTAB );
+      zPart = rbuObjIterGetIndexWhere(p, pIter);
       zCollist = rbuObjIterGetIndexCols(
           p, pIter, &zImposterCols, &zImposterPK, &zWhere, &nBind
       );
       zBind = rbuObjIterGetBindlist(p, nBind);
-      zPart = rbuObjIterGetIndexWhere(p, pIter);
 
       /* Create the imposter table used to write to this index. */
       sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 0, 1);
       sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 1,tnum);
       rbuMPrintfExec(p, p->dbMain,
@@ -190952,16 +192966,28 @@
 
       /* Create the SELECT statement to read keys in sorted order */
       if( p->rc==SQLITE_OK ){
         char *zSql;
         if( rbuIsVacuum(p) ){
+          char *zStart = 0;
+          if( nOffset ){
+            zStart = rbuVacuumIndexStart(p, pIter);
+            if( zStart ){
+              sqlite3_free(zLimit);
+              zLimit = 0;
+            }
+          }
+
           zSql = sqlite3_mprintf(
-              "SELECT %s, 0 AS rbu_control FROM '%q' %s ORDER BY %s%s",
+              "SELECT %s, 0 AS rbu_control FROM '%q' %s %s %s ORDER BY %s%s",
               zCollist,
               pIter->zDataTbl,
-              zPart, zCollist, zLimit
+              zPart,
+              (zStart ? (zPart ? "AND" : "WHERE") : ""), zStart,
+              zCollist, zLimit
           );
+          sqlite3_free(zStart);
         }else
 
         if( pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_NONE ){
           zSql = sqlite3_mprintf(
               "SELECT %s, rbu_control FROM %s.'rbu_tmp_%q' %s ORDER BY %s%s",
@@ -190980,11 +193006,15 @@
               zPart,
               (zPart ? "AND" : "WHERE"),
               zCollist, zLimit
           );
         }
-        p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz, zSql);
+        if( p->rc==SQLITE_OK ){
+          p->rc = prepareFreeAndCollectError(p->dbRbu,&pIter->pSelect,pz,zSql);
+        }else{
+          sqlite3_free(zSql);
+        }
       }
 
       sqlite3_free(zImposterCols);
       sqlite3_free(zImposterPK);
       sqlite3_free(zWhere);
@@ -191080,22 +193110,46 @@
       }
 
       /* Create the SELECT statement to read keys from data_xxx */
       if( p->rc==SQLITE_OK ){
         const char *zRbuRowid = "";
+        char *zStart = 0;
+        char *zOrder = 0;
         if( bRbuRowid ){
           zRbuRowid = rbuIsVacuum(p) ? ",_rowid_ " : ",rbu_rowid";
         }
-        p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz,
-            sqlite3_mprintf(
-              "SELECT %s,%s rbu_control%s FROM '%q'%s",
-              zCollist,
-              (rbuIsVacuum(p) ? "0 AS " : ""),
-              zRbuRowid,
-              pIter->zDataTbl, zLimit
-            )
-        );
+
+        if( rbuIsVacuum(p) ){
+          if( nOffset ){
+            zStart = rbuVacuumTableStart(p, pIter, bRbuRowid, zWrite);
+            if( zStart ){
+              sqlite3_free(zLimit);
+              zLimit = 0;
+            }
+          }
+          if( bRbuRowid ){
+            zOrder = rbuMPrintf(p, "_rowid_");
+          }else{
+            zOrder = rbuObjIterGetPkList(p, pIter, "", ", ", "");
+          }
+        }
+
+        if( p->rc==SQLITE_OK ){
+          p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz,
+              sqlite3_mprintf(
+                "SELECT %s,%s rbu_control%s FROM '%q'%s %s %s %s",
+                zCollist,
+                (rbuIsVacuum(p) ? "0 AS " : ""),
+                zRbuRowid,
+                pIter->zDataTbl, (zStart ? zStart : ""),
+                (zOrder ? "ORDER BY" : ""), zOrder,
+                zLimit
+              )
+          );
+        }
+        sqlite3_free(zStart);
+        sqlite3_free(zOrder);
       }
 
       sqlite3_free(zWhere);
       sqlite3_free(zOldlist);
       sqlite3_free(zNewlist);
@@ -192406,14 +194460,15 @@
 ){
   sqlite3rbu *p = (sqlite3rbu*)sqlite3_user_data(pCtx);
   sqlite3_stmt *pStmt = 0;
   char *zErrmsg = 0;
   int rc;
+  sqlite3 *db = (rbuIsVacuum(p) ? p->dbRbu : p->dbMain);
 
   assert( nVal==1 );
 
-  rc = prepareFreeAndCollectError(p->dbMain, &pStmt, &zErrmsg,
+  rc = prepareFreeAndCollectError(db, &pStmt, &zErrmsg,
       sqlite3_mprintf("SELECT count(*) FROM sqlite_master "
         "WHERE type='index' AND tbl_name = %Q", sqlite3_value_text(apVal[0]))
   );
   if( rc!=SQLITE_OK ){
     sqlite3_result_error(pCtx, zErrmsg, -1);
@@ -192424,11 +194479,11 @@
     }
     rc = sqlite3_finalize(pStmt);
     if( rc==SQLITE_OK ){
       sqlite3_result_int(pCtx, nIndex);
     }else{
-      sqlite3_result_error(pCtx, sqlite3_errmsg(p->dbMain), -1);
+      sqlite3_result_error(pCtx, sqlite3_errmsg(db), -1);
     }
   }
 
   sqlite3_free(zErrmsg);
 }
@@ -193318,13 +195373,11 @@
         rc = SQLITE_ERROR;
         pRbu->zErrmsg = sqlite3_mprintf("rbu/zipvfs setup error");
       }else if( rc==SQLITE_NOTFOUND ){
         pRbu->pTargetFd = p;
         p->pRbu = pRbu;
-        if( p->openFlags & SQLITE_OPEN_MAIN_DB ){
-          rbuMainlistAdd(p);
-        }
+        rbuMainlistAdd(p);
         if( p->pWalFd ) p->pWalFd->pRbu = pRbu;
         rc = SQLITE_OK;
       }
     }
     return rc;
@@ -193383,14 +195436,11 @@
     ** todo: really, it's not clear why this might occur, as
     ** wal_autocheckpoint ought to be turned off.  */
     if( ofst==WAL_LOCK_CKPT && n==1 ) rc = SQLITE_BUSY;
   }else{
     int bCapture = 0;
-    if( n==1 && (flags & SQLITE_SHM_EXCLUSIVE)
-     && pRbu && pRbu->eStage==RBU_STAGE_CAPTURE
-     && (ofst==WAL_LOCK_WRITE || ofst==WAL_LOCK_CKPT || ofst==WAL_LOCK_READ0)
-    ){
+    if( pRbu && pRbu->eStage==RBU_STAGE_CAPTURE ){
       bCapture = 1;
     }
 
     if( bCapture==0 || 0==(flags & SQLITE_SHM_UNLOCK) ){
       rc = p->pReal->pMethods->xShmLock(p->pReal, ofst, n, flags);
@@ -193419,24 +195469,28 @@
 
   /* If not in RBU_STAGE_OAL, allow this call to pass through. Or, if this
   ** rbu is in the RBU_STAGE_OAL state, use heap memory for *-shm space
   ** instead of a file on disk.  */
   assert( p->openFlags & (SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_TEMP_DB) );
-  if( eStage==RBU_STAGE_OAL || eStage==RBU_STAGE_MOVE ){
-    if( iRegion<=p->nShm ){
-      sqlite3_int64 nByte = (iRegion+1) * sizeof(char*);
-      char **apNew = (char**)sqlite3_realloc64(p->apShm, nByte);
-      if( apNew==0 ){
-        rc = SQLITE_NOMEM;
-      }else{
-        memset(&apNew[p->nShm], 0, sizeof(char*) * (1 + iRegion - p->nShm));
-        p->apShm = apNew;
-        p->nShm = iRegion+1;
-      }
+  if( eStage==RBU_STAGE_OAL ){
+    sqlite3_int64 nByte = (iRegion+1) * sizeof(char*);
+    char **apNew = (char**)sqlite3_realloc64(p->apShm, nByte);
+
+    /* This is an RBU connection that uses its own heap memory for the
+    ** pages of the *-shm file. Since no other process can have run
+    ** recovery, the connection must request *-shm pages in order
+    ** from start to finish.  */
+    assert( iRegion==p->nShm );
+    if( apNew==0 ){
+      rc = SQLITE_NOMEM;
+    }else{
+      memset(&apNew[p->nShm], 0, sizeof(char*) * (1 + iRegion - p->nShm));
+      p->apShm = apNew;
+      p->nShm = iRegion+1;
     }
 
-    if( rc==SQLITE_OK && p->apShm[iRegion]==0 ){
+    if( rc==SQLITE_OK ){
       char *pNew = (char*)sqlite3_malloc64(szRegion);
       if( pNew==0 ){
         rc = SQLITE_NOMEM;
       }else{
         memset(pNew, 0, szRegion);
@@ -193661,11 +195715,12 @@
   **      be intercepted (see the rbuVfsOpen() function) and the *-oal
   **      file opened instead.
   */
   if( rc==SQLITE_OK && flags==SQLITE_ACCESS_EXISTS ){
     rbu_file *pDb = rbuFindMaindb(pRbuVfs, zPath, 1);
-    if( pDb && pDb->pRbu && pDb->pRbu->eStage==RBU_STAGE_OAL ){
+    if( pDb && pDb->pRbu->eStage==RBU_STAGE_OAL ){
+      assert( pDb->pRbu );
       if( *pResOut ){
         rc = SQLITE_CANTOPEN;
       }else{
         sqlite3_int64 sz = 0;
         rc = rbuVfsFileSize(&pDb->base, &sz);
@@ -196654,11 +198709,13 @@
           }
         }
       }
       sqlite3_free((char*)azCol);
       if( bMismatch ){
-        *pzErrMsg = sqlite3_mprintf("table schemas do not match");
+        if( pzErrMsg ){
+          *pzErrMsg = sqlite3_mprintf("table schemas do not match");
+        }
         rc = SQLITE_SCHEMA;
       }
       if( bHasPk==0 ){
         /* Ignore tables with no primary keys */
         goto diff_out;
@@ -196860,16 +198917,16 @@
 **
 ** If successful, return zero. Otherwise, if an OOM condition is encountered,
 ** set *pRc to SQLITE_NOMEM and return non-zero.
 */
 static int sessionBufferGrow(SessionBuffer *p, size_t nByte, int *pRc){
-  if( *pRc==SQLITE_OK && p->nAlloc-p->nBuf<nByte ){
+  if( *pRc==SQLITE_OK && (size_t)(p->nAlloc-p->nBuf)<nByte ){
     u8 *aNew;
     i64 nNew = p->nAlloc ? p->nAlloc : 128;
     do {
       nNew = nNew*2;
-    }while( (nNew-p->nBuf)<nByte );
+    }while( (size_t)(nNew-p->nBuf)<nByte );
 
     aNew = (u8 *)sqlite3_realloc64(p->aBuf, nNew);
     if( 0==aNew ){
       *pRc = SQLITE_NOMEM;
     }else{
@@ -201266,10 +203323,11 @@
   int bColumnsize;                /* "columnsize=" option value (dflt==1) */
   int eDetail;                    /* FTS5_DETAIL_XXX value */
   char *zContentExprlist;
   Fts5Tokenizer *pTok;
   fts5_tokenizer *pTokApi;
+  int bLock;                      /* True when table is preparing statement */
 
   /* Values loaded from the %_config table */
   int iCookie;                    /* Incremented when %_config is modified */
   int pgsz;                       /* Approximate page size used in %_data */
   int nAutomerge;                 /* 'automerge' setting */
@@ -201782,10 +203840,11 @@
 static int sqlite3Fts5ExprNext(Fts5Expr*, i64 iMax);
 static int sqlite3Fts5ExprEof(Fts5Expr*);
 static i64 sqlite3Fts5ExprRowid(Fts5Expr*);
 
 static void sqlite3Fts5ExprFree(Fts5Expr*);
+static int sqlite3Fts5ExprAnd(Fts5Expr **pp1, Fts5Expr *p2);
 
 /* Called during startup to register a UDF with SQLite */
 static int sqlite3Fts5ExprInit(Fts5Global*, sqlite3*);
 
 static int sqlite3Fts5ExprPhraseCount(Fts5Expr*);
@@ -202633,19 +204692,22 @@
   fts5yycoverage[stateno][iLookAhead] = 1;
 #endif
   do{
     i = fts5yy_shift_ofst[stateno];
     assert( i>=0 );
-    /* assert( i+fts5YYNFTS5TOKEN<=(int)fts5YY_NLOOKAHEAD ); */
+    assert( i<=fts5YY_ACTTAB_COUNT );
+    assert( i+fts5YYNFTS5TOKEN<=(int)fts5YY_NLOOKAHEAD );
     assert( iLookAhead!=fts5YYNOCODE );
     assert( iLookAhead < fts5YYNFTS5TOKEN );
     i += iLookAhead;
-    if( i>=fts5YY_NLOOKAHEAD || fts5yy_lookahead[i]!=iLookAhead ){
+    assert( i<(int)fts5YY_NLOOKAHEAD );
+    if( fts5yy_lookahead[i]!=iLookAhead ){
 #ifdef fts5YYFALLBACK
       fts5YYCODETYPE iFallback;            /* Fallback token */
-      if( iLookAhead<sizeof(fts5yyFallback)/sizeof(fts5yyFallback[0])
-             && (iFallback = fts5yyFallback[iLookAhead])!=0 ){
+      assert( iLookAhead<sizeof(fts5yyFallback)/sizeof(fts5yyFallback[0]) );
+      iFallback = fts5yyFallback[iLookAhead];
+      if( iFallback!=0 ){
 #ifndef NDEBUG
         if( fts5yyTraceFILE ){
           fprintf(fts5yyTraceFILE, "%sFALLBACK %s => %s\n",
              fts5yyTracePrompt, fts5yyTokenName[iLookAhead], fts5yyTokenName[iFallback]);
         }
@@ -202656,20 +204718,12 @@
       }
 #endif
 #ifdef fts5YYWILDCARD
       {
         int j = i - iLookAhead + fts5YYWILDCARD;
-        if(
-#if fts5YY_SHIFT_MIN+fts5YYWILDCARD<0
-          j>=0 &&
-#endif
-#if fts5YY_SHIFT_MAX+fts5YYWILDCARD>=fts5YY_ACTTAB_COUNT
-          j<fts5YY_ACTTAB_COUNT &&
-#endif
-          j<(int)(sizeof(fts5yy_lookahead)/sizeof(fts5yy_lookahead[0])) &&
-          fts5yy_lookahead[j]==fts5YYWILDCARD && iLookAhead>0
-        ){
+        assert( j<(int)(sizeof(fts5yy_lookahead)/sizeof(fts5yy_lookahead[0])) );
+        if( fts5yy_lookahead[j]==fts5YYWILDCARD && iLookAhead>0 ){
 #ifndef NDEBUG
           if( fts5yyTraceFILE ){
             fprintf(fts5yyTraceFILE, "%sWILDCARD %s => %s\n",
                fts5yyTracePrompt, fts5yyTokenName[iLookAhead],
                fts5yyTokenName[fts5YYWILDCARD]);
@@ -202679,10 +204733,11 @@
         }
       }
 #endif /* fts5YYWILDCARD */
       return fts5yy_default[stateno];
     }else{
+      assert( i>=0 && i<sizeof(fts5yy_action)/sizeof(fts5yy_action[0]) );
       return fts5yy_action[i];
     }
   }while(1);
 }
 
@@ -203379,13 +205434,12 @@
 ** Return the fallback token corresponding to canonical token iToken, or
 ** 0 if iToken has no fallback.
 */
 static int sqlite3Fts5ParserFallback(int iToken){
 #ifdef fts5YYFALLBACK
-  if( iToken<(int)(sizeof(fts5yyFallback)/sizeof(fts5yyFallback[0])) ){
-    return fts5yyFallback[iToken];
-  }
+  assert( iToken<(int)(sizeof(fts5yyFallback)/sizeof(fts5yyFallback[0])) );
+  return fts5yyFallback[iToken];
 #else
   (void)iToken;
 #endif
   return 0;
 }
@@ -204285,14 +206339,23 @@
     return 1;
   }else{
     i64 iOff = *piOff;
     int iVal;
     fts5FastGetVarint32(a, i, iVal);
-    if( iVal==1 ){
+    if( iVal<=1 ){
+      if( iVal==0 ){
+        *pi = i;
+        return 0;
+      }
       fts5FastGetVarint32(a, i, iVal);
       iOff = ((i64)iVal) << 32;
       fts5FastGetVarint32(a, i, iVal);
+      if( iVal<2 ){
+        /* This is a corrupt record. So stop parsing it here. */
+        *piOff = -1;
+        return 1;
+      }
     }
     *piOff = iOff + ((iVal-2) & 0x7FFFFFFF);
     *pi = i;
     return 0;
   }
@@ -205773,10 +207836,46 @@
     sqlite3_free(p->apExprPhrase);
     sqlite3_free(p);
   }
 }
 
+static int sqlite3Fts5ExprAnd(Fts5Expr **pp1, Fts5Expr *p2){
+  Fts5Parse sParse;
+  memset(&sParse, 0, sizeof(sParse));
+
+  if( *pp1 ){
+    Fts5Expr *p1 = *pp1;
+    int nPhrase = p1->nPhrase + p2->nPhrase;
+
+    p1->pRoot = sqlite3Fts5ParseNode(&sParse, FTS5_AND, p1->pRoot, p2->pRoot,0);
+    p2->pRoot = 0;
+
+    if( sParse.rc==SQLITE_OK ){
+      Fts5ExprPhrase **ap = (Fts5ExprPhrase**)sqlite3_realloc(
+          p1->apExprPhrase, nPhrase * sizeof(Fts5ExprPhrase*)
+      );
+      if( ap==0 ){
+        sParse.rc = SQLITE_NOMEM;
+      }else{
+        int i;
+        memmove(&ap[p2->nPhrase], ap, p1->nPhrase*sizeof(Fts5ExprPhrase*));
+        for(i=0; i<p2->nPhrase; i++){
+          ap[i] = p2->apExprPhrase[i];
+        }
+        p1->nPhrase = nPhrase;
+        p1->apExprPhrase = ap;
+      }
+    }
+    sqlite3_free(p2->apExprPhrase);
+    sqlite3_free(p2);
+  }else{
+    *pp1 = p2;
+  }
+
+  return sParse.rc;
+}
+
 /*
 ** Argument pTerm must be a synonym iterator. Return the current rowid
 ** that it points to.
 */
 static i64 fts5ExprSynonymRowid(Fts5ExprTerm *pTerm, int bDesc, int *pbEof){
@@ -209569,10 +211668,11 @@
         sqlite3_free(pRet);
         pRet = 0;
       }else{
         /* TODO1: Fix this */
         pRet->p[nByte] = 0x00;
+        pRet->p[nByte+1] = 0x00;
         pRet->szLeaf = fts5GetU16(&pRet->p[2]);
       }
     }
     p->rc = rc;
     p->nRead++;
@@ -209591,11 +211691,11 @@
 }
 
 static Fts5Data *fts5LeafRead(Fts5Index *p, i64 iRowid){
   Fts5Data *pRet = fts5DataRead(p, iRowid);
   if( pRet ){
-    if( pRet->szLeaf>pRet->nn ){
+    if( pRet->nn<4 || pRet->szLeaf>pRet->nn ){
       p->rc = FTS5_CORRUPT;
       fts5DataRelease(pRet);
       pRet = 0;
     }
   }
@@ -209871,11 +211971,11 @@
   pData = fts5DataRead(p, FTS5_STRUCTURE_ROWID);
   if( p->rc==SQLITE_OK ){
     /* TODO: Do we need this if the leaf-index is appended? Probably... */
     memset(&pData->p[pData->nn], 0, FTS5_DATA_PADDING);
     p->rc = fts5StructureDecode(pData->p, pData->nn, &iCookie, &pRet);
-    if( p->rc==SQLITE_OK && pConfig->iCookie!=iCookie ){
+    if( p->rc==SQLITE_OK && (pConfig->pgsz==0 || pConfig->iCookie!=iCookie) ){
       p->rc = sqlite3Fts5ConfigLoad(pConfig, iCookie);
     }
     fts5DataRelease(pData);
     if( p->rc!=SQLITE_OK ){
       fts5StructureRelease(pRet);
@@ -213832,29 +215932,37 @@
     /* The maximum size of the output is equal to the sum of the two
     ** input sizes + 1 varint (9 bytes). The extra varint is because if the
     ** first rowid in one input is a large negative number, and the first in
     ** the other a non-negative number, the delta for the non-negative
     ** number will be larger on disk than the literal integer value
-    ** was.  */
-    if( sqlite3Fts5BufferSize(&p->rc, &out, p1->n + p2->n + 9) ) return;
+    ** was.
+    **
+    ** Or, if the input position-lists are corrupt, then the output might
+    ** include up to 2 extra 10-byte positions created by interpreting -1
+    ** (the value PoslistNext64() uses for EOF) as a position and appending
+    ** it to the output. This can happen at most once for each input
+    ** position-list, hence two 10 byte paddings.  */
+    if( sqlite3Fts5BufferSize(&p->rc, &out, p1->n + p2->n + 9+10+10) ) return;
     fts5DoclistIterInit(p1, &i1);
     fts5DoclistIterInit(p2, &i2);
 
     while( 1 ){
       if( i1.iRowid<i2.iRowid ){
         /* Copy entry from i1 */
         fts5MergeAppendDocid(&out, iLastRowid, i1.iRowid);
         fts5BufferSafeAppendBlob(&out, i1.aPoslist, i1.nPoslist+i1.nSize);
         fts5DoclistIterNext(&i1);
         if( i1.aPoslist==0 ) break;
+        assert( out.n<=((i1.aPoslist-p1->p) + (i2.aPoslist-p2->p)+9+10+10) );
       }
       else if( i2.iRowid!=i1.iRowid ){
         /* Copy entry from i2 */
         fts5MergeAppendDocid(&out, iLastRowid, i2.iRowid);
         fts5BufferSafeAppendBlob(&out, i2.aPoslist, i2.nPoslist+i2.nSize);
         fts5DoclistIterNext(&i2);
         if( i2.aPoslist==0 ) break;
+        assert( out.n<=((i1.aPoslist-p1->p) + (i2.aPoslist-p2->p)+9+10+10) );
       }
       else{
         /* Merge the two position lists. */
         i64 iPos1 = 0;
         i64 iPos2 = 0;
@@ -213867,27 +215975,29 @@
 
         i64 iPrev = 0;
         Fts5PoslistWriter writer;
         memset(&writer, 0, sizeof(writer));
 
+        /* See the earlier comment in this function for an explanation of why
+        ** corrupt input position lists might cause the output to consume
+        ** at most 20 bytes of unexpected space. */
         fts5MergeAppendDocid(&out, iLastRowid, i2.iRowid);
         fts5BufferZero(&tmp);
-        sqlite3Fts5BufferSize(&p->rc, &tmp, i1.nPoslist + i2.nPoslist);
+        sqlite3Fts5BufferSize(&p->rc, &tmp, i1.nPoslist + i2.nPoslist + 10 + 10);
         if( p->rc ) break;
 
         sqlite3Fts5PoslistNext64(a1, i1.nPoslist, &iOff1, &iPos1);
         sqlite3Fts5PoslistNext64(a2, i2.nPoslist, &iOff2, &iPos2);
-        assert( iPos1>=0 && iPos2>=0 );
+        assert_nc( iPos1>=0 && iPos2>=0 );
 
         if( iPos1<iPos2 ){
           sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos1);
           sqlite3Fts5PoslistNext64(a1, i1.nPoslist, &iOff1, &iPos1);
         }else{
           sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos2);
           sqlite3Fts5PoslistNext64(a2, i2.nPoslist, &iOff2, &iPos2);
         }
-
         if( iPos1>=0 && iPos2>=0 ){
           while( 1 ){
             if( iPos1<iPos2 ){
               if( iPos1!=iPrev ){
                 sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos1);
@@ -213908,26 +216018,33 @@
             sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos1);
           }
           aCopy = &a1[iOff1];
           nCopy = i1.nPoslist - iOff1;
         }else{
-          assert( iPos2>=0 && iPos2!=iPrev );
+          assert_nc( iPos2>=0 && iPos2!=iPrev );
           sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, iPos2);
           aCopy = &a2[iOff2];
           nCopy = i2.nPoslist - iOff2;
         }
         if( nCopy>0 ){
           fts5BufferSafeAppendBlob(&tmp, aCopy, nCopy);
         }
 
         /* WRITEPOSLISTSIZE */
+        assert_nc( tmp.n<=i1.nPoslist+i2.nPoslist );
+        assert( tmp.n<=i1.nPoslist+i2.nPoslist+10+10 );
+        if( tmp.n>i1.nPoslist+i2.nPoslist ){
+          if( p->rc==SQLITE_OK ) p->rc = FTS5_CORRUPT;
+          break;
+        }
         fts5BufferSafeAppendVarint(&out, tmp.n * 2);
         fts5BufferSafeAppendBlob(&out, tmp.p, tmp.n);
         fts5DoclistIterNext(&i1);
         fts5DoclistIterNext(&i2);
-        assert( out.n<=(p1->n+p2->n+9) );
+        assert_nc( out.n<=(p1->n+p2->n+9) );
         if( i1.aPoslist==0 || i2.aPoslist==0 ) break;
+        assert( out.n<=((i1.aPoslist-p1->p) + (i2.aPoslist-p2->p)+9+10+10) );
       }
     }
 
     if( i1.aPoslist ){
       fts5MergeAppendDocid(&out, iLastRowid, i1.iRowid);
@@ -213935,11 +216052,11 @@
     }
     else if( i2.aPoslist ){
       fts5MergeAppendDocid(&out, iLastRowid, i2.iRowid);
       fts5BufferSafeAppendBlob(&out, i2.aPoslist, i2.aEof - i2.aPoslist);
     }
-    assert( out.n<=(p1->n+p2->n+9) );
+    assert_nc( out.n<=(p1->n+p2->n+9) );
 
     fts5BufferSet(&p->rc, p1, out.n, out.p);
     fts5BufferFree(&tmp);
     fts5BufferFree(&out);
   }
@@ -215918,21 +218035,43 @@
 
 /*
 ** Implementation of the xBestIndex method for FTS5 tables. Within the
 ** WHERE constraint, it searches for the following:
 **
-**   1. A MATCH constraint against the special column.
+**   1. A MATCH constraint against the table column.
 **   2. A MATCH constraint against the "rank" column.
-**   3. An == constraint against the rowid column.
-**   4. A < or <= constraint against the rowid column.
-**   5. A > or >= constraint against the rowid column.
+**   3. A MATCH constraint against some other column.
+**   4. An == constraint against the rowid column.
+**   5. A < or <= constraint against the rowid column.
+**   6. A > or >= constraint against the rowid column.
 **
-** Within the ORDER BY, either:
+** Within the ORDER BY, the following are supported:
 **
 **   5. ORDER BY rank [ASC|DESC]
 **   6. ORDER BY rowid [ASC|DESC]
 **
+** Information for the xFilter call is passed via both the idxNum and
+** idxStr variables. Specifically, idxNum is a bitmask of the following
+** flags used to encode the ORDER BY clause:
+**
+**     FTS5_BI_ORDER_RANK
+**     FTS5_BI_ORDER_ROWID
+**     FTS5_BI_ORDER_DESC
+**
+** idxStr is used to encode data from the WHERE clause. For each argument
+** passed to the xFilter method, the following is appended to idxStr:
+**
+**   Match against table column:            "m"
+**   Match against rank column:             "r"
+**   Match against other column:            "<column-number>"
+**   Equality constraint against the rowid: "="
+**   A < or <= against the rowid:           "<"
+**   A > or >= against the rowid:           ">"
+**
+** This function ensures that there is at most one "r" or "=". And that if
+** there exists an "=" then there is no "<" or ">".
+**
 ** Costs are assigned as follows:
 **
 **  a) If an unusable MATCH operator is present in the WHERE clause, the
 **     cost is unconditionally set to 1e50 (a really big number).
 **
@@ -215956,77 +218095,108 @@
 static int fts5BestIndexMethod(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){
   Fts5Table *pTab = (Fts5Table*)pVTab;
   Fts5Config *pConfig = pTab->pConfig;
   const int nCol = pConfig->nCol;
   int idxFlags = 0;               /* Parameter passed through to xFilter() */
-  int bHasMatch;
-  int iNext;
   int i;
 
-  struct Constraint {
-    int op;                       /* Mask against sqlite3_index_constraint.op */
-    int fts5op;                   /* FTS5 mask for idxFlags */
-    int iCol;                     /* 0==rowid, 1==tbl, 2==rank */
-    int omit;                     /* True to omit this if found */
-    int iConsIndex;               /* Index in pInfo->aConstraint[] */
-  } aConstraint[] = {
-    {SQLITE_INDEX_CONSTRAINT_MATCH|SQLITE_INDEX_CONSTRAINT_EQ,
-                                    FTS5_BI_MATCH,    1, 1, -1},
-    {SQLITE_INDEX_CONSTRAINT_MATCH|SQLITE_INDEX_CONSTRAINT_EQ,
-                                    FTS5_BI_RANK,     2, 1, -1},
-    {SQLITE_INDEX_CONSTRAINT_EQ,    FTS5_BI_ROWID_EQ, 0, 0, -1},
-    {SQLITE_INDEX_CONSTRAINT_LT|SQLITE_INDEX_CONSTRAINT_LE,
-                                    FTS5_BI_ROWID_LE, 0, 0, -1},
-    {SQLITE_INDEX_CONSTRAINT_GT|SQLITE_INDEX_CONSTRAINT_GE,
-                                    FTS5_BI_ROWID_GE, 0, 0, -1},
-  };
+  char *idxStr;
+  int iIdxStr = 0;
+  int iCons = 0;
+
+  int bSeenEq = 0;
+  int bSeenGt = 0;
+  int bSeenLt = 0;
+  int bSeenMatch = 0;
+  int bSeenRank = 0;
 
-  int aColMap[3];
-  aColMap[0] = -1;
-  aColMap[1] = nCol;
-  aColMap[2] = nCol+1;
 
   assert( SQLITE_INDEX_CONSTRAINT_EQ<SQLITE_INDEX_CONSTRAINT_MATCH );
   assert( SQLITE_INDEX_CONSTRAINT_GT<SQLITE_INDEX_CONSTRAINT_MATCH );
   assert( SQLITE_INDEX_CONSTRAINT_LE<SQLITE_INDEX_CONSTRAINT_MATCH );
   assert( SQLITE_INDEX_CONSTRAINT_GE<SQLITE_INDEX_CONSTRAINT_MATCH );
   assert( SQLITE_INDEX_CONSTRAINT_LE<SQLITE_INDEX_CONSTRAINT_MATCH );
 
-  /* Set idxFlags flags for all WHERE clause terms that will be used. */
+  if( pConfig->bLock ){
+    pTab->base.zErrMsg = sqlite3_mprintf(
+        "recursively defined fts5 content table"
+    );
+    return SQLITE_ERROR;
+  }
+
+  idxStr = (char*)sqlite3_malloc(pInfo->nConstraint * 6 + 1);
+  if( idxStr==0 ) return SQLITE_NOMEM;
+  pInfo->idxStr = idxStr;
+  pInfo->needToFreeIdxStr = 1;
+
   for(i=0; i<pInfo->nConstraint; i++){
     struct sqlite3_index_constraint *p = &pInfo->aConstraint[i];
     int iCol = p->iColumn;
-
-    if( (p->op==SQLITE_INDEX_CONSTRAINT_MATCH && iCol>=0 && iCol<=nCol)
-     || (p->op==SQLITE_INDEX_CONSTRAINT_EQ && iCol==nCol)
+    if( p->op==SQLITE_INDEX_CONSTRAINT_MATCH
+     || (p->op==SQLITE_INDEX_CONSTRAINT_EQ && iCol>=nCol)
     ){
       /* A MATCH operator or equivalent */
-      if( p->usable ){
-        idxFlags = (idxFlags & 0xFFFF) | FTS5_BI_MATCH | (iCol << 16);
-        aConstraint[0].iConsIndex = i;
-      }else{
+      if( p->usable==0 || iCol<0 ){
         /* As there exists an unusable MATCH constraint this is an
         ** unusable plan. Set a prohibitively high cost. */
         pInfo->estimatedCost = 1e50;
+        assert( iIdxStr < pInfo->nConstraint*6 + 1 );
+        idxStr[iIdxStr] = 0;
         return SQLITE_OK;
+      }else{
+        if( iCol==nCol+1 ){
+          if( bSeenRank ) continue;
+          idxStr[iIdxStr++] = 'r';
+          bSeenRank = 1;
+        }else{
+          bSeenMatch = 1;
+          idxStr[iIdxStr++] = 'm';
+          if( iCol<nCol ){
+            sqlite3_snprintf(6, &idxStr[iIdxStr], "%d", iCol);
+            idxStr += strlen(&idxStr[iIdxStr]);
+            assert( idxStr[iIdxStr]=='\0' );
+          }
+        }
+        pInfo->aConstraintUsage[i].argvIndex = ++iCons;
+        pInfo->aConstraintUsage[i].omit = 1;
       }
-    }else if( p->op<=SQLITE_INDEX_CONSTRAINT_MATCH ){
-      int j;
-      for(j=1; j<ArraySize(aConstraint); j++){
-        struct Constraint *pC = &aConstraint[j];
-        if( iCol==aColMap[pC->iCol] && (p->op & pC->op) && p->usable ){
-          pC->iConsIndex = i;
-          idxFlags |= pC->fts5op;
+    }
+    else if( p->usable && bSeenEq==0
+      && p->op==SQLITE_INDEX_CONSTRAINT_EQ && iCol<0
+    ){
+      idxStr[iIdxStr++] = '=';
+      bSeenEq = 1;
+      pInfo->aConstraintUsage[i].argvIndex = ++iCons;
+    }
+  }
+
+  if( bSeenEq==0 ){
+    for(i=0; i<pInfo->nConstraint; i++){
+      struct sqlite3_index_constraint *p = &pInfo->aConstraint[i];
+      if( p->iColumn<0 && p->usable ){
+        int op = p->op;
+        if( op==SQLITE_INDEX_CONSTRAINT_LT || op==SQLITE_INDEX_CONSTRAINT_LE ){
+          if( bSeenLt ) continue;
+          idxStr[iIdxStr++] = '<';
+          pInfo->aConstraintUsage[i].argvIndex = ++iCons;
+          bSeenLt = 1;
+        }else
+        if( op==SQLITE_INDEX_CONSTRAINT_GT || op==SQLITE_INDEX_CONSTRAINT_GE ){
+          if( bSeenGt ) continue;
+          idxStr[iIdxStr++] = '>';
+          pInfo->aConstraintUsage[i].argvIndex = ++iCons;
+          bSeenGt = 1;
         }
       }
     }
   }
+  idxStr[iIdxStr] = '\0';
 
   /* Set idxFlags flags for the ORDER BY clause */
   if( pInfo->nOrderBy==1 ){
     int iSort = pInfo->aOrderBy[0].iColumn;
-    if( iSort==(pConfig->nCol+1) && BitFlagTest(idxFlags, FTS5_BI_MATCH) ){
+    if( iSort==(pConfig->nCol+1) && bSeenMatch ){
       idxFlags |= FTS5_BI_ORDER_RANK;
     }else if( iSort==-1 ){
       idxFlags |= FTS5_BI_ORDER_ROWID;
     }
     if( BitFlagTest(idxFlags, FTS5_BI_ORDER_RANK|FTS5_BI_ORDER_ROWID) ){
@@ -216036,30 +218206,19 @@
       }
     }
   }
 
   /* Calculate the estimated cost based on the flags set in idxFlags. */
-  bHasMatch = BitFlagTest(idxFlags, FTS5_BI_MATCH);
-  if( BitFlagTest(idxFlags, FTS5_BI_ROWID_EQ) ){
-    pInfo->estimatedCost = bHasMatch ? 100.0 : 10.0;
-    if( bHasMatch==0 ) fts5SetUniqueFlag(pInfo);
-  }else if( BitFlagAllTest(idxFlags, FTS5_BI_ROWID_LE|FTS5_BI_ROWID_GE) ){
-    pInfo->estimatedCost = bHasMatch ? 500.0 : 250000.0;
-  }else if( BitFlagTest(idxFlags, FTS5_BI_ROWID_LE|FTS5_BI_ROWID_GE) ){
-    pInfo->estimatedCost = bHasMatch ? 750.0 : 750000.0;
+  if( bSeenEq ){
+    pInfo->estimatedCost = bSeenMatch ? 100.0 : 10.0;
+    if( bSeenMatch==0 ) fts5SetUniqueFlag(pInfo);
+  }else if( bSeenLt && bSeenGt ){
+    pInfo->estimatedCost = bSeenMatch ? 500.0 : 250000.0;
+  }else if( bSeenLt || bSeenGt ){
+    pInfo->estimatedCost = bSeenMatch ? 750.0 : 750000.0;
   }else{
-    pInfo->estimatedCost = bHasMatch ? 1000.0 : 1000000.0;
-  }
-
-  /* Assign argvIndex values to each constraint in use. */
-  iNext = 1;
-  for(i=0; i<ArraySize(aConstraint); i++){
-    struct Constraint *pC = &aConstraint[i];
-    if( pC->iConsIndex>=0 ){
-      pInfo->aConstraintUsage[pC->iConsIndex].argvIndex = iNext++;
-      pInfo->aConstraintUsage[pC->iConsIndex].omit = (unsigned char)pC->omit;
-    }
+    pInfo->estimatedCost = bSeenMatch ? 1000.0 : 1000000.0;
   }
 
   pInfo->idxNum = idxFlags;
   return SQLITE_OK;
 }
@@ -216378,11 +218537,11 @@
   ** And since the statement required here reads from this very virtual
   ** table, saving it creates a circular reference.
   **
   ** If SQLite a built-in statement cache, this wouldn't be a problem. */
   rc = fts5PrepareStatement(&pSorter->pStmt, pConfig,
-      "SELECT rowid, rank FROM %Q.%Q ORDER BY %s(%s%s%s) %s",
+      "SELECT rowid, rank FROM %Q.%Q ORDER BY %s(\"%w\"%s%s) %s",
       pConfig->zDb, pConfig->zName, zRank, pConfig->zName,
       (zRankArgs ? ", " : ""),
       (zRankArgs ? zRankArgs : ""),
       bDesc ? "DESC" : "ASC"
   );
@@ -216434,14 +218593,14 @@
   for(n=0; z[n] && z[n]!=' '; n++);
 
   assert( pTab->p.base.zErrMsg==0 );
   pCsr->ePlan = FTS5_PLAN_SPECIAL;
 
-  if( 0==sqlite3_strnicmp("reads", z, n) ){
+  if( n==5 && 0==sqlite3_strnicmp("reads", z, n) ){
     pCsr->iSpecial = sqlite3Fts5IndexReads(pTab->p.pIndex);
   }
-  else if( 0==sqlite3_strnicmp("id", z, n) ){
+  else if( n==2 && 0==sqlite3_strnicmp("id", z, n) ){
     pCsr->iSpecial = pCsr->iCsrId;
   }
   else{
     /* An unrecognized directive. Return an error message. */
     pTab->p.base.zErrMsg = sqlite3_mprintf("unknown special query: %.*s", n, z);
@@ -216578,31 +218737,29 @@
 **   3. A full-table scan.
 */
 static int fts5FilterMethod(
   sqlite3_vtab_cursor *pCursor,   /* The cursor used for this query */
   int idxNum,                     /* Strategy index */
-  const char *zUnused,            /* Unused */
+  const char *idxStr,             /* Unused */
   int nVal,                       /* Number of elements in apVal */
   sqlite3_value **apVal           /* Arguments for the indexing scheme */
 ){
   Fts5FullTable *pTab = (Fts5FullTable*)(pCursor->pVtab);
   Fts5Config *pConfig = pTab->p.pConfig;
   Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;
   int rc = SQLITE_OK;             /* Error code */
-  int iVal = 0;                   /* Counter for apVal[] */
   int bDesc;                      /* True if ORDER BY [rank|rowid] DESC */
   int bOrderByRank;               /* True if ORDER BY rank */
-  sqlite3_value *pMatch = 0;      /* <tbl> MATCH ? expression (or NULL) */
   sqlite3_value *pRank = 0;       /* rank MATCH ? expression (or NULL) */
   sqlite3_value *pRowidEq = 0;    /* rowid = ? expression (or NULL) */
   sqlite3_value *pRowidLe = 0;    /* rowid <= ? expression (or NULL) */
   sqlite3_value *pRowidGe = 0;    /* rowid >= ? expression (or NULL) */
   int iCol;                       /* Column on LHS of MATCH operator */
   char **pzErrmsg = pConfig->pzErrmsg;
-
-  UNUSED_PARAM(zUnused);
-  UNUSED_PARAM(nVal);
+  int i;
+  int iIdxStr = 0;
+  Fts5Expr *pExpr = 0;
 
   if( pCsr->ePlan ){
     fts5FreeCursorComponents(pCsr);
     memset(&pCsr->ePlan, 0, sizeof(Fts5Cursor) - ((u8*)&pCsr->ePlan-(u8*)pCsr));
   }
@@ -216611,27 +218768,64 @@
   assert( pCsr->pExpr==0 );
   assert( pCsr->csrflags==0 );
   assert( pCsr->pRank==0 );
   assert( pCsr->zRank==0 );
   assert( pCsr->zRankArgs==0 );
+  assert( pTab->pSortCsr==0 || nVal==0 );
 
   assert( pzErrmsg==0 || pzErrmsg==&pTab->p.base.zErrMsg );
   pConfig->pzErrmsg = &pTab->p.base.zErrMsg;
 
-  /* Decode the arguments passed through to this function.
-  **
-  ** Note: The following set of if(...) statements must be in the same
-  ** order as the corresponding entries in the struct at the top of
-  ** fts5BestIndexMethod().  */
-  if( BitFlagTest(idxNum, FTS5_BI_MATCH) ) pMatch = apVal[iVal++];
-  if( BitFlagTest(idxNum, FTS5_BI_RANK) ) pRank = apVal[iVal++];
-  if( BitFlagTest(idxNum, FTS5_BI_ROWID_EQ) ) pRowidEq = apVal[iVal++];
-  if( BitFlagTest(idxNum, FTS5_BI_ROWID_LE) ) pRowidLe = apVal[iVal++];
-  if( BitFlagTest(idxNum, FTS5_BI_ROWID_GE) ) pRowidGe = apVal[iVal++];
-  iCol = (idxNum>>16);
-  assert( iCol>=0 && iCol<=pConfig->nCol );
-  assert( iVal==nVal );
+  /* Decode the arguments passed through to this function. */
+  for(i=0; i<nVal; i++){
+    switch( idxStr[iIdxStr++] ){
+      case 'r':
+        pRank = apVal[i];
+        break;
+      case 'm': {
+        const char *zText = (const char*)sqlite3_value_text(apVal[i]);
+        if( zText==0 ) zText = "";
+
+        if( idxStr[iIdxStr]>='0' && idxStr[iIdxStr]<='9' ){
+          iCol = 0;
+          do{
+            iCol = iCol*10 + (idxStr[iIdxStr]-'0');
+            iIdxStr++;
+          }while( idxStr[iIdxStr]>='0' && idxStr[iIdxStr]<='9' );
+        }else{
+          iCol = pConfig->nCol;
+        }
+
+        if( zText[0]=='*' ){
+          /* The user has issued a query of the form "MATCH '*...'". This
+          ** indicates that the MATCH expression is not a full text query,
+          ** but a request for an internal parameter.  */
+          rc = fts5SpecialMatch(pTab, pCsr, &zText[1]);
+          goto filter_out;
+        }else{
+          char **pzErr = &pTab->p.base.zErrMsg;
+          rc = sqlite3Fts5ExprNew(pConfig, iCol, zText, &pExpr, pzErr);
+          if( rc==SQLITE_OK ){
+            rc = sqlite3Fts5ExprAnd(&pCsr->pExpr, pExpr);
+            pExpr = 0;
+          }
+          if( rc!=SQLITE_OK ) goto filter_out;
+        }
+
+        break;
+      }
+      case '=':
+        pRowidEq = apVal[i];
+        break;
+      case '<':
+        pRowidLe = apVal[i];
+        break;
+      default: assert( idxStr[iIdxStr-1]=='>' );
+        pRowidGe = apVal[i];
+        break;
+    }
+  }
   bOrderByRank = ((idxNum & FTS5_BI_ORDER_RANK) ? 1 : 0);
   pCsr->bDesc = bDesc = ((idxNum & FTS5_BI_ORDER_DESC) ? 1 : 0);
 
   /* Set the cursor upper and lower rowid limits. Only some strategies
   ** actually use them. This is ok, as the xBestIndex() method leaves the
@@ -216654,11 +218848,11 @@
     ** set to FTS5_PLAN_SORTED_MATCH). pSortCsr is the cursor that will
     ** return results to the user for this query. The current cursor
     ** (pCursor) is used to execute the query issued by function
     ** fts5CursorFirstSorted() above.  */
     assert( pRowidEq==0 && pRowidLe==0 && pRowidGe==0 && pRank==0 );
-    assert( nVal==0 && pMatch==0 && bOrderByRank==0 && bDesc==0 );
+    assert( nVal==0 && bOrderByRank==0 && bDesc==0 );
     assert( pCsr->iLastRowid==LARGEST_INT64 );
     assert( pCsr->iFirstRowid==SMALLEST_INT64 );
     if( pTab->pSortCsr->bDesc ){
       pCsr->iLastRowid = pTab->pSortCsr->iFirstRowid;
       pCsr->iFirstRowid = pTab->pSortCsr->iLastRowid;
@@ -216667,33 +218861,19 @@
       pCsr->iFirstRowid = pTab->pSortCsr->iFirstRowid;
     }
     pCsr->ePlan = FTS5_PLAN_SOURCE;
     pCsr->pExpr = pTab->pSortCsr->pExpr;
     rc = fts5CursorFirst(pTab, pCsr, bDesc);
-  }else if( pMatch ){
-    const char *zExpr = (const char*)sqlite3_value_text(apVal[0]);
-    if( zExpr==0 ) zExpr = "";
-
+  }else if( pCsr->pExpr ){
     rc = fts5CursorParseRank(pConfig, pCsr, pRank);
     if( rc==SQLITE_OK ){
-      if( zExpr[0]=='*' ){
-        /* The user has issued a query of the form "MATCH '*...'". This
-        ** indicates that the MATCH expression is not a full text query,
-        ** but a request for an internal parameter.  */
-        rc = fts5SpecialMatch(pTab, pCsr, &zExpr[1]);
+      if( bOrderByRank ){
+        pCsr->ePlan = FTS5_PLAN_SORTED_MATCH;
+        rc = fts5CursorFirstSorted(pTab, pCsr, bDesc);
       }else{
-        char **pzErr = &pTab->p.base.zErrMsg;
-        rc = sqlite3Fts5ExprNew(pConfig, iCol, zExpr, &pCsr->pExpr, pzErr);
-        if( rc==SQLITE_OK ){
-          if( bOrderByRank ){
-            pCsr->ePlan = FTS5_PLAN_SORTED_MATCH;
-            rc = fts5CursorFirstSorted(pTab, pCsr, bDesc);
-          }else{
-            pCsr->ePlan = FTS5_PLAN_MATCH;
-            rc = fts5CursorFirst(pTab, pCsr, bDesc);
-          }
-        }
+        pCsr->ePlan = FTS5_PLAN_MATCH;
+        rc = fts5CursorFirst(pTab, pCsr, bDesc);
       }
     }
   }else if( pConfig->zContent==0 ){
     *pConfig->pzErrmsg = sqlite3_mprintf(
         "%s: table does not support scanning", pConfig->zName
@@ -216706,19 +218886,21 @@
     rc = sqlite3Fts5StorageStmt(
         pTab->pStorage, fts5StmtType(pCsr), &pCsr->pStmt, &pTab->p.base.zErrMsg
     );
     if( rc==SQLITE_OK ){
       if( pCsr->ePlan==FTS5_PLAN_ROWID ){
-        sqlite3_bind_value(pCsr->pStmt, 1, apVal[0]);
+        sqlite3_bind_value(pCsr->pStmt, 1, pRowidEq);
       }else{
         sqlite3_bind_int64(pCsr->pStmt, 1, pCsr->iFirstRowid);
         sqlite3_bind_int64(pCsr->pStmt, 2, pCsr->iLastRowid);
       }
       rc = fts5NextMethod(pCursor);
     }
   }
 
+ filter_out:
+  sqlite3Fts5ExprFree(pExpr);
   pConfig->pzErrmsg = pzErrmsg;
   return rc;
 }
 
 /*
@@ -217685,11 +219867,11 @@
   assert( argc>=1 );
   pAux = (Fts5Auxiliary*)sqlite3_user_data(context);
   iCsrId = sqlite3_value_int64(argv[0]);
 
   pCsr = fts5CursorFromCsrid(pAux->pGlobal, iCsrId);
-  if( pCsr==0 ){
+  if( pCsr==0 || pCsr->ePlan==0 ){
     char *zErr = sqlite3_mprintf("no such cursor: %lld", iCsrId);
     sqlite3_result_error(context, zErr, -1);
     sqlite3_free(zErr);
   }else{
     fts5ApiInvoke(pAux, pCsr, context, argc-1, &argv[1]);
@@ -218101,11 +220283,11 @@
   int nArg,                       /* Number of args */
   sqlite3_value **apUnused        /* Function arguments */
 ){
   assert( nArg==0 );
   UNUSED_PARAM2(nArg, apUnused);
-  sqlite3_result_text(pCtx, "fts5: 2019-04-16 19:49:53 884b4b7e502b4e991677b53971277adfaf0a04a284f8e483e2553d0f83156b50", -1, SQLITE_TRANSIENT);
+  sqlite3_result_text(pCtx, "fts5: 2019-10-10 20:19:45 18db032d058f1436ce3dea84081f4ee5a0f2259ad97301d43c426bc7f3df1b0b", -1, SQLITE_TRANSIENT);
 }
 
 /*
 ** Return true if zName is the extension on one of the shadow tables used
 ** by this module.
@@ -218373,11 +220555,13 @@
     if( zSql==0 ){
       rc = SQLITE_NOMEM;
     }else{
       int f = SQLITE_PREPARE_PERSISTENT;
       if( eStmt>FTS5_STMT_LOOKUP ) f |= SQLITE_PREPARE_NO_VTAB;
+      p->pConfig->bLock++;
       rc = sqlite3_prepare_v3(pC->db, zSql, -1, f, &p->aStmt[eStmt], 0);
+      p->pConfig->bLock--;
       sqlite3_free(zSql);
       if( rc!=SQLITE_OK && pzErrMsg ){
         *pzErrMsg = sqlite3_mprintf("%s", sqlite3_errmsg(pC->db));
       }
     }
@@ -222360,12 +224544,14 @@
       }
     }
   }
 
   if( rc==SQLITE_OK && pCsr->bEof==0 && pTab->eType==FTS5_VOCAB_COL ){
-    while( pCsr->aDoc[pCsr->iCol]==0 ) pCsr->iCol++;
-    assert( pCsr->iCol<pCsr->pFts5->pConfig->nCol );
+    for(/* noop */; pCsr->iCol<nCol && pCsr->aDoc[pCsr->iCol]==0; pCsr->iCol++);
+    if( pCsr->iCol==nCol ){
+      rc = FTS5_CORRUPT;
+    }
   }
   return rc;
 }
 
 /*
@@ -222865,12 +225051,12 @@
 }
 #endif /* SQLITE_CORE */
 #endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_STMTVTAB) */
 
 /************** End of stmt.c ************************************************/
-#if __LINE__!=222870
+#if __LINE__!=225056
 #undef SQLITE_SOURCE_ID
-#define SQLITE_SOURCE_ID      "2019-04-16 19:49:53 884b4b7e502b4e991677b53971277adfaf0a04a284f8e483e2553d0f8315alt2"
+#define SQLITE_SOURCE_ID      "2019-10-10 20:19:45 18db032d058f1436ce3dea84081f4ee5a0f2259ad97301d43c426bc7f3dfalt2"
 #endif
 /* Return the source-id for this library */
 SQLITE_API const char *sqlite3_sourceid(void){ return SQLITE_SOURCE_ID; }
 /************************** End of sqlite3.c ******************************/
diff a/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/sqlite3.h b/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/sqlite3.h
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/sqlite3.h
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/sqlite3.h
@@ -121,13 +121,13 @@
 **
 ** See also: [sqlite3_libversion()],
 ** [sqlite3_libversion_number()], [sqlite3_sourceid()],
 ** [sqlite_version()] and [sqlite_source_id()].
 */
-#define SQLITE_VERSION        "3.28.0"
-#define SQLITE_VERSION_NUMBER 3028000
-#define SQLITE_SOURCE_ID      "2019-04-16 19:49:53 884b4b7e502b4e991677b53971277adfaf0a04a284f8e483e2553d0f83156b50"
+#define SQLITE_VERSION        "3.30.1"
+#define SQLITE_VERSION_NUMBER 3030001
+#define SQLITE_SOURCE_ID      "2019-10-10 20:19:45 18db032d058f1436ce3dea84081f4ee5a0f2259ad97301d43c426bc7f3df1b0b"
 
 /*
 ** CAPI3REF: Run-Time Library Version Numbers
 ** KEYWORDS: sqlite3_version sqlite3_sourceid
 **
@@ -1294,12 +1294,18 @@
 **
 ** [[sqlite3_vfs.xAccess]]
 ** ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]
 ** to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to
 ** test whether a file is readable and writable, or [SQLITE_ACCESS_READ]
-** to test whether a file is at least readable.   The file can be a
-** directory.
+** to test whether a file is at least readable.  The SQLITE_ACCESS_READ
+** flag is never actually used and is not implemented in the built-in
+** VFSes of SQLite.  The file is named by the second argument and can be a
+** directory. The xAccess method returns [SQLITE_OK] on success or some
+** non-zero error code if there is an I/O error or if the name of
+** the file given in the second argument is illegal.  If SQLITE_OK
+** is returned, then non-zero or zero is written into *pResOut to indicate
+** whether or not the file is accessible.
 **
 ** ^SQLite will always allocate at least mxPathname+1 bytes for the
 ** output buffer xFullPathname.  The exact size of the output buffer
 ** is also passed as a parameter to both  methods. If the output buffer
 ** is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is
@@ -2085,10 +2091,21 @@
 ** The second parameter is a pointer to an integer into which
 ** is written 0 or 1 to indicate whether triggers are disabled or enabled
 ** following this call.  The second parameter may be a NULL pointer, in
 ** which case the trigger setting is not reported back. </dd>
 **
+** [[SQLITE_DBCONFIG_ENABLE_VIEW]]
+** <dt>SQLITE_DBCONFIG_ENABLE_VIEW</dt>
+** <dd> ^This option is used to enable or disable [CREATE VIEW | views].
+** There should be two additional arguments.
+** The first argument is an integer which is 0 to disable views,
+** positive to enable views or negative to leave the setting unchanged.
+** The second parameter is a pointer to an integer into which
+** is written 0 or 1 to indicate whether views are disabled or enabled
+** following this call.  The second parameter may be a NULL pointer, in
+** which case the view setting is not reported back. </dd>
+**
 ** [[SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER]]
 ** <dt>SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER</dt>
 ** <dd> ^This option is used to enable or disable the
 ** [fts3_tokenizer()] function which is part of the
 ** [FTS3] full-text search engine extension.
@@ -2196,10 +2213,11 @@
 ** flag is enabled, language features that allow ordinary SQL to
 ** deliberately corrupt the database file are disabled.  The disabled
 ** features include but are not limited to the following:
 ** <ul>
 ** <li> The [PRAGMA writable_schema=ON] statement.
+** <li> The [PRAGMA journal_mode=OFF] statement.
 ** <li> Writes to the [sqlite_dbpage] virtual table.
 ** <li> Direct writes to [shadow tables].
 ** </ul>
 ** </dd>
 **
@@ -2211,10 +2229,38 @@
 ** the writable_schema, positive to enable writable_schema, or negative to
 ** leave the setting unchanged. The second parameter is a pointer to an
 ** integer into which is written 0 or 1 to indicate whether the writable_schema
 ** is enabled or disabled following this call.
 ** </dd>
+**
+** [[SQLITE_DBCONFIG_LEGACY_ALTER_TABLE]]
+** <dt>SQLITE_DBCONFIG_LEGACY_ALTER_TABLE</dt>
+** <dd>The SQLITE_DBCONFIG_LEGACY_ALTER_TABLE option activates or deactivates
+** the legacy behavior of the [ALTER TABLE RENAME] command such it
+** behaves as it did prior to [version 3.24.0] (2018-06-04).  See the
+** "Compatibility Notice" on the [ALTER TABLE RENAME documentation] for
+** additional information. This feature can also be turned on and off
+** using the [PRAGMA legacy_alter_table] statement.
+** </dd>
+**
+** [[SQLITE_DBCONFIG_DQS_DML]]
+** <dt>SQLITE_DBCONFIG_DQS_DML</td>
+** <dd>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates
+** the legacy [double-quoted string literal] misfeature for DML statement
+** only, that is DELETE, INSERT, SELECT, and UPDATE statements. The
+** default value of this setting is determined by the [-DSQLITE_DQS]
+** compile-time option.
+** </dd>
+**
+** [[SQLITE_DBCONFIG_DQS_DDL]]
+** <dt>SQLITE_DBCONFIG_DQS_DDL</td>
+** <dd>The SQLITE_DBCONFIG_DQS option activates or deactivates
+** the legacy [double-quoted string literal] misfeature for DDL statements,
+** such as CREATE TABLE and CREATE INDEX. The
+** default value of this setting is determined by the [-DSQLITE_DQS]
+** compile-time option.
+** </dd>
 ** </dl>
 */
 #define SQLITE_DBCONFIG_MAINDBNAME            1000 /* const char* */
 #define SQLITE_DBCONFIG_LOOKASIDE             1001 /* void* int int */
 #define SQLITE_DBCONFIG_ENABLE_FKEY           1002 /* int int* */
@@ -2225,11 +2271,15 @@
 #define SQLITE_DBCONFIG_ENABLE_QPSG           1007 /* int int* */
 #define SQLITE_DBCONFIG_TRIGGER_EQP           1008 /* int int* */
 #define SQLITE_DBCONFIG_RESET_DATABASE        1009 /* int int* */
 #define SQLITE_DBCONFIG_DEFENSIVE             1010 /* int int* */
 #define SQLITE_DBCONFIG_WRITABLE_SCHEMA       1011 /* int int* */
-#define SQLITE_DBCONFIG_MAX                   1011 /* Largest DBCONFIG */
+#define SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    1012 /* int int* */
+#define SQLITE_DBCONFIG_DQS_DML               1013 /* int int* */
+#define SQLITE_DBCONFIG_DQS_DDL               1014 /* int int* */
+#define SQLITE_DBCONFIG_ENABLE_VIEW           1015 /* int int* */
+#define SQLITE_DBCONFIG_MAX                   1015 /* Largest DBCONFIG */
 
 /*
 ** CAPI3REF: Enable Or Disable Extended Result Codes
 ** METHOD: sqlite3
 **
@@ -3774,11 +3824,11 @@
 ** a schema change, on the first  [sqlite3_step()] call following any change
 ** to the [sqlite3_bind_text | bindings] of that [parameter].
 ** ^The specific value of WHERE-clause [parameter] might influence the
 ** choice of query plan if the parameter is the left-hand side of a [LIKE]
 ** or [GLOB] operator or if the parameter is compared to an indexed column
-** and the [SQLITE_ENABLE_STAT3] compile-time option is enabled.
+** and the [SQLITE_ENABLE_STAT4] compile-time option is enabled.
 ** </li>
 ** </ol>
 **
 ** <p>^sqlite3_prepare_v3() differs from sqlite3_prepare_v2() only in having
 ** the extra prepFlags parameter, which is a bit array consisting of zero or
@@ -4809,10 +4859,16 @@
 ** deterministic.  The built-in [random()] SQL function is an example of a
 ** function that is not deterministic.  The SQLite query planner is able to
 ** perform additional optimizations on deterministic functions, so use
 ** of the [SQLITE_DETERMINISTIC] flag is recommended where possible.
 **
+** ^The fourth parameter may also optionally include the [SQLITE_DIRECTONLY]
+** flag, which if present prevents the function from being invoked from
+** within VIEWs or TRIGGERs.  For security reasons, the [SQLITE_DIRECTONLY]
+** flag is recommended for any application-defined SQL function that has
+** side-effects.
+**
 ** ^(The fifth parameter is an arbitrary pointer.  The implementation of the
 ** function can gain access to this pointer using [sqlite3_user_data()].)^
 **
 ** ^The sixth, seventh and eighth parameters passed to the three
 ** "sqlite3_create_function*" functions, xFunc, xStep and xFinal, are
@@ -4925,12 +4981,34 @@
 **
 ** These constants may be ORed together with the
 ** [SQLITE_UTF8 | preferred text encoding] as the fourth argument
 ** to [sqlite3_create_function()], [sqlite3_create_function16()], or
 ** [sqlite3_create_function_v2()].
+**
+** The SQLITE_DETERMINISTIC flag means that the new function will always
+** maps the same inputs into the same output.  The abs() function is
+** deterministic, for example, but randomblob() is not.
+**
+** The SQLITE_DIRECTONLY flag means that the function may only be invoked
+** from top-level SQL, and cannot be used in VIEWs or TRIGGERs.  This is
+** a security feature which is recommended for all
+** [application-defined SQL functions] that have side-effects.  This flag
+** prevents an attacker from adding triggers and views to a schema then
+** tricking a high-privilege application into causing unintended side-effects
+** while performing ordinary queries.
+**
+** The SQLITE_SUBTYPE flag indicates to SQLite that a function may call
+** [sqlite3_value_subtype()] to inspect the sub-types of its arguments.
+** Specifying this flag makes no difference for scalar or aggregate user
+** functions. However, if it is not specified for a user-defined window
+** function, then any sub-types belonging to arguments passed to the window
+** function may be discarded before the window function is called (i.e.
+** sqlite3_value_subtype() will always return 0).
 */
-#define SQLITE_DETERMINISTIC    0x800
+#define SQLITE_DETERMINISTIC    0x000000800
+#define SQLITE_DIRECTONLY       0x000080000
+#define SQLITE_SUBTYPE          0x000100000
 
 /*
 ** CAPI3REF: Deprecated Functions
 ** DEPRECATED
 **
@@ -6572,10 +6650,16 @@
 ** no longer needs the pClientData pointer.  ^The destructor will also
 ** be invoked if the call to sqlite3_create_module_v2() fails.
 ** ^The sqlite3_create_module()
 ** interface is equivalent to sqlite3_create_module_v2() with a NULL
 ** destructor.
+**
+** ^If the third parameter (the pointer to the sqlite3_module object) is
+** NULL then no new module is create and any existing modules with the
+** same name are dropped.
+**
+** See also: [sqlite3_drop_modules()]
 */
 SQLITE_API int sqlite3_create_module(
   sqlite3 *db,               /* SQLite connection to register module with */
   const char *zName,         /* Name of the module */
   const sqlite3_module *p,   /* Methods for the module */
@@ -6587,10 +6671,27 @@
   const sqlite3_module *p,   /* Methods for the module */
   void *pClientData,         /* Client data for xCreate/xConnect */
   void(*xDestroy)(void*)     /* Module destructor function */
 );
 
+/*
+** CAPI3REF: Remove Unnecessary Virtual Table Implementations
+** METHOD: sqlite3
+**
+** ^The sqlite3_drop_modules(D,L) interface removes all virtual
+** table modules from database connection D except those named on list L.
+** The L parameter must be either NULL or a pointer to an array of pointers
+** to strings where the array is terminated by a single NULL pointer.
+** ^If the L parameter is NULL, then all virtual table modules are removed.
+**
+** See also: [sqlite3_create_module()]
+*/
+SQLITE_API int sqlite3_drop_modules(
+  sqlite3 *db,                /* Remove modules from this connection */
+  const char **azKeep         /* Except, do not remove the ones named here */
+);
+
 /*
 ** CAPI3REF: Virtual Table Instance Object
 ** KEYWORDS: sqlite3_vtab
 **
 ** Every [virtual table module] implementation uses a subclass
@@ -7295,11 +7396,11 @@
 ** [sqlite3_test_control()] interface.
 */
 #define SQLITE_TESTCTRL_FIRST                    5
 #define SQLITE_TESTCTRL_PRNG_SAVE                5
 #define SQLITE_TESTCTRL_PRNG_RESTORE             6
-#define SQLITE_TESTCTRL_PRNG_RESET               7
+#define SQLITE_TESTCTRL_PRNG_RESET               7  /* NOT USED */
 #define SQLITE_TESTCTRL_BITVEC_TEST              8
 #define SQLITE_TESTCTRL_FAULT_INSTALL            9
 #define SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS     10
 #define SQLITE_TESTCTRL_PENDING_BYTE            11
 #define SQLITE_TESTCTRL_ASSERT                  12
@@ -7317,11 +7418,14 @@
 #define SQLITE_TESTCTRL_BYTEORDER               22
 #define SQLITE_TESTCTRL_ISINIT                  23
 #define SQLITE_TESTCTRL_SORTER_MMAP             24
 #define SQLITE_TESTCTRL_IMPOSTER                25
 #define SQLITE_TESTCTRL_PARSER_COVERAGE         26
-#define SQLITE_TESTCTRL_LAST                    26  /* Largest TESTCTRL */
+#define SQLITE_TESTCTRL_RESULT_INTREAL          27
+#define SQLITE_TESTCTRL_PRNG_SEED               28
+#define SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS     29
+#define SQLITE_TESTCTRL_LAST                    29  /* Largest TESTCTRL */
 
 /*
 ** CAPI3REF: SQL Keyword Checking
 **
 ** These routines provide access to the set of SQL language keywords
diff a/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/sqlite3ext.h b/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/sqlite3ext.h
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/sqlite3ext.h
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/sqlite3ext.h
@@ -320,10 +320,12 @@
   /* Version 3.26.0 and later */
   const char *(*normalized_sql)(sqlite3_stmt*);
   /* Version 3.28.0 and later */
   int (*stmt_isexplain)(sqlite3_stmt*);
   int (*value_frombind)(sqlite3_value*);
+  /* Version 3.30.0 and later */
+  int (*drop_modules)(sqlite3*,const char**);
 };
 
 /*
 ** This is the function signature used for all extension entry points.  It
 ** is also defined in the file "loadext.c".
@@ -612,10 +614,12 @@
 /* Version 3.26.0 and later */
 #define sqlite3_normalized_sql         sqlite3_api->normalized_sql
 /* Version 3.28.0 and later */
 #define sqlite3_stmt_isexplain         sqlite3_api->isexplain
 #define sqlite3_value_frombind         sqlite3_api->frombind
+/* Version 3.30.0 and later */
+#define sqlite3_drop_modules           sqlite3_api->drop_modules
 #endif /* !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION) */
 
 #if !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION)
   /* This case when the file really is being compiled as a loadable
   ** extension */
