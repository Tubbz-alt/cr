<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderThemeGtk.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2007 Apple Inc.
   3  * Copyright (C) 2007 Alp Toker &lt;alp@atoker.com&gt;
   4  * Copyright (C) 2008 Collabora Ltd.
   5  * Copyright (C) 2009 Kenneth Rohde Christiansen
   6  * Copyright (C) 2010 Igalia S.L.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderThemeGtk.h&quot;
  27 
  28 #include &quot;CSSValueKeywords.h&quot;
  29 #include &quot;FileList.h&quot;
  30 #include &quot;FloatRoundedRect.h&quot;
  31 #include &quot;FontDescription.h&quot;
  32 #include &quot;GRefPtrGtk.h&quot;
  33 #include &quot;GUniquePtrGtk.h&quot;
  34 #include &quot;Gradient.h&quot;
  35 #include &quot;GraphicsContext.h&quot;
  36 #include &quot;HTMLInputElement.h&quot;
  37 #include &quot;HTMLMediaElement.h&quot;
  38 #include &quot;LocalizedStrings.h&quot;
  39 #include &quot;MediaControlElements.h&quot;
  40 #include &quot;Page.h&quot;
  41 #include &quot;PaintInfo.h&quot;
  42 #include &quot;PlatformContextCairo.h&quot;
  43 #include &quot;RenderBox.h&quot;
  44 #include &quot;RenderObject.h&quot;
  45 #include &quot;RenderProgress.h&quot;
  46 #include &quot;RenderThemeWidget.h&quot;
  47 #include &quot;ScrollbarThemeGtk.h&quot;
  48 #include &quot;StringTruncator.h&quot;
  49 #include &quot;TimeRanges.h&quot;
  50 #include &quot;UserAgentScripts.h&quot;
  51 #include &quot;UserAgentStyleSheets.h&quot;
  52 #include &lt;cmath&gt;
  53 #include &lt;gdk/gdk.h&gt;
  54 #include &lt;glib.h&gt;
  55 #include &lt;gtk/gtk.h&gt;
  56 #include &lt;wtf/FileSystem.h&gt;
  57 #include &lt;wtf/glib/GRefPtr.h&gt;
  58 #include &lt;wtf/glib/GUniquePtr.h&gt;
  59 #include &lt;wtf/text/CString.h&gt;
  60 #include &lt;wtf/text/StringBuilder.h&gt;
  61 
  62 namespace WebCore {
  63 
  64 RenderTheme&amp; RenderTheme::singleton()
  65 {
  66     static NeverDestroyed&lt;RenderThemeGtk&gt; theme;
  67     return theme;
  68 }
  69 
  70 static double getScreenDPI()
  71 {
  72     // FIXME: Really this should be the widget&#39;s screen.
  73     GdkScreen* screen = gdk_screen_get_default();
  74     if (!screen)
  75         return 96; // Default to 96 DPI.
  76 
  77     float dpi = gdk_screen_get_resolution(screen);
  78     if (dpi &lt;= 0)
  79         return 96;
  80     return dpi;
  81 }
  82 
  83 void RenderThemeGtk::updateCachedSystemFontDescription(CSSValueID, FontCascadeDescription&amp; fontDescription) const
  84 {
  85     GtkSettings* settings = gtk_settings_get_default();
  86     if (!settings)
  87         return;
  88 
  89     // This will be a font selection string like &quot;Sans 10&quot; so we cannot use it as the family name.
  90     GUniqueOutPtr&lt;gchar&gt; fontName;
  91     g_object_get(settings, &quot;gtk-font-name&quot;, &amp;fontName.outPtr(), nullptr);
  92     if (!fontName || !fontName.get()[0])
  93         return;
  94 
  95     PangoFontDescription* pangoDescription = pango_font_description_from_string(fontName.get());
  96     if (!pangoDescription)
  97         return;
  98 
  99     fontDescription.setOneFamily(pango_font_description_get_family(pangoDescription));
 100 
 101     int size = pango_font_description_get_size(pangoDescription) / PANGO_SCALE;
 102     // If the size of the font is in points, we need to convert it to pixels.
 103     if (!pango_font_description_get_size_is_absolute(pangoDescription))
 104         size = size * (getScreenDPI() / 72.0);
 105 
 106     fontDescription.setSpecifiedSize(size);
 107     fontDescription.setIsAbsoluteSize(true);
 108     fontDescription.setWeight(normalWeightValue());
 109     fontDescription.setItalic(FontSelectionValue());
 110     pango_font_description_free(pangoDescription);
 111 }
 112 
 113 #if ENABLE(DATALIST_ELEMENT)
 114 IntSize RenderThemeGtk::sliderTickSize() const
 115 {
 116     // FIXME: We need to set this to the size of one tick mark.
 117     return IntSize(0, 0);
 118 }
 119 
 120 int RenderThemeGtk::sliderTickOffsetFromTrackCenter() const
 121 {
 122     // FIXME: We need to set this to the position of the tick marks.
 123     return 0;
 124 }
 125 #endif
 126 
 127 static void themeChangedCallback()
 128 {
 129     Page::updateStyleForAllPagesAfterGlobalChangeInEnvironment();
 130 }
 131 
 132 RenderThemeGtk::RenderThemeGtk()
 133 {
 134     static bool themeMonitorInitialized = false;
 135     if (!themeMonitorInitialized) {
 136         GtkSettings* settings = gtk_settings_get_default();
 137         g_signal_connect(settings, &quot;notify::gtk-theme-name&quot;, G_CALLBACK(themeChangedCallback), nullptr);
 138         g_signal_connect(settings, &quot;notify::gtk-color-scheme&quot;, G_CALLBACK(themeChangedCallback), nullptr);
 139         themeMonitorInitialized = true;
 140     }
 141 }
 142 
 143 enum RenderThemePart {
 144     Entry,
 145     EntrySelection,
 146     EntryIconLeft,
 147     EntryIconRight,
 148     Button,
 149     CheckButton,
 150     RadioButton,
 151     ComboBox,
 152     ComboBoxButton,
 153     ComboBoxArrow,
 154     Scale,
 155     ScaleTrough,
 156     ScaleSlider,
 157     ProgressBar,
 158     ProgressBarTrough,
 159     ProgressBarProgress,
 160     ListBox,
 161     SpinButton,
 162     SpinButtonUpButton,
 163     SpinButtonDownButton,
 164 #if ENABLE(VIDEO)
 165     MediaButton,
 166 #endif
 167     Window,
 168 };
 169 
 170 #if ENABLE(VIDEO)
 171 static bool nodeHasPseudo(Node&amp; node, const char* pseudo)
 172 {
 173     return is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(node).pseudo() == pseudo;
 174 }
 175 
 176 static bool nodeHasClass(Node* node, const char* className)
 177 {
 178     if (!is&lt;Element&gt;(*node))
 179         return false;
 180 
 181     Element&amp; element = downcast&lt;Element&gt;(*node);
 182 
 183     if (!element.hasClass())
 184         return false;
 185 
 186     return element.classNames().contains(className);
 187 }
 188 #endif // ENABLE(VIDEO)
 189 
 190 RenderThemeGtk::~RenderThemeGtk() = default;
 191 
 192 static bool supportsFocus(ControlPart appearance)
 193 {
 194     switch (appearance) {
 195     case PushButtonPart:
 196     case ButtonPart:
 197     case TextFieldPart:
 198     case TextAreaPart:
 199     case SearchFieldPart:
 200     case MenulistPart:
 201     case RadioPart:
 202     case CheckboxPart:
 203     case SliderHorizontalPart:
 204     case SliderVerticalPart:
 205         return true;
 206     default:
 207         return false;
 208     }
 209 }
 210 
 211 bool RenderThemeGtk::supportsFocusRing(const RenderStyle&amp; style) const
 212 {
 213     return supportsFocus(style.appearance());
 214 }
 215 
 216 bool RenderThemeGtk::controlSupportsTints(const RenderObject&amp; o) const
 217 {
 218     return isEnabled(o);
 219 }
 220 
 221 int RenderThemeGtk::baselinePosition(const RenderBox&amp; box) const
 222 {
 223     // FIXME: This strategy is possibly incorrect for the GTK+ port.
 224     if (box.style().appearance() == CheckboxPart || box.style().appearance() == RadioPart)
 225         return box.marginTop() + box.height() - 2;
 226     return RenderTheme::baselinePosition(box);
 227 }
 228 
 229 void RenderThemeGtk::adjustRepaintRect(const RenderObject&amp;, FloatRect&amp;)
 230 {
 231 }
 232 static GtkStateFlags themePartStateFlags(const RenderThemeGtk&amp; theme, RenderThemePart themePart, const RenderObject&amp; renderObject)
 233 {
 234     unsigned stateFlags = 0;
 235     switch (renderObject.style().direction()) {
 236     case TextDirection::RTL:
 237         stateFlags |= GTK_STATE_FLAG_DIR_RTL;
 238         break;
 239     case TextDirection::LTR:
 240         stateFlags |= GTK_STATE_FLAG_DIR_LTR;
 241         break;
 242     }
 243 
 244     if (!theme.isEnabled(renderObject) || (themePart == Entry &amp;&amp; theme.isReadOnlyControl(renderObject)))
 245         stateFlags |= GTK_STATE_FLAG_INSENSITIVE;
 246     else {
 247         if (theme.isHovered(renderObject))
 248             stateFlags |= GTK_STATE_FLAG_PRELIGHT;
 249         if (theme.isFocused(renderObject))
 250             stateFlags |= GTK_STATE_FLAG_FOCUSED;
 251     }
 252 
 253     switch (themePart) {
 254     case CheckButton:
 255     case RadioButton:
 256         if (theme.isChecked(renderObject))
 257             stateFlags |= GTK_STATE_FLAG_CHECKED;
 258         if (theme.isIndeterminate(renderObject))
 259             stateFlags |= GTK_STATE_FLAG_INCONSISTENT;
 260         if (theme.isPressed(renderObject))
 261             stateFlags |= GTK_STATE_FLAG_SELECTED;
 262         break;
 263     case Button:
 264     case ComboBoxButton:
 265     case ScaleSlider:
 266     case EntryIconLeft:
 267     case EntryIconRight:
 268 #if ENABLE(VIDEO)
 269     case MediaButton:
 270 #endif
 271         if (theme.isPressed(renderObject))
 272             stateFlags |= GTK_STATE_FLAG_ACTIVE;
 273         break;
 274     case SpinButtonUpButton:
 275         if (theme.isPressed(renderObject) &amp;&amp; theme.isSpinUpButtonPartPressed(renderObject))
 276             stateFlags |= GTK_STATE_FLAG_ACTIVE;
 277         if (theme.isHovered(renderObject) &amp;&amp; !theme.isSpinUpButtonPartHovered(renderObject))
 278             stateFlags &amp;= ~GTK_STATE_FLAG_PRELIGHT;
 279         break;
 280     case SpinButtonDownButton:
 281         if (theme.isPressed(renderObject) &amp;&amp; !theme.isSpinUpButtonPartPressed(renderObject))
 282             stateFlags |= GTK_STATE_FLAG_ACTIVE;
 283         if (theme.isHovered(renderObject) &amp;&amp; theme.isSpinUpButtonPartHovered(renderObject))
 284             stateFlags &amp;= ~GTK_STATE_FLAG_PRELIGHT;
 285         break;
 286     default:
 287         break;
 288     }
 289 
 290     return static_cast&lt;GtkStateFlags&gt;(stateFlags);
 291 }
 292 
 293 void RenderThemeGtk::adjustButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 294 {
 295     // Some layout tests check explicitly that buttons ignore line-height.
 296     if (style.appearance() == PushButtonPart)
 297         style.setLineHeight(RenderStyle::initialLineHeight());
 298 }
 299 
 300 static void shrinkToMinimumSizeAndCenterRectangle(FloatRect&amp; rect, const IntSize&amp; minSize)
 301 {
 302     if (rect.width() &gt; minSize.width()) {
 303         rect.inflateX(-(rect.width() - minSize.width()) / 2);
 304         rect.setWidth(minSize.width()); // In case rect.width() was equal to minSize.width() + 1.
 305     }
 306 
 307     if (rect.height() &gt; minSize.height()) {
 308         rect.inflateY(-(rect.height() - minSize.height()) / 2);
 309         rect.setHeight(minSize.height()); // In case rect.height() was equal to minSize.height() + 1.
 310     }
 311 }
 312 
 313 static void setToggleSize(RenderThemePart themePart, RenderStyle&amp; style)
 314 {
 315     ASSERT(themePart == CheckButton || themePart == RadioButton);
 316 
 317     // The width and height are both specified, so we shouldn&#39;t change them.
 318     if (!style.width().isIntrinsicOrAuto() &amp;&amp; !style.height().isAuto())
 319         return;
 320 
 321     auto&amp; toggleWidget = static_cast&lt;RenderThemeToggleButton&amp;&gt;(RenderThemeWidget::getOrCreate(themePart == CheckButton ? RenderThemeWidget::Type::CheckButton : RenderThemeWidget::Type::RadioButton));
 322     toggleWidget.button().setState(GTK_STATE_FLAG_NORMAL);
 323     toggleWidget.toggle().setState(GTK_STATE_FLAG_NORMAL);
 324     IntSize preferredSize = toggleWidget.button().preferredSize();
 325     preferredSize = preferredSize.expandedTo(toggleWidget.toggle().preferredSize());
 326 
 327     if (style.width().isIntrinsicOrAuto())
 328         style.setWidth(Length(preferredSize.width(), Fixed));
 329 
 330     if (style.height().isAuto())
 331         style.setHeight(Length(preferredSize.height(), Fixed));
 332 }
 333 
 334 static void paintToggle(const RenderThemeGtk* theme, RenderThemePart themePart, const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; fullRect)
 335 {
 336     ASSERT(themePart == CheckButton || themePart == RadioButton);
 337 
 338     auto&amp; toggleWidget = static_cast&lt;RenderThemeToggleButton&amp;&gt;(RenderThemeWidget::getOrCreate(themePart == CheckButton ? RenderThemeWidget::Type::CheckButton : RenderThemeWidget::Type::RadioButton));
 339     auto toggleState = themePartStateFlags(*theme, themePart, renderObject);
 340     toggleWidget.button().setState(toggleState);
 341     toggleWidget.toggle().setState(toggleState);
 342 
 343     FloatRect rect = fullRect;
 344     // Some themes do not render large toggle buttons properly, so we simply
 345     // shrink the rectangle back down to the default size and then center it
 346     // in the full toggle button region. The reason for not simply forcing toggle
 347     // buttons to be a smaller size is that we don&#39;t want to break site layouts.
 348     IntSize preferredSize = toggleWidget.button().preferredSize();
 349     preferredSize = preferredSize.expandedTo(toggleWidget.toggle().preferredSize());
 350     shrinkToMinimumSizeAndCenterRectangle(rect, preferredSize);
 351     toggleWidget.button().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 352     toggleWidget.toggle().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 353 
 354     if (theme-&gt;isFocused(renderObject))
 355         toggleWidget.button().renderFocus(paintInfo.context().platformContext()-&gt;cr(), rect);
 356 }
 357 
 358 void RenderThemeGtk::setCheckboxSize(RenderStyle&amp; style) const
 359 {
 360     setToggleSize(CheckButton, style);
 361 }
 362 
 363 bool RenderThemeGtk::paintCheckbox(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 364 {
 365     paintToggle(this, CheckButton, renderObject, paintInfo, rect);
 366     return false;
 367 }
 368 
 369 void RenderThemeGtk::setRadioSize(RenderStyle&amp; style) const
 370 {
 371     setToggleSize(RadioButton, style);
 372 }
 373 
 374 bool RenderThemeGtk::paintRadio(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 375 {
 376     paintToggle(this, RadioButton, renderObject, paintInfo, rect);
 377     return false;
 378 }
 379 
 380 bool RenderThemeGtk::paintButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 381 {
 382     auto&amp; buttonWidget = static_cast&lt;RenderThemeButton&amp;&gt;(RenderThemeWidget::getOrCreate(isDefault(renderObject) ? RenderThemeWidget::Type::ButtonDefault : RenderThemeWidget::Type::Button));
 383     buttonWidget.button().setState(themePartStateFlags(*this, Button, renderObject));
 384     buttonWidget.button().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 385     if (isFocused(renderObject))
 386         buttonWidget.button().renderFocus(paintInfo.context().platformContext()-&gt;cr(), rect);
 387     return false;
 388 }
 389 
 390 static Color menuListColor(const Element* element)
 391 {
 392     auto&amp; comboWidget = static_cast&lt;RenderThemeComboBox&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ComboBox));
 393     GtkStateFlags state = element-&gt;isDisabledFormControl() ? GTK_STATE_FLAG_INSENSITIVE : GTK_STATE_FLAG_NORMAL;
 394     comboWidget.comboBox().setState(state);
 395     comboWidget.button().setState(state);
 396     return comboWidget.button().color();
 397 }
 398 
 399 void RenderThemeGtk::adjustMenuListStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element* element) const
 400 {
 401     // The tests check explicitly that select menu buttons ignore line height.
 402     style.setLineHeight(RenderStyle::initialLineHeight());
 403 
 404     // We cannot give a proper rendering when border radius is active, unfortunately.
 405     style.resetBorderRadius();
 406 
 407     if (element)
 408         style.setColor(menuListColor(element));
 409 }
 410 
 411 void RenderThemeGtk::adjustMenuListButtonStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element* e) const
 412 {
 413     adjustMenuListStyle(styleResolver, style, e);
 414 }
 415 
 416 /*
 417  * GtkComboBox gadgets tree
 418  *
 419  * combobox
 420  * ├── box.linked
 421  * │   ╰── button.combo
 422  * │       ╰── box
 423  * │           ├── cellview
 424  * │           ╰── arrow
 425  * ╰── window.popup
 426  */
 427 LengthBox RenderThemeGtk::popupInternalPaddingBox(const RenderStyle&amp; style) const
 428 {
 429     if (style.appearance() == NoControlPart)
 430         return LengthBox(0);
 431 
 432     auto&amp; comboWidget = static_cast&lt;RenderThemeComboBox&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ComboBox));
 433     comboWidget.comboBox().setState(GTK_STATE_FLAG_NORMAL);
 434     comboWidget.button().setState(GTK_STATE_FLAG_NORMAL);
 435     comboWidget.arrow().setState(GTK_STATE_FLAG_NORMAL);
 436     GtkBorder comboContentsBox = comboWidget.comboBox().contentsBox();
 437     GtkBorder boxContentsBox = comboWidget.box().contentsBox();
 438     GtkBorder buttonContentsBox = comboWidget.button().contentsBox();
 439     GtkBorder buttonBoxContentsBox = comboWidget.buttonBox().contentsBox();
 440     GtkBorder padding;
 441     padding.left = comboContentsBox.left + boxContentsBox.left + buttonContentsBox.left + buttonBoxContentsBox.left;
 442     padding.right = comboContentsBox.right + boxContentsBox.right + buttonContentsBox.right + buttonBoxContentsBox.right;
 443     padding.top = comboContentsBox.top + boxContentsBox.top + buttonContentsBox.top + buttonBoxContentsBox.top;
 444     padding.bottom = comboContentsBox.bottom + boxContentsBox.bottom + buttonContentsBox.bottom + buttonBoxContentsBox.bottom;
 445 
 446     auto arrowSize = comboWidget.arrow().preferredSize();
 447     return LengthBox(padding.top, padding.right + (style.direction() == TextDirection::LTR ? arrowSize.width() : 0),
 448         padding.bottom, padding.left + (style.direction() == TextDirection::RTL ? arrowSize.width() : 0));
 449 }
 450 
 451 bool RenderThemeGtk::paintMenuList(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
 452 {
 453     auto&amp; comboWidget = static_cast&lt;RenderThemeComboBox&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ComboBox));
 454     auto comboState = themePartStateFlags(*this, ComboBoxButton, renderObject);
 455     comboWidget.comboBox().setState(comboState);
 456     comboWidget.button().setState(comboState);
 457     comboWidget.arrow().setState(comboState);
 458 
 459     cairo_t* cr = paintInfo.context().platformContext()-&gt;cr();
 460     comboWidget.comboBox().render(cr, rect);
 461     comboWidget.box().render(cr, rect);
 462     FloatRect contentsRect;
 463     comboWidget.button().render(cr, rect, &amp;contentsRect);
 464     comboWidget.buttonBox().render(cr, contentsRect);
 465     comboWidget.arrow().render(cr, contentsRect);
 466     if (isFocused(renderObject))
 467         comboWidget.button().renderFocus(cr, rect);
 468 
 469     return false;
 470 }
 471 
 472 bool RenderThemeGtk::paintMenuListButtonDecorations(const RenderBox&amp; object, const PaintInfo&amp; info, const FloatRect&amp; rect)
 473 {
 474     return paintMenuList(object, info, rect);
 475 }
 476 
 477 static IntSize spinButtonSize()
 478 {
 479     auto&amp; spinButtonWidget = static_cast&lt;RenderThemeSpinButton&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SpinButton));
 480     spinButtonWidget.spinButton().setState(GTK_STATE_FLAG_NORMAL);
 481     spinButtonWidget.entry().setState(GTK_STATE_FLAG_NORMAL);
 482     spinButtonWidget.up().setState(GTK_STATE_FLAG_NORMAL);
 483     spinButtonWidget.down().setState(GTK_STATE_FLAG_NORMAL);
 484 
 485     IntSize preferredSize = spinButtonWidget.spinButton().preferredSize();
 486     preferredSize = preferredSize.expandedTo(spinButtonWidget.entry().preferredSize());
 487     IntSize upPreferredSize = preferredSize.expandedTo(spinButtonWidget.up().preferredSize());
 488     IntSize downPreferredSize = preferredSize.expandedTo(spinButtonWidget.down().preferredSize());
 489 
 490     return IntSize(upPreferredSize.width() + downPreferredSize.width(), std::max(upPreferredSize.height(), downPreferredSize.height()));
 491 }
 492 
 493 
 494 void RenderThemeGtk::adjustTextFieldStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element* element) const
 495 {
 496     if (!is&lt;HTMLInputElement&gt;(element) || !shouldHaveSpinButton(downcast&lt;HTMLInputElement&gt;(*element)))
 497         return;
 498 
 499     style.setMinHeight(Length(spinButtonSize().height(), Fixed));
 500 
 501     // The default theme for the GTK+ port uses very wide spin buttons (66px) compared to what other
 502     // browsers use (~13 px). And unfortunately, most of the web developers won&#39;t test how their site
 503     // renders on WebKitGTK. To ensure that spin buttons don&#39;t end up covering the values of the input
 504     // field, we override the width of the input element and always increment it with the width needed
 505     // for the spinbutton (when drawing the spinbutton).
 506     int minimumWidth = style.width().intValue() + spinButtonSize().width();
 507     style.setMinWidth(Length(minimumWidth, Fixed));
 508 }
 509 
 510 bool RenderThemeGtk::paintTextField(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
 511 {
 512     if (is&lt;HTMLInputElement&gt;(renderObject.node()) &amp;&amp; shouldHaveSpinButton(downcast&lt;HTMLInputElement&gt;(*renderObject.node()))) {
 513         auto&amp; spinButtonWidget = static_cast&lt;RenderThemeSpinButton&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SpinButton));
 514         auto spinButtonState = themePartStateFlags(*this, Entry, renderObject);
 515         spinButtonWidget.spinButton().setState(spinButtonState);
 516         spinButtonWidget.entry().setState(spinButtonState);
 517         spinButtonWidget.spinButton().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 518         spinButtonWidget.entry().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 519     } else {
 520         auto&amp; entryWidget = static_cast&lt;RenderThemeEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::Entry));
 521         entryWidget.entry().setState(themePartStateFlags(*this, Entry, renderObject));
 522         entryWidget.entry().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 523 
 524 #if ENABLE(DATALIST_ELEMENT)
 525         if (is&lt;HTMLInputElement&gt;(renderObject.generatingNode())) {
 526             const auto&amp; input = downcast&lt;HTMLInputElement&gt;(*(renderObject.generatingNode()));
 527             if (input.list())
 528                 paintListButtonForInput(renderObject, paintInfo, rect);
 529         }
 530 #endif
 531     }
 532     return false;
 533 }
 534 
 535 static void adjustSearchFieldIconStyle(RenderThemePart themePart, RenderStyle&amp; style)
 536 {
 537     ASSERT(themePart == EntryIconLeft || themePart == EntryIconRight);
 538     auto&amp; searchEntryWidget = static_cast&lt;RenderThemeSearchEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SearchEntry));
 539     searchEntryWidget.entry().setState(GTK_STATE_FLAG_NORMAL);
 540     searchEntryWidget.leftIcon().setState(GTK_STATE_FLAG_NORMAL);
 541     searchEntryWidget.rightIcon().setState(GTK_STATE_FLAG_NORMAL);
 542 
 543     // Get the icon size based on the font size.
 544     auto&amp; icon = static_cast&lt;RenderThemeIconGadget&amp;&gt;(themePart == EntryIconLeft ? searchEntryWidget.leftIcon() : searchEntryWidget.rightIcon());
 545     icon.setIconSize(style.computedFontPixelSize());
 546     IntSize preferredSize = icon.preferredSize();
 547     GtkBorder contentsBox = searchEntryWidget.entry().contentsBox();
 548     if (themePart == EntryIconLeft)
 549         preferredSize.expand(contentsBox.left, contentsBox.top + contentsBox.bottom);
 550     else
 551         preferredSize.expand(contentsBox.right, contentsBox.top + contentsBox.bottom);
 552     style.setWidth(Length(preferredSize.width(), Fixed));
 553     style.setHeight(Length(preferredSize.height(), Fixed));
 554 }
 555 
 556 bool RenderThemeGtk::paintTextArea(const RenderObject&amp; o, const PaintInfo&amp; i, const FloatRect&amp; r)
 557 {
 558     return paintTextField(o, i, r);
 559 }
 560 
 561 void RenderThemeGtk::adjustSearchFieldResultsButtonStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element* e) const
 562 {
 563     adjustSearchFieldCancelButtonStyle(styleResolver, style, e);
 564 }
 565 
 566 bool RenderThemeGtk::paintSearchFieldResultsButton(const RenderBox&amp; o, const PaintInfo&amp; i, const IntRect&amp; rect)
 567 {
 568     return paintSearchFieldResultsDecorationPart(o, i, rect);
 569 }
 570 
 571 void RenderThemeGtk::adjustSearchFieldResultsDecorationPartStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 572 {
 573     adjustSearchFieldIconStyle(EntryIconLeft, style);
 574 }
 575 
 576 void RenderThemeGtk::adjustSearchFieldCancelButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 577 {
 578     adjustSearchFieldIconStyle(EntryIconRight, style);
 579 }
 580 
 581 static bool paintSearchFieldIcon(RenderThemeGtk* theme, RenderThemePart themePart, const RenderBox&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 582 {
 583     ASSERT(themePart == EntryIconLeft || themePart == EntryIconRight);
 584     auto&amp; searchEntryWidget = static_cast&lt;RenderThemeSearchEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SearchEntry));
 585     searchEntryWidget.entry().setState(themePartStateFlags(*theme, Entry, renderObject));
 586     auto&amp; icon = static_cast&lt;RenderThemeIconGadget&amp;&gt;(themePart == EntryIconLeft ? searchEntryWidget.leftIcon() : searchEntryWidget.rightIcon());
 587     icon.setState(themePartStateFlags(*theme, themePart, renderObject));
 588     icon.setIconSize(renderObject.style().computedFontPixelSize());
 589     GtkBorder contentsBox = searchEntryWidget.entry().contentsBox();
 590     IntRect iconRect = rect;
 591     if (themePart == EntryIconLeft) {
 592         iconRect.move(contentsBox.left, contentsBox.top);
 593         iconRect.contract(contentsBox.left, contentsBox.top + contentsBox.bottom);
 594     } else
 595         iconRect.contract(contentsBox.right, contentsBox.top + contentsBox.bottom);
 596     return !icon.render(paintInfo.context().platformContext()-&gt;cr(), iconRect);
 597 }
 598 bool RenderThemeGtk::paintSearchFieldResultsDecorationPart(const RenderBox&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 599 {
 600     return paintSearchFieldIcon(this, EntryIconLeft, renderObject, paintInfo, rect);
 601 }
 602 
 603 bool RenderThemeGtk::paintSearchFieldCancelButton(const RenderBox&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 604 {
 605     return paintSearchFieldIcon(this, EntryIconRight, renderObject, paintInfo, rect);
 606 }
 607 
 608 #if ENABLE(DATALIST_ELEMENT)
 609 void RenderThemeGtk::adjustListButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 610 {
 611     // Add a margin to place the button at end of the input field.
 612     if (style.isLeftToRightDirection())
 613         style.setMarginRight(Length(-4, Fixed));
 614     else
 615         style.setMarginLeft(Length(-4, Fixed));
 616 }
 617 
 618 void RenderThemeGtk::paintListButtonForInput(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
 619 {
 620     // Use a combo box widget to render its arrow.
 621     auto&amp; comboWidget = static_cast&lt;RenderThemeComboBox&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ComboBox));
 622     comboWidget.arrow().setState(themePartStateFlags(*this, ComboBoxButton, renderObject));
 623 
 624     // But a search entry widget to get the contents rect, since this is a text input field.
 625     auto&amp; searchEntryWidget = static_cast&lt;RenderThemeSearchEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SearchEntry));
 626     auto&amp; icon = static_cast&lt;RenderThemeIconGadget&amp;&gt;(searchEntryWidget.rightIcon());
 627     icon.setIconSize(comboWidget.arrow().preferredSize().width());
 628     GtkBorder contentsBox = searchEntryWidget.entry().contentsBox();
 629     FloatRect adjustedRect(rect);
 630     adjustedRect.move(contentsBox.left, contentsBox.top);
 631     adjustedRect.contract(contentsBox.right + 1, contentsBox.top + contentsBox.bottom);
 632     comboWidget.arrow().render(paintInfo.context().platformContext()-&gt;cr(), adjustedRect);
 633 }
 634 #endif
 635 
 636 void RenderThemeGtk::adjustSearchFieldStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 637 {
 638     // We cannot give a proper rendering when border radius is active, unfortunately.
 639     style.resetBorderRadius();
 640     style.setLineHeight(RenderStyle::initialLineHeight());
 641 }
 642 
 643 bool RenderThemeGtk::paintSearchField(const RenderObject&amp; o, const PaintInfo&amp; i, const IntRect&amp; rect)
 644 {
 645     return paintTextField(o, i, rect);
 646 }
 647 
 648 bool RenderThemeGtk::shouldHaveCapsLockIndicator(const HTMLInputElement&amp; element) const
 649 {
 650     return element.isPasswordField();
 651 }
 652 
 653 void RenderThemeGtk::adjustSliderTrackStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 654 {
 655     style.setBoxShadow(nullptr);
 656 }
 657 
 658 void RenderThemeGtk::adjustSliderThumbStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element* element) const
 659 {
 660     RenderTheme::adjustSliderThumbStyle(styleResolver, style, element);
 661     style.setBoxShadow(nullptr);
 662 }
 663 
 664 /*
 665  * GtkScale
 666  *
 667  * scale
 668  * ╰── contents
 669  *     ╰── trough
 670  *         ├── slider
 671  *         ╰── [highlight]
 672  */
 673 bool RenderThemeGtk::paintSliderTrack(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 674 {
 675     ControlPart part = renderObject.style().appearance();
 676     ASSERT(part == SliderHorizontalPart || part == SliderVerticalPart);
 677 
 678     auto&amp; sliderWidget = static_cast&lt;RenderThemeSlider&amp;&gt;(RenderThemeWidget::getOrCreate(part == SliderHorizontalPart ? RenderThemeWidget::Type::HorizontalSlider : RenderThemeWidget::Type::VerticalSlider));
 679     auto scaleState = themePartStateFlags(*this, Scale, renderObject);
 680     auto&amp; scale = sliderWidget.scale();
 681     scale.setState(scaleState);
 682     auto&amp; contents = sliderWidget.contents();
 683     auto&amp; trough = sliderWidget.trough();
 684     trough.setState(scaleState);
 685     auto&amp; slider = sliderWidget.slider();
 686     auto&amp; highlight = sliderWidget.highlight();
 687 
 688     // The given rectangle is not calculated based on the scale size, but all the margins and paddings are based on it.
 689     IntSize preferredSize = scale.preferredSize();
 690     preferredSize = preferredSize.expandedTo(contents.preferredSize());
 691     preferredSize = preferredSize.expandedTo(trough.preferredSize());
 692     FloatRect trackRect = rect;
 693     if (part == SliderHorizontalPart) {
 694         trackRect.move(0, rect.height() / 2 - (preferredSize.height() / 2));
 695         trackRect.setHeight(preferredSize.height());
 696     } else {
 697         trackRect.move(rect.width() / 2 - (preferredSize.width() / 2), 0);
 698         trackRect.setWidth(preferredSize.width());
 699     }
 700 
 701     FloatRect contentsRect;
 702     scale.render(paintInfo.context().platformContext()-&gt;cr(), trackRect, &amp;contentsRect);
 703     contents.render(paintInfo.context().platformContext()-&gt;cr(), contentsRect, &amp;contentsRect);
 704     // Scale trough defines its size querying slider and highlight.
 705     if (part == SliderHorizontalPart)
 706         contentsRect.setHeight(trough.preferredSize().height() + std::max(slider.preferredSize().height(), highlight.preferredSize().height()));
 707     else
 708         contentsRect.setWidth(trough.preferredSize().width() + std::max(slider.preferredSize().width(), highlight.preferredSize().width()));
 709     FloatRect troughRect = contentsRect;
 710     trough.render(paintInfo.context().platformContext()-&gt;cr(), troughRect, &amp;contentsRect);
 711     if (isFocused(renderObject))
 712         trough.renderFocus(paintInfo.context().platformContext()-&gt;cr(), troughRect);
 713 
 714     LayoutPoint thumbLocation;
 715     if (is&lt;HTMLInputElement&gt;(renderObject.node())) {
 716         auto&amp; input = downcast&lt;HTMLInputElement&gt;(*renderObject.node());
 717         if (auto* element = input.sliderThumbElement())
 718             thumbLocation = element-&gt;renderBox()-&gt;location();
 719     }
 720 
 721     if (part == SliderHorizontalPart) {
 722         if (renderObject.style().direction() == TextDirection::RTL) {
 723             contentsRect.move(thumbLocation.x(), 0);
 724             contentsRect.setWidth(contentsRect.width() - thumbLocation.x());
 725         } else
 726             contentsRect.setWidth(thumbLocation.x());
 727     } else
 728         contentsRect.setHeight(thumbLocation.y());
 729     highlight.render(paintInfo.context().platformContext()-&gt;cr(), contentsRect);
 730 
 731     return false;
 732 }
 733 
 734 void RenderThemeGtk::adjustSliderThumbSize(RenderStyle&amp; style, const Element*) const
 735 {
 736     ControlPart part = style.appearance();
 737     if (part != SliderThumbHorizontalPart &amp;&amp; part != SliderThumbVerticalPart)
 738         return;
 739 
 740     auto&amp; sliderWidget = static_cast&lt;RenderThemeSlider&amp;&gt;(RenderThemeWidget::getOrCreate(part == SliderThumbHorizontalPart ? RenderThemeWidget::Type::HorizontalSlider : RenderThemeWidget::Type::VerticalSlider));
 741     sliderWidget.scale().setState(GTK_STATE_FLAG_NORMAL);
 742     sliderWidget.trough().setState(GTK_STATE_FLAG_NORMAL);
 743 
 744     IntSize preferredSize = sliderWidget.scale().preferredSize();
 745     preferredSize = preferredSize.expandedTo(sliderWidget.contents().preferredSize());
 746     preferredSize = preferredSize.expandedTo(sliderWidget.trough().preferredSize());
 747     preferredSize = preferredSize.expandedTo(sliderWidget.slider().preferredSize());
 748     if (part == SliderThumbHorizontalPart) {
 749         style.setWidth(Length(preferredSize.width(), Fixed));
 750         style.setHeight(Length(preferredSize.height(), Fixed));
 751         return;
 752     }
 753     ASSERT(part == SliderThumbVerticalPart);
 754     style.setWidth(Length(preferredSize.height(), Fixed));
 755     style.setHeight(Length(preferredSize.width(), Fixed));
 756 }
 757 
 758 bool RenderThemeGtk::paintSliderThumb(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 759 {
 760     ControlPart part = renderObject.style().appearance();
 761     ASSERT(part == SliderThumbHorizontalPart || part == SliderThumbVerticalPart);
 762 
 763     auto&amp; sliderWidget = static_cast&lt;RenderThemeSlider&amp;&gt;(RenderThemeWidget::getOrCreate(part == SliderThumbHorizontalPart ? RenderThemeWidget::Type::HorizontalSlider : RenderThemeWidget::Type::VerticalSlider));
 764     auto scaleState = themePartStateFlags(*this, Scale, renderObject);
 765     auto&amp; scale = sliderWidget.scale();
 766     scale.setState(scaleState);
 767     auto&amp; contents = sliderWidget.contents();
 768     auto&amp; trough = sliderWidget.trough();
 769     trough.setState(scaleState);
 770     auto&amp; slider = sliderWidget.slider();
 771     slider.setState(themePartStateFlags(*this, ScaleSlider, renderObject));
 772     auto&amp; highlight = sliderWidget.highlight();
 773 
 774     GtkBorder scaleContentsBox = scale.contentsBox();
 775     GtkBorder contentsContentsBox = contents.contentsBox();
 776     GtkBorder troughContentsBox = trough.contentsBox();
 777     GtkBorder padding;
 778     padding.left = scaleContentsBox.left + contentsContentsBox.left + troughContentsBox.left;
 779     padding.right = scaleContentsBox.right + contentsContentsBox.right + troughContentsBox.right;
 780     padding.top = scaleContentsBox.top + contentsContentsBox.top + troughContentsBox.top;
 781     padding.bottom = scaleContentsBox.bottom + contentsContentsBox.bottom + troughContentsBox.bottom;
 782 
 783     // Scale trough defines its size querying slider and highlight.
 784     int troughHeight = trough.preferredSize().height() + std::max(slider.preferredSize().height(), highlight.preferredSize().height());
 785     IntRect sliderRect(rect.location(), IntSize(troughHeight, troughHeight));
 786     sliderRect.move(padding.left, padding.top);
 787     sliderRect.contract(padding.left + padding.right, padding.top + padding.bottom);
 788     slider.render(paintInfo.context().platformContext()-&gt;cr(), sliderRect);
 789     return false;
 790 }
 791 
 792 IntRect RenderThemeGtk::progressBarRectForBounds(const RenderObject&amp; renderObject, const IntRect&amp; bounds) const
 793 {
 794     const auto&amp; renderProgress = downcast&lt;RenderProgress&gt;(renderObject);
 795     auto&amp; progressBarWidget = static_cast&lt;RenderThemeProgressBar&amp;&gt;(RenderThemeWidget::getOrCreate(renderProgress.isDeterminate() ? RenderThemeProgressBar::Type::ProgressBar : RenderThemeProgressBar::Type::IndeterminateProgressBar));
 796     IntSize preferredSize = progressBarWidget.progressBar().preferredSize();
 797     preferredSize = preferredSize.expandedTo(progressBarWidget.trough().preferredSize());
 798     preferredSize = preferredSize.expandedTo(progressBarWidget.progress().preferredSize());
 799     return IntRect(bounds.x(), bounds.y(), bounds.width(), preferredSize.height());
 800 }
 801 
 802 bool RenderThemeGtk::paintProgressBar(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 803 {
 804     if (!renderObject.isProgress())
 805         return true;
 806 
 807     const auto&amp; renderProgress = downcast&lt;RenderProgress&gt;(renderObject);
 808     auto&amp; progressBarWidget = static_cast&lt;RenderThemeProgressBar&amp;&gt;(RenderThemeWidget::getOrCreate(renderProgress.isDeterminate() ? RenderThemeProgressBar::Type::ProgressBar : RenderThemeProgressBar::Type::IndeterminateProgressBar));
 809     progressBarWidget.progressBar().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 810     progressBarWidget.trough().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 811     progressBarWidget.progress().render(paintInfo.context().platformContext()-&gt;cr(), calculateProgressRect(renderObject, rect));
 812     return false;
 813 }
 814 
 815 RenderTheme::InnerSpinButtonLayout RenderThemeGtk::innerSpinButtonLayout(const RenderObject&amp; renderObject) const
 816 {
 817     return renderObject.style().direction() == TextDirection::RTL ? InnerSpinButtonLayout::HorizontalUpLeft : InnerSpinButtonLayout::HorizontalUpRight;
 818 }
 819 
 820 void RenderThemeGtk::adjustInnerSpinButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 821 {
 822     style.setWidth(Length(spinButtonSize().width(), Fixed));
 823     style.setHeight(Length(spinButtonSize().height(), Fixed));
 824 }
 825 
 826 bool RenderThemeGtk::paintInnerSpinButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 827 {
 828     auto&amp; spinButtonWidget = static_cast&lt;RenderThemeSpinButton&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SpinButton));
 829     auto spinButtonState = themePartStateFlags(*this, SpinButton, renderObject);
 830     spinButtonWidget.spinButton().setState(spinButtonState);
 831     spinButtonWidget.entry().setState(spinButtonState);
 832     auto&amp; up = spinButtonWidget.up();
 833     up.setState(themePartStateFlags(*this, SpinButtonUpButton, renderObject));
 834     auto&amp; down = spinButtonWidget.down();
 835     down.setState(themePartStateFlags(*this, SpinButtonDownButton, renderObject));
 836 
 837     IntRect iconRect = rect;
 838     iconRect.setWidth(iconRect.width() / 2);
 839     if (renderObject.style().direction() == TextDirection::RTL)
 840         up.render(paintInfo.context().platformContext()-&gt;cr(), iconRect);
 841     else
 842         down.render(paintInfo.context().platformContext()-&gt;cr(), iconRect);
 843     iconRect.move(iconRect.width(), 0);
 844     if (renderObject.style().direction() == TextDirection::RTL)
 845         down.render(paintInfo.context().platformContext()-&gt;cr(), iconRect);
 846     else
 847         up.render(paintInfo.context().platformContext()-&gt;cr(), iconRect);
 848 
 849     return false;
 850 }
 851 
 852 Seconds RenderThemeGtk::caretBlinkInterval() const
 853 {
 854     GtkSettings* settings = gtk_settings_get_default();
 855 
 856     gboolean shouldBlink;
 857     gint time;
 858 
 859     g_object_get(settings, &quot;gtk-cursor-blink&quot;, &amp;shouldBlink, &quot;gtk-cursor-blink-time&quot;, &amp;time, nullptr);
 860 
 861     if (!shouldBlink)
 862         return 0_s;
 863 
 864     return 500_us * time;
 865 }
 866 
 867 enum StyleColorType { StyleColorBackground, StyleColorForeground };
 868 
 869 static Color styleColor(RenderThemePart themePart, GtkStateFlags state, StyleColorType colorType)
 870 {
 871     RenderThemeGadget* gadget = nullptr;
 872     switch (themePart) {
 873     default:
 874         ASSERT_NOT_REACHED();
 875         FALLTHROUGH;
 876     case Entry:
 877         gadget = &amp;static_cast&lt;RenderThemeEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::Entry)).entry();
 878         break;
 879     case EntrySelection:
 880         gadget = static_cast&lt;RenderThemeEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SelectedEntry)).selection();
 881         break;
 882     case ListBox:
 883         gadget = &amp;static_cast&lt;RenderThemeListView&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ListView)).treeview();
 884         break;
 885     case Button:
 886         gadget = &amp;static_cast&lt;RenderThemeButton&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::Button)).button();
 887         break;
 888     case Window:
 889         gadget = &amp;static_cast&lt;RenderThemeWindow&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::Window)).window();
 890         break;
 891     }
 892 
 893     ASSERT(gadget);
 894     gadget-&gt;setState(state);
 895     return colorType == StyleColorBackground ? gadget-&gt;backgroundColor() : gadget-&gt;color();
 896 }
 897 
 898 Color RenderThemeGtk::platformActiveSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 899 {
 900     return styleColor(EntrySelection, static_cast&lt;GtkStateFlags&gt;(GTK_STATE_FLAG_SELECTED | GTK_STATE_FLAG_FOCUSED), StyleColorBackground);
 901 }
 902 
 903 Color RenderThemeGtk::platformInactiveSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 904 {
 905     return styleColor(EntrySelection, GTK_STATE_FLAG_SELECTED, StyleColorBackground);
 906 }
 907 
 908 Color RenderThemeGtk::platformActiveSelectionForegroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 909 {
 910     return styleColor(EntrySelection, static_cast&lt;GtkStateFlags&gt;(GTK_STATE_FLAG_SELECTED | GTK_STATE_FLAG_FOCUSED), StyleColorForeground);
 911 }
 912 
 913 Color RenderThemeGtk::platformInactiveSelectionForegroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 914 {
 915     return styleColor(EntrySelection, GTK_STATE_FLAG_SELECTED, StyleColorForeground);
 916 }
 917 
 918 Color RenderThemeGtk::platformActiveListBoxSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 919 {
 920     return styleColor(ListBox, static_cast&lt;GtkStateFlags&gt;(GTK_STATE_FLAG_SELECTED | GTK_STATE_FLAG_FOCUSED), StyleColorBackground);
 921 }
 922 
 923 Color RenderThemeGtk::platformInactiveListBoxSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 924 {
 925     return styleColor(ListBox, GTK_STATE_FLAG_SELECTED, StyleColorBackground);
 926 }
 927 
 928 Color RenderThemeGtk::platformActiveListBoxSelectionForegroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 929 {
 930     return styleColor(ListBox, static_cast&lt;GtkStateFlags&gt;(GTK_STATE_FLAG_SELECTED | GTK_STATE_FLAG_FOCUSED), StyleColorForeground);
 931 }
 932 
 933 Color RenderThemeGtk::platformInactiveListBoxSelectionForegroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 934 {
 935     return styleColor(ListBox, GTK_STATE_FLAG_SELECTED, StyleColorForeground);
 936 }
 937 
 938 Color RenderThemeGtk::disabledTextColor(const Color&amp;, const Color&amp;) const
 939 {
 940     return styleColor(Entry, GTK_STATE_FLAG_INSENSITIVE, StyleColorForeground);
 941 }
 942 
 943 Color RenderThemeGtk::systemColor(CSSValueID cssValueId, OptionSet&lt;StyleColor::Options&gt; options) const
 944 {
 945     switch (cssValueId) {
 946     case CSSValueButtontext:
 947         return styleColor(Button, GTK_STATE_FLAG_ACTIVE, StyleColorForeground);
 948     case CSSValueCaptiontext:
 949         return styleColor(Entry, GTK_STATE_FLAG_ACTIVE, StyleColorForeground);
 950     case CSSValueText:
 951         return styleColor(Entry, GTK_STATE_FLAG_ACTIVE, StyleColorForeground);
 952     case CSSValueGraytext:
 953         return styleColor(Entry, GTK_STATE_FLAG_INSENSITIVE, StyleColorForeground);
 954     case CSSValueWebkitControlBackground:
 955         return styleColor(Entry, GTK_STATE_FLAG_ACTIVE, StyleColorBackground);
 956     case CSSValueWindow: {
 957         // Only get window color from the theme in dark mode.
 958         gboolean preferDarkTheme = FALSE;
 959         if (auto* settings = gtk_settings_get_default())
 960             g_object_get(settings, &quot;gtk-application-prefer-dark-theme&quot;, &amp;preferDarkTheme, nullptr);
 961         if (preferDarkTheme)
 962             return styleColor(Window, GTK_STATE_FLAG_ACTIVE, StyleColorBackground);
 963         break;
 964     }
 965     default:
 966         break;
 967     }
 968 
 969     return RenderTheme::systemColor(cssValueId, options);
 970 }
 971 
 972 void RenderThemeGtk::platformColorsDidChange()
 973 {
 974     RenderTheme::platformColorsDidChange();
 975 }
 976 
 977 #if ENABLE(VIDEO)
 978 String RenderThemeGtk::extraMediaControlsStyleSheet()
 979 {
 980     return String(mediaControlsGtkUserAgentStyleSheet, sizeof(mediaControlsGtkUserAgentStyleSheet));
 981 }
 982 
 983 #if ENABLE(FULLSCREEN_API)
 984 String RenderThemeGtk::extraFullScreenStyleSheet()
 985 {
 986     return String();
 987 }
 988 #endif
 989 
 990 bool RenderThemeGtk::paintMediaButton(const RenderObject&amp; renderObject, GraphicsContext&amp; graphicsContext, const IntRect&amp; rect, const char* iconName)
 991 {
 992     auto&amp; iconWidget = static_cast&lt;RenderThemeIcon&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::Icon));
 993     auto&amp; icon = static_cast&lt;RenderThemeIconGadget&amp;&gt;(iconWidget.icon());
 994     icon.setState(themePartStateFlags(*this, MediaButton, renderObject));
 995     icon.setIconSize(RenderThemeIconGadget::IconSizeGtk::Menu);
 996     icon.setIconName(iconName);
 997     return !icon.render(graphicsContext.platformContext()-&gt;cr(), rect);
 998 }
 999 
1000 bool RenderThemeGtk::hasOwnDisabledStateHandlingFor(ControlPart part) const
1001 {
1002     return (part != MediaMuteButtonPart);
1003 }
1004 
1005 bool RenderThemeGtk::paintMediaFullscreenButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1006 {
1007     return paintMediaButton(renderObject, paintInfo.context(), rect, &quot;view-fullscreen-symbolic&quot;);
1008 }
1009 
1010 bool RenderThemeGtk::paintMediaMuteButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1011 {
1012     Node* node = renderObject.node();
1013     if (!node)
1014         return true;
1015     Node* mediaNode = node-&gt;shadowHost();
1016     if (!is&lt;HTMLMediaElement&gt;(mediaNode))
1017         return true;
1018 
1019     HTMLMediaElement* mediaElement = downcast&lt;HTMLMediaElement&gt;(mediaNode);
1020     return paintMediaButton(renderObject, paintInfo.context(), rect, mediaElement-&gt;muted() ? &quot;audio-volume-muted-symbolic&quot; : &quot;audio-volume-high-symbolic&quot;);
1021 }
1022 
1023 bool RenderThemeGtk::paintMediaPlayButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1024 {
1025     Node* node = renderObject.node();
1026     if (!node)
1027         return true;
1028     if (!nodeHasPseudo(*node, &quot;-webkit-media-controls-play-button&quot;))
1029         return true;
1030 
1031     return paintMediaButton(renderObject, paintInfo.context(), rect, nodeHasClass(node, &quot;paused&quot;) ? &quot;media-playback-start-symbolic&quot; : &quot;media-playback-pause-symbolic&quot;);
1032 }
1033 
1034 bool RenderThemeGtk::paintMediaSeekBackButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1035 {
1036     return paintMediaButton(renderObject, paintInfo.context(), rect, &quot;media-seek-backward-symbolic&quot;);
1037 }
1038 
1039 bool RenderThemeGtk::paintMediaSeekForwardButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1040 {
1041     return paintMediaButton(renderObject, paintInfo.context(), rect, &quot;media-seek-forward-symbolic&quot;);
1042 }
1043 
1044 #if ENABLE(VIDEO_TRACK)
1045 bool RenderThemeGtk::paintMediaToggleClosedCaptionsButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1046 {
1047     return paintMediaButton(renderObject, paintInfo.context(), rect, &quot;media-view-subtitles-symbolic&quot;);
1048 }
1049 #endif
1050 
1051 static FloatRoundedRect::Radii borderRadiiFromStyle(const RenderStyle&amp; style)
1052 {
1053     return FloatRoundedRect::Radii(
1054         IntSize(style.borderTopLeftRadius().width.intValue(), style.borderTopLeftRadius().height.intValue()),
1055         IntSize(style.borderTopRightRadius().width.intValue(), style.borderTopRightRadius().height.intValue()),
1056         IntSize(style.borderBottomLeftRadius().width.intValue(), style.borderBottomLeftRadius().height.intValue()),
1057         IntSize(style.borderBottomRightRadius().width.intValue(), style.borderBottomRightRadius().height.intValue()));
1058 }
1059 
1060 bool RenderThemeGtk::paintMediaSliderTrack(const RenderObject&amp; o, const PaintInfo&amp; paintInfo, const IntRect&amp; r)
1061 {
1062     auto mediaElement = parentMediaElement(o);
1063     if (!mediaElement)
1064         return true;
1065 
1066     GraphicsContext&amp; context = paintInfo.context();
1067     context.save();
1068     context.setStrokeStyle(NoStroke);
1069 
1070     float mediaDuration = mediaElement-&gt;duration();
1071     float totalTrackWidth = r.width();
1072     auto&amp; style = o.style();
1073     RefPtr&lt;TimeRanges&gt; timeRanges = mediaElement-&gt;buffered();
1074     for (unsigned index = 0; index &lt; timeRanges-&gt;length(); ++index) {
1075         float start = timeRanges-&gt;start(index).releaseReturnValue();
1076         float end = timeRanges-&gt;end(index).releaseReturnValue();
1077         float startRatio = start / mediaDuration;
1078         float lengthRatio = (end - start) / mediaDuration;
1079         if (!lengthRatio)
1080             continue;
1081 
1082         IntRect rangeRect(r);
1083         rangeRect.setWidth(lengthRatio * totalTrackWidth);
1084         if (index)
1085             rangeRect.move(startRatio * totalTrackWidth, 0);
1086         context.fillRoundedRect(FloatRoundedRect(rangeRect, borderRadiiFromStyle(style)), style.visitedDependentColor(CSSPropertyColor));
1087     }
1088 
1089     context.restore();
1090     return false;
1091 }
1092 
1093 bool RenderThemeGtk::paintMediaSliderThumb(const RenderObject&amp; o, const PaintInfo&amp; paintInfo, const IntRect&amp; r)
1094 {
1095     auto&amp; style = o.style();
1096     paintInfo.context().fillRoundedRect(FloatRoundedRect(r, borderRadiiFromStyle(style)), style.visitedDependentColor(CSSPropertyColor));
1097     return false;
1098 }
1099 
1100 bool RenderThemeGtk::paintMediaVolumeSliderTrack(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1101 {
1102     auto mediaElement = parentMediaElement(renderObject);
1103     if (!mediaElement)
1104         return true;
1105 
1106     float volume = mediaElement-&gt;muted() ? 0.0f : mediaElement-&gt;volume();
1107     if (!volume)
1108         return true;
1109 
1110     GraphicsContext&amp; context = paintInfo.context();
1111     context.save();
1112     context.setStrokeStyle(NoStroke);
1113 
1114     int rectHeight = rect.height();
1115     float trackHeight = rectHeight * volume;
1116     auto&amp; style = renderObject.style();
1117     IntRect volumeRect(rect);
1118     volumeRect.move(0, rectHeight - trackHeight);
1119     volumeRect.setHeight(ceil(trackHeight));
1120 
1121     context.fillRoundedRect(FloatRoundedRect(volumeRect, borderRadiiFromStyle(style)), style.visitedDependentColor(CSSPropertyColor));
1122     context.restore();
1123 
1124     return false;
1125 }
1126 
1127 bool RenderThemeGtk::paintMediaVolumeSliderThumb(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1128 {
1129     return paintMediaSliderThumb(renderObject, paintInfo, rect);
1130 }
1131 
1132 String RenderThemeGtk::formatMediaControlsCurrentTime(float currentTime, float duration) const
1133 {
1134     return formatMediaControlsTime(currentTime) + &quot; / &quot; + formatMediaControlsTime(duration);
1135 }
1136 
1137 bool RenderThemeGtk::paintMediaCurrentTime(const RenderObject&amp;, const PaintInfo&amp;, const IntRect&amp;)
1138 {
1139     return false;
1140 }
1141 #endif
1142 
1143 void RenderThemeGtk::adjustProgressBarStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
1144 {
1145     style.setBoxShadow(nullptr);
1146 }
1147 
1148 // These values have been copied from RenderThemeChromiumSkia.cpp
1149 static const int progressActivityBlocks = 5;
1150 static const int progressAnimationFrames = 10;
1151 static const Seconds progressAnimationInterval { 125_ms };
1152 Seconds RenderThemeGtk::animationRepeatIntervalForProgressBar(RenderProgress&amp;) const
1153 {
1154     return progressAnimationInterval;
1155 }
1156 
1157 Seconds RenderThemeGtk::animationDurationForProgressBar(RenderProgress&amp;) const
1158 {
1159     return progressAnimationInterval * progressAnimationFrames * 2; // &quot;2&quot; for back and forth;
1160 }
1161 
1162 IntRect RenderThemeGtk::calculateProgressRect(const RenderObject&amp; renderObject, const IntRect&amp; fullBarRect)
1163 {
1164     IntRect progressRect(fullBarRect);
1165     const auto&amp; renderProgress = downcast&lt;RenderProgress&gt;(renderObject);
1166     if (renderProgress.isDeterminate()) {
1167         int progressWidth = progressRect.width() * renderProgress.position();
1168         if (renderObject.style().direction() == TextDirection::RTL)
1169             progressRect.setX(progressRect.x() + progressRect.width() - progressWidth);
1170         progressRect.setWidth(progressWidth);
1171         return progressRect;
1172     }
1173 
1174     double animationProgress = renderProgress.animationProgress();
1175 
1176     // Never let the progress rect shrink smaller than 2 pixels.
1177     int newWidth = std::max(2, progressRect.width() / progressActivityBlocks);
1178     int movableWidth = progressRect.width() - newWidth;
1179     progressRect.setWidth(newWidth);
1180 
1181     // We want the first 0.5 units of the animation progress to represent the
1182     // forward motion and the second 0.5 units to represent the backward motion,
1183     // thus we multiply by two here to get the full sweep of the progress bar with
1184     // each direction.
1185     if (animationProgress &lt; 0.5)
1186         progressRect.setX(progressRect.x() + (animationProgress * 2 * movableWidth));
1187     else
1188         progressRect.setX(progressRect.x() + ((1.0 - animationProgress) * 2 * movableWidth));
1189     return progressRect;
1190 }
1191 
1192 String RenderThemeGtk::fileListNameForWidth(const FileList* fileList, const FontCascade&amp; font, int width, bool multipleFilesAllowed) const
1193 {
1194     if (width &lt;= 0)
1195         return String();
1196 
1197     if (fileList-&gt;length() &gt; 1)
1198         return StringTruncator::rightTruncate(multipleFileUploadText(fileList-&gt;length()), width, font);
1199 
1200     String string;
1201     if (fileList-&gt;length())
1202         string = FileSystem::pathGetFileName(fileList-&gt;item(0)-&gt;path());
1203     else if (multipleFilesAllowed)
1204         string = fileButtonNoFilesSelectedLabel();
1205     else
1206         string = fileButtonNoFileSelectedLabel();
1207 
1208     return StringTruncator::centerTruncate(string, width, font);
1209 }
1210 
1211 #if ENABLE(VIDEO)
1212 String RenderThemeGtk::mediaControlsScript()
1213 {
1214     StringBuilder scriptBuilder;
1215     scriptBuilder.appendCharacters(mediaControlsLocalizedStringsJavaScript, sizeof(mediaControlsLocalizedStringsJavaScript));
1216     scriptBuilder.appendCharacters(mediaControlsBaseJavaScript, sizeof(mediaControlsBaseJavaScript));
1217     scriptBuilder.appendCharacters(mediaControlsGtkJavaScript, sizeof(mediaControlsGtkJavaScript));
1218     return scriptBuilder.toString();
1219 }
1220 #endif // ENABLE(VIDEO)
1221 }
    </pre>
  </body>
</html>