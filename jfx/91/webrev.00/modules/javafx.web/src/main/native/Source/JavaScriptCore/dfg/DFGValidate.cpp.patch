diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp
@@ -255,10 +255,12 @@
                 case MakeRope:
                 case ValueAdd:
                 case ValueSub:
                 case ValueMul:
                 case ValueDiv:
+                case ValueMod:
+                case ValuePow:
                 case ArithAdd:
                 case ArithSub:
                 case ArithMul:
                 case ArithIMul:
                 case ArithDiv:
@@ -491,23 +493,23 @@
                         continue;
 
                     VALIDATE(
                         (node, edge),
                         edge->op() == SetLocal
-                        || edge->op() == SetArgument
-                        || edge->op() == Flush
+                        || edge->op() == SetArgumentDefinitely
+                        || edge->op() == SetArgumentMaybe
                         || edge->op() == Phi);
 
                     if (phisInThisBlock.contains(edge.node()))
                         continue;
 
                     if (nodesInThisBlock.contains(edge.node())) {
                         VALIDATE(
                             (node, edge),
                             edge->op() == SetLocal
-                            || edge->op() == SetArgument
-                            || edge->op() == Flush);
+                            || edge->op() == SetArgumentDefinitely
+                            || edge->op() == SetArgumentMaybe);
 
                         continue;
                     }
 
                     // There must exist a predecessor block that has this node index in
@@ -534,11 +536,12 @@
                                      prevNode->shouldGenerate());
                         }
                         VALIDATE(
                             (local, block->predecessors[k], prevNode),
                             prevNode->op() == SetLocal
-                            || prevNode->op() == SetArgument
+                            || prevNode->op() == SetArgumentDefinitely
+                            || prevNode->op() == SetArgumentMaybe
                             || prevNode->op() == Phi);
                         if (prevNode == edge.node()) {
                             found = true;
                             break;
                         }
@@ -664,26 +667,41 @@
                     if (!m_myRefCounts.get(node))
                         break;
                     if (m_graph.m_form == ThreadedCPS) {
                         VALIDATE((node, block), getLocalPositions.operand(node->local()) == notSet);
                         VALIDATE((node, block), !!node->child1());
+                        VALIDATE((node, block), node->child1()->op() == SetArgumentDefinitely || node->child1()->op() == Phi);
                     }
                     getLocalPositions.operand(node->local()) = i;
                     break;
                 case SetLocal:
                     // Only record the first SetLocal. There may be multiple SetLocals
                     // because of flushing.
                     if (setLocalPositions.operand(node->local()) != notSet)
                         break;
                     setLocalPositions.operand(node->local()) = i;
                     break;
-                case SetArgument:
+                case SetArgumentDefinitely:
                     // This acts like a reset. It's ok to have a second GetLocal for a local in the same
-                    // block if we had a SetArgument for that local.
+                    // block if we had a SetArgumentDefinitely for that local.
                     getLocalPositions.operand(node->local()) = notSet;
                     setLocalPositions.operand(node->local()) = notSet;
                     break;
+                case SetArgumentMaybe:
+                    break;
+                case Flush:
+                case PhantomLocal:
+                    if (m_graph.m_form == ThreadedCPS) {
+                        VALIDATE((node, block),
+                            node->child1()->op() == Phi
+                            || node->child1()->op() == SetLocal
+                            || node->child1()->op() == SetArgumentDefinitely
+                            || node->child1()->op() == SetArgumentMaybe);
+                        if (node->op() == PhantomLocal)
+                            VALIDATE((node, block), node->child1()->op() != SetArgumentMaybe);
+                    }
+                    break;
                 default:
                     break;
                 }
             }
 
@@ -697,10 +715,56 @@
             for (size_t i = 0; i < block->variablesAtHead.numberOfLocals(); ++i) {
                 checkOperand(
                     block, getLocalPositions, setLocalPositions, virtualRegisterForLocal(i));
             }
         }
+
+        if (m_graph.m_form == ThreadedCPS) {
+            Vector<Node*> worklist;
+            HashSet<Node*> seen;
+            for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
+                for (Node* node : *block) {
+                    if (node->op() == GetLocal || node->op() == PhantomLocal) {
+                        worklist.append(node);
+                        auto addResult = seen.add(node);
+                        VALIDATE((node, block), addResult.isNewEntry);
+                    }
+                }
+            }
+
+            while (worklist.size()) {
+                Node* node = worklist.takeLast();
+                switch (node->op()) {
+                case PhantomLocal:
+                case GetLocal: {
+                    Node* child = node->child1().node();
+                    if (seen.add(child).isNewEntry)
+                        worklist.append(child);
+                    break;
+                }
+                case Phi: {
+                    for (unsigned i = 0; i < m_graph.numChildren(node); ++i) {
+                        Edge edge = m_graph.child(node, i);
+                        if (!edge)
+                            continue;
+                        if (seen.add(edge.node()).isNewEntry)
+                            worklist.append(edge.node());
+                    }
+                    break;
+                }
+                case SetLocal:
+                case SetArgumentDefinitely:
+                    break;
+                case SetArgumentMaybe:
+                    VALIDATE((node), !"Should not reach SetArgumentMaybe. GetLocal that has data flow that reaches a SetArgumentMaybe is invalid IR.");
+                    break;
+                default:
+                    VALIDATE((node), !"Unexecpted node type.");
+                    break;
+                }
+            }
+        }
     }
 
     void validateSSA()
     {
         // FIXME: Add more things here.
@@ -737,11 +801,12 @@
                     VALIDATE((node), !didSeeExitOK);
                     break;
 
                 case GetLocal:
                 case SetLocal:
-                case SetArgument:
+                case SetArgumentDefinitely:
+                case SetArgumentMaybe:
                 case Phantom:
                     VALIDATE((node), !"bad node type for SSA");
                     break;
 
                 default:
