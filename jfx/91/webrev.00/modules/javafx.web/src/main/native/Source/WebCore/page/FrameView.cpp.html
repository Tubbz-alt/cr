<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1998, 1999 Torben Weis &lt;weis@kde.org&gt;
   3  *                     1999 Lars Knoll &lt;knoll@kde.org&gt;
   4  *                     1999 Antti Koivisto &lt;koivisto@kde.org&gt;
   5  *                     2000 Dirk Mueller &lt;mueller@kde.org&gt;
   6  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   7  *           (C) 2006 Graham Dennis (graham.dennis@gmail.com)
   8  *           (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   9  * Copyright (C) 2009 Google Inc. All rights reserved.
  10  *
  11  * This library is free software; you can redistribute it and/or
  12  * modify it under the terms of the GNU Library General Public
  13  * License as published by the Free Software Foundation; either
  14  * version 2 of the License, or (at your option) any later version.
  15  *
  16  * This library is distributed in the hope that it will be useful,
  17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19  * Library General Public License for more details.
  20  *
  21  * You should have received a copy of the GNU Library General Public License
  22  * along with this library; see the file COPYING.LIB.  If not, write to
  23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24  * Boston, MA 02110-1301, USA.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;FrameView.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;BackForwardController.h&quot;
  32 #include &quot;CSSAnimationController.h&quot;
  33 #include &quot;CachedImage.h&quot;
  34 #include &quot;CachedResourceLoader.h&quot;
  35 #include &quot;Chrome.h&quot;
  36 #include &quot;ChromeClient.h&quot;
  37 #include &quot;CustomHeaderFields.h&quot;
  38 #include &quot;DOMWindow.h&quot;
  39 #include &quot;DebugPageOverlays.h&quot;
  40 #include &quot;DeprecatedGlobalSettings.h&quot;
  41 #include &quot;DocumentLoader.h&quot;
  42 #include &quot;DocumentMarkerController.h&quot;
  43 #include &quot;EventHandler.h&quot;
  44 #include &quot;EventNames.h&quot;
  45 #include &quot;FloatRect.h&quot;
  46 #include &quot;FocusController.h&quot;
  47 #include &quot;Frame.h&quot;
  48 #include &quot;FrameLoader.h&quot;
  49 #include &quot;FrameLoaderClient.h&quot;
  50 #include &quot;FrameSelection.h&quot;
  51 #include &quot;FrameTree.h&quot;
  52 #include &quot;GraphicsContext.h&quot;
  53 #include &quot;HTMLBodyElement.h&quot;
  54 #include &quot;HTMLEmbedElement.h&quot;
  55 #include &quot;HTMLFrameElement.h&quot;
  56 #include &quot;HTMLFrameSetElement.h&quot;
  57 #include &quot;HTMLHtmlElement.h&quot;
  58 #include &quot;HTMLIFrameElement.h&quot;
  59 #include &quot;HTMLNames.h&quot;
  60 #include &quot;HTMLObjectElement.h&quot;
  61 #include &quot;HTMLParserIdioms.h&quot;
  62 #include &quot;HTMLPlugInImageElement.h&quot;
  63 #include &quot;ImageDocument.h&quot;
  64 #include &quot;InspectorClient.h&quot;
  65 #include &quot;InspectorController.h&quot;
  66 #include &quot;InspectorInstrumentation.h&quot;
  67 #include &quot;Logging.h&quot;
  68 #include &quot;MemoryCache.h&quot;
  69 #include &quot;OverflowEvent.h&quot;
  70 #include &quot;Page.h&quot;
  71 #include &quot;PageCache.h&quot;
  72 #include &quot;PageOverlayController.h&quot;
  73 #include &quot;ProgressTracker.h&quot;
  74 #include &quot;RenderEmbeddedObject.h&quot;
  75 #include &quot;RenderFullScreen.h&quot;
  76 #include &quot;RenderIFrame.h&quot;
  77 #include &quot;RenderInline.h&quot;
  78 #include &quot;RenderLayer.h&quot;
  79 #include &quot;RenderLayerBacking.h&quot;
  80 #include &quot;RenderLayerCompositor.h&quot;
  81 #include &quot;RenderSVGRoot.h&quot;
  82 #include &quot;RenderScrollbar.h&quot;
  83 #include &quot;RenderScrollbarPart.h&quot;
  84 #include &quot;RenderStyle.h&quot;
  85 #include &quot;RenderText.h&quot;
  86 #include &quot;RenderTheme.h&quot;
  87 #include &quot;RenderView.h&quot;
  88 #include &quot;RenderWidget.h&quot;
  89 #include &quot;ResizeObserver.h&quot;
  90 #include &quot;RuntimeEnabledFeatures.h&quot;
  91 #include &quot;SVGDocument.h&quot;
  92 #include &quot;SVGSVGElement.h&quot;
  93 #include &quot;ScriptRunner.h&quot;
  94 #include &quot;ScriptedAnimationController.h&quot;
  95 #include &quot;ScrollAnimator.h&quot;
  96 #include &quot;ScrollingCoordinator.h&quot;
  97 #include &quot;Settings.h&quot;
  98 #include &quot;StyleResolver.h&quot;
  99 #include &quot;StyleScope.h&quot;
 100 #include &quot;TextResourceDecoder.h&quot;
 101 #include &quot;TiledBacking.h&quot;
 102 #include &quot;VelocityData.h&quot;
 103 #include &quot;VisualViewport.h&quot;
 104 #include &quot;WheelEventTestTrigger.h&quot;
 105 #include &lt;wtf/text/TextStream.h&gt;
 106 
 107 #include &lt;wtf/IsoMallocInlines.h&gt;
 108 #include &lt;wtf/MemoryPressureHandler.h&gt;
 109 #include &lt;wtf/Ref.h&gt;
 110 #include &lt;wtf/SetForScope.h&gt;
 111 #include &lt;wtf/SystemTracing.h&gt;
 112 
 113 #if USE(COORDINATED_GRAPHICS)
 114 #include &quot;TiledBackingStore.h&quot;
 115 #endif
 116 
 117 #if ENABLE(CSS_SCROLL_SNAP)
 118 #include &quot;AxisScrollSnapOffsets.h&quot;
 119 #endif
 120 
 121 #if PLATFORM(IOS_FAMILY)
 122 #include &quot;DocumentLoader.h&quot;
 123 #include &quot;LegacyTileCache.h&quot;
 124 #endif
 125 
 126 #if PLATFORM(MAC)
 127 #include &quot;LocalDefaultSystemAppearance.h&quot;
 128 #endif
 129 
 130 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(frame().page() &amp;&amp; frame().page()-&gt;isAlwaysOnLoggingAllowed(), Layout, &quot;%p - FrameView::&quot; fmt, this, ##__VA_ARGS__)
 131 
 132 namespace WebCore {
 133 
 134 using namespace HTMLNames;
 135 
 136 WTF_MAKE_ISO_ALLOCATED_IMPL(FrameView);
 137 
 138 MonotonicTime FrameView::sCurrentPaintTimeStamp { };
 139 
 140 // The maximum number of updateEmbeddedObjects iterations that should be done before returning.
 141 static const unsigned maxUpdateEmbeddedObjectsIterations = 2;
 142 
 143 static constexpr unsigned defaultSignificantRenderedTextCharacterThreshold = 3000;
 144 static constexpr float defaultSignificantRenderedTextMeanLength = 50;
 145 static constexpr unsigned mainArticleSignificantRenderedTextCharacterThreshold = 1500;
 146 static constexpr float mainArticleSignificantRenderedTextMeanLength = 25;
 147 
 148 Pagination::Mode paginationModeForRenderStyle(const RenderStyle&amp; style)
 149 {
 150     Overflow overflow = style.overflowY();
 151     if (overflow != Overflow::PagedX &amp;&amp; overflow != Overflow::PagedY)
 152         return Pagination::Unpaginated;
 153 
 154     bool isHorizontalWritingMode = style.isHorizontalWritingMode();
 155     TextDirection textDirection = style.direction();
 156     WritingMode writingMode = style.writingMode();
 157 
 158     // paged-x always corresponds to LeftToRightPaginated or RightToLeftPaginated. If the WritingMode
 159     // is horizontal, then we use TextDirection to choose between those options. If the WritingMode
 160     // is vertical, then the direction of the verticality dictates the choice.
 161     if (overflow == Overflow::PagedX) {
 162         if ((isHorizontalWritingMode &amp;&amp; textDirection == TextDirection::LTR) || writingMode == LeftToRightWritingMode)
 163             return Pagination::LeftToRightPaginated;
 164         return Pagination::RightToLeftPaginated;
 165     }
 166 
 167     // paged-y always corresponds to TopToBottomPaginated or BottomToTopPaginated. If the WritingMode
 168     // is horizontal, then the direction of the horizontality dictates the choice. If the WritingMode
 169     // is vertical, then we use TextDirection to choose between those options.
 170     if (writingMode == TopToBottomWritingMode || (!isHorizontalWritingMode &amp;&amp; textDirection == TextDirection::RTL))
 171         return Pagination::TopToBottomPaginated;
 172     return Pagination::BottomToTopPaginated;
 173 }
 174 
 175 FrameView::FrameView(Frame&amp; frame)
 176     : m_frame(frame)
 177     , m_layoutContext(*this)
 178     , m_updateEmbeddedObjectsTimer(*this, &amp;FrameView::updateEmbeddedObjectsTimerFired)
 179     , m_updateWidgetPositionsTimer(*this, &amp;FrameView::updateWidgetPositionsTimerFired)
 180     , m_delayedScrollEventTimer(*this, &amp;FrameView::sendScrollEvent)
 181     , m_delayedScrollToFocusedElementTimer(*this, &amp;FrameView::scrollToFocusedElementTimerFired)
 182     , m_speculativeTilingEnableTimer(*this, &amp;FrameView::speculativeTilingEnableTimerFired)
 183 {
 184     init();
 185 
 186 #if ENABLE(RUBBER_BANDING)
 187     ScrollElasticity verticalElasticity = ScrollElasticityNone;
 188     ScrollElasticity horizontalElasticity = ScrollElasticityNone;
 189     if (m_frame-&gt;isMainFrame()) {
 190         verticalElasticity = m_frame-&gt;page() ? m_frame-&gt;page()-&gt;verticalScrollElasticity() : ScrollElasticityAllowed;
 191         horizontalElasticity = m_frame-&gt;page() ? m_frame-&gt;page()-&gt;horizontalScrollElasticity() : ScrollElasticityAllowed;
 192     } else if (m_frame-&gt;settings().rubberBandingForSubScrollableRegionsEnabled()) {
 193         verticalElasticity = ScrollElasticityAutomatic;
 194         horizontalElasticity = ScrollElasticityAutomatic;
 195     }
 196 
 197     ScrollableArea::setVerticalScrollElasticity(verticalElasticity);
 198     ScrollableArea::setHorizontalScrollElasticity(horizontalElasticity);
 199 #endif
 200 }
 201 
 202 Ref&lt;FrameView&gt; FrameView::create(Frame&amp; frame)
 203 {
 204     Ref&lt;FrameView&gt; view = adoptRef(*new FrameView(frame));
 205     if (frame.page() &amp;&amp; frame.page()-&gt;isVisible())
 206         view-&gt;show();
 207     return view;
 208 }
 209 
 210 Ref&lt;FrameView&gt; FrameView::create(Frame&amp; frame, const IntSize&amp; initialSize)
 211 {
 212     Ref&lt;FrameView&gt; view = adoptRef(*new FrameView(frame));
 213     view-&gt;Widget::setFrameRect(IntRect(view-&gt;location(), initialSize));
 214     if (frame.page() &amp;&amp; frame.page()-&gt;isVisible())
 215         view-&gt;show();
 216     return view;
 217 }
 218 
 219 FrameView::~FrameView()
 220 {
 221     removeFromAXObjectCache();
 222     resetScrollbars();
 223 
 224     // Custom scrollbars should already be destroyed at this point
 225     ASSERT(!horizontalScrollbar() || !horizontalScrollbar()-&gt;isCustomScrollbar());
 226     ASSERT(!verticalScrollbar() || !verticalScrollbar()-&gt;isCustomScrollbar());
 227 
 228     setHasHorizontalScrollbar(false); // Remove native scrollbars now before we lose the connection to the HostWindow.
 229     setHasVerticalScrollbar(false);
 230 
 231     ASSERT(!m_scrollCorner);
 232 
 233     ASSERT(frame().view() != this || !frame().contentRenderer());
 234 }
 235 
 236 void FrameView::reset()
 237 {
 238     m_cannotBlitToWindow = false;
 239     m_isOverlapped = false;
 240     m_contentIsOpaque = false;
 241     m_updateEmbeddedObjectsTimer.stop();
 242     m_wasScrolledByUser = false;
 243     m_delayedScrollEventTimer.stop();
 244     m_shouldScrollToFocusedElement = false;
 245     m_delayedScrollToFocusedElementTimer.stop();
 246     m_lastViewportSize = IntSize();
 247     m_lastZoomFactor = 1.0f;
 248     m_isTrackingRepaints = false;
 249     m_trackedRepaintRects.clear();
 250     m_lastPaintTime = MonotonicTime();
 251     m_paintBehavior = PaintBehavior::Normal;
 252     m_isPainting = false;
 253     m_needsDeferredScrollbarsUpdate = false;
 254     m_maintainScrollPositionAnchor = nullptr;
 255     resetLayoutMilestones();
 256     layoutContext().reset();
 257 }
 258 
 259 void FrameView::resetLayoutMilestones()
 260 {
 261     m_firstLayoutCallbackPending = false;
 262     m_isVisuallyNonEmpty = false;
 263     m_hasReachedSignificantRenderedTextThreshold = false;
 264     m_renderedSignificantAmountOfText = false;
 265     m_visuallyNonEmptyCharacterCount = 0;
 266     m_visuallyNonEmptyPixelCount = 0;
 267     m_textRendererCountForVisuallyNonEmptyCharacters = 0;
 268 }
 269 
 270 void FrameView::removeFromAXObjectCache()
 271 {
 272     if (AXObjectCache* cache = axObjectCache()) {
 273         if (HTMLFrameOwnerElement* owner = frame().ownerElement())
 274             cache-&gt;childrenChanged(owner-&gt;renderer());
 275         cache-&gt;remove(this);
 276     }
 277 }
 278 
 279 void FrameView::resetScrollbars()
 280 {
 281     // FIXME: Do we really need this?
 282     layoutContext().resetFirstLayoutFlag();
 283     // Reset the document&#39;s scrollbars back to our defaults before we yield the floor.
 284     setScrollbarsSuppressed(true);
 285     if (m_canHaveScrollbars)
 286         setScrollbarModes(ScrollbarAuto, ScrollbarAuto);
 287     else
 288         setScrollbarModes(ScrollbarAlwaysOff, ScrollbarAlwaysOff);
 289     setScrollbarsSuppressed(false);
 290 }
 291 
 292 void FrameView::resetScrollbarsAndClearContentsSize()
 293 {
 294     resetScrollbars();
 295 
 296     LOG(Layout, &quot;FrameView %p resetScrollbarsAndClearContentsSize&quot;, this);
 297 
 298     setScrollbarsSuppressed(true);
 299     setContentsSize(IntSize());
 300     setScrollbarsSuppressed(false);
 301 }
 302 
 303 void FrameView::init()
 304 {
 305     reset();
 306 
 307     m_size = LayoutSize();
 308 
 309     // Propagate the scrolling mode to the view.
 310     auto* ownerElement = frame().ownerElement();
 311     if (is&lt;HTMLFrameElementBase&gt;(ownerElement) &amp;&amp; downcast&lt;HTMLFrameElementBase&gt;(*ownerElement).scrollingMode() == ScrollbarAlwaysOff)
 312         setCanHaveScrollbars(false);
 313 
 314     Page* page = frame().page();
 315     if (page &amp;&amp; page-&gt;chrome().client().shouldPaintEntireContents())
 316         setPaintsEntireContents(true);
 317 }
 318 
 319 void FrameView::prepareForDetach()
 320 {
 321     detachCustomScrollbars();
 322     // When the view is no longer associated with a frame, it needs to be removed from the ax object cache
 323     // right now, otherwise it won&#39;t be able to reach the topDocument()&#39;s axObject cache later.
 324     removeFromAXObjectCache();
 325 
 326     if (frame().page()) {
 327         if (ScrollingCoordinator* scrollingCoordinator = frame().page()-&gt;scrollingCoordinator())
 328             scrollingCoordinator-&gt;willDestroyScrollableArea(*this);
 329     }
 330 }
 331 
 332 void FrameView::detachCustomScrollbars()
 333 {
 334     Scrollbar* horizontalBar = horizontalScrollbar();
 335     if (horizontalBar &amp;&amp; horizontalBar-&gt;isCustomScrollbar())
 336         setHasHorizontalScrollbar(false);
 337 
 338     Scrollbar* verticalBar = verticalScrollbar();
 339     if (verticalBar &amp;&amp; verticalBar-&gt;isCustomScrollbar())
 340         setHasVerticalScrollbar(false);
 341 
 342     m_scrollCorner = nullptr;
 343 }
 344 
 345 void FrameView::recalculateScrollbarOverlayStyle()
 346 {
 347     ScrollbarOverlayStyle oldOverlayStyle = scrollbarOverlayStyle();
 348     Optional&lt;ScrollbarOverlayStyle&gt; clientOverlayStyle = frame().page() ? frame().page()-&gt;chrome().client().preferredScrollbarOverlayStyle() : WTF::nullopt;
 349     if (clientOverlayStyle) {
 350         if (clientOverlayStyle.value() != oldOverlayStyle)
 351             setScrollbarOverlayStyle(clientOverlayStyle.value());
 352         return;
 353     }
 354 
 355     ScrollbarOverlayStyle computedOverlayStyle = ScrollbarOverlayStyleDefault;
 356 
 357     Color backgroundColor = documentBackgroundColor();
 358     if (backgroundColor.isValid()) {
 359         // Reduce the background color from RGB to a lightness value
 360         // and determine which scrollbar style to use based on a lightness
 361         // heuristic.
 362         double hue, saturation, lightness;
 363         backgroundColor.getHSL(hue, saturation, lightness);
 364         if (lightness &lt;= .5 &amp;&amp; backgroundColor.isVisible())
 365             computedOverlayStyle = ScrollbarOverlayStyleLight;
 366         else if (!backgroundColor.isVisible() &amp;&amp; useDarkAppearance())
 367             computedOverlayStyle = ScrollbarOverlayStyleLight;
 368     }
 369 
 370     if (oldOverlayStyle != computedOverlayStyle)
 371         setScrollbarOverlayStyle(computedOverlayStyle);
 372 }
 373 
 374 #if ENABLE(DARK_MODE_CSS)
 375 void FrameView::recalculateBaseBackgroundColor()
 376 {
 377     bool usingDarkAppearance = useDarkAppearance();
 378     if (m_usesDarkAppearance == usingDarkAppearance)
 379         return;
 380 
 381     m_usesDarkAppearance = usingDarkAppearance;
 382     Optional&lt;Color&gt; backgroundColor;
 383     if (m_isTransparent)
 384         backgroundColor = Color(Color::transparent);
 385     updateBackgroundRecursively(backgroundColor);
 386 }
 387 #endif
 388 
 389 void FrameView::clear()
 390 {
 391     setCanBlitOnScroll(true);
 392 
 393     reset();
 394 
 395     setScrollbarsSuppressed(true);
 396 
 397 #if PLATFORM(IOS_FAMILY)
 398     // To avoid flashes of white, disable tile updates immediately when view is cleared at the beginning of a page load.
 399     // Tiling will be re-enabled from UIKit via [WAKWindow setTilingMode:] when we have content to draw.
 400     if (LegacyTileCache* tileCache = legacyTileCache())
 401         tileCache-&gt;setTilingMode(LegacyTileCache::Disabled);
 402 #endif
 403 }
 404 
 405 #if PLATFORM(IOS_FAMILY)
 406 void FrameView::didReplaceMultipartContent()
 407 {
 408     // Re-enable tile updates that were disabled in clear().
 409     if (LegacyTileCache* tileCache = legacyTileCache())
 410         tileCache-&gt;setTilingMode(LegacyTileCache::Normal);
 411 }
 412 #endif
 413 
 414 bool FrameView::didFirstLayout() const
 415 {
 416     return layoutContext().didFirstLayout();
 417 }
 418 
 419 void FrameView::invalidateRect(const IntRect&amp; rect)
 420 {
 421     if (!parent()) {
 422         if (auto* page = frame().page())
 423             page-&gt;chrome().invalidateContentsAndRootView(rect);
 424         return;
 425     }
 426 
 427     auto* renderer = frame().ownerRenderer();
 428     if (!renderer)
 429         return;
 430 
 431     IntRect repaintRect = rect;
 432     repaintRect.moveBy(roundedIntPoint(renderer-&gt;contentBoxLocation()));
 433     renderer-&gt;repaintRectangle(repaintRect);
 434 }
 435 
 436 void FrameView::setFrameRect(const IntRect&amp; newRect)
 437 {
 438     Ref&lt;FrameView&gt; protectedThis(*this);
 439     IntRect oldRect = frameRect();
 440     if (newRect == oldRect)
 441         return;
 442 
 443     // Every scroll that happens as the result of frame size change is programmatic.
 444     auto oldScrollType = currentScrollType();
 445     setCurrentScrollType(ScrollType::Programmatic);
 446 
 447     ScrollView::setFrameRect(newRect);
 448 
 449     updateScrollableAreaSet();
 450 
 451     if (RenderView* renderView = this-&gt;renderView()) {
 452         if (renderView-&gt;usesCompositing())
 453             renderView-&gt;compositor().frameViewDidChangeSize();
 454     }
 455 
 456     if (frame().isMainFrame() &amp;&amp; frame().page())
 457         frame().page()-&gt;pageOverlayController().didChangeViewSize();
 458 
 459     viewportContentsChanged();
 460     setCurrentScrollType(oldScrollType);
 461 }
 462 
 463 bool FrameView::scheduleAnimation()
 464 {
 465     auto* page = frame().page();
 466     if (!page)
 467         return false;
 468     page-&gt;chrome().scheduleAnimation();
 469     return true;
 470 }
 471 
 472 FrameFlattening FrameView::effectiveFrameFlattening() const
 473 {
 474 #if PLATFORM(IOS_FAMILY)
 475     // On iOS when async frame scrolling is enabled, it does not make sense to use full frame flattening.
 476     // In that case, we just consider that frame flattening is disabled. This allows people to test
 477     // frame scrolling on iOS by enabling &quot;Async Frame Scrolling&quot; via the Safari menu.
 478     if (frame().settings().asyncFrameScrollingEnabled() &amp;&amp; frame().settings().frameFlattening() == FrameFlattening::FullyEnabled)
 479         return FrameFlattening::Disabled;
 480 #endif
 481     return frame().settings().frameFlattening();
 482 }
 483 
 484 bool FrameView::frameFlatteningEnabled() const
 485 {
 486     return effectiveFrameFlattening() != FrameFlattening::Disabled;
 487 }
 488 
 489 bool FrameView::isFrameFlatteningValidForThisFrame() const
 490 {
 491     if (!frameFlatteningEnabled())
 492         return false;
 493 
 494     HTMLFrameOwnerElement* owner = frame().ownerElement();
 495     if (!owner)
 496         return false;
 497 
 498     // Frame flattening is valid only for &lt;frame&gt; and &lt;iframe&gt;.
 499     return owner-&gt;hasTagName(frameTag) || owner-&gt;hasTagName(iframeTag);
 500 }
 501 
 502 bool FrameView::avoidScrollbarCreation() const
 503 {
 504     // with frame flattening no subframe can have scrollbars
 505     // but we also cannot turn scrollbars off as we determine
 506     // our flattening policy using that.
 507     return isFrameFlatteningValidForThisFrame();
 508 }
 509 
 510 void FrameView::setCanHaveScrollbars(bool canHaveScrollbars)
 511 {
 512     m_canHaveScrollbars = canHaveScrollbars;
 513     ScrollView::setCanHaveScrollbars(canHaveScrollbars);
 514 }
 515 
 516 void FrameView::updateCanHaveScrollbars()
 517 {
 518     ScrollbarMode hMode;
 519     ScrollbarMode vMode;
 520     scrollbarModes(hMode, vMode);
 521     if (hMode == ScrollbarAlwaysOff &amp;&amp; vMode == ScrollbarAlwaysOff)
 522         setCanHaveScrollbars(false);
 523     else
 524         setCanHaveScrollbars(true);
 525 }
 526 
 527 Ref&lt;Scrollbar&gt; FrameView::createScrollbar(ScrollbarOrientation orientation)
 528 {
 529     // FIXME: We need to update the scrollbar dynamically as documents change (or as doc elements and bodies get discovered that have custom styles).
 530     Document* doc = frame().document();
 531 
 532     // Try the &lt;body&gt; element first as a scrollbar source.
 533     HTMLElement* body = doc ? doc-&gt;bodyOrFrameset() : nullptr;
 534     if (body &amp;&amp; body-&gt;renderer() &amp;&amp; body-&gt;renderer()-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))
 535         return RenderScrollbar::createCustomScrollbar(*this, orientation, body);
 536 
 537     // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
 538     Element* docElement = doc ? doc-&gt;documentElement() : nullptr;
 539     if (docElement &amp;&amp; docElement-&gt;renderer() &amp;&amp; docElement-&gt;renderer()-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))
 540         return RenderScrollbar::createCustomScrollbar(*this, orientation, docElement);
 541 
 542     // If we have an owning iframe/frame element, then it can set the custom scrollbar also.
 543     RenderWidget* frameRenderer = frame().ownerRenderer();
 544     if (frameRenderer &amp;&amp; frameRenderer-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))
 545         return RenderScrollbar::createCustomScrollbar(*this, orientation, nullptr, &amp;frame());
 546 
 547     // Nobody set a custom style, so we just use a native scrollbar.
 548     return ScrollView::createScrollbar(orientation);
 549 }
 550 
 551 void FrameView::didRestoreFromPageCache()
 552 {
 553     // When restoring from page cache, the main frame stays in place while subframes get swapped in.
 554     // We update the scrollable area set to ensure that scrolling data structures get invalidated.
 555     updateScrollableAreaSet();
 556 }
 557 
 558 void FrameView::willDestroyRenderTree()
 559 {
 560     detachCustomScrollbars();
 561     layoutContext().clearSubtreeLayoutRoot();
 562 }
 563 
 564 void FrameView::didDestroyRenderTree()
 565 {
 566     ASSERT(!layoutContext().subtreeLayoutRoot());
 567     ASSERT(m_widgetsInRenderTree.isEmpty());
 568 
 569     // If the render tree is destroyed below FrameView::updateEmbeddedObjects(), there will still be a null sentinel in the set.
 570     // Everything else should have removed itself as the tree was felled.
 571     ASSERT(!m_embeddedObjectsToUpdate || m_embeddedObjectsToUpdate-&gt;isEmpty() || (m_embeddedObjectsToUpdate-&gt;size() == 1 &amp;&amp; m_embeddedObjectsToUpdate-&gt;first() == nullptr));
 572 
 573     ASSERT(!m_viewportConstrainedObjects || m_viewportConstrainedObjects-&gt;isEmpty());
 574     ASSERT(!m_slowRepaintObjects || m_slowRepaintObjects-&gt;isEmpty());
 575 
 576     ASSERT(!frame().animation().hasAnimations());
 577 }
 578 
 579 void FrameView::setContentsSize(const IntSize&amp; size)
 580 {
 581     if (size == contentsSize())
 582         return;
 583 
 584     layoutContext().disableSetNeedsLayout();
 585 
 586     ScrollView::setContentsSize(size);
 587     contentsResized();
 588 
 589     Page* page = frame().page();
 590     if (!page)
 591         return;
 592 
 593     updateScrollableAreaSet();
 594 
 595     page-&gt;chrome().contentsSizeChanged(frame(), size); // Notify only.
 596 
 597     if (frame().isMainFrame()) {
 598         page-&gt;pageOverlayController().didChangeDocumentSize();
 599         PageCache::singleton().markPagesForContentsSizeChanged(*page);
 600     }
 601     layoutContext().enableSetNeedsLayout();
 602 }
 603 
 604 void FrameView::adjustViewSize()
 605 {
 606     RenderView* renderView = this-&gt;renderView();
 607     if (!renderView)
 608         return;
 609 
 610     ASSERT(frame().view() == this);
 611 
 612     const IntRect rect = renderView-&gt;documentRect();
 613     const IntSize&amp; size = rect.size();
 614     ScrollView::setScrollOrigin(IntPoint(-rect.x(), -rect.y()), !frame().document()-&gt;printing(), size == contentsSize());
 615 
 616     LOG_WITH_STREAM(Layout, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; adjustViewSize: unscaled document rect changed to &quot; &lt;&lt; renderView-&gt;unscaledDocumentRect() &lt;&lt; &quot; (scaled to &quot; &lt;&lt; size &lt;&lt; &quot;)&quot;);
 617 
 618     setContentsSize(size);
 619 }
 620 
 621 void FrameView::applyOverflowToViewport(const RenderElement&amp; renderer, ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode)
 622 {
 623     // Handle the overflow:hidden/scroll case for the body/html elements.  WinIE treats
 624     // overflow:hidden and overflow:scroll on &lt;body&gt; as applying to the document&#39;s
 625     // scrollbars.  The CSS2.1 draft states that HTML UAs should use the &lt;html&gt; or &lt;body&gt; element and XML/XHTML UAs should
 626     // use the root element.
 627 
 628     // To combat the inability to scroll on a page with overflow:hidden on the root when scaled, disregard hidden when
 629     // there is a frameScaleFactor that is greater than one on the main frame. Also disregard hidden if there is a
 630     // header or footer.
 631 
 632     bool overrideHidden = frame().isMainFrame() &amp;&amp; ((frame().frameScaleFactor() &gt; 1) || headerHeight() || footerHeight());
 633 
 634     Overflow overflowX = renderer.style().overflowX();
 635     Overflow overflowY = renderer.style().overflowY();
 636 
 637     if (is&lt;RenderSVGRoot&gt;(renderer)) {
 638         // FIXME: evaluate if we can allow overflow for these cases too.
 639         // Overflow is always hidden when stand-alone SVG documents are embedded.
 640         if (downcast&lt;RenderSVGRoot&gt;(renderer).isEmbeddedThroughFrameContainingSVGDocument()) {
 641             overflowX = Overflow::Hidden;
 642             overflowY = Overflow::Hidden;
 643         }
 644     }
 645 
 646     switch (overflowX) {
 647     case Overflow::Hidden:
 648         if (overrideHidden)
 649             hMode = ScrollbarAuto;
 650         else
 651             hMode = ScrollbarAlwaysOff;
 652         break;
 653     case Overflow::Scroll:
 654         hMode = ScrollbarAlwaysOn;
 655         break;
 656     case Overflow::Auto:
 657         hMode = ScrollbarAuto;
 658         break;
 659     default:
 660         // Don&#39;t set it at all.
 661         ;
 662     }
 663 
 664     switch (overflowY) {
 665     case Overflow::Hidden:
 666         if (overrideHidden)
 667             vMode = ScrollbarAuto;
 668         else
 669             vMode = ScrollbarAlwaysOff;
 670         break;
 671     case Overflow::Scroll:
 672         vMode = ScrollbarAlwaysOn;
 673         break;
 674     case Overflow::Auto:
 675         vMode = ScrollbarAuto;
 676         break;
 677     default:
 678         // Don&#39;t set it at all. Values of Overflow::PagedX and Overflow::PagedY are handled by applyPaginationToViewPort().
 679         ;
 680     }
 681 }
 682 
 683 void FrameView::applyPaginationToViewport()
 684 {
 685     auto* document = frame().document();
 686     auto* documentElement = document ? document-&gt;documentElement() : nullptr;
 687     if (!documentElement || !documentElement-&gt;renderer()) {
 688         setPagination(Pagination());
 689         return;
 690     }
 691 
 692     auto&amp; documentRenderer = *documentElement-&gt;renderer();
 693     auto* documentOrBodyRenderer = &amp;documentRenderer;
 694 
 695     auto* body = document-&gt;body();
 696     if (body &amp;&amp; body-&gt;renderer()) {
 697         documentOrBodyRenderer = documentRenderer.style().overflowX() == Overflow::Visible &amp;&amp; is&lt;HTMLHtmlElement&gt;(*documentElement) ?
 698             body-&gt;renderer() : &amp;documentRenderer;
 699     }
 700 
 701     Pagination pagination;
 702     Overflow overflowY = documentOrBodyRenderer-&gt;style().overflowY();
 703     if (overflowY == Overflow::PagedX || overflowY == Overflow::PagedY) {
 704         pagination.mode = WebCore::paginationModeForRenderStyle(documentOrBodyRenderer-&gt;style());
 705         GapLength columnGapLength = documentOrBodyRenderer-&gt;style().columnGap();
 706         pagination.gap = 0;
 707         if (!columnGapLength.isNormal()) {
 708             if (auto* containerForPaginationGap = is&lt;RenderBox&gt;(documentOrBodyRenderer) ? downcast&lt;RenderBox&gt;(documentOrBodyRenderer) : documentOrBodyRenderer-&gt;containingBlock())
 709                 pagination.gap = valueForLength(columnGapLength.length(), containerForPaginationGap-&gt;availableLogicalWidth()).toUnsigned();
 710         }
 711     }
 712     setPagination(pagination);
 713 }
 714 
 715 void FrameView::calculateScrollbarModesForLayout(ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode, ScrollbarModesCalculationStrategy strategy)
 716 {
 717     m_viewportRendererType = ViewportRendererType::None;
 718 
 719     const HTMLFrameOwnerElement* owner = frame().ownerElement();
 720     if (owner &amp;&amp; (owner-&gt;scrollingMode() == ScrollbarAlwaysOff)) {
 721         hMode = ScrollbarAlwaysOff;
 722         vMode = ScrollbarAlwaysOff;
 723         return;
 724     }
 725 
 726     if (m_canHaveScrollbars || strategy == RulesFromWebContentOnly) {
 727         hMode = ScrollbarAuto;
 728         vMode = ScrollbarAuto;
 729     } else {
 730         hMode = ScrollbarAlwaysOff;
 731         vMode = ScrollbarAlwaysOff;
 732     }
 733 
 734     if (layoutContext().subtreeLayoutRoot())
 735         return;
 736 
 737     auto* document = frame().document();
 738     if (!document)
 739         return;
 740 
 741     auto* documentElement = document-&gt;documentElement();
 742     if (!documentElement)
 743         return;
 744 
 745     auto* bodyOrFrameset = document-&gt;bodyOrFrameset();
 746     auto* rootRenderer = documentElement-&gt;renderer();
 747     if (!bodyOrFrameset || !bodyOrFrameset-&gt;renderer()) {
 748         if (rootRenderer) {
 749             applyOverflowToViewport(*rootRenderer, hMode, vMode);
 750             m_viewportRendererType = ViewportRendererType::Document;
 751         }
 752         return;
 753     }
 754 
 755     if (is&lt;HTMLFrameSetElement&gt;(*bodyOrFrameset) &amp;&amp; !frameFlatteningEnabled()) {
 756         vMode = ScrollbarAlwaysOff;
 757         hMode = ScrollbarAlwaysOff;
 758         return;
 759     }
 760 
 761     if (is&lt;HTMLBodyElement&gt;(*bodyOrFrameset) &amp;&amp; rootRenderer) {
 762         // It&#39;s sufficient to just check the X overflow,
 763         // since it&#39;s illegal to have visible in only one direction.
 764         if (rootRenderer-&gt;style().overflowX() == Overflow::Visible &amp;&amp; is&lt;HTMLHtmlElement&gt;(documentElement)) {
 765             auto* bodyRenderer = bodyOrFrameset-&gt;renderer();
 766             if (bodyRenderer) {
 767                 applyOverflowToViewport(*bodyRenderer, hMode, vMode);
 768                 m_viewportRendererType = ViewportRendererType::Body;
 769             }
 770         } else {
 771             applyOverflowToViewport(*rootRenderer, hMode, vMode);
 772             m_viewportRendererType = ViewportRendererType::Document;
 773         }
 774     }
 775 }
 776 
 777 void FrameView::willRecalcStyle()
 778 {
 779     RenderView* renderView = this-&gt;renderView();
 780     if (!renderView)
 781         return;
 782 
 783     renderView-&gt;compositor().willRecalcStyle();
 784 }
 785 
 786 bool FrameView::updateCompositingLayersAfterStyleChange()
 787 {
 788     // If we expect to update compositing after an incipient layout, don&#39;t do so here.
 789     if (!renderView() || needsLayout() || layoutContext().isInLayout())
 790         return false;
 791     return renderView()-&gt;compositor().didRecalcStyleWithNoPendingLayout();
 792 }
 793 
 794 void FrameView::updateCompositingLayersAfterLayout()
 795 {
 796     RenderView* renderView = this-&gt;renderView();
 797     if (!renderView)
 798         return;
 799 
 800     renderView-&gt;compositor().updateCompositingLayers(CompositingUpdateType::AfterLayout);
 801 }
 802 
 803 GraphicsLayer* FrameView::layerForHorizontalScrollbar() const
 804 {
 805     RenderView* renderView = this-&gt;renderView();
 806     if (!renderView)
 807         return nullptr;
 808     return renderView-&gt;compositor().layerForHorizontalScrollbar();
 809 }
 810 
 811 GraphicsLayer* FrameView::layerForVerticalScrollbar() const
 812 {
 813     RenderView* renderView = this-&gt;renderView();
 814     if (!renderView)
 815         return nullptr;
 816     return renderView-&gt;compositor().layerForVerticalScrollbar();
 817 }
 818 
 819 GraphicsLayer* FrameView::layerForScrollCorner() const
 820 {
 821     RenderView* renderView = this-&gt;renderView();
 822     if (!renderView)
 823         return nullptr;
 824     return renderView-&gt;compositor().layerForScrollCorner();
 825 }
 826 
 827 TiledBacking* FrameView::tiledBacking() const
 828 {
 829     RenderView* renderView = this-&gt;renderView();
 830     if (!renderView)
 831         return nullptr;
 832 
 833     RenderLayerBacking* backing = renderView-&gt;layer()-&gt;backing();
 834     if (!backing)
 835         return nullptr;
 836 
 837     return backing-&gt;tiledBacking();
 838 }
 839 
 840 ScrollingNodeID FrameView::scrollingNodeID() const
 841 {
 842     RenderView* renderView = this-&gt;renderView();
 843     if (!renderView)
 844         return 0;
 845 
 846     RenderLayerBacking* backing = renderView-&gt;layer()-&gt;backing();
 847     if (!backing)
 848         return 0;
 849 
 850     return backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);
 851 }
 852 
 853 ScrollableArea* FrameView::scrollableAreaForScrollLayerID(uint64_t nodeID) const
 854 {
 855     RenderView* renderView = this-&gt;renderView();
 856     if (!renderView)
 857         return nullptr;
 858 
 859     return renderView-&gt;compositor().scrollableAreaForScrollLayerID(nodeID);
 860 }
 861 
 862 #if ENABLE(RUBBER_BANDING)
 863 GraphicsLayer* FrameView::layerForOverhangAreas() const
 864 {
 865     RenderView* renderView = this-&gt;renderView();
 866     if (!renderView)
 867         return nullptr;
 868     return renderView-&gt;compositor().layerForOverhangAreas();
 869 }
 870 
 871 GraphicsLayer* FrameView::setWantsLayerForTopOverHangArea(bool wantsLayer) const
 872 {
 873     RenderView* renderView = this-&gt;renderView();
 874     if (!renderView)
 875         return nullptr;
 876 
 877     return renderView-&gt;compositor().updateLayerForTopOverhangArea(wantsLayer);
 878 }
 879 
 880 GraphicsLayer* FrameView::setWantsLayerForBottomOverHangArea(bool wantsLayer) const
 881 {
 882     RenderView* renderView = this-&gt;renderView();
 883     if (!renderView)
 884         return nullptr;
 885 
 886     return renderView-&gt;compositor().updateLayerForBottomOverhangArea(wantsLayer);
 887 }
 888 
 889 #endif // ENABLE(RUBBER_BANDING)
 890 
 891 #if ENABLE(CSS_SCROLL_SNAP)
 892 void FrameView::updateSnapOffsets()
 893 {
 894     if (!frame().document())
 895         return;
 896 
 897     // FIXME: Should we allow specifying snap points through &lt;html&gt; tags too?
 898     HTMLElement* body = frame().document()-&gt;bodyOrFrameset();
 899     if (!renderView() || !body || !body-&gt;renderer())
 900         return;
 901 
 902     updateSnapOffsetsForScrollableArea(*this, *body, *renderView(), body-&gt;renderer()-&gt;style());
 903 }
 904 
 905 bool FrameView::isScrollSnapInProgress() const
 906 {
 907     if (scrollbarsSuppressed())
 908         return false;
 909 
 910     // If the scrolling thread updates the scroll position for this FrameView, then we should return
 911     // ScrollingCoordinator::isScrollSnapInProgress().
 912     if (Page* page = frame().page()) {
 913         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator()) {
 914             if (!scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
 915                 return scrollingCoordinator-&gt;isScrollSnapInProgress();
 916         }
 917     }
 918 
 919     // If the main thread updates the scroll position for this FrameView, we should return
 920     // ScrollAnimator::isScrollSnapInProgress().
 921     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
 922         return scrollAnimator-&gt;isScrollSnapInProgress();
 923 
 924     return false;
 925 }
 926 
 927 void FrameView::updateScrollingCoordinatorScrollSnapProperties() const
 928 {
 929     renderView()-&gt;compositor().updateScrollSnapPropertiesWithFrameView(*this);
 930 }
 931 #endif
 932 
 933 bool FrameView::flushCompositingStateForThisFrame(const Frame&amp; rootFrameForFlush)
 934 {
 935     RenderView* renderView = this-&gt;renderView();
 936     if (!renderView)
 937         return true; // We don&#39;t want to keep trying to update layers if we have no renderer.
 938 
 939     ASSERT(frame().view() == this);
 940 
 941     // If we sync compositing layers when a layout is pending, we may cause painting of compositing
 942     // layer content to occur before layout has happened, which will cause paintContents() to bail.
 943     if (needsLayout())
 944         return false;
 945 
 946 #if PLATFORM(IOS_FAMILY)
 947     if (LegacyTileCache* tileCache = legacyTileCache())
 948         tileCache-&gt;doPendingRepaints();
 949 #endif
 950 
 951     renderView-&gt;compositor().flushPendingLayerChanges(&amp;rootFrameForFlush == m_frame.ptr());
 952 
 953     return true;
 954 }
 955 
 956 void FrameView::setNeedsOneShotDrawingSynchronization()
 957 {
 958     if (Page* page = frame().page())
 959         page-&gt;chrome().client().setNeedsOneShotDrawingSynchronization();
 960 }
 961 
 962 GraphicsLayer* FrameView::graphicsLayerForPlatformWidget(PlatformWidget platformWidget)
 963 {
 964     // To find the Widget that corresponds with platformWidget we have to do a linear
 965     // search of our child widgets.
 966     const Widget* foundWidget = nullptr;
 967     for (auto&amp; widget : children()) {
 968         if (widget-&gt;platformWidget() != platformWidget)
 969             continue;
 970         foundWidget = widget.ptr();
 971         break;
 972     }
 973 
 974     if (!foundWidget)
 975         return nullptr;
 976 
 977     auto* renderWidget = RenderWidget::find(*foundWidget);
 978     if (!renderWidget)
 979         return nullptr;
 980 
 981     auto* widgetLayer = renderWidget-&gt;layer();
 982     if (!widgetLayer || !widgetLayer-&gt;isComposited())
 983         return nullptr;
 984 
 985     return widgetLayer-&gt;backing()-&gt;parentForSublayers();
 986 }
 987 
 988 void FrameView::scheduleLayerFlushAllowingThrottling()
 989 {
 990     RenderView* view = this-&gt;renderView();
 991     if (!view)
 992         return;
 993     view-&gt;compositor().scheduleLayerFlush(true /* canThrottle */);
 994 }
 995 
 996 LayoutRect FrameView::fixedScrollableAreaBoundsInflatedForScrolling(const LayoutRect&amp; uninflatedBounds) const
 997 {
 998     LayoutPoint scrollPosition;
 999     LayoutSize topLeftExpansion;
1000     LayoutSize bottomRightExpansion;
1001 
1002     if (frame().settings().visualViewportEnabled()) {
1003         // FIXME: this is wrong under zooming; uninflatedBounds is scaled but the scroll positions are not.
1004         scrollPosition = layoutViewportRect().location();
1005         topLeftExpansion = scrollPosition - unscaledMinimumScrollPosition();
1006         bottomRightExpansion = unscaledMaximumScrollPosition() - scrollPosition;
1007     } else {
1008         scrollPosition = scrollPositionRespectingCustomFixedPosition();
1009         topLeftExpansion = scrollPosition - minimumScrollPosition();
1010         bottomRightExpansion = maximumScrollPosition() - scrollPosition;
1011     }
1012 
1013     return LayoutRect(uninflatedBounds.location() - topLeftExpansion, uninflatedBounds.size() + topLeftExpansion + bottomRightExpansion);
1014 }
1015 
1016 LayoutPoint FrameView::scrollPositionRespectingCustomFixedPosition() const
1017 {
1018 #if PLATFORM(IOS_FAMILY)
1019     if (!frame().settings().visualViewportEnabled())
1020         return useCustomFixedPositionLayoutRect() ? customFixedPositionLayoutRect().location() : scrollPosition();
1021 #endif
1022 
1023     return scrollPositionForFixedPosition();
1024 }
1025 
1026 int FrameView::headerHeight() const
1027 {
1028     if (!frame().isMainFrame())
1029         return 0;
1030     Page* page = frame().page();
1031     return page ? page-&gt;headerHeight() : 0;
1032 }
1033 
1034 int FrameView::footerHeight() const
1035 {
1036     if (!frame().isMainFrame())
1037         return 0;
1038     Page* page = frame().page();
1039     return page ? page-&gt;footerHeight() : 0;
1040 }
1041 
1042 float FrameView::topContentInset(TopContentInsetType contentInsetTypeToReturn) const
1043 {
1044     if (platformWidget() &amp;&amp; contentInsetTypeToReturn == TopContentInsetType::WebCoreOrPlatformContentInset)
1045         return platformTopContentInset();
1046 
1047     if (!frame().isMainFrame())
1048         return 0;
1049 
1050     Page* page = frame().page();
1051     return page ? page-&gt;topContentInset() : 0;
1052 }
1053 
1054 void FrameView::topContentInsetDidChange(float newTopContentInset)
1055 {
1056     RenderView* renderView = this-&gt;renderView();
1057     if (!renderView)
1058         return;
1059 
1060     if (platformWidget())
1061         platformSetTopContentInset(newTopContentInset);
1062 
1063     layoutContext().layout();
1064     // Every scroll that happens as the result of content inset change is programmatic.
1065     auto oldScrollType = currentScrollType();
1066     setCurrentScrollType(ScrollType::Programmatic);
1067 
1068     updateScrollbars(scrollPosition());
1069     if (renderView-&gt;usesCompositing())
1070         renderView-&gt;compositor().frameViewDidChangeSize();
1071 
1072     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
1073         tiledBacking-&gt;setTopContentInset(newTopContentInset);
1074 
1075     setCurrentScrollType(oldScrollType);
1076 }
1077 
1078 void FrameView::topContentDirectionDidChange()
1079 {
1080     m_needsDeferredScrollbarsUpdate = true;
1081 }
1082 
1083 void FrameView::handleDeferredScrollbarsUpdateAfterDirectionChange()
1084 {
1085     if (!m_needsDeferredScrollbarsUpdate)
1086         return;
1087 
1088     m_needsDeferredScrollbarsUpdate = false;
1089 
1090     updateScrollbars(scrollPosition());
1091     positionScrollbarLayers();
1092 }
1093 
1094 // Sometimes (for plug-ins) we need to eagerly go into compositing mode.
1095 void FrameView::enterCompositingMode()
1096 {
1097     if (RenderView* renderView = this-&gt;renderView()) {
1098         renderView-&gt;compositor().enableCompositingMode();
1099         if (!needsLayout())
1100             renderView-&gt;compositor().scheduleCompositingLayerUpdate();
1101     }
1102 }
1103 
1104 bool FrameView::isEnclosedInCompositingLayer() const
1105 {
1106     auto frameOwnerRenderer = frame().ownerRenderer();
1107     if (frameOwnerRenderer &amp;&amp; frameOwnerRenderer-&gt;containerForRepaint())
1108         return true;
1109 
1110     if (FrameView* parentView = parentFrameView())
1111         return parentView-&gt;isEnclosedInCompositingLayer();
1112     return false;
1113 }
1114 
1115 bool FrameView::flushCompositingStateIncludingSubframes()
1116 {
1117     bool allFramesFlushed = flushCompositingStateForThisFrame(frame());
1118 
1119     for (Frame* child = frame().tree().firstRenderedChild(); child; child = child-&gt;tree().traverseNextRendered(m_frame.ptr())) {
1120         if (!child-&gt;view())
1121             continue;
1122         bool flushed = child-&gt;view()-&gt;flushCompositingStateForThisFrame(frame());
1123         allFramesFlushed &amp;= flushed;
1124     }
1125     return allFramesFlushed;
1126 }
1127 
1128 bool FrameView::isSoftwareRenderable() const
1129 {
1130     RenderView* renderView = this-&gt;renderView();
1131     return !renderView || !renderView-&gt;compositor().has3DContent();
1132 }
1133 
1134 void FrameView::setIsInWindow(bool isInWindow)
1135 {
1136     if (RenderView* renderView = this-&gt;renderView())
1137         renderView-&gt;setIsInWindow(isInWindow);
1138 }
1139 
1140 void FrameView::forceLayoutParentViewIfNeeded()
1141 {
1142     RenderWidget* ownerRenderer = frame().ownerRenderer();
1143     if (!ownerRenderer)
1144         return;
1145 
1146     RenderBox* contentBox = embeddedContentBox();
1147     if (!contentBox)
1148         return;
1149 
1150     auto&amp; svgRoot = downcast&lt;RenderSVGRoot&gt;(*contentBox);
1151     if (svgRoot.everHadLayout() &amp;&amp; !svgRoot.needsLayout())
1152         return;
1153 
1154     LOG(Layout, &quot;FrameView %p forceLayoutParentViewIfNeeded scheduling layout on parent FrameView %p&quot;, this, &amp;ownerRenderer-&gt;view().frameView());
1155 
1156     // If the embedded SVG document appears the first time, the ownerRenderer has already finished
1157     // layout without knowing about the existence of the embedded SVG document, because RenderReplaced
1158     // embeddedContentBox() returns nullptr, as long as the embedded document isn&#39;t loaded yet. Before
1159     // bothering to lay out the SVG document, mark the ownerRenderer needing layout and ask its
1160     // FrameView for a layout. After that the RenderEmbeddedObject (ownerRenderer) carries the
1161     // correct size, which RenderSVGRoot::computeReplacedLogicalWidth/Height rely on, when laying
1162     // out for the first time, or when the RenderSVGRoot size has changed dynamically (eg. via &lt;script&gt;).
1163 
1164     ownerRenderer-&gt;setNeedsLayoutAndPrefWidthsRecalc();
1165     ownerRenderer-&gt;view().frameView().layoutContext().scheduleLayout();
1166 }
1167 
1168 void FrameView::markRootOrBodyRendererDirty() const
1169 {
1170     auto&amp; document = *frame().document();
1171     RenderBox* rootRenderer = document.documentElement() ? document.documentElement()-&gt;renderBox() : nullptr;
1172     auto* body = document.bodyOrFrameset();
1173     RenderBox* bodyRenderer = rootRenderer &amp;&amp; body ? body-&gt;renderBox() : nullptr;
1174     if (bodyRenderer &amp;&amp; bodyRenderer-&gt;stretchesToViewport())
1175         bodyRenderer-&gt;setChildNeedsLayout();
1176     else if (rootRenderer &amp;&amp; rootRenderer-&gt;stretchesToViewport())
1177         rootRenderer-&gt;setChildNeedsLayout();
1178 }
1179 
1180 void FrameView::adjustScrollbarsForLayout(bool isFirstLayout)
1181 {
1182     ScrollbarMode hMode;
1183     ScrollbarMode vMode;
1184     calculateScrollbarModesForLayout(hMode, vMode);
1185     if (isFirstLayout &amp;&amp; !layoutContext().isLayoutNested()) {
1186         setScrollbarsSuppressed(true);
1187         // Set the initial vMode to AlwaysOn if we&#39;re auto.
1188         if (vMode == ScrollbarAuto)
1189             setVerticalScrollbarMode(ScrollbarAlwaysOn); // This causes a vertical scrollbar to appear.
1190         // Set the initial hMode to AlwaysOff if we&#39;re auto.
1191         if (hMode == ScrollbarAuto)
1192             setHorizontalScrollbarMode(ScrollbarAlwaysOff); // This causes a horizontal scrollbar to disappear.
1193         ASSERT(frame().page());
1194         if (frame().page()-&gt;expectsWheelEventTriggers())
1195             scrollAnimator().setWheelEventTestTrigger(frame().page()-&gt;testTrigger());
1196         setScrollbarModes(hMode, vMode);
1197         setScrollbarsSuppressed(false, true);
1198     } else if (hMode != horizontalScrollbarMode() || vMode != verticalScrollbarMode())
1199         setScrollbarModes(hMode, vMode);
1200 }
1201 
1202 void FrameView::willDoLayout(WeakPtr&lt;RenderElement&gt; layoutRoot)
1203 {
1204     bool subtreeLayout = !is&lt;RenderView&gt;(*layoutRoot);
1205     if (subtreeLayout)
1206         return;
1207 
1208     if (auto* body = frame().document()-&gt;bodyOrFrameset()) {
1209         if (is&lt;HTMLFrameSetElement&gt;(*body) &amp;&amp; !frameFlatteningEnabled() &amp;&amp; body-&gt;renderer())
1210             body-&gt;renderer()-&gt;setChildNeedsLayout();
1211     }
1212     auto firstLayout = !layoutContext().didFirstLayout();
1213     if (firstLayout) {
1214         m_lastViewportSize = sizeForResizeEvent();
1215         m_lastZoomFactor = layoutRoot-&gt;style().zoom();
1216         m_firstLayoutCallbackPending = true;
1217     }
1218     adjustScrollbarsForLayout(firstLayout);
1219 
1220     auto oldSize = m_size;
1221     LayoutSize newSize = layoutSize();
1222     if (oldSize != newSize) {
1223         m_size = newSize;
1224         LOG(Layout, &quot;  layout size changed from %.3fx%.3f to %.3fx%.3f&quot;, oldSize.width().toFloat(), oldSize.height().toFloat(),     newSize.width().toFloat(), newSize.height().toFloat());
1225         layoutContext().setNeedsFullRepaint();
1226         if (!firstLayout)
1227             markRootOrBodyRendererDirty();
1228     }
1229     forceLayoutParentViewIfNeeded();
1230 }
1231 
1232 void FrameView::didLayout(WeakPtr&lt;RenderElement&gt; layoutRoot)
1233 {
1234     renderView()-&gt;releaseProtectedRenderWidgets();
1235     auto* layoutRootEnclosingLayer = layoutRoot-&gt;enclosingLayer();
1236     layoutRootEnclosingLayer-&gt;updateLayerPositionsAfterLayout(!is&lt;RenderView&gt;(*layoutRoot), layoutContext().needsFullRepaint());
1237 
1238     updateCompositingLayersAfterLayout();
1239 
1240 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
1241     if (auto* cache = frame().document()-&gt;existingAXObjectCache())
1242         cache-&gt;postNotification(layoutRoot.get(), AXObjectCache::AXLayoutComplete);
1243 #endif
1244 
1245     frame().document()-&gt;invalidateRenderingDependentRegions();
1246 
1247     updateCanBlitOnScrollRecursively();
1248 
1249     handleDeferredScrollUpdateAfterContentSizeChange();
1250 
1251     handleDeferredScrollbarsUpdateAfterDirectionChange();
1252 
1253     if (frame().document()-&gt;hasListenerType(Document::OVERFLOWCHANGED_LISTENER))
1254         updateOverflowStatus(layoutWidth() &lt; contentsWidth(), layoutHeight() &lt; contentsHeight());
1255 
1256     frame().document()-&gt;markers().invalidateRectsForAllMarkers();
1257 }
1258 
1259 bool FrameView::shouldDeferScrollUpdateAfterContentSizeChange()
1260 {
1261     return (layoutContext().layoutPhase() &lt; FrameViewLayoutContext::LayoutPhase::InPostLayout) &amp;&amp; (layoutContext().layoutPhase() != FrameViewLayoutContext::LayoutPhase::OutsideLayout);
1262 }
1263 
1264 RenderBox* FrameView::embeddedContentBox() const
1265 {
1266     RenderView* renderView = this-&gt;renderView();
1267     if (!renderView)
1268         return nullptr;
1269 
1270     RenderObject* firstChild = renderView-&gt;firstChild();
1271 
1272     // Curently only embedded SVG documents participate in the size-negotiation logic.
1273     if (is&lt;RenderSVGRoot&gt;(firstChild))
1274         return downcast&lt;RenderSVGRoot&gt;(firstChild);
1275 
1276     return nullptr;
1277 }
1278 
1279 void FrameView::addEmbeddedObjectToUpdate(RenderEmbeddedObject&amp; embeddedObject)
1280 {
1281     if (!m_embeddedObjectsToUpdate)
1282         m_embeddedObjectsToUpdate = makeUnique&lt;ListHashSet&lt;RenderEmbeddedObject*&gt;&gt;();
1283 
1284     HTMLFrameOwnerElement&amp; element = embeddedObject.frameOwnerElement();
1285     if (is&lt;HTMLObjectElement&gt;(element) || is&lt;HTMLEmbedElement&gt;(element)) {
1286         // Tell the DOM element that it needs a widget update.
1287         HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
1288         if (!pluginElement.needsCheckForSizeChange())
1289             pluginElement.setNeedsWidgetUpdate(true);
1290     }
1291 
1292     m_embeddedObjectsToUpdate-&gt;add(&amp;embeddedObject);
1293 }
1294 
1295 void FrameView::removeEmbeddedObjectToUpdate(RenderEmbeddedObject&amp; embeddedObject)
1296 {
1297     if (!m_embeddedObjectsToUpdate)
1298         return;
1299 
1300     m_embeddedObjectsToUpdate-&gt;remove(&amp;embeddedObject);
1301 }
1302 
1303 void FrameView::setMediaType(const String&amp; mediaType)
1304 {
1305     m_mediaType = mediaType;
1306 }
1307 
1308 String FrameView::mediaType() const
1309 {
1310     // See if we have an override type.
1311     String overrideType = frame().loader().client().overrideMediaType();
1312     InspectorInstrumentation::applyEmulatedMedia(frame(), overrideType);
1313     if (!overrideType.isNull())
1314         return overrideType;
1315     return m_mediaType;
1316 }
1317 
1318 void FrameView::adjustMediaTypeForPrinting(bool printing)
1319 {
1320     if (printing) {
1321         if (m_mediaTypeWhenNotPrinting.isNull())
1322             m_mediaTypeWhenNotPrinting = mediaType();
1323         setMediaType(&quot;print&quot;);
1324     } else {
1325         if (!m_mediaTypeWhenNotPrinting.isNull())
1326             setMediaType(m_mediaTypeWhenNotPrinting);
1327         m_mediaTypeWhenNotPrinting = String();
1328     }
1329 }
1330 
1331 bool FrameView::useSlowRepaints(bool considerOverlap) const
1332 {
1333     bool mustBeSlow = hasSlowRepaintObjects() || (platformWidget() &amp;&amp; hasViewportConstrainedObjects());
1334 
1335     // FIXME: WidgetMac.mm makes the assumption that useSlowRepaints ==
1336     // m_contentIsOpaque, so don&#39;t take the fast path for composited layers
1337     // if they are a platform widget in order to get painting correctness
1338     // for transparent layers. See the comment in WidgetMac::paint.
1339     if (usesCompositedScrolling() &amp;&amp; !platformWidget())
1340         return mustBeSlow;
1341 
1342     bool isOverlapped = m_isOverlapped &amp;&amp; considerOverlap;
1343 
1344     if (mustBeSlow || m_cannotBlitToWindow || isOverlapped || !m_contentIsOpaque)
1345         return true;
1346 
1347     if (FrameView* parentView = parentFrameView())
1348         return parentView-&gt;useSlowRepaints(considerOverlap);
1349 
1350     return false;
1351 }
1352 
1353 bool FrameView::useSlowRepaintsIfNotOverlapped() const
1354 {
1355     return useSlowRepaints(false);
1356 }
1357 
1358 void FrameView::updateCanBlitOnScrollRecursively()
1359 {
1360     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
1361         if (FrameView* view = frame-&gt;view())
1362             view-&gt;setCanBlitOnScroll(!view-&gt;useSlowRepaints());
1363     }
1364 }
1365 
1366 bool FrameView::usesCompositedScrolling() const
1367 {
1368     RenderView* renderView = this-&gt;renderView();
1369     if (renderView &amp;&amp; renderView-&gt;isComposited()) {
1370         GraphicsLayer* layer = renderView-&gt;layer()-&gt;backing()-&gt;graphicsLayer();
1371         if (layer &amp;&amp; layer-&gt;drawsContent())
1372             return true;
1373     }
1374 
1375     return false;
1376 }
1377 
1378 bool FrameView::usesAsyncScrolling() const
1379 {
1380 #if ENABLE(ASYNC_SCROLLING)
1381     if (Page* page = frame().page()) {
1382         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1383             return scrollingCoordinator-&gt;coordinatesScrollingForFrameView(*this);
1384     }
1385 #endif
1386     return false;
1387 }
1388 
1389 bool FrameView::usesMockScrollAnimator() const
1390 {
1391     return DeprecatedGlobalSettings::usesMockScrollAnimator();
1392 }
1393 
1394 void FrameView::logMockScrollAnimatorMessage(const String&amp; message) const
1395 {
1396     Document* document = frame().document();
1397     if (!document)
1398         return;
1399     StringBuilder builder;
1400     if (frame().isMainFrame())
1401         builder.appendLiteral(&quot;Main&quot;);
1402     builder.appendLiteral(&quot;FrameView: &quot;);
1403     builder.append(message);
1404     document-&gt;addConsoleMessage(MessageSource::Other, MessageLevel::Debug, builder.toString());
1405 }
1406 
1407 void FrameView::setCannotBlitToWindow()
1408 {
1409     m_cannotBlitToWindow = true;
1410     updateCanBlitOnScrollRecursively();
1411 }
1412 
1413 void FrameView::addSlowRepaintObject(RenderElement&amp; renderer)
1414 {
1415     bool hadSlowRepaintObjects = hasSlowRepaintObjects();
1416 
1417     if (!m_slowRepaintObjects)
1418         m_slowRepaintObjects = makeUnique&lt;HashSet&lt;const RenderElement*&gt;&gt;();
1419 
1420     m_slowRepaintObjects-&gt;add(&amp;renderer);
1421     if (hadSlowRepaintObjects)
1422         return;
1423 
1424     updateCanBlitOnScrollRecursively();
1425 
1426     if (auto* page = frame().page()) {
1427         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
1428             scrollingCoordinator-&gt;frameViewHasSlowRepaintObjectsDidChange(*this);
1429     }
1430 }
1431 
1432 void FrameView::removeSlowRepaintObject(RenderElement&amp; renderer)
1433 {
1434     if (!m_slowRepaintObjects)
1435         return;
1436 
1437     m_slowRepaintObjects-&gt;remove(&amp;renderer);
1438     if (!m_slowRepaintObjects-&gt;isEmpty())
1439         return;
1440 
1441     m_slowRepaintObjects = nullptr;
1442     updateCanBlitOnScrollRecursively();
1443 
1444     if (auto* page = frame().page()) {
1445         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
1446             scrollingCoordinator-&gt;frameViewHasSlowRepaintObjectsDidChange(*this);
1447     }
1448 }
1449 
1450 void FrameView::addViewportConstrainedObject(RenderLayerModelObject* object)
1451 {
1452     if (!m_viewportConstrainedObjects)
1453         m_viewportConstrainedObjects = makeUnique&lt;ViewportConstrainedObjectSet&gt;();
1454 
1455     if (!m_viewportConstrainedObjects-&gt;contains(object)) {
1456         m_viewportConstrainedObjects-&gt;add(object);
1457         if (platformWidget())
1458             updateCanBlitOnScrollRecursively();
1459 
1460         if (Page* page = frame().page()) {
1461             if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1462                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(*this);
1463         }
1464     }
1465 }
1466 
1467 void FrameView::removeViewportConstrainedObject(RenderLayerModelObject* object)
1468 {
1469     if (m_viewportConstrainedObjects &amp;&amp; m_viewportConstrainedObjects-&gt;remove(object)) {
1470         if (Page* page = frame().page()) {
1471             if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1472                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(*this);
1473         }
1474 
1475         // FIXME: In addFixedObject() we only call this if there&#39;s a platform widget,
1476         // why isn&#39;t the same check being made here?
1477         updateCanBlitOnScrollRecursively();
1478     }
1479 }
1480 
1481 LayoutSize FrameView::expandedLayoutViewportSize(const LayoutSize&amp; baseLayoutViewportSize, const LayoutSize&amp; documentSize, double heightExpansionFactor)
1482 {
1483     if (!heightExpansionFactor)
1484         return baseLayoutViewportSize;
1485 
1486     auto documentHeight = documentSize.height();
1487     auto layoutViewportHeight = baseLayoutViewportSize.height();
1488     if (layoutViewportHeight &gt; documentHeight)
1489         return baseLayoutViewportSize;
1490 
1491     return { baseLayoutViewportSize.width(), std::min(documentHeight, LayoutUnit((1 + heightExpansionFactor) * layoutViewportHeight)) };
1492 }
1493 
1494 LayoutRect FrameView::computeUpdatedLayoutViewportRect(const LayoutRect&amp; layoutViewport, const LayoutRect&amp; documentRect, const LayoutSize&amp; unobscuredContentSize, const LayoutRect&amp; unobscuredContentRect, const LayoutSize&amp; baseLayoutViewportSize, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, LayoutViewportConstraint constraint)
1495 {
1496     LayoutRect layoutViewportRect = layoutViewport;
1497 
1498     // The layout viewport is never smaller than baseLayoutViewportSize, and never be smaller than the unobscuredContentRect.
1499     LayoutSize constrainedSize = baseLayoutViewportSize;
1500     layoutViewportRect.setSize(constrainedSize.expandedTo(unobscuredContentSize));
1501 
1502     LayoutPoint layoutViewportOrigin = computeLayoutViewportOrigin(unobscuredContentRect, stableLayoutViewportOriginMin, stableLayoutViewportOriginMax, layoutViewportRect, StickToViewportBounds);
1503 
1504     // FIXME: Is this equivalent to calling computeLayoutViewportOrigin() with StickToDocumentBounds?
1505     if (constraint == LayoutViewportConstraint::ConstrainedToDocumentRect) {
1506         // The max stable layout viewport origin really depends on the size of the layout viewport itself, so we need to adjust the location of the layout viewport one final time to make sure it does not end up out of bounds of the document.
1507         // Without this adjustment (and with using the non-constrained unobscuredContentRect&#39;s size as the size of the layout viewport) the layout viewport can be pushed past the bounds of the document during rubber-banding, and cannot be pushed
1508         // back in until the user scrolls back in the other direction.
1509         layoutViewportOrigin.setX(clampTo&lt;float&gt;(layoutViewportOrigin.x().toFloat(), 0, documentRect.width() - layoutViewportRect.width()));
1510         layoutViewportOrigin.setY(clampTo&lt;float&gt;(layoutViewportOrigin.y().toFloat(), 0, documentRect.height() - layoutViewportRect.height()));
1511     }
1512     layoutViewportRect.setLocation(layoutViewportOrigin);
1513 
1514     return layoutViewportRect;
1515 }
1516 
1517 // visualViewport and layoutViewport are both in content coordinates (unzoomed).
1518 LayoutPoint FrameView::computeLayoutViewportOrigin(const LayoutRect&amp; visualViewport, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, const LayoutRect&amp; layoutViewport, ScrollBehaviorForFixedElements fixedBehavior)
1519 {
1520     LayoutPoint layoutViewportOrigin = layoutViewport.location();
1521     bool allowRubberBanding = fixedBehavior == StickToViewportBounds;
1522 
1523     if (visualViewport.width() &gt; layoutViewport.width()) {
1524         layoutViewportOrigin.setX(visualViewport.x());
1525         if (!allowRubberBanding) {
1526             if (layoutViewportOrigin.x() &lt; stableLayoutViewportOriginMin.x())
1527                 layoutViewportOrigin.setX(stableLayoutViewportOriginMin.x());
1528             else if (layoutViewportOrigin.x() &gt; stableLayoutViewportOriginMax.x())
1529                 layoutViewportOrigin.setX(stableLayoutViewportOriginMax.x());
1530         }
1531     } else {
1532         bool rubberbandingAtLeft = allowRubberBanding &amp;&amp; visualViewport.x() &lt; stableLayoutViewportOriginMin.x();
1533         bool rubberbandingAtRight = allowRubberBanding &amp;&amp; (visualViewport.maxX() - layoutViewport.width()) &gt; stableLayoutViewportOriginMax.x();
1534 
1535         if (visualViewport.x() &lt; layoutViewport.x() || rubberbandingAtLeft)
1536             layoutViewportOrigin.setX(visualViewport.x());
1537 
1538         if (visualViewport.maxX() &gt; layoutViewport.maxX() || rubberbandingAtRight)
1539             layoutViewportOrigin.setX(visualViewport.maxX() - layoutViewport.width());
1540 
1541         if (!rubberbandingAtLeft &amp;&amp; layoutViewportOrigin.x() &lt; stableLayoutViewportOriginMin.x())
1542             layoutViewportOrigin.setX(stableLayoutViewportOriginMin.x());
1543 
1544         if (!rubberbandingAtRight &amp;&amp; layoutViewportOrigin.x() &gt; stableLayoutViewportOriginMax.x())
1545             layoutViewportOrigin.setX(stableLayoutViewportOriginMax.x());
1546     }
1547 
1548     if (visualViewport.height() &gt; layoutViewport.height()) {
1549         layoutViewportOrigin.setY(visualViewport.y());
1550         if (!allowRubberBanding) {
1551             if (layoutViewportOrigin.y() &lt; stableLayoutViewportOriginMin.y())
1552                 layoutViewportOrigin.setY(stableLayoutViewportOriginMin.y());
1553             else if (layoutViewportOrigin.y() &gt; stableLayoutViewportOriginMax.y())
1554                 layoutViewportOrigin.setY(stableLayoutViewportOriginMax.y());
1555         }
1556     } else {
1557         bool rubberbandingAtTop = allowRubberBanding &amp;&amp; visualViewport.y() &lt; stableLayoutViewportOriginMin.y();
1558         bool rubberbandingAtBottom = allowRubberBanding &amp;&amp; (visualViewport.maxY() - layoutViewport.height()) &gt; stableLayoutViewportOriginMax.y();
1559 
1560         if (visualViewport.y() &lt; layoutViewport.y() || rubberbandingAtTop)
1561             layoutViewportOrigin.setY(visualViewport.y());
1562 
1563         if (visualViewport.maxY() &gt; layoutViewport.maxY() || rubberbandingAtBottom)
1564             layoutViewportOrigin.setY(visualViewport.maxY() - layoutViewport.height());
1565 
1566         if (!rubberbandingAtTop &amp;&amp; layoutViewportOrigin.y() &lt; stableLayoutViewportOriginMin.y())
1567             layoutViewportOrigin.setY(stableLayoutViewportOriginMin.y());
1568 
1569         if (!rubberbandingAtBottom &amp;&amp; layoutViewportOrigin.y() &gt; stableLayoutViewportOriginMax.y())
1570             layoutViewportOrigin.setY(stableLayoutViewportOriginMax.y());
1571     }
1572 
1573     return layoutViewportOrigin;
1574 }
1575 
1576 void FrameView::setBaseLayoutViewportOrigin(LayoutPoint origin, TriggerLayoutOrNot layoutTriggering)
1577 {
1578     ASSERT(frame().settings().visualViewportEnabled());
1579 
1580     if (origin == m_layoutViewportOrigin)
1581         return;
1582 
1583     m_layoutViewportOrigin = origin;
1584     if (layoutTriggering == TriggerLayoutOrNot::Yes)
1585         setViewportConstrainedObjectsNeedLayout();
1586 
1587     if (TiledBacking* tiledBacking = this-&gt;tiledBacking()) {
1588         FloatRect layoutViewport = layoutViewportRect();
1589         layoutViewport.moveBy(unscaledScrollOrigin()); // tiledBacking deals in top-left relative coordinates.
1590         tiledBacking-&gt;setLayoutViewportRect(layoutViewport);
1591     }
1592 }
1593 
1594 void FrameView::setLayoutViewportOverrideRect(Optional&lt;LayoutRect&gt; rect, TriggerLayoutOrNot layoutTriggering)
1595 {
1596     if (rect == m_layoutViewportOverrideRect)
1597         return;
1598 
1599     LayoutRect oldRect = layoutViewportRect();
1600     m_layoutViewportOverrideRect = rect;
1601 
1602     // Triggering layout on height changes is necessary to make bottom-fixed elements behave correctly.
1603     if (oldRect.height() != layoutViewportRect().height())
1604         layoutTriggering = TriggerLayoutOrNot::Yes;
1605 
1606     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;\nFrameView &quot; &lt;&lt; this &lt;&lt; &quot; setLayoutViewportOverrideRect() - changing override layout viewport from &quot; &lt;&lt; oldRect &lt;&lt; &quot; to &quot; &lt;&lt; m_layoutViewportOverrideRect.valueOr(LayoutRect()) &lt;&lt; &quot; layoutTriggering &quot; &lt;&lt; (layoutTriggering == TriggerLayoutOrNot::Yes ? &quot;yes&quot; : &quot;no&quot;));
1607 
1608     if (oldRect != layoutViewportRect() &amp;&amp; layoutTriggering == TriggerLayoutOrNot::Yes)
1609         setViewportConstrainedObjectsNeedLayout();
1610 }
1611 
1612 void FrameView::setVisualViewportOverrideRect(Optional&lt;LayoutRect&gt; rect)
1613 {
1614     m_visualViewportOverrideRect = rect;
1615 }
1616 
1617 LayoutSize FrameView::baseLayoutViewportSize() const
1618 {
1619     return renderView() ? renderView()-&gt;size() : size();
1620 }
1621 
1622 void FrameView::updateLayoutViewport()
1623 {
1624     if (!frame().settings().visualViewportEnabled())
1625         return;
1626 
1627     // Don&#39;t update the layout viewport if we&#39;re in the middle of adjusting scrollbars. We&#39;ll get another call
1628     // as a post-layout task.
1629     if (layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::InViewSizeAdjust)
1630         return;
1631 
1632     LayoutRect layoutViewport = layoutViewportRect();
1633 
1634     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;\nFrameView &quot; &lt;&lt; this &lt;&lt; &quot; updateLayoutViewport() totalContentSize &quot; &lt;&lt; totalContentsSize() &lt;&lt; &quot; unscaledDocumentRect &quot; &lt;&lt; (renderView() ? renderView()-&gt;unscaledDocumentRect() : IntRect()) &lt;&lt; &quot; header height &quot; &lt;&lt; headerHeight() &lt;&lt; &quot; footer height &quot; &lt;&lt; footerHeight() &lt;&lt; &quot; fixed behavior &quot; &lt;&lt; scrollBehaviorForFixedElements());
1635     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport: &quot; &lt;&lt; layoutViewport);
1636     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;visualViewport: &quot; &lt;&lt; visualViewportRect() &lt;&lt; &quot; (is override &quot; &lt;&lt; (bool)m_visualViewportOverrideRect &lt;&lt; &quot;)&quot;);
1637     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;stable origins: min: &quot; &lt;&lt; minStableLayoutViewportOrigin() &lt;&lt; &quot; max: &quot;&lt;&lt; maxStableLayoutViewportOrigin());
1638 
1639     if (m_layoutViewportOverrideRect) {
1640         if (currentScrollType() == ScrollType::Programmatic) {
1641             LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;computing new override layout viewport because of programmatic scrolling&quot;);
1642             LayoutPoint newOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, StickToDocumentBounds);
1643             setLayoutViewportOverrideRect(LayoutRect(newOrigin, m_layoutViewportOverrideRect.value().size()));
1644         }
1645         layoutOrVisualViewportChanged();
1646         return;
1647     }
1648 
1649     LayoutPoint newLayoutViewportOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, scrollBehaviorForFixedElements());
1650     if (newLayoutViewportOrigin != m_layoutViewportOrigin) {
1651         setBaseLayoutViewportOrigin(newLayoutViewportOrigin);
1652         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport changed to &quot; &lt;&lt; layoutViewportRect());
1653     }
1654     layoutOrVisualViewportChanged();
1655 }
1656 
1657 LayoutPoint FrameView::minStableLayoutViewportOrigin() const
1658 {
1659     return unscaledMinimumScrollPosition();
1660 }
1661 
1662 LayoutPoint FrameView::maxStableLayoutViewportOrigin() const
1663 {
1664     LayoutPoint maxPosition = unscaledMaximumScrollPosition();
1665     maxPosition = (maxPosition - LayoutSize(0, headerHeight() + footerHeight())).expandedTo({ });
1666     return maxPosition;
1667 }
1668 
1669 IntPoint FrameView::unscaledScrollOrigin() const
1670 {
1671     if (RenderView* renderView = this-&gt;renderView())
1672         return -renderView-&gt;unscaledDocumentRect().location(); // Akin to code in adjustViewSize().
1673 
1674     return { };
1675 }
1676 
1677 LayoutRect FrameView::layoutViewportRect() const
1678 {
1679     if (m_layoutViewportOverrideRect)
1680         return m_layoutViewportOverrideRect.value();
1681 
1682     // Size of initial containing block, anchored at scroll position, in document coordinates (unchanged by scale factor).
1683     return LayoutRect(m_layoutViewportOrigin, baseLayoutViewportSize());
1684 }
1685 
1686 // visibleContentRect is in the bounds of the scroll view content. That consists of an
1687 // optional header, the document, and an optional footer. Only the document is scaled,
1688 // so we have to compute the visible part of the document in unscaled document coordinates.
1689 // On iOS, pageScaleFactor is always 1 here, and we never have headers and footers.
1690 LayoutRect FrameView::visibleDocumentRect(const FloatRect&amp; visibleContentRect, float headerHeight, float footerHeight, const FloatSize&amp; totalContentsSize, float pageScaleFactor)
1691 {
1692     float contentsHeight = totalContentsSize.height() - headerHeight - footerHeight;
1693 
1694     float rubberBandTop = std::min&lt;float&gt;(visibleContentRect.y(), 0);
1695     float visibleScaledDocumentTop = std::max&lt;float&gt;(visibleContentRect.y() - headerHeight, 0) + rubberBandTop;
1696 
1697     float rubberBandBottom = std::min&lt;float&gt;((totalContentsSize.height() - visibleContentRect.y()) - visibleContentRect.height(), 0);
1698     float visibleScaledDocumentBottom = std::min&lt;float&gt;(visibleContentRect.maxY() - headerHeight, contentsHeight) - rubberBandBottom;
1699 
1700     FloatRect visibleDocumentRect = visibleContentRect;
1701     visibleDocumentRect.setY(visibleScaledDocumentTop);
1702     visibleDocumentRect.setHeight(std::max&lt;float&gt;(visibleScaledDocumentBottom - visibleScaledDocumentTop, 0));
1703     visibleDocumentRect.scale(1 / pageScaleFactor);
1704 
1705     return LayoutRect(visibleDocumentRect);
1706 }
1707 
1708 LayoutRect FrameView::visualViewportRect() const
1709 {
1710     if (m_visualViewportOverrideRect)
1711         return m_visualViewportOverrideRect.value();
1712 
1713     FloatRect visibleContentRect = this-&gt;visibleContentRect(LegacyIOSDocumentVisibleRect);
1714     return visibleDocumentRect(visibleContentRect, headerHeight(), footerHeight(), totalContentsSize(), frameScaleFactor());
1715 }
1716 
1717 LayoutRect FrameView::viewportConstrainedVisibleContentRect() const
1718 {
1719     ASSERT(!frame().settings().visualViewportEnabled());
1720 
1721 #if PLATFORM(IOS_FAMILY)
1722     if (useCustomFixedPositionLayoutRect())
1723         return customFixedPositionLayoutRect();
1724 #endif
1725     LayoutRect viewportRect = visibleContentRect();
1726 
1727     viewportRect.setLocation(scrollPositionForFixedPosition());
1728     return viewportRect;
1729 }
1730 
1731 LayoutRect FrameView::rectForFixedPositionLayout() const
1732 {
1733     if (frame().settings().visualViewportEnabled())
1734         return layoutViewportRect();
1735 
1736     return viewportConstrainedVisibleContentRect();
1737 }
1738 
1739 float FrameView::frameScaleFactor() const
1740 {
1741     return frame().frameScaleFactor();
1742 }
1743 
1744 LayoutPoint FrameView::scrollPositionForFixedPosition() const
1745 {
1746     if (frame().settings().visualViewportEnabled())
1747         return layoutViewportRect().location();
1748 
1749     return scrollPositionForFixedPosition(visibleContentRect(), totalContentsSize(), scrollPosition(), scrollOrigin(), frameScaleFactor(), fixedElementsLayoutRelativeToFrame(), scrollBehaviorForFixedElements(), headerHeight(), footerHeight());
1750 }
1751 
1752 LayoutPoint FrameView::scrollPositionForFixedPosition(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, const LayoutPoint&amp; scrollPosition, const LayoutPoint&amp; scrollOrigin, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements behaviorForFixed, int headerHeight, int footerHeight)
1753 {
1754     LayoutPoint position;
1755     if (behaviorForFixed == StickToDocumentBounds)
1756         position = ScrollableArea::constrainScrollPositionForOverhang(visibleContentRect, totalContentsSize, scrollPosition, scrollOrigin, headerHeight, footerHeight);
1757     else {
1758         position = scrollPosition;
1759         position.setY(position.y() - headerHeight);
1760     }
1761 
1762     LayoutSize maxSize = totalContentsSize - visibleContentRect.size();
1763 
1764     float dragFactorX = (fixedElementsLayoutRelativeToFrame || !maxSize.width()) ? 1 : (totalContentsSize.width() - visibleContentRect.width() * frameScaleFactor) / maxSize.width();
1765     float dragFactorY = (fixedElementsLayoutRelativeToFrame || !maxSize.height()) ? 1 : (totalContentsSize.height() - visibleContentRect.height() * frameScaleFactor) / maxSize.height();
1766 
1767     return LayoutPoint(position.x() * dragFactorX / frameScaleFactor, position.y() * dragFactorY / frameScaleFactor);
1768 }
1769 
1770 float FrameView::yPositionForInsetClipLayer(const FloatPoint&amp; scrollPosition, float topContentInset)
1771 {
1772     if (!topContentInset)
1773         return 0;
1774 
1775     // The insetClipLayer should not move for negative scroll values.
1776     float scrollY = std::max&lt;float&gt;(0, scrollPosition.y());
1777 
1778     if (scrollY &gt;= topContentInset)
1779         return 0;
1780 
1781     return topContentInset - scrollY;
1782 }
1783 
1784 float FrameView::yPositionForHeaderLayer(const FloatPoint&amp; scrollPosition, float topContentInset)
1785 {
1786     if (!topContentInset)
1787         return 0;
1788 
1789     float scrollY = std::max&lt;float&gt;(0, scrollPosition.y());
1790 
1791     if (scrollY &gt;= topContentInset)
1792         return topContentInset;
1793 
1794     return scrollY;
1795 }
1796 
1797 float FrameView::yPositionForFooterLayer(const FloatPoint&amp; scrollPosition, float topContentInset, float totalContentsHeight, float footerHeight)
1798 {
1799     return yPositionForHeaderLayer(scrollPosition, topContentInset) + totalContentsHeight - footerHeight;
1800 }
1801 
1802 FloatPoint FrameView::positionForRootContentLayer(const FloatPoint&amp; scrollPosition, const FloatPoint&amp; scrollOrigin, float topContentInset, float headerHeight)
1803 {
1804     return FloatPoint(0, yPositionForHeaderLayer(scrollPosition, topContentInset) + headerHeight) - toFloatSize(scrollOrigin);
1805 }
1806 
1807 FloatPoint FrameView::positionForRootContentLayer() const
1808 {
1809     return positionForRootContentLayer(scrollPosition(), scrollOrigin(), topContentInset(), headerHeight());
1810 }
1811 
1812 #if PLATFORM(IOS_FAMILY)
1813 LayoutRect FrameView::rectForViewportConstrainedObjects(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements scrollBehavior)
1814 {
1815     if (fixedElementsLayoutRelativeToFrame)
1816         return visibleContentRect;
1817 
1818     if (totalContentsSize.isEmpty())
1819         return visibleContentRect;
1820 
1821     // We impose an lower limit on the size (so an upper limit on the scale) of
1822     // the rect used to position fixed objects so that they don&#39;t crowd into the
1823     // center of the screen at larger scales.
1824     const LayoutUnit maxContentWidthForZoomThreshold = 1024_lu;
1825     float zoomedOutScale = frameScaleFactor * visibleContentRect.width() / std::min(maxContentWidthForZoomThreshold, totalContentsSize.width());
1826     float constraintThresholdScale = 1.5 * zoomedOutScale;
1827     float maxPostionedObjectsRectScale = std::min(frameScaleFactor, constraintThresholdScale);
1828 
1829     LayoutRect viewportConstrainedObjectsRect = visibleContentRect;
1830 
1831     if (frameScaleFactor &gt; constraintThresholdScale) {
1832         FloatRect contentRect(FloatPoint(), totalContentsSize);
1833         FloatRect viewportRect = visibleContentRect;
1834 
1835         // Scale the rect up from a point that is relative to its position in the viewport.
1836         FloatSize sizeDelta = contentRect.size() - viewportRect.size();
1837 
1838         FloatPoint scaleOrigin;
1839         scaleOrigin.setX(contentRect.x() + sizeDelta.width() &gt; 0 ? contentRect.width() * (viewportRect.x() - contentRect.x()) / sizeDelta.width() : 0);
1840         scaleOrigin.setY(contentRect.y() + sizeDelta.height() &gt; 0 ? contentRect.height() * (viewportRect.y() - contentRect.y()) / sizeDelta.height() : 0);
1841 
1842         AffineTransform rescaleTransform = AffineTransform::translation(scaleOrigin.x(), scaleOrigin.y());
1843         rescaleTransform.scale(frameScaleFactor / maxPostionedObjectsRectScale, frameScaleFactor / maxPostionedObjectsRectScale);
1844         rescaleTransform = CGAffineTransformTranslate(rescaleTransform, -scaleOrigin.x(), -scaleOrigin.y());
1845 
1846         viewportConstrainedObjectsRect = enclosingLayoutRect(rescaleTransform.mapRect(visibleContentRect));
1847     }
1848 
1849     if (scrollBehavior == StickToDocumentBounds) {
1850         LayoutRect documentBounds(LayoutPoint(), totalContentsSize);
1851         viewportConstrainedObjectsRect.intersect(documentBounds);
1852     }
1853 
1854     return viewportConstrainedObjectsRect;
1855 }
1856 
1857 LayoutRect FrameView::viewportConstrainedObjectsRect() const
1858 {
1859     return rectForViewportConstrainedObjects(visibleContentRect(), totalContentsSize(), frame().frameScaleFactor(), fixedElementsLayoutRelativeToFrame(), scrollBehaviorForFixedElements());
1860 }
1861 #endif
1862 
1863 ScrollPosition FrameView::minimumScrollPosition() const
1864 {
1865     ScrollPosition minimumPosition = ScrollView::minimumScrollPosition();
1866 
1867     if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToBottom)
1868         minimumPosition.setY(maximumScrollPosition().y());
1869 
1870     return minimumPosition;
1871 }
1872 
1873 ScrollPosition FrameView::maximumScrollPosition() const
1874 {
1875     ScrollPosition maximumPosition = ScrollView::maximumScrollPosition();
1876 
1877     if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToTop)
1878         maximumPosition.setY(minimumScrollPosition().y());
1879 
1880     return maximumPosition;
1881 }
1882 
1883 ScrollPosition FrameView::unscaledMinimumScrollPosition() const
1884 {
1885     if (RenderView* renderView = this-&gt;renderView()) {
1886         IntRect unscaledDocumentRect = renderView-&gt;unscaledDocumentRect();
1887         ScrollPosition minimumPosition = unscaledDocumentRect.location();
1888 
1889         if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToBottom)
1890             minimumPosition.setY(unscaledMaximumScrollPosition().y());
1891 
1892         return minimumPosition;
1893     }
1894 
1895     return minimumScrollPosition();
1896 }
1897 
1898 ScrollPosition FrameView::unscaledMaximumScrollPosition() const
1899 {
1900     if (RenderView* renderView = this-&gt;renderView()) {
1901         IntRect unscaledDocumentRect = renderView-&gt;unscaledDocumentRect();
1902         unscaledDocumentRect.expand(0, headerHeight() + footerHeight());
1903         ScrollPosition maximumPosition = ScrollPosition(unscaledDocumentRect.maxXMaxYCorner() - visibleSize()).expandedTo({ 0, 0 });
1904         if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToTop)
1905             maximumPosition.setY(unscaledMinimumScrollPosition().y());
1906 
1907         return maximumPosition;
1908     }
1909 
1910     return maximumScrollPosition();
1911 }
1912 
1913 void FrameView::viewportContentsChanged()
1914 {
1915     if (!frame().view()) {
1916         // The frame is being destroyed.
1917         return;
1918     }
1919 
1920     if (auto* page = frame().page())
1921         page-&gt;updateValidationBubbleStateIfNeeded();
1922 
1923     // When the viewport contents changes (scroll, resize, style recalc, layout, ...),
1924     // check if we should resume animated images or unthrottle DOM timers.
1925     applyRecursivelyWithVisibleRect([] (FrameView&amp; frameView, const IntRect&amp; visibleRect) {
1926         frameView.resumeVisibleImageAnimations(visibleRect);
1927         frameView.updateScriptedAnimationsAndTimersThrottlingState(visibleRect);
1928 
1929         if (auto* renderView = frameView.frame().contentRenderer())
1930             renderView-&gt;updateVisibleViewportRect(visibleRect);
1931     });
1932 }
1933 
1934 IntRect FrameView::viewRectExpandedByContentInsets() const
1935 {
1936     FloatRect viewRect;
1937     if (delegatesScrolling() &amp;&amp; platformWidget())
1938         viewRect = unobscuredContentRect();
1939     else
1940         viewRect = visualViewportRect();
1941 
1942     if (auto* page = frame().page())
1943         viewRect.expand(page-&gt;contentInsets());
1944 
1945     return IntRect(viewRect);
1946 }
1947 
1948 bool FrameView::fixedElementsLayoutRelativeToFrame() const
1949 {
1950     return frame().settings().fixedElementsLayoutRelativeToFrame();
1951 }
1952 
1953 IntPoint FrameView::lastKnownMousePosition() const
1954 {
1955     return frame().eventHandler().lastKnownMousePosition();
1956 }
1957 
1958 bool FrameView::isHandlingWheelEvent() const
1959 {
1960     return frame().eventHandler().isHandlingWheelEvent();
1961 }
1962 
1963 bool FrameView::shouldSetCursor() const
1964 {
1965     Page* page = frame().page();
1966     return page &amp;&amp; page-&gt;isVisible() &amp;&amp; page-&gt;focusController().isActive();
1967 }
1968 
1969 #if ENABLE(DARK_MODE_CSS)
1970 RenderObject* FrameView::rendererForColorScheme() const
1971 {
1972     auto* document = frame().document();
1973     auto* documentElement = document ? document-&gt;documentElement() : nullptr;
1974     auto* documentElementRenderer = documentElement ? documentElement-&gt;renderer() : nullptr;
1975     if (documentElementRenderer &amp;&amp; documentElementRenderer-&gt;style().hasExplicitlySetColorScheme())
1976         return documentElementRenderer;
1977     auto* bodyElement = document ? document-&gt;bodyOrFrameset() : nullptr;
1978     return bodyElement ? bodyElement-&gt;renderer() : nullptr;
1979 }
1980 #endif
1981 
1982 bool FrameView::useDarkAppearance() const
1983 {
1984 #if ENABLE(DARK_MODE_CSS)
1985     if (auto* renderer = rendererForColorScheme())
1986         return renderer-&gt;useDarkAppearance();
1987 #endif
1988     if (auto* document = frame().document())
1989         return document-&gt;useDarkAppearance(nullptr);
1990     return false;
1991 }
1992 
1993 OptionSet&lt;StyleColor::Options&gt; FrameView::styleColorOptions() const
1994 {
1995 #if ENABLE(DARK_MODE_CSS)
1996     if (auto* renderer = rendererForColorScheme())
1997         return renderer-&gt;styleColorOptions();
1998 #endif
1999     if (auto* document = frame().document())
2000         return document-&gt;styleColorOptions(nullptr);
2001     return { };
2002 }
2003 
2004 bool FrameView::scrollContentsFastPath(const IntSize&amp; scrollDelta, const IntRect&amp; rectToScroll, const IntRect&amp; clipRect)
2005 {
2006     if (!m_viewportConstrainedObjects || m_viewportConstrainedObjects-&gt;isEmpty()) {
2007         frame().page()-&gt;chrome().scroll(scrollDelta, rectToScroll, clipRect);
2008         return true;
2009     }
2010 
2011     bool isCompositedContentLayer = usesCompositedScrolling();
2012 
2013     // Get the rects of the fixed objects visible in the rectToScroll
2014     Region regionToUpdate;
2015     for (auto&amp; renderer : *m_viewportConstrainedObjects) {
2016         if (!renderer-&gt;style().hasViewportConstrainedPosition())
2017             continue;
2018         if (renderer-&gt;isComposited())
2019             continue;
2020 
2021         // Fixed items should always have layers.
2022         ASSERT(renderer-&gt;hasLayer());
2023         RenderLayer* layer = downcast&lt;RenderBoxModelObject&gt;(*renderer).layer();
2024 
2025         if (layer-&gt;viewportConstrainedNotCompositedReason() == RenderLayer::NotCompositedForBoundsOutOfView
2026             || layer-&gt;viewportConstrainedNotCompositedReason() == RenderLayer::NotCompositedForNoVisibleContent) {
2027             // Don&#39;t invalidate for invisible fixed layers.
2028             continue;
2029         }
2030 
2031         if (layer-&gt;hasAncestorWithFilterOutsets()) {
2032             // If the fixed layer has a blur/drop-shadow filter applied on at least one of its parents, we cannot
2033             // scroll using the fast path, otherwise the outsets of the filter will be moved around the page.
2034             return false;
2035         }
2036 
2037         // FIXME: use pixel snapping instead of enclosing when ScrollView has finished transitioning from IntRect to Float/LayoutRect.
2038         IntRect updateRect = enclosingIntRect(layer-&gt;repaintRectIncludingNonCompositingDescendants());
2039         updateRect = contentsToRootView(updateRect);
2040         if (!isCompositedContentLayer)
2041             updateRect.intersect(rectToScroll);
2042         if (!updateRect.isEmpty())
2043             regionToUpdate.unite(updateRect);
2044     }
2045 
2046     // 1) scroll
2047     frame().page()-&gt;chrome().scroll(scrollDelta, rectToScroll, clipRect);
2048 
2049     // 2) update the area of fixed objects that has been invalidated
2050     for (auto&amp; updateRect : regionToUpdate.rects()) {
2051         IntRect scrolledRect = updateRect;
2052         scrolledRect.move(scrollDelta);
2053         updateRect.unite(scrolledRect);
2054         if (isCompositedContentLayer) {
2055             updateRect = rootViewToContents(updateRect);
2056             ASSERT(renderView());
2057             renderView()-&gt;layer()-&gt;setBackingNeedsRepaintInRect(updateRect);
2058             continue;
2059         }
2060         updateRect.intersect(rectToScroll);
2061         frame().page()-&gt;chrome().invalidateContentsAndRootView(updateRect);
2062     }
2063 
2064     return true;
2065 }
2066 
2067 void FrameView::scrollContentsSlowPath(const IntRect&amp; updateRect)
2068 {
2069     repaintSlowRepaintObjects();
2070 
2071     if (!usesCompositedScrolling() &amp;&amp; isEnclosedInCompositingLayer()) {
2072         if (RenderWidget* frameRenderer = frame().ownerRenderer()) {
2073             LayoutRect rect(frameRenderer-&gt;borderLeft() + frameRenderer-&gt;paddingLeft(), frameRenderer-&gt;borderTop() + frameRenderer-&gt;paddingTop(),
2074                 visibleWidth(), visibleHeight());
2075             frameRenderer-&gt;repaintRectangle(rect);
2076             return;
2077         }
2078     }
2079 
2080     ScrollView::scrollContentsSlowPath(updateRect);
2081 }
2082 
2083 void FrameView::repaintSlowRepaintObjects()
2084 {
2085     if (!m_slowRepaintObjects)
2086         return;
2087 
2088     // Renderers with fixed backgrounds may be in compositing layers, so we need to explicitly
2089     // repaint them after scrolling.
2090     for (auto&amp; renderer : *m_slowRepaintObjects)
2091         renderer-&gt;repaintSlowRepaintObject();
2092 }
2093 
2094 // Note that this gets called at painting time.
2095 void FrameView::setIsOverlapped(bool isOverlapped)
2096 {
2097     if (isOverlapped == m_isOverlapped)
2098         return;
2099 
2100     m_isOverlapped = isOverlapped;
2101     updateCanBlitOnScrollRecursively();
2102 }
2103 
2104 void FrameView::setContentIsOpaque(bool contentIsOpaque)
2105 {
2106     if (contentIsOpaque == m_contentIsOpaque)
2107         return;
2108 
2109     m_contentIsOpaque = contentIsOpaque;
2110     updateCanBlitOnScrollRecursively();
2111 }
2112 
2113 void FrameView::restoreScrollbar()
2114 {
2115     setScrollbarsSuppressed(false);
2116 }
2117 
2118 bool FrameView::scrollToFragment(const URL&amp; url)
2119 {
2120     String fragmentIdentifier = url.fragmentIdentifier();
2121     if (scrollToAnchor(fragmentIdentifier))
2122         return true;
2123 
2124     // Try again after decoding the ref, based on the document&#39;s encoding.
2125     if (TextResourceDecoder* decoder = frame().document()-&gt;decoder()) {
2126         if (scrollToAnchor(decodeURLEscapeSequences(fragmentIdentifier, decoder-&gt;encoding())))
2127             return true;
2128     }
2129 
2130     resetScrollAnchor();
2131     return false;
2132 }
2133 
2134 bool FrameView::scrollToAnchor(const String&amp; fragmentIdentifier)
2135 {
2136     LOG(Scrolling, &quot;FrameView::scrollToAnchor %s&quot;, fragmentIdentifier.utf8().data());
2137 
2138     // If our URL has no ref, then we have no place we need to jump to.
2139     if (fragmentIdentifier.isNull())
2140         return false;
2141 
2142     ASSERT(frame().document());
2143     auto&amp; document = *frame().document();
2144 
2145     if (!document.haveStylesheetsLoaded()) {
2146         document.setGotoAnchorNeededAfterStylesheetsLoad(true);
2147         return false;
2148     }
2149 
2150     document.setGotoAnchorNeededAfterStylesheetsLoad(false);
2151 
2152     Element* anchorElement = document.findAnchor(fragmentIdentifier);
2153 
2154     LOG(Scrolling, &quot; anchorElement is %p&quot;, anchorElement);
2155 
2156     // Setting to null will clear the current target.
2157     document.setCSSTarget(anchorElement);
2158 
2159     if (is&lt;SVGDocument&gt;(document)) {
2160         if (fragmentIdentifier.isEmpty())
2161             return false;
2162         if (auto rootElement = SVGDocument::rootElement(document)) {
2163             if (rootElement-&gt;scrollToFragment(fragmentIdentifier))
2164                 return true;
2165             // If SVG failed to scrollToAnchor() and anchorElement is null, no other scrolling will be possible.
2166             if (!anchorElement)
2167                 return false;
2168         }
2169     } else if (!anchorElement &amp;&amp; !(fragmentIdentifier.isEmpty() || equalLettersIgnoringASCIICase(fragmentIdentifier, &quot;top&quot;))) {
2170         // Implement the rule that &quot;&quot; and &quot;top&quot; both mean top of page as in other browsers.
2171         return false;
2172     }
2173 
2174     ContainerNode* scrollPositionAnchor = anchorElement;
2175     if (!scrollPositionAnchor)
2176         scrollPositionAnchor = frame().document();
2177     maintainScrollPositionAtAnchor(scrollPositionAnchor);
2178 
2179     // If the anchor accepts keyboard focus, move focus there to aid users relying on keyboard navigation.
2180     if (anchorElement) {
2181         if (anchorElement-&gt;isFocusable())
2182             document.setFocusedElement(anchorElement);
2183         else {
2184             document.setFocusedElement(nullptr);
2185             document.setFocusNavigationStartingNode(anchorElement);
2186         }
2187     }
2188 
2189     return true;
2190 }
2191 
2192 void FrameView::maintainScrollPositionAtAnchor(ContainerNode* anchorNode)
2193 {
2194     LOG(Scrolling, &quot;FrameView::maintainScrollPositionAtAnchor at %p&quot;, anchorNode);
2195 
2196     m_maintainScrollPositionAnchor = anchorNode;
2197     if (!m_maintainScrollPositionAnchor)
2198         return;
2199     m_shouldScrollToFocusedElement = false;
2200     m_delayedScrollToFocusedElementTimer.stop();
2201 
2202     // We need to update the layout before scrolling, otherwise we could
2203     // really mess things up if an anchor scroll comes at a bad moment.
2204     frame().document()-&gt;updateStyleIfNeeded();
2205     // Only do a layout if changes have occurred that make it necessary.
2206     RenderView* renderView = this-&gt;renderView();
2207     if (renderView &amp;&amp; renderView-&gt;needsLayout())
2208         layoutContext().layout();
2209     else
2210         scrollToAnchor();
2211 }
2212 
2213 void FrameView::scrollElementToRect(const Element&amp; element, const IntRect&amp; rect)
2214 {
2215     frame().document()-&gt;updateLayoutIgnorePendingStylesheets();
2216 
2217     LayoutRect bounds;
2218     if (RenderElement* renderer = element.renderer())
2219         bounds = renderer-&gt;absoluteAnchorRect();
2220     int centeringOffsetX = (rect.width() - bounds.width()) / 2;
2221     int centeringOffsetY = (rect.height() - bounds.height()) / 2;
2222     setScrollPosition(IntPoint(bounds.x() - centeringOffsetX - rect.x(), bounds.y() - centeringOffsetY - rect.y()));
2223 }
2224 
2225 void FrameView::setScrollPosition(const ScrollPosition&amp; scrollPosition)
2226 {
2227     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::setScrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; , clearing anchor&quot;);
2228 
2229     auto oldScrollType = currentScrollType();
2230     setCurrentScrollType(ScrollType::Programmatic);
2231 
2232     m_maintainScrollPositionAnchor = nullptr;
2233     m_shouldScrollToFocusedElement = false;
2234     m_delayedScrollToFocusedElementTimer.stop();
2235     Page* page = frame().page();
2236     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())
2237         scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());
2238     ScrollView::setScrollPosition(scrollPosition);
2239 
2240     setCurrentScrollType(oldScrollType);
2241 }
2242 
2243 void FrameView::resetScrollAnchor()
2244 {
2245     ASSERT(frame().document());
2246     auto&amp; document = *frame().document();
2247 
2248     // If CSS target was set previously, we want to set it to 0, recalc
2249     // and possibly repaint because :target pseudo class may have been
2250     // set (see bug 11321).
2251     document.setCSSTarget(nullptr);
2252 
2253     if (is&lt;SVGDocument&gt;(document)) {
2254         if (auto rootElement = SVGDocument::rootElement(document)) {
2255             // We need to update the layout before resetScrollAnchor(), otherwise we
2256             // could really mess things up if resetting the anchor comes at a bad moment.
2257             document.updateStyleIfNeeded();
2258             rootElement-&gt;resetScrollAnchor();
2259         }
2260     }
2261 }
2262 
2263 void FrameView::scheduleScrollToFocusedElement(SelectionRevealMode selectionRevealMode)
2264 {
2265     if (selectionRevealMode == SelectionRevealMode::DoNotReveal)
2266         return;
2267 
2268     m_selectionRevealModeForFocusedElement = selectionRevealMode;
2269     if (m_shouldScrollToFocusedElement)
2270         return;
2271     m_shouldScrollToFocusedElement = true;
2272     m_delayedScrollToFocusedElementTimer.startOneShot(0_s);
2273 }
2274 
2275 void FrameView::scrollToFocusedElementImmediatelyIfNeeded()
2276 {
2277     if (!m_shouldScrollToFocusedElement)
2278         return;
2279 
2280     m_delayedScrollToFocusedElementTimer.stop();
2281     scrollToFocusedElementInternal();
2282 }
2283 
2284 void FrameView::scrollToFocusedElementTimerFired()
2285 {
2286     auto protectedThis = makeRef(*this);
2287     scrollToFocusedElementInternal();
2288 }
2289 
2290 void FrameView::scrollToFocusedElementInternal()
2291 {
2292     RELEASE_ASSERT(m_shouldScrollToFocusedElement);
2293     auto document = makeRefPtr(frame().document());
2294     if (!document)
2295         return;
2296 
2297     document-&gt;updateLayoutIgnorePendingStylesheets();
2298     if (!m_shouldScrollToFocusedElement)
2299         return; // Updating the layout may have ran scripts.
2300     m_shouldScrollToFocusedElement = false;
2301 
2302     auto focusedElement = makeRefPtr(document-&gt;focusedElement());
2303     if (!focusedElement)
2304         return;
2305     auto updateTarget = focusedElement-&gt;focusAppearanceUpdateTarget();
2306     if (!updateTarget)
2307         return;
2308 
2309     auto* renderer = updateTarget-&gt;renderer();
2310     if (!renderer || renderer-&gt;isWidget())
2311         return;
2312 
2313     bool insideFixed;
2314     LayoutRect absoluteBounds = renderer-&gt;absoluteAnchorRect(&amp;insideFixed);
2315     renderer-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { m_selectionRevealModeForFocusedElement, ScrollAlignment::alignCenterIfNeeded, ScrollAlignment::alignCenterIfNeeded, ShouldAllowCrossOriginScrolling::No });
2316 }
2317 
2318 void FrameView::contentsResized()
2319 {
2320     // For non-delegated scrolling, updateTiledBackingAdaptiveSizing() is called via addedOrRemovedScrollbar() which occurs less often.
2321     if (delegatesScrolling())
2322         updateTiledBackingAdaptiveSizing();
2323 }
2324 
2325 void FrameView::delegatesScrollingDidChange()
2326 {
2327     RenderView* renderView = this-&gt;renderView();
2328     if (!renderView)
2329         return;
2330 
2331     RenderLayerCompositor&amp; compositor = renderView-&gt;compositor();
2332     // When we switch to delegatesScrolling mode, we should destroy the scrolling/clipping layers in RenderLayerCompositor.
2333     if (compositor.usesCompositing()) {
2334         ASSERT(compositor.usesCompositing());
2335         compositor.enableCompositingMode(false);
2336         compositor.clearBackingForAllLayers();
2337     }
2338 }
2339 
2340 #if USE(COORDINATED_GRAPHICS)
2341 void FrameView::setFixedVisibleContentRect(const IntRect&amp; visibleContentRect)
2342 {
2343     bool visibleContentSizeDidChange = false;
2344     if (visibleContentRect.size() != this-&gt;fixedVisibleContentRect().size()) {
2345         // When the viewport size changes or the content is scaled, we need to
2346         // reposition the fixed and sticky positioned elements.
2347         setViewportConstrainedObjectsNeedLayout();
2348         visibleContentSizeDidChange = true;
2349     }
2350 
2351     IntPoint oldPosition = scrollPosition();
2352     ScrollView::setFixedVisibleContentRect(visibleContentRect);
2353     IntPoint newPosition = scrollPosition();
2354     if (oldPosition != newPosition) {
2355         updateLayerPositionsAfterScrolling();
2356         if (frame().settings().acceleratedCompositingForFixedPositionEnabled())
2357             updateCompositingLayersAfterScrolling();
2358         scrollAnimator().setCurrentPosition(newPosition);
2359         scrollPositionChanged(oldPosition, newPosition);
2360     }
2361     if (visibleContentSizeDidChange) {
2362         // Update the scroll-bars to calculate new page-step size.
2363         updateScrollbars(scrollPosition());
2364     }
2365     didChangeScrollOffset();
2366 }
2367 #endif
2368 
2369 void FrameView::setViewportConstrainedObjectsNeedLayout()
2370 {
2371     if (!hasViewportConstrainedObjects())
2372         return;
2373 
2374     for (auto&amp; renderer : *m_viewportConstrainedObjects) {
2375         renderer-&gt;setNeedsLayout();
2376         if (renderer-&gt;hasLayer()) {
2377             auto* layer = downcast&lt;RenderBoxModelObject&gt;(*renderer).layer();
2378             layer-&gt;setNeedsCompositingGeometryUpdate();
2379         }
2380     }
2381 }
2382 
2383 void FrameView::didChangeScrollOffset()
2384 {
2385     if (auto* page = frame().page())
2386         page-&gt;pageOverlayController().didScrollFrame(frame());
2387     frame().loader().client().didChangeScrollOffset();
2388 }
2389 
2390 void FrameView::scrollOffsetChangedViaPlatformWidgetImpl(const ScrollOffset&amp; oldOffset, const ScrollOffset&amp; newOffset)
2391 {
2392     updateLayerPositionsAfterScrolling();
2393     updateCompositingLayersAfterScrolling();
2394     repaintSlowRepaintObjects();
2395     scrollPositionChanged(scrollPositionFromOffset(oldOffset), scrollPositionFromOffset(newOffset));
2396 
2397     if (auto* renderView = this-&gt;renderView()) {
2398         if (renderView-&gt;usesCompositing())
2399             renderView-&gt;compositor().didChangeVisibleRect();
2400     }
2401 }
2402 
2403 // These scroll positions are affected by zooming.
2404 void FrameView::scrollPositionChanged(const ScrollPosition&amp; oldPosition, const ScrollPosition&amp; newPosition)
2405 {
2406     UNUSED_PARAM(oldPosition);
2407     UNUSED_PARAM(newPosition);
2408 
2409     Page* page = frame().page();
2410     Seconds throttlingDelay = page ? page-&gt;chrome().client().eventThrottlingDelay() : 0_s;
2411 
2412     if (throttlingDelay == 0_s) {
2413         m_delayedScrollEventTimer.stop();
2414         sendScrollEvent();
2415     } else if (!m_delayedScrollEventTimer.isActive())
2416         m_delayedScrollEventTimer.startOneShot(throttlingDelay);
2417 
2418     if (RenderView* renderView = this-&gt;renderView()) {
2419         if (renderView-&gt;usesCompositing())
2420             renderView-&gt;compositor().frameViewDidScroll();
2421     }
2422 
2423     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; scrollPositionChanged from &quot; &lt;&lt; oldPosition &lt;&lt; &quot; to &quot; &lt;&lt; newPosition &lt;&lt; &quot; (scale &quot; &lt;&lt; frameScaleFactor() &lt;&lt; &quot; )&quot;);
2424     updateLayoutViewport();
2425     viewportContentsChanged();
2426 }
2427 
2428 void FrameView::applyRecursivelyWithVisibleRect(const WTF::Function&lt;void (FrameView&amp; frameView, const IntRect&amp; visibleRect)&gt;&amp; apply)
2429 {
2430     IntRect windowClipRect = this-&gt;windowClipRect();
2431     auto visibleRect = windowToContents(windowClipRect);
2432     apply(*this, visibleRect);
2433 
2434     // Recursive call for subframes. We cache the current FrameView&#39;s windowClipRect to avoid recomputing it for every subframe.
2435     SetForScope&lt;IntRect*&gt; windowClipRectCache(m_cachedWindowClipRect, &amp;windowClipRect);
2436     for (Frame* childFrame = frame().tree().firstChild(); childFrame; childFrame = childFrame-&gt;tree().nextSibling()) {
2437         if (auto* childView = childFrame-&gt;view())
2438             childView-&gt;applyRecursivelyWithVisibleRect(apply);
2439     }
2440 }
2441 
2442 void FrameView::resumeVisibleImageAnimations(const IntRect&amp; visibleRect)
2443 {
2444     if (visibleRect.isEmpty())
2445         return;
2446 
2447     if (auto* renderView = frame().contentRenderer())
2448         renderView-&gt;resumePausedImageAnimationsIfNeeded(visibleRect);
2449 }
2450 
2451 void FrameView::updateScriptedAnimationsAndTimersThrottlingState(const IntRect&amp; visibleRect)
2452 {
2453     if (frame().isMainFrame())
2454         return;
2455 
2456     auto* document = frame().document();
2457     if (!document)
2458         return;
2459 
2460     // We don&#39;t throttle zero-size or display:none frames because those are usually utility frames.
2461     bool shouldThrottle = visibleRect.isEmpty() &amp;&amp; !m_size.isEmpty() &amp;&amp; frame().ownerRenderer();
2462 
2463     if (auto* scriptedAnimationController = document-&gt;scriptedAnimationController()) {
2464         if (shouldThrottle)
2465             scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::OutsideViewport);
2466         else
2467             scriptedAnimationController-&gt;removeThrottlingReason(ScriptedAnimationController::ThrottlingReason::OutsideViewport);
2468     }
2469 
2470     document-&gt;setTimerThrottlingEnabled(shouldThrottle);
2471 }
2472 
2473 
2474 void FrameView::resumeVisibleImageAnimationsIncludingSubframes()
2475 {
2476     applyRecursivelyWithVisibleRect([] (FrameView&amp; frameView, const IntRect&amp; visibleRect) {
2477         frameView.resumeVisibleImageAnimations(visibleRect);
2478     });
2479 }
2480 
2481 void FrameView::updateLayerPositionsAfterScrolling()
2482 {
2483     // If we&#39;re scrolling as a result of updating the view size after layout, we&#39;ll update widgets and layer positions soon anyway.
2484     if (layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::InViewSizeAdjust)
2485         return;
2486 
2487     if (!layoutContext().isLayoutNested() &amp;&amp; hasViewportConstrainedObjects()) {
2488         if (RenderView* renderView = this-&gt;renderView()) {
2489             updateWidgetPositions();
2490             renderView-&gt;layer()-&gt;updateLayerPositionsAfterDocumentScroll();
2491         }
2492     }
2493 }
2494 
2495 bool FrameView::shouldUpdateCompositingLayersAfterScrolling() const
2496 {
2497 #if ENABLE(ASYNC_SCROLLING)
2498     // If the scrolling thread is updating the fixed elements, then the FrameView should not update them as well.
2499 
2500     Page* page = frame().page();
2501     if (!page)
2502         return true;
2503 
2504     if (&amp;page-&gt;mainFrame() != m_frame.ptr())
2505         return true;
2506 
2507     ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator();
2508     if (!scrollingCoordinator)
2509         return true;
2510 
2511     if (scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
2512         return true;
2513 
2514     if (currentScrollType() == ScrollType::Programmatic)
2515         return true;
2516 
2517     return false;
2518 #endif
2519     return true;
2520 }
2521 
2522 void FrameView::updateCompositingLayersAfterScrolling()
2523 {
2524     ASSERT(layoutContext().layoutPhase() &gt;= FrameViewLayoutContext::LayoutPhase::InPostLayout || layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::OutsideLayout);
2525 
2526     if (!shouldUpdateCompositingLayersAfterScrolling())
2527         return;
2528 
2529     if (!layoutContext().isLayoutNested() &amp;&amp; hasViewportConstrainedObjects()) {
2530         if (RenderView* renderView = this-&gt;renderView())
2531             renderView-&gt;compositor().updateCompositingLayers(CompositingUpdateType::OnScroll);
2532     }
2533 }
2534 
2535 bool FrameView::isRubberBandInProgress() const
2536 {
2537     if (scrollbarsSuppressed())
2538         return false;
2539 
2540     // If the scrolling thread updates the scroll position for this FrameView, then we should return
2541     // ScrollingCoordinator::isRubberBandInProgress().
2542     if (Page* page = frame().page()) {
2543         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator()) {
2544             if (!scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
2545                 return scrollingCoordinator-&gt;isRubberBandInProgress();
2546         }
2547     }
2548 
2549     // If the main thread updates the scroll position for this FrameView, we should return
2550     // ScrollAnimator::isRubberBandInProgress().
2551     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
2552         return scrollAnimator-&gt;isRubberBandInProgress();
2553 
2554     return false;
2555 }
2556 
2557 bool FrameView::requestScrollPositionUpdate(const ScrollPosition&amp; position)
2558 {
2559     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::requestScrollPositionUpdate &quot; &lt;&lt; position);
2560 
2561 #if ENABLE(ASYNC_SCROLLING)
2562     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
2563         tiledBacking-&gt;prepopulateRect(FloatRect(position, visibleContentRect().size()));
2564 #endif
2565 
2566 #if ENABLE(ASYNC_SCROLLING) || USE(COORDINATED_GRAPHICS)
2567     if (Page* page = frame().page()) {
2568         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
2569             return scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, position);
2570     }
2571 #else
2572     UNUSED_PARAM(position);
2573 #endif
2574 
2575     return false;
2576 }
2577 
2578 HostWindow* FrameView::hostWindow() const
2579 {
2580     auto* page = frame().page();
2581     if (!page)
2582         return nullptr;
2583     return &amp;page-&gt;chrome();
2584 }
2585 
2586 void FrameView::addTrackedRepaintRect(const FloatRect&amp; r)
2587 {
2588     if (!m_isTrackingRepaints || r.isEmpty())
2589         return;
2590 
2591     FloatRect repaintRect = r;
2592     repaintRect.moveBy(-scrollPosition());
2593     m_trackedRepaintRects.append(repaintRect);
2594 }
2595 
2596 void FrameView::repaintContentRectangle(const IntRect&amp; r)
2597 {
2598     ASSERT(!frame().ownerElement());
2599 
2600     if (!shouldUpdate())
2601         return;
2602 
2603     ScrollView::repaintContentRectangle(r);
2604 }
2605 
2606 static unsigned countRenderedCharactersInRenderObjectWithThreshold(const RenderElement&amp; renderer, unsigned threshold)
2607 {
2608     unsigned count = 0;
2609     for (const RenderObject* descendant = &amp;renderer; descendant; descendant = descendant-&gt;nextInPreOrder()) {
2610         if (is&lt;RenderText&gt;(*descendant)) {
2611             count += downcast&lt;RenderText&gt;(*descendant).text().length();
2612             if (count &gt;= threshold)
2613                 break;
2614         }
2615     }
2616     return count;
2617 }
2618 
2619 bool FrameView::renderedCharactersExceed(unsigned threshold)
2620 {
2621     if (!frame().contentRenderer())
2622         return false;
2623     return countRenderedCharactersInRenderObjectWithThreshold(*frame().contentRenderer(), threshold) &gt;= threshold;
2624 }
2625 
2626 void FrameView::availableContentSizeChanged(AvailableSizeChangeReason reason)
2627 {
2628     if (Document* document = frame().document()) {
2629         // FIXME: Merge this logic with m_setNeedsLayoutWasDeferred and find a more appropriate
2630         // way of handling potential recursive layouts when the viewport is resized to accomodate
2631         // the content but the content always overflows the viewport. See webkit.org/b/165781.
2632         if (!(layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::InViewSizeAdjust &amp;&amp; useFixedLayout()))
2633             document-&gt;updateViewportUnitsOnResize();
2634     }
2635 
2636     updateLayoutViewport();
2637     setNeedsLayoutAfterViewConfigurationChange();
2638     ScrollView::availableContentSizeChanged(reason);
2639 }
2640 
2641 bool FrameView::shouldLayoutAfterContentsResized() const
2642 {
2643     return !useFixedLayout() || useCustomFixedPositionLayoutRect();
2644 }
2645 
2646 void FrameView::updateContentsSize()
2647 {
2648     // We check to make sure the view is attached to a frame() as this method can
2649     // be triggered before the view is attached by Frame::createView(...) setting
2650     // various values such as setScrollBarModes(...) for example.  An ASSERT is
2651     // triggered when a view is layout before being attached to a frame().
2652     if (!frame().view())
2653         return;
2654 
2655 #if PLATFORM(IOS_FAMILY)
2656     if (RenderView* root = m_frame-&gt;contentRenderer()) {
2657         if (useCustomFixedPositionLayoutRect() &amp;&amp; hasViewportConstrainedObjects()) {
2658             setViewportConstrainedObjectsNeedLayout();
2659             // We must eagerly enter compositing mode because fixed position elements
2660             // will not have been made compositing via a preceding style change before
2661             // m_useCustomFixedPositionLayoutRect was true.
2662             root-&gt;compositor().enableCompositingMode();
2663         }
2664     }
2665 #endif
2666 
2667     if (shouldLayoutAfterContentsResized() &amp;&amp; needsLayout())
2668         layoutContext().layout();
2669 
2670     if (RenderView* renderView = this-&gt;renderView()) {
2671         if (renderView-&gt;usesCompositing())
2672             renderView-&gt;compositor().frameViewDidChangeSize();
2673     }
2674 }
2675 
2676 void FrameView::addedOrRemovedScrollbar()
2677 {
2678     if (RenderView* renderView = this-&gt;renderView()) {
2679         if (renderView-&gt;usesCompositing())
2680             renderView-&gt;compositor().frameViewDidAddOrRemoveScrollbars();
2681     }
2682 
2683     updateTiledBackingAdaptiveSizing();
2684 }
2685 
2686 TiledBacking::Scrollability FrameView::computeScrollability() const
2687 {
2688     auto* page = frame().page();
2689 
2690     // Use smaller square tiles if the Window is not active to facilitate app napping.
2691     if (!page || !page-&gt;isWindowActive())
2692         return TiledBacking::HorizontallyScrollable | TiledBacking::VerticallyScrollable;
2693 
2694     bool horizontallyScrollable;
2695     bool verticallyScrollable;
2696     bool clippedByAncestorView = static_cast&lt;bool&gt;(m_viewExposedRect);
2697 
2698 #if PLATFORM(IOS_FAMILY)
2699     if (page)
2700         clippedByAncestorView |= page-&gt;enclosedInScrollableAncestorView();
2701 #endif
2702 
2703     if (delegatesScrolling()) {
2704         IntSize documentSize = contentsSize();
2705         IntSize visibleSize = this-&gt;visibleSize();
2706 
2707         horizontallyScrollable = clippedByAncestorView || documentSize.width() &gt; visibleSize.width();
2708         verticallyScrollable = clippedByAncestorView || documentSize.height() &gt; visibleSize.height();
2709     } else {
2710         horizontallyScrollable = clippedByAncestorView || horizontalScrollbar();
2711         verticallyScrollable = clippedByAncestorView || verticalScrollbar();
2712     }
2713 
2714     TiledBacking::Scrollability scrollability = TiledBacking::NotScrollable;
2715     if (horizontallyScrollable)
2716         scrollability = TiledBacking::HorizontallyScrollable;
2717 
2718     if (verticallyScrollable)
2719         scrollability |= TiledBacking::VerticallyScrollable;
2720 
2721     return scrollability;
2722 }
2723 
2724 void FrameView::updateTiledBackingAdaptiveSizing()
2725 {
2726     auto* tiledBacking = this-&gt;tiledBacking();
2727     if (!tiledBacking)
2728         return;
2729 
2730     tiledBacking-&gt;setScrollability(computeScrollability());
2731 }
2732 
2733 // FIXME: This shouldn&#39;t be called from outside; FrameView should call it when the relevant viewports change.
2734 void FrameView::layoutOrVisualViewportChanged()
2735 {
2736     if (!frame().settings().visualViewportAPIEnabled())
2737         return;
2738 
2739     if (auto* window = frame().window())
2740         window-&gt;visualViewport().update();
2741 
2742     if (auto* page = frame().page()) {
2743         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
2744             scrollingCoordinator-&gt;frameViewVisualViewportChanged(*this);
2745     }
2746 }
2747 
2748 #if PLATFORM(IOS_FAMILY)
2749 
2750 void FrameView::unobscuredContentSizeChanged()
2751 {
2752     updateTiledBackingAdaptiveSizing();
2753 }
2754 
2755 #endif
2756 
2757 static LayerFlushThrottleState::Flags determineLayerFlushThrottleState(Page&amp; page)
2758 {
2759     // We only throttle when constantly receiving new data during the inital page load.
2760     if (!page.progress().isMainLoadProgressing())
2761         return 0;
2762     // Scrolling during page loading disables throttling.
2763     if (page.mainFrame().view()-&gt;wasScrolledByUser())
2764         return 0;
2765     // Disable for image documents so large GIF animations don&#39;t get throttled during loading.
2766     auto* document = page.mainFrame().document();
2767     if (!document || is&lt;ImageDocument&gt;(*document))
2768         return 0;
2769     return LayerFlushThrottleState::Enabled;
2770 }
2771 
2772 void FrameView::disableLayerFlushThrottlingTemporarilyForInteraction()
2773 {
2774     if (!frame().page())
2775         return;
2776     auto&amp; page = *frame().page();
2777 
2778     LayerFlushThrottleState::Flags flags = LayerFlushThrottleState::UserIsInteracting | determineLayerFlushThrottleState(page);
2779     if (page.chrome().client().adjustLayerFlushThrottling(flags))
2780         return;
2781 
2782     if (RenderView* view = renderView())
2783         view-&gt;compositor().disableLayerFlushThrottlingTemporarilyForInteraction();
2784 }
2785 
2786 void FrameView::loadProgressingStatusChanged()
2787 {
2788     if (!m_isVisuallyNonEmpty &amp;&amp; frame().loader().isComplete())
2789         fireLayoutRelatedMilestonesIfNeeded();
2790     updateLayerFlushThrottling();
2791     adjustTiledBackingCoverage();
2792 }
2793 
2794 void FrameView::updateLayerFlushThrottling()
2795 {
2796     Page* page = frame().page();
2797     if (!page)
2798         return;
2799 
2800     ASSERT(frame().isMainFrame());
2801 
2802     LayerFlushThrottleState::Flags flags = determineLayerFlushThrottleState(*page);
2803 
2804     // See if the client is handling throttling.
2805     if (page-&gt;chrome().client().adjustLayerFlushThrottling(flags))
2806         return;
2807 
2808     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
2809         if (RenderView* renderView = frame-&gt;contentRenderer())
2810             renderView-&gt;compositor().setLayerFlushThrottlingEnabled(flags &amp; LayerFlushThrottleState::Enabled);
2811     }
2812 }
2813 
2814 void FrameView::adjustTiledBackingCoverage()
2815 {
2816     if (!m_speculativeTilingEnabled)
2817         enableSpeculativeTilingIfNeeded();
2818 
2819     RenderView* renderView = this-&gt;renderView();
2820     if (renderView &amp;&amp; renderView-&gt;layer() &amp;&amp; renderView-&gt;layer()-&gt;backing())
2821         renderView-&gt;layer()-&gt;backing()-&gt;adjustTiledBackingCoverage();
2822 #if PLATFORM(IOS_FAMILY)
2823     if (LegacyTileCache* tileCache = legacyTileCache())
2824         tileCache-&gt;setSpeculativeTileCreationEnabled(m_speculativeTilingEnabled);
2825 #endif
2826 }
2827 
2828 static bool shouldEnableSpeculativeTilingDuringLoading(const FrameView&amp; view)
2829 {
2830     Page* page = view.frame().page();
2831     return page &amp;&amp; view.isVisuallyNonEmpty() &amp;&amp; !page-&gt;progress().isMainLoadProgressing();
2832 }
2833 
2834 void FrameView::enableSpeculativeTilingIfNeeded()
2835 {
2836     ASSERT(!m_speculativeTilingEnabled);
2837     if (m_wasScrolledByUser) {
2838         m_speculativeTilingEnabled = true;
2839         return;
2840     }
2841     if (!shouldEnableSpeculativeTilingDuringLoading(*this))
2842         return;
2843 
2844     if (m_speculativeTilingDelayDisabledForTesting) {
2845         speculativeTilingEnableTimerFired();
2846         return;
2847     }
2848 
2849     if (m_speculativeTilingEnableTimer.isActive())
2850         return;
2851     // Delay enabling a bit as load completion may trigger further loading from scripts.
2852     static const Seconds speculativeTilingEnableDelay { 500_ms };
2853     m_speculativeTilingEnableTimer.startOneShot(speculativeTilingEnableDelay);
2854 }
2855 
2856 void FrameView::speculativeTilingEnableTimerFired()
2857 {
2858     if (m_speculativeTilingEnabled)
2859         return;
2860     m_speculativeTilingEnabled = shouldEnableSpeculativeTilingDuringLoading(*this);
2861     adjustTiledBackingCoverage();
2862 }
2863 
2864 void FrameView::show()
2865 {
2866     ScrollView::show();
2867 
2868     if (frame().isMainFrame()) {
2869         // Turn off speculative tiling for a brief moment after a FrameView appears on screen.
2870         // Note that adjustTiledBackingCoverage() kicks the (500ms) timer to re-enable it.
2871         m_speculativeTilingEnabled = false;
2872         m_wasScrolledByUser = false;
2873         adjustTiledBackingCoverage();
2874     }
2875 }
2876 
2877 void FrameView::hide()
2878 {
2879     ScrollView::hide();
2880     adjustTiledBackingCoverage();
2881 }
2882 
2883 bool FrameView::needsLayout() const
2884 {
2885     return layoutContext().needsLayout();
2886 }
2887 
2888 void FrameView::setNeedsLayoutAfterViewConfigurationChange()
2889 {
2890     layoutContext().setNeedsLayoutAfterViewConfigurationChange();
2891 }
2892 
2893 void FrameView::setNeedsCompositingConfigurationUpdate()
2894 {
2895     RenderView* renderView = this-&gt;renderView();
2896     if (renderView &amp;&amp; renderView-&gt;usesCompositing()) {
2897         if (auto* rootLayer = renderView-&gt;layer())
2898             rootLayer-&gt;setNeedsCompositingConfigurationUpdate();
2899         renderView-&gt;compositor().scheduleCompositingLayerUpdate();
2900     }
2901 }
2902 
2903 void FrameView::setNeedsCompositingGeometryUpdate()
2904 {
2905     RenderView* renderView = this-&gt;renderView();
2906     if (renderView-&gt;usesCompositing()) {
2907         if (auto* rootLayer = renderView-&gt;layer())
2908             rootLayer-&gt;setNeedsCompositingGeometryUpdate();
2909         renderView-&gt;compositor().scheduleCompositingLayerUpdate();
2910     }
2911 }
2912 
2913 void FrameView::scheduleSelectionUpdate()
2914 {
2915     if (needsLayout())
2916         return;
2917     // FIXME: We should not need to go through the layout process since selection update does not change dimension/geometry.
2918     // However we can&#39;t tell at this point if the tree is stable yet, so let&#39;s just schedule a root only layout for now.
2919     setNeedsLayoutAfterViewConfigurationChange();
2920 }
2921 
2922 bool FrameView::isTransparent() const
2923 {
2924     return m_isTransparent;
2925 }
2926 
2927 void FrameView::setTransparent(bool isTransparent)
2928 {
2929     if (m_isTransparent == isTransparent)
2930         return;
2931 
2932     m_isTransparent = isTransparent;
2933 
2934     // setTransparent can be called in the window between FrameView initialization
2935     // and switching in the new Document; this means that the RenderView that we
2936     // retrieve is actually attached to the previous Document, which is going away,
2937     // and must not update compositing layers.
2938     if (!isViewForDocumentInFrame())
2939         return;
2940 
2941     setNeedsLayoutAfterViewConfigurationChange();
2942     setNeedsCompositingConfigurationUpdate();
2943 }
2944 
2945 bool FrameView::hasOpaqueBackground() const
2946 {
2947     return !m_isTransparent &amp;&amp; m_baseBackgroundColor.isOpaque();
2948 }
2949 
2950 Color FrameView::baseBackgroundColor() const
2951 {
2952     return m_baseBackgroundColor;
2953 }
2954 
2955 void FrameView::setBaseBackgroundColor(const Color&amp; backgroundColor)
2956 {
2957     Color newBaseBackgroundColor = backgroundColor.isValid() ? backgroundColor : Color::white;
2958     if (m_baseBackgroundColor == newBaseBackgroundColor)
2959         return;
2960 
2961     m_baseBackgroundColor = newBaseBackgroundColor;
2962 
2963     if (!isViewForDocumentInFrame())
2964         return;
2965 
2966     recalculateScrollbarOverlayStyle();
2967     setNeedsLayoutAfterViewConfigurationChange();
2968     setNeedsCompositingConfigurationUpdate();
2969 }
2970 
2971 void FrameView::updateBackgroundRecursively(const Optional&lt;Color&gt;&amp; backgroundColor)
2972 {
2973 #if HAVE(OS_DARK_MODE_SUPPORT)
2974 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
2975     static const auto cssValueControlBackground = CSSValueAppleSystemControlBackground;
2976 #else
2977     static const auto cssValueControlBackground = CSSValueWindow;
2978 #endif
2979     Color baseBackgroundColor = backgroundColor.valueOr(RenderTheme::singleton().systemColor(cssValueControlBackground, styleColorOptions()));
2980 #else
2981     Color baseBackgroundColor = backgroundColor.valueOr(Color::white);
2982 #endif
2983 
2984     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
2985         if (FrameView* view = frame-&gt;view()) {
2986             view-&gt;setTransparent(!baseBackgroundColor.isVisible());
2987             view-&gt;setBaseBackgroundColor(baseBackgroundColor);
2988             if (view-&gt;needsLayout())
2989                 view-&gt;layoutContext().scheduleLayout();
2990         }
2991     }
2992 }
2993 
2994 bool FrameView::hasExtendedBackgroundRectForPainting() const
2995 {
2996     TiledBacking* tiledBacking = this-&gt;tiledBacking();
2997     if (!tiledBacking)
2998         return false;
2999 
3000     return tiledBacking-&gt;hasMargins();
3001 }
3002 
3003 void FrameView::updateExtendBackgroundIfNecessary()
3004 {
3005     ExtendedBackgroundMode mode = calculateExtendedBackgroundMode();
3006     if (mode == ExtendedBackgroundModeNone)
3007         return;
3008 
3009     updateTilesForExtendedBackgroundMode(mode);
3010 }
3011 
3012 FrameView::ExtendedBackgroundMode FrameView::calculateExtendedBackgroundMode() const
3013 {
3014 #if PLATFORM(IOS_FAMILY)
3015     // &lt;rdar://problem/16201373&gt;
3016     return ExtendedBackgroundModeNone;
3017 #else
3018     if (!frame().settings().backgroundShouldExtendBeyondPage())
3019         return ExtendedBackgroundModeNone;
3020 
3021     // Just because Settings::backgroundShouldExtendBeyondPage() is true does not necessarily mean
3022     // that the background rect needs to be extended for painting. Simple backgrounds can be extended
3023     // just with RenderLayerCompositor&#39;s rootExtendedBackgroundColor. More complicated backgrounds,
3024     // such as images, require extending the background rect to continue painting into the extended
3025     // region. This function finds out if it is necessary to extend the background rect for painting.
3026 
3027     if (!frame().isMainFrame())
3028         return ExtendedBackgroundModeNone;
3029 
3030     Document* document = frame().document();
3031     if (!document)
3032         return ExtendedBackgroundModeNone;
3033 
3034     if (!renderView())
3035         return ExtendedBackgroundModeNone;
3036 
3037     auto* rootBackgroundRenderer = renderView()-&gt;rendererForRootBackground();
3038     if (!rootBackgroundRenderer)
3039         return ExtendedBackgroundModeNone;
3040 
3041     if (!rootBackgroundRenderer-&gt;style().hasBackgroundImage())
3042         return ExtendedBackgroundModeNone;
3043 
3044     ExtendedBackgroundMode mode = ExtendedBackgroundModeNone;
3045     if (rootBackgroundRenderer-&gt;style().backgroundRepeatX() == FillRepeat::Repeat)
3046         mode |= ExtendedBackgroundModeHorizontal;
3047     if (rootBackgroundRenderer-&gt;style().backgroundRepeatY() == FillRepeat::Repeat)
3048         mode |= ExtendedBackgroundModeVertical;
3049 
3050     return mode;
3051 #endif
3052 }
3053 
3054 void FrameView::updateTilesForExtendedBackgroundMode(ExtendedBackgroundMode mode)
3055 {
3056     RenderView* renderView = this-&gt;renderView();
3057     if (!renderView)
3058         return;
3059 
3060     RenderLayerBacking* backing = renderView-&gt;layer()-&gt;backing();
3061     if (!backing)
3062         return;
3063 
3064     TiledBacking* tiledBacking = backing-&gt;tiledBacking();
3065     if (!tiledBacking)
3066         return;
3067 
3068     ExtendedBackgroundMode existingMode = ExtendedBackgroundModeNone;
3069     if (tiledBacking-&gt;hasVerticalMargins())
3070         existingMode |= ExtendedBackgroundModeVertical;
3071     if (tiledBacking-&gt;hasHorizontalMargins())
3072         existingMode |= ExtendedBackgroundModeHorizontal;
3073 
3074     if (existingMode == mode)
3075         return;
3076 
3077     backing-&gt;setTiledBackingHasMargins(mode &amp; ExtendedBackgroundModeHorizontal, mode &amp; ExtendedBackgroundModeVertical);
3078 }
3079 
3080 IntRect FrameView::extendedBackgroundRectForPainting() const
3081 {
3082     TiledBacking* tiledBacking = this-&gt;tiledBacking();
3083     if (!tiledBacking)
3084         return IntRect();
3085 
3086     RenderView* renderView = this-&gt;renderView();
3087     if (!renderView)
3088         return IntRect();
3089 
3090     LayoutRect extendedRect = renderView-&gt;unextendedBackgroundRect();
3091     if (!tiledBacking-&gt;hasMargins())
3092         return snappedIntRect(extendedRect);
3093 
3094     extendedRect.moveBy(LayoutPoint(-tiledBacking-&gt;leftMarginWidth(), -tiledBacking-&gt;topMarginHeight()));
3095     extendedRect.expand(LayoutSize(tiledBacking-&gt;leftMarginWidth() + tiledBacking-&gt;rightMarginWidth(), tiledBacking-&gt;topMarginHeight() + tiledBacking-&gt;bottomMarginHeight()));
3096     return snappedIntRect(extendedRect);
3097 }
3098 
3099 bool FrameView::shouldUpdateWhileOffscreen() const
3100 {
3101     return m_shouldUpdateWhileOffscreen;
3102 }
3103 
3104 void FrameView::setShouldUpdateWhileOffscreen(bool shouldUpdateWhileOffscreen)
3105 {
3106     m_shouldUpdateWhileOffscreen = shouldUpdateWhileOffscreen;
3107 }
3108 
3109 bool FrameView::shouldUpdate() const
3110 {
3111     if (isOffscreen() &amp;&amp; !shouldUpdateWhileOffscreen())
3112         return false;
3113     return true;
3114 }
3115 
3116 bool FrameView::safeToPropagateScrollToParent() const
3117 {
3118     auto* document = frame().document();
3119     if (!document)
3120         return false;
3121 
3122     auto* parentFrame = frame().tree().parent();
3123     if (!parentFrame)
3124         return false;
3125 
3126     auto* parentDocument = parentFrame-&gt;document();
3127     if (!parentDocument)
3128         return false;
3129 
3130     return document-&gt;securityOrigin().canAccess(parentDocument-&gt;securityOrigin());
3131 }
3132 
3133 void FrameView::scrollToAnchor()
3134 {
3135     RefPtr&lt;ContainerNode&gt; anchorNode = m_maintainScrollPositionAnchor;
3136 
3137     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::scrollToAnchor() &quot; &lt;&lt; anchorNode.get());
3138 
3139     if (!anchorNode)
3140         return;
3141 
3142     if (!anchorNode-&gt;renderer())
3143         return;
3144     m_shouldScrollToFocusedElement = false;
3145     m_delayedScrollToFocusedElementTimer.stop();
3146 
3147     LayoutRect rect;
3148     bool insideFixed = false;
3149     if (anchorNode != frame().document() &amp;&amp; anchorNode-&gt;renderer())
3150         rect = anchorNode-&gt;renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
3151 
3152     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot; anchor node rect &quot; &lt;&lt; rect);
3153 
3154     // Scroll nested layers and frames to reveal the anchor.
3155     // Align to the top and to the closest side (this matches other browsers).
3156     if (anchorNode-&gt;renderer()-&gt;style().isHorizontalWritingMode())
3157         anchorNode-&gt;renderer()-&gt;scrollRectToVisible(rect, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignTopAlways, ShouldAllowCrossOriginScrolling::No });
3158     else if (anchorNode-&gt;renderer()-&gt;style().isFlippedBlocksWritingMode())
3159         anchorNode-&gt;renderer()-&gt;scrollRectToVisible(rect, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignRightAlways, ScrollAlignment::alignToEdgeIfNeeded, ShouldAllowCrossOriginScrolling::No });
3160     else
3161         anchorNode-&gt;renderer()-&gt;scrollRectToVisible(rect, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignLeftAlways, ScrollAlignment::alignToEdgeIfNeeded, ShouldAllowCrossOriginScrolling::No });
3162 
3163     if (AXObjectCache* cache = frame().document()-&gt;existingAXObjectCache())
3164         cache-&gt;handleScrolledToAnchor(anchorNode.get());
3165 
3166     // scrollRectToVisible can call into setScrollPosition(), which resets m_maintainScrollPositionAnchor.
3167     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot; restoring anchor node to &quot; &lt;&lt; anchorNode.get());
3168     m_maintainScrollPositionAnchor = anchorNode;
3169     m_shouldScrollToFocusedElement = false;
3170     m_delayedScrollToFocusedElementTimer.stop();
3171 }
3172 
3173 void FrameView::updateEmbeddedObject(RenderEmbeddedObject&amp; embeddedObject)
3174 {
3175     // No need to update if it&#39;s already crashed or known to be missing.
3176     if (embeddedObject.isPluginUnavailable())
3177         return;
3178 
3179     HTMLFrameOwnerElement&amp; element = embeddedObject.frameOwnerElement();
3180 
3181     if (embeddedObject.isSnapshottedPlugIn()) {
3182         if (is&lt;HTMLObjectElement&gt;(element) || is&lt;HTMLEmbedElement&gt;(element)) {
3183             HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
3184             pluginElement.checkSnapshotStatus();
3185         }
3186         return;
3187     }
3188 
3189     auto weakRenderer = makeWeakPtr(embeddedObject);
3190 
3191     // FIXME: This could turn into a real virtual dispatch if we defined
3192     // updateWidget(PluginCreationOption) on HTMLElement.
3193     if (is&lt;HTMLPlugInImageElement&gt;(element)) {
3194         HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
3195         if (pluginElement.needsCheckForSizeChange()) {
3196             pluginElement.checkSnapshotStatus();
3197             return;
3198         }
3199         if (pluginElement.needsWidgetUpdate())
3200             pluginElement.updateWidget(CreatePlugins::Yes);
3201     } else
3202         ASSERT_NOT_REACHED();
3203 
3204     // It&#39;s possible the renderer was destroyed below updateWidget() since loading a plugin may execute arbitrary JavaScript.
3205     if (!weakRenderer)
3206         return;
3207 
3208     auto ignoreWidgetState = embeddedObject.updateWidgetPosition();
3209     UNUSED_PARAM(ignoreWidgetState);
3210 }
3211 
3212 bool FrameView::updateEmbeddedObjects()
3213 {
3214     if (layoutContext().isLayoutNested() || !m_embeddedObjectsToUpdate || m_embeddedObjectsToUpdate-&gt;isEmpty())
3215         return true;
3216 
3217     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
3218 
3219     // Insert a marker for where we should stop.
3220     ASSERT(!m_embeddedObjectsToUpdate-&gt;contains(nullptr));
3221     m_embeddedObjectsToUpdate-&gt;add(nullptr);
3222 
3223     while (!m_embeddedObjectsToUpdate-&gt;isEmpty()) {
3224         RenderEmbeddedObject* embeddedObject = m_embeddedObjectsToUpdate-&gt;takeFirst();
3225         if (!embeddedObject)
3226             break;
3227         updateEmbeddedObject(*embeddedObject);
3228     }
3229 
3230     return m_embeddedObjectsToUpdate-&gt;isEmpty();
3231 }
3232 
3233 void FrameView::updateEmbeddedObjectsTimerFired()
3234 {
3235     RefPtr&lt;FrameView&gt; protectedThis(this);
3236     m_updateEmbeddedObjectsTimer.stop();
3237     for (unsigned i = 0; i &lt; maxUpdateEmbeddedObjectsIterations; i++) {
3238         if (updateEmbeddedObjects())
3239             break;
3240     }
3241 }
3242 
3243 void FrameView::flushAnyPendingPostLayoutTasks()
3244 {
3245     layoutContext().flushAsynchronousTasks();
3246     if (m_updateEmbeddedObjectsTimer.isActive())
3247         updateEmbeddedObjectsTimerFired();
3248 }
3249 
3250 void FrameView::queuePostLayoutCallback(Function&lt;void()&gt;&amp;&amp; callback)
3251 {
3252     m_postLayoutCallbackQueue.append(WTFMove(callback));
3253 }
3254 
3255 void FrameView::flushPostLayoutTasksQueue()
3256 {
3257     if (layoutContext().isLayoutNested())
3258         return;
3259 
3260     if (!m_postLayoutCallbackQueue.size())
3261         return;
3262 
3263     Vector&lt;Function&lt;void()&gt;&gt; queue = WTFMove(m_postLayoutCallbackQueue);
3264     for (auto&amp; task : queue)
3265         task();
3266 }
3267 
3268 void FrameView::performPostLayoutTasks()
3269 {
3270     // FIXME: We should not run any JavaScript code in this function.
3271     LOG(Layout, &quot;FrameView %p performPostLayoutTasks&quot;, this);
3272     updateHasReachedSignificantRenderedTextThreshold();
3273     frame().selection().updateAppearanceAfterLayout();
3274 
3275     flushPostLayoutTasksQueue();
3276 
3277     if (!layoutContext().isLayoutNested() &amp;&amp; frame().document()-&gt;documentElement())
3278         fireLayoutRelatedMilestonesIfNeeded();
3279 
3280 #if PLATFORM(IOS_FAMILY)
3281     // Only send layout-related delegate callbacks synchronously for the main frame to
3282     // avoid re-entering layout for the main frame while delivering a layout-related delegate
3283     // callback for a subframe.
3284     if (frame().isMainFrame()) {
3285         if (Page* page = frame().page())
3286             page-&gt;chrome().client().didLayout();
3287     }
3288 #endif
3289 
3290     // FIXME: We should consider adding DidLayout as a LayoutMilestone. That would let us merge this
3291     // with didLayout(LayoutMilestones).
3292     frame().loader().client().dispatchDidLayout();
3293 
3294     updateWidgetPositions();
3295 
3296 #if ENABLE(CSS_SCROLL_SNAP)
3297     updateSnapOffsets();
3298 #endif
3299     m_updateEmbeddedObjectsTimer.startOneShot(0_s);
3300 
3301     if (auto* page = frame().page()) {
3302         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
3303             scrollingCoordinator-&gt;frameViewLayoutUpdated(*this);
3304     }
3305 
3306     if (RenderView* renderView = this-&gt;renderView()) {
3307         if (renderView-&gt;usesCompositing())
3308             renderView-&gt;compositor().frameViewDidLayout();
3309     }
3310 
3311     scrollToAnchor();
3312 
3313     sendResizeEventIfNeeded();
3314 
3315     updateLayoutViewport();
3316     viewportContentsChanged();
3317 
3318     updateScrollSnapState();
3319 
3320     if (AXObjectCache* cache = frame().document()-&gt;existingAXObjectCache())
3321         cache-&gt;performDeferredCacheUpdate();
3322 }
3323 
3324 IntSize FrameView::sizeForResizeEvent() const
3325 {
3326 #if PLATFORM(IOS_FAMILY)
3327     if (m_useCustomSizeForResizeEvent)
3328         return m_customSizeForResizeEvent;
3329 #endif
3330     if (useFixedLayout() &amp;&amp; !fixedLayoutSize().isEmpty() &amp;&amp; delegatesScrolling())
3331         return fixedLayoutSize();
3332     return visibleContentRectIncludingScrollbars().size();
3333 }
3334 
3335 void FrameView::sendResizeEventIfNeeded()
3336 {
3337     if (layoutContext().isInRenderTreeLayout() || needsLayout())
3338         return;
3339 
3340     RenderView* renderView = this-&gt;renderView();
3341     if (!renderView || renderView-&gt;printing())
3342         return;
3343 
3344     if (frame().page() &amp;&amp; frame().page()-&gt;chrome().client().isSVGImageChromeClient())
3345         return;
3346 
3347     IntSize currentSize = sizeForResizeEvent();
3348     float currentZoomFactor = renderView-&gt;style().zoom();
3349 
3350     if (currentSize == m_lastViewportSize &amp;&amp; currentZoomFactor == m_lastZoomFactor)
3351         return;
3352 
3353     m_lastViewportSize = currentSize;
3354     m_lastZoomFactor = currentZoomFactor;
3355 
3356     if (!layoutContext().didFirstLayout())
3357         return;
3358 
3359 #if PLATFORM(IOS_FAMILY)
3360     // Don&#39;t send the resize event if the document is loading. Some pages automatically reload
3361     // when the window is resized; Safari on iOS often resizes the window while setting up its
3362     // viewport. This obviously can cause problems.
3363     if (DocumentLoader* documentLoader = frame().loader().documentLoader()) {
3364         if (documentLoader-&gt;isLoadingInAPISense())
3365             return;
3366     }
3367 #endif
3368 
3369     bool isMainFrame = frame().isMainFrame();
3370     bool canSendResizeEventSynchronously = isMainFrame &amp;&amp; !m_shouldAutoSize;
3371 
3372     LOG(Events, &quot;FrameView %p sendResizeEventIfNeeded sending resize event, size %dx%d (canSendResizeEventSynchronously %d)&quot;, this, currentSize.width(), currentSize.height(), canSendResizeEventSynchronously);
3373 
3374     Ref&lt;Event&gt; resizeEvent = Event::create(eventNames().resizeEvent, Event::CanBubble::No, Event::IsCancelable::No);
3375     if (canSendResizeEventSynchronously)
3376         frame().document()-&gt;dispatchWindowEvent(resizeEvent);
3377     else {
3378         // FIXME: Queueing this event for an unpredictable time in the future seems
3379         // intrinsically racy. By the time this resize event fires, the frame might
3380         // be resized again, so we could end up with two resize events for the same size.
3381         frame().document()-&gt;enqueueWindowEvent(WTFMove(resizeEvent));
3382     }
3383 
3384     if (InspectorInstrumentation::hasFrontends() &amp;&amp; isMainFrame) {
3385         if (Page* page = frame().page()) {
3386             if (InspectorClient* inspectorClient = page-&gt;inspectorController().inspectorClient())
3387                 inspectorClient-&gt;didResizeMainFrame(&amp;frame());
3388         }
3389     }
3390 }
3391 
3392 void FrameView::willStartLiveResize()
3393 {
3394     ScrollView::willStartLiveResize();
3395     adjustTiledBackingCoverage();
3396 }
3397 
3398 void FrameView::willEndLiveResize()
3399 {
3400     ScrollView::willEndLiveResize();
3401     adjustTiledBackingCoverage();
3402 }
3403 
3404 void FrameView::autoSizeIfEnabled()
3405 {
3406     if (!m_shouldAutoSize)
3407         return;
3408 
3409     if (m_inAutoSize)
3410         return;
3411 
3412     auto* document = frame().document();
3413     if (!document)
3414         return;
3415 
3416     auto* renderView = document-&gt;renderView();
3417     if (!renderView)
3418         return;
3419 
3420     auto* firstChild = renderView-&gt;firstChild();
3421     if (!firstChild)
3422         return;
3423 
3424     LOG(Layout, &quot;FrameView %p autoSizeIfEnabled&quot;, this);
3425     SetForScope&lt;bool&gt; changeInAutoSize(m_inAutoSize, true);
3426     if (layoutContext().subtreeLayoutRoot())
3427         layoutContext().convertSubtreeLayoutToFullLayout();
3428 
3429     ScrollbarMode horizonalScrollbarMode = ScrollbarAlwaysOff;
3430     ScrollbarMode verticalScrollbarMode = ScrollbarAlwaysOff;
3431     setVerticalScrollbarLock(false);
3432     setHorizontalScrollbarLock(false);
3433     setScrollbarModes(horizonalScrollbarMode, verticalScrollbarMode, true, true);
3434 
3435     ASSERT(is&lt;RenderElement&gt;(*firstChild));
3436     auto&amp; documentRenderer = downcast&lt;RenderElement&gt;(*firstChild);
3437     documentRenderer.mutableStyle().setMaxWidth(Length(m_autoSizeConstraint.width(), Fixed));
3438     resize(m_autoSizeConstraint.width(), m_autoSizeConstraint.height());
3439 
3440     Ref&lt;FrameView&gt; protectedThis(*this);
3441     document-&gt;updateStyleIfNeeded();
3442     document-&gt;updateLayoutIgnorePendingStylesheets();
3443     // While the final content size could slightly be different after the next resize/layout (see below), we intentionally save and report
3444     // the current value to avoid unstable layout (e.g. content &quot;height: 100%&quot;).
3445     // See also webkit.org/b/173561
3446     m_autoSizeContentSize = contentsSize();
3447 
3448     auto finalWidth = std::max(m_autoSizeConstraint.width(), m_autoSizeContentSize.width());
3449     auto finalHeight = m_autoSizeFixedMinimumHeight ? std::max(m_autoSizeFixedMinimumHeight, m_autoSizeContentSize.height()) : m_autoSizeContentSize.height();
3450     resize(finalWidth, finalHeight);
3451     document-&gt;updateLayoutIgnorePendingStylesheets();
3452     if (auto* page = frame().page())
3453         page-&gt;chrome().client().intrinsicContentsSizeChanged(m_autoSizeContentSize);
3454     m_didRunAutosize = true;
3455 }
3456 
3457 void FrameView::setAutoSizeFixedMinimumHeight(int fixedMinimumHeight)
3458 {
3459     if (m_autoSizeFixedMinimumHeight == fixedMinimumHeight)
3460         return;
3461 
3462     m_autoSizeFixedMinimumHeight = fixedMinimumHeight;
3463 
3464     setNeedsLayoutAfterViewConfigurationChange();
3465 }
3466 
3467 RenderElement* FrameView::viewportRenderer() const
3468 {
3469     if (m_viewportRendererType == ViewportRendererType::None)
3470         return nullptr;
3471 
3472     auto* document = frame().document();
3473     if (!document)
3474         return nullptr;
3475 
3476     if (m_viewportRendererType == ViewportRendererType::Document) {
3477         auto* documentElement = document-&gt;documentElement();
3478         if (!documentElement)
3479             return nullptr;
3480         return documentElement-&gt;renderer();
3481     }
3482 
3483     if (m_viewportRendererType == ViewportRendererType::Body) {
3484         auto* body = document-&gt;body();
3485         if (!body)
3486             return nullptr;
3487         return body-&gt;renderer();
3488     }
3489 
3490     ASSERT_NOT_REACHED();
3491     return nullptr;
3492 }
3493 
3494 void FrameView::updateOverflowStatus(bool horizontalOverflow, bool verticalOverflow)
3495 {
3496     auto* viewportRenderer = this-&gt;viewportRenderer();
3497     if (!viewportRenderer)
3498         return;
3499 
3500     if (m_overflowStatusDirty) {
3501         m_horizontalOverflow = horizontalOverflow;
3502         m_verticalOverflow = verticalOverflow;
3503         m_overflowStatusDirty = false;
3504         return;
3505     }
3506 
3507     bool horizontalOverflowChanged = (m_horizontalOverflow != horizontalOverflow);
3508     bool verticalOverflowChanged = (m_verticalOverflow != verticalOverflow);
3509 
3510     if (horizontalOverflowChanged || verticalOverflowChanged) {
3511         m_horizontalOverflow = horizontalOverflow;
3512         m_verticalOverflow = verticalOverflow;
3513 
3514         Ref&lt;OverflowEvent&gt; overflowEvent = OverflowEvent::create(horizontalOverflowChanged, horizontalOverflow,
3515             verticalOverflowChanged, verticalOverflow);
3516         overflowEvent-&gt;setTarget(viewportRenderer-&gt;element());
3517 
3518         frame().document()-&gt;enqueueOverflowEvent(WTFMove(overflowEvent));
3519     }
3520 }
3521 
3522 const Pagination&amp; FrameView::pagination() const
3523 {
3524     if (m_pagination != Pagination())
3525         return m_pagination;
3526 
3527     if (frame().isMainFrame()) {
3528         if (Page* page = frame().page())
3529             return page-&gt;pagination();
3530     }
3531 
3532     return m_pagination;
3533 }
3534 
3535 void FrameView::setPagination(const Pagination&amp; pagination)
3536 {
3537     if (m_pagination == pagination)
3538         return;
3539 
3540     m_pagination = pagination;
3541 
3542     frame().document()-&gt;styleScope().didChangeStyleSheetEnvironment();
3543 }
3544 
3545 IntRect FrameView::windowClipRect() const
3546 {
3547     ASSERT(frame().view() == this);
3548 
3549     if (m_cachedWindowClipRect)
3550         return *m_cachedWindowClipRect;
3551 
3552     if (paintsEntireContents())
3553         return contentsToWindow(IntRect(IntPoint(), totalContentsSize()));
3554 
3555     // Set our clip rect to be our contents.
3556     IntRect clipRect = contentsToWindow(visibleContentRect(LegacyIOSDocumentVisibleRect));
3557 
3558     if (!frame().ownerElement())
3559         return clipRect;
3560 
3561     // Take our owner element and get its clip rect.
3562     HTMLFrameOwnerElement* ownerElement = frame().ownerElement();
3563     if (FrameView* parentView = ownerElement-&gt;document().view())
3564         clipRect.intersect(parentView-&gt;windowClipRectForFrameOwner(ownerElement, true));
3565     return clipRect;
3566 }
3567 
3568 IntRect FrameView::windowClipRectForFrameOwner(const HTMLFrameOwnerElement* ownerElement, bool clipToLayerContents) const
3569 {
3570     // The renderer can sometimes be null when style=&quot;display:none&quot; interacts
3571     // with external content and plugins.
3572     if (!ownerElement-&gt;renderer())
3573         return windowClipRect();
3574 
3575     // If we have no layer, just return our window clip rect.
3576     const RenderLayer* enclosingLayer = ownerElement-&gt;renderer()-&gt;enclosingLayer();
3577     if (!enclosingLayer)
3578         return windowClipRect();
3579 
3580     // Apply the clip from the layer.
3581     IntRect clipRect;
3582     if (clipToLayerContents)
3583         clipRect = snappedIntRect(enclosingLayer-&gt;childrenClipRect());
3584     else
3585         clipRect = snappedIntRect(enclosingLayer-&gt;selfClipRect());
3586     clipRect = contentsToWindow(clipRect);
3587     return intersection(clipRect, windowClipRect());
3588 }
3589 
3590 bool FrameView::isActive() const
3591 {
3592     Page* page = frame().page();
3593     return page &amp;&amp; page-&gt;focusController().isActive();
3594 }
3595 
3596 bool FrameView::forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const
3597 {
3598     Page* page = frame().page();
3599     return page &amp;&amp; page-&gt;settings().forceUpdateScrollbarsOnMainThreadForPerformanceTesting();
3600 }
3601 
3602 void FrameView::scrollTo(const ScrollPosition&amp; newPosition)
3603 {
3604     IntPoint oldPosition = scrollPosition();
3605     ScrollView::scrollTo(newPosition);
3606     if (oldPosition != scrollPosition())
3607         scrollPositionChanged(oldPosition, scrollPosition());
3608 
3609     didChangeScrollOffset();
3610 }
3611 
3612 float FrameView::adjustScrollStepForFixedContent(float step, ScrollbarOrientation orientation, ScrollGranularity granularity)
3613 {
3614     if (granularity != ScrollByPage || orientation == HorizontalScrollbar)
3615         return step;
3616 
3617     TrackedRendererListHashSet* positionedObjects = nullptr;
3618     if (RenderView* root = frame().contentRenderer()) {
3619         if (!root-&gt;hasPositionedObjects())
3620             return step;
3621         positionedObjects = root-&gt;positionedObjects();
3622     }
3623 
3624     FloatRect unobscuredContentRect = this-&gt;unobscuredContentRect();
3625     float topObscuredArea = 0;
3626     float bottomObscuredArea = 0;
3627     for (const auto&amp; positionedObject : *positionedObjects) {
3628         const RenderStyle&amp; style = positionedObject-&gt;style();
3629         if (style.position() != PositionType::Fixed || style.visibility() == Visibility::Hidden || !style.opacity())
3630             continue;
3631 
3632         FloatQuad contentQuad = positionedObject-&gt;absoluteContentQuad();
3633         if (!contentQuad.isRectilinear())
3634             continue;
3635 
3636         FloatRect contentBoundingBox = contentQuad.boundingBox();
3637         FloatRect fixedRectInView = intersection(unobscuredContentRect, contentBoundingBox);
3638 
3639         if (fixedRectInView.width() &lt; unobscuredContentRect.width())
3640             continue;
3641 
3642         if (fixedRectInView.y() == unobscuredContentRect.y())
3643             topObscuredArea = std::max(topObscuredArea, fixedRectInView.height());
3644         else if (fixedRectInView.maxY() == unobscuredContentRect.maxY())
3645             bottomObscuredArea = std::max(bottomObscuredArea, fixedRectInView.height());
3646     }
3647 
3648     return Scrollbar::pageStep(unobscuredContentRect.height(), unobscuredContentRect.height() - topObscuredArea - bottomObscuredArea);
3649 }
3650 
3651 void FrameView::invalidateScrollbarRect(Scrollbar&amp; scrollbar, const IntRect&amp; rect)
3652 {
3653     // Add in our offset within the FrameView.
3654     IntRect dirtyRect = rect;
3655     dirtyRect.moveBy(scrollbar.location());
3656     invalidateRect(dirtyRect);
3657 }
3658 
3659 float FrameView::visibleContentScaleFactor() const
3660 {
3661     if (!frame().isMainFrame() || !frame().settings().delegatesPageScaling())
3662         return 1;
3663 
3664     Page* page = frame().page();
3665     if (!page)
3666         return 1;
3667 
3668     return page-&gt;pageScaleFactor();
3669 }
3670 
3671 void FrameView::setVisibleScrollerThumbRect(const IntRect&amp; scrollerThumb)
3672 {
3673     if (!frame().isMainFrame())
3674         return;
3675 
3676     if (Page* page = frame().page())
3677         page-&gt;chrome().client().notifyScrollerThumbIsVisibleInRect(scrollerThumb);
3678 }
3679 
3680 ScrollableArea* FrameView::enclosingScrollableArea() const
3681 {
3682     // FIXME: Walk up the frame tree and look for a scrollable parent frame or RenderLayer.
3683     return nullptr;
3684 }
3685 
3686 IntRect FrameView::scrollableAreaBoundingBox(bool*) const
3687 {
3688     RenderWidget* ownerRenderer = frame().ownerRenderer();
3689     if (!ownerRenderer)
3690         return frameRect();
3691 
3692     return ownerRenderer-&gt;absoluteContentQuad().enclosingBoundingBox();
3693 }
3694 
3695 bool FrameView::isScrollable(Scrollability definitionOfScrollable)
3696 {
3697     // Check for:
3698     // 1) If there an actual overflow.
3699     // 2) display:none or visibility:hidden set to self or inherited.
3700     // 3) overflow{-x,-y}: hidden;
3701     // 4) scrolling: no;
3702     if (!didFirstLayout())
3703         return false;
3704 
3705     bool requiresActualOverflowToBeConsideredScrollable = !frame().isMainFrame() || definitionOfScrollable != Scrollability::ScrollableOrRubberbandable;
3706 #if !ENABLE(RUBBER_BANDING)
3707     requiresActualOverflowToBeConsideredScrollable = true;
3708 #endif
3709 
3710     // Covers #1
3711     if (requiresActualOverflowToBeConsideredScrollable) {
3712         IntSize totalContentsSize = this-&gt;totalContentsSize();
3713         IntSize visibleContentSize = visibleContentRect(LegacyIOSDocumentVisibleRect).size();
3714         if (totalContentsSize.height() &lt;= visibleContentSize.height() &amp;&amp; totalContentsSize.width() &lt;= visibleContentSize.width())
3715             return false;
3716     }
3717 
3718     // Covers #2.
3719     HTMLFrameOwnerElement* owner = frame().ownerElement();
3720     if (owner &amp;&amp; (!owner-&gt;renderer() || !owner-&gt;renderer()-&gt;visibleToHitTesting()))
3721         return false;
3722 
3723     // Cover #3 and #4.
3724     ScrollbarMode horizontalMode;
3725     ScrollbarMode verticalMode;
3726     calculateScrollbarModesForLayout(horizontalMode, verticalMode, RulesFromWebContentOnly);
3727     if (horizontalMode == ScrollbarAlwaysOff &amp;&amp; verticalMode == ScrollbarAlwaysOff)
3728         return false;
3729 
3730     return true;
3731 }
3732 
3733 bool FrameView::isScrollableOrRubberbandable()
3734 {
3735     return isScrollable(Scrollability::ScrollableOrRubberbandable);
3736 }
3737 
3738 bool FrameView::hasScrollableOrRubberbandableAncestor()
3739 {
3740     if (frame().isMainFrame())
3741         return isScrollableOrRubberbandable();
3742 
3743     for (FrameView* parent = this-&gt;parentFrameView(); parent; parent = parent-&gt;parentFrameView()) {
3744         Scrollability frameScrollability = parent-&gt;frame().isMainFrame() ? Scrollability::ScrollableOrRubberbandable : Scrollability::Scrollable;
3745         if (parent-&gt;isScrollable(frameScrollability))
3746             return true;
3747     }
3748 
3749     return false;
3750 }
3751 
3752 void FrameView::updateScrollableAreaSet()
3753 {
3754     // That ensures that only inner frames are cached.
3755     FrameView* parentFrameView = this-&gt;parentFrameView();
3756     if (!parentFrameView)
3757         return;
3758 
3759     if (!isScrollable()) {
3760         parentFrameView-&gt;removeScrollableArea(this);
3761         return;
3762     }
3763 
3764     parentFrameView-&gt;addScrollableArea(this);
3765 }
3766 
3767 bool FrameView::shouldSuspendScrollAnimations() const
3768 {
3769     return frame().loader().state() != FrameStateComplete;
3770 }
3771 
3772 void FrameView::scrollbarStyleChanged(ScrollbarStyle newStyle, bool forceUpdate)
3773 {
3774     if (!frame().isMainFrame())
3775         return;
3776 
3777     if (Page* page = frame().page())
3778         page-&gt;chrome().client().recommendedScrollbarStyleDidChange(newStyle);
3779 
3780     ScrollView::scrollbarStyleChanged(newStyle, forceUpdate);
3781 }
3782 
3783 void FrameView::notifyPageThatContentAreaWillPaint() const
3784 {
3785     Page* page = frame().page();
3786     if (!page)
3787         return;
3788 
3789     contentAreaWillPaint();
3790 
3791     if (!m_scrollableAreas)
3792         return;
3793 
3794     for (auto&amp; scrollableArea : *m_scrollableAreas)
3795         scrollableArea-&gt;contentAreaWillPaint();
3796 }
3797 
3798 bool FrameView::scrollAnimatorEnabled() const
3799 {
3800 #if ENABLE(SMOOTH_SCROLLING)
3801     if (Page* page = frame().page())
3802         return page-&gt;settings().scrollAnimatorEnabled();
3803 #endif
3804 
3805     return false;
3806 }
3807 
3808 void FrameView::updateScrollCorner()
3809 {
3810     RenderElement* renderer = nullptr;
3811     std::unique_ptr&lt;RenderStyle&gt; cornerStyle;
3812     IntRect cornerRect = scrollCornerRect();
3813 
3814     if (!cornerRect.isEmpty()) {
3815         // Try the &lt;body&gt; element first as a scroll corner source.
3816         Document* doc = frame().document();
3817         Element* body = doc ? doc-&gt;bodyOrFrameset() : nullptr;
3818         if (body &amp;&amp; body-&gt;renderer()) {
3819             renderer = body-&gt;renderer();
3820             cornerStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;renderer-&gt;style());
3821         }
3822 
3823         if (!cornerStyle) {
3824             // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
3825             Element* docElement = doc ? doc-&gt;documentElement() : nullptr;
3826             if (docElement &amp;&amp; docElement-&gt;renderer()) {
3827                 renderer = docElement-&gt;renderer();
3828                 cornerStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;renderer-&gt;style());
3829             }
3830         }
3831 
3832         if (!cornerStyle) {
3833             // If we have an owning iframe/frame element, then it can set the custom scrollbar also.
3834             if (RenderWidget* renderer = frame().ownerRenderer())
3835                 cornerStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;renderer-&gt;style());
3836         }
3837     }
3838 
3839     if (!cornerStyle)
3840         m_scrollCorner = nullptr;
3841     else {
3842         if (!m_scrollCorner) {
3843             m_scrollCorner = createRenderer&lt;RenderScrollbarPart&gt;(renderer-&gt;document(), WTFMove(*cornerStyle));
3844             m_scrollCorner-&gt;initializeStyle();
3845         } else
3846             m_scrollCorner-&gt;setStyle(WTFMove(*cornerStyle));
3847         invalidateScrollCorner(cornerRect);
3848     }
3849 }
3850 
3851 void FrameView::paintScrollCorner(GraphicsContext&amp; context, const IntRect&amp; cornerRect)
3852 {
3853     if (context.invalidatingControlTints()) {
3854         updateScrollCorner();
3855         return;
3856     }
3857 
3858     if (m_scrollCorner) {
3859         if (frame().isMainFrame())
3860             context.fillRect(cornerRect, baseBackgroundColor());
3861         m_scrollCorner-&gt;paintIntoRect(context, cornerRect.location(), cornerRect);
3862         return;
3863     }
3864 
3865 #if PLATFORM(MAC)
3866     // Keep this in sync with ScrollAnimatorMac&#39;s effectiveAppearanceForScrollerImp:.
3867     LocalDefaultSystemAppearance localAppearance(useDarkAppearanceForScrollbars());
3868 #endif
3869 
3870     ScrollView::paintScrollCorner(context, cornerRect);
3871 }
3872 
3873 void FrameView::paintScrollbar(GraphicsContext&amp; context, Scrollbar&amp; bar, const IntRect&amp; rect)
3874 {
3875     if (bar.isCustomScrollbar() &amp;&amp; frame().isMainFrame()) {
3876         IntRect toFill = bar.frameRect();
3877         toFill.intersect(rect);
3878         context.fillRect(toFill, baseBackgroundColor());
3879     }
3880 
3881     ScrollView::paintScrollbar(context, bar, rect);
3882 }
3883 
3884 Color FrameView::documentBackgroundColor() const
3885 {
3886     // &lt;https://bugs.webkit.org/show_bug.cgi?id=59540&gt; We blend the background color of
3887     // the document and the body against the base background color of the frame view.
3888     // Background images are unfortunately impractical to include.
3889 
3890     // Return invalid Color objects whenever there is insufficient information.
3891     if (!frame().document())
3892         return Color();
3893 
3894     auto* htmlElement = frame().document()-&gt;documentElement();
3895     auto* bodyElement = frame().document()-&gt;bodyOrFrameset();
3896 
3897     // Start with invalid colors.
3898     Color htmlBackgroundColor;
3899     Color bodyBackgroundColor;
3900     if (htmlElement &amp;&amp; htmlElement-&gt;renderer())
3901         htmlBackgroundColor = htmlElement-&gt;renderer()-&gt;style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
3902     if (bodyElement &amp;&amp; bodyElement-&gt;renderer())
3903         bodyBackgroundColor = bodyElement-&gt;renderer()-&gt;style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
3904 
3905     if (!bodyBackgroundColor.isValid()) {
3906         if (!htmlBackgroundColor.isValid())
3907             return Color();
3908         return baseBackgroundColor().blend(htmlBackgroundColor);
3909     }
3910 
3911     if (!htmlBackgroundColor.isValid())
3912         return baseBackgroundColor().blend(bodyBackgroundColor);
3913 
3914     // We take the aggregate of the base background color
3915     // the &lt;html&gt; background color, and the &lt;body&gt;
3916     // background color to find the document color. The
3917     // addition of the base background color is not
3918     // technically part of the document background, but it
3919     // otherwise poses problems when the aggregate is not
3920     // fully opaque.
3921     return baseBackgroundColor().blend(htmlBackgroundColor).blend(bodyBackgroundColor);
3922 }
3923 
3924 bool FrameView::hasCustomScrollbars() const
3925 {
3926     for (auto&amp; widget : children()) {
3927         if (is&lt;FrameView&gt;(widget)) {
3928             if (downcast&lt;FrameView&gt;(widget.get()).hasCustomScrollbars())
3929                 return true;
3930         } else if (is&lt;Scrollbar&gt;(widget)) {
3931             if (downcast&lt;Scrollbar&gt;(widget.get()).isCustomScrollbar())
3932                 return true;
3933         }
3934     }
3935     return false;
3936 }
3937 
3938 FrameView* FrameView::parentFrameView() const
3939 {
3940     if (!parent())
3941         return nullptr;
3942     auto* parentFrame = frame().tree().parent();
3943     if (!parentFrame)
3944         return nullptr;
3945     return parentFrame-&gt;view();
3946 }
3947 
3948 bool FrameView::isInChildFrameWithFrameFlattening() const
3949 {
3950     if (!frameFlatteningEnabled())
3951         return false;
3952 
3953     if (!parent())
3954         return false;
3955 
3956     HTMLFrameOwnerElement* ownerElement = frame().ownerElement();
3957     if (!ownerElement)
3958         return false;
3959 
3960     if (!ownerElement-&gt;renderWidget())
3961         return false;
3962 
3963     // Frame flattening applies when the owner element is either in a frameset or
3964     // an iframe with flattening parameters.
3965     if (is&lt;HTMLIFrameElement&gt;(*ownerElement))
3966         return downcast&lt;RenderIFrame&gt;(*ownerElement-&gt;renderWidget()).flattenFrame();
3967 
3968     if (is&lt;HTMLFrameElement&gt;(*ownerElement))
3969         return true;
3970 
3971     return false;
3972 }
3973 
3974 void FrameView::updateControlTints()
3975 {
3976     // This is called when control tints are changed from aqua/graphite to clear and vice versa.
3977     // We do a &quot;fake&quot; paint, and when the theme gets a paint call, it can then do an invalidate.
3978     // This is only done if the theme supports control tinting. It&#39;s up to the theme and platform
3979     // to define when controls get the tint and to call this function when that changes.
3980 
3981     // Optimize the common case where we bring a window to the front while it&#39;s still empty.
3982     if (frame().document()-&gt;url().isEmpty())
3983         return;
3984 
3985     // As noted above, this is a &quot;fake&quot; paint, so we should pause counting relevant repainted objects.
3986     Page* page = frame().page();
3987     bool isCurrentlyCountingRelevantRepaintedObject = false;
3988     if (page) {
3989         isCurrentlyCountingRelevantRepaintedObject = page-&gt;isCountingRelevantRepaintedObjects();
3990         page-&gt;setIsCountingRelevantRepaintedObjects(false);
3991     }
3992 
3993     RenderView* renderView = this-&gt;renderView();
3994     if ((renderView &amp;&amp; renderView-&gt;theme().supportsControlTints()) || hasCustomScrollbars())
3995         invalidateControlTints();
3996 
3997     if (page)
3998         page-&gt;setIsCountingRelevantRepaintedObjects(isCurrentlyCountingRelevantRepaintedObject);
3999 }
4000 
4001 void FrameView::traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons paintInvalidationReasons)
4002 {
4003     if (needsLayout())
4004         layoutContext().layout();
4005 
4006     GraphicsContext context(paintInvalidationReasons);
4007     if (platformWidget()) {
4008         // FIXME: consult paintsEntireContents().
4009         paintContents(context, visibleContentRect(LegacyIOSDocumentVisibleRect));
4010     } else
4011         paint(context, frameRect());
4012 }
4013 
4014 bool FrameView::wasScrolledByUser() const
4015 {
4016     return m_wasScrolledByUser;
4017 }
4018 
4019 void FrameView::setWasScrolledByUser(bool wasScrolledByUser)
4020 {
4021     LOG(Scrolling, &quot;FrameView::setWasScrolledByUser at %d&quot;, wasScrolledByUser);
4022 
4023     m_shouldScrollToFocusedElement = false;
4024     m_delayedScrollToFocusedElementTimer.stop();
4025     if (currentScrollType() == ScrollType::Programmatic)
4026         return;
4027     m_maintainScrollPositionAnchor = nullptr;
4028     if (m_wasScrolledByUser == wasScrolledByUser)
4029         return;
4030     m_wasScrolledByUser = wasScrolledByUser;
4031     if (frame().isMainFrame())
4032         updateLayerFlushThrottling();
4033     adjustTiledBackingCoverage();
4034 }
4035 
4036 void FrameView::willPaintContents(GraphicsContext&amp; context, const IntRect&amp;, PaintingState&amp; paintingState)
4037 {
4038     Document* document = frame().document();
4039 
4040     if (!context.paintingDisabled())
4041         InspectorInstrumentation::willPaint(*renderView());
4042 
4043     paintingState.isTopLevelPainter = !sCurrentPaintTimeStamp;
4044 
4045     if (paintingState.isTopLevelPainter)
4046         sCurrentPaintTimeStamp = MonotonicTime::now();
4047 
4048     paintingState.paintBehavior = m_paintBehavior;
4049 
4050     if (FrameView* parentView = parentFrameView()) {
4051         if (parentView-&gt;paintBehavior() &amp; PaintBehavior::FlattenCompositingLayers)
4052             m_paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4053 
4054         if (parentView-&gt;paintBehavior() &amp; PaintBehavior::Snapshotting)
4055             m_paintBehavior.add(PaintBehavior::Snapshotting);
4056 
4057         if (parentView-&gt;paintBehavior() &amp; PaintBehavior::TileFirstPaint)
4058             m_paintBehavior.add(PaintBehavior::TileFirstPaint);
4059     }
4060 
4061     if (document-&gt;printing()) {
4062         m_paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4063         m_paintBehavior.add(PaintBehavior::Snapshotting);
4064     }
4065 
4066     paintingState.isFlatteningPaintOfRootFrame = (m_paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) &amp;&amp; !frame().ownerElement();
4067     if (paintingState.isFlatteningPaintOfRootFrame)
4068         notifyWidgetsInAllFrames(WillPaintFlattened);
4069 
4070     ASSERT(!m_isPainting);
4071     m_isPainting = true;
4072 }
4073 
4074 void FrameView::didPaintContents(GraphicsContext&amp; context, const IntRect&amp; dirtyRect, PaintingState&amp; paintingState)
4075 {
4076     m_isPainting = false;
4077 
4078     if (paintingState.isFlatteningPaintOfRootFrame)
4079         notifyWidgetsInAllFrames(DidPaintFlattened);
4080 
4081     m_paintBehavior = paintingState.paintBehavior;
4082     m_lastPaintTime = MonotonicTime::now();
4083 
4084     if (paintingState.isTopLevelPainter)
4085         sCurrentPaintTimeStamp = MonotonicTime();
4086 
4087     if (!context.paintingDisabled()) {
4088         InspectorInstrumentation::didPaint(*renderView(), dirtyRect);
4089         // FIXME: should probably not fire milestones for snapshot painting. https://bugs.webkit.org/show_bug.cgi?id=117623
4090         firePaintRelatedMilestonesIfNeeded();
4091     }
4092 }
4093 
4094 void FrameView::paintContents(GraphicsContext&amp; context, const IntRect&amp; dirtyRect, SecurityOriginPaintPolicy securityOriginPaintPolicy)
4095 {
4096 #ifndef NDEBUG
4097     bool fillWithWarningColor;
4098     if (frame().document()-&gt;printing())
4099         fillWithWarningColor = false; // Printing, don&#39;t fill with red (can&#39;t remember why).
4100     else if (frame().ownerElement())
4101         fillWithWarningColor = false; // Subframe, don&#39;t fill with red.
4102     else if (isTransparent())
4103         fillWithWarningColor = false; // Transparent, don&#39;t fill with red.
4104     else if (m_paintBehavior &amp; PaintBehavior::SelectionOnly)
4105         fillWithWarningColor = false; // Selections are transparent, don&#39;t fill with red.
4106     else if (m_nodeToDraw)
4107         fillWithWarningColor = false; // Element images are transparent, don&#39;t fill with red.
4108     else
4109         fillWithWarningColor = true;
4110 
4111     if (fillWithWarningColor)
4112         context.fillRect(dirtyRect, Color(255, 64, 255));
4113 #endif
4114 
4115     RenderView* renderView = this-&gt;renderView();
4116     if (!renderView) {
4117         LOG_ERROR(&quot;called FrameView::paint with nil renderer&quot;);
4118         return;
4119     }
4120 
4121     if (!layoutContext().inPaintableState())
4122         return;
4123 
4124     ASSERT(!needsLayout());
4125     if (needsLayout()) {
4126         RELEASE_LOG_IF_ALLOWED(&quot;FrameView::paintContents() - not painting because render tree needs layout (is main frame %d)&quot;, frame().isMainFrame());
4127         return;
4128     }
4129 
4130     PaintingState paintingState;
4131     willPaintContents(context, dirtyRect, paintingState);
4132 
4133     // m_nodeToDraw is used to draw only one element (and its descendants)
4134     RenderObject* renderer = m_nodeToDraw ? m_nodeToDraw-&gt;renderer() : nullptr;
4135     RenderLayer* rootLayer = renderView-&gt;layer();
4136 
4137 #ifndef NDEBUG
4138     RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;rootLayer-&gt;renderer());
4139 #endif
4140 
4141     // To work around http://webkit.org/b/135106, ensure that the paint root isn&#39;t an inline with culled line boxes.
4142     // FIXME: This can cause additional content to be included in the snapshot, so remove this once that bug is fixed.
4143     while (is&lt;RenderInline&gt;(renderer) &amp;&amp; !downcast&lt;RenderInline&gt;(*renderer).firstLineBox())
4144         renderer = renderer-&gt;parent();
4145 
4146     rootLayer-&gt;paint(context, dirtyRect, LayoutSize(), m_paintBehavior, renderer, { }, securityOriginPaintPolicy == SecurityOriginPaintPolicy::AnyOrigin ? RenderLayer::SecurityOriginPaintPolicy::AnyOrigin : RenderLayer::SecurityOriginPaintPolicy::AccessibleOriginOnly);
4147     if (rootLayer-&gt;containsDirtyOverlayScrollbars())
4148         rootLayer-&gt;paintOverlayScrollbars(context, dirtyRect, m_paintBehavior, renderer);
4149 
4150     didPaintContents(context, dirtyRect, paintingState);
4151 }
4152 
4153 void FrameView::setPaintBehavior(OptionSet&lt;PaintBehavior&gt; behavior)
4154 {
4155     m_paintBehavior = behavior;
4156 }
4157 
4158 OptionSet&lt;PaintBehavior&gt; FrameView::paintBehavior() const
4159 {
4160     return m_paintBehavior;
4161 }
4162 
4163 bool FrameView::isPainting() const
4164 {
4165     return m_isPainting;
4166 }
4167 
4168 // FIXME: change this to use the subtreePaint terminology.
4169 void FrameView::setNodeToDraw(Node* node)
4170 {
4171     m_nodeToDraw = node;
4172 }
4173 
4174 void FrameView::paintContentsForSnapshot(GraphicsContext&amp; context, const IntRect&amp; imageRect, SelectionInSnapshot shouldPaintSelection, CoordinateSpaceForSnapshot coordinateSpace)
4175 {
4176     updateLayoutAndStyleIfNeededRecursive();
4177 
4178     // Cache paint behavior and set a new behavior appropriate for snapshots.
4179     auto oldBehavior = paintBehavior();
4180     setPaintBehavior(oldBehavior | PaintBehavior::FlattenCompositingLayers | PaintBehavior::Snapshotting);
4181 
4182     // If the snapshot should exclude selection, then we&#39;ll clear the current selection
4183     // in the render tree only. This will allow us to restore the selection from the DOM
4184     // after we paint the snapshot.
4185     if (shouldPaintSelection == ExcludeSelection) {
4186         for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
4187             if (auto* renderView = frame-&gt;contentRenderer())
4188                 renderView-&gt;selection().clear();
4189         }
4190     }
4191 
4192     if (coordinateSpace == DocumentCoordinates)
4193         paintContents(context, imageRect);
4194     else {
4195         // A snapshot in ViewCoordinates will include a scrollbar, and the snapshot will contain
4196         // whatever content the document is currently scrolled to.
4197         paint(context, imageRect);
4198     }
4199 
4200     // Restore selection.
4201     if (shouldPaintSelection == ExcludeSelection) {
4202         for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr()))
4203             frame-&gt;selection().updateAppearance();
4204     }
4205 
4206     // Restore cached paint behavior.
4207     setPaintBehavior(oldBehavior);
4208 }
4209 
4210 void FrameView::paintOverhangAreas(GraphicsContext&amp; context, const IntRect&amp; horizontalOverhangArea, const IntRect&amp; verticalOverhangArea, const IntRect&amp; dirtyRect)
4211 {
4212     if (context.paintingDisabled())
4213         return;
4214 
4215     if (frame().document()-&gt;printing())
4216         return;
4217 
4218     ScrollView::paintOverhangAreas(context, horizontalOverhangArea, verticalOverhangArea, dirtyRect);
4219 }
4220 
4221 void FrameView::updateLayoutAndStyleIfNeededRecursive()
4222 {
4223     // Style updating, render tree creation, and layout needs to be done multiple times
4224     // for more than one reason. But one reason is that when an &lt;object&gt; element determines
4225     // what it needs to load a subframe, a second pass is needed. That requires update
4226     // passes equal to the number of levels of DOM nesting. That is why this number is large.
4227     // There are test cases where we have roughly 10 levels of DOM nesting, so this needs to
4228     // be greater than that. We have a limit to avoid the possibility of an infinite loop.
4229     // Typical calls will run the loop 2 times (once to do work, once to detect no further work
4230     // is needed).
4231     // FIXME: We should find an approach that does not require a loop at all.
4232     const unsigned maxUpdatePasses = 25;
4233 
4234     // Style updates can trigger script, which can cause this FrameView to be destroyed.
4235     Ref&lt;FrameView&gt; protectedThis(*this);
4236 
4237     AnimationUpdateBlock animationUpdateBlock(&amp;frame().animation());
4238 
4239     using DescendantsDeque = Deque&lt;Ref&lt;FrameView&gt;, 16&gt;;
4240     auto nextRenderedDescendant = [this] (DescendantsDeque&amp; descendantsDeque) -&gt; RefPtr&lt;FrameView&gt; {
4241         if (descendantsDeque.isEmpty())
4242             descendantsDeque.append(*this);
4243         else {
4244             // Append renderered children after processing the parent, in case the processing
4245             // affects the set of rendered children.
4246             auto previousView = descendantsDeque.takeFirst();
4247             for (auto* frame = previousView-&gt;frame().tree().firstRenderedChild(); frame; frame = frame-&gt;tree().nextRenderedSibling()) {
4248                 if (auto* view = frame-&gt;view())
4249                     descendantsDeque.append(*view);
4250             }
4251             if (descendantsDeque.isEmpty())
4252                 return nullptr;
4253         }
4254         return descendantsDeque.first().ptr();
4255     };
4256 
4257     for (unsigned i = 0; i &lt; maxUpdatePasses; ++i) {
4258         bool didWork = false;
4259         DescendantsDeque deque;
4260         while (auto view = nextRenderedDescendant(deque)) {
4261             if (view-&gt;frame().document()-&gt;updateStyleIfNeeded())
4262                 didWork = true;
4263             if (view-&gt;needsLayout()) {
4264                 view-&gt;layoutContext().layout();
4265                 didWork = true;
4266             }
4267         }
4268         if (!didWork)
4269             break;
4270     }
4271 
4272 #if !ASSERT_DISABLED
4273     auto needsStyleRecalc = [&amp;] {
4274         DescendantsDeque deque;
4275         while (auto view = nextRenderedDescendant(deque)) {
4276             auto* document = view-&gt;frame().document();
4277             if (document &amp;&amp; document-&gt;childNeedsStyleRecalc())
4278                 return true;
4279         }
4280         return false;
4281     };
4282 
4283     auto needsLayout = [&amp;] {
4284         DescendantsDeque deque;
4285         while (auto view = nextRenderedDescendant(deque)) {
4286             if (view-&gt;needsLayout())
4287                 return true;
4288         }
4289         return false;
4290     };
4291 #endif
4292 
4293     ASSERT(!needsStyleRecalc());
4294     ASSERT(!needsLayout());
4295 }
4296 
4297 void FrameView::incrementVisuallyNonEmptyCharacterCount(const String&amp; inlineText)
4298 {
4299     if (m_visuallyNonEmptyCharacterCount &gt; visualCharacterThreshold &amp;&amp; m_hasReachedSignificantRenderedTextThreshold)
4300         return;
4301 
4302     auto nonWhitespaceLength = [](auto&amp; inlineText) {
4303         auto length = inlineText.length();
4304         for (unsigned i = 0; i &lt; inlineText.length(); ++i) {
4305             if (isNotHTMLSpace(inlineText[i]))
4306                 continue;
4307             --length;
4308         }
4309         return length;
4310     };
4311     m_visuallyNonEmptyCharacterCount += nonWhitespaceLength(inlineText);
4312     ++m_textRendererCountForVisuallyNonEmptyCharacters;
4313 }
4314 
4315 static bool elementOverflowRectIsLargerThanThreshold(const Element&amp; element)
4316 {
4317     // Require the document to grow a bit.
4318     // Using a value of 48 allows the header on Google&#39;s search page to render immediately before search results populate later.
4319     static const int documentHeightThreshold = 48;
4320     if (auto* elementRenderBox = element.renderBox())
4321         return snappedIntRect(elementRenderBox-&gt;layoutOverflowRect()).height() &gt;= documentHeightThreshold;
4322 
4323     return false;
4324 }
4325 
4326 void FrameView::updateHasReachedSignificantRenderedTextThreshold()
4327 {
4328     if (m_hasReachedSignificantRenderedTextThreshold)
4329         return;
4330 
4331     auto* page = frame().page();
4332     if (!page || !page-&gt;requestedLayoutMilestones().contains(DidRenderSignificantAmountOfText))
4333         return;
4334 
4335     auto* document = frame().document();
4336     if (!document)
4337         return;
4338 
4339     document-&gt;updateMainArticleElementAfterLayout();
4340     auto hasMainArticleElement = document-&gt;hasMainArticleElement();
4341     auto characterThreshold = hasMainArticleElement ? mainArticleSignificantRenderedTextCharacterThreshold : defaultSignificantRenderedTextCharacterThreshold;
4342     if (m_visuallyNonEmptyCharacterCount &lt; characterThreshold)
4343         return;
4344 
4345     auto meanLength = hasMainArticleElement ? mainArticleSignificantRenderedTextMeanLength : defaultSignificantRenderedTextMeanLength;
4346     if (!m_textRendererCountForVisuallyNonEmptyCharacters || m_visuallyNonEmptyCharacterCount / static_cast&lt;float&gt;(m_textRendererCountForVisuallyNonEmptyCharacters) &lt; meanLength)
4347         return;
4348 
4349     m_hasReachedSignificantRenderedTextThreshold = true;
4350 }
4351 
4352 bool FrameView::qualifiesAsSignificantRenderedText() const
4353 {
4354     ASSERT(!m_renderedSignificantAmountOfText);
4355     auto* document = frame().document();
4356     if (!document || document-&gt;styleScope().hasPendingSheetsBeforeBody())
4357         return false;
4358 
4359     auto* documentElement = document-&gt;documentElement();
4360     if (!documentElement || !elementOverflowRectIsLargerThanThreshold(*documentElement))
4361         return false;
4362 
4363     return m_hasReachedSignificantRenderedTextThreshold;
4364 }
4365 
4366 bool FrameView::qualifiesAsVisuallyNonEmpty() const
4367 {
4368     // No content yet.
4369     Element* documentElement = frame().document()-&gt;documentElement();
4370     if (!documentElement || !documentElement-&gt;renderer())
4371         return false;
4372 
4373     // FIXME: We should also ignore renderers with non-final style.
4374     if (frame().document()-&gt;styleScope().hasPendingSheetsBeforeBody())
4375         return false;
4376 
4377     auto finishedParsingMainDocument = frame().loader().stateMachine().committedFirstRealDocumentLoad() &amp;&amp; (frame().document()-&gt;readyState() == Document::Interactive || frame().document()-&gt;readyState() == Document::Complete);
4378     // Ensure that we always fire visually non-empty milestone eventually.
4379     if (finishedParsingMainDocument &amp;&amp; frame().loader().isComplete())
4380         return true;
4381 
4382     auto isVisible = [](const Element* element) {
4383         if (!element || !element-&gt;renderer())
4384             return false;
4385         if (!element-&gt;renderer()-&gt;opacity())
4386             return false;
4387         return element-&gt;renderer()-&gt;style().visibility() == Visibility::Visible;
4388     };
4389 
4390     if (!isVisible(documentElement))
4391         return false;
4392 
4393     if (!isVisible(frame().document()-&gt;body()))
4394         return false;
4395 
4396     if (!elementOverflowRectIsLargerThanThreshold(*documentElement))
4397         return false;
4398 
4399     // The first few hundred characters rarely contain the interesting content of the page.
4400     if (m_visuallyNonEmptyCharacterCount &gt; visualCharacterThreshold)
4401         return true;
4402 
4403     // Use a threshold value to prevent very small amounts of visible content from triggering didFirstVisuallyNonEmptyLayout
4404     if (m_visuallyNonEmptyPixelCount &gt; visualPixelThreshold)
4405         return true;
4406 
4407     auto isMoreContentExpected = [&amp;]() {
4408         ASSERT(finishedParsingMainDocument);
4409         // Pending css/font loading means we should wait a little longer. Classic non-async, non-defer scripts are all processed by now.
4410         auto* documentLoader = frame().loader().documentLoader();
4411         if (!documentLoader)
4412             return false;
4413 
4414         auto&amp; resourceLoader = documentLoader-&gt;cachedResourceLoader();
4415         if (!resourceLoader.requestCount())
4416             return false;
4417 
4418         auto&amp; resources = resourceLoader.allCachedResources();
4419         for (auto&amp; resource : resources) {
4420             if (resource.value-&gt;isLoaded())
4421                 continue;
4422             if (resource.value-&gt;type() == CachedResource::Type::CSSStyleSheet || resource.value-&gt;type() == CachedResource::Type::FontResource)
4423                 return true;
4424         }
4425         return false;
4426     };
4427 
4428     // Finished parsing the main document and we still don&#39;t yet have enough content. Check if we might be getting some more.
4429     if (finishedParsingMainDocument)
4430         return !isMoreContentExpected();
4431 
4432     return false;
4433 }
4434 
4435 bool FrameView::isViewForDocumentInFrame() const
4436 {
4437     RenderView* renderView = this-&gt;renderView();
4438     if (!renderView)
4439         return false;
4440 
4441     return &amp;renderView-&gt;frameView() == this;
4442 }
4443 
4444 void FrameView::enableAutoSizeMode(bool enable, const IntSize&amp; viewSize)
4445 {
4446     ASSERT(!enable || !viewSize.isEmpty());
4447     if (m_shouldAutoSize == enable &amp;&amp; m_autoSizeConstraint == viewSize)
4448         return;
4449 
4450     m_shouldAutoSize = enable;
4451     m_autoSizeConstraint = viewSize;
4452     m_autoSizeContentSize = contentsSize();
4453     m_didRunAutosize = false;
4454 
4455     setNeedsLayoutAfterViewConfigurationChange();
4456     layoutContext().scheduleLayout();
4457     if (m_shouldAutoSize) {
4458         overrideViewportSizeForCSSViewportUnits({ m_autoSizeConstraint.width(), m_overrideViewportSize ? m_overrideViewportSize-&gt;height : WTF::nullopt });
4459         return;
4460     }
4461 
4462     clearViewportSizeOverrideForCSSViewportUnits();
4463     // Since autosize mode forces the scrollbar mode, change them to being auto.
4464     setVerticalScrollbarLock(false);
4465     setHorizontalScrollbarLock(false);
4466     setScrollbarModes(ScrollbarAuto, ScrollbarAuto);
4467 }
4468 
4469 void FrameView::forceLayout(bool allowSubtreeLayout)
4470 {
4471     if (!allowSubtreeLayout &amp;&amp; layoutContext().subtreeLayoutRoot())
4472         layoutContext().convertSubtreeLayoutToFullLayout();
4473     layoutContext().layout();
4474 }
4475 
4476 void FrameView::forceLayoutForPagination(const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkFactor, AdjustViewSizeOrNot shouldAdjustViewSize)
4477 {
4478     if (!renderView())
4479         return;
4480 
4481     Ref&lt;FrameView&gt; protectedThis(*this);
4482     auto&amp; renderView = *this-&gt;renderView();
4483 
4484     // Dumping externalRepresentation(frame().renderer()).ascii() is a good trick to see
4485     // the state of things before and after the layout
4486     float pageLogicalWidth = renderView.style().isHorizontalWritingMode() ? pageSize.width() : pageSize.height();
4487     float pageLogicalHeight = renderView.style().isHorizontalWritingMode() ? pageSize.height() : pageSize.width();
4488 
4489     renderView.setPageLogicalSize({ floor(pageLogicalWidth), floor(pageLogicalHeight) });
4490     renderView.setNeedsLayoutAndPrefWidthsRecalc();
4491     forceLayout();
4492     if (hasOneRef())
4493         return;
4494 
4495     // If we don&#39;t fit in the given page width, we&#39;ll lay out again. If we don&#39;t fit in the
4496     // page width when shrunk, we will lay out at maximum shrink and clip extra content.
4497     // FIXME: We are assuming a shrink-to-fit printing implementation. A cropping
4498     // implementation should not do this!
4499     bool horizontalWritingMode = renderView.style().isHorizontalWritingMode();
4500     const LayoutRect&amp; documentRect = renderView.documentRect();
4501     LayoutUnit docLogicalWidth = horizontalWritingMode ? documentRect.width() : documentRect.height();
4502     if (docLogicalWidth &gt; pageLogicalWidth) {
4503         int expectedPageWidth = std::min&lt;float&gt;(documentRect.width(), pageSize.width() * maximumShrinkFactor);
4504         int expectedPageHeight = std::min&lt;float&gt;(documentRect.height(), pageSize.height() * maximumShrinkFactor);
4505         FloatSize maxPageSize = frame().resizePageRectsKeepingRatio(FloatSize(originalPageSize.width(), originalPageSize.height()), FloatSize(expectedPageWidth, expectedPageHeight));
4506         pageLogicalWidth = horizontalWritingMode ? maxPageSize.width() : maxPageSize.height();
4507         pageLogicalHeight = horizontalWritingMode ? maxPageSize.height() : maxPageSize.width();
4508 
4509         renderView.setPageLogicalSize({ floor(pageLogicalWidth), floor(pageLogicalHeight) });
4510         renderView.setNeedsLayoutAndPrefWidthsRecalc();
4511         forceLayout();
4512         if (hasOneRef())
4513             return;
4514 
4515         const LayoutRect&amp; updatedDocumentRect = renderView.documentRect();
4516         LayoutUnit docLogicalHeight = horizontalWritingMode ? updatedDocumentRect.height() : updatedDocumentRect.width();
4517         LayoutUnit docLogicalTop = horizontalWritingMode ? updatedDocumentRect.y() : updatedDocumentRect.x();
4518         LayoutUnit docLogicalRight = horizontalWritingMode ? updatedDocumentRect.maxX() : updatedDocumentRect.maxY();
4519         LayoutUnit clippedLogicalLeft;
4520         if (!renderView.style().isLeftToRightDirection())
4521             clippedLogicalLeft = docLogicalRight - pageLogicalWidth;
4522         LayoutRect overflow { clippedLogicalLeft, docLogicalTop, LayoutUnit(pageLogicalWidth), docLogicalHeight };
4523 
4524         if (!horizontalWritingMode)
4525             overflow = overflow.transposedRect();
4526         renderView.clearLayoutOverflow();
4527         renderView.addLayoutOverflow(overflow); // This is how we clip in case we overflow again.
4528     }
4529 
4530     if (shouldAdjustViewSize)
4531         adjustViewSize();
4532 }
4533 
4534 void FrameView::adjustPageHeightDeprecated(float *newBottom, float oldTop, float oldBottom, float /*bottomLimit*/)
4535 {
4536     RenderView* renderView = this-&gt;renderView();
4537     if (!renderView) {
4538         *newBottom = oldBottom;
4539         return;
4540 
4541     }
4542     // Use a context with painting disabled.
4543     GraphicsContext context(GraphicsContext::PaintInvalidationReasons::None);
4544     renderView-&gt;setTruncatedAt(static_cast&lt;int&gt;(floorf(oldBottom)));
4545     IntRect dirtyRect(0, static_cast&lt;int&gt;(floorf(oldTop)), renderView-&gt;layoutOverflowRect().maxX(), static_cast&lt;int&gt;(ceilf(oldBottom - oldTop)));
4546     renderView-&gt;setPrintRect(dirtyRect);
4547     renderView-&gt;layer()-&gt;paint(context, dirtyRect);
4548     *newBottom = renderView-&gt;bestTruncatedAt();
4549     if (!*newBottom)
4550         *newBottom = oldBottom;
4551     renderView-&gt;setPrintRect(IntRect());
4552 }
4553 
4554 IntRect FrameView::convertFromRendererToContainingView(const RenderElement* renderer, const IntRect&amp; rendererRect) const
4555 {
4556     IntRect rect = snappedIntRect(enclosingLayoutRect(renderer-&gt;localToAbsoluteQuad(FloatRect(rendererRect)).boundingBox()));
4557 
4558     return contentsToView(rect);
4559 }
4560 
4561 IntRect FrameView::convertFromContainingViewToRenderer(const RenderElement* renderer, const IntRect&amp; viewRect) const
4562 {
4563     IntRect rect = viewToContents(viewRect);
4564 
4565     // FIXME: we don&#39;t have a way to map an absolute rect down to a local quad, so just
4566     // move the rect for now.
4567     rect.setLocation(roundedIntPoint(renderer-&gt;absoluteToLocal(rect.location(), UseTransforms)));
4568     return rect;
4569 }
4570 
4571 FloatRect FrameView::convertFromContainingViewToRenderer(const RenderElement* renderer, const FloatRect&amp; viewRect) const
4572 {
4573     FloatRect rect = viewToContents(viewRect);
4574 
4575     return (renderer-&gt;absoluteToLocalQuad(rect)).boundingBox();
4576 }
4577 
4578 IntPoint FrameView::convertFromRendererToContainingView(const RenderElement* renderer, const IntPoint&amp; rendererPoint) const
4579 {
4580     IntPoint point = roundedIntPoint(renderer-&gt;localToAbsolute(rendererPoint, UseTransforms));
4581 
4582     return contentsToView(point);
4583 }
4584 
4585 IntPoint FrameView::convertFromContainingViewToRenderer(const RenderElement* renderer, const IntPoint&amp; viewPoint) const
4586 {
4587     IntPoint point = viewPoint;
4588 
4589     // Convert from FrameView coords into page (&quot;absolute&quot;) coordinates.
4590     if (!delegatesScrolling())
4591         point = viewToContents(point);
4592 
4593     return roundedIntPoint(renderer-&gt;absoluteToLocal(point, UseTransforms));
4594 }
4595 
4596 IntRect FrameView::convertToContainingView(const IntRect&amp; localRect) const
4597 {
4598     if (const ScrollView* parentScrollView = parent()) {
4599         if (is&lt;FrameView&gt;(*parentScrollView)) {
4600             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4601             // Get our renderer in the parent view
4602             RenderWidget* renderer = frame().ownerRenderer();
4603             if (!renderer)
4604                 return localRect;
4605 
4606             auto rect = localRect;
4607             rect.moveBy(roundedIntPoint(renderer-&gt;contentBoxLocation()));
4608             return parentView.convertFromRendererToContainingView(renderer, rect);
4609         }
4610 
4611         return Widget::convertToContainingView(localRect);
4612     }
4613 
4614     return localRect;
4615 }
4616 
4617 IntRect FrameView::convertFromContainingView(const IntRect&amp; parentRect) const
4618 {
4619     if (const ScrollView* parentScrollView = parent()) {
4620         if (is&lt;FrameView&gt;(*parentScrollView)) {
4621             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4622 
4623             // Get our renderer in the parent view
4624             RenderWidget* renderer = frame().ownerRenderer();
4625             if (!renderer)
4626                 return parentRect;
4627 
4628             auto rect = parentView.convertFromContainingViewToRenderer(renderer, parentRect);
4629             rect.moveBy(-roundedIntPoint(renderer-&gt;contentBoxLocation()));
4630             return rect;
4631         }
4632 
4633         return Widget::convertFromContainingView(parentRect);
4634     }
4635 
4636     return parentRect;
4637 }
4638 
4639 FloatRect FrameView::convertFromContainingView(const FloatRect&amp; parentRect) const
4640 {
4641     if (const ScrollView* parentScrollView = parent()) {
4642         if (is&lt;FrameView&gt;(*parentScrollView)) {
4643             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4644 
4645             // Get our renderer in the parent view
4646             RenderWidget* renderer = frame().ownerRenderer();
4647             if (!renderer)
4648                 return parentRect;
4649 
4650             auto rect = parentView.convertFromContainingViewToRenderer(renderer, parentRect);
4651             rect.moveBy(-renderer-&gt;contentBoxLocation());
4652             return rect;
4653         }
4654 
4655         return Widget::convertFromContainingView(parentRect);
4656     }
4657 
4658     return parentRect;
4659 }
4660 
4661 IntPoint FrameView::convertToContainingView(const IntPoint&amp; localPoint) const
4662 {
4663     if (const ScrollView* parentScrollView = parent()) {
4664         if (is&lt;FrameView&gt;(*parentScrollView)) {
4665             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4666 
4667             // Get our renderer in the parent view
4668             RenderWidget* renderer = frame().ownerRenderer();
4669             if (!renderer)
4670                 return localPoint;
4671 
4672             auto point = localPoint;
4673             point.moveBy(roundedIntPoint(renderer-&gt;contentBoxLocation()));
4674             return parentView.convertFromRendererToContainingView(renderer, point);
4675         }
4676 
4677         return Widget::convertToContainingView(localPoint);
4678     }
4679 
4680     return localPoint;
4681 }
4682 
4683 IntPoint FrameView::convertFromContainingView(const IntPoint&amp; parentPoint) const
4684 {
4685     if (const ScrollView* parentScrollView = parent()) {
4686         if (is&lt;FrameView&gt;(*parentScrollView)) {
4687             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4688 
4689             // Get our renderer in the parent view
4690             RenderWidget* renderer = frame().ownerRenderer();
4691             if (!renderer)
4692                 return parentPoint;
4693 
4694             auto point = parentView.convertFromContainingViewToRenderer(renderer, parentPoint);
4695             point.moveBy(-roundedIntPoint(renderer-&gt;contentBoxLocation()));
4696             return point;
4697         }
4698 
4699         return Widget::convertFromContainingView(parentPoint);
4700     }
4701 
4702     return parentPoint;
4703 }
4704 
4705 float FrameView::documentToAbsoluteScaleFactor(Optional&lt;float&gt; effectiveZoom) const
4706 {
4707     // If effectiveZoom is passed, it already factors in pageZoomFactor().
4708     return effectiveZoom.valueOr(frame().pageZoomFactor()) * frame().frameScaleFactor();
4709 }
4710 
4711 float FrameView::absoluteToDocumentScaleFactor(Optional&lt;float&gt; effectiveZoom) const
4712 {
4713     // If effectiveZoom is passed, it already factors in pageZoomFactor().
4714     return 1 / documentToAbsoluteScaleFactor(effectiveZoom);
4715 }
4716 
4717 FloatRect FrameView::absoluteToDocumentRect(FloatRect rect, Optional&lt;float&gt; effectiveZoom) const
4718 {
4719     rect.scale(absoluteToDocumentScaleFactor(effectiveZoom));
4720     return rect;
4721 }
4722 
4723 FloatPoint FrameView::absoluteToDocumentPoint(FloatPoint p, Optional&lt;float&gt; effectiveZoom) const
4724 {
4725     return p.scaled(absoluteToDocumentScaleFactor(effectiveZoom));
4726 }
4727 
4728 FloatRect FrameView::absoluteToClientRect(FloatRect rect, Optional&lt;float&gt; effectiveZoom) const
4729 {
4730     return documentToClientRect(absoluteToDocumentRect(rect, effectiveZoom));
4731 }
4732 
4733 FloatSize FrameView::documentToClientOffset() const
4734 {
4735     FloatSize clientOrigin = -toFloatSize(visibleContentRect().location());
4736 
4737     // Layout and visual viewports are affected by page zoom, so we need to factor that out.
4738     return clientOrigin.scaled(1 / (frame().pageZoomFactor() * frame().frameScaleFactor()));
4739 }
4740 
4741 FloatRect FrameView::documentToClientRect(FloatRect rect) const
4742 {
4743     rect.move(documentToClientOffset());
4744     return rect;
4745 }
4746 
4747 FloatPoint FrameView::documentToClientPoint(FloatPoint p) const
4748 {
4749     p.move(documentToClientOffset());
4750     return p;
4751 }
4752 
4753 FloatRect FrameView::clientToDocumentRect(FloatRect rect) const
4754 {
4755     rect.move(-documentToClientOffset());
4756     return rect;
4757 }
4758 
4759 FloatPoint FrameView::clientToDocumentPoint(FloatPoint point) const
4760 {
4761     point.move(-documentToClientOffset());
4762     return point;
4763 }
4764 
4765 FloatPoint FrameView::absoluteToLayoutViewportPoint(FloatPoint p) const
4766 {
4767     ASSERT(frame().settings().visualViewportEnabled());
4768     p.scale(1 / frame().frameScaleFactor());
4769     p.moveBy(-layoutViewportRect().location());
4770     return p;
4771 }
4772 
4773 FloatPoint FrameView::layoutViewportToAbsolutePoint(FloatPoint p) const
4774 {
4775     ASSERT(frame().settings().visualViewportEnabled());
4776     p.moveBy(layoutViewportRect().location());
4777     return p.scaled(frame().frameScaleFactor());
4778 }
4779 
4780 FloatRect FrameView::layoutViewportToAbsoluteRect(FloatRect rect) const
4781 {
4782     ASSERT(frame().settings().visualViewportEnabled());
4783     rect.moveBy(layoutViewportRect().location());
4784     rect.scale(frame().frameScaleFactor());
4785     return rect;
4786 }
4787 
4788 FloatRect FrameView::absoluteToLayoutViewportRect(FloatRect rect) const
4789 {
4790     ASSERT(frame().settings().visualViewportEnabled());
4791     rect.scale(1 / frame().frameScaleFactor());
4792     rect.moveBy(-layoutViewportRect().location());
4793     return rect;
4794 }
4795 
4796 FloatRect FrameView::clientToLayoutViewportRect(FloatRect rect) const
4797 {
4798     ASSERT(frame().settings().visualViewportEnabled());
4799     rect.scale(frame().pageZoomFactor());
4800     return rect;
4801 }
4802 
4803 FloatPoint FrameView::clientToLayoutViewportPoint(FloatPoint p) const
4804 {
4805     ASSERT(frame().settings().visualViewportEnabled());
4806     return p.scaled(frame().pageZoomFactor());
4807 }
4808 
4809 void FrameView::setTracksRepaints(bool trackRepaints)
4810 {
4811     if (trackRepaints == m_isTrackingRepaints)
4812         return;
4813 
4814     // Force layout to flush out any pending repaints.
4815     if (trackRepaints) {
4816         if (frame().document())
4817             frame().document()-&gt;updateLayout();
4818     }
4819 
4820     for (Frame* frame = &amp;m_frame-&gt;tree().top(); frame; frame = frame-&gt;tree().traverseNext()) {
4821         if (RenderView* renderView = frame-&gt;contentRenderer())
4822             renderView-&gt;compositor().setTracksRepaints(trackRepaints);
4823     }
4824 
4825     resetTrackedRepaints();
4826     m_isTrackingRepaints = trackRepaints;
4827 }
4828 
4829 void FrameView::resetTrackedRepaints()
4830 {
4831     m_trackedRepaintRects.clear();
4832     if (RenderView* renderView = this-&gt;renderView())
4833         renderView-&gt;compositor().resetTrackedRepaintRects();
4834 }
4835 
4836 String FrameView::trackedRepaintRectsAsText() const
4837 {
4838     Frame&amp; frame = this-&gt;frame();
4839     Ref&lt;Frame&gt; protector(frame);
4840 
4841     if (auto* document = frame.document())
4842         document-&gt;updateLayout();
4843 
4844     TextStream ts;
4845     if (!m_trackedRepaintRects.isEmpty()) {
4846         ts &lt;&lt; &quot;(repaint rects\n&quot;;
4847         for (auto&amp; rect : m_trackedRepaintRects)
4848             ts &lt;&lt; &quot;  (rect &quot; &lt;&lt; LayoutUnit(rect.x()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.y()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.width()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.height()) &lt;&lt; &quot;)\n&quot;;
4849         ts &lt;&lt; &quot;)\n&quot;;
4850     }
4851     return ts.release();
4852 }
4853 
4854 bool FrameView::addScrollableArea(ScrollableArea* scrollableArea)
4855 {
4856     if (!m_scrollableAreas)
4857         m_scrollableAreas = makeUnique&lt;ScrollableAreaSet&gt;();
4858 
4859     if (m_scrollableAreas-&gt;add(scrollableArea).isNewEntry) {
4860         scrollableAreaSetChanged();
4861         return true;
4862     }
4863 
4864     return false;
4865 }
4866 
4867 bool FrameView::removeScrollableArea(ScrollableArea* scrollableArea)
4868 {
4869     if (m_scrollableAreas &amp;&amp; m_scrollableAreas-&gt;remove(scrollableArea)) {
4870         scrollableAreaSetChanged();
4871         return true;
4872     }
4873     return false;
4874 }
4875 
4876 bool FrameView::containsScrollableArea(ScrollableArea* scrollableArea) const
4877 {
4878     return m_scrollableAreas &amp;&amp; m_scrollableAreas-&gt;contains(scrollableArea);
4879 }
4880 
4881 void FrameView::scrollableAreaSetChanged()
4882 {
4883     if (auto* page = frame().page()) {
4884         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
4885             scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*this);
4886     }
4887 }
4888 
4889 void FrameView::sendScrollEvent()
4890 {
4891     frame().eventHandler().sendScrollEvent();
4892     frame().eventHandler().dispatchFakeMouseMoveEventSoon();
4893 }
4894 
4895 void FrameView::addChild(Widget&amp; widget)
4896 {
4897     if (is&lt;FrameView&gt;(widget)) {
4898         auto&amp; childFrameView = downcast&lt;FrameView&gt;(widget);
4899         if (childFrameView.isScrollable())
4900             addScrollableArea(&amp;childFrameView);
4901     }
4902 
4903     ScrollView::addChild(widget);
4904 }
4905 
4906 void FrameView::removeChild(Widget&amp; widget)
4907 {
4908     if (is&lt;FrameView&gt;(widget))
4909         removeScrollableArea(&amp;downcast&lt;FrameView&gt;(widget));
4910 
4911     ScrollView::removeChild(widget);
4912 }
4913 
4914 bool FrameView::wheelEvent(const PlatformWheelEvent&amp; wheelEvent)
4915 {
4916     // Note that to allow for rubber-band over-scroll behavior, even non-scrollable views
4917     // should handle wheel events.
4918 #if !ENABLE(RUBBER_BANDING)
4919     if (!isScrollable())
4920         return false;
4921 #endif
4922 
4923     if (delegatesScrolling()) {
4924         ScrollPosition oldPosition = scrollPosition();
4925         ScrollPosition newPosition = oldPosition - IntSize(wheelEvent.deltaX(), wheelEvent.deltaY());
4926         if (oldPosition != newPosition) {
4927             ScrollView::scrollTo(newPosition);
4928             scrollPositionChanged(oldPosition, scrollPosition());
4929             didChangeScrollOffset();
4930         }
4931         return true;
4932     }
4933 
4934     // We don&#39;t allow mouse wheeling to happen in a ScrollView that has had its scrollbars explicitly disabled.
4935     if (!canHaveScrollbars())
4936         return false;
4937 
4938     if (platformWidget())
4939         return false;
4940 
4941 #if ENABLE(ASYNC_SCROLLING)
4942     if (Page* page = frame().page()) {
4943         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator()) {
4944             if (scrollingCoordinator-&gt;coordinatesScrollingForFrameView(*this))
4945                 return scrollingCoordinator-&gt;handleWheelEvent(*this, wheelEvent) != ScrollingEventResult::DidNotHandleEvent;
4946         }
4947     }
4948 #endif
4949 
4950     return ScrollableArea::handleWheelEvent(wheelEvent);
4951 }
4952 
4953 
4954 bool FrameView::isVerticalDocument() const
4955 {
4956     RenderView* renderView = this-&gt;renderView();
4957     if (!renderView)
4958         return true;
4959 
4960     return renderView-&gt;style().isHorizontalWritingMode();
4961 }
4962 
4963 bool FrameView::isFlippedDocument() const
4964 {
4965     RenderView* renderView = this-&gt;renderView();
4966     if (!renderView)
4967         return false;
4968 
4969     return renderView-&gt;style().isFlippedBlocksWritingMode();
4970 }
4971 
4972 void FrameView::notifyWidgetsInAllFrames(WidgetNotification notification)
4973 {
4974     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
4975         if (FrameView* view = frame-&gt;view())
4976             view-&gt;notifyWidgets(notification);
4977     }
4978 }
4979 
4980 AXObjectCache* FrameView::axObjectCache() const
4981 {
4982     if (frame().document())
4983         return frame().document()-&gt;existingAXObjectCache();
4984     return nullptr;
4985 }
4986 
4987 #if PLATFORM(IOS_FAMILY)
4988 bool FrameView::useCustomFixedPositionLayoutRect() const
4989 {
4990     return !frame().settings().visualViewportEnabled() &amp;&amp; m_useCustomFixedPositionLayoutRect;
4991 }
4992 
4993 void FrameView::setCustomFixedPositionLayoutRect(const IntRect&amp; rect)
4994 {
4995     if (m_useCustomFixedPositionLayoutRect &amp;&amp; m_customFixedPositionLayoutRect == rect)
4996         return;
4997     m_useCustomFixedPositionLayoutRect = true;
4998     m_customFixedPositionLayoutRect = rect;
4999     updateContentsSize();
5000 }
5001 
5002 bool FrameView::updateFixedPositionLayoutRect()
5003 {
5004     if (!m_useCustomFixedPositionLayoutRect)
5005         return false;
5006 
5007     IntRect newRect;
5008     Page* page = frame().page();
5009     if (!page || !page-&gt;chrome().client().fetchCustomFixedPositionLayoutRect(newRect))
5010         return false;
5011 
5012     if (newRect != m_customFixedPositionLayoutRect) {
5013         m_customFixedPositionLayoutRect = newRect;
5014         setViewportConstrainedObjectsNeedLayout();
5015         return true;
5016     }
5017     return false;
5018 }
5019 
5020 void FrameView::setCustomSizeForResizeEvent(IntSize customSize)
5021 {
5022     m_useCustomSizeForResizeEvent = true;
5023     m_customSizeForResizeEvent = customSize;
5024     sendResizeEventIfNeeded();
5025 }
5026 
5027 void FrameView::setScrollVelocity(const VelocityData&amp; velocityData)
5028 {
5029     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
5030         tiledBacking-&gt;setVelocity(velocityData);
5031 }
5032 #endif // PLATFORM(IOS_FAMILY)
5033 
5034 void FrameView::setScrollingPerformanceLoggingEnabled(bool flag)
5035 {
5036     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
5037         tiledBacking-&gt;setScrollingPerformanceLoggingEnabled(flag);
5038 }
5039 
5040 void FrameView::didAddScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
5041 {
5042     ScrollableArea::didAddScrollbar(scrollbar, orientation);
5043     Page* page = frame().page();
5044     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())
5045         scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());
5046     if (AXObjectCache* cache = axObjectCache())
5047         cache-&gt;handleScrollbarUpdate(this);
5048 }
5049 
5050 void FrameView::willRemoveScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
5051 {
5052     ScrollableArea::willRemoveScrollbar(scrollbar, orientation);
5053     if (AXObjectCache* cache = axObjectCache()) {
5054         cache-&gt;remove(scrollbar);
5055         cache-&gt;handleScrollbarUpdate(this);
5056     }
5057 }
5058 
5059 void FrameView::addPaintPendingMilestones(OptionSet&lt;LayoutMilestone&gt; milestones)
5060 {
5061     m_milestonesPendingPaint.add(milestones);
5062 }
5063 
5064 void FrameView::fireLayoutRelatedMilestonesIfNeeded()
5065 {
5066     OptionSet&lt;LayoutMilestone&gt; requestedMilestones;
5067     OptionSet&lt;LayoutMilestone&gt; milestonesAchieved;
5068     Page* page = frame().page();
5069     if (page)
5070         requestedMilestones = page-&gt;requestedLayoutMilestones();
5071 
5072     if (m_firstLayoutCallbackPending) {
5073         m_firstLayoutCallbackPending = false;
5074         frame().loader().didFirstLayout();
5075         if (requestedMilestones &amp; DidFirstLayout)
5076             milestonesAchieved.add(DidFirstLayout);
5077         if (frame().isMainFrame())
5078             page-&gt;startCountingRelevantRepaintedObjects();
5079     }
5080 
5081     if (!m_isVisuallyNonEmpty &amp;&amp; qualifiesAsVisuallyNonEmpty()) {
5082         m_isVisuallyNonEmpty = true;
5083         addPaintPendingMilestones(DidFirstMeaningfulPaint);
5084         if (requestedMilestones &amp; DidFirstVisuallyNonEmptyLayout)
5085             milestonesAchieved.add(DidFirstVisuallyNonEmptyLayout);
5086     }
5087 
5088     if (!m_renderedSignificantAmountOfText &amp;&amp; qualifiesAsSignificantRenderedText()) {
5089         m_renderedSignificantAmountOfText = true;
5090         if (requestedMilestones &amp; DidRenderSignificantAmountOfText)
5091             milestonesAchieved.add(DidRenderSignificantAmountOfText);
5092     }
5093 
5094     if (milestonesAchieved &amp;&amp; frame().isMainFrame()) {
5095         if (milestonesAchieved.contains(DidFirstVisuallyNonEmptyLayout))
5096             RELEASE_LOG_IF_ALLOWED(&quot;fireLayoutRelatedMilestonesIfNeeded() - firing first visually non-empty layout milestone on the main frame&quot;);
5097         frame().loader().didReachLayoutMilestone(milestonesAchieved);
5098     }
5099 }
5100 
5101 void FrameView::firePaintRelatedMilestonesIfNeeded()
5102 {
5103     Page* page = frame().page();
5104     if (!page)
5105         return;
5106 
5107     OptionSet&lt;LayoutMilestone&gt; milestonesAchieved;
5108 
5109     // Make sure the pending paint milestones have actually been requested before we send them.
5110     if (m_milestonesPendingPaint &amp; DidFirstFlushForHeaderLayer) {
5111         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstFlushForHeaderLayer)
5112             milestonesAchieved.add(DidFirstFlushForHeaderLayer);
5113     }
5114 
5115     if (m_milestonesPendingPaint &amp; DidFirstPaintAfterSuppressedIncrementalRendering) {
5116         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstPaintAfterSuppressedIncrementalRendering)
5117             milestonesAchieved.add(DidFirstPaintAfterSuppressedIncrementalRendering);
5118     }
5119 
5120     if (m_milestonesPendingPaint &amp; DidFirstMeaningfulPaint) {
5121         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstMeaningfulPaint)
5122             milestonesAchieved.add(DidFirstMeaningfulPaint);
5123     }
5124 
5125     m_milestonesPendingPaint = { };
5126 
5127     if (milestonesAchieved)
5128         page-&gt;mainFrame().loader().didReachLayoutMilestone(milestonesAchieved);
5129 }
5130 
5131 void FrameView::setVisualUpdatesAllowedByClient(bool visualUpdatesAllowed)
5132 {
5133     if (m_visualUpdatesAllowedByClient == visualUpdatesAllowed)
5134         return;
5135 
5136     m_visualUpdatesAllowedByClient = visualUpdatesAllowed;
5137 
5138     frame().document()-&gt;setVisualUpdatesAllowedByClient(visualUpdatesAllowed);
5139 }
5140 
5141 void FrameView::setScrollPinningBehavior(ScrollPinningBehavior pinning)
5142 {
5143     m_scrollPinningBehavior = pinning;
5144 
5145     if (Page* page = frame().page()) {
5146         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
5147             scrollingCoordinator-&gt;setScrollPinningBehavior(pinning);
5148     }
5149 
5150     updateScrollbars(scrollPosition());
5151 }
5152 
5153 ScrollBehaviorForFixedElements FrameView::scrollBehaviorForFixedElements() const
5154 {
5155     return frame().settings().backgroundShouldExtendBeyondPage() ? StickToViewportBounds : StickToDocumentBounds;
5156 }
5157 
5158 RenderView* FrameView::renderView() const
5159 {
5160     return frame().contentRenderer();
5161 }
5162 
5163 int FrameView::mapFromLayoutToCSSUnits(LayoutUnit value) const
5164 {
5165     return value / (frame().pageZoomFactor() * frame().frameScaleFactor());
5166 }
5167 
5168 LayoutUnit FrameView::mapFromCSSToLayoutUnits(int value) const
5169 {
5170     return LayoutUnit(value * frame().pageZoomFactor() * frame().frameScaleFactor());
5171 }
5172 
5173 void FrameView::didAddWidgetToRenderTree(Widget&amp; widget)
5174 {
5175     ASSERT(!m_widgetsInRenderTree.contains(&amp;widget));
5176     m_widgetsInRenderTree.add(&amp;widget);
5177 }
5178 
5179 void FrameView::willRemoveWidgetFromRenderTree(Widget&amp; widget)
5180 {
5181     ASSERT(m_widgetsInRenderTree.contains(&amp;widget));
5182     m_widgetsInRenderTree.remove(&amp;widget);
5183 }
5184 
5185 static Vector&lt;RefPtr&lt;Widget&gt;&gt; collectAndProtectWidgets(const HashSet&lt;Widget*&gt;&amp; set)
5186 {
5187     return copyToVectorOf&lt;RefPtr&lt;Widget&gt;&gt;(set);
5188 }
5189 
5190 void FrameView::updateWidgetPositions()
5191 {
5192     m_updateWidgetPositionsTimer.stop();
5193     // updateWidgetPosition() can possibly cause layout to be re-entered (via plug-ins running
5194     // scripts in response to NPP_SetWindow, for example), so we need to keep the Widgets
5195     // alive during enumeration.
5196     for (auto&amp; widget : collectAndProtectWidgets(m_widgetsInRenderTree)) {
5197         if (auto* renderer = RenderWidget::find(*widget)) {
5198             auto ignoreWidgetState = renderer-&gt;updateWidgetPosition();
5199             UNUSED_PARAM(ignoreWidgetState);
5200         }
5201     }
5202 }
5203 
5204 void FrameView::scheduleUpdateWidgetPositions()
5205 {
5206     if (!m_updateWidgetPositionsTimer.isActive())
5207         m_updateWidgetPositionsTimer.startOneShot(0_s);
5208 }
5209 
5210 void FrameView::updateWidgetPositionsTimerFired()
5211 {
5212     updateWidgetPositions();
5213 }
5214 
5215 void FrameView::notifyWidgets(WidgetNotification notification)
5216 {
5217     for (auto&amp; widget : collectAndProtectWidgets(m_widgetsInRenderTree))
5218         widget-&gt;notifyWidget(notification);
5219 }
5220 
5221 void FrameView::setViewExposedRect(Optional&lt;FloatRect&gt; viewExposedRect)
5222 {
5223     if (m_viewExposedRect == viewExposedRect)
5224         return;
5225 
5226     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; setViewExposedRect &quot; &lt;&lt; (viewExposedRect ? viewExposedRect.value() : FloatRect()));
5227 
5228     bool hasRectChanged = !m_viewExposedRect == !viewExposedRect;
5229     m_viewExposedRect = viewExposedRect;
5230 
5231     // FIXME: We should support clipping to the exposed rect for subframes as well.
5232     if (!frame().isMainFrame())
5233         return;
5234 
5235     if (TiledBacking* tiledBacking = this-&gt;tiledBacking()) {
5236         if (hasRectChanged)
5237             updateTiledBackingAdaptiveSizing();
5238         adjustTiledBackingCoverage();
5239         tiledBacking-&gt;setTiledScrollingIndicatorPosition(m_viewExposedRect ? m_viewExposedRect.value().location() : FloatPoint());
5240     }
5241 
5242     if (auto* view = renderView())
5243         view-&gt;compositor().scheduleLayerFlush(false /* canThrottle */);
5244 
5245     if (auto* page = frame().page())
5246         page-&gt;pageOverlayController().didChangeViewExposedRect();
5247 }
5248 
5249 void FrameView::clearViewportSizeOverrideForCSSViewportUnits()
5250 {
5251     if (!m_overrideViewportSize)
5252         return;
5253 
5254     m_overrideViewportSize = WTF::nullopt;
5255     if (auto* document = frame().document())
5256         document-&gt;styleScope().didChangeStyleSheetEnvironment();
5257 }
5258 
5259 void FrameView::setViewportSizeForCSSViewportUnits(IntSize size)
5260 {
5261     overrideViewportSizeForCSSViewportUnits({ size.width(), size.height() });
5262 }
5263 
5264 void FrameView::overrideViewportSizeForCSSViewportUnits(OverrideViewportSize size)
5265 {
5266     if (m_overrideViewportSize &amp;&amp; *m_overrideViewportSize == size)
5267         return;
5268 
5269     m_overrideViewportSize = size;
5270 
5271     if (auto* document = frame().document())
5272         document-&gt;styleScope().didChangeStyleSheetEnvironment();
5273 }
5274 
5275 IntSize FrameView::viewportSizeForCSSViewportUnits() const
5276 {
5277     OverrideViewportSize viewportSize;
5278 
5279     if (m_overrideViewportSize) {
5280         viewportSize = *m_overrideViewportSize;
5281         // auto-size overrides the width only, so we can&#39;t always bail out early here.
5282         if (viewportSize.width &amp;&amp; viewportSize.height)
5283             return { *viewportSize.width, *viewportSize.height };
5284     }
5285 
5286     if (useFixedLayout()) {
5287         auto fixedLayoutSize = this-&gt;fixedLayoutSize();
5288         viewportSize.width = viewportSize.width.valueOr(fixedLayoutSize.width());
5289         viewportSize.height = viewportSize.height.valueOr(fixedLayoutSize.height());
5290         return { *viewportSize.width, *viewportSize.height };
5291     }
5292 
5293     // FIXME: the value returned should take into account the value of the overflow
5294     // property on the root element.
5295     auto visibleContentSizeIncludingScrollbars = visibleContentRectIncludingScrollbars().size();
5296     viewportSize.width = viewportSize.width.valueOr(visibleContentSizeIncludingScrollbars.width());
5297     viewportSize.height = viewportSize.height.valueOr(visibleContentSizeIncludingScrollbars.height());
5298     return { *viewportSize.width, *viewportSize.height };
5299 }
5300 
5301 bool FrameView::shouldPlaceBlockDirectionScrollbarOnLeft() const
5302 {
5303     return renderView() &amp;&amp; renderView()-&gt;shouldPlaceBlockDirectionScrollbarOnLeft();
5304 }
5305 
5306 } // namespace WebCore
    </pre>
  </body>
</html>