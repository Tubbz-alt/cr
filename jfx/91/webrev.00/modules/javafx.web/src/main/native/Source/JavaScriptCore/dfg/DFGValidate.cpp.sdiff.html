<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGUseKind.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGValueSource.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 240                     case UntypedUse:
 241                     case CellUse:
 242                     case KnownCellUse:
 243                     case Int32Use:
 244                     case KnownInt32Use:
 245                     case Int52RepUse:
 246                     case DoubleRepUse:
 247                     case BooleanUse:
 248                     case KnownBooleanUse:
 249                         break;
 250                     default:
 251                         VALIDATE((node), !&quot;Bad use kind&quot;);
 252                         break;
 253                     }
 254                     break;
 255                 case MakeRope:
 256                 case ValueAdd:
 257                 case ValueSub:
 258                 case ValueMul:
 259                 case ValueDiv:


 260                 case ArithAdd:
 261                 case ArithSub:
 262                 case ArithMul:
 263                 case ArithIMul:
 264                 case ArithDiv:
 265                 case ArithMod:
 266                 case ArithMin:
 267                 case ArithMax:
 268                 case ArithPow:
 269                 case CompareLess:
 270                 case CompareLessEq:
 271                 case CompareGreater:
 272                 case CompareGreaterEq:
 273                 case CompareBelow:
 274                 case CompareBelowEq:
 275                 case CompareEq:
 276                 case CompareStrictEq:
 277                 case SameValue:
 278                 case StrCat:
 279                     VALIDATE((node), !!node-&gt;child1());
</pre>
<hr />
<pre>
 476                 }
 477             }
 478 
 479             for (size_t i = 0; i &lt; block-&gt;phis.size(); ++i) {
 480                 Node* node = block-&gt;phis[i];
 481                 ASSERT(phisInThisBlock.contains(node));
 482                 VALIDATE((node), node-&gt;op() == Phi);
 483                 VirtualRegister local = node-&gt;local();
 484                 for (unsigned j = 0; j &lt; m_graph.numChildren(node); ++j) {
 485                     // Phi children in LoadStore form are invalid.
 486                     if (m_graph.m_form == LoadStore &amp;&amp; block-&gt;isPhiIndex(i))
 487                         continue;
 488 
 489                     Edge edge = m_graph.child(node, j);
 490                     if (!edge)
 491                         continue;
 492 
 493                     VALIDATE(
 494                         (node, edge),
 495                         edge-&gt;op() == SetLocal
<span class="line-modified"> 496                         || edge-&gt;op() == SetArgument</span>
<span class="line-modified"> 497                         || edge-&gt;op() == Flush</span>
 498                         || edge-&gt;op() == Phi);
 499 
 500                     if (phisInThisBlock.contains(edge.node()))
 501                         continue;
 502 
 503                     if (nodesInThisBlock.contains(edge.node())) {
 504                         VALIDATE(
 505                             (node, edge),
 506                             edge-&gt;op() == SetLocal
<span class="line-modified"> 507                             || edge-&gt;op() == SetArgument</span>
<span class="line-modified"> 508                             || edge-&gt;op() == Flush);</span>
 509 
 510                         continue;
 511                     }
 512 
 513                     // There must exist a predecessor block that has this node index in
 514                     // its tail variables.
 515                     bool found = false;
 516                     for (unsigned k = 0; k &lt; block-&gt;predecessors.size(); ++k) {
 517                         BasicBlock* prevBlock = block-&gt;predecessors[k];
 518                         VALIDATE((block-&gt;predecessors[k]), prevBlock);
 519                         Node* prevNode = prevBlock-&gt;variablesAtTail.operand(local);
 520                         // If we have a Phi that is not referring to *this* block then all predecessors
 521                         // must have that local available.
 522                         VALIDATE((local, block, block-&gt;predecessors[k]), prevNode);
 523                         switch (prevNode-&gt;op()) {
 524                         case GetLocal:
 525                         case Flush:
 526                         case PhantomLocal:
 527                             prevNode = prevNode-&gt;child1().node();
 528                             break;
 529                         default:
 530                             break;
 531                         }
 532                         if (node-&gt;shouldGenerate()) {
 533                             VALIDATE((local, block-&gt;predecessors[k], prevNode),
 534                                      prevNode-&gt;shouldGenerate());
 535                         }
 536                         VALIDATE(
 537                             (local, block-&gt;predecessors[k], prevNode),
 538                             prevNode-&gt;op() == SetLocal
<span class="line-modified"> 539                             || prevNode-&gt;op() == SetArgument</span>

 540                             || prevNode-&gt;op() == Phi);
 541                         if (prevNode == edge.node()) {
 542                             found = true;
 543                             break;
 544                         }
 545                         // At this point it cannot refer into this block.
 546                         VALIDATE((local, block-&gt;predecessors[k], prevNode), !prevBlock-&gt;isInBlock(edge.node()));
 547                     }
 548 
 549                     VALIDATE((node, edge), found);
 550                 }
 551             }
 552 
 553             Operands&lt;size_t&gt; getLocalPositions(
 554                 block-&gt;variablesAtHead.numberOfArguments(),
 555                 block-&gt;variablesAtHead.numberOfLocals());
 556             Operands&lt;size_t&gt; setLocalPositions(
 557                 block-&gt;variablesAtHead.numberOfArguments(),
 558                 block-&gt;variablesAtHead.numberOfLocals());
 559 
</pre>
<hr />
<pre>
 649                     break;
 650                 }
 651                 case Phantom:
 652                     VALIDATE((node), m_graph.m_fixpointState != FixpointNotConverged);
 653                     break;
 654                 default:
 655                     break;
 656                 }
 657 
 658                 if (!node-&gt;shouldGenerate())
 659                     continue;
 660                 switch (node-&gt;op()) {
 661                 case GetLocal:
 662                     // Ignore GetLocal&#39;s that we know to be dead, but that the graph
 663                     // doesn&#39;t yet know to be dead.
 664                     if (!m_myRefCounts.get(node))
 665                         break;
 666                     if (m_graph.m_form == ThreadedCPS) {
 667                         VALIDATE((node, block), getLocalPositions.operand(node-&gt;local()) == notSet);
 668                         VALIDATE((node, block), !!node-&gt;child1());

 669                     }
 670                     getLocalPositions.operand(node-&gt;local()) = i;
 671                     break;
 672                 case SetLocal:
 673                     // Only record the first SetLocal. There may be multiple SetLocals
 674                     // because of flushing.
 675                     if (setLocalPositions.operand(node-&gt;local()) != notSet)
 676                         break;
 677                     setLocalPositions.operand(node-&gt;local()) = i;
 678                     break;
<span class="line-modified"> 679                 case SetArgument:</span>
 680                     // This acts like a reset. It&#39;s ok to have a second GetLocal for a local in the same
<span class="line-modified"> 681                     // block if we had a SetArgument for that local.</span>
 682                     getLocalPositions.operand(node-&gt;local()) = notSet;
 683                     setLocalPositions.operand(node-&gt;local()) = notSet;
 684                     break;














 685                 default:
 686                     break;
 687                 }
 688             }
 689 
 690             if (m_graph.m_form == LoadStore)
 691                 continue;
 692 
 693             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfArguments(); ++i) {
 694                 checkOperand(
 695                     block, getLocalPositions, setLocalPositions, virtualRegisterForArgument(i));
 696             }
 697             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfLocals(); ++i) {
 698                 checkOperand(
 699                     block, getLocalPositions, setLocalPositions, virtualRegisterForLocal(i));
 700             }
 701         }














































 702     }
 703 
 704     void validateSSA()
 705     {
 706         // FIXME: Add more things here.
 707         // https://bugs.webkit.org/show_bug.cgi?id=123471
 708 
 709         VALIDATE((), m_graph.m_roots.size() == 1);
 710         VALIDATE((), m_graph.m_roots[0] == m_graph.block(0));
 711         VALIDATE((), !m_graph.m_argumentFormats.isEmpty()); // We always have at least one entrypoint.
 712         VALIDATE((), m_graph.m_rootToArguments.isEmpty()); // This is only used in CPS.
 713 
 714         for (unsigned entrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeOffset.keys())
 715             VALIDATE((), entrypointIndex &gt; 0); // By convention, 0 is the entrypoint index for the op_enter entrypoint, which can not be in a catch.
 716 
 717         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 718             BasicBlock* block = m_graph.block(blockIndex);
 719             if (!block)
 720                 continue;
 721 
 722             VALIDATE((block), block-&gt;phis.isEmpty());
 723 
 724             bool didSeeExitOK = false;
 725             bool isOSRExited = false;
 726 
 727             for (auto* node : *block) {
 728                 didSeeExitOK |= node-&gt;origin.exitOK;
 729                 switch (node-&gt;op()) {
 730                 case Phi:
 731                     // Phi cannot exit, and it would be wrong to hoist anything to the Phi that could
 732                     // exit.
 733                     VALIDATE((node), !node-&gt;origin.exitOK);
 734 
 735                     // It never makes sense to have exitOK anywhere in the block before a Phi. It&#39;s only
 736                     // OK to exit after all Phis are done.
 737                     VALIDATE((node), !didSeeExitOK);
 738                     break;
 739 
 740                 case GetLocal:
 741                 case SetLocal:
<span class="line-modified"> 742                 case SetArgument:</span>

 743                 case Phantom:
 744                     VALIDATE((node), !&quot;bad node type for SSA&quot;);
 745                     break;
 746 
 747                 default:
 748                     // FIXME: Add more things here.
 749                     // https://bugs.webkit.org/show_bug.cgi?id=123471
 750                     break;
 751                 }
 752 
 753                 if (isOSRExited)
 754                     continue;
 755                 switch (node-&gt;op()) {
 756                 case PhantomNewObject:
 757                 case PhantomNewFunction:
 758                 case PhantomNewGeneratorFunction:
 759                 case PhantomNewAsyncFunction:
 760                 case PhantomNewAsyncGeneratorFunction:
 761                 case PhantomCreateActivation:
 762                 case PhantomDirectArguments:
</pre>
</td>
<td>
<hr />
<pre>
 240                     case UntypedUse:
 241                     case CellUse:
 242                     case KnownCellUse:
 243                     case Int32Use:
 244                     case KnownInt32Use:
 245                     case Int52RepUse:
 246                     case DoubleRepUse:
 247                     case BooleanUse:
 248                     case KnownBooleanUse:
 249                         break;
 250                     default:
 251                         VALIDATE((node), !&quot;Bad use kind&quot;);
 252                         break;
 253                     }
 254                     break;
 255                 case MakeRope:
 256                 case ValueAdd:
 257                 case ValueSub:
 258                 case ValueMul:
 259                 case ValueDiv:
<span class="line-added"> 260                 case ValueMod:</span>
<span class="line-added"> 261                 case ValuePow:</span>
 262                 case ArithAdd:
 263                 case ArithSub:
 264                 case ArithMul:
 265                 case ArithIMul:
 266                 case ArithDiv:
 267                 case ArithMod:
 268                 case ArithMin:
 269                 case ArithMax:
 270                 case ArithPow:
 271                 case CompareLess:
 272                 case CompareLessEq:
 273                 case CompareGreater:
 274                 case CompareGreaterEq:
 275                 case CompareBelow:
 276                 case CompareBelowEq:
 277                 case CompareEq:
 278                 case CompareStrictEq:
 279                 case SameValue:
 280                 case StrCat:
 281                     VALIDATE((node), !!node-&gt;child1());
</pre>
<hr />
<pre>
 478                 }
 479             }
 480 
 481             for (size_t i = 0; i &lt; block-&gt;phis.size(); ++i) {
 482                 Node* node = block-&gt;phis[i];
 483                 ASSERT(phisInThisBlock.contains(node));
 484                 VALIDATE((node), node-&gt;op() == Phi);
 485                 VirtualRegister local = node-&gt;local();
 486                 for (unsigned j = 0; j &lt; m_graph.numChildren(node); ++j) {
 487                     // Phi children in LoadStore form are invalid.
 488                     if (m_graph.m_form == LoadStore &amp;&amp; block-&gt;isPhiIndex(i))
 489                         continue;
 490 
 491                     Edge edge = m_graph.child(node, j);
 492                     if (!edge)
 493                         continue;
 494 
 495                     VALIDATE(
 496                         (node, edge),
 497                         edge-&gt;op() == SetLocal
<span class="line-modified"> 498                         || edge-&gt;op() == SetArgumentDefinitely</span>
<span class="line-modified"> 499                         || edge-&gt;op() == SetArgumentMaybe</span>
 500                         || edge-&gt;op() == Phi);
 501 
 502                     if (phisInThisBlock.contains(edge.node()))
 503                         continue;
 504 
 505                     if (nodesInThisBlock.contains(edge.node())) {
 506                         VALIDATE(
 507                             (node, edge),
 508                             edge-&gt;op() == SetLocal
<span class="line-modified"> 509                             || edge-&gt;op() == SetArgumentDefinitely</span>
<span class="line-modified"> 510                             || edge-&gt;op() == SetArgumentMaybe);</span>
 511 
 512                         continue;
 513                     }
 514 
 515                     // There must exist a predecessor block that has this node index in
 516                     // its tail variables.
 517                     bool found = false;
 518                     for (unsigned k = 0; k &lt; block-&gt;predecessors.size(); ++k) {
 519                         BasicBlock* prevBlock = block-&gt;predecessors[k];
 520                         VALIDATE((block-&gt;predecessors[k]), prevBlock);
 521                         Node* prevNode = prevBlock-&gt;variablesAtTail.operand(local);
 522                         // If we have a Phi that is not referring to *this* block then all predecessors
 523                         // must have that local available.
 524                         VALIDATE((local, block, block-&gt;predecessors[k]), prevNode);
 525                         switch (prevNode-&gt;op()) {
 526                         case GetLocal:
 527                         case Flush:
 528                         case PhantomLocal:
 529                             prevNode = prevNode-&gt;child1().node();
 530                             break;
 531                         default:
 532                             break;
 533                         }
 534                         if (node-&gt;shouldGenerate()) {
 535                             VALIDATE((local, block-&gt;predecessors[k], prevNode),
 536                                      prevNode-&gt;shouldGenerate());
 537                         }
 538                         VALIDATE(
 539                             (local, block-&gt;predecessors[k], prevNode),
 540                             prevNode-&gt;op() == SetLocal
<span class="line-modified"> 541                             || prevNode-&gt;op() == SetArgumentDefinitely</span>
<span class="line-added"> 542                             || prevNode-&gt;op() == SetArgumentMaybe</span>
 543                             || prevNode-&gt;op() == Phi);
 544                         if (prevNode == edge.node()) {
 545                             found = true;
 546                             break;
 547                         }
 548                         // At this point it cannot refer into this block.
 549                         VALIDATE((local, block-&gt;predecessors[k], prevNode), !prevBlock-&gt;isInBlock(edge.node()));
 550                     }
 551 
 552                     VALIDATE((node, edge), found);
 553                 }
 554             }
 555 
 556             Operands&lt;size_t&gt; getLocalPositions(
 557                 block-&gt;variablesAtHead.numberOfArguments(),
 558                 block-&gt;variablesAtHead.numberOfLocals());
 559             Operands&lt;size_t&gt; setLocalPositions(
 560                 block-&gt;variablesAtHead.numberOfArguments(),
 561                 block-&gt;variablesAtHead.numberOfLocals());
 562 
</pre>
<hr />
<pre>
 652                     break;
 653                 }
 654                 case Phantom:
 655                     VALIDATE((node), m_graph.m_fixpointState != FixpointNotConverged);
 656                     break;
 657                 default:
 658                     break;
 659                 }
 660 
 661                 if (!node-&gt;shouldGenerate())
 662                     continue;
 663                 switch (node-&gt;op()) {
 664                 case GetLocal:
 665                     // Ignore GetLocal&#39;s that we know to be dead, but that the graph
 666                     // doesn&#39;t yet know to be dead.
 667                     if (!m_myRefCounts.get(node))
 668                         break;
 669                     if (m_graph.m_form == ThreadedCPS) {
 670                         VALIDATE((node, block), getLocalPositions.operand(node-&gt;local()) == notSet);
 671                         VALIDATE((node, block), !!node-&gt;child1());
<span class="line-added"> 672                         VALIDATE((node, block), node-&gt;child1()-&gt;op() == SetArgumentDefinitely || node-&gt;child1()-&gt;op() == Phi);</span>
 673                     }
 674                     getLocalPositions.operand(node-&gt;local()) = i;
 675                     break;
 676                 case SetLocal:
 677                     // Only record the first SetLocal. There may be multiple SetLocals
 678                     // because of flushing.
 679                     if (setLocalPositions.operand(node-&gt;local()) != notSet)
 680                         break;
 681                     setLocalPositions.operand(node-&gt;local()) = i;
 682                     break;
<span class="line-modified"> 683                 case SetArgumentDefinitely:</span>
 684                     // This acts like a reset. It&#39;s ok to have a second GetLocal for a local in the same
<span class="line-modified"> 685                     // block if we had a SetArgumentDefinitely for that local.</span>
 686                     getLocalPositions.operand(node-&gt;local()) = notSet;
 687                     setLocalPositions.operand(node-&gt;local()) = notSet;
 688                     break;
<span class="line-added"> 689                 case SetArgumentMaybe:</span>
<span class="line-added"> 690                     break;</span>
<span class="line-added"> 691                 case Flush:</span>
<span class="line-added"> 692                 case PhantomLocal:</span>
<span class="line-added"> 693                     if (m_graph.m_form == ThreadedCPS) {</span>
<span class="line-added"> 694                         VALIDATE((node, block),</span>
<span class="line-added"> 695                             node-&gt;child1()-&gt;op() == Phi</span>
<span class="line-added"> 696                             || node-&gt;child1()-&gt;op() == SetLocal</span>
<span class="line-added"> 697                             || node-&gt;child1()-&gt;op() == SetArgumentDefinitely</span>
<span class="line-added"> 698                             || node-&gt;child1()-&gt;op() == SetArgumentMaybe);</span>
<span class="line-added"> 699                         if (node-&gt;op() == PhantomLocal)</span>
<span class="line-added"> 700                             VALIDATE((node, block), node-&gt;child1()-&gt;op() != SetArgumentMaybe);</span>
<span class="line-added"> 701                     }</span>
<span class="line-added"> 702                     break;</span>
 703                 default:
 704                     break;
 705                 }
 706             }
 707 
 708             if (m_graph.m_form == LoadStore)
 709                 continue;
 710 
 711             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfArguments(); ++i) {
 712                 checkOperand(
 713                     block, getLocalPositions, setLocalPositions, virtualRegisterForArgument(i));
 714             }
 715             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfLocals(); ++i) {
 716                 checkOperand(
 717                     block, getLocalPositions, setLocalPositions, virtualRegisterForLocal(i));
 718             }
 719         }
<span class="line-added"> 720 </span>
<span class="line-added"> 721         if (m_graph.m_form == ThreadedCPS) {</span>
<span class="line-added"> 722             Vector&lt;Node*&gt; worklist;</span>
<span class="line-added"> 723             HashSet&lt;Node*&gt; seen;</span>
<span class="line-added"> 724             for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {</span>
<span class="line-added"> 725                 for (Node* node : *block) {</span>
<span class="line-added"> 726                     if (node-&gt;op() == GetLocal || node-&gt;op() == PhantomLocal) {</span>
<span class="line-added"> 727                         worklist.append(node);</span>
<span class="line-added"> 728                         auto addResult = seen.add(node);</span>
<span class="line-added"> 729                         VALIDATE((node, block), addResult.isNewEntry);</span>
<span class="line-added"> 730                     }</span>
<span class="line-added"> 731                 }</span>
<span class="line-added"> 732             }</span>
<span class="line-added"> 733 </span>
<span class="line-added"> 734             while (worklist.size()) {</span>
<span class="line-added"> 735                 Node* node = worklist.takeLast();</span>
<span class="line-added"> 736                 switch (node-&gt;op()) {</span>
<span class="line-added"> 737                 case PhantomLocal:</span>
<span class="line-added"> 738                 case GetLocal: {</span>
<span class="line-added"> 739                     Node* child = node-&gt;child1().node();</span>
<span class="line-added"> 740                     if (seen.add(child).isNewEntry)</span>
<span class="line-added"> 741                         worklist.append(child);</span>
<span class="line-added"> 742                     break;</span>
<span class="line-added"> 743                 }</span>
<span class="line-added"> 744                 case Phi: {</span>
<span class="line-added"> 745                     for (unsigned i = 0; i &lt; m_graph.numChildren(node); ++i) {</span>
<span class="line-added"> 746                         Edge edge = m_graph.child(node, i);</span>
<span class="line-added"> 747                         if (!edge)</span>
<span class="line-added"> 748                             continue;</span>
<span class="line-added"> 749                         if (seen.add(edge.node()).isNewEntry)</span>
<span class="line-added"> 750                             worklist.append(edge.node());</span>
<span class="line-added"> 751                     }</span>
<span class="line-added"> 752                     break;</span>
<span class="line-added"> 753                 }</span>
<span class="line-added"> 754                 case SetLocal:</span>
<span class="line-added"> 755                 case SetArgumentDefinitely:</span>
<span class="line-added"> 756                     break;</span>
<span class="line-added"> 757                 case SetArgumentMaybe:</span>
<span class="line-added"> 758                     VALIDATE((node), !&quot;Should not reach SetArgumentMaybe. GetLocal that has data flow that reaches a SetArgumentMaybe is invalid IR.&quot;);</span>
<span class="line-added"> 759                     break;</span>
<span class="line-added"> 760                 default:</span>
<span class="line-added"> 761                     VALIDATE((node), !&quot;Unexecpted node type.&quot;);</span>
<span class="line-added"> 762                     break;</span>
<span class="line-added"> 763                 }</span>
<span class="line-added"> 764             }</span>
<span class="line-added"> 765         }</span>
 766     }
 767 
 768     void validateSSA()
 769     {
 770         // FIXME: Add more things here.
 771         // https://bugs.webkit.org/show_bug.cgi?id=123471
 772 
 773         VALIDATE((), m_graph.m_roots.size() == 1);
 774         VALIDATE((), m_graph.m_roots[0] == m_graph.block(0));
 775         VALIDATE((), !m_graph.m_argumentFormats.isEmpty()); // We always have at least one entrypoint.
 776         VALIDATE((), m_graph.m_rootToArguments.isEmpty()); // This is only used in CPS.
 777 
 778         for (unsigned entrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeOffset.keys())
 779             VALIDATE((), entrypointIndex &gt; 0); // By convention, 0 is the entrypoint index for the op_enter entrypoint, which can not be in a catch.
 780 
 781         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 782             BasicBlock* block = m_graph.block(blockIndex);
 783             if (!block)
 784                 continue;
 785 
 786             VALIDATE((block), block-&gt;phis.isEmpty());
 787 
 788             bool didSeeExitOK = false;
 789             bool isOSRExited = false;
 790 
 791             for (auto* node : *block) {
 792                 didSeeExitOK |= node-&gt;origin.exitOK;
 793                 switch (node-&gt;op()) {
 794                 case Phi:
 795                     // Phi cannot exit, and it would be wrong to hoist anything to the Phi that could
 796                     // exit.
 797                     VALIDATE((node), !node-&gt;origin.exitOK);
 798 
 799                     // It never makes sense to have exitOK anywhere in the block before a Phi. It&#39;s only
 800                     // OK to exit after all Phis are done.
 801                     VALIDATE((node), !didSeeExitOK);
 802                     break;
 803 
 804                 case GetLocal:
 805                 case SetLocal:
<span class="line-modified"> 806                 case SetArgumentDefinitely:</span>
<span class="line-added"> 807                 case SetArgumentMaybe:</span>
 808                 case Phantom:
 809                     VALIDATE((node), !&quot;bad node type for SSA&quot;);
 810                     break;
 811 
 812                 default:
 813                     // FIXME: Add more things here.
 814                     // https://bugs.webkit.org/show_bug.cgi?id=123471
 815                     break;
 816                 }
 817 
 818                 if (isOSRExited)
 819                     continue;
 820                 switch (node-&gt;op()) {
 821                 case PhantomNewObject:
 822                 case PhantomNewFunction:
 823                 case PhantomNewGeneratorFunction:
 824                 case PhantomNewAsyncFunction:
 825                 case PhantomNewAsyncGeneratorFunction:
 826                 case PhantomCreateActivation:
 827                 case PhantomDirectArguments:
</pre>
</td>
</tr>
</table>
<center><a href="DFGUseKind.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGValueSource.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>