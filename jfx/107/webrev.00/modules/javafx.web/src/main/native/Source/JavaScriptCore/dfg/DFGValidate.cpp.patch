diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp
@@ -29,10 +29,11 @@
 #if ENABLE(DFG_JIT)
 
 #include "CodeBlockWithJITType.h"
 #include "DFGClobberize.h"
 #include "DFGClobbersExitState.h"
+#include "DFGDominators.h"
 #include "DFGMayExit.h"
 #include "JSCInlines.h"
 #include <wtf/Assertions.h>
 
 namespace JSC { namespace DFG {
@@ -773,10 +774,14 @@
         VALIDATE((), m_graph.m_roots.size() == 1);
         VALIDATE((), m_graph.m_roots[0] == m_graph.block(0));
         VALIDATE((), !m_graph.m_argumentFormats.isEmpty()); // We always have at least one entrypoint.
         VALIDATE((), m_graph.m_rootToArguments.isEmpty()); // This is only used in CPS.
 
+        m_graph.initializeNodeOwners();
+
+        auto& dominators = m_graph.ensureSSADominators();
+
         for (unsigned entrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeOffset.keys())
             VALIDATE((), entrypointIndex > 0); // By convention, 0 is the entrypoint index for the op_enter entrypoint, which can not be in a catch.
 
         for (BlockIndex blockIndex = 0; blockIndex < m_graph.numBlocks(); ++blockIndex) {
             BasicBlock* block = m_graph.block(blockIndex);
@@ -786,10 +791,12 @@
             VALIDATE((block), block->phis.isEmpty());
 
             bool didSeeExitOK = false;
             bool isOSRExited = false;
 
+            HashSet<Node*> nodesInThisBlock;
+
             for (auto* node : *block) {
                 didSeeExitOK |= node->origin.exitOK;
                 switch (node->op()) {
                 case Phi:
                     // Phi cannot exit, and it would be wrong to hoist anything to the Phi that could
@@ -904,11 +911,17 @@
                         [&] (const Edge& edge) {
                             VALIDATE((node), !edge->isPhantomAllocation());
                         });
                     break;
                 }
+
                 isOSRExited |= node->isPseudoTerminal();
+
+                m_graph.doToChildren(node, [&] (Edge child) {
+                    VALIDATE((node), dominators.strictlyDominates(child->owner, block) || nodesInThisBlock.contains(child.node()));
+                });
+                nodesInThisBlock.add(node);
             }
         }
     }
 
     void validateEdgeWithDoubleResultIfNecessary(Node* node, Edge edge)
