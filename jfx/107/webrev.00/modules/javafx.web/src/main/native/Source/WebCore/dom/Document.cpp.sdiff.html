<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../WTF/wtf/URLHelpers.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../page/FrameView.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
4943 }
4944 
4945 static bool isValidNameNonASCII(const LChar* characters, unsigned length)
4946 {
4947     if (!isValidNameStart(characters[0]))
4948         return false;
4949 
4950     for (unsigned i = 1; i &lt; length; ++i) {
4951         if (!isValidNamePart(characters[i]))
4952             return false;
4953     }
4954 
4955     return true;
4956 }
4957 
4958 static bool isValidNameNonASCII(const UChar* characters, unsigned length)
4959 {
4960     unsigned i = 0;
4961 
4962     UChar32 c;
<span class="line-modified">4963     U16_NEXT(characters, i, length, c)</span>
4964     if (!isValidNameStart(c))
4965         return false;
4966 
4967     while (i &lt; length) {
<span class="line-modified">4968         U16_NEXT(characters, i, length, c)</span>
4969         if (!isValidNamePart(c))
4970             return false;
4971     }
4972 
4973     return true;
4974 }
4975 
4976 template&lt;typename CharType&gt;
4977 static inline bool isValidNameASCII(const CharType* characters, unsigned length)
4978 {
4979     CharType c = characters[0];
4980     if (!(isASCIIAlpha(c) || c == &#39;:&#39; || c == &#39;_&#39;))
4981         return false;
4982 
4983     for (unsigned i = 1; i &lt; length; ++i) {
4984         c = characters[i];
4985         if (!(isASCIIAlphanumeric(c) || c == &#39;:&#39; || c == &#39;_&#39; || c == &#39;-&#39; || c == &#39;.&#39;))
4986             return false;
4987     }
4988 
</pre>
<hr />
<pre>
5008 
5009     if (isValidNameASCII(characters, length))
5010         return true;
5011 
5012     return isValidNameNonASCII(characters, length);
5013 }
5014 
5015 ExceptionOr&lt;std::pair&lt;AtomString, AtomString&gt;&gt; Document::parseQualifiedName(const String&amp; qualifiedName)
5016 {
5017     unsigned length = qualifiedName.length();
5018 
5019     if (!length)
5020         return Exception { InvalidCharacterError };
5021 
5022     bool nameStart = true;
5023     bool sawColon = false;
5024     unsigned colonPosition = 0;
5025 
5026     for (unsigned i = 0; i &lt; length; ) {
5027         UChar32 c;
<span class="line-modified">5028         U16_NEXT(qualifiedName, i, length, c)</span>
5029         if (c == &#39;:&#39;) {
5030             if (sawColon)
5031                 return Exception { InvalidCharacterError };
5032             nameStart = true;
5033             sawColon = true;
5034             colonPosition = i - 1;
5035         } else if (nameStart) {
5036             if (!isValidNameStart(c))
5037                 return Exception { InvalidCharacterError };
5038             nameStart = false;
5039         } else {
5040             if (!isValidNamePart(c))
5041                 return Exception { InvalidCharacterError };
5042         }
5043     }
5044 
5045     if (!sawColon)
5046         return std::pair&lt;AtomString, AtomString&gt; { { }, { qualifiedName } };
5047 
5048     if (!colonPosition || length - colonPosition &lt;= 1)
</pre>
<hr />
<pre>
6926     return EditingBehavior { settings().editingBehaviorType() };
6927 }
6928 
6929 float Document::deviceScaleFactor() const
6930 {
6931     float deviceScaleFactor = 1.0;
6932     if (Page* documentPage = page())
6933         deviceScaleFactor = documentPage-&gt;deviceScaleFactor();
6934     return deviceScaleFactor;
6935 }
6936 
6937 bool Document::useSystemAppearance() const
6938 {
6939     if (auto* documentPage = page())
6940         return documentPage-&gt;useSystemAppearance();
6941     return false;
6942 }
6943 
6944 bool Document::useDarkAppearance(const RenderStyle* style) const
6945 {
<span class="line-removed">6946 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
6947 #if ENABLE(DARK_MODE_CSS)
6948     OptionSet&lt;ColorScheme&gt; colorScheme;
6949 
6950     // Use the style&#39;s supported color schemes, if supplied.
6951     if (style)
6952         colorScheme = style-&gt;colorScheme().colorScheme();
6953 
6954     // Fallback to the document&#39;s supported color schemes if style was empty (auto).
6955     if (colorScheme.isEmpty())
6956         colorScheme = m_colorScheme;
6957 
6958     if (colorScheme.contains(ColorScheme::Dark) &amp;&amp; !colorScheme.contains(ColorScheme::Light))
6959         return true;
6960 #else
6961     UNUSED_PARAM(style);
6962 #endif
6963 
6964     bool pageUsesDarkAppearance = false;
6965     if (Page* documentPage = page())
6966         pageUsesDarkAppearance = documentPage-&gt;useDarkAppearance();
6967 
6968     if (useSystemAppearance())
6969         return pageUsesDarkAppearance;
6970 
6971 #if ENABLE(DARK_MODE_CSS)
6972     if (colorScheme.contains(ColorScheme::Dark))
6973         return pageUsesDarkAppearance;
6974 #endif
<span class="line-removed">6975 #else</span>
<span class="line-removed">6976     UNUSED_PARAM(style);</span>
<span class="line-removed">6977 #endif</span>
6978 
6979     return false;
6980 }
6981 
6982 bool Document::useElevatedUserInterfaceLevel() const
6983 {
6984     if (auto* documentPage = page())
6985         return documentPage-&gt;useElevatedUserInterfaceLevel();
6986     return false;
6987 }
6988 
6989 OptionSet&lt;StyleColor::Options&gt; Document::styleColorOptions(const RenderStyle* style) const
6990 {
6991     OptionSet&lt;StyleColor::Options&gt; options;
6992     if (useSystemAppearance())
6993         options.add(StyleColor::Options::UseSystemAppearance);
6994     if (useDarkAppearance(style))
6995         options.add(StyleColor::Options::UseDarkAppearance);
6996     if (useElevatedUserInterfaceLevel())
6997         options.add(StyleColor::Options::UseElevatedUserInterfaceLevel);
</pre>
</td>
<td>
<hr />
<pre>
4943 }
4944 
4945 static bool isValidNameNonASCII(const LChar* characters, unsigned length)
4946 {
4947     if (!isValidNameStart(characters[0]))
4948         return false;
4949 
4950     for (unsigned i = 1; i &lt; length; ++i) {
4951         if (!isValidNamePart(characters[i]))
4952             return false;
4953     }
4954 
4955     return true;
4956 }
4957 
4958 static bool isValidNameNonASCII(const UChar* characters, unsigned length)
4959 {
4960     unsigned i = 0;
4961 
4962     UChar32 c;
<span class="line-modified">4963     U16_NEXT(characters, i, length, c);</span>
4964     if (!isValidNameStart(c))
4965         return false;
4966 
4967     while (i &lt; length) {
<span class="line-modified">4968         U16_NEXT(characters, i, length, c);</span>
4969         if (!isValidNamePart(c))
4970             return false;
4971     }
4972 
4973     return true;
4974 }
4975 
4976 template&lt;typename CharType&gt;
4977 static inline bool isValidNameASCII(const CharType* characters, unsigned length)
4978 {
4979     CharType c = characters[0];
4980     if (!(isASCIIAlpha(c) || c == &#39;:&#39; || c == &#39;_&#39;))
4981         return false;
4982 
4983     for (unsigned i = 1; i &lt; length; ++i) {
4984         c = characters[i];
4985         if (!(isASCIIAlphanumeric(c) || c == &#39;:&#39; || c == &#39;_&#39; || c == &#39;-&#39; || c == &#39;.&#39;))
4986             return false;
4987     }
4988 
</pre>
<hr />
<pre>
5008 
5009     if (isValidNameASCII(characters, length))
5010         return true;
5011 
5012     return isValidNameNonASCII(characters, length);
5013 }
5014 
5015 ExceptionOr&lt;std::pair&lt;AtomString, AtomString&gt;&gt; Document::parseQualifiedName(const String&amp; qualifiedName)
5016 {
5017     unsigned length = qualifiedName.length();
5018 
5019     if (!length)
5020         return Exception { InvalidCharacterError };
5021 
5022     bool nameStart = true;
5023     bool sawColon = false;
5024     unsigned colonPosition = 0;
5025 
5026     for (unsigned i = 0; i &lt; length; ) {
5027         UChar32 c;
<span class="line-modified">5028         U16_NEXT(qualifiedName, i, length, c);</span>
5029         if (c == &#39;:&#39;) {
5030             if (sawColon)
5031                 return Exception { InvalidCharacterError };
5032             nameStart = true;
5033             sawColon = true;
5034             colonPosition = i - 1;
5035         } else if (nameStart) {
5036             if (!isValidNameStart(c))
5037                 return Exception { InvalidCharacterError };
5038             nameStart = false;
5039         } else {
5040             if (!isValidNamePart(c))
5041                 return Exception { InvalidCharacterError };
5042         }
5043     }
5044 
5045     if (!sawColon)
5046         return std::pair&lt;AtomString, AtomString&gt; { { }, { qualifiedName } };
5047 
5048     if (!colonPosition || length - colonPosition &lt;= 1)
</pre>
<hr />
<pre>
6926     return EditingBehavior { settings().editingBehaviorType() };
6927 }
6928 
6929 float Document::deviceScaleFactor() const
6930 {
6931     float deviceScaleFactor = 1.0;
6932     if (Page* documentPage = page())
6933         deviceScaleFactor = documentPage-&gt;deviceScaleFactor();
6934     return deviceScaleFactor;
6935 }
6936 
6937 bool Document::useSystemAppearance() const
6938 {
6939     if (auto* documentPage = page())
6940         return documentPage-&gt;useSystemAppearance();
6941     return false;
6942 }
6943 
6944 bool Document::useDarkAppearance(const RenderStyle* style) const
6945 {

6946 #if ENABLE(DARK_MODE_CSS)
6947     OptionSet&lt;ColorScheme&gt; colorScheme;
6948 
6949     // Use the style&#39;s supported color schemes, if supplied.
6950     if (style)
6951         colorScheme = style-&gt;colorScheme().colorScheme();
6952 
6953     // Fallback to the document&#39;s supported color schemes if style was empty (auto).
6954     if (colorScheme.isEmpty())
6955         colorScheme = m_colorScheme;
6956 
6957     if (colorScheme.contains(ColorScheme::Dark) &amp;&amp; !colorScheme.contains(ColorScheme::Light))
6958         return true;
6959 #else
6960     UNUSED_PARAM(style);
6961 #endif
6962 
6963     bool pageUsesDarkAppearance = false;
6964     if (Page* documentPage = page())
6965         pageUsesDarkAppearance = documentPage-&gt;useDarkAppearance();
6966 
6967     if (useSystemAppearance())
6968         return pageUsesDarkAppearance;
6969 
6970 #if ENABLE(DARK_MODE_CSS)
6971     if (colorScheme.contains(ColorScheme::Dark))
6972         return pageUsesDarkAppearance;
6973 #endif



6974 
6975     return false;
6976 }
6977 
6978 bool Document::useElevatedUserInterfaceLevel() const
6979 {
6980     if (auto* documentPage = page())
6981         return documentPage-&gt;useElevatedUserInterfaceLevel();
6982     return false;
6983 }
6984 
6985 OptionSet&lt;StyleColor::Options&gt; Document::styleColorOptions(const RenderStyle* style) const
6986 {
6987     OptionSet&lt;StyleColor::Options&gt; options;
6988     if (useSystemAppearance())
6989         options.add(StyleColor::Options::UseSystemAppearance);
6990     if (useDarkAppearance(style))
6991         options.add(StyleColor::Options::UseDarkAppearance);
6992     if (useElevatedUserInterfaceLevel())
6993         options.add(StyleColor::Options::UseElevatedUserInterfaceLevel);
</pre>
</td>
</tr>
</table>
<center><a href="../../WTF/wtf/URLHelpers.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../page/FrameView.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>