diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGObjectAllocationSinkingPhase.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGObjectAllocationSinkingPhase.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGObjectAllocationSinkingPhase.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGObjectAllocationSinkingPhase.cpp
@@ -1813,13 +1813,15 @@
                 insertOSRHintsForUpdate(
                     0, block->at(0)->origin, canExit,
                     availabilityCalculator.m_availability, identifier, phiDef->value());
 
                 for (PromotedHeapLocation location : hintsForPhi[variable->index()]) {
-                    m_insertionSet.insert(0,
-                        location.createHint(m_graph, block->at(0)->origin.withInvalidExit(), phiDef->value()));
-                    m_localMapping.set(location, phiDef->value());
+                    if (m_heap.onlyLocalAllocation(location.base())) {
+                        m_insertionSet.insert(0,
+                            location.createHint(m_graph, block->at(0)->origin.withInvalidExit(), phiDef->value()));
+                        m_localMapping.set(location, phiDef->value());
+                    }
                 }
             }
 
             if (DFGObjectAllocationSinkingPhaseInternal::verbose) {
                 dataLog("Local mapping at ", pointerDump(block), ": ", mapDump(m_localMapping), "\n");
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp
@@ -29,10 +29,11 @@
 #if ENABLE(DFG_JIT)
 
 #include "CodeBlockWithJITType.h"
 #include "DFGClobberize.h"
 #include "DFGClobbersExitState.h"
+#include "DFGDominators.h"
 #include "DFGMayExit.h"
 #include "JSCInlines.h"
 #include <wtf/Assertions.h>
 
 namespace JSC { namespace DFG {
@@ -773,10 +774,14 @@
         VALIDATE((), m_graph.m_roots.size() == 1);
         VALIDATE((), m_graph.m_roots[0] == m_graph.block(0));
         VALIDATE((), !m_graph.m_argumentFormats.isEmpty()); // We always have at least one entrypoint.
         VALIDATE((), m_graph.m_rootToArguments.isEmpty()); // This is only used in CPS.
 
+        m_graph.initializeNodeOwners();
+
+        auto& dominators = m_graph.ensureSSADominators();
+
         for (unsigned entrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeOffset.keys())
             VALIDATE((), entrypointIndex > 0); // By convention, 0 is the entrypoint index for the op_enter entrypoint, which can not be in a catch.
 
         for (BlockIndex blockIndex = 0; blockIndex < m_graph.numBlocks(); ++blockIndex) {
             BasicBlock* block = m_graph.block(blockIndex);
@@ -786,10 +791,12 @@
             VALIDATE((block), block->phis.isEmpty());
 
             bool didSeeExitOK = false;
             bool isOSRExited = false;
 
+            HashSet<Node*> nodesInThisBlock;
+
             for (auto* node : *block) {
                 didSeeExitOK |= node->origin.exitOK;
                 switch (node->op()) {
                 case Phi:
                     // Phi cannot exit, and it would be wrong to hoist anything to the Phi that could
@@ -904,11 +911,17 @@
                         [&] (const Edge& edge) {
                             VALIDATE((node), !edge->isPhantomAllocation());
                         });
                     break;
                 }
+
                 isOSRExited |= node->isPseudoTerminal();
+
+                m_graph.doToChildren(node, [&] (Edge child) {
+                    VALIDATE((node), dominators.strictlyDominates(child->owner, block) || nodesInThisBlock.contains(child.node()));
+                });
+                nodesInThisBlock.add(node);
             }
         }
     }
 
     void validateEdgeWithDoubleResultIfNecessary(Node* node, Edge edge)
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/parser.rb b/modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/parser.rb
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/parser.rb
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/parser.rb
@@ -626,13 +626,11 @@
     
     def parseSequence(final, comment)
         firstCodeOrigin = @tokens[@idx].codeOrigin
         list = []
         loop {
-            if (@idx == @tokens.length and not final) or (final and @tokens[@idx] =~ final)
-                break
-            elsif @tokens[@idx].is_a? Annotation
+            if @tokens[@idx].is_a? Annotation
                 # This is the only place where we can encounter a global
                 # annotation, and hence need to be able to distinguish between
                 # them.
                 # globalAnnotations are the ones that start from column 0. All
                 # others are considered localAnnotations.  The only reason to
@@ -642,10 +640,12 @@
                 codeOrigin = @tokens[@idx].codeOrigin
                 annotationOpcode = (@tokens[@idx].type == :global) ? "globalAnnotation" : "localAnnotation"
                 list << Instruction.new(codeOrigin, annotationOpcode, [], @tokens[@idx].string)
                 @annotation = nil
                 @idx += 2 # Consume the newline as well.
+            elsif (@idx == @tokens.length and not final) or (final and @tokens[@idx] =~ final)
+                break
             elsif @tokens[@idx] == "\n"
                 # ignore
                 @idx += 1
             elsif @tokens[@idx] == "const"
                 @idx += 1
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/NativeErrorConstructor.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/NativeErrorConstructor.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/NativeErrorConstructor.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/NativeErrorConstructor.h
@@ -20,10 +20,11 @@
 
 #pragma once
 
 #include "Error.h"
 #include "InternalFunction.h"
+#include "JSGlobalObject.h"
 #include "NativeErrorPrototype.h"
 
 namespace JSC {
 
 class ErrorInstance;
diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/Platform.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/Platform.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/Platform.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/Platform.h
@@ -1447,11 +1447,11 @@
 #if PLATFORM(MAC) || PLATFORM(IOS)
 #define USE_CFNETWORK_AUTO_ADDED_HTTP_HEADER_SUPPRESSION 1
 #endif
 #endif
 
-#if (PLATFORM(MAC) && __MAC_OS_X_VERSION_MIN_REQUIRED >= 101400) || (PLATFORM(IOS_FAMILY) && __IPHONE_OS_VERSION_MIN_REQUIRED >= 130000) || PLATFORM(GTK)
+#if (PLATFORM(MAC) && __MAC_OS_X_VERSION_MIN_REQUIRED >= 101400) || (PLATFORM(IOS_FAMILY) && __IPHONE_OS_VERSION_MIN_REQUIRED >= 130000)
 #define HAVE_OS_DARK_MODE_SUPPORT 1
 #endif
 
 #if PLATFORM(MAC) && __MAC_OS_X_VERSION_MIN_REQUIRED >= 101400
 #define HAVE_CG_FONT_RENDERING_GET_FONT_SMOOTHING_DISABLED 1
diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/URLHelpers.cpp b/modules/javafx.web/src/main/native/Source/WTF/wtf/URLHelpers.cpp
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/URLHelpers.cpp
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/URLHelpers.cpp
@@ -299,11 +299,11 @@
     loadIDNScriptWhiteList();
     int32_t i = 0;
     Optional<UChar32> previousCodePoint;
     while (i < length) {
         UChar32 c;
-        U16_NEXT(buffer, i, length, c)
+        U16_NEXT(buffer, i, length, c);
         UErrorCode error = U_ZERO_ERROR;
         UScriptCode script = uscript_getScript(c, &error);
         if (error != U_ZERO_ERROR) {
             LOG_ERROR("got ICU error while trying to look at scripts: %d", error);
             return false;
diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp
@@ -4958,16 +4958,16 @@
 static bool isValidNameNonASCII(const UChar* characters, unsigned length)
 {
     unsigned i = 0;
 
     UChar32 c;
-    U16_NEXT(characters, i, length, c)
+    U16_NEXT(characters, i, length, c);
     if (!isValidNameStart(c))
         return false;
 
     while (i < length) {
-        U16_NEXT(characters, i, length, c)
+        U16_NEXT(characters, i, length, c);
         if (!isValidNamePart(c))
             return false;
     }
 
     return true;
@@ -5023,11 +5023,11 @@
     bool sawColon = false;
     unsigned colonPosition = 0;
 
     for (unsigned i = 0; i < length; ) {
         UChar32 c;
-        U16_NEXT(qualifiedName, i, length, c)
+        U16_NEXT(qualifiedName, i, length, c);
         if (c == ':') {
             if (sawColon)
                 return Exception { InvalidCharacterError };
             nameStart = true;
             sawColon = true;
@@ -6941,11 +6941,10 @@
     return false;
 }
 
 bool Document::useDarkAppearance(const RenderStyle* style) const
 {
-#if HAVE(OS_DARK_MODE_SUPPORT)
 #if ENABLE(DARK_MODE_CSS)
     OptionSet<ColorScheme> colorScheme;
 
     // Use the style's supported color schemes, if supplied.
     if (style)
@@ -6970,13 +6969,10 @@
 
 #if ENABLE(DARK_MODE_CSS)
     if (colorScheme.contains(ColorScheme::Dark))
         return pageUsesDarkAppearance;
 #endif
-#else
-    UNUSED_PARAM(style);
-#endif
 
     return false;
 }
 
 bool Document::useElevatedUserInterfaceLevel() const
diff a/modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp b/modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp
@@ -2969,16 +2969,11 @@
 }
 
 void FrameView::updateBackgroundRecursively(const Optional<Color>& backgroundColor)
 {
 #if HAVE(OS_DARK_MODE_SUPPORT)
-#if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
-    static const auto cssValueControlBackground = CSSValueAppleSystemControlBackground;
-#else
-    static const auto cssValueControlBackground = CSSValueWindow;
-#endif
-    Color baseBackgroundColor = backgroundColor.valueOr(RenderTheme::singleton().systemColor(cssValueControlBackground, styleColorOptions()));
+    Color baseBackgroundColor = backgroundColor.valueOr(RenderTheme::singleton().systemColor(CSSValueAppleSystemControlBackground, styleColorOptions()));
 #else
     Color baseBackgroundColor = backgroundColor.valueOr(Color::white);
 #endif
 
     for (auto* frame = m_frame.ptr(); frame; frame = frame->tree().traverseNext(m_frame.ptr())) {
diff a/modules/javafx.web/src/main/native/Source/WebCore/page/Page.cpp b/modules/javafx.web/src/main/native/Source/WebCore/page/Page.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/Page.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/Page.cpp
@@ -2712,11 +2712,11 @@
     }
 }
 
 void Page::effectiveAppearanceDidChange(bool useDarkAppearance, bool useElevatedUserInterfaceLevel)
 {
-#if HAVE(OS_DARK_MODE_SUPPORT)
+#if ENABLE(DARK_MODE_CSS)
     if (m_useDarkAppearance == useDarkAppearance && m_useElevatedUserInterfaceLevel == useElevatedUserInterfaceLevel)
         return;
 
     m_useDarkAppearance = useDarkAppearance;
     m_useElevatedUserInterfaceLevel = useElevatedUserInterfaceLevel;
@@ -2736,11 +2736,11 @@
 #endif
 }
 
 bool Page::useDarkAppearance() const
 {
-#if HAVE(OS_DARK_MODE_SUPPORT)
+#if ENABLE(DARK_MODE_CSS)
     FrameView* view = mainFrame().view();
     if (!view || !equalLettersIgnoringASCIICase(view->mediaType(), "screen"))
         return false;
     if (m_useDarkAppearanceOverride)
         return m_useDarkAppearanceOverride.value();
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ComplexTextController.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ComplexTextController.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ComplexTextController.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ComplexTextController.cpp
@@ -203,21 +203,33 @@
     for (size_t r = 0; r < runCount; ++r) {
         const ComplexTextRun& complexTextRun = *m_complexTextRuns[r];
         for (unsigned j = 0; j < complexTextRun.glyphCount(); ++j) {
             unsigned index = offsetIntoAdjustedGlyphs + j;
             float adjustedAdvance = m_adjustedBaseAdvances[index].width();
-            if (x < adjustedAdvance) {
+            bool hit = m_run.ltr() ? x < adjustedAdvance : (x <= adjustedAdvance && adjustedAdvance);
+            if (hit) {
                 unsigned hitGlyphStart = complexTextRun.indexAt(j);
                 unsigned hitGlyphEnd;
                 if (m_run.ltr())
                     hitGlyphEnd = std::max(hitGlyphStart, j + 1 < complexTextRun.glyphCount() ? complexTextRun.indexAt(j + 1) : complexTextRun.indexEnd());
                 else
                     hitGlyphEnd = std::max(hitGlyphStart, j > 0 ? complexTextRun.indexAt(j - 1) : complexTextRun.indexEnd());
 
                 // FIXME: Instead of dividing the glyph's advance equally between the characters, this
                 // could use the glyph's "ligature carets". This is available in CoreText via CTFontGetLigatureCaretPositions().
-                unsigned hitIndex = hitGlyphStart + (hitGlyphEnd - hitGlyphStart) * (m_run.ltr() ? x / adjustedAdvance : 1 - x / adjustedAdvance);
+                unsigned hitIndex;
+                if (m_run.ltr())
+                    hitIndex = hitGlyphStart + (hitGlyphEnd - hitGlyphStart) * (x / adjustedAdvance);
+                else {
+                    if (hitGlyphStart == hitGlyphEnd)
+                        hitIndex = hitGlyphStart;
+                    else if (x)
+                        hitIndex = hitGlyphEnd - (hitGlyphEnd - hitGlyphStart) * (x / adjustedAdvance);
+                    else
+                        hitIndex = hitGlyphEnd - 1;
+                }
+
                 unsigned stringLength = complexTextRun.stringLength();
                 CachedTextBreakIterator cursorPositionIterator(StringView(complexTextRun.characters(), stringLength), TextBreakIterator::Mode::Caret, nullAtom());
                 unsigned clusterStart;
                 if (cursorPositionIterator.isBoundary(hitIndex))
                     clusterStart = hitIndex;
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/freetype/FontPlatformDataFreeType.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/freetype/FontPlatformDataFreeType.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/freetype/FontPlatformDataFreeType.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/freetype/FontPlatformDataFreeType.cpp
@@ -277,11 +277,11 @@
     CairoFtFaceLocker cairoFtFaceLocker(m_scaledFont.get());
     FT_Face ftFace = cairoFtFaceLocker.ftFace();
     if (!ftFace)
         return nullptr;
 
-    HbUniquePtr<hb_face_t> face(hb_ft_face_create_cached(ftFace));
+    HbUniquePtr<hb_face_t> face(hb_ft_face_create_referenced(ftFace));
     if (!hb_ot_math_has_data(face.get()))
         return nullptr;
 
     return HbUniquePtr<hb_font_t>(hb_font_create(face.get()));
 }
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/harfbuzz/ComplexTextControllerHarfBuzz.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/harfbuzz/ComplexTextControllerHarfBuzz.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/harfbuzz/ComplexTextControllerHarfBuzz.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/harfbuzz/ComplexTextControllerHarfBuzz.cpp
@@ -162,21 +162,19 @@
             m_glyphOrigins[i] = { };
             continue;
         }
 
         float offsetX = harfBuzzPositionToFloat(glyphPositions[i].x_offset);
-        float offsetY = -harfBuzzPositionToFloat(glyphPositions[i].y_offset);
+        float offsetY = harfBuzzPositionToFloat(glyphPositions[i].y_offset);
         float advanceX = harfBuzzPositionToFloat(glyphPositions[i].x_advance);
         float advanceY = harfBuzzPositionToFloat(glyphPositions[i].y_advance);
 
-        if (!i)
-            m_initialAdvance = { offsetX, -offsetY };
-
         m_glyphs[i] = glyph;
         m_baseAdvances[i] = { advanceX, advanceY };
         m_glyphOrigins[i] = { offsetX, offsetY };
     }
+    m_initialAdvance = toFloatSize(m_glyphOrigins[0]);
 }
 
 static const hb_tag_t s_vertTag = HB_TAG('v', 'e', 'r', 't');
 static const hb_tag_t s_vrt2Tag = HB_TAG('v', 'r', 't', '2');
 static const hb_tag_t s_kernTag = HB_TAG('k', 'e', 'r', 'n');
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFrameSet.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFrameSet.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFrameSet.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFrameSet.cpp
@@ -523,21 +523,19 @@
         for (int c = 0; c < cols; c++) {
             child->setLocation(IntPoint(xPos, yPos));
             int width = m_cols.m_sizes[c];
 
             // has to be resized and itself resize its contents
-            if (width != child->width() || height != child->height()) {
-                child->setWidth(width);
-                child->setHeight(height);
+            child->setWidth(width);
+            child->setHeight(height);
 #if PLATFORM(IOS_FAMILY)
-                // FIXME: Is this iOS-specific?
-                child->setNeedsLayout(MarkOnlyThis);
+            // FIXME: Is this iOS-specific?
+            child->setNeedsLayout(MarkOnlyThis);
 #else
-                child->setNeedsLayout();
+            child->setNeedsLayout();
 #endif
-                child->layout();
-            }
+            child->layout();
 
             xPos += width + borderThickness;
 
             child = child->nextSiblingBox();
             if (!child)
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderThemeGtk.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderThemeGtk.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderThemeGtk.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderThemeGtk.cpp
@@ -122,26 +122,10 @@
     // FIXME: We need to set this to the position of the tick marks.
     return 0;
 }
 #endif
 
-static void themeChangedCallback()
-{
-    Page::updateStyleForAllPagesAfterGlobalChangeInEnvironment();
-}
-
-RenderThemeGtk::RenderThemeGtk()
-{
-    static bool themeMonitorInitialized = false;
-    if (!themeMonitorInitialized) {
-        GtkSettings* settings = gtk_settings_get_default();
-        g_signal_connect(settings, "notify::gtk-theme-name", G_CALLBACK(themeChangedCallback), nullptr);
-        g_signal_connect(settings, "notify::gtk-color-scheme", G_CALLBACK(themeChangedCallback), nullptr);
-        themeMonitorInitialized = true;
-    }
-}
-
 enum RenderThemePart {
     Entry,
     EntrySelection,
     EntryIconLeft,
     EntryIconRight,
@@ -949,21 +933,10 @@
         return styleColor(Entry, GTK_STATE_FLAG_ACTIVE, StyleColorForeground);
     case CSSValueText:
         return styleColor(Entry, GTK_STATE_FLAG_ACTIVE, StyleColorForeground);
     case CSSValueGraytext:
         return styleColor(Entry, GTK_STATE_FLAG_INSENSITIVE, StyleColorForeground);
-    case CSSValueWebkitControlBackground:
-        return styleColor(Entry, GTK_STATE_FLAG_ACTIVE, StyleColorBackground);
-    case CSSValueWindow: {
-        // Only get window color from the theme in dark mode.
-        gboolean preferDarkTheme = FALSE;
-        if (auto* settings = gtk_settings_get_default())
-            g_object_get(settings, "gtk-application-prefer-dark-theme", &preferDarkTheme, nullptr);
-        if (preferDarkTheme)
-            return styleColor(Window, GTK_STATE_FLAG_ACTIVE, StyleColorBackground);
-        break;
-    }
     default:
         break;
     }
 
     return RenderTheme::systemColor(cssValueId, options);
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderThemeGtk.h b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderThemeGtk.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderThemeGtk.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderThemeGtk.h
@@ -102,11 +102,10 @@
 #endif
 
     bool shouldHaveCapsLockIndicator(const HTMLInputElement&) const override;
 
 private:
-    RenderThemeGtk();
     virtual ~RenderThemeGtk();
 
     bool paintCheckbox(const RenderObject&, const PaintInfo&, const IntRect&) override;
     void setCheckboxSize(RenderStyle&) const override;
 
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.cpp
@@ -297,10 +297,12 @@
 
 WTF::IteratorRange<RunResolver::Iterator> RunResolver::rangeForRendererWithOffsets(const RenderObject& renderer, unsigned startOffset, unsigned endOffset) const
 {
     ASSERT(startOffset <= endOffset);
     auto range = rangeForRenderer(renderer);
+    if (range.begin() == range.end())
+        return { end(), end() };
     auto it = range.begin();
     auto localEnd = (*it).start() + endOffset;
     // Advance to the first run with the start offset inside. Only the first node in a range can have a startOffset.
     while (it != range.end() && (*it).end() <= startOffset)
         ++it;
diff a/modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGAnimatedPropertyPairAccessor.h b/modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGAnimatedPropertyPairAccessor.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGAnimatedPropertyPairAccessor.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGAnimatedPropertyPairAccessor.h
@@ -56,10 +56,16 @@
     const Ref<AnimatedPropertyType1>& property1(const OwnerType& owner) const { return m_accessor1.property(owner); }
 
     Ref<AnimatedPropertyType2>& property2(OwnerType& owner) const { return m_accessor2.property(owner); }
     const Ref<AnimatedPropertyType2>& property2(const OwnerType& owner) const { return m_accessor2.property(owner); }
 
+    void detach(const OwnerType& owner) const override
+    {
+        property1(owner)->detach();
+        property2(owner)->detach();
+    }
+
     bool matches(const OwnerType& owner, const SVGAnimatedProperty& animatedProperty) const override
     {
         return m_accessor1.matches(owner, animatedProperty) || m_accessor2.matches(owner, animatedProperty);
     }
 
diff a/modules/javafx.web/src/main/native/Source/WebCore/testing/InternalSettings.cpp b/modules/javafx.web/src/main/native/Source/WebCore/testing/InternalSettings.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/testing/InternalSettings.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/testing/InternalSettings.cpp
@@ -49,14 +49,10 @@
 
 #if USE(SOUP)
 #include "SoupNetworkSession.h"
 #endif
 
-#if PLATFORM(GTK)
-#include <gtk/gtk.h>
-#endif
-
 namespace WebCore {
 
 InternalSettings::Backup::Backup(Settings& settings)
     : m_originalEditingBehavior(settings.editingBehaviorType())
 #if ENABLE(TEXT_AUTOSIZING)
@@ -540,20 +536,10 @@
 #endif
 }
 
 void InternalSettings::setUseDarkAppearanceInternal(bool useDarkAppearance)
 {
-#if PLATFORM(GTK)
-    // GTK doesn't allow to change the theme from the web process, but tests need to do it, so
-    // we do it here only for tests.
-    if (auto* settings = gtk_settings_get_default()) {
-        gboolean preferDarkTheme;
-        g_object_get(settings, "gtk-application-prefer-dark-theme", &preferDarkTheme, nullptr);
-        if (preferDarkTheme != useDarkAppearance)
-            g_object_set(settings, "gtk-application-prefer-dark-theme", useDarkAppearance, nullptr);
-    }
-#endif
     ASSERT(m_page);
     m_page->effectiveAppearanceDidChange(useDarkAppearance, m_page->useElevatedUserInterfaceLevel());
 }
 
 ExceptionOr<void> InternalSettings::setUseDarkAppearance(bool useDarkAppearance)
diff a/modules/javafx.web/src/main/native/Source/cmake/OptionsGTK.cmake b/modules/javafx.web/src/main/native/Source/cmake/OptionsGTK.cmake
--- a/modules/javafx.web/src/main/native/Source/cmake/OptionsGTK.cmake
+++ b/modules/javafx.web/src/main/native/Source/cmake/OptionsGTK.cmake
@@ -1,13 +1,13 @@
 include(GNUInstallDirs)
 include(VersioningUtils)
 
-SET_PROJECT_VERSION(2 26 2)
+SET_PROJECT_VERSION(2 26 3)
 set(WEBKITGTK_API_VERSION 4.0)
 
-CALCULATE_LIBRARY_VERSIONS_FROM_LIBTOOL_TRIPLE(WEBKIT 76 3 39)
-CALCULATE_LIBRARY_VERSIONS_FROM_LIBTOOL_TRIPLE(JAVASCRIPTCORE 32 7 14)
+CALCULATE_LIBRARY_VERSIONS_FROM_LIBTOOL_TRIPLE(WEBKIT 76 4 39)
+CALCULATE_LIBRARY_VERSIONS_FROM_LIBTOOL_TRIPLE(JAVASCRIPTCORE 32 8 14)
 
 # These are shared variables, but we special case their definition so that we can use the
 # CMAKE_INSTALL_* variables that are populated by the GNUInstallDirs macro.
 set(LIB_INSTALL_DIR "${CMAKE_INSTALL_FULL_LIBDIR}" CACHE PATH "Absolute path to library installation directory")
 set(EXEC_INSTALL_DIR "${CMAKE_INSTALL_FULL_BINDIR}" CACHE PATH "Absolute path to executable installation directory")
@@ -193,11 +193,10 @@
 set(GTK_INCLUDE_DIRS ${GTK3_INCLUDE_DIRS})
 set(GDK_LIBRARIES ${GDK3_LIBRARIES})
 set(GDK_INCLUDE_DIRS ${GDK3_INCLUDE_DIRS})
 
 SET_AND_EXPOSE_TO_BUILD(HAVE_GTK_UNIX_PRINTING ${GTKUnixPrint_FOUND})
-SET_AND_EXPOSE_TO_BUILD(HAVE_OS_DARK_MODE_SUPPORT 1)
 
 if (USE_WPE_RENDERER)
     find_package(WPE 1.3.0)
     if (NOT WPE_FOUND)
         message(FATAL_ERROR "libwpe is required for USE_WPE_RENDERER")
