<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-font/fontpath_linux.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #if defined (__linux__) &amp;&amp; ! defined (ANDROID_NDK)
 27 
 28 #include &lt;string.h&gt;
 29 #include &lt;stdio.h&gt;
 30 #include &lt;stdlib.h&gt;
 31 #include &lt;strings.h&gt;
 32 #include &lt;sys/types.h&gt;
 33 #include &lt;sys/stat.h&gt;
 34 #include &lt;sys/mman.h&gt;
 35 #include &lt;fcntl.h&gt;
 36 #include &lt;unistd.h&gt;
 37 #include &lt;limits.h&gt;
 38 
 39 #include &lt;dlfcn.h&gt;
 40 #include &lt;fontconfig/fontconfig.h&gt;
 41 
 42 #include &lt;jni.h&gt;
 43 
 44 #ifdef STATIC_BUILD
 45 JNIEXPORT jint JNICALL
 46 JNI_OnLoad_javafx_font(JavaVM * vm, void * reserved) {
 47 #ifdef JNI_VERSION_1_8
 48     //min. returned JNI_VERSION required by JDK8 for builtin libraries
 49     JNIEnv *env;
 50     if ((*vm)-&gt;GetEnv(vm, (void **)&amp;env, JNI_VERSION_1_8) != JNI_OK) {
 51         return JNI_VERSION_1_4;
 52     }
 53     return JNI_VERSION_1_8;
 54 #else
 55     return JNI_VERSION_1_4;
 56 #endif
 57 }
 58 #endif
 59 
 60 /*
 61  * We are not explicitly linking against fontconfig. This isn&#39;t so
 62  * relevant for desktop platforms any more but could help on embedded
 63  * platforms where it may not exist.
 64  */
 65 
 66 static void* openFontConfig() {
 67 
 68     char *homeEnv;
 69     static char *homeEnvStr = &quot;HOME=&quot;; /* must be static */
 70     void* libfontconfig = NULL;
 71 
 72     /* 64 bit sparc should pick up the right version from the lib path.
 73      * New features may be added to libfontconfig, this is expected to
 74      * be compatible with old features, but we may need to start
 75      * distinguishing the library version, to know whether to expect
 76      * certain symbols - and functionality - to be available.
 77      * Also add explicit search for .so.1 in case .so symlink doesn&#39;t exist.
 78      */
 79     libfontconfig = dlopen(&quot;libfontconfig.so.1&quot;, RTLD_LOCAL|RTLD_LAZY);
 80     if (libfontconfig == NULL) {
 81         libfontconfig = dlopen(&quot;libfontconfig.so&quot;, RTLD_LOCAL|RTLD_LAZY);
 82         if (libfontconfig == NULL) {
 83             return NULL;
 84         }
 85     }
 86 
 87     /* Version 1.0 of libfontconfig crashes if HOME isn&#39;t defined in
 88      * the environment. This should generally never happen, but we can&#39;t
 89      * control it, and can&#39;t control the version of fontconfig, so iff
 90      * its not defined we set it to an empty value which is sufficient
 91      * to prevent a crash. I considered unsetting it before exit, but
 92      * it doesn&#39;t appear to work on Solaris, so I will leave it set.
 93      */
 94     homeEnv = getenv(&quot;HOME&quot;);
 95     if (homeEnv == NULL) {
 96         putenv(homeEnvStr);
 97     }
 98 
 99     return libfontconfig;
100 }
101 
102 typedef void* (FcFiniFuncType)();
103 
104 static void closeFontConfig(void* libfontconfig, jboolean fcFini) {
105 
106   /* NB FcFini is not in (eg) the Solaris 10 version of fontconfig. Its not
107    * clear if this means we are really leaking resources in those cases
108    * but it seems we should call this function when its available.
109    * But since the Swing GTK code may be still accessing the lib, its probably
110    * safest for now to just let this &quot;leak&quot; rather than potentially
111    * concurrently free global data still in use by other code.
112    */
113 #if 0
114     if (fcFini) { /* release resources */
115         FcFiniFuncType FcFini = (FcFiniFuncType)dlsym(libfontconfig, &quot;FcFini&quot;);
116 
117         if (FcFini != NULL) {
118             (*FcFini)();
119         }
120     }
121 #endif
122     dlclose(libfontconfig);
123 }
124 
125 typedef FcConfig* (*FcInitLoadConfigFuncType)();
126 typedef FcPattern* (*FcPatternBuildFuncType)(FcPattern *orig, ...);
127 typedef FcObjectSet* (*FcObjectSetFuncType)(const char *first, ...);
128 typedef FcFontSet* (*FcFontListFuncType)(FcConfig *config,
129                                          FcPattern *p,
130                                          FcObjectSet *os);
131 typedef FcResult (*FcPatternGetBoolFuncType)(const FcPattern *p,
132                                                const char *object,
133                                                int n,
134                                                FcBool *b);
135 typedef FcResult (*FcPatternGetIntegerFuncType)(const FcPattern *p,
136                                                 const char *object,
137                                                 int n,
138                                                 int *i);
139 typedef FcResult (*FcPatternGetStringFuncType)(const FcPattern *p,
140                                                const char *object,
141                                                int n,
142                                                FcChar8 ** s);
143 typedef void (*FcPatternDestroyFuncType)(FcPattern *p);
144 typedef void (*FcFontSetDestroyFuncType)(FcFontSet *s);
145 typedef FcPattern* (*FcNameParseFuncType)(const FcChar8 *name);
146 typedef FcBool (*FcPatternAddStringFuncType)(FcPattern *p,
147                                              const char *object,
148                                              const FcChar8 *s);
149 typedef void (*FcDefaultSubstituteFuncType)(FcPattern *p);
150 typedef FcBool (*FcConfigSubstituteFuncType)(FcConfig *config,
151                                              FcPattern *p,
152                                              FcMatchKind kind);
153 typedef FcPattern* (*FcFontMatchFuncType)(FcConfig *config,
154                                           FcPattern *p,
155                                           FcResult *result);
156 typedef FcFontSet* (*FcFontSetCreateFuncType)();
157 typedef FcBool (*FcFontSetAddFuncType)(FcFontSet *s, FcPattern *font);
158 
159 typedef FcResult (*FcPatternGetCharSetFuncType)(FcPattern *p,
160                                                 const char *object,
161                                                 int n,
162                                                 FcCharSet **c);
163 typedef FcFontSet* (*FcFontSortFuncType)(FcConfig *config,
164                                          FcPattern *p,
165                                          FcBool trim,
166                                          FcCharSet **csp,
167                                          FcResult *result);
168 
169 typedef FcCharSet* (*FcCharSetUnionFuncType)(const FcCharSet *a,
170                                              const FcCharSet *b);
171 typedef FcChar32 (*FcCharSetSubtractCountFuncType)(const FcCharSet *a,
172                                                    const FcCharSet *b);
173 
174 JNIEXPORT jboolean JNICALL
175 Java_com_sun_javafx_font_FontConfigManager_getFontConfig
176 (JNIEnv *env, jclass obj, jstring localeStr,
177  jobjectArray fcCompFontArray, jboolean includeFallbacks) {
178 
179     FcNameParseFuncType FcNameParse;
180     FcPatternAddStringFuncType FcPatternAddString;
181     FcConfigSubstituteFuncType FcConfigSubstitute;
182     FcDefaultSubstituteFuncType  FcDefaultSubstitute;
183     FcFontMatchFuncType FcFontMatch;
184     FcPatternGetStringFuncType FcPatternGetString;
185     FcPatternDestroyFuncType FcPatternDestroy;
186     FcPatternGetCharSetFuncType FcPatternGetCharSet;
187     FcFontSortFuncType FcFontSort;
188     FcFontSetDestroyFuncType FcFontSetDestroy;
189     FcCharSetUnionFuncType FcCharSetUnion;
190     FcCharSetSubtractCountFuncType FcCharSetSubtractCount;
191 
192     int i, arrlen;
193     jstring fcNameStr, jstr;
194     const char *locale, *fcName;
195     FcPattern *pattern;
196     FcResult result;
197     void* libfontconfig;
198     jfieldID fcNameFID, fcFirstFontFID, fcAllFontsFID;
199     jfieldID familyNameFID, styleNameFID, fullNameFID, fontFileFID;
200     jmethodID fcFontCons;
201     jclass fcCompFontClass, fcFontClass;
202 
203 
204     // Deleting local refs as we go along so this should be plenty
205     // Unlikely to matter even if it fails.
206     (*env)-&gt;EnsureLocalCapacity(env, 64);
207     if ((*env)-&gt;ExceptionOccurred(env)) {
208         return JNI_FALSE;
209     }
210     fcCompFontClass =
211         (*env)-&gt;FindClass(env,
212                        &quot;com/sun/javafx/font/FontConfigManager$FcCompFont&quot;);
213     if ((*env)-&gt;ExceptionOccurred(env)) {
214         return JNI_FALSE;
215     }
216     fcFontClass =
217          (*env)-&gt;FindClass(env,
218                        &quot;com/sun/javafx/font/FontConfigManager$FontConfigFont&quot;);
219     if ((*env)-&gt;ExceptionOccurred(env)) {
220         return JNI_FALSE;
221     }
222     if (fcCompFontArray == NULL ||
223         fcCompFontClass == NULL ||
224         fcFontClass == NULL)
225     {
226         return JNI_FALSE;
227     }
228 
229     fcNameFID = (*env)-&gt;GetFieldID(env, fcCompFontClass,
230                                    &quot;fcName&quot;, &quot;Ljava/lang/String;&quot;);
231     if ((*env)-&gt;ExceptionOccurred(env)) {
232         return JNI_FALSE;
233     }
234     fcFirstFontFID =
235         (*env)-&gt;GetFieldID(env, fcCompFontClass, &quot;firstFont&quot;,
236                   &quot;Lcom/sun/javafx/font/FontConfigManager$FontConfigFont;&quot;);
237     if ((*env)-&gt;ExceptionOccurred(env)) {
238         return JNI_FALSE;
239     }
240     fcAllFontsFID =
241         (*env)-&gt;GetFieldID(env, fcCompFontClass, &quot;allFonts&quot;,
242                   &quot;[Lcom/sun/javafx/font/FontConfigManager$FontConfigFont;&quot;);
243     if ((*env)-&gt;ExceptionOccurred(env)) {
244         return JNI_FALSE;
245     }
246     fcFontCons = (*env)-&gt;GetMethodID(env, fcFontClass, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
247     if ((*env)-&gt;ExceptionOccurred(env)) {
248         return JNI_FALSE;
249     }
250     familyNameFID = (*env)-&gt;GetFieldID(env, fcFontClass,
251                                       &quot;familyName&quot;, &quot;Ljava/lang/String;&quot;);
252     if ((*env)-&gt;ExceptionOccurred(env)) {
253         return JNI_FALSE;
254     }
255     styleNameFID = (*env)-&gt;GetFieldID(env, fcFontClass,
256                                       &quot;styleStr&quot;, &quot;Ljava/lang/String;&quot;);
257     if ((*env)-&gt;ExceptionOccurred(env)) {
258         return JNI_FALSE;
259     }
260     fullNameFID = (*env)-&gt;GetFieldID(env, fcFontClass,
261                                      &quot;fullName&quot;, &quot;Ljava/lang/String;&quot;);
262     if ((*env)-&gt;ExceptionOccurred(env)) {
263         return JNI_FALSE;
264     }
265     fontFileFID = (*env)-&gt;GetFieldID(env, fcFontClass,
266                                      &quot;fontFile&quot;, &quot;Ljava/lang/String;&quot;);
267     if ((*env)-&gt;ExceptionOccurred(env)) {
268         return JNI_FALSE;
269     }
270     if (fcNameFID == NULL ||
271         fcFirstFontFID == NULL ||
272         fcAllFontsFID == NULL ||
273         fcFontCons == NULL ||
274         familyNameFID == NULL ||
275         styleNameFID == NULL ||
276         fullNameFID == NULL ||
277         fontFileFID == NULL)
278     {
279         return JNI_FALSE;
280     }
281 
282     if ((libfontconfig = openFontConfig()) == NULL) {
283         return JNI_FALSE;
284     }
285 
286     FcNameParse = (FcNameParseFuncType)dlsym(libfontconfig, &quot;FcNameParse&quot;);
287     FcPatternAddString =
288         (FcPatternAddStringFuncType)dlsym(libfontconfig, &quot;FcPatternAddString&quot;);
289     FcConfigSubstitute =
290         (FcConfigSubstituteFuncType)dlsym(libfontconfig, &quot;FcConfigSubstitute&quot;);
291     FcDefaultSubstitute = (FcDefaultSubstituteFuncType)
292         dlsym(libfontconfig, &quot;FcDefaultSubstitute&quot;);
293     FcFontMatch = (FcFontMatchFuncType)dlsym(libfontconfig, &quot;FcFontMatch&quot;);
294     FcPatternGetString =
295         (FcPatternGetStringFuncType)dlsym(libfontconfig, &quot;FcPatternGetString&quot;);
296     FcPatternDestroy =
297         (FcPatternDestroyFuncType)dlsym(libfontconfig, &quot;FcPatternDestroy&quot;);
298     FcPatternGetCharSet =
299         (FcPatternGetCharSetFuncType)dlsym(libfontconfig,
300                                            &quot;FcPatternGetCharSet&quot;);
301     FcFontSort =
302         (FcFontSortFuncType)dlsym(libfontconfig, &quot;FcFontSort&quot;);
303     FcFontSetDestroy =
304         (FcFontSetDestroyFuncType)dlsym(libfontconfig, &quot;FcFontSetDestroy&quot;);
305     FcCharSetUnion =
306         (FcCharSetUnionFuncType)dlsym(libfontconfig, &quot;FcCharSetUnion&quot;);
307     FcCharSetSubtractCount =
308         (FcCharSetSubtractCountFuncType)dlsym(libfontconfig,
309                                               &quot;FcCharSetSubtractCount&quot;);
310 
311     if (FcNameParse          == NULL ||
312         FcPatternAddString   == NULL ||
313         FcConfigSubstitute   == NULL ||
314         FcDefaultSubstitute  == NULL ||
315         FcFontMatch          == NULL ||
316         FcPatternGetString   == NULL ||
317         FcPatternDestroy     == NULL ||
318         FcPatternGetCharSet  == NULL ||
319         FcFontSetDestroy     == NULL ||
320         FcCharSetUnion       == NULL ||
321         FcCharSetSubtractCount == NULL) {/* problem with the library: return.*/
322         closeFontConfig(libfontconfig, JNI_FALSE);
323         return JNI_FALSE;
324     }
325 
326     locale = (*env)-&gt;GetStringUTFChars(env, localeStr, 0);
327 
328     arrlen = (*env)-&gt;GetArrayLength(env, fcCompFontArray);
329     for (i=0; i&lt;arrlen; i++) {
330         FcFontSet* fontset;
331         int fn, j, fontCount, nfonts;
332         unsigned int minGlyphs;
333         FcChar8 **family, **styleStr, **fullname, **file;
334         jarray fcFontArr;
335         jobject fcCompFontObj;
336 
337         fcCompFontObj = (*env)-&gt;GetObjectArrayElement(env, fcCompFontArray, i);
338         if ((*env)-&gt;ExceptionOccurred(env)) {
339             return JNI_FALSE;
340         }
341         fcNameStr =
342             (jstring)((*env)-&gt;GetObjectField(env, fcCompFontObj, fcNameFID));
343         fcName = (*env)-&gt;GetStringUTFChars(env, fcNameStr, 0);
344         if (fcName == NULL) {
345             continue;
346         }
347         pattern = (*FcNameParse)((FcChar8 *)fcName);
348         if (pattern == NULL) {
349             (*env)-&gt;ReleaseStringUTFChars(env, fcNameStr, (const char*)fcName);
350             closeFontConfig(libfontconfig, JNI_FALSE);
351             return JNI_FALSE;
352         }
353 
354         /* locale may not usually be necessary as fontconfig appears to apply
355          * this anyway based on the user&#39;s environment. However we want
356          * to use the value of the JDK startup locale so this should take
357          * care of it.
358          */
359         if (locale != NULL) {
360             (*FcPatternAddString)(pattern, FC_LANG, (unsigned char*)locale);
361         }
362         (*FcConfigSubstitute)(NULL, pattern, FcMatchPattern);
363         (*FcDefaultSubstitute)(pattern);
364         fontset = (*FcFontSort)(NULL, pattern, FcTrue, NULL, &amp;result);
365         if (fontset == NULL) {
366             (*FcPatternDestroy)(pattern);
367             (*env)-&gt;ReleaseStringUTFChars(env, fcNameStr, (const char*)fcName);
368             closeFontConfig(libfontconfig, JNI_FALSE);
369             return JNI_FALSE;
370         }
371 
372         /* fontconfig returned us &quot;nfonts&quot;. It may include Type 1 fonts
373          * but we are going to skip those.
374          * Next create separate C arrays of length nfonts for family file etc.
375          * Inspect the returned fonts and the ones we like (adds enough glyphs)
376          * are added to the arrays and we increment &#39;fontCount&#39;.
377          */
378         nfonts = fontset-&gt;nfont;
379         family   = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));
380         styleStr = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));
381         fullname = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));
382         file     = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));
383         if (family == NULL || styleStr == NULL ||
384             fullname == NULL || file == NULL) {
385             if (family != NULL) {
386                 free(family);
387             }
388             if (styleStr != NULL) {
389                 free(styleStr);
390             }
391             if (fullname != NULL) {
392                 free(fullname);
393             }
394             if (file != NULL) {
395                 free(file);
396             }
397             (*FcPatternDestroy)(pattern);
398             (*FcFontSetDestroy)(fontset);
399             (*env)-&gt;ReleaseStringUTFChars(env, fcNameStr, (const char*)fcName);
400             closeFontConfig(libfontconfig, JNI_FALSE);
401             return JNI_FALSE;
402         }
403         fontCount = 0;
404         minGlyphs = 20;
<a name="1" id="anc1"></a>
405         for (j=0; j&lt;nfonts; j++) {
406             FcPattern *fontPattern = fontset-&gt;fonts[j];
407             FcChar8 *fontformat;
<a name="2" id="anc2"></a><span class="line-modified">408             FcCharSet *unionCharset = NULL, *charset;</span>
409 
410             fontformat = NULL;
411             (*FcPatternGetString)(fontPattern, FC_FONTFORMAT, 0, &amp;fontformat);
412             /* We only want TrueType fonts for Java FX */
413             if (fontformat != NULL
414                 &amp;&amp; (strcmp((char*)fontformat, &quot;TrueType&quot;) != 0)) {
415                 continue;
416             }
417             result = (*FcPatternGetCharSet)(fontPattern,
418                                             FC_CHARSET, 0, &amp;charset);
419             if (result != FcResultMatch) {
420                 free(family);
421                 free(fullname);
422                 free(styleStr);
423                 free(file);
424                 (*FcPatternDestroy)(pattern);
425                 (*FcFontSetDestroy)(fontset);
426                 (*env)-&gt;ReleaseStringUTFChars(env,
427                                               fcNameStr, (const char*)fcName);
428                 closeFontConfig(libfontconfig, JNI_FALSE);
429                 return JNI_FALSE;
430             }
431 
432             /* We don&#39;t want 20 or 30 fonts, so once we hit 10 fonts,
433              * then require that they really be adding value. Too many
434              * adversely affects load time for minimal value-add.
435              * This is still likely far more than we&#39;ve had in the past.
436              */
437             if (j==10) {
438                 minGlyphs = 50;
439             }
440             if (unionCharset == NULL) {
441                 unionCharset = charset;
442             } else {
443                 if ((*FcCharSetSubtractCount)(charset, unionCharset)
444                     &gt; minGlyphs) {
445                     unionCharset = (* FcCharSetUnion)(unionCharset, charset);
446                 } else {
447                     continue;
448                 }
449             }
450 
451             fontCount++; // found a font we will use.
452             (*FcPatternGetString)(fontPattern, FC_FILE, 0, &amp;file[j]);
453             (*FcPatternGetString)(fontPattern, FC_FAMILY, 0, &amp;family[j]);
454             (*FcPatternGetString)(fontPattern, FC_STYLE, 0, &amp;styleStr[j]);
455             (*FcPatternGetString)(fontPattern, FC_FULLNAME, 0, &amp;fullname[j]);
456             if (!includeFallbacks) {
457                 break;
458             }
<a name="3" id="anc3"></a>






459         }
460 
461         /* Once we get here &#39;fontCount&#39; is the number of returned fonts
462          * we actually want to use, so we create &#39;fcFontArr&#39; of that length.
463          * The non-null entries of &quot;family[]&quot; etc are those fonts.
464          * Then loop again over all nfonts adding just those non-null ones
465          * to &#39;fcFontArr&#39;. If its null (we didn&#39;t want the font)
466          * then we don&#39;t enter the main body.
467          * So we should never get more than &#39;fontCount&#39; entries.
468          */
469         if (includeFallbacks) {
470             fcFontArr =
471                 (*env)-&gt;NewObjectArray(env, fontCount, fcFontClass, NULL);
472             (*env)-&gt;SetObjectField(env,
473                                    fcCompFontObj, fcAllFontsFID, fcFontArr);
474         } else {
475             fcFontArr = NULL;
476         }
477         fn=0;
478 
479         for (j=0;j&lt;nfonts;j++) {
480             if (family[j] != NULL) {
481                 jobject fcFont =
482                     (*env)-&gt;NewObject(env, fcFontClass, fcFontCons);
483                 jstr = (*env)-&gt;NewStringUTF(env, (const char*)family[j]);
484                 (*env)-&gt;SetObjectField(env, fcFont, familyNameFID, jstr);
485                 (*env)-&gt;DeleteLocalRef(env, jstr);
486                 if (file[j] != NULL) {
487                     jstr = (*env)-&gt;NewStringUTF(env, (const char*)file[j]);
488                     (*env)-&gt;SetObjectField(env, fcFont, fontFileFID, jstr);
489                     (*env)-&gt;DeleteLocalRef(env, jstr);
490                 }
491                 if (styleStr[j] != NULL) {
492                     jstr = (*env)-&gt;NewStringUTF(env, (const char*)styleStr[j]);
493                     (*env)-&gt;SetObjectField(env, fcFont, styleNameFID, jstr);
494                     (*env)-&gt;DeleteLocalRef(env, jstr);
495                 }
496                 if (fullname[j] != NULL) {
497                     jstr = (*env)-&gt;NewStringUTF(env, (const char*)fullname[j]);
498                     (*env)-&gt;SetObjectField(env, fcFont, fullNameFID, jstr);
499                     (*env)-&gt;DeleteLocalRef(env, jstr);
500                 }
501                 if (fn==0) {
502                     (*env)-&gt;SetObjectField(env, fcCompFontObj,
503                                            fcFirstFontFID, fcFont);
504                 }
505                 if (includeFallbacks &amp;&amp; fcFontArr != NULL) {
506                     (*env)-&gt;SetObjectArrayElement(env, fcFontArr, fn++,fcFont);
507                     (*env)-&gt;DeleteLocalRef(env, fcFont);
508                 } else {
509                     (*env)-&gt;DeleteLocalRef(env, fcFont);
510                     break;
511                 }
512             }
513         }
514         if (fcFontArr != NULL) {
515             (*env)-&gt;DeleteLocalRef(env, fcFontArr);
516         }
517         (*env)-&gt;ReleaseStringUTFChars (env, fcNameStr, (const char*)fcName);
518         (*env)-&gt;DeleteLocalRef(env, fcNameStr);
519         (*FcFontSetDestroy)(fontset);
520         (*FcPatternDestroy)(pattern);
521         free(family);
522         free(styleStr);
523         free(fullname);
524         free(file);
525     }
526 
527     /* release resources and close the &quot;.so&quot; */
528 
529     if (locale) {
530         (*env)-&gt;ReleaseStringUTFChars (env, localeStr, (const char*)locale);
531     }
532     closeFontConfig(libfontconfig, JNI_TRUE);
533     return JNI_TRUE;
534 }
535 
536 
537 JNIEXPORT jboolean JNICALL
538 Java_com_sun_javafx_font_FontConfigManager_populateMapsNative
539 (JNIEnv *env, jclass obj,
540  jobject fontToFileMap,
541  jobject fontToFamilyNameMap,
542  jobject familyToFontListMap,
543  jobject locale
544  )
545 {
546     void *libfontconfig;
547     const char *lang;
548     int langLen, f;
549     FcPatternBuildFuncType FcPatternBuild;
550     FcObjectSetFuncType FcObjectSetBuild;
551     FcFontListFuncType FcFontList;
552     FcPatternGetStringFuncType FcPatternGetString;
553     FcFontSetDestroyFuncType FcFontSetDestroy;
554     FcPattern *pattern;
555     FcObjectSet *objset;
556     FcFontSet *fontSet;
557     jclass classID, arrayListClass;
558     jmethodID arrayListCtr, addMID, getMID;
559     jmethodID toLowerCaseMID;
560     jmethodID putMID, containsKeyMID;
561     jboolean debugFC = getenv(&quot;PRISM_FONTCONFIG_DEBUG&quot;) != NULL;
562 
563     if (fontToFileMap == NULL ||
564         fontToFamilyNameMap == NULL ||
565         familyToFontListMap == NULL ||
566         locale == NULL)
567     {
568         if (debugFC) {
569             fprintf(stderr, &quot;Null arg to native fontconfig lookup&quot;);
570         }
571         return JNI_FALSE;
572     }
573     if ((libfontconfig = openFontConfig()) == NULL) {
574         if (debugFC) {
575             fprintf(stderr,&quot;Could not open libfontconfig\n&quot;);
576         }
577         return JNI_FALSE;
578     }
579 
580     FcPatternBuild     =
581         (FcPatternBuildFuncType)dlsym(libfontconfig, &quot;FcPatternBuild&quot;);
582     FcObjectSetBuild   =
583         (FcObjectSetFuncType)dlsym(libfontconfig, &quot;FcObjectSetBuild&quot;);
584     FcFontList         =
585         (FcFontListFuncType)dlsym(libfontconfig, &quot;FcFontList&quot;);
586     FcPatternGetString =
587         (FcPatternGetStringFuncType)dlsym(libfontconfig, &quot;FcPatternGetString&quot;);
588     FcFontSetDestroy   =
589         (FcFontSetDestroyFuncType)dlsym(libfontconfig, &quot;FcFontSetDestroy&quot;);
590 
591     if (FcPatternBuild     == NULL ||
592         FcObjectSetBuild   == NULL ||
593         FcPatternGetString == NULL ||
594         FcFontList         == NULL ||
595         FcFontSetDestroy   == NULL) { /* problem with the library: return. */
596         if (debugFC) {
597            fprintf(stderr,&quot;Could not find symbols in libfontconfig\n&quot;);
598         }
599         closeFontConfig(libfontconfig, JNI_FALSE);
600         return JNI_FALSE;
601     }
602 
603     // Deleting local refs as we go along so this should be plenty
604     // Unlikely to matter even if it fails.
605     (*env)-&gt;EnsureLocalCapacity(env, 64);
606     if ((*env)-&gt;ExceptionOccurred(env)) {
607         return JNI_FALSE;
608     }
609     classID = (*env)-&gt;FindClass(env, &quot;java/util/HashMap&quot;);
610     if ((*env)-&gt;ExceptionOccurred(env) || classID == NULL) {
611         return JNI_FALSE;
612     }
613     getMID = (*env)-&gt;GetMethodID(env, classID, &quot;get&quot;,
614                  &quot;(Ljava/lang/Object;)Ljava/lang/Object;&quot;);
615     if ((*env)-&gt;ExceptionOccurred(env) || getMID == NULL) {
616         return JNI_FALSE;
617     }
618     putMID = (*env)-&gt;GetMethodID(env, classID, &quot;put&quot;,
619                  &quot;(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;&quot;);
620     if ((*env)-&gt;ExceptionOccurred(env) || putMID == NULL) {
621         return JNI_FALSE;
622     }
623 
624     containsKeyMID = (*env)-&gt;GetMethodID(env, classID, &quot;containsKey&quot;,
625                                              &quot;(Ljava/lang/Object;)Z&quot;);
626     if ((*env)-&gt;ExceptionOccurred(env) || containsKeyMID == NULL) {
627         return JNI_FALSE;
628     }
629 
630     arrayListClass = (*env)-&gt;FindClass(env, &quot;java/util/ArrayList&quot;);
631     if ((*env)-&gt;ExceptionOccurred(env) || arrayListClass == NULL) {
632         return JNI_FALSE;
633     }
634     arrayListCtr = (*env)-&gt;GetMethodID(env, arrayListClass,
635                                               &quot;&lt;init&gt;&quot;, &quot;(I)V&quot;);
636     if ((*env)-&gt;ExceptionOccurred(env) || arrayListCtr == NULL) {
637         return JNI_FALSE;
638     }
639     addMID = (*env)-&gt;GetMethodID(env, arrayListClass,
640                                  &quot;add&quot;, &quot;(Ljava/lang/Object;)Z&quot;);
641     if ((*env)-&gt;ExceptionOccurred(env) || addMID == NULL) {
642         return JNI_FALSE;
643     }
644 
645     classID = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
646     if ((*env)-&gt;ExceptionOccurred(env) || classID == NULL) {
647         return JNI_FALSE;
648     }
649     toLowerCaseMID =
650         (*env)-&gt;GetMethodID(env, classID, &quot;toLowerCase&quot;,
651                             &quot;(Ljava/util/Locale;)Ljava/lang/String;&quot;);
652     if ((*env)-&gt;ExceptionOccurred(env) || toLowerCaseMID == NULL) {
653         return JNI_FALSE;
654     }
655     pattern = (*FcPatternBuild)(NULL, FC_OUTLINE, FcTypeBool, FcTrue, NULL);
656     objset = (*FcObjectSetBuild)(FC_FAMILY, FC_FAMILYLANG,
657                                  FC_FULLNAME, FC_FULLNAMELANG,
658                                  FC_FILE, FC_FONTFORMAT, NULL);
659     fontSet = (*FcFontList)(NULL, pattern, objset);
660 
661     if (debugFC) {
662         fprintf(stderr,&quot;Fontconfig found %d fonts\n&quot;, fontSet-&gt;nfont);
663     }
664 
665     for (f=0; f &lt; fontSet-&gt;nfont; f++) {
666         int n=0, done=0;
667         FcPattern *fp = fontSet-&gt;fonts[f];
668 
669         FcChar8 *family = NULL;
670         FcChar8 *familyEN = NULL;
671         FcChar8 *familyLang = NULL;
672         FcChar8 *fullName = NULL;
673         FcChar8 *fullNameEN = NULL;
674         FcChar8 *fullNameLang = NULL;
675         FcChar8 *file;
676         FcResult res;
677         jstring jFileStr;
678         jstring jFamilyStr, jFamilyStrLC;
679         jstring jFullNameStr, jFullNameStrLC;
680         jobject jList;
681         FcChar8 *format = NULL;
682 
683         /* We only want TrueType &amp; OpenType fonts for Java FX */
684         format = NULL;
685         if ((*FcPatternGetString)(fp, FC_FONTFORMAT, 0, &amp;format)
686             != FcResultMatch) {
687             continue;
688         }
689         if (format == NULL ||
690             ((strcmp((char*)format, &quot;TrueType&quot;) != 0) &amp;&amp;
691              (strcmp((char*)format, &quot;CFF&quot;) != 0))) {
692             continue;
693         }
694         if ((*FcPatternGetString)(fp, FC_FILE, 0, &amp;file) != FcResultMatch) {
695             continue;
696         } else {
697             char pathname[PATH_MAX+1];
698             char* path = realpath((char*)file, pathname);
699             if (path == NULL) {
700                 continue;
701             } else {
702                 file = (FcChar8*)path;
703             }
704         }
705         n=0;
706         while (!done) {
707             family = NULL;
708             familyLang = NULL;
709             fullName = NULL;
710             fullNameLang = NULL;
711 
712             if (((*FcPatternGetString)(fp, FC_FAMILY, n, &amp;family)
713                 == FcResultMatch) &amp;&amp;
714                 ((*FcPatternGetString)(fp, FC_FAMILYLANG, n, &amp;familyLang)
715                 == FcResultMatch) &amp;&amp;
716                 (family != NULL &amp;&amp; familyLang != NULL) &amp;&amp;
717                 (familyEN == NULL || (strcmp((char*)familyLang, &quot;en&quot;) == 0)))
718             {
719                 familyEN = family;
720             }
721             if (((*FcPatternGetString)(fp, FC_FULLNAME, n, &amp;fullName)
722                 == FcResultMatch) &amp;&amp;
723                 ((*FcPatternGetString)(fp, FC_FULLNAMELANG, n, &amp;fullNameLang)
724                 == FcResultMatch) &amp;&amp;
725                 (fullName != NULL &amp;&amp; fullNameLang != NULL) &amp;&amp;
726                 (fullNameEN == NULL ||
727                  (strcmp((char*)fullNameLang,&quot;en&quot;) == 0)))
728             {
729                 fullNameEN = fullName;
730             }
731             if (family == NULL &amp;&amp; fullName == NULL) {
732                 done = 1;
733                 break;
734             }
735             n++;
736         }
737 
738         if (debugFC) {
739             fprintf(stderr,&quot;Read FC font family=%s fullname=%s file=%s\n&quot;,
740                     (familyEN == NULL) ? &quot;null&quot; : (char*)familyEN,
741                     (fullNameEN == NULL) ? &quot;null&quot; : (char*)fullNameEN,
742                     (file == NULL) ? &quot;null&quot; : (char*)file);
743             fflush(stderr);
744         }
745 
746         /* We set the names from the first found names for a font, updating
747          * to the English ones as they are found. If these are null
748          * we must not have found any name, so we&#39;d better skip.
749          */
750         if (familyEN == NULL || fullNameEN == NULL || file == NULL) {
751             if (debugFC) {
752                 fprintf(stderr,&quot;FC: Skipping on error for above font\n&quot;);
753                 fflush(stderr);
754             }
755             continue;
756         }
757 
758         jFileStr = (*env)-&gt;NewStringUTF(env, (const char*)file);
759         jFamilyStr = (*env)-&gt;NewStringUTF(env, (const char*)familyEN);
760         jFullNameStr = (*env)-&gt;NewStringUTF(env, (const char*)fullNameEN);
761 
762         if (jFileStr == NULL || jFamilyStr == NULL || jFullNameStr == NULL) {
763             if (debugFC) {
764                 fprintf(stderr,&quot;Failed to create string object&quot;);
765             }
766             continue;
767         }
768 
769         jFamilyStrLC = (*env)-&gt;CallObjectMethod(env, jFamilyStr,
770                                                 toLowerCaseMID, locale);
771         if ((*env)-&gt;ExceptionOccurred(env)) {
772             return JNI_FALSE;
773         }
774         jFullNameStrLC = (*env)-&gt;CallObjectMethod(env, jFullNameStr,
775                                                   toLowerCaseMID, locale);
776         if ((*env)-&gt;ExceptionOccurred(env)) {
777             return JNI_FALSE;
778         }
779         if (jFamilyStrLC == NULL || jFullNameStrLC == NULL) {
780             if (debugFC) {
781                 fprintf(stderr,&quot;Failed to create lower case string object&quot;);
782                 fflush(stderr);
783             }
784             continue;
785         }
786 
787         (*env)-&gt;CallObjectMethod(env, fontToFileMap, putMID,
788                                  jFullNameStrLC, jFileStr);
789         if ((*env)-&gt;ExceptionOccurred(env)) {
790             return JNI_FALSE;
791         }
792         (*env)-&gt;CallObjectMethod(env, fontToFamilyNameMap, putMID,
793                                  jFullNameStrLC, jFamilyStr);
794         if ((*env)-&gt;ExceptionOccurred(env)) {
795             return JNI_FALSE;
796         }
797         jList = (*env)-&gt;CallObjectMethod(env, familyToFontListMap,
798                                          getMID, jFamilyStrLC);
799         if ((*env)-&gt;ExceptionOccurred(env)) {
800             return JNI_FALSE;
801         }
802         if (jList == NULL) {
803             jList = (*env)-&gt;NewObject(env, arrayListClass, arrayListCtr, 4);
804             if ((*env)-&gt;ExceptionOccurred(env)) {
805                 return JNI_FALSE;
806             }
807             (*env)-&gt;CallObjectMethod(env, familyToFontListMap,
808                                      putMID, jFamilyStrLC, jList);
809             if ((*env)-&gt;ExceptionOccurred(env)) {
810                 return JNI_FALSE;
811             }
812         }
813         if (jList == NULL) {
814             if (debugFC) {
815                 fprintf(stderr,&quot;Fontconfig: List is null\n&quot;);
816                 fflush(stderr);
817             }
818             continue;
819         }
820         (*env)-&gt;CallObjectMethod(env, jList, addMID, jFullNameStr);
821         if ((*env)-&gt;ExceptionOccurred(env)) {
822             return JNI_FALSE;
823         }
824         /* Now referenced from the passed in maps, so can delete local refs. */
825         (*env)-&gt;DeleteLocalRef(env, jFileStr);
826         (*env)-&gt;DeleteLocalRef(env, jFamilyStr);
827         (*env)-&gt;DeleteLocalRef(env, jFamilyStrLC);
828         (*env)-&gt;DeleteLocalRef(env, jFullNameStr);
829         (*env)-&gt;DeleteLocalRef(env, jFullNameStrLC);
830         (*env)-&gt;DeleteLocalRef(env, jList);
831 
832     }
833     if (debugFC) {
834         fprintf(stderr,&quot;Done enumerating fontconfig fonts\n&quot;);
835         fflush(stderr);
836     }
837     (*FcFontSetDestroy)(fontSet);
838     closeFontConfig(libfontconfig, JNI_TRUE);
839 
840     return JNI_TRUE;
841 }
842 
843 
844 #endif /* __linux__ */
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>