diff a/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGPointLight.java b/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGPointLight.java
--- a/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGPointLight.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGPointLight.java
@@ -66,45 +66,53 @@
     public double getCa() {
         return ca;
     }
 
     public void setCa(double ca) {
-        this.ca = ca;
-        visualsChanged();
+        if (this.ca != ca) {
+            this.ca = ca;
+            visualsChanged();
+        }
     }
 
 
     private double la = DEFAULT_LA;
 
     public double getLa() {
         return la;
     }
 
     public void setLa(double la) {
-        this.la = la;
-        visualsChanged();
+        if (this.la != la) {
+            this.la = la;
+            visualsChanged();
+        }
     }
 
 
     private double qa = DEFAULT_QA;
 
     public double getQa() {
         return qa;
     }
 
     public void setQa(double qa) {
-        this.qa = qa;
-        visualsChanged();
+        if (this.qa != qa) {
+            this.qa = qa;
+            visualsChanged();
+        }
     }
 
 
     private double maxRange = DEFAULT_MAX_RANGE;
 
     public double getMaxRange() {
         return maxRange;
     }
 
     public void setMaxRange(double maxRange) {
-        this.maxRange = maxRange < 0 ? 0 : maxRange;
-        visualsChanged();
+        if (this.maxRange != maxRange) {
+            this.maxRange = maxRange < 0 ? 0 : maxRange;
+            visualsChanged();
+        }
     }
 }
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/d3d/D3DContext.java b/modules/javafx.graphics/src/main/java/com/sun/prism/d3d/D3DContext.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/d3d/D3DContext.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/prism/d3d/D3DContext.java
@@ -551,11 +551,11 @@
     void setAmbientLight(long nativeMeshView, float r, float g, float b) {
         nSetAmbientLight(pContext, nativeMeshView, r, g, b);
     }
 
     void setPointLight(long nativeMeshView, int index, float x, float y, float z,
-            float r, float g, float b, float w, float ca, float la, float qa,  float maxRange) {
+            float r, float g, float b, float w, float ca, float la, float qa, float maxRange) {
         nSetPointLight(pContext, nativeMeshView, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);
     }
 
     @Override
     protected void renderQuads(float coordArray[], byte colorArray[], int numVertices) {
diff a/modules/javafx.graphics/src/main/java/javafx/scene/PointLight.java b/modules/javafx.graphics/src/main/java/javafx/scene/PointLight.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/PointLight.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/PointLight.java
@@ -91,22 +91,20 @@
     public PointLight(Color color) {
         super(color);
     }
 
     /**
-     * The maximum range of this {@code PointLight}. For a pixel to be affected by this light, its distance to
-     * the light source must be less than or equal to the light's maximum range. Any negative value will treated
-     * as 0.
+     * The maximum range of this {@code PointLight}. For a pixel to be affected by this light, its distance to the
+     * light source must be less than or equal to the light's maximum range. Any negative value will be treated as 0.
      * <p>
      * Lower {@code maxRange} values can give better performance as pixels outside the range of the light
      * will not require complex calculation. The attenuation formula can be used to calculate a realistic
-     * {@code maxRange} value by finding the where the attenuation is close enough to 0.
+     * {@code maxRange} value by finding the distance where the attenuation is close enough to 0.
      * <p>
-     * Nodes that are inside the light's range can still be excluded from the light's effect
-     * by removing them from its {@link #getScope() scope} (or including them in its
-     * {@link #getExclusionScope() exclusion scope}). If a node is known to always be
-     * outside of the light's range, it is more performant to exclude it from its scope.
+     * Nodes that are inside the light's range can still be excluded from the light's effect by removing them from
+     * its {@link #getScope() scope} (or including them in its {@link #getExclusionScope() exclusion scope}). If a
+     * node is known to always be outside of the light's range, it is more performant to exclude it from its scope.
      *
      * @defaultValue {@code Double.POSITIVE_INFINITY}
      * @since 14
      */
     private DoubleProperty maxRange;
