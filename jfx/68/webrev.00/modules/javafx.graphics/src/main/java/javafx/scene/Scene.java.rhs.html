<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/javafx/scene/Scene.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene;
  27 
  28 import com.sun.glass.ui.Application;
  29 import com.sun.glass.ui.Accessible;
  30 import com.sun.javafx.util.Logging;
  31 import com.sun.javafx.util.Utils;
  32 import com.sun.javafx.application.PlatformImpl;
  33 import com.sun.javafx.collections.TrackableObservableList;
  34 import com.sun.javafx.css.StyleManager;
  35 import com.sun.javafx.cursor.CursorFrame;
  36 import com.sun.javafx.event.EventQueue;
  37 import com.sun.javafx.geom.PickRay;
  38 import com.sun.javafx.geom.Vec3d;
  39 import com.sun.javafx.geom.transform.BaseTransform;
  40 import com.sun.javafx.perf.PerformanceTracker;
  41 import com.sun.javafx.scene.CssFlags;
  42 import com.sun.javafx.scene.LayoutFlags;
  43 import com.sun.javafx.scene.SceneEventDispatcher;
  44 import com.sun.javafx.scene.SceneHelper;
  45 import com.sun.javafx.scene.input.DragboardHelper;
  46 import com.sun.javafx.scene.input.ExtendedInputMethodRequests;
  47 import com.sun.javafx.scene.input.InputEventUtils;
  48 import com.sun.javafx.scene.input.PickResultChooser;
  49 import com.sun.javafx.scene.traversal.Direction;
  50 import com.sun.javafx.scene.traversal.SceneTraversalEngine;
  51 import com.sun.javafx.scene.traversal.TopMostTraversalEngine;
  52 import com.sun.javafx.sg.prism.NGCamera;
  53 import com.sun.javafx.sg.prism.NGLightBase;
  54 import com.sun.javafx.tk.*;
  55 import com.sun.prism.impl.PrismSettings;
  56 
  57 import javafx.animation.KeyFrame;
  58 import javafx.animation.Timeline;
  59 import javafx.application.ConditionalFeature;
  60 import javafx.application.Platform;
  61 import javafx.beans.DefaultProperty;
  62 import javafx.beans.InvalidationListener;
  63 import javafx.beans.NamedArg;
  64 import javafx.beans.property.*;
  65 import javafx.collections.FXCollections;
  66 import javafx.collections.ListChangeListener.Change;
  67 import javafx.collections.ObservableList;
  68 import javafx.collections.ObservableMap;
  69 import javafx.css.CssMetaData;
  70 import javafx.css.StyleableObjectProperty;
  71 import javafx.event.*;
  72 import javafx.geometry.*;
  73 import javafx.scene.image.WritableImage;
  74 import javafx.scene.input.*;
  75 import javafx.scene.paint.Color;
  76 import javafx.scene.paint.Paint;
  77 import javafx.stage.PopupWindow;
  78 import javafx.stage.Stage;
  79 import javafx.stage.StageStyle;
  80 import javafx.stage.Window;
  81 import javafx.util.Callback;
  82 import javafx.util.Duration;
  83 import com.sun.javafx.logging.PlatformLogger;
  84 import com.sun.javafx.logging.PlatformLogger.Level;
  85 
  86 import java.security.AccessControlContext;
  87 import java.security.AccessController;
  88 import java.security.PrivilegedAction;
  89 import java.util.*;
  90 import java.util.concurrent.CopyOnWriteArrayList;
  91 
  92 import com.sun.javafx.logging.PulseLogger;
  93 
  94 import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;
  95 import com.sun.javafx.scene.NodeHelper;
  96 import com.sun.javafx.stage.WindowHelper;
  97 import com.sun.javafx.scene.input.ClipboardHelper;
  98 import com.sun.javafx.scene.input.TouchPointHelper;
  99 import java.lang.ref.WeakReference;
 100 
 101 /**
 102  * The JavaFX {@code Scene} class is the container for all content in a scene graph.
 103  * The background of the scene is filled as specified by the {@code fill} property.
 104  * &lt;p&gt;
 105  * The application must specify the root {@code Node} for the scene graph by setting
 106  * the {@code root} property.   If a {@code Group} is used as the root, the
 107  * contents of the scene graph will be clipped by the scene&#39;s width and height and
 108  * changes to the scene&#39;s size (if user resizes the stage) will not alter the
 109  * layout of the scene graph. If a resizable node (layout {@code Region} or
 110  * {@code Control}) is set as the root, then the root&#39;s size will track the
 111  * scene&#39;s size, causing the contents to be relayed out as necessary.
 112  * &lt;p&gt;
 113  * The scene&#39;s size may be initialized by the application during construction.
 114  * If no size is specified, the scene will automatically compute its initial
 115  * size based on the preferred size of its content. If only one dimension is specified,
 116  * the other dimension is computed using the specified dimension, respecting content bias
 117  * of a root.
 118  * &lt;p&gt;
 119  * An application may request depth buffer support or scene anti-aliasing
 120  * support at the creation of a {@code Scene}. A scene with only 2D shapes and
 121  * without any 3D transforms does not need a depth buffer nor scene
 122  * anti-aliasing support. A scene containing 3D shapes or 2D shapes with 3D
 123  * transforms may use depth buffer support for proper depth sorted rendering; to
 124  * avoid depth fighting (also known as Z fighting), disable depth testing on 2D
 125  * shapes that have no 3D transforms. See
 126  * {@link Node#depthTestProperty() depthTest} for more information. A scene with
 127  * 3D shapes may enable scene anti-aliasing to improve its rendering quality.
 128  * &lt;p&gt;
 129  * The depthBuffer and antiAliasing flags are conditional features. With the
 130  * respective default values of: false and {@code SceneAntialiasing.DISABLED}.
 131  * See {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 132  * for more information.
 133  * &lt;p&gt;
 134  * A default headlight will be added to a scene that contains one or more
 135  * {@code Shape3D} nodes, but no light nodes. This light source is a
 136  * {@code Color.WHITE} {@code PointLight} placed at the camera position.
 137  *
 138  * &lt;p&gt;
 139  * A {@code Scene} may be created and modified on any thread until it is attached
 140  * to a {@link Window} that is {@link Window#isShowing() showing}.
 141  * After that, it must be modified only on the JavaFX Application Thread.
 142  * Note that {@code Scene} is not thread-safe; modifying a {@code Scene} on
 143  * multiple threads at the same time will lead to unpredictable results and
 144  * must be avoided.
 145  * &lt;/p&gt;
 146  *
 147  * &lt;p&gt;
 148  * The JavaFX Application Thread is created as part of the startup process for
 149  * the JavaFX runtime. See the {@link javafx.application.Application} class and
 150  * the {@link Platform#startup(Runnable)} method for more information.
 151  * &lt;/p&gt;
 152  *
 153  * &lt;p&gt;Example:&lt;/p&gt;
 154  *
 155  * &lt;pre&gt;
 156 import javafx.scene.*;
 157 import javafx.scene.paint.*;
 158 import javafx.scene.shape.*;
 159 
 160 Group root = new Group();
 161 Scene s = new Scene(root, 300, 300, Color.BLACK);
 162 
 163 Rectangle r = new Rectangle(25,25,250,250);
 164 r.setFill(Color.BLUE);
 165 
 166 root.getChildren().add(r);
 167  * &lt;/pre&gt;
 168  *
 169  * @since JavaFX 2.0
 170  */
 171 @DefaultProperty(&quot;root&quot;)
 172 public class Scene implements EventTarget {
 173 
 174     private double widthSetByUser = -1.0;
 175     private double heightSetByUser = -1.0;
 176     private boolean sizeInitialized = false;
 177     private final boolean depthBuffer;
 178     private final SceneAntialiasing antiAliasing;
 179 
 180     private EnumSet&lt;DirtyBits&gt; dirtyBits = EnumSet.noneOf(DirtyBits.class);
 181 
 182     final AccessControlContext acc = AccessController.getContext();
 183 
 184     private Camera defaultCamera;
 185 
 186     /**
 187      * A node that is temporarily responsible for the FOCUS_NODE
 188      * accessibility attribute. E.g. a currently active MenuBar.
 189      */
 190     private Node transientFocusContainer;
 191 
 192     //Neither width nor height are initialized and will be calculated according to content when this Scene
 193     //is shown for the first time.
 194 //    public Scene() {
 195 //        //this(-1, -1, (Parent) new Group());
 196 //        this(-1, -1, (Parent)null);
 197 //    }
 198 
 199     /**
 200      * Creates a Scene for a specific root Node.
 201      *
 202      * @param root The root node of the scene graph
 203      *
 204      * @throws NullPointerException if root is null
 205      */
 206     public Scene(@NamedArg(&quot;root&quot;) Parent root) {
 207         this(root, -1, -1, Color.WHITE, false, SceneAntialiasing.DISABLED);
 208     }
 209 
 210 //Public constructor initializing public-init properties
 211 //When width &lt; 0, and or height &lt; 0 is passed, then width and/or height are understood as unitialized
 212 //Unitialized dimension is calculated when Scene is shown for the first time.
 213 //    public Scene(
 214 //            @Default(&quot;-1&quot;) double width,
 215 //            @Default(&quot;-1&quot;) double height) {
 216 //        //this(width, height, (Parent)new Group());
 217 //        this(width, height, (Parent)null);
 218 //    }
 219 //
 220 //    public Scene(double width, double height, Paint fill) {
 221 //        //this(width, height, (Parent) new Group());
 222 //        this(width, height, (Parent)null);
 223 //        setFill(fill);
 224 //    }
 225 
 226     /**
 227      * Creates a Scene for a specific root Node with a specific size.
 228      *
 229      * @param root The root node of the scene graph
 230      * @param width The width of the scene
 231      * @param height The height of the scene
 232      *
 233      * @throws NullPointerException if root is null
 234      */
 235     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height) {
 236         this(root, width, height, Color.WHITE, false, SceneAntialiasing.DISABLED);
 237     }
 238 
 239     /**
 240      * Creates a Scene for a specific root Node with a fill.
 241      *
 242      * @param root The parent
 243      * @param fill The fill
 244      *
 245      * @throws NullPointerException if root is null
 246      */
 247     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
 248         this(root, -1, -1, fill, false, SceneAntialiasing.DISABLED);
 249     }
 250 
 251     /**
 252      * Creates a Scene for a specific root Node with a specific size and fill.
 253      *
 254      * @param root The root node of the scene graph
 255      * @param width The width of the scene
 256      * @param height The height of the scene
 257      * @param fill The fill
 258      *
 259      * @throws NullPointerException if root is null
 260      */
 261     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height,
 262             @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
 263         this(root, width, height, fill, false, SceneAntialiasing.DISABLED);
 264     }
 265 
 266     /**
 267      * Constructs a scene consisting of a root, with a dimension of width and
 268      * height, and specifies whether a depth buffer is created for this scene.
 269      * &lt;p&gt;
 270      * A scene with only 2D shapes and without any 3D transforms does not need a
 271      * depth buffer. A scene containing 3D shapes or 2D shapes with 3D
 272      * transforms may use depth buffer support for proper depth sorted
 273      * rendering; to avoid depth fighting (also known as Z fighting), disable
 274      * depth testing on 2D shapes that have no 3D transforms. See
 275      * {@link Node#depthTestProperty() depthTest} for more information.
 276      *
 277      * @param root The root node of the scene graph
 278      * @param width The width of the scene
 279      * @param height The height of the scene
 280      * @param depthBuffer The depth buffer flag
 281      * &lt;p&gt;
 282      * The depthBuffer flag is a conditional feature and its default value is
 283      * false. See
 284      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 285      * for more information.
 286      *
 287      * @throws NullPointerException if root is null
 288      *
 289      * @see javafx.scene.Node#setDepthTest(DepthTest)
 290      */
 291     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height, @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer) {
 292         this(root, width, height, Color.WHITE, depthBuffer, SceneAntialiasing.DISABLED);
 293     }
 294 
 295     /**
 296      * Constructs a scene consisting of a root, with a dimension of width and
 297      * height, specifies whether a depth buffer is created for this scene and
 298      * specifies whether scene anti-aliasing is requested.
 299      * &lt;p&gt;
 300      * A scene with only 2D shapes and without any 3D transforms does not need a
 301      * depth buffer nor scene anti-aliasing support. A scene containing 3D
 302      * shapes or 2D shapes with 3D transforms may use depth buffer support for
 303      * proper depth sorted rendering; to avoid depth fighting (also known as Z
 304      * fighting), disable depth testing on 2D shapes that have no 3D transforms.
 305      * See {@link Node#depthTestProperty() depthTest} for more information. A
 306      * scene with 3D shapes may enable scene anti-aliasing to improve its
 307      * rendering quality.
 308      *
 309      * @param root The root node of the scene graph
 310      * @param width The width of the scene
 311      * @param height The height of the scene
 312      * @param depthBuffer The depth buffer flag
 313      * @param antiAliasing The scene anti-aliasing attribute. A value of
 314      * {@code null} is treated as DISABLED.
 315      * &lt;p&gt;
 316      * The depthBuffer and antiAliasing are conditional features. With the
 317      * respective default values of: false and {@code SceneAntialiasing.DISABLED}. See
 318      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 319      * for more information.
 320      *
 321      * @throws NullPointerException if root is null
 322      *
 323      * @see javafx.scene.Node#setDepthTest(DepthTest)
 324      * @since JavaFX 8.0
 325      */
 326     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height,
 327             @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer,
 328             @NamedArg(value=&quot;antiAliasing&quot;, defaultValue=&quot;DISABLED&quot;) SceneAntialiasing antiAliasing) {
 329         this(root, width, height, Color.WHITE, depthBuffer, antiAliasing);
 330 
 331         if (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED &amp;&amp;
 332                 !Toolkit.getToolkit().isMSAASupported())
 333         {
 334             String logname = Scene.class.getName();
 335             PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;
 336                 + &quot;antiAliasing&quot;);
 337         }
 338     }
 339 
 340     private Scene(Parent root, double width, double height, Paint fill,
 341             boolean depthBuffer, SceneAntialiasing antiAliasing) {
 342         this.depthBuffer = depthBuffer;
 343         this.antiAliasing = antiAliasing;
 344         if (root == null) {
 345             throw new NullPointerException(&quot;Root cannot be null&quot;);
 346         }
 347 
 348         if ((depthBuffer || (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED))
 349                 &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
 350             String logname = Scene.class.getName();
 351             PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;
 352                     + &quot;ConditionalFeature.SCENE3D&quot;);
 353         }
 354 
 355         init();
 356         setRoot(root);
 357         init(width, height);
 358         setFill(fill);
 359     }
 360 
 361     static {
 362             PerformanceTracker.setSceneAccessor(new PerformanceTracker.SceneAccessor() {
 363                 public void setPerfTracker(Scene scene, PerformanceTracker tracker) {
 364                     synchronized (trackerMonitor) {
 365                         scene.tracker = tracker;
 366                     }
 367                 }
 368                 public PerformanceTracker getPerfTracker(Scene scene) {
 369                     synchronized (trackerMonitor) {
 370                         return scene.tracker;
 371                     }
 372                 }
 373             });
 374             SceneHelper.setSceneAccessor(
 375                     new SceneHelper.SceneAccessor() {
 376                         @Override
 377                         public void enableInputMethodEvents(Scene scene, boolean enable) {
 378                             scene.enableInputMethodEvents(enable);
 379                         }
 380 
 381                         @Override
 382                         public void processKeyEvent(Scene scene, KeyEvent e) {
 383                             scene.processKeyEvent(e);
 384                         }
 385 
 386                         @Override
 387                         public void processMouseEvent(Scene scene, MouseEvent e) {
 388                             scene.processMouseEvent(e);
 389                         }
 390 
 391                         @Override
 392                         public void preferredSize(Scene scene) {
 393                             scene.preferredSize();
 394                         }
 395 
 396                         @Override
 397                         public void disposePeer(Scene scene) {
 398                             scene.disposePeer();
 399                         }
 400 
 401                         @Override
 402                         public void initPeer(Scene scene) {
 403                             scene.initPeer();
 404                         }
 405 
 406                         @Override
 407                         public void setWindow(Scene scene, Window window) {
 408                             scene.setWindow(window);
 409                         }
 410 
 411                         @Override
 412                         public TKScene getPeer(Scene scene) {
 413                             return scene.getPeer();
 414                         }
 415 
 416                         @Override
 417                         public void setAllowPGAccess(boolean flag) {
 418                             Scene.setAllowPGAccess(flag);
 419                         }
 420 
 421                         @Override
 422                         public void parentEffectiveOrientationInvalidated(
 423                                 final Scene scene) {
 424                             scene.parentEffectiveOrientationInvalidated();
 425                         }
 426 
 427                         @Override
 428                         public Camera getEffectiveCamera(Scene scene) {
 429                             return scene.getEffectiveCamera();
 430                         }
 431 
 432                         @Override
 433                         public Scene createPopupScene(Parent root) {
 434                             return new Scene(root) {
 435                                        @Override
 436                                        void doLayoutPass() {
 437                                            resizeRootToPreferredSize(getRoot());
 438                                            super.doLayoutPass();
 439                                        }
 440 
 441                                        @Override
 442                                        void resizeRootOnSceneSizeChange(
 443                                                double newWidth,
 444                                                double newHeight) {
 445                                            // don&#39;t resize
 446                                        }
 447                                    };
 448                         }
 449 
 450                         @Override
 451                         public void setTransientFocusContainer(Scene scene, Node node) {
 452                             if (scene != null) {
 453                                 scene.transientFocusContainer = node;
 454                             }
 455                         }
 456 
 457                         @Override
 458                         public Accessible getAccessible(Scene scene) {
 459                             return scene.getAccessible();
 460                         }
 461                     });
 462         }
 463 
 464         // Reserve space for 30 nodes in the dirtyNodes set.
 465         private static final int MIN_DIRTY_CAPACITY = 30;
 466 
 467         // For debugging
 468         private static boolean inSynchronizer = false;
 469         private static boolean inMousePick = false;
 470         private static boolean allowPGAccess = false;
 471         private static int pgAccessCount = 0;
 472 
 473         /**
 474          * Used for debugging purposes. Returns true if we are in either the
 475          * mouse event code (picking) or the synchronizer, or if the scene is
 476          * not yet initialized,
 477          *
 478          */
 479         static boolean isPGAccessAllowed() {
 480             return inSynchronizer || inMousePick || allowPGAccess;
 481         }
 482 
 483         static void setAllowPGAccess(boolean flag) {
 484             if (Utils.assertionEnabled()) {
 485                 if (flag) {
 486                     pgAccessCount++;
 487                     allowPGAccess = true;
 488                 }
 489                 else {
 490                     if (pgAccessCount &lt;= 0) {
 491                         throw new java.lang.AssertionError(&quot;*** pgAccessCount underflow&quot;);
 492                     }
 493                     if (--pgAccessCount == 0) {
 494                         allowPGAccess = false;
 495                     }
 496                 }
 497             }
 498         }
 499 
 500         /**
 501          * If true, use the platform&#39;s drag gesture detection
 502          * else use Scene-level detection as per DnDGesture.process(MouseEvent, List)
 503          */
 504         private static final boolean PLATFORM_DRAG_GESTURE_INITIATION = false;
 505 
 506     /**
 507      * Set of dirty nodes; processed once per frame by the synchronizer.
 508      * When a node&#39;s state changes such that it becomes &quot;dirty&quot; with respect
 509      * to the graphics stack and requires synchronization, then that node
 510      * is added to this list. Note that if state on the Node changes, but it
 511      * was already dirty, then the Node doesn&#39;t add itself again.
 512      * &lt;p&gt;
 513      * Because at initialization time every node in the scene graph is dirty,
 514      * we have a special state and special code path during initialization
 515      * that does not involve adding each node to the dirtyNodes list. When
 516      * dirtyNodes is null, that means this Scene has not yet been synchronized.
 517      * A good default size is then created for the dirtyNodes list.
 518      * &lt;p&gt;
 519      * We double-buffer the set so that we can add new nodes to the
 520      * set while processing the existing set. This avoids our having to
 521      * take a snapshot of the set (e.g., with toArray()) and reduces garbage.
 522      */
 523     private Node[] dirtyNodes;
 524     private int dirtyNodesSize;
 525 
 526     /**
 527      * Add the specified node to this scene&#39;s dirty list. Called by the
 528      * markDirty method in Node or when the Node&#39;s scene changes.
 529      */
 530     void addToDirtyList(Node n) {
 531         if (dirtyNodes == null || dirtyNodesSize == 0) {
 532             if (peer != null) {
 533                 Toolkit.getToolkit().requestNextPulse();
 534             }
 535         }
 536 
 537         if (dirtyNodes != null) {
 538             if (dirtyNodesSize == dirtyNodes.length) {
 539                 Node[] tmp = new Node[dirtyNodesSize + (dirtyNodesSize &gt;&gt; 1)];
 540                 System.arraycopy(dirtyNodes, 0, tmp, 0, dirtyNodesSize);
 541                 dirtyNodes = tmp;
 542             }
 543             dirtyNodes[dirtyNodesSize++] = n;
 544         }
 545     }
 546 
 547     private void doCSSPass() {
 548         final Parent sceneRoot = getRoot();
 549         //
 550         // RT-17547: when the tree is synchronized, the dirty bits are
 551         // are cleared but the cssFlag might still be something other than
 552         // clean.
 553         //
 554         // Before RT-17547, the code checked the dirty bit. But this is
 555         // superfluous since the dirty bit will be set if the flag is not clean,
 556         // but the flag will never be anything other than clean if the dirty
 557         // bit is not set. The dirty bit is still needed, however, since setting
 558         // it ensures a pulse if no other dirty bits have been set.
 559         //
 560         // For the purpose of showing the change, the dirty bit
 561         // check code was commented out and not removed.
 562         //
 563 //        if (sceneRoot.isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS)) {
 564         if (sceneRoot.cssFlag != CssFlags.CLEAN) {
 565             // The dirty bit isn&#39;t checked but we must ensure it is cleared.
 566             // The cssFlag is set to clean in either Node.processCSS or
 567             // NodeHelper.processCSS
 568             sceneRoot.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
 569             sceneRoot.processCSS();
 570         }
 571     }
 572 
 573     void doLayoutPass() {
 574         final Parent r = getRoot();
 575         if (r != null) {
 576             r.layout();
 577         }
 578     }
 579 
 580     /**
 581      * The peer of this scene
 582      */
 583     private TKScene peer;
 584 
 585     /*
 586      * Get Scene&#39;s peer
 587      */
 588     TKScene getPeer() {
 589         return peer;
 590     }
 591 
 592     /**
 593      * The scene pulse listener that gets called on toolkit pulses
 594      */
 595     ScenePulseListener scenePulseListener = new ScenePulseListener();
 596 
 597     private List&lt;Runnable&gt; preLayoutPulseListeners;
 598     private List&lt;Runnable&gt; postLayoutPulseListeners;
 599 
 600     /**
 601      * Adds a new scene pre layout pulse listener to this scene. Every time a pulse occurs,
 602      * this listener will be called on the JavaFX Application Thread directly
 603      * &lt;strong&gt;before&lt;/strong&gt; the CSS and layout passes, and also before
 604      * any rendering is done for
 605      * this frame. This scene pulse listener is suitable for knowing when a
 606      * scenegraph pulse is happening and also for modifying the scenegraph
 607      * (as it is called before CSS and layout, so any changes made will be properly
 608      * styled and positioned).
 609      *
 610      * This method must be called on the JavaFX Application thread.
 611      *
 612      * @param r The Runnable to be called when the pulse occurs.
 613      *
 614      * @throws IllegalStateException if this method is called on a thread
 615      * other than the JavaFX Application Thread.
 616      *
 617      * @throws NullPointerException if the provided Runnable is null.
 618      *
 619      * @since 9
 620      */
 621     public final void addPreLayoutPulseListener(Runnable r) {
 622         Toolkit.getToolkit().checkFxUserThread();
 623 
 624         if (r == null) {
 625             throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
 626         }
 627         if (preLayoutPulseListeners == null) {
 628             preLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
 629         }
 630         preLayoutPulseListeners.add(r);
 631     }
 632 
 633     /**
 634      * Removes a previously registered scene pre layout pulse listener from listening to
 635      * pulses in this scene. This method does nothing if the specified Runnable is
 636      * not already in the list.
 637      *
 638      * This method must be called on the JavaFX Application thread.
 639      *
 640      * @param r The Runnable that should no longer be called when the pulse
 641      * occurs for this scene.
 642      *
 643      * @throws IllegalStateException if this method is called on a thread
 644      * other than the JavaFX Application Thread.
 645      *
 646      * @since 9
 647      */
 648     public final void removePreLayoutPulseListener(Runnable r) {
 649         Toolkit.getToolkit().checkFxUserThread();
 650 
 651         if (preLayoutPulseListeners == null) {
 652             return;
 653         }
 654         preLayoutPulseListeners.remove(r);
 655     }
 656 
 657     /**
 658      * Adds a new scene post layout pulse listener to this scene. Every time a pulse occurs,
 659      * this listener will be called on the JavaFX Application Thread directly
 660      * &lt;strong&gt;after&lt;/strong&gt; the CSS and layout passes, but before any rendering is done for
 661      * this frame. This scene pulse listener is suitable for knowing when a
 662      * scenegraph pulse is happening, but it is not suited to use cases related
 663      * to modifying the scenegraph (as it is called after CSS and layout, so
 664      * any changes will possibly be incorrect until the next pulse is run).
 665      * An alternative (and better) solution for situations where a scenegraph
 666      * modification is required to happen is to use either the
 667      * {@link #addPreLayoutPulseListener(Runnable)} API or the the
 668      * {@link javafx.animation.AnimationTimer} API.
 669      *
 670      * This method must be called on the JavaFX Application thread.
 671      *
 672      * @param r The Runnable to be called when the pulse occurs.
 673      *
 674      * @throws IllegalStateException if this method is called on a thread
 675      * other than the JavaFX Application Thread.
 676      *
 677      * @throws NullPointerException if the provided Runnable is null.
 678      *
 679      * @since 9
 680      */
 681     public final void addPostLayoutPulseListener(Runnable r) {
 682         Toolkit.getToolkit().checkFxUserThread();
 683 
 684         if (r == null) {
 685             throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
 686         }
 687         if (postLayoutPulseListeners == null) {
 688             postLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
 689         }
 690         postLayoutPulseListeners.add(r);
 691     }
 692 
 693     /**
 694      * Removes a previously registered scene post layout pulse listener from listening to
 695      * pulses in this scene. This method does nothing if the specified Runnable is
 696      * not already in the list.
 697      *
 698      * This method must be called on the JavaFX Application thread.
 699      *
 700      * @param r The Runnable that should no longer be called when the pulse
 701      * occurs for this scene.
 702      *
 703      * @throws IllegalStateException if this method is called on a thread
 704      * other than the JavaFX Application Thread.
 705      *
 706      * @since 9
 707      */
 708     public final void removePostLayoutPulseListener(Runnable r) {
 709         Toolkit.getToolkit().checkFxUserThread();
 710 
 711         if (postLayoutPulseListeners == null) {
 712             return;
 713         }
 714         postLayoutPulseListeners.remove(r);
 715     }
 716 
 717     /**
 718      * Return the defined {@code SceneAntialiasing} for this {@code Scene}.
 719      * &lt;p&gt;
 720      * Note: this is a conditional feature. See
 721      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 722      * and {@link javafx.scene.SceneAntialiasing SceneAntialiasing}
 723      * for more information.
 724      * @return the SceneAntialiasing for this scene
 725      * @since JavaFX 8.0
 726      */
 727     public final SceneAntialiasing getAntiAliasing() {
 728         return antiAliasing;
 729     }
 730 
 731     private boolean getAntiAliasingInternal() {
 732         return (antiAliasing != null &amp;&amp;
 733                 Toolkit.getToolkit().isMSAASupported() &amp;&amp;
 734                 Platform.isSupported(ConditionalFeature.SCENE3D)) ?
 735                 antiAliasing != SceneAntialiasing.DISABLED : false;
 736     }
 737 
 738     /**
 739      * The {@code Window} for this {@code Scene}
 740      */
 741     private ReadOnlyObjectWrapper&lt;Window&gt; window;
 742 
 743     void setWindow(Window value) {
 744         windowPropertyImpl().set(value);
 745     }
 746 
 747     public final Window getWindow() {
 748         return window == null ? null : window.get();
 749     }
 750 
 751     public final ReadOnlyObjectProperty&lt;Window&gt; windowProperty() {
 752         return windowPropertyImpl().getReadOnlyProperty();
 753     }
 754 
 755     private ReadOnlyObjectWrapper&lt;Window&gt; windowPropertyImpl() {
 756         if (window == null) {
 757             window = new ReadOnlyObjectWrapper&lt;Window&gt;() {
 758                 private Window oldWindow;
 759 
 760                 @Override protected void invalidated() {
 761                     final Window newWindow = get();
 762                     getKeyHandler().windowForSceneChanged(oldWindow, newWindow);
 763                     if (oldWindow != null) {
 764                         disposePeer();
 765                     }
 766                     if (newWindow != null) {
 767                         initPeer();
 768                     }
 769                     parentEffectiveOrientationInvalidated();
 770 
 771                     oldWindow = newWindow;
 772                 }
 773 
 774                 @Override
 775                 public Object getBean() {
 776                     return Scene.this;
 777                 }
 778 
 779                 @Override
 780                 public String getName() {
 781                     return &quot;window&quot;;
 782                 }
 783             };
 784         }
 785         return window;
 786     }
 787 
 788     void initPeer() {
 789         assert peer == null;
 790 
 791         Window window = getWindow();
 792         // initPeer() is only called from Window, either when the window
 793         // is being shown, or the window scene is being changed. In any case
 794         // this scene&#39;s window cannot be null.
 795         assert window != null;
 796 
 797         TKStage windowPeer = WindowHelper.getPeer(window);
 798         if (windowPeer == null) {
 799             // This is fine, the window is not visible. initPeer() will
 800             // be called again later, when the window is being shown.
 801             return;
 802         }
 803 
 804         final boolean isTransparentWindowsSupported = Platform.isSupported(ConditionalFeature.TRANSPARENT_WINDOW);
 805         if (!isTransparentWindowsSupported) {
 806             PlatformImpl.addNoTransparencyStylesheetToScene(this);
 807         }
 808 
 809         PerformanceTracker.logEvent(&quot;Scene.initPeer started&quot;);
 810 
 811         setAllowPGAccess(true);
 812 
 813         Toolkit tk = Toolkit.getToolkit();
 814         peer = windowPeer.createTKScene(isDepthBufferInternal(), getAntiAliasingInternal(), acc);
 815         PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene created&quot;);
 816         peer.setTKSceneListener(new ScenePeerListener());
 817         peer.setTKScenePaintListener(new ScenePeerPaintListener());
 818         PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene set&quot;);
 819         peer.setRoot(getRoot().getPeer());
 820         peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
 821         NodeHelper.updatePeer(getEffectiveCamera());
 822         peer.setCamera((NGCamera) getEffectiveCamera().getPeer());
 823         peer.markDirty();
 824         PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene initialized&quot;);
 825 
 826         setAllowPGAccess(false);
 827 
 828         tk.addSceneTkPulseListener(scenePulseListener);
 829         // listen to dnd gestures coming from the platform
 830         if (PLATFORM_DRAG_GESTURE_INITIATION) {
 831             if (dragGestureListener == null) {
 832                 dragGestureListener = new DragGestureListener();
 833             }
 834             tk.registerDragGestureListener(peer, EnumSet.allOf(TransferMode.class), dragGestureListener);
 835         }
 836         tk.enableDrop(peer, new DropTargetListener());
 837         tk.installInputMethodRequests(peer, new InputMethodRequestsDelegate());
 838 
 839         PerformanceTracker.logEvent(&quot;Scene.initPeer finished&quot;);
 840     }
 841 
 842     public void disposePeer() {
 843         if (peer == null) {
 844             // This is fine, the window is either not shown yet and there is no
 845             // need in disposing scene peer, or is hidden and disposePeer()
 846             // has already been called.
 847             return;
 848         }
 849 
 850         PerformanceTracker.logEvent(&quot;Scene.disposePeer started&quot;);
 851 
 852         Toolkit tk = Toolkit.getToolkit();
 853         tk.removeSceneTkPulseListener(scenePulseListener);
 854         if (accessible != null) {
 855             disposeAccessibles();
 856             Node root = getRoot();
 857             if (root != null) root.releaseAccessible();
 858             accessible.dispose();
 859             accessible = null;
 860         }
 861         peer.dispose();
 862         peer = null;
 863 
 864         PerformanceTracker.logEvent(&quot;Scene.disposePeer finished&quot;);
 865     }
 866 
 867     DnDGesture dndGesture = null;
 868     DragGestureListener dragGestureListener;
 869     /**
 870      * The horizontal location of this {@code Scene} on the {@code Window}.
 871      */
 872     private ReadOnlyDoubleWrapper x;
 873 
 874     private final void setX(double value) {
 875         xPropertyImpl().set(value);
 876     }
 877 
 878     public final double getX() {
 879         return x == null ? 0.0 : x.get();
 880     }
 881 
 882     public final ReadOnlyDoubleProperty xProperty() {
 883         return xPropertyImpl().getReadOnlyProperty();
 884     }
 885 
 886     private ReadOnlyDoubleWrapper xPropertyImpl() {
 887         if (x == null) {
 888             x = new ReadOnlyDoubleWrapper(this, &quot;x&quot;);
 889         }
 890         return x;
 891     }
 892 
 893     /**
 894      * The vertical location of this {@code Scene} on the {@code Window}.
 895      */
 896     private ReadOnlyDoubleWrapper y;
 897 
 898     private final void setY(double value) {
 899         yPropertyImpl().set(value);
 900     }
 901 
 902     public final double getY() {
 903         return y == null ? 0.0 : y.get();
 904     }
 905 
 906     public final ReadOnlyDoubleProperty yProperty() {
 907         return yPropertyImpl().getReadOnlyProperty();
 908     }
 909 
 910     private ReadOnlyDoubleWrapper yPropertyImpl() {
 911         if (y == null) {
 912             y = new ReadOnlyDoubleWrapper(this, &quot;y&quot;);
 913         }
 914         return y;
 915     }
 916 
 917     /**
 918      * The width of this {@code Scene}
 919      */
 920     private ReadOnlyDoubleWrapper width;
 921 
 922     private final void setWidth(double value) {
 923         widthPropertyImpl().set(value);
 924     }
 925 
 926     public final double getWidth() {
 927         return width == null ? 0.0 : width.get();
 928     }
 929 
 930     public final ReadOnlyDoubleProperty widthProperty() {
 931         return widthPropertyImpl().getReadOnlyProperty();
 932     }
 933 
 934     private ReadOnlyDoubleWrapper widthPropertyImpl() {
 935         if (width == null) {
 936             width = new ReadOnlyDoubleWrapper() {
 937 
 938                 @Override
 939                 protected void invalidated() {
 940                     final Parent _root = getRoot();
 941                     //TODO - use a better method to update mirroring
 942                     if (_root.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
 943                         NodeHelper.transformsChanged(_root);
 944                     }
 945                     if (_root.isResizable()) {
 946                         resizeRootOnSceneSizeChange(get() - _root.getLayoutX() - _root.getTranslateX(), _root.getLayoutBounds().getHeight());
 947                     }
 948 
 949                     getEffectiveCamera().setViewWidth(get());
 950                 }
 951 
 952                 @Override
 953                 public Object getBean() {
 954                     return Scene.this;
 955                 }
 956 
 957                 @Override
 958                 public String getName() {
 959                     return &quot;width&quot;;
 960                 }
 961             };
 962         }
 963         return width;
 964     }
 965 
 966     /**
 967      * The height of this {@code Scene}
 968      */
 969     private ReadOnlyDoubleWrapper height;
 970 
 971     private final void setHeight(double value) {
 972         heightPropertyImpl().set(value);
 973     }
 974 
 975     public final double getHeight() {
 976         return height == null ? 0.0 : height.get();
 977     }
 978 
 979     public final ReadOnlyDoubleProperty heightProperty() {
 980         return heightPropertyImpl().getReadOnlyProperty();
 981     }
 982 
 983     private ReadOnlyDoubleWrapper heightPropertyImpl() {
 984         if (height == null) {
 985             height = new ReadOnlyDoubleWrapper() {
 986 
 987                 @Override
 988                 protected void invalidated() {
 989                     final Parent _root = getRoot();
 990                     if (_root.isResizable()) {
 991                         resizeRootOnSceneSizeChange(_root.getLayoutBounds().getWidth(), get() - _root.getLayoutY() - _root.getTranslateY());
 992                     }
 993 
 994                     getEffectiveCamera().setViewHeight(get());
 995                 }
 996 
 997                 @Override
 998                 public Object getBean() {
 999                     return Scene.this;
1000                 }
1001 
1002                 @Override
1003                 public String getName() {
1004                     return &quot;height&quot;;
1005                 }
1006             };
1007         }
1008         return height;
1009     }
1010 
1011     void resizeRootOnSceneSizeChange(double newWidth, double newHeight) {
1012         getRoot().resize(newWidth, newHeight);
1013     }
1014 
1015     // Reusable target wrapper (to avoid creating new one for each picking)
1016     private TargetWrapper tmpTargetWrapper = new TargetWrapper();
1017 
1018     /**
1019      * Specifies the type of camera use for rendering this {@code Scene}.
1020      * If {@code camera} is null, a parallel camera is used for rendering.
1021      * It is illegal to set a camera that belongs to other {@code Scene}
1022      * or {@code SubScene}.
1023      * &lt;p&gt;
1024      * Note: this is a conditional feature. See
1025      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
1026      * for more information.
1027      *
1028      * @defaultValue null
1029      */
1030     private ObjectProperty&lt;Camera&gt; camera;
1031 
1032     public final void setCamera(Camera value) {
1033         cameraProperty().set(value);
1034     }
1035 
1036     public final Camera getCamera() {
1037         return camera == null ? null : camera.get();
1038     }
1039 
1040     public final ObjectProperty&lt;Camera&gt; cameraProperty() {
1041         if (camera == null) {
1042             camera = new ObjectPropertyBase&lt;Camera&gt;() {
1043                 Camera oldCamera = null;
1044 
1045                 @Override
1046                 protected void invalidated() {
1047                     Camera _value = get();
1048                     if (_value != null) {
1049                         if (_value instanceof PerspectiveCamera
1050                                 &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
1051                             String logname = Scene.class.getName();
1052                             PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;
1053                                     + &quot;ConditionalFeature.SCENE3D&quot;);
1054                         }
1055                         // Illegal value if it belongs to other scene or any subscene
1056                         if ((_value.getScene() != null &amp;&amp; _value.getScene() != Scene.this)
1057                                 || _value.getSubScene() != null) {
1058                             throw new IllegalArgumentException(_value
1059                                     + &quot;is already part of other scene or subscene&quot;);
1060                         }
1061                         // throws exception if the camera already has a different owner
1062                         _value.setOwnerScene(Scene.this);
1063                         _value.setViewWidth(getWidth());
1064                         _value.setViewHeight(getHeight());
1065                     }
1066                     if (oldCamera != null &amp;&amp; oldCamera != _value) {
1067                         oldCamera.setOwnerScene(null);
1068                     }
1069                     oldCamera = _value;
1070                 }
1071 
1072                 @Override
1073                 public Object getBean() {
1074                     return Scene.this;
1075                 }
1076 
1077                 @Override
1078                 public String getName() {
1079                     return &quot;camera&quot;;
1080                 }
1081             };
1082         }
1083         return camera;
1084     }
1085 
1086     Camera getEffectiveCamera() {
1087         final Camera cam = getCamera();
1088         if (cam == null
1089                 || (cam instanceof PerspectiveCamera
1090                 &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D))) {
1091             if (defaultCamera == null) {
1092                 defaultCamera = new ParallelCamera();
1093                 defaultCamera.setOwnerScene(this);
1094                 defaultCamera.setViewWidth(getWidth());
1095                 defaultCamera.setViewHeight(getHeight());
1096             }
1097             return defaultCamera;
1098         }
1099 
1100         return cam;
1101     }
1102 
1103     // Used by the camera
1104     void markCameraDirty() {
1105         markDirty(DirtyBits.CAMERA_DIRTY);
1106         setNeedsRepaint();
1107     }
1108 
1109     void markCursorDirty() {
1110         markDirty(DirtyBits.CURSOR_DIRTY);
1111     }
1112 
1113     /**
1114      * Defines the background fill of this {@code Scene}. Both a {@code null}
1115      * value meaning &#39;paint no background&#39; and a {@link javafx.scene.paint.Paint}
1116      * with transparency are supported. The default fill of the Scene is
1117      * {@link Color#WHITE}, but it is more commonly the case that the initial
1118      * color shown to users is the background fill of the
1119      * {@link #rootProperty() root node} of the {@code Scene}, as it typically is
1120      * stretched to take up all available space in the {@code Scene}. The
1121      * root node of the {@code Scene} is given the CSS style class &#39;root&#39;, and
1122      * the default user agent stylesheets that ship with JavaFX (presently
1123      * Caspian and Modena) apply styling on to this root style class. In the
1124      * case of Caspian this does not impact the background fill color of the
1125      * root node, but in the case of Modena the default fill is set to be a
1126      * light gray color.
1127      *
1128      * @defaultValue WHITE
1129      */
1130     private ObjectProperty&lt;Paint&gt; fill;
1131 
1132     public final void setFill(Paint value) {
1133         fillProperty().set(value);
1134     }
1135 
1136     public final Paint getFill() {
1137         return fill == null ? Color.WHITE : fill.get();
1138     }
1139 
1140     public final ObjectProperty&lt;Paint&gt; fillProperty() {
1141         if (fill == null) {
1142             fill = new ObjectPropertyBase&lt;Paint&gt;(Color.WHITE) {
1143 
1144                 @Override
1145                 protected void invalidated() {
1146                     markDirty(DirtyBits.FILL_DIRTY);
1147                 }
1148 
1149                 @Override
1150                 public Object getBean() {
1151                     return Scene.this;
1152                 }
1153 
1154                 @Override
1155                 public String getName() {
1156                     return &quot;fill&quot;;
1157                 }
1158             };
1159         }
1160         return fill;
1161     }
1162 
1163     /**
1164      * Defines the root {@code Node} of the scene graph.
1165      * If a {@code Group} is used as the root, the
1166      * contents of the scene graph will be clipped by the scene&#39;s width and height and
1167      * changes to the scene&#39;s size (if user resizes the stage) will not alter the
1168      * layout of the scene graph.    If a resizable node (layout {@code Region} or
1169      * {@code Control}) is set as the root, then the root&#39;s size will track the
1170      * scene&#39;s size, causing the contents to be relayed out as necessary.
1171      *
1172      * Scene doesn&#39;t accept null root.
1173      *
1174      */
1175     private ObjectProperty&lt;Parent&gt; root;
1176 
1177     public final void setRoot(Parent value) {
1178         rootProperty().set(value);
1179     }
1180 
1181     public final Parent getRoot() {
1182         return root == null ? null : root.get();
1183     }
1184 
1185     Parent oldRoot;
1186     public final ObjectProperty&lt;Parent&gt; rootProperty() {
1187         if (root == null) {
1188             root = new ObjectPropertyBase&lt;Parent&gt;() {
1189 
1190                 private void forceUnbind() {
1191                     System.err.println(&quot;Unbinding illegal root.&quot;);
1192                     unbind();
1193                 }
1194 
1195                 @Override
1196                 protected void invalidated() {
1197                     Parent _value = get();
1198 
1199                     if (_value == null) {
1200                         if (isBound()) forceUnbind();
1201                         throw new NullPointerException(&quot;Scene&#39;s root cannot be null&quot;);
1202                     }
1203 
1204                     if (_value.getParent() != null) {
1205                         if (isBound()) forceUnbind();
1206                         throw new IllegalArgumentException(_value +
1207                                 &quot;is already inside a scene-graph and cannot be set as root&quot;);
1208                     }
1209                     if (_value.getClipParent() != null) {
1210                         if (isBound()) forceUnbind();
1211                         throw new IllegalArgumentException(_value +
1212                                 &quot;is set as a clip on another node, so cannot be set as root&quot;);
1213                     }
1214                     if (_value.getScene() != null &amp;&amp; _value.getScene().getRoot() == _value &amp;&amp; _value.getScene() != Scene.this) {
1215                         if (isBound()) forceUnbind();
1216                         throw new IllegalArgumentException(_value +
1217                                 &quot;is already set as root of another scene&quot;);
1218                     }
1219 
1220                     if (oldRoot != null) {
1221                         oldRoot.setScenes(null, null);
1222                     }
1223                     oldRoot = _value;
1224                     _value.getStyleClass().add(0, &quot;root&quot;);
1225                     _value.setScenes(Scene.this, null);
1226                     markDirty(DirtyBits.ROOT_DIRTY);
1227                     _value.resize(getWidth(), getHeight()); // maybe no-op if root is not resizable
1228                     _value.requestLayout();
1229                 }
1230 
1231                 @Override
1232                 public Object getBean() {
1233                     return Scene.this;
1234                 }
1235 
1236                 @Override
1237                 public String getName() {
1238                     return &quot;root&quot;;
1239                 }
1240             };
1241         }
1242         return root;
1243     }
1244 
1245     void setNeedsRepaint() {
1246         if (this.peer != null) {
1247             peer.entireSceneNeedsRepaint();
1248         }
1249     }
1250 
1251     // Process CSS and layout and sync the scene prior to the snapshot
1252     // operation of the given node for this scene (currently the node
1253     // is unused but could possibly be used in the future to optimize this)
1254     void doCSSLayoutSyncForSnapshot(Node node) {
1255         if (!sizeInitialized) {
1256             preferredSize();
1257         } else {
1258             doCSSPass();
1259         }
1260 
1261         // we do not need pulse in the snapshot code
1262         // because this scene can be stage-less
1263         doLayoutPass();
1264 
1265         getRoot().updateBounds();
1266         if (peer != null) {
1267             peer.waitForRenderingToComplete();
1268             peer.waitForSynchronization();
1269             try {
1270                 // Run the synchronizer while holding the render lock
1271                 scenePulseListener.synchronizeSceneNodes();
1272             } finally {
1273                 peer.releaseSynchronization(false);
1274             }
1275         } else {
1276             scenePulseListener.synchronizeSceneNodes();
1277         }
1278 
1279     }
1280 
1281     // Shared method for Scene.snapshot and Node.snapshot. It is static because
1282     // we might be doing a Node snapshot with a null scene
1283     static WritableImage doSnapshot(Scene scene,
<a name="1" id="anc1"></a><span class="line-modified">1284                                     double x, double y, double w, double h,</span>
<span class="line-modified">1285                                     Node root, BaseTransform transform, boolean depthBuffer,</span>
<span class="line-modified">1286                                     Paint fill, Camera camera, WritableImage wimg) {</span>
<span class="line-modified">1287 </span>
<span class="line-modified">1288         int xMin = (int) Math.floor(x);</span>
<span class="line-modified">1289         int yMin = (int) Math.floor(y);</span>
<span class="line-modified">1290         int xMax = (int) Math.ceil(x + w);</span>
<span class="line-modified">1291         int yMax = (int) Math.ceil(y + h);</span>



1292         int width = Math.max(xMax - xMin, 1);
1293         int height = Math.max(yMax - yMin, 1);
1294         if (wimg == null) {
1295             wimg = new WritableImage(width, height);
<a name="2" id="anc2"></a><span class="line-modified">1296         }</span>
<span class="line-modified">1297         else {</span>
<span class="line-modified">1298             width = (int) wimg.getWidth();</span>
<span class="line-added">1299             height = (int) wimg.getHeight();</span>
<span class="line-added">1300         }</span>
<span class="line-added">1301 </span>
<span class="line-added">1302         int maxTextureSize = PrismSettings.maxTextureSize;</span>
<span class="line-added">1303         if (height &gt; maxTextureSize || width &gt; maxTextureSize) {</span>
<span class="line-added">1304             // The requested size for the screenshot is to big to fit a single texture,</span>
<span class="line-added">1305             // so we need to take several snapshot tiles and merge them into single image (fixes JDK-8088198)</span>
<span class="line-added">1306             int verticalTileNb = (int) Math.ceil(height / (double) maxTextureSize);</span>
<span class="line-added">1307             int horizontalTileNb = (int) Math.ceil(width / (double) maxTextureSize);</span>
<span class="line-added">1308             for (int i = 0; i &lt; horizontalTileNb; i++) {</span>
<span class="line-added">1309                 for (int j = 0; j &lt; verticalTileNb; j++) {</span>
<span class="line-added">1310                     int xOffset = i * maxTextureSize;</span>
<span class="line-added">1311                     int yOffset = j * maxTextureSize;</span>
<span class="line-added">1312                     int tileWidth = Math.min(maxTextureSize, width - xOffset);</span>
<span class="line-added">1313                     int tileHeight = Math.min(maxTextureSize, height - yOffset);</span>
<span class="line-added">1314                     WritableImage tile = doSnapshotTile(scene, xMin + xOffset, yMin + yOffset, tileWidth, tileHeight, root, transform, depthBuffer, fill, camera, null);</span>
<span class="line-added">1315                     wimg.getPixelWriter().setPixels(xOffset, yOffset, tileWidth, tileHeight, tile.getPixelReader(), 0, 0);</span>
<span class="line-added">1316                 }</span>
<span class="line-added">1317             }</span>
<span class="line-added">1318         }</span>
<span class="line-added">1319         else {</span>
<span class="line-added">1320             // The requested size for the screenshot fits max texture size,</span>
<span class="line-added">1321             // so we can directly return the one generated tile and avoid the extra pixel copy.</span>
<span class="line-added">1322             wimg = doSnapshotTile(scene, xMin, yMin, width, height, root, transform, depthBuffer, fill, camera, wimg);</span>
<span class="line-added">1323         }</span>
<span class="line-added">1324 </span>
<span class="line-added">1325         // if this scene belongs to some stage</span>
<span class="line-added">1326         // we need to mark the entire scene as dirty</span>
<span class="line-added">1327         // because dirty logic is buggy</span>
<span class="line-added">1328         if (scene != null &amp;&amp; scene.peer != null) {</span>
<span class="line-added">1329             scene.setNeedsRepaint();</span>
1330         }
1331 
<a name="3" id="anc3"></a><span class="line-added">1332         return wimg;</span>
<span class="line-added">1333     }</span>
<span class="line-added">1334 </span>
<span class="line-added">1335     /**</span>
<span class="line-added">1336      * Capture a single snapshot tile</span>
<span class="line-added">1337      */</span>
<span class="line-added">1338     private static WritableImage doSnapshotTile(Scene scene,</span>
<span class="line-added">1339                                                 int x, int y, int w, int h,</span>
<span class="line-added">1340                                                 Node root, BaseTransform transform, boolean depthBuffer,</span>
<span class="line-added">1341                                                 Paint fill, Camera camera, WritableImage tileImg) {</span>
<span class="line-added">1342         Toolkit tk = Toolkit.getToolkit();</span>
<span class="line-added">1343         Toolkit.ImageRenderingContext context = new Toolkit.ImageRenderingContext();</span>
<span class="line-added">1344         if (tileImg == null) {</span>
<span class="line-added">1345             tileImg = new WritableImage(w, h);</span>
<span class="line-added">1346         }</span>
1347         setAllowPGAccess(true);
<a name="4" id="anc4"></a><span class="line-modified">1348         context.x = x;</span>
<span class="line-modified">1349         context.y = y;</span>
<span class="line-modified">1350         context.width = w;</span>
<span class="line-modified">1351         context.height = h;</span>
1352         context.transform = transform;
1353         context.depthBuffer = depthBuffer;
1354         context.root = root.getPeer();
1355         context.platformPaint = fill == null ? null : tk.getPaint(fill);
1356         double cameraViewWidth = 1.0;
1357         double cameraViewHeight = 1.0;
1358         if (camera != null) {
1359             // temporarily adjust camera viewport to the snapshot size
1360             cameraViewWidth = camera.getViewWidth();
1361             cameraViewHeight = camera.getViewHeight();
<a name="5" id="anc5"></a><span class="line-modified">1362             camera.setViewWidth(w);</span>
<span class="line-modified">1363             camera.setViewHeight(h);</span>
1364             NodeHelper.updatePeer(camera);
1365             context.camera = camera.getPeer();
1366         } else {
1367             context.camera = null;
1368         }
1369 
1370         // Grab the lights from the scene
1371         context.lights = null;
1372         if (scene != null &amp;&amp; !scene.lights.isEmpty()) {
1373             context.lights = new NGLightBase[scene.lights.size()];
1374             for (int i = 0; i &lt; scene.lights.size(); i++) {
1375                 context.lights[i] = scene.lights.get(i).getPeer();
1376             }
1377         }
1378 
1379         Toolkit.WritableImageAccessor accessor = Toolkit.getWritableImageAccessor();
<a name="6" id="anc6"></a><span class="line-modified">1380         context.platformImage = accessor.getTkImageLoader(tileImg);</span>
1381         setAllowPGAccess(false);
1382         Object tkImage = tk.renderToImage(context);
<a name="7" id="anc7"></a><span class="line-modified">1383         accessor.loadTkImage(tileImg, tkImage);</span>
1384 
1385         if (camera != null) {
1386             setAllowPGAccess(true);
1387             camera.setViewWidth(cameraViewWidth);
1388             camera.setViewHeight(cameraViewHeight);
1389             NodeHelper.updatePeer(camera);
1390             setAllowPGAccess(false);
1391         }
<a name="8" id="anc8"></a><span class="line-modified">1392         return tileImg;</span>








1393     }
1394 
1395     /**
1396      * Implementation method for snapshot
1397      */
1398     private WritableImage doSnapshot(WritableImage img) {
1399         // TODO: no need to do CSS, layout or sync in the deferred case,
1400         // if this scene is attached to a visible stage
1401         doCSSLayoutSyncForSnapshot(getRoot());
1402 
1403         double w = getWidth();
1404         double h = getHeight();
1405         BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;
1406 
1407         return doSnapshot(this, 0, 0, w, h,
1408                 getRoot(), transform, isDepthBufferInternal(),
1409                 getFill(), getEffectiveCamera(), img);
1410     }
1411 
1412     // Pulse listener used to run all deferred (async) snapshot requests
1413     private static TKPulseListener snapshotPulseListener = null;
1414 
1415     private static List&lt;Runnable&gt; snapshotRunnableListA;
1416     private static List&lt;Runnable&gt; snapshotRunnableListB;
1417     private static List&lt;Runnable&gt; snapshotRunnableList;
1418 
1419     static void addSnapshotRunnable(final Runnable runnable) {
1420         Toolkit.getToolkit().checkFxUserThread();
1421 
1422         if (snapshotPulseListener == null) {
1423             snapshotRunnableListA = new ArrayList&lt;Runnable&gt;();
1424             snapshotRunnableListB = new ArrayList&lt;Runnable&gt;();
1425             snapshotRunnableList = snapshotRunnableListA;
1426 
1427             snapshotPulseListener = () -&gt; {
1428                 if (snapshotRunnableList.size() &gt; 0) {
1429                     List&lt;Runnable&gt; runnables = snapshotRunnableList;
1430                     if (snapshotRunnableList == snapshotRunnableListA) {
1431                         snapshotRunnableList = snapshotRunnableListB;
1432                     } else {
1433                         snapshotRunnableList = snapshotRunnableListA;
1434                     }
1435                     for (Runnable r : runnables) {
1436                         try {
1437                             r.run();
1438                         } catch (Throwable th) {
1439                             System.err.println(&quot;Exception in snapshot runnable&quot;);
1440                             th.printStackTrace(System.err);
1441                         }
1442                     }
1443                     runnables.clear();
1444                 }
1445             };
1446 
1447             // Add listener that will be called after all of the scenes have
1448             // had layout and CSS processing, and have been synced
1449             Toolkit.getToolkit().addPostSceneTkPulseListener(snapshotPulseListener);
1450         }
1451 
1452         final AccessControlContext acc = AccessController.getContext();
1453         snapshotRunnableList.add(() -&gt; {
1454             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
1455                 runnable.run();
1456                 return null;
1457             }, acc);
1458         });
1459         Toolkit.getToolkit().requestNextPulse();
1460     }
1461 
1462     /**
1463      * Takes a snapshot of this scene and returns the rendered image when
1464      * it is ready.
1465      * CSS and layout processing will be done for the scene prior to
1466      * rendering it.
1467      * The entire destination image is cleared using the fill {@code Paint}
1468      * of this scene. The nodes in the scene are then rendered to the image.
1469      * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
1470      * If the image is smaller than the size of the scene, then the rendering
1471      * will be clipped by the image.
1472      *
1473      * &lt;p&gt;
1474      * When taking a snapshot of a scene that is being animated, either
1475      * explicitly by the application or implicitly (such as chart animation),
1476      * the snapshot will be rendered based on the state of the scene graph at
1477      * the moment the snapshot is taken and will not reflect any subsequent
1478      * animation changes.
1479      * &lt;/p&gt;
1480      *
1481      * @param image the writable image that will be used to hold the rendered scene.
1482      * It may be null in which case a new WritableImage will be constructed.
1483      * If the image is non-null, the scene will be rendered into the
1484      * existing image.
1485      * In this case, the width and height of the image determine the area
1486      * that is rendered instead of the width and height of the scene.
1487      *
1488      * @throws IllegalStateException if this method is called on a thread
1489      *     other than the JavaFX Application Thread.
1490      *
1491      * @return the rendered image
1492      * @since JavaFX 2.2
1493      */
1494     public WritableImage snapshot(WritableImage image) {
1495         Toolkit.getToolkit().checkFxUserThread();
1496 
1497         return doSnapshot(image);
1498     }
1499 
1500     /**
1501      * Takes a snapshot of this scene at the next frame and calls the
1502      * specified callback method when the image is ready.
1503      * CSS and layout processing will be done for the scene prior to
1504      * rendering it.
1505      * The entire destination image is cleared using the fill {@code Paint}
1506      * of this scene. The nodes in the scene are then rendered to the image.
1507      * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
1508      * If the image is smaller than the size of the scene, then the rendering
1509      * will be clipped by the image.
1510      *
1511      * &lt;p&gt;
1512      * This is an asynchronous call, which means that other
1513      * events or animation might be processed before the scene is rendered.
1514      * If any such events modify a node in the scene that modification will
1515      * be reflected in the rendered image (as it will also be reflected in
1516      * the frame rendered to the Stage).
1517      * &lt;/p&gt;
1518      *
1519      * &lt;p&gt;
1520      * When taking a snapshot of a scene that is being animated, either
1521      * explicitly by the application or implicitly (such as chart animation),
1522      * the snapshot will be rendered based on the state of the scene graph at
1523      * the moment the snapshot is taken and will not reflect any subsequent
1524      * animation changes.
1525      * &lt;/p&gt;
1526      *
1527      * @param callback a class whose call method will be called when the image
1528      * is ready. The SnapshotResult that is passed into the call method of
1529      * the callback will contain the rendered image and the source scene
1530      * that was rendered. The callback parameter must not be null.
1531      *
1532      * @param image the writable image that will be used to hold the rendered scene.
1533      * It may be null in which case a new WritableImage will be constructed.
1534      * If the image is non-null, the scene will be rendered into the
1535      * existing image.
1536      * In this case, the width and height of the image determine the area
1537      * that is rendered instead of the width and height of the scene.
1538      *
1539      * @throws IllegalStateException if this method is called on a thread
1540      *     other than the JavaFX Application Thread.
1541      *
1542      * @throws NullPointerException if the callback parameter is null.
1543      * @since JavaFX 2.2
1544      */
1545     public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback, WritableImage image) {
1546         Toolkit.getToolkit().checkFxUserThread();
1547         if (callback == null) {
1548             throw new NullPointerException(&quot;The callback must not be null&quot;);
1549         }
1550 
1551         final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;
1552         final WritableImage theImage = image;
1553 
1554         // Create a deferred runnable that will be run from a pulse listener
1555         // that is called after all of the scenes have been synced but before
1556         // any of them have been rendered.
1557         final Runnable snapshotRunnable = () -&gt; {
1558             WritableImage img = doSnapshot(theImage);
1559 //                System.err.println(&quot;Calling snapshot callback&quot;);
1560             SnapshotResult result = new SnapshotResult(img, Scene.this, null);
1561             try {
1562                 Void v = theCallback.call(result);
1563             } catch (Throwable th) {
1564                 System.err.println(&quot;Exception in snapshot callback&quot;);
1565                 th.printStackTrace(System.err);
1566             }
1567         };
1568 //        System.err.println(&quot;Schedule a snapshot in the future&quot;);
1569         addSnapshotRunnable(snapshotRunnable);
1570     }
1571 
1572     /**
1573      * Defines the mouse cursor for this {@code Scene}.
1574      */
1575     private ObjectProperty&lt;Cursor&gt; cursor;
1576 
1577     public final void setCursor(Cursor value) {
1578         cursorProperty().set(value);
1579     }
1580 
1581     public final Cursor getCursor() {
1582         return cursor == null ? null : cursor.get();
1583     }
1584 
1585     public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
1586         if (cursor == null) {
1587             cursor = new ObjectPropertyBase&lt;Cursor&gt;() {
1588                          @Override
1589                          protected void invalidated() {
1590                              markCursorDirty();
1591                          }
1592 
1593                          @Override
1594                          public Object getBean() {
1595                              return Scene.this;
1596                          }
1597 
1598                          @Override
1599                          public String getName() {
1600                              return &quot;cursor&quot;;
1601                          }
1602                      };
1603         }
1604         return cursor;
1605     }
1606 
1607     /**
1608      * Looks for any node within the scene graph based on the specified CSS selector.
1609      * If more than one node matches the specified selector, this function
1610      * returns the first of them.
1611      * If no nodes are found with this id, then null is returned.
1612      *
1613      * @param selector The css selector to look up
1614      * @return the {@code Node} in the scene which matches the CSS {@code selector},
1615      * or {@code null} if none is found.
1616      */
1617      public Node lookup(String selector) {
1618          return getRoot().lookup(selector);
1619      }
1620     /**
1621      * A ObservableList of string URLs linking to the stylesheets to use with this scene&#39;s
1622      * contents. For additional information about using CSS with the
1623      * scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
1624      * Guide&lt;/a&gt;.
1625      */
1626     private final ObservableList&lt;String&gt; stylesheets  = new TrackableObservableList&lt;String&gt;() {
1627         @Override
1628         protected void onChanged(Change&lt;String&gt; c) {
1629             StyleManager.getInstance().stylesheetsChanged(Scene.this, c);
1630             // RT-9784 - if stylesheet is removed, reset styled properties to
1631             // their initial value.
1632             c.reset();
1633             while(c.next()) {
1634                 if (c.wasRemoved() == false) {
1635                     continue;
1636                 }
1637                 break; // no point in resetting more than once...
1638             }
1639             getRoot().reapplyCSS();
1640         }
1641     };
1642 
1643     /**
1644      * Gets an observable list of string URLs linking to the stylesheets to use
1645      * with this scene&#39;s contents.
1646      * &lt;p&gt;
1647      * The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
1648      * does not have a [scheme:] component, the URL is considered to be the [path] component only.
1649      * Any leading &#39;/&#39; character of the [path] is ignored and the [path] is treated as a path relative to
1650      * the root of the application&#39;s classpath.
1651      * &lt;/p&gt;
1652      * &lt;pre&gt;&lt;code&gt;
1653      *
1654      * package com.example.javafx.app;
1655      *
1656      * import javafx.application.Application;
1657      * import javafx.scene.Group;
1658      * import javafx.scene.Scene;
1659      * import javafx.stage.Stage;
1660      *
1661      * public class MyApp extends Application {
1662      *
1663      *     {@literal @}Override public void start(Stage stage) {
1664      *         Scene scene = new Scene(new Group());
1665      *         scene.getStylesheets().add(&quot;/com/example/javafx/app/mystyles.css&quot;);
1666      *         stage.setScene(scene);
1667      *         stage.show();
1668      *     }
1669      *
1670      *     public static void main(String[] args) {
1671      *         launch(args);
1672      *     }
1673      * }
1674      * &lt;/code&gt;&lt;/pre&gt;
1675      * For additional information about using CSS with the scene graph,
1676      * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
1677      *
1678      * @return the list of stylesheets to use with this scene
1679      */
1680     public final ObservableList&lt;String&gt; getStylesheets() { return stylesheets; }
1681 
1682     private ObjectProperty&lt;String&gt; userAgentStylesheet = null;
1683 
1684     /**
1685      * @return the userAgentStylesheet property.
1686      * @see #getUserAgentStylesheet()
1687      * @see #setUserAgentStylesheet(String)
1688      * @since  JavaFX 8u20
1689      */
1690     public final ObjectProperty&lt;String&gt; userAgentStylesheetProperty() {
1691         if (userAgentStylesheet == null) {
1692             userAgentStylesheet = new SimpleObjectProperty&lt;String&gt;(Scene.this, &quot;userAgentStylesheet&quot;, null) {
1693                 @Override protected void invalidated() {
1694                     StyleManager.getInstance().forget(Scene.this);
1695                     getRoot().reapplyCSS();
1696                 }
1697             };
1698         }
1699         return userAgentStylesheet;
1700     }
1701 
1702     /**
1703      * Get the URL of the user-agent stylesheet that will be used by this Scene. If the URL has not been set,
1704      * the platform-default user-agent stylesheet will be used.
1705      * &lt;p&gt;
1706      * For additional information about using CSS with the scene graph,
1707      * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
1708      * &lt;/p&gt;
1709      * @return The URL of the user-agent stylesheet that will be used by this Scene,
1710      * or null if has not been set.
1711      * @since  JavaFX 8u20
1712      */
1713     public final String getUserAgentStylesheet() {
1714         return userAgentStylesheet == null ? null : userAgentStylesheet.get();
1715     }
1716 
1717     /**
1718      * Set the URL of the user-agent stylesheet that will be used by this Scene in place of the
1719      * the platform-default user-agent stylesheet. If the URL does not resolve to a valid location,
1720      * the platform-default user-agent stylesheet will be used.
1721      * &lt;p&gt;
1722      * For additional information about using CSS with the scene graph,
1723      * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
1724      * &lt;/p&gt;
1725      * @param url The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
1726      * does not have a [scheme:] component, the URL is considered to be the [path] component only.
1727      * Any leading &#39;/&#39; character of the [path] is ignored and the [path] is treated as a path relative to
1728      * the root of the application&#39;s classpath.
1729      * @since  JavaFX 8u20
1730      */
1731     public final void setUserAgentStylesheet(String url) {
1732         userAgentStylesheetProperty().set(url);
1733     }
1734 
1735     /**
1736      * Retrieves the depth buffer attribute for this scene.
1737      * @return the depth buffer attribute.
1738      */
1739     public final boolean isDepthBuffer() {
1740         return depthBuffer;
1741     }
1742 
1743     boolean isDepthBufferInternal() {
1744         if (!Platform.isSupported(ConditionalFeature.SCENE3D)) {
1745             return false;
1746         }
1747         return depthBuffer;
1748     }
1749 
1750     private void init(double width, double height) {
1751         if (width &gt;= 0) {
1752             widthSetByUser = width;
1753             setWidth((float)width);
1754         }
1755         if (height &gt;= 0) {
1756             heightSetByUser = height;
1757             setHeight((float)height);
1758         }
1759         sizeInitialized = (widthSetByUser &gt;= 0 &amp;&amp; heightSetByUser &gt;= 0);
1760     }
1761 
1762     private void init() {
1763         if (PerformanceTracker.isLoggingEnabled()) {
1764             PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;]&quot;);
1765         }
1766         mouseHandler = new MouseHandler();
1767         clickGenerator = new ClickGenerator();
1768 
1769         if (PerformanceTracker.isLoggingEnabled()) {
1770             PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;] - finished&quot;);
1771         }
1772     }
1773 
1774     void preferredSize() {
1775         final Parent root = getRoot();
1776 
1777         // one or the other isn&#39;t initialized, need to perform layout in
1778         // order to ensure we can properly measure the preferred size of the
1779         // scene
1780         doCSSPass();
1781 
1782         resizeRootToPreferredSize(root);
1783         doLayoutPass();
1784 
1785         if (widthSetByUser &lt; 0) {
1786             setWidth(root.isResizable()? root.getLayoutX() + root.getTranslateX() + root.getLayoutBounds().getWidth() :
1787                             root.getBoundsInParent().getMaxX());
1788         } else {
1789             setWidth(widthSetByUser);
1790         }
1791 
1792         if (heightSetByUser &lt; 0) {
1793             setHeight(root.isResizable()? root.getLayoutY() + root.getTranslateY() + root.getLayoutBounds().getHeight() :
1794                             root.getBoundsInParent().getMaxY());
1795         } else {
1796             setHeight(heightSetByUser);
1797         }
1798 
1799         sizeInitialized = (getWidth() &gt; 0) &amp;&amp; (getHeight() &gt; 0);
1800 
1801         PerformanceTracker.logEvent(&quot;Scene preferred bounds computation complete&quot;);
1802     }
1803 
1804     final void resizeRootToPreferredSize(Parent root) {
1805         final double preferredWidth;
1806         final double preferredHeight;
1807 
1808         final Orientation contentBias = root.getContentBias();
1809         if (contentBias == null) {
1810             preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
1811             preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
1812         } else if (contentBias == Orientation.HORIZONTAL) {
1813             // height depends on width
1814             preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
1815             preferredHeight = getPreferredHeight(root, heightSetByUser,
1816                                                        preferredWidth);
1817         } else /* if (contentBias == Orientation.VERTICAL) */ {
1818             // width depends on height
1819             preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
1820             preferredWidth = getPreferredWidth(root, widthSetByUser,
1821                                                      preferredHeight);
1822         }
1823 
1824         root.resize(preferredWidth, preferredHeight);
1825     }
1826 
1827     private static double getPreferredWidth(Parent root,
1828                                             double forcedWidth,
1829                                             double height) {
1830         if (forcedWidth &gt;= 0) {
1831             return forcedWidth;
1832         }
1833         final double normalizedHeight = (height &gt;= 0) ? height : -1;
1834         return root.boundedSize(root.prefWidth(normalizedHeight),
1835                                 root.minWidth(normalizedHeight),
1836                                 root.maxWidth(normalizedHeight));
1837     }
1838 
1839     private static double getPreferredHeight(Parent root,
1840                                              double forcedHeight,
1841                                              double width) {
1842         if (forcedHeight &gt;= 0) {
1843             return forcedHeight;
1844         }
1845         final double normalizedWidth = (width &gt;= 0) ? width : -1;
1846         return root.boundedSize(root.prefHeight(normalizedWidth),
1847                                 root.minHeight(normalizedWidth),
1848                                 root.maxHeight(normalizedWidth));
1849     }
1850 
1851     private PerformanceTracker tracker;
1852     private static final Object trackerMonitor = new Object();
1853 
1854     // mouse events handling
1855     private MouseHandler mouseHandler;
1856     private ClickGenerator clickGenerator;
1857 
1858     // gesture events handling
1859     private Point2D cursorScreenPos;
1860     private Point2D cursorScenePos;
1861 
1862     private static class TouchGesture {
1863         WeakReference&lt;EventTarget&gt; target;
1864         Point2D sceneCoords;
1865         Point2D screenCoords;
1866         boolean finished;
1867     }
1868 
1869     private final TouchGesture scrollGesture = new TouchGesture();
1870     private final TouchGesture zoomGesture = new TouchGesture();
1871     private final TouchGesture rotateGesture = new TouchGesture();
1872     private final TouchGesture swipeGesture = new TouchGesture();
1873 
1874     // touch events handling
1875     private TouchMap touchMap = new TouchMap();
1876     private TouchEvent nextTouchEvent = null;
1877     private TouchPoint[] touchPoints = null;
1878     private int touchEventSetId = 0;
1879     private int touchPointIndex = 0;
1880     private Map&lt;Integer, EventTarget&gt; touchTargets =
1881             new HashMap&lt;Integer, EventTarget&gt;();
1882 
1883     void processMouseEvent(MouseEvent e) {
1884         mouseHandler.process(e, false);
1885     }
1886 
1887     private void processMenuEvent(double x2, double y2, double xAbs, double yAbs, boolean isKeyboardTrigger) {
1888         EventTarget eventTarget = null;
1889         Scene.inMousePick = true;
1890         if (isKeyboardTrigger) {
1891             Node sceneFocusOwner = getFocusOwner();
1892 
1893             // for keyboard triggers set coordinates inside focus owner
1894             final double xOffset = xAbs - x2;
1895             final double yOffset = yAbs - y2;
1896             if (sceneFocusOwner != null) {
1897                 final Bounds bounds = sceneFocusOwner.localToScene(
1898                         sceneFocusOwner.getBoundsInLocal());
1899                 x2 = bounds.getMinX() + bounds.getWidth() / 4;
1900                 y2 = bounds.getMinY() + bounds.getHeight() / 2;
1901                 eventTarget = sceneFocusOwner;
1902             } else {
1903                 x2 = Scene.this.getWidth() / 4;
1904                 y2 = Scene.this.getWidth() / 2;
1905                 eventTarget = Scene.this;
1906             }
1907 
1908             xAbs = x2 + xOffset;
1909             yAbs = y2 + yOffset;
1910         }
1911 
1912         final PickResult res = pick(x2, y2);
1913 
1914         if (!isKeyboardTrigger) {
1915             eventTarget = res.getIntersectedNode();
1916             if (eventTarget == null) {
1917                 eventTarget = this;
1918             }
1919         }
1920 
1921         if (eventTarget != null) {
1922             ContextMenuEvent context = new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,
1923                     x2, y2, xAbs, yAbs, isKeyboardTrigger, res);
1924             Event.fireEvent(eventTarget, context);
1925         }
1926         Scene.inMousePick = false;
1927     }
1928 
1929     private void processGestureEvent(GestureEvent e, TouchGesture gesture) {
1930         EventTarget pickedTarget = null;
1931 
1932         if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
1933                 e.getEventType() == RotateEvent.ROTATION_STARTED ||
1934                 e.getEventType() == ScrollEvent.SCROLL_STARTED) {
1935             gesture.target = null;
1936             gesture.finished = false;
1937         }
1938 
1939         if (gesture.target != null &amp;&amp; (!gesture.finished || e.isInertia())) {
1940             pickedTarget = gesture.target.get();
1941         } else {
1942             pickedTarget = e.getPickResult().getIntersectedNode();
1943             if (pickedTarget == null) {
1944                 pickedTarget = this;
1945             }
1946         }
1947 
1948         if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
1949                 e.getEventType() == RotateEvent.ROTATION_STARTED ||
1950                 e.getEventType() == ScrollEvent.SCROLL_STARTED) {
1951             gesture.target = new WeakReference&lt;&gt;(pickedTarget);
1952         }
1953         if (e.getEventType() != ZoomEvent.ZOOM_FINISHED &amp;&amp;
1954                 e.getEventType() != RotateEvent.ROTATION_FINISHED &amp;&amp;
1955                 e.getEventType() != ScrollEvent.SCROLL_FINISHED &amp;&amp;
1956                 !e.isInertia()) {
1957             gesture.sceneCoords = new Point2D(e.getSceneX(), e.getSceneY());
1958             gesture.screenCoords = new Point2D(e.getScreenX(), e.getScreenY());
1959         }
1960 
1961         if (pickedTarget != null) {
1962             Event.fireEvent(pickedTarget, e);
1963         }
1964 
1965         if (e.getEventType() == ZoomEvent.ZOOM_FINISHED ||
1966                 e.getEventType() == RotateEvent.ROTATION_FINISHED ||
1967                 e.getEventType() == ScrollEvent.SCROLL_FINISHED) {
1968             gesture.finished = true;
1969         }
1970     }
1971 
1972     private void processTouchEvent(TouchEvent e, TouchPoint[] touchPoints) {
1973         inMousePick = true;
1974         touchEventSetId++;
1975 
1976         List&lt;TouchPoint&gt; touchList = Arrays.asList(touchPoints);
1977 
1978         // fire all the events
1979         for (TouchPoint tp : touchPoints) {
1980             if (tp.getTarget() != null) {
1981                 EventType&lt;TouchEvent&gt; type = null;
1982                 switch (tp.getState()) {
1983                     case MOVED:
1984                         type = TouchEvent.TOUCH_MOVED;
1985                         break;
1986                     case PRESSED:
1987                         type = TouchEvent.TOUCH_PRESSED;
1988                         break;
1989                     case RELEASED:
1990                         type = TouchEvent.TOUCH_RELEASED;
1991                         break;
1992                     case STATIONARY:
1993                         type = TouchEvent.TOUCH_STATIONARY;
1994                         break;
1995                 }
1996 
1997                 for (TouchPoint t : touchPoints) {
1998                     TouchPointHelper.reset(t);
1999                 }
2000 
2001                 TouchEvent te = new TouchEvent(type, tp, touchList,
2002                         touchEventSetId, e.isShiftDown(), e.isControlDown(),
2003                         e.isAltDown(), e.isMetaDown());
2004 
2005                 Event.fireEvent(tp.getTarget(), te);
2006             }
2007         }
2008 
2009         // process grabbing
2010         for (TouchPoint tp : touchPoints) {
2011             EventTarget grabbed = tp.getGrabbed();
2012             if (grabbed != null) {
2013                 touchTargets.put(tp.getId(), grabbed);
2014             };
2015 
2016             if (grabbed == null || tp.getState() == TouchPoint.State.RELEASED) {
2017                 touchTargets.remove(tp.getId());
2018             }
2019         }
2020 
2021         inMousePick = false;
2022     }
2023 
2024     /**
2025      * Note: The only user of this method is in unit test: PickAndContainTest.
2026      */
2027     Node test_pick(double x, double y) {
2028         inMousePick = true;
2029         PickResult result = mouseHandler.pickNode(new PickRay(x, y, 1,
2030                 Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY));
2031         inMousePick = false;
2032         if (result != null) {
2033             return result.getIntersectedNode();
2034         }
2035         return null;
2036     }
2037 
2038     private PickResult pick(final double x, final double y) {
2039         pick(tmpTargetWrapper, x, y);
2040         return tmpTargetWrapper.getResult();
2041     }
2042 
2043     private boolean isInScene(double x, double y) {
2044         if (x &lt; 0 || y &lt; 0 || x &gt; getWidth() || y &gt; getHeight())  {
2045             return false;
2046         }
2047 
2048         Window w = getWindow();
2049         if (w instanceof Stage
2050                 &amp;&amp; ((Stage) w).getStyle() == StageStyle.TRANSPARENT
2051                 &amp;&amp; getFill() == null) {
2052             return false;
2053         }
2054 
2055         return true;
2056     }
2057 
2058     private void pick(TargetWrapper target, final double x, final double y) {
2059         final PickRay pickRay = getEffectiveCamera().computePickRay(
2060                 x, y, null);
2061 
2062         final double mag = pickRay.getDirectionNoClone().length();
2063         pickRay.getDirectionNoClone().normalize();
2064         final PickResult res = mouseHandler.pickNode(pickRay);
2065         if (res != null) {
2066             target.setNodeResult(res);
2067         } else {
2068             //TODO: is this the intersection with projection plane?
2069             Vec3d o = pickRay.getOriginNoClone();
2070             Vec3d d = pickRay.getDirectionNoClone();
2071             target.setSceneResult(new PickResult(
2072                     null, new Point3D(
2073                     o.x + mag * d.x,
2074                     o.y + mag * d.y,
2075                     o.z + mag * d.z),
2076                     mag),
2077                     isInScene(x, y) ? this : null);
2078         }
2079     }
2080 
2081     /***************************************************************************
2082      *                                                                         *
2083      * Key Events and Focus Traversal                                          *
2084      *                                                                         *
2085      **************************************************************************/
2086 
2087     /*
2088      * We cannot initialize keyHandler in init because some of the triggers
2089      * access it before the init block.
2090      * No clue why def keyHandler = bind lazy {KeyHandler{scene:this};}
2091      * does not compile.
2092      */
2093     private KeyHandler keyHandler = null;
2094     private KeyHandler getKeyHandler() {
2095         if (keyHandler == null) {
2096             keyHandler = new KeyHandler();
2097         }
2098         return keyHandler;
2099     }
2100     /**
2101      * Set to true if something has happened to the focused node that makes
2102      * it no longer eligible to have the focus.
2103      *
2104      */
2105     private boolean focusDirty = true;
2106 
2107     final void setFocusDirty(boolean value) {
2108         if (!focusDirty) {
2109             Toolkit.getToolkit().requestNextPulse();
2110         }
2111         focusDirty = value;
2112     }
2113 
2114     final boolean isFocusDirty() {
2115         return focusDirty;
2116     }
2117 
2118     private TopMostTraversalEngine traversalEngine = new SceneTraversalEngine(this);
2119 
2120     /**
2121      * Traverses focus from the given node in the given direction.
2122      */
2123     boolean traverse(Node node, Direction dir) {
2124         if (node.getSubScene() != null) {
2125             return node.getSubScene().traverse(node, dir);
2126         }
2127         return traversalEngine.trav(node, dir) != null;
2128     }
2129 
2130     /**
2131      * Moves the focus to a reasonable initial location. Called when a scene&#39;s
2132      * focus is dirty and there&#39;s no current owner, or if the owner has been
2133      * removed from the scene.
2134      */
2135     private void focusInitial() {
2136         traversalEngine.traverseToFirst();
2137     }
2138 
2139     /**
2140      * Moves the focus to a reasonble location &quot;near&quot; the given node.
2141      * Called when the focused node is no longer eligible to have
2142      * the focus because it has become invisible or disabled. This
2143      * function assumes that it is still a member of the same scene.
2144      */
2145     private void focusIneligible(Node node) {
2146         traverse(node, Direction.NEXT);
2147     }
2148 
2149     public void processKeyEvent(KeyEvent e) {
2150         if (dndGesture != null) {
2151             if (!dndGesture.processKey(e)) {
2152                 dndGesture = null;
2153             }
2154         }
2155 
2156         getKeyHandler().process(e);
2157     }
2158 
2159     void requestFocus(Node node) {
2160         getKeyHandler().requestFocus(node);
2161     }
2162 
2163     private Node oldFocusOwner;
2164 
2165     /**
2166       * The scene&#39;s current focus owner node. This node&#39;s &quot;focused&quot;
2167       * variable might be false if this scene has no window, or if the
2168       * window is inactive (window.focused == false).
2169       * @since JavaFX 2.2
2170       */
2171     private ReadOnlyObjectWrapper&lt;Node&gt; focusOwner = new ReadOnlyObjectWrapper&lt;Node&gt;(this, &quot;focusOwner&quot;) {
2172 
2173         @Override
2174         protected void invalidated() {
2175             if (oldFocusOwner != null) {
2176                 ((Node.FocusedProperty) oldFocusOwner.focusedProperty()).store(false);
2177             }
2178             Node value = get();
2179             if (value != null) {
2180                 ((Node.FocusedProperty) value.focusedProperty()).store(keyHandler.windowFocused);
2181                 if (value != oldFocusOwner) {
2182                     value.getScene().enableInputMethodEvents(
2183                             value.getInputMethodRequests() != null
2184                             &amp;&amp; value.getOnInputMethodTextChanged() != null);
2185                 }
2186             }
2187             // for the rest of the method we need to update the oldFocusOwner
2188             // and use a local copy of it because the user handlers can cause
2189             // recurrent calls of requestFocus
2190             Node localOldOwner = oldFocusOwner;
2191             oldFocusOwner = value;
2192             if (localOldOwner != null) {
2193                 ((Node.FocusedProperty) localOldOwner.focusedProperty()).notifyListeners();
2194             }
2195             if (value != null) {
2196                 ((Node.FocusedProperty) value.focusedProperty()).notifyListeners();
2197             }
2198             PlatformLogger logger = Logging.getFocusLogger();
2199             if (logger.isLoggable(Level.FINE)) {
2200                 if (value == get()) {
2201                     logger.fine(&quot;Changed focus from &quot;
2202                             + localOldOwner + &quot; to &quot; + value);
2203                 } else {
2204                     logger.fine(&quot;Changing focus from &quot;
2205                             + localOldOwner + &quot; to &quot; + value
2206                             + &quot; canceled by nested requestFocus&quot;);
2207                 }
2208             }
2209             if (accessible != null) {
2210                 accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
2211             }
2212         }
2213     };
2214 
2215     public final Node getFocusOwner() {
2216         return focusOwner.get();
2217     }
2218 
2219     public final ReadOnlyObjectProperty&lt;Node&gt; focusOwnerProperty() {
2220         return focusOwner.getReadOnlyProperty();
2221     }
2222 
2223     // For testing.
2224     void focusCleanup() {
2225         scenePulseListener.focusCleanup();
2226     }
2227 
2228     private void processInputMethodEvent(InputMethodEvent e) {
2229         Node node = getFocusOwner();
2230         if (node != null) {
2231             node.fireEvent(e);
2232         }
2233     }
2234 
2235     public void enableInputMethodEvents(boolean enable) {
2236        if (peer != null) {
2237            peer.enableInputMethodEvents(enable);
2238        }
2239     }
2240 
2241     /**
2242      * Returns true if this scene is quiescent, i.e. it has no activity
2243      * pending on it such as CSS processing or layout requests.
2244      *
2245      * Intended to be used for tests only
2246      *
2247      * @return boolean indicating whether the scene is quiescent
2248      */
2249     boolean isQuiescent() {
2250         final Parent r = getRoot();
2251         return !isFocusDirty()
2252                &amp;&amp; (r == null || (r.cssFlag == CssFlags.CLEAN &amp;&amp;
2253                 r.layoutFlag == LayoutFlags.CLEAN));
2254     }
2255 
2256     /**
2257      * A listener for pulses, used for testing. If non-null, this is called at
2258      * the very end of ScenePulseListener.pulse().
2259      *
2260      * Intended to be used for tests only
2261      */
2262     Runnable testPulseListener = null;
2263 
2264     /**
2265      * Set the specified dirty bit and mark the peer as dirty
2266      */
2267     private void markDirty(DirtyBits dirtyBit) {
2268         setDirty(dirtyBit);
2269         if (peer != null) {
2270             Toolkit.getToolkit().requestNextPulse();
2271         }
2272     }
2273 
2274     /**
2275      * Set the specified dirty bit
2276      */
2277     private void setDirty(DirtyBits dirtyBit) {
2278         dirtyBits.add(dirtyBit);
2279     }
2280 
2281     /**
2282      * Test the specified dirty bit
2283      */
2284     private boolean isDirty(DirtyBits dirtyBit) {
2285         return dirtyBits.contains(dirtyBit);
2286     }
2287 
2288     /**
2289      * Test whether the dirty bits are empty
2290      */
2291     private boolean isDirtyEmpty() {
2292         return dirtyBits.isEmpty();
2293     }
2294 
2295     /**
2296      * Clear all dirty bits
2297      */
2298     private void clearDirty() {
2299         dirtyBits.clear();
2300     }
2301 
2302     private enum DirtyBits {
2303         FILL_DIRTY,
2304         ROOT_DIRTY,
2305         CAMERA_DIRTY,
2306         LIGHTS_DIRTY,
2307         CURSOR_DIRTY;
2308     }
2309 
2310     private List&lt;LightBase&gt; lights = new ArrayList&lt;&gt;();
2311 
2312     // @param light must not be null
2313     final void addLight(LightBase light) {
2314         if (!lights.contains(light)) {
2315             lights.add(light);
2316             markDirty(DirtyBits.LIGHTS_DIRTY);
2317         }
2318     }
2319 
2320     final void removeLight(LightBase light) {
2321         if (lights.remove(light)) {
2322             markDirty(DirtyBits.LIGHTS_DIRTY);
2323         }
2324     }
2325 
2326     /**
2327      * PG Light synchronizer.
2328      */
2329     private void syncLights() {
2330         if (!isDirty(DirtyBits.LIGHTS_DIRTY)) {
2331             return;
2332         }
2333         inSynchronizer = true;
2334         NGLightBase peerLights[] = peer.getLights();
2335         if (!lights.isEmpty() || (peerLights != null)) {
2336             if (lights.isEmpty()) {
2337                 peer.setLights(null);
2338             } else {
2339                 if (peerLights == null || peerLights.length &lt; lights.size()) {
2340                     peerLights = new NGLightBase[lights.size()];
2341                 }
2342                 int i = 0;
2343                 for (; i &lt; lights.size(); i++) {
2344                     peerLights[i] = lights.get(i).getPeer();
2345                 }
2346                 // Clear the rest of the list
2347                 while (i &lt; peerLights.length &amp;&amp; peerLights[i] != null) {
2348                     peerLights[i++] = null;
2349                 }
2350                 peer.setLights(peerLights);
2351             }
2352         }
2353         inSynchronizer = false;
2354     }
2355 
2356     //INNER CLASSES
2357 
2358     /*******************************************************************************
2359      *                                                                             *
2360      * Scene Pulse Listener                                                        *
2361      *                                                                             *
2362      ******************************************************************************/
2363 
2364     class ScenePulseListener implements TKPulseListener {
2365 
2366         private boolean firstPulse = true;
2367 
2368         /**
2369          * PG synchronizer. Called once per frame from the pulse listener.
2370          * This function calls the synchronizePGNode method on each node in
2371          * the dirty list.
2372          */
2373         private void synchronizeSceneNodes() {
2374             Toolkit.getToolkit().checkFxUserThread();
2375 
2376             Scene.inSynchronizer = true;
2377 
2378             // if dirtyNodes is null then that means this Scene has not yet been
2379             // synchronized, and so we will simply synchronize every node in the
2380             // scene and then create the dirty nodes array list
2381             if (Scene.this.dirtyNodes == null) {
2382                 // must do this recursively
2383                 syncAll(getRoot());
2384                 dirtyNodes = new Node[MIN_DIRTY_CAPACITY];
2385 
2386             } else {
2387                 // This is not the first time this scene has been synchronized,
2388                 // so we will only synchronize those nodes that need it
2389                 for (int i = 0 ; i &lt; dirtyNodesSize; ++i) {
2390                     Node node = dirtyNodes[i];
2391                     dirtyNodes[i] = null;
2392                     if (node.getScene() == Scene.this) {
2393                             node.syncPeer();
2394                         }
2395                     }
2396                 dirtyNodesSize = 0;
2397             }
2398 
2399             Scene.inSynchronizer = false;
2400         }
2401 
2402         /**
2403          * Recursive function for synchronizing every node in the scenegraph.
2404          * The return value is the number of nodes in the graph.
2405          */
2406         private int syncAll(Node node) {
2407             node.syncPeer();
2408             int size = 1;
2409             if (node instanceof Parent) {
2410                 Parent p = (Parent) node;
2411                 final int childrenCount = p.getChildren().size();
2412 
2413                 for (int i = 0; i &lt; childrenCount; i++) {
2414                     Node n = p.getChildren().get(i);
2415                     if (n != null) {
2416                         size += syncAll(n);
2417                     }
2418                 }
2419             } else if (node instanceof SubScene) {
2420                 SubScene subScene = (SubScene)node;
2421                 size += syncAll(subScene.getRoot());
2422             }
2423             if (node.getClip() != null) {
2424                 size += syncAll(node.getClip());
2425             }
2426 
2427             return size;
2428         }
2429 
2430         private void synchronizeSceneProperties() {
2431             inSynchronizer = true;
2432             if (isDirty(DirtyBits.ROOT_DIRTY)) {
2433                 peer.setRoot(getRoot().getPeer());
2434             }
2435 
2436             if (isDirty(DirtyBits.FILL_DIRTY)) {
2437                 Toolkit tk = Toolkit.getToolkit();
2438                 peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
2439             }
2440 
2441             // new camera was set on the scene or old camera changed
2442             final Camera cam = getEffectiveCamera();
2443             if (isDirty(DirtyBits.CAMERA_DIRTY)) {
2444                 NodeHelper.updatePeer(cam);
2445                 peer.setCamera((NGCamera) cam.getPeer());
2446             }
2447 
2448             if (isDirty(DirtyBits.CURSOR_DIRTY)) {
2449                 mouseHandler.updateCursor(getCursor());
2450                 mouseHandler.updateCursorFrame();
2451             }
2452 
2453             clearDirty();
2454             inSynchronizer = false;
2455         }
2456 
2457         /**
2458          * The focus is considered dirty if something happened to
2459          * the scene graph that may require the focus to be moved.
2460          * This must handle cases where (a) the focus owner may have
2461          * become ineligible to have the focus, and (b) where the focus
2462          * owner is null and a node may have become traversable and eligible.
2463          */
2464         private void focusCleanup() {
2465             if (Scene.this.isFocusDirty()) {
2466                 final Node oldOwner = Scene.this.getFocusOwner();
2467                 if (oldOwner == null) {
2468                     Scene.this.focusInitial();
2469                 } else if (oldOwner.getScene() != Scene.this) {
2470                     Scene.this.requestFocus(null);
2471                     Scene.this.focusInitial();
2472                 } else if (!oldOwner.isCanReceiveFocus()) {
2473                     Scene.this.requestFocus(null);
2474                     Scene.this.focusIneligible(oldOwner);
2475                 }
2476                 Scene.this.setFocusDirty(false);
2477             }
2478         }
2479 
2480         @Override
2481         public void pulse() {
2482             if (Scene.this.tracker != null) {
2483                 Scene.this.tracker.pulse();
2484             }
2485             if (firstPulse) {
2486                 PerformanceTracker.logEvent(&quot;Scene - first repaint&quot;);
2487             }
2488 
2489             focusCleanup();
2490 
2491             disposeAccessibles();
2492 
2493             // run any scene pre pulse listeners immediately _before_ css / layout,
2494             // and before scene synchronization
2495             if (preLayoutPulseListeners != null) {
2496                 for (Runnable r : preLayoutPulseListeners) {
2497                     r.run();
2498                 }
2499             }
2500 
2501             if (PULSE_LOGGING_ENABLED) {
2502                 PulseLogger.newPhase(&quot;CSS Pass&quot;);
2503             }
2504             Scene.this.doCSSPass();
2505 
2506             if (PULSE_LOGGING_ENABLED) {
2507                 PulseLogger.newPhase(&quot;Layout Pass&quot;);
2508             }
2509             Scene.this.doLayoutPass();
2510 
2511             // run any scene post pulse listeners immediately _after_ css / layout,
2512             // and before scene synchronization
2513             if (postLayoutPulseListeners != null) {
2514                 for (Runnable r : postLayoutPulseListeners) {
2515                     r.run();
2516                 }
2517             }
2518 
2519             boolean dirty = dirtyNodes == null || dirtyNodesSize != 0 || !isDirtyEmpty();
2520             if (dirty) {
2521                 if (PULSE_LOGGING_ENABLED) {
2522                     PulseLogger.newPhase(&quot;Update bounds&quot;);
2523                 }
2524                 getRoot().updateBounds();
2525                 if (peer != null) {
2526                     try {
2527                         if (PULSE_LOGGING_ENABLED) {
2528                             PulseLogger.newPhase(&quot;Waiting for previous rendering&quot;);
2529                         }
2530                         peer.waitForRenderingToComplete();
2531                         peer.waitForSynchronization();
2532                         // synchronize scene properties
2533                         if (PULSE_LOGGING_ENABLED) {
2534                             PulseLogger.newPhase(&quot;Copy state to render graph&quot;);
2535                         }
2536                         syncLights();
2537                         synchronizeSceneProperties();
2538                         // Run the synchronizer
2539                         synchronizeSceneNodes();
2540                         Scene.this.mouseHandler.pulse();
2541                         // Tell the scene peer that it needs to repaint
2542                         peer.markDirty();
2543                     } finally {
2544                         peer.releaseSynchronization(true);
2545                     }
2546                 } else {
2547                     if (PULSE_LOGGING_ENABLED) {
2548                         PulseLogger.newPhase(&quot;Synchronize with null peer&quot;);
2549                     }
2550                     synchronizeSceneNodes();
2551                     Scene.this.mouseHandler.pulse();
2552                 }
2553 
2554                 if (Scene.this.getRoot().cssFlag != CssFlags.CLEAN) {
2555                     NodeHelper.markDirty(Scene.this.getRoot(),
2556                             com.sun.javafx.scene.DirtyBits.NODE_CSS);
2557                 }
2558             }
2559 
2560             // required for image cursor created from animated image
2561             Scene.this.mouseHandler.updateCursorFrame();
2562 
2563             if (firstPulse) {
2564                 if (PerformanceTracker.isLoggingEnabled()) {
2565                     PerformanceTracker.logEvent(&quot;Scene - first repaint - layout complete&quot;);
2566                     if (PrismSettings.perfLogFirstPaintFlush) {
2567                         PerformanceTracker.outputLog();
2568                     }
2569                     if (PrismSettings.perfLogFirstPaintExit) {
2570                         System.exit(0);
2571                     }
2572                 }
2573                 firstPulse = false;
2574             }
2575 
2576             if (testPulseListener != null) {
2577                 testPulseListener.run();
2578             }
2579         }
2580     }
2581 
2582     /*******************************************************************************
2583      *                                                                             *
2584      * Scene Peer Listener                                                         *
2585      *                                                                             *
2586      ******************************************************************************/
2587 
2588     class ScenePeerListener implements TKSceneListener {
2589         @Override
2590         public void changedLocation(float x, float y) {
2591             if (x != Scene.this.getX()) {
2592                 Scene.this.setX(x);
2593             }
2594             if (y != Scene.this.getY()) {
2595                 Scene.this.setY(y);
2596             }
2597         }
2598 
2599         @Override
2600         public void changedSize(float w, float h) {
2601             if (w != Scene.this.getWidth()) Scene.this.setWidth(w);
2602             if (h != Scene.this.getHeight()) Scene.this.setHeight(h);
2603         }
2604 
2605         @Override
2606         public void mouseEvent(EventType&lt;MouseEvent&gt; type, double x, double y, double screenX, double screenY,
2607                                MouseButton button, boolean popupTrigger, boolean synthesized,
2608                                boolean shiftDown, boolean controlDown, boolean altDown, boolean metaDown,
2609                                boolean primaryDown, boolean middleDown, boolean secondaryDown,
2610                                boolean backDown, boolean forwardDown)
2611         {
2612             MouseEvent mouseEvent = new MouseEvent(type, x, y, screenX, screenY, button,
2613                     0, // click count will be adjusted by clickGenerator later anyway
2614                     shiftDown, controlDown, altDown, metaDown,
2615                     primaryDown, middleDown, secondaryDown, backDown, forwardDown,
2616                     synthesized, popupTrigger, false, null);
2617             processMouseEvent(mouseEvent);
2618         }
2619 
2620 
2621         @Override
2622         public void keyEvent(KeyEvent keyEvent)
2623         {
2624             processKeyEvent(keyEvent);
2625         }
2626 
2627         @Override
2628         public void inputMethodEvent(EventType&lt;InputMethodEvent&gt; type,
2629                                      ObservableList&lt;InputMethodTextRun&gt; composed, String committed,
2630                                      int caretPosition)
2631         {
2632             InputMethodEvent inputMethodEvent = new InputMethodEvent(
2633                type, composed, committed, caretPosition);
2634             processInputMethodEvent(inputMethodEvent);
2635         }
2636 
2637         public void menuEvent(double x, double y, double xAbs, double yAbs,
2638                 boolean isKeyboardTrigger) {
2639             Scene.this.processMenuEvent(x, y, xAbs,yAbs, isKeyboardTrigger);
2640         }
2641 
2642         @Override
2643         public void scrollEvent(
2644                 EventType&lt;ScrollEvent&gt; eventType,
2645                 double scrollX, double scrollY,
2646                 double totalScrollX, double totalScrollY,
2647                 double xMultiplier, double yMultiplier,
2648                 int touchCount,
2649                 int scrollTextX, int scrollTextY,
2650                 int defaultTextX, int defaultTextY,
2651                 double x, double y, double screenX, double screenY,
2652                 boolean _shiftDown, boolean _controlDown,
2653                 boolean _altDown, boolean _metaDown,
2654                 boolean _direct, boolean _inertia) {
2655 
2656             ScrollEvent.HorizontalTextScrollUnits xUnits = scrollTextX &gt; 0 ?
2657                     ScrollEvent.HorizontalTextScrollUnits.CHARACTERS :
2658                     ScrollEvent.HorizontalTextScrollUnits.NONE;
2659 
2660             double xText = scrollTextX &lt; 0 ? 0 : scrollTextX * scrollX;
2661 
2662             ScrollEvent.VerticalTextScrollUnits yUnits = scrollTextY &gt; 0 ?
2663                     ScrollEvent.VerticalTextScrollUnits.LINES :
2664                     (scrollTextY &lt; 0 ?
2665                         ScrollEvent.VerticalTextScrollUnits.PAGES :
2666                         ScrollEvent.VerticalTextScrollUnits.NONE);
2667 
2668             double yText = scrollTextY &lt; 0 ? scrollY : scrollTextY * scrollY;
2669 
2670             xMultiplier = defaultTextX &gt; 0 &amp;&amp; scrollTextX &gt;= 0
2671                     ? Math.round(xMultiplier * scrollTextX / defaultTextX)
2672                     : xMultiplier;
2673 
2674             yMultiplier = defaultTextY &gt; 0 &amp;&amp; scrollTextY &gt;= 0
2675                     ? Math.round(yMultiplier * scrollTextY / defaultTextY)
2676                     : yMultiplier;
2677 
2678             if (eventType == ScrollEvent.SCROLL_FINISHED) {
2679                 x = scrollGesture.sceneCoords.getX();
2680                 y = scrollGesture.sceneCoords.getY();
2681                 screenX = scrollGesture.screenCoords.getX();
2682                 screenY = scrollGesture.screenCoords.getY();
2683             } else if (Double.isNaN(x) || Double.isNaN(y) ||
2684                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2685                 if (cursorScenePos == null || cursorScreenPos == null) {
2686                     return;
2687                 }
2688                 x = cursorScenePos.getX();
2689                 y = cursorScenePos.getY();
2690                 screenX = cursorScreenPos.getX();
2691                 screenY = cursorScreenPos.getY();
2692             }
2693 
2694             inMousePick = true;
2695             Scene.this.processGestureEvent(new ScrollEvent(
2696                     eventType,
2697                     x, y, screenX, screenY,
2698                     _shiftDown, _controlDown, _altDown, _metaDown,
2699                     _direct, _inertia,
2700                     scrollX * xMultiplier, scrollY * yMultiplier,
2701                     totalScrollX * xMultiplier, totalScrollY * yMultiplier,
2702                     xMultiplier, yMultiplier,
2703                     xUnits, xText, yUnits, yText, touchCount, pick(x, y)),
2704                     scrollGesture);
2705             inMousePick = false;
2706         }
2707 
2708         @Override
2709         public void zoomEvent(
2710                 EventType&lt;ZoomEvent&gt; eventType,
2711                 double zoomFactor, double totalZoomFactor,
2712                 double x, double y, double screenX, double screenY,
2713                 boolean _shiftDown, boolean _controlDown,
2714                 boolean _altDown, boolean _metaDown,
2715                 boolean _direct, boolean _inertia) {
2716 
2717             if (eventType == ZoomEvent.ZOOM_FINISHED) {
2718                 x = zoomGesture.sceneCoords.getX();
2719                 y = zoomGesture.sceneCoords.getY();
2720                 screenX = zoomGesture.screenCoords.getX();
2721                 screenY = zoomGesture.screenCoords.getY();
2722             } else if (Double.isNaN(x) || Double.isNaN(y) ||
2723                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2724                 if (cursorScenePos == null || cursorScreenPos == null) {
2725                     return;
2726                 }
2727                 x = cursorScenePos.getX();
2728                 y = cursorScenePos.getY();
2729                 screenX = cursorScreenPos.getX();
2730                 screenY = cursorScreenPos.getY();
2731             }
2732 
2733             inMousePick = true;
2734             Scene.this.processGestureEvent(new ZoomEvent(eventType,
2735                     x, y, screenX, screenY,
2736                     _shiftDown, _controlDown, _altDown, _metaDown,
2737                     _direct, _inertia,
2738                     zoomFactor, totalZoomFactor, pick(x, y)),
2739                     zoomGesture);
2740             inMousePick = false;
2741         }
2742 
2743         @Override
2744         public void rotateEvent(
2745                 EventType&lt;RotateEvent&gt; eventType, double angle, double totalAngle,
2746                 double x, double y, double screenX, double screenY,
2747                 boolean _shiftDown, boolean _controlDown,
2748                 boolean _altDown, boolean _metaDown,
2749                 boolean _direct, boolean _inertia) {
2750 
2751             if (eventType == RotateEvent.ROTATION_FINISHED) {
2752                 x = rotateGesture.sceneCoords.getX();
2753                 y = rotateGesture.sceneCoords.getY();
2754                 screenX = rotateGesture.screenCoords.getX();
2755                 screenY = rotateGesture.screenCoords.getY();
2756             } else if (Double.isNaN(x) || Double.isNaN(y) ||
2757                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2758                 if (cursorScenePos == null || cursorScreenPos == null) {
2759                     return;
2760                 }
2761                 x = cursorScenePos.getX();
2762                 y = cursorScenePos.getY();
2763                 screenX = cursorScreenPos.getX();
2764                 screenY = cursorScreenPos.getY();
2765             }
2766 
2767             inMousePick = true;
2768             Scene.this.processGestureEvent(new RotateEvent(
2769                     eventType, x, y, screenX, screenY,
2770                     _shiftDown, _controlDown, _altDown, _metaDown,
2771                     _direct, _inertia, angle, totalAngle, pick(x, y)),
2772                     rotateGesture);
2773             inMousePick = false;
2774 
2775         }
2776 
2777         @Override
2778         public void swipeEvent(
2779                 EventType&lt;SwipeEvent&gt; eventType, int touchCount,
2780                 double x, double y, double screenX, double screenY,
2781                 boolean _shiftDown, boolean _controlDown,
2782                 boolean _altDown, boolean _metaDown, boolean _direct) {
2783 
2784             if (Double.isNaN(x) || Double.isNaN(y) ||
2785                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2786                 if (cursorScenePos == null || cursorScreenPos == null) {
2787                     return;
2788                 }
2789                 x = cursorScenePos.getX();
2790                 y = cursorScenePos.getY();
2791                 screenX = cursorScreenPos.getX();
2792                 screenY = cursorScreenPos.getY();
2793             }
2794 
2795             inMousePick = true;
2796             Scene.this.processGestureEvent(new SwipeEvent(
2797                     eventType, x, y, screenX, screenY,
2798                     _shiftDown, _controlDown, _altDown, _metaDown, _direct,
2799                     touchCount, pick(x, y)),
2800                     swipeGesture);
2801             inMousePick = false;
2802         }
2803 
2804         @Override
2805         public void touchEventBegin(
2806                 long time, int touchCount, boolean isDirect,
2807                 boolean _shiftDown, boolean _controlDown,
2808                 boolean _altDown, boolean _metaDown) {
2809 
2810             if (!isDirect) {
2811                 nextTouchEvent = null;
2812                 return;
2813             }
2814             nextTouchEvent = new TouchEvent(
2815                     TouchEvent.ANY, null, null, 0,
2816                     _shiftDown, _controlDown, _altDown, _metaDown);
2817             if (touchPoints == null || touchPoints.length != touchCount) {
2818                 touchPoints = new TouchPoint[touchCount];
2819             }
2820             touchPointIndex = 0;
2821         }
2822 
2823         @Override
2824         public void touchEventNext(
2825                 TouchPoint.State state, long touchId,
2826                 double x, double y, double screenX, double screenY) {
2827 
2828             inMousePick = true;
2829             if (nextTouchEvent == null) {
2830                 // ignore indirect touch events
2831                 return;
2832             }
2833             touchPointIndex++;
2834             int id = (state == TouchPoint.State.PRESSED
2835                     ? touchMap.add(touchId) :  touchMap.get(touchId));
2836             if (state == TouchPoint.State.RELEASED) {
2837                 touchMap.remove(touchId);
2838             }
2839             int order = touchMap.getOrder(id);
2840 
2841             if (order &gt;= touchPoints.length) {
2842                 throw new RuntimeException(&quot;Too many touch points reported&quot;);
2843             }
2844 
2845             // pick target
2846             boolean isGrabbed = false;
2847             PickResult pickRes = pick(x, y);
2848             EventTarget pickedTarget = touchTargets.get(id);
2849             if (pickedTarget == null) {
2850                 pickedTarget = pickRes.getIntersectedNode();
2851                 if (pickedTarget == null) {
2852                     pickedTarget = Scene.this;
2853                 }
2854             } else {
2855                 isGrabbed = true;
2856             }
2857 
2858             TouchPoint tp = new TouchPoint(id, state,
2859                     x, y, screenX, screenY, pickedTarget, pickRes);
2860 
2861             touchPoints[order] = tp;
2862 
2863             if (isGrabbed) {
2864                 tp.grab(pickedTarget);
2865             }
2866             if (tp.getState() == TouchPoint.State.PRESSED) {
2867                 tp.grab(pickedTarget);
2868                 touchTargets.put(tp.getId(), pickedTarget);
2869             } else if (tp.getState() == TouchPoint.State.RELEASED) {
2870                 touchTargets.remove(tp.getId());
2871             }
2872             inMousePick = false;
2873         }
2874 
2875         @Override
2876         public void touchEventEnd() {
2877             if (nextTouchEvent == null) {
2878                 // ignore indirect touch events
2879                 return;
2880             }
2881 
2882             if (touchPointIndex != touchPoints.length) {
2883                 throw new RuntimeException(&quot;Wrong number of touch points reported&quot;);
2884             }
2885 
2886             Scene.this.processTouchEvent(nextTouchEvent, touchPoints);
2887 
2888             if (touchMap.cleanup()) {
2889                 // gesture finished
2890                 touchEventSetId = 0;
2891             }
2892         }
2893 
2894         @Override
2895         public Accessible getSceneAccessible() {
2896             return getAccessible();
2897         }
2898     }
2899 
2900     private class ScenePeerPaintListener implements TKScenePaintListener {
2901         @Override
2902         public void frameRendered() {
2903             // must use tracker with synchronization since this method is called on render thread
2904             synchronized (trackerMonitor) {
2905                 if (Scene.this.tracker != null) {
2906                     Scene.this.tracker.frameRendered();
2907                 }
2908             }
2909         }
2910     }
2911 
2912     /*******************************************************************************
2913      *                                                                             *
2914      * Drag and Drop                                                               *
2915      *                                                                             *
2916      ******************************************************************************/
2917 
2918     class DropTargetListener implements TKDropTargetListener {
2919 
2920         /*
2921          * This function is called when an drag operation enters a valid drop target.
2922          * This may be from either an internal or external dnd operation.
2923          */
2924         @Override
2925         public TransferMode dragEnter(double x, double y, double screenX, double screenY,
2926                                       TransferMode transferMode, TKClipboard dragboard)
2927         {
2928             if (dndGesture == null) {
2929                 dndGesture = new DnDGesture();
2930             }
2931             Dragboard db = DragboardHelper.createDragboard(dragboard);
2932             dndGesture.dragboard = db;
2933             DragEvent dragEvent =
2934                     new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2935                             transferMode, null, null, pick(x, y));
2936             return dndGesture.processTargetEnterOver(dragEvent);
2937         }
2938 
2939         @Override
2940         public TransferMode dragOver(double x, double y, double screenX, double screenY,
2941                                      TransferMode transferMode)
2942         {
2943             if (Scene.this.dndGesture == null) {
2944                 System.err.println(&quot;GOT A dragOver when dndGesture is null!&quot;);
2945                 return null;
2946             } else {
2947                 if (dndGesture.dragboard == null) {
2948                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragOver&quot;);
2949                 }
2950                 DragEvent dragEvent =
2951                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2952                                 transferMode, null, null, pick(x, y));
2953                 return dndGesture.processTargetEnterOver(dragEvent);
2954             }
2955         }
2956 
2957         @Override
2958         public void dragExit(double x, double y, double screenX, double screenY) {
2959             if (dndGesture == null) {
2960                 System.err.println(&quot;GOT A dragExit when dndGesture is null!&quot;);
2961             } else {
2962                 if (dndGesture.dragboard == null) {
2963                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragExit&quot;);
2964                 }
2965                 DragEvent dragEvent =
2966                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2967                                 null, null, null, pick(x, y));
2968                 dndGesture.processTargetExit(dragEvent);
2969                 if (dndGesture.source == null) {
2970                     dndGesture.dragboard = null;
2971                     dndGesture = null;
2972                 }
2973             }
2974         }
2975 
2976 
2977         @Override
2978         public TransferMode drop(double x, double y, double screenX, double screenY,
2979                                   TransferMode transferMode)
2980         {
2981             if (dndGesture == null) {
2982                 System.err.println(&quot;GOT A drop when dndGesture is null!&quot;);
2983                 return null;
2984             } else {
2985                 if (dndGesture.dragboard == null) {
2986                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDrop&quot;);
2987                 }
2988                 DragEvent dragEvent =
2989                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2990                                 transferMode, null, null, pick(x, y));
2991                 // Data dropped to the app can be accessed without restriction
2992                 DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);
2993 
2994                 TransferMode tm;
2995                 try {
2996                     tm = dndGesture.processTargetDrop(dragEvent);
2997                 } finally {
2998                     DragboardHelper.setDataAccessRestriction(
2999                             dndGesture.dragboard, true);
3000                 }
3001 
3002                 if (dndGesture.source == null) {
3003                     dndGesture.dragboard = null;
3004                     dndGesture = null;
3005                 }
3006                 return tm;
3007             }
3008         }
3009     }
3010 
3011     class DragGestureListener implements TKDragGestureListener {
3012 
3013        @Override
3014        public void dragGestureRecognized(double x, double y, double screenX, double screenY,
3015                                          int button, TKClipboard dragboard)
3016        {
3017            Dragboard db = DragboardHelper.createDragboard(dragboard);
3018            dndGesture = new DnDGesture();
3019            dndGesture.dragboard = db;
3020            // TODO: support mouse buttons in DragEvent
3021            DragEvent dragEvent = new DragEvent(DragEvent.ANY, db, x, y, screenX, screenY,
3022                    null, null, null, pick(x, y));
3023            dndGesture.processRecognized(dragEvent);
3024            dndGesture = null;
3025         }
3026     }
3027 
3028     /**
3029      * A Drag and Drop gesture has a lifespan that lasts from mouse
3030      * PRESSED event to mouse RELEASED event.
3031      */
3032     class DnDGesture {
3033         private final double hysteresisSizeX =
3034                 Toolkit.getToolkit().getMultiClickMaxX();
3035         private final double hysteresisSizeY =
3036                 Toolkit.getToolkit().getMultiClickMaxY();
3037 
3038         private EventTarget source = null;
3039         private Set&lt;TransferMode&gt; sourceTransferModes = null;
3040         private TransferMode acceptedTransferMode = null;
3041         private Dragboard dragboard = null;
3042         private EventTarget potentialTarget = null;
3043         private EventTarget target = null;
3044         private DragDetectedState dragDetected = DragDetectedState.NOT_YET;
3045         private double pressedX;
3046         private double pressedY;
3047         private List&lt;EventTarget&gt; currentTargets = new ArrayList&lt;EventTarget&gt;();
3048         private List&lt;EventTarget&gt; newTargets = new ArrayList&lt;EventTarget&gt;();
3049         private EventTarget fullPDRSource = null;
3050 
3051         /**
3052          * Fires event on a given target or on scene if the node is null
3053          */
3054         private void fireEvent(EventTarget target, Event e) {
3055             if (target != null) {
3056                 Event.fireEvent(target, e);
3057             }
3058         }
3059 
3060         /**
3061          * Called when DRAG_DETECTED event is going to be processed by
3062          * application
3063          */
3064         private void processingDragDetected() {
3065             dragDetected = DragDetectedState.PROCESSING;
3066         }
3067 
3068         /**
3069          * Called after DRAG_DETECTED event has been processed by application
3070          */
3071         private void dragDetectedProcessed() {
3072             dragDetected = DragDetectedState.DONE;
3073             final boolean hasContent = (dragboard != null) &amp;&amp; (ClipboardHelper.contentPut(dragboard));
3074             if (hasContent) {
3075                 /* start DnD */
3076                 Toolkit.getToolkit().startDrag(Scene.this.peer,
3077                                                 sourceTransferModes,
3078                                                 new DragSourceListener(),
3079                                                 dragboard);
3080             } else if (fullPDRSource != null) {
3081                 /* start PDR */
3082                 Scene.this.mouseHandler.enterFullPDR(fullPDRSource);
3083             }
3084 
3085             fullPDRSource = null;
3086         }
3087 
3088         /**
3089          * Sets the default dragDetect value
3090          */
3091         private void processDragDetection(MouseEvent mouseEvent) {
3092 
3093             if (dragDetected != DragDetectedState.NOT_YET) {
3094                 mouseEvent.setDragDetect(false);
3095                 return;
3096             }
3097 
3098             if (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED) {
3099                 pressedX = mouseEvent.getSceneX();
3100                 pressedY = mouseEvent.getSceneY();
3101 
3102                 mouseEvent.setDragDetect(false);
3103 
3104             } else if (mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) {
3105 
3106                 double deltaX = Math.abs(mouseEvent.getSceneX() - pressedX);
3107                 double deltaY = Math.abs(mouseEvent.getSceneY() - pressedY);
3108                 mouseEvent.setDragDetect(deltaX &gt; hysteresisSizeX ||
3109                                          deltaY &gt; hysteresisSizeY);
3110 
3111             }
3112         }
3113 
3114         /**
3115          * This function is useful for drag gesture recognition from
3116          * within this Scene (as opposed to in the TK implementation... by the platform)
3117          */
3118         private boolean process(MouseEvent mouseEvent, EventTarget target) {
3119             boolean continueProcessing = true;
3120             if (!PLATFORM_DRAG_GESTURE_INITIATION) {
3121 
3122                 if (dragDetected != DragDetectedState.DONE &amp;&amp;
3123                         (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED ||
3124                         mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) &amp;&amp;
3125                         mouseEvent.isDragDetect()) {
3126 
3127                     processingDragDetected();
3128 
3129                     if (target != null) {
3130                         final MouseEvent detectedEvent = mouseEvent.copyFor(
3131                                 mouseEvent.getSource(), target,
3132                                 MouseEvent.DRAG_DETECTED);
3133 
3134                         try {
3135                             fireEvent(target, detectedEvent);
3136                         } finally {
3137                             // Putting data to dragboard finished, restrict access to them
3138                             if (dragboard != null) {
3139                                 DragboardHelper.setDataAccessRestriction(
3140                                         dragboard, true);
3141                             }
3142                         }
3143                     }
3144 
3145                     dragDetectedProcessed();
3146                 }
3147 
3148                 if (mouseEvent.getEventType() == MouseEvent.MOUSE_RELEASED) {
3149                     continueProcessing = false;
3150                 }
3151             }
3152             return continueProcessing;
3153         }
3154 
3155         /*
3156          * Called when a drag source is recognized. This occurs at the very start of
3157          * the publicly visible drag and drop API, as it is responsible for calling
3158          * the Node.onDragSourceRecognized function.
3159          */
3160         private boolean processRecognized(DragEvent de) {
3161             MouseEvent me = new MouseEvent(
3162                     MouseEvent.DRAG_DETECTED, de.getX(), de.getY(),
3163                     de.getSceneX(), de.getScreenY(), MouseButton.PRIMARY, 1,
3164                     false, false, false, false, false, true, false, false, false,
3165                     false, de.getPickResult());
3166 
3167             processingDragDetected();
3168 
3169             final EventTarget target = de.getPickResult().getIntersectedNode();
3170             try {
3171                 fireEvent(target != null ? target : Scene.this, me);
3172             } finally {
3173                 // Putting data to dragboard finished, restrict access to them
3174                 if (dragboard != null) {
3175                     DragboardHelper.setDataAccessRestriction(
3176                             dragboard, true);
3177                 }
3178             }
3179 
3180             dragDetectedProcessed();
3181 
3182             final boolean hasContent = dragboard != null
3183                     &amp;&amp; !dragboard.getContentTypes().isEmpty();
3184             return hasContent;
3185         }
3186 
3187         private void processDropEnd(DragEvent de) {
3188             if (source == null) {
3189                 System.out.println(&quot;Scene.DnDGesture.processDropEnd() - UNEXPECTD - source is NULL&quot;);
3190                 return;
3191             }
3192 
3193             de = new DragEvent(de.getSource(), source, DragEvent.DRAG_DONE,
3194                     de.getDragboard(), de.getSceneX(), de.getSceneY(),
3195                     de.getScreenX(), de.getScreenY(),
3196                     de.getTransferMode(), source, target, de.getPickResult());
3197 
3198             Event.fireEvent(source, de);
3199 
3200             tmpTargetWrapper.clear();
3201             handleExitEnter(de, tmpTargetWrapper);
3202 
3203             // at this point the drag and drop operation is completely over, so we
3204             // can tell the toolkit that it can clean up if needs be.
3205             Toolkit.getToolkit().stopDrag(dragboard);
3206         }
3207 
3208         private TransferMode processTargetEnterOver(DragEvent de) {
3209             pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
3210             final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();
3211 
3212             if (dragboard == null) {
3213                 dragboard = createDragboard(de, false);
3214             }
3215 
3216             de = new DragEvent(de.getSource(), pickedTarget, de.getEventType(),
3217                     dragboard, de.getSceneX(), de.getSceneY(),
3218                     de.getScreenX(), de.getScreenY(),
3219                     de.getTransferMode(), source, potentialTarget, de.getPickResult());
3220 
3221             handleExitEnter(de, tmpTargetWrapper);
3222 
3223             de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_OVER,
3224                     de.getDragboard(), de.getSceneX(), de.getSceneY(),
3225                     de.getScreenX(), de.getScreenY(),
3226                     de.getTransferMode(), source, potentialTarget, de.getPickResult());
3227 
3228             fireEvent(pickedTarget, de);
3229 
3230             Object acceptingObject = de.getAcceptingObject();
3231             potentialTarget = acceptingObject instanceof EventTarget
3232                     ? (EventTarget) acceptingObject : null;
3233             acceptedTransferMode = de.getAcceptedTransferMode();
3234             return acceptedTransferMode;
3235         }
3236 
3237         private void processTargetActionChanged(DragEvent de) {
3238             // Do we want DRAG_TRANSFER_MODE_CHANGED event?
3239 //            final Node pickedNode = Scene.this.mouseHandler.pickNode(de.getX(), de.getY());
3240 //            if (pickedNode != null &amp;&amp; pickedNode.isTreeVisible()) {
3241 //                de = DragEvent.copy(de.getSource(), pickedNode, source,
3242 //                        pickedNode, de, DragEvent.DRAG_TRANSFER_MODE_CHANGED);
3243 //
3244 //                if (dragboard == null) {
3245 //                    dragboard = createDragboard(de);
3246 //                }
3247 //                dragboard = de.getPlatformDragboard();
3248 //
3249 //                fireEvent(pickedNode, de);
3250 //            }
3251         }
3252 
3253         private void processTargetExit(DragEvent de) {
3254             if (dragboard == null) {
3255                 // dragboard should have been created in processTargetEnterOver()
3256                 throw new NullPointerException(&quot;dragboard is null in processTargetExit()&quot;);
3257             }
3258 
3259             if (currentTargets.size() &gt; 0) {
3260                 potentialTarget = null;
3261                 tmpTargetWrapper.clear();
3262                 handleExitEnter(de, tmpTargetWrapper);
3263             }
3264         }
3265 
3266         private TransferMode processTargetDrop(DragEvent de) {
3267             pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
3268             final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();
3269 
3270             de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_DROPPED,
3271                     de.getDragboard(), de.getSceneX(), de.getSceneY(),
3272                     de.getScreenX(), de.getScreenY(),
3273                     acceptedTransferMode, source, potentialTarget, de.getPickResult());
3274 
3275             if (dragboard == null) {
3276                 // dragboard should have been created in processTargetEnterOver()
3277                 throw new NullPointerException(&quot;dragboard is null in processTargetDrop()&quot;);
3278             }
3279 
3280             handleExitEnter(de, tmpTargetWrapper);
3281 
3282             fireEvent(pickedTarget, de);
3283 
3284             Object acceptingObject = de.getAcceptingObject();
3285             potentialTarget = acceptingObject instanceof EventTarget
3286                     ? (EventTarget) acceptingObject : null;
3287             target = potentialTarget;
3288 
3289             TransferMode result = de.isDropCompleted() ?
3290                 de.getAcceptedTransferMode() : null;
3291 
3292             tmpTargetWrapper.clear();
3293             handleExitEnter(de, tmpTargetWrapper);
3294 
3295             return result;
3296         }
3297 
3298         private void handleExitEnter(DragEvent e, TargetWrapper target) {
3299             EventTarget currentTarget =
3300                     currentTargets.size() &gt; 0 ? currentTargets.get(0) : null;
3301 
3302             if (target.getEventTarget() != currentTarget) {
3303 
3304                 target.fillHierarchy(newTargets);
3305 
3306                 int i = currentTargets.size() - 1;
3307                 int j = newTargets.size() - 1;
3308 
3309                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentTargets.get(i) == newTargets.get(j)) {
3310                     i--;
3311                     j--;
3312                 }
3313 
3314                 for (; i &gt;= 0; i--) {
3315                     EventTarget t = currentTargets.get(i);
3316                     if (potentialTarget == t) {
3317                         potentialTarget = null;
3318                     }
3319                     e = e.copyFor(e.getSource(), t, source,
3320                             potentialTarget, DragEvent.DRAG_EXITED_TARGET);
3321                     Event.fireEvent(t, e);
3322                 }
3323 
3324                 potentialTarget = null;
3325                 for (; j &gt;= 0; j--) {
3326                     EventTarget t = newTargets.get(j);
3327                     e = e.copyFor(e.getSource(), t, source,
3328                             potentialTarget, DragEvent.DRAG_ENTERED_TARGET);
3329                     Object acceptingObject = e.getAcceptingObject();
3330                     if (acceptingObject instanceof EventTarget) {
3331                         potentialTarget = (EventTarget) acceptingObject;
3332                     }
3333                     Event.fireEvent(t, e);
3334                 }
3335 
3336                 currentTargets.clear();
3337                 currentTargets.addAll(newTargets);
3338                 newTargets.clear();
3339             }
3340         }
3341 
3342 //        function getIntendedTransferMode(e:MouseEvent):TransferMode {
3343 //            return if (e.altDown) TransferMode.COPY else TransferMode.MOVE;
3344 //        }
3345 
3346         /*
3347          * Function that hooks into the key processing code in Scene to handle the
3348          * situation where a drag and drop event is taking place and the user presses
3349          * the escape key to cancel the drag and drop operation.
3350          */
3351         private boolean processKey(KeyEvent e) {
3352             //note: this seems not to be called, the DnD cancelation is provided by platform
3353             if ((e.getEventType() == KeyEvent.KEY_PRESSED) &amp;&amp; (e.getCode() == KeyCode.ESCAPE)) {
3354 
3355                 // cancel drag and drop
3356                 DragEvent de = new DragEvent(
3357                         source, source, DragEvent.DRAG_DONE, dragboard, 0, 0, 0, 0,
3358                         null, source, null, null);
3359                 if (source != null) {
3360                     Event.fireEvent(source, de);
3361                 }
3362 
3363                 tmpTargetWrapper.clear();
3364                 handleExitEnter(de, tmpTargetWrapper);
3365 
3366                 return false;
3367             }
3368             return true;
3369         }
3370 
3371         /*
3372          * This starts the drag gesture running, creating the dragboard used for
3373          * the remainder of this drag and drop operation.
3374          */
3375         private Dragboard startDrag(EventTarget source, Set&lt;TransferMode&gt; t) {
3376             if (dragDetected != DragDetectedState.PROCESSING) {
3377                 throw new IllegalStateException(&quot;Cannot start drag and drop &quot;
3378                         + &quot;outside of DRAG_DETECTED event handler&quot;);
3379             }
3380 
3381             if (t.isEmpty()) {
3382                 dragboard = null;
3383             } else if (dragboard == null) {
3384                 dragboard = createDragboard(null, true);
3385             }
3386 
3387             // The app can see what it puts to dragboard without restriction
3388             DragboardHelper.setDataAccessRestriction(dragboard, false);
3389 
3390             this.source = source;
3391             potentialTarget = source;
3392             sourceTransferModes = t;
3393             return dragboard;
3394         }
3395 
3396         /*
3397          * This starts the full PDR gesture.
3398          */
3399         private void startFullPDR(EventTarget source) {
3400             fullPDRSource = source;
3401         }
3402 
3403         private Dragboard createDragboard(final DragEvent de, boolean isDragSource) {
3404             Dragboard dragboard = null;
3405             if (de != null) {
3406                 dragboard = de.getDragboard();
3407                 if (dragboard != null) {
3408                     return dragboard;
3409                 }
3410             }
3411             TKClipboard dragboardPeer = peer.createDragboard(isDragSource);
3412             return DragboardHelper.createDragboard(dragboardPeer);
3413         }
3414     }
3415 
3416     /**
3417      * State of a drag gesture with regards to DRAG_DETECTED event.
3418      */
3419     private enum DragDetectedState {
3420         NOT_YET,
3421         PROCESSING,
3422         DONE
3423     }
3424 
3425     class DragSourceListener implements TKDragSourceListener {
3426 
3427         @Override
3428         public void dragDropEnd(double x, double y, double screenX, double screenY,
3429                                 TransferMode transferMode)
3430         {
3431             if (dndGesture != null) {
3432                 if (dndGesture.dragboard == null) {
3433                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDropEnd&quot;);
3434                 }
3435                 DragEvent dragEvent =
3436                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
3437                         transferMode, null, null, null);
3438 
3439                 // DRAG_DONE event is delivered to gesture source, it can access
3440                 // its own data without restriction
3441                 DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);
3442                 try {
3443                     dndGesture.processDropEnd(dragEvent);
3444                 } finally {
3445                     DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, true);
3446                 }
3447                 dndGesture = null;
3448             }
3449         }
3450     }
3451 
3452     /*******************************************************************************
3453      *                                                                             *
3454      * Mouse Event Handling                                                        *
3455      *                                                                             *
3456      ******************************************************************************/
3457 
3458     static class ClickCounter {
3459         Toolkit toolkit = Toolkit.getToolkit();
3460         private int count;
3461         private boolean out;
3462         private boolean still;
3463         private Timeline timeout;
3464         private double pressedX, pressedY;
3465 
3466         private void inc() { count++; }
3467         private int get() { return count; }
3468         private boolean isStill() { return still; }
3469 
3470         private void clear() {
3471             count = 0;
3472             stopTimeout();
3473         }
3474 
3475         private void out() {
3476             out = true;
3477             stopTimeout();
3478         }
3479 
3480         private void applyOut() {
3481             if (out) clear();
3482             out = false;
3483         }
3484 
3485         private void moved(double x, double y) {
3486             if (Math.abs(x - pressedX) &gt; toolkit.getMultiClickMaxX() ||
3487                     Math.abs(y - pressedY) &gt; toolkit.getMultiClickMaxY()) {
3488                 out();
3489                 still = false;
3490             }
3491         }
3492 
3493         private void start(double x, double y) {
3494             pressedX = x;
3495             pressedY = y;
3496             out = false;
3497 
3498             if (timeout != null) {
3499                 timeout.stop();
3500             }
3501             timeout = new Timeline();
3502             timeout.getKeyFrames().add(
3503                     new KeyFrame(new Duration(toolkit.getMultiClickTime()),
3504                             event -&gt; {
3505                                 out = true;
3506                                 timeout = null;
3507                             }
3508                     ));
3509             timeout.play();
3510             still = true;
3511         }
3512 
3513         private void stopTimeout() {
3514             if (timeout != null) {
3515                 timeout.stop();
3516                 timeout = null;
3517             }
3518         }
3519     }
3520 
3521     static class ClickGenerator {
3522         private ClickCounter lastPress = null;
3523 
3524         private Map&lt;MouseButton, ClickCounter&gt; counters =
3525                 new EnumMap&lt;MouseButton, ClickCounter&gt;(MouseButton.class);
3526         private List&lt;EventTarget&gt; pressedTargets = new ArrayList&lt;EventTarget&gt;();
3527         private List&lt;EventTarget&gt; releasedTargets = new ArrayList&lt;EventTarget&gt;();
3528 
3529         public ClickGenerator() {
3530             for (MouseButton mb : MouseButton.values()) {
3531                 if (mb != MouseButton.NONE) {
3532                     counters.put(mb, new ClickCounter());
3533                 }
3534             }
3535         }
3536 
3537         private MouseEvent preProcess(MouseEvent e) {
3538             for (ClickCounter cc : counters.values()) {
3539                 cc.moved(e.getSceneX(), e.getSceneY());
3540             }
3541 
3542             ClickCounter cc = counters.get(e.getButton());
3543             boolean still = lastPress != null ? lastPress.isStill() : false;
3544 
3545             if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {
3546 
3547                 if (! e.isPrimaryButtonDown()) { counters.get(MouseButton.PRIMARY).clear(); }
3548                 if (! e.isSecondaryButtonDown()) { counters.get(MouseButton.SECONDARY).clear(); }
3549                 if (! e.isMiddleButtonDown()) { counters.get(MouseButton.MIDDLE).clear(); }
3550                 if (! e.isBackButtonDown()) { counters.get(MouseButton.BACK).clear(); }
3551                 if (! e.isForwardButtonDown()) { counters.get(MouseButton.FORWARD).clear(); }
3552                 cc.applyOut();
3553                 cc.inc();
3554                 cc.start(e.getSceneX(), e.getSceneY());
3555                 lastPress = cc;
3556             }
3557 
3558             return new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
3559                     e.getScreenX(), e.getScreenY(), e.getButton(),
3560                     cc != null &amp;&amp; e.getEventType() != MouseEvent.MOUSE_MOVED ? cc.get() : 0,
3561                     e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
3562                     e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
3563                     e.isBackButtonDown(), e.isForwardButtonDown(),
3564                     e.isSynthesized(), e.isPopupTrigger(), still, e.getPickResult());
3565         }
3566 
3567         private void postProcess(MouseEvent e, TargetWrapper target, TargetWrapper pickedTarget) {
3568 
3569             if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
3570                 ClickCounter cc = counters.get(e.getButton());
3571 
3572                 target.fillHierarchy(pressedTargets);
3573                 pickedTarget.fillHierarchy(releasedTargets);
3574                 int i = pressedTargets.size() - 1;
3575                 int j = releasedTargets.size() - 1;
3576 
3577                 EventTarget clickedTarget = null;
3578                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; pressedTargets.get(i) == releasedTargets.get(j)) {
3579                     clickedTarget = pressedTargets.get(i);
3580                     i--;
3581                     j--;
3582                 }
3583 
3584                 pressedTargets.clear();
3585                 releasedTargets.clear();
3586 
3587                 if (clickedTarget != null &amp;&amp; lastPress != null) {
3588                     MouseEvent click = new MouseEvent(null, clickedTarget,
3589                             MouseEvent.MOUSE_CLICKED, e.getSceneX(), e.getSceneY(),
3590                             e.getScreenX(), e.getScreenY(), e.getButton(),
3591                             cc.get(),
3592                             e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
3593                             e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
3594                             e.isBackButtonDown(), e.isForwardButtonDown(),
3595                             e.isSynthesized(), e.isPopupTrigger(), lastPress.isStill(), e.getPickResult());
3596                     Event.fireEvent(clickedTarget, click);
3597                 }
3598             }
3599         }
3600     }
3601 
3602     /**
3603      * Generates mouse exited event for a node which is going to be removed
3604      * and its children, where appropriate.
3605      * @param removing Node which is going to be removed
3606      */
3607     void generateMouseExited(Node removing) {
3608         mouseHandler.handleNodeRemoval(removing);
3609     }
3610 
3611     class MouseHandler {
3612         private TargetWrapper pdrEventTarget = new TargetWrapper(); // pdr - press-drag-release
3613         private boolean pdrInProgress = false;
3614         private boolean fullPDREntered = false;
3615 
3616         private EventTarget currentEventTarget = null;
3617         private MouseEvent lastEvent;
3618         private boolean hover = false;
3619 
3620         private boolean primaryButtonDown = false;
3621         private boolean secondaryButtonDown = false;
3622         private boolean middleButtonDown = false;
3623         private boolean backButtonDown = false;
3624         private boolean forwardButtonDown = false;
3625 
3626         private EventTarget fullPDRSource = null;
3627         private TargetWrapper fullPDRTmpTargetWrapper = new TargetWrapper();
3628 
3629         /* lists needed for enter/exit events generation */
3630         private final List&lt;EventTarget&gt; pdrEventTargets = new ArrayList&lt;EventTarget&gt;();
3631         private final List&lt;EventTarget&gt; currentEventTargets = new ArrayList&lt;EventTarget&gt;();
3632         private final List&lt;EventTarget&gt; newEventTargets = new ArrayList&lt;EventTarget&gt;();
3633 
3634         private final List&lt;EventTarget&gt; fullPDRCurrentEventTargets = new ArrayList&lt;EventTarget&gt;();
3635         private final List&lt;EventTarget&gt; fullPDRNewEventTargets = new ArrayList&lt;EventTarget&gt;();
3636         private EventTarget fullPDRCurrentTarget = null;
3637 
3638         private Cursor currCursor;
3639         private CursorFrame currCursorFrame;
3640         private EventQueue queue = new EventQueue();
3641 
3642         private Runnable pickProcess = new Runnable() {
3643 
3644             @Override
3645             public void run() {
3646                 // Make sure this is run only if the peer is still alive
3647                 // and there is an event to deliver
3648                 if (Scene.this.peer != null &amp;&amp; lastEvent != null) {
3649                     process(lastEvent, true);
3650                 }
3651             }
3652         };
3653 
3654         private void pulse() {
3655             if (hover &amp;&amp; lastEvent != null) {
3656                 //Shouldn&#39;t run user code directly. User can call stage.showAndWait() and block the pulse.
3657                 Platform.runLater(pickProcess);
3658             }
3659         }
3660 
3661         private void clearPDREventTargets() {
3662             pdrInProgress = false;
3663             currentEventTarget = currentEventTargets.size() &gt; 0
3664                     ? currentEventTargets.get(0) : null;
3665             pdrEventTarget.clear();
3666         }
3667 
3668         public void enterFullPDR(EventTarget gestureSource) {
3669             fullPDREntered = true;
3670             fullPDRSource = gestureSource;
3671             fullPDRCurrentTarget = null;
3672             fullPDRCurrentEventTargets.clear();
3673         }
3674 
3675         public void exitFullPDR(MouseEvent e) {
3676             if (!fullPDREntered) {
3677                 return;
3678             }
3679             fullPDREntered = false;
3680             for (int i = fullPDRCurrentEventTargets.size() - 1; i &gt;= 0; i--) {
3681                 EventTarget entered = fullPDRCurrentEventTargets.get(i);
3682                 Event.fireEvent(entered, MouseEvent.copyForMouseDragEvent(e,
3683                         entered, entered,
3684                         MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
3685                         fullPDRSource, e.getPickResult()));
3686             }
3687             fullPDRSource = null;
3688             fullPDRCurrentEventTargets.clear();
3689             fullPDRCurrentTarget = null;
3690         }
3691 
3692         private void handleNodeRemoval(Node removing) {
3693             if (lastEvent == null) {
3694                 // this can happen only if everything has been exited anyway
3695                 return;
3696             }
3697 
3698 
3699             if (currentEventTargets.contains(removing)) {
3700                 int i = 0;
3701                 EventTarget trg = null;
3702                 while(trg != removing) {
3703                     trg = currentEventTargets.get(i++);
3704 
3705                     queue.postEvent(lastEvent.copyFor(trg, trg,
3706                             MouseEvent.MOUSE_EXITED_TARGET));
3707                 }
3708                 currentEventTargets.subList(0, i).clear();
3709             }
3710 
3711             if (fullPDREntered &amp;&amp; fullPDRCurrentEventTargets.contains(removing)) {
3712                 int i = 0;
3713                 EventTarget trg = null;
3714                 while (trg != removing) {
3715                     trg = fullPDRCurrentEventTargets.get(i++);
3716 
3717                     queue.postEvent(
3718                             MouseEvent.copyForMouseDragEvent(lastEvent, trg, trg,
3719                             MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
3720                             fullPDRSource, lastEvent.getPickResult()));
3721                 }
3722 
3723                 fullPDRCurrentEventTargets.subList(0, i).clear();
3724             }
3725 
3726             queue.fire();
3727 
3728             if (pdrInProgress &amp;&amp; pdrEventTargets.contains(removing)) {
3729                 int i = 0;
3730                 EventTarget trg = null;
3731                 while (trg != removing) {
3732                     trg = pdrEventTargets.get(i++);
3733 
3734                     // trg.setHover(false) - already taken care of
3735                     // by the code above which sent a mouse exited event
3736                     ((Node) trg).setPressed(false);
3737                 }
3738                 pdrEventTargets.subList(0, i).clear();
3739 
3740                 trg = pdrEventTargets.get(0);
3741                 final PickResult res = pdrEventTarget.getResult();
3742                 if (trg instanceof Node) {
3743                     pdrEventTarget.setNodeResult(new PickResult((Node) trg,
3744                             res.getIntersectedPoint(), res.getIntersectedDistance()));
3745                 } else {
3746                     pdrEventTarget.setSceneResult(new PickResult(null,
3747                             res.getIntersectedPoint(), res.getIntersectedDistance()),
3748                             (Scene) trg);
3749                 }
3750             }
3751         }
3752 
3753         private void handleEnterExit(MouseEvent e, TargetWrapper pickedTarget) {
3754             if (pickedTarget.getEventTarget() != currentEventTarget ||
3755                     e.getEventType() == MouseEvent.MOUSE_EXITED) {
3756 
3757                 if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
3758                     newEventTargets.clear();
3759                 } else {
3760                     pickedTarget.fillHierarchy(newEventTargets);
3761                 }
3762 
3763                 int newTargetsSize = newEventTargets.size();
3764                 int i = currentEventTargets.size() - 1;
3765                 int j = newTargetsSize - 1;
3766                 int k = pdrEventTargets.size() - 1;
3767 
3768                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentEventTargets.get(i) == newEventTargets.get(j)) {
3769                     i--;
3770                     j--;
3771                     k--;
3772                 }
3773 
3774                 final int memk = k;
3775                 for (; i &gt;= 0; i--, k--) {
3776                     final EventTarget exitedEventTarget = currentEventTargets.get(i);
3777                     if (pdrInProgress &amp;&amp;
3778                             (k &lt; 0 || exitedEventTarget != pdrEventTargets.get(k))) {
3779                          break;
3780                     }
3781                     queue.postEvent(e.copyFor(
3782                             exitedEventTarget, exitedEventTarget,
3783                             MouseEvent.MOUSE_EXITED_TARGET));
3784                 }
3785 
3786                 k = memk;
3787                 for (; j &gt;= 0; j--, k--) {
3788                     final EventTarget enteredEventTarget = newEventTargets.get(j);
3789                     if (pdrInProgress &amp;&amp;
3790                             (k &lt; 0 || enteredEventTarget != pdrEventTargets.get(k))) {
3791                         break;
3792                     }
3793                     queue.postEvent(e.copyFor(
3794                             enteredEventTarget, enteredEventTarget,
3795                             MouseEvent.MOUSE_ENTERED_TARGET));
3796                 }
3797 
3798                 currentEventTarget = pickedTarget.getEventTarget();
3799                 currentEventTargets.clear();
3800                 for (j++; j &lt; newTargetsSize; j++) {
3801                     currentEventTargets.add(newEventTargets.get(j));
3802                 }
3803             }
3804             queue.fire();
3805         }
3806 
3807         private void process(MouseEvent e, boolean onPulse) {
3808             Toolkit.getToolkit().checkFxUserThread();
3809             Scene.inMousePick = true;
3810 
3811             cursorScreenPos = new Point2D(e.getScreenX(), e.getScreenY());
3812             cursorScenePos = new Point2D(e.getSceneX(), e.getSceneY());
3813 
3814             boolean gestureStarted = false;
3815             if (!onPulse) {
3816                 if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {
3817                     if (!(primaryButtonDown || secondaryButtonDown || middleButtonDown ||
3818                             backButtonDown || forwardButtonDown)) {
3819                         //old gesture ended and new one started
3820                         gestureStarted = true;
3821                         if (!PLATFORM_DRAG_GESTURE_INITIATION) {
3822                             Scene.this.dndGesture = new DnDGesture();
3823                         }
3824                         clearPDREventTargets();
3825                     }
3826                 } else if (e.getEventType() == MouseEvent.MOUSE_MOVED) {
3827                     // gesture ended
3828                     clearPDREventTargets();
3829                 } else if (e.getEventType() == MouseEvent.MOUSE_ENTERED) {
3830                     hover = true;
3831                 } else if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
3832                     hover = false;
3833                 }
3834 
3835                 primaryButtonDown = e.isPrimaryButtonDown();
3836                 secondaryButtonDown = e.isSecondaryButtonDown();
3837                 middleButtonDown = e.isMiddleButtonDown();
3838                 backButtonDown = e.isBackButtonDown();
3839                 forwardButtonDown = e.isForwardButtonDown();
3840             }
3841 
3842             pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
3843             PickResult res = tmpTargetWrapper.getResult();
3844             if (res != null) {
3845                 e = new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
3846                     e.getScreenX(), e.getScreenY(), e.getButton(), e.getClickCount(),
3847                     e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
3848                     e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
3849                     e.isBackButtonDown(), e.isForwardButtonDown(),
3850                     e.isSynthesized(), e.isPopupTrigger(), e.isStillSincePress(), res);
3851             }
3852 
3853             if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
3854                 tmpTargetWrapper.clear();
3855             }
3856 
3857             TargetWrapper target;
3858             if (pdrInProgress) {
3859                 target = pdrEventTarget;
3860             } else {
3861                 target = tmpTargetWrapper;
3862             }
3863 
3864             if (gestureStarted) {
3865                 pdrEventTarget.copy(target);
3866                 pdrEventTarget.fillHierarchy(pdrEventTargets);
3867             }
3868 
3869             if (!onPulse) {
3870                 e = clickGenerator.preProcess(e);
3871             }
3872 
3873             // enter/exit handling
3874             handleEnterExit(e, tmpTargetWrapper);
3875 
3876             //deliver event to the target node
3877             if (Scene.this.dndGesture != null) {
3878                 Scene.this.dndGesture.processDragDetection(e);
3879             }
3880 
3881             if (fullPDREntered &amp;&amp; e.getEventType() == MouseEvent.MOUSE_RELEASED) {
3882                 processFullPDR(e, onPulse);
3883             }
3884 
3885             if (target.getEventTarget() != null) {
3886                 if (e.getEventType() != MouseEvent.MOUSE_ENTERED
3887                         &amp;&amp; e.getEventType() != MouseEvent.MOUSE_EXITED
3888                         &amp;&amp; !onPulse) {
3889                     Event.fireEvent(target.getEventTarget(), e);
3890                 }
3891             }
3892 
3893             if (fullPDREntered &amp;&amp; e.getEventType() != MouseEvent.MOUSE_RELEASED) {
3894                 processFullPDR(e, onPulse);
3895             }
3896 
3897             if (!onPulse) {
3898                 clickGenerator.postProcess(e, target, tmpTargetWrapper);
3899             }
3900 
3901             // handle drag and drop
3902 
3903             if (!PLATFORM_DRAG_GESTURE_INITIATION &amp;&amp; !onPulse) {
3904                 if (Scene.this.dndGesture != null) {
3905                     if (!Scene.this.dndGesture.process(e, target.getEventTarget())) {
3906                         dndGesture = null;
3907                     }
3908                 }
3909             }
3910 
3911             Cursor cursor = target.getCursor();
3912             if (e.getEventType() != MouseEvent.MOUSE_EXITED) {
3913                 if (cursor == null &amp;&amp; hover) {
3914                     cursor = Scene.this.getCursor();
3915                 }
3916 
3917                 updateCursor(cursor);
3918                 updateCursorFrame();
3919             }
3920 
3921             if (gestureStarted) {
3922                 pdrInProgress = true;
3923             }
3924 
3925             if (pdrInProgress &amp;&amp;
3926                     !(primaryButtonDown || secondaryButtonDown || middleButtonDown ||
3927                             backButtonDown || forwardButtonDown)) {
3928                 clearPDREventTargets();
3929                 exitFullPDR(e);
3930                 // we need to do new picking in case the originally picked node
3931                 // was moved or removed by the event handlers
3932                 pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
3933                 handleEnterExit(e, tmpTargetWrapper);
3934             }
3935 
3936             lastEvent = e.getEventType() == MouseEvent.MOUSE_EXITED ? null : e;
3937             Scene.inMousePick = false;
3938         }
3939 
3940         private void processFullPDR(MouseEvent e, boolean onPulse) {
3941 
3942             pick(fullPDRTmpTargetWrapper, e.getSceneX(), e.getSceneY());
3943             final PickResult result = fullPDRTmpTargetWrapper.getResult();
3944 
3945             final EventTarget eventTarget = fullPDRTmpTargetWrapper.getEventTarget();
3946 
3947             // enter/exit handling
3948             if (eventTarget != fullPDRCurrentTarget) {
3949 
3950                 fullPDRTmpTargetWrapper.fillHierarchy(fullPDRNewEventTargets);
3951 
3952                 int newTargetsSize = fullPDRNewEventTargets.size();
3953                 int i = fullPDRCurrentEventTargets.size() - 1;
3954                 int j = newTargetsSize - 1;
3955 
3956                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp;
3957                         fullPDRCurrentEventTargets.get(i) == fullPDRNewEventTargets.get(j)) {
3958                     i--;
3959                     j--;
3960                 }
3961 
3962                 for (; i &gt;= 0; i--) {
3963                     final EventTarget exitedEventTarget = fullPDRCurrentEventTargets.get(i);
3964                     Event.fireEvent(exitedEventTarget, MouseEvent.copyForMouseDragEvent(e,
3965                             exitedEventTarget, exitedEventTarget,
3966                             MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
3967                             fullPDRSource, result));
3968                 }
3969 
3970                 for (; j &gt;= 0; j--) {
3971                     final EventTarget enteredEventTarget = fullPDRNewEventTargets.get(j);
3972                     Event.fireEvent(enteredEventTarget, MouseEvent.copyForMouseDragEvent(e,
3973                             enteredEventTarget, enteredEventTarget,
3974                             MouseDragEvent.MOUSE_DRAG_ENTERED_TARGET,
3975                             fullPDRSource, result));
3976                 }
3977 
3978                 fullPDRCurrentTarget = eventTarget;
3979                 fullPDRCurrentEventTargets.clear();
3980                 fullPDRCurrentEventTargets.addAll(fullPDRNewEventTargets);
3981                 fullPDRNewEventTargets.clear();
3982             }
3983             // done enter/exit handling
3984 
3985             // event delivery
3986             if (eventTarget != null &amp;&amp; !onPulse) {
3987                 if (e.getEventType() == MouseEvent.MOUSE_DRAGGED) {
3988                     Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
3989                             eventTarget, eventTarget,
3990                             MouseDragEvent.MOUSE_DRAG_OVER,
3991                             fullPDRSource, result));
3992                 }
3993                 if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
3994                     Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
3995                             eventTarget, eventTarget,
3996                             MouseDragEvent.MOUSE_DRAG_RELEASED,
3997                             fullPDRSource, result));
3998                 }
3999             }
4000         }
4001 
4002         private void updateCursor(Cursor newCursor) {
4003             if (currCursor != newCursor) {
4004                 if (currCursor != null) {
4005                     currCursor.deactivate();
4006                 }
4007 
4008                 if (newCursor != null) {
4009                     newCursor.activate();
4010                 }
4011 
4012                 currCursor = newCursor;
4013             }
4014         }
4015 
4016         public void updateCursorFrame() {
4017             final CursorFrame newCursorFrame =
4018                     (currCursor != null)
4019                            ? currCursor.getCurrentFrame()
4020                            : Cursor.DEFAULT.getCurrentFrame();
4021             if (currCursorFrame != newCursorFrame) {
4022                 if (Scene.this.peer != null) {
4023                     Scene.this.peer.setCursor(newCursorFrame);
4024                 }
4025 
4026                 currCursorFrame = newCursorFrame;
4027             }
4028         }
4029 
4030         private PickResult pickNode(PickRay pickRay) {
4031             PickResultChooser r = new PickResultChooser();
4032             Scene.this.getRoot().pickNode(pickRay, r);
4033             return r.toPickResult();
4034         }
4035     }
4036 
4037     /*******************************************************************************
4038      *                                                                             *
4039      * Key Event Handling                                                          *
4040      *                                                                             *
4041      ******************************************************************************/
4042 
4043     class KeyHandler {
4044         private void setFocusOwner(final Node value) {
4045             // Cancel IM composition if there is one in progress.
4046             // This needs to be done before the focus owner is switched as it
4047             // generates event that needs to be delivered to the old focus owner.
4048             if (oldFocusOwner != null) {
4049                 final Scene s = oldFocusOwner.getScene();
4050                 if (s != null) {
4051                     final TKScene peer = s.getPeer();
4052                     if (peer != null) {
4053                         peer.finishInputMethodComposition();
4054                     }
4055                 }
4056             }
4057             focusOwner.set(value);
4058         }
4059 
4060         private boolean windowFocused;
4061         protected boolean isWindowFocused() { return windowFocused; }
4062         protected void setWindowFocused(boolean value) {
4063             windowFocused = value;
4064             if (getFocusOwner() != null) {
4065                 getFocusOwner().setFocused(windowFocused);
4066             }
4067             if (windowFocused) {
4068                 if (accessible != null) {
4069                     accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
4070                 }
4071             }
4072         }
4073 
4074         private void windowForSceneChanged(Window oldWindow, Window window) {
4075             if (oldWindow != null) {
4076                 oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);
4077             }
4078 
4079             if (window != null) {
4080                 window.focusedProperty().addListener(sceneWindowFocusedListener);
4081                 setWindowFocused(window.isFocused());
4082             } else {
4083                 setWindowFocused(false);
4084             }
4085         }
4086 
4087         private final InvalidationListener sceneWindowFocusedListener = valueModel -&gt; setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());
4088 
4089         private void process(KeyEvent e) {
4090             final Node sceneFocusOwner = getFocusOwner();
4091             final EventTarget eventTarget =
4092                     (sceneFocusOwner != null &amp;&amp; sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner
4093                                               : Scene.this;
4094 
4095             // send the key event to the current focus owner or to scene if
4096             // the focus owner is not set
4097             Event.fireEvent(eventTarget, e);
4098         }
4099 
4100         private void requestFocus(Node node) {
4101             if (getFocusOwner() == node || (node != null &amp;&amp; !node.isCanReceiveFocus())) {
4102                 return;
4103             }
4104             setFocusOwner(node);
4105         }
4106     }
4107     /***************************************************************************
4108      *                                                                         *
4109      *                         Event Dispatch                                  *
4110      *                                                                         *
4111      **************************************************************************/
4112     // PENDING_DOC_REVIEW
4113     /**
4114      * Specifies the event dispatcher for this scene. When replacing the value
4115      * with a new {@code EventDispatcher}, the new dispatcher should forward
4116      * events to the replaced dispatcher to keep the scene&#39;s default event
4117      * handling behavior.
4118      */
4119     private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;
4120 
4121     public final void setEventDispatcher(EventDispatcher value) {
4122         eventDispatcherProperty().set(value);
4123     }
4124 
4125     public final EventDispatcher getEventDispatcher() {
4126         return eventDispatcherProperty().get();
4127     }
4128 
4129     public final ObjectProperty&lt;EventDispatcher&gt;
4130             eventDispatcherProperty() {
4131         initializeInternalEventDispatcher();
4132         return eventDispatcher;
4133     }
4134 
4135     private SceneEventDispatcher internalEventDispatcher;
4136 
4137     // Delegates requests from platform input method to the focused
4138     // node&#39;s one, if any.
4139     class InputMethodRequestsDelegate implements ExtendedInputMethodRequests {
4140         @Override
4141         public Point2D getTextLocation(int offset) {
4142             InputMethodRequests requests = getClientRequests();
4143             if (requests != null) {
4144                 return requests.getTextLocation(offset);
4145             } else {
4146                 return new Point2D(0, 0);
4147             }
4148         }
4149 
4150         @Override
4151         public int getLocationOffset(int x, int y) {
4152             InputMethodRequests requests = getClientRequests();
4153             if (requests != null) {
4154                 return requests.getLocationOffset(x, y);
4155             } else {
4156                 return 0;
4157             }
4158         }
4159 
4160         @Override
4161         public void cancelLatestCommittedText() {
4162             InputMethodRequests requests = getClientRequests();
4163             if (requests != null) {
4164                 requests.cancelLatestCommittedText();
4165             }
4166         }
4167 
4168         @Override
4169         public String getSelectedText() {
4170             InputMethodRequests requests = getClientRequests();
4171             if (requests != null) {
4172                 return requests.getSelectedText();
4173             }
4174             return null;
4175         }
4176 
4177         @Override
4178         public int getInsertPositionOffset() {
4179             InputMethodRequests requests = getClientRequests();
4180             if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
4181                 return ((ExtendedInputMethodRequests)requests).getInsertPositionOffset();
4182             }
4183             return 0;
4184         }
4185 
4186         @Override
4187         public String getCommittedText(int begin, int end) {
4188             InputMethodRequests requests = getClientRequests();
4189             if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
4190                 return ((ExtendedInputMethodRequests)requests).getCommittedText(begin, end);
4191             }
4192             return null;
4193         }
4194 
4195         @Override
4196         public int getCommittedTextLength() {
4197             InputMethodRequests requests = getClientRequests();
4198             if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
4199                 return ((ExtendedInputMethodRequests)requests).getCommittedTextLength();
4200             }
4201             return 0;
4202         }
4203 
4204         private InputMethodRequests getClientRequests() {
4205             Node focusOwner = getFocusOwner();
4206             if (focusOwner != null) {
4207                 return focusOwner.getInputMethodRequests();
4208             }
4209             return null;
4210         }
4211     }
4212 
4213     // PENDING_DOC_REVIEW
4214     /**
4215      * Registers an event handler to this scene. The handler is called when the
4216      * scene receives an {@code Event} of the specified type during the bubbling
4217      * phase of event delivery.
4218      *
4219      * @param &lt;T&gt; the specific event class of the handler
4220      * @param eventType the type of the events to receive by the handler
4221      * @param eventHandler the handler to register
4222      * @throws NullPointerException if the event type or handler is null
4223      */
4224     public final &lt;T extends Event&gt; void addEventHandler(
4225             final EventType&lt;T&gt; eventType,
4226             final EventHandler&lt;? super T&gt; eventHandler) {
4227         getInternalEventDispatcher().getEventHandlerManager()
4228                                     .addEventHandler(eventType, eventHandler);
4229     }
4230 
4231     // PENDING_DOC_REVIEW
4232     /**
4233      * Unregisters a previously registered event handler from this scene. One
4234      * handler might have been registered for different event types, so the
4235      * caller needs to specify the particular event type from which to
4236      * unregister the handler.
4237      *
4238      * @param &lt;T&gt; the specific event class of the handler
4239      * @param eventType the event type from which to unregister
4240      * @param eventHandler the handler to unregister
4241      * @throws NullPointerException if the event type or handler is null
4242      */
4243     public final &lt;T extends Event&gt; void removeEventHandler(
4244             final EventType&lt;T&gt; eventType,
4245             final EventHandler&lt;? super T&gt; eventHandler) {
4246         getInternalEventDispatcher().getEventHandlerManager()
4247                                     .removeEventHandler(eventType,
4248                                                         eventHandler);
4249     }
4250 
4251     // PENDING_DOC_REVIEW
4252     /**
4253      * Registers an event filter to this scene. The filter is called when the
4254      * scene receives an {@code Event} of the specified type during the
4255      * capturing phase of event delivery.
4256      *
4257      * @param &lt;T&gt; the specific event class of the filter
4258      * @param eventType the type of the events to receive by the filter
4259      * @param eventFilter the filter to register
4260      * @throws NullPointerException if the event type or filter is null
4261      */
4262     public final &lt;T extends Event&gt; void addEventFilter(
4263             final EventType&lt;T&gt; eventType,
4264             final EventHandler&lt;? super T&gt; eventFilter) {
4265         getInternalEventDispatcher().getEventHandlerManager()
4266                                     .addEventFilter(eventType, eventFilter);
4267     }
4268 
4269     // PENDING_DOC_REVIEW
4270     /**
4271      * Unregisters a previously registered event filter from this scene. One
4272      * filter might have been registered for different event types, so the
4273      * caller needs to specify the particular event type from which to
4274      * unregister the filter.
4275      *
4276      * @param &lt;T&gt; the specific event class of the filter
4277      * @param eventType the event type from which to unregister
4278      * @param eventFilter the filter to unregister
4279      * @throws NullPointerException if the event type or filter is null
4280      */
4281     public final &lt;T extends Event&gt; void removeEventFilter(
4282             final EventType&lt;T&gt; eventType,
4283             final EventHandler&lt;? super T&gt; eventFilter) {
4284         getInternalEventDispatcher().getEventHandlerManager()
4285                                     .removeEventFilter(eventType, eventFilter);
4286     }
4287 
4288     /**
4289      * Sets the handler to use for this event type. There can only be one such
4290      * handler specified at a time. This handler is guaranteed to be called
4291      * first. This is used for registering the user-defined onFoo event
4292      * handlers.
4293      *
4294      * @param &lt;T&gt; the specific event class of the handler
4295      * @param eventType the event type to associate with the given eventHandler
4296      * @param eventHandler the handler to register, or null to unregister
4297      * @throws NullPointerException if the event type is null
4298      */
4299     protected final &lt;T extends Event&gt; void setEventHandler(
4300             final EventType&lt;T&gt; eventType,
4301             final EventHandler&lt;? super T&gt; eventHandler) {
4302         getInternalEventDispatcher().getEventHandlerManager()
4303                                     .setEventHandler(eventType, eventHandler);
4304     }
4305 
4306     private SceneEventDispatcher getInternalEventDispatcher() {
4307         initializeInternalEventDispatcher();
4308         return internalEventDispatcher;
4309     }
4310 
4311     final void initializeInternalEventDispatcher() {
4312         if (internalEventDispatcher == null) {
4313             internalEventDispatcher = createInternalEventDispatcher();
4314             eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(
4315                                           this,
4316                                           &quot;eventDispatcher&quot;,
4317                                           internalEventDispatcher);
4318         }
4319     }
4320 
4321     private SceneEventDispatcher createInternalEventDispatcher() {
4322         return new SceneEventDispatcher(this);
4323     }
4324 
4325     /**
4326      * Registers the specified mnemonic.
4327      *
4328      * @param m The mnemonic
4329      */
4330     public void addMnemonic(Mnemonic m) {
4331         getInternalEventDispatcher().getKeyboardShortcutsHandler()
4332                                     .addMnemonic(m);
4333     }
4334 
4335 
4336     /**
4337      * Unregisters the specified mnemonic.
4338      *
4339      * @param m The mnemonic
4340      */
4341     public void removeMnemonic(Mnemonic m) {
4342         getInternalEventDispatcher().getKeyboardShortcutsHandler()
4343                                     .removeMnemonic(m);
4344     }
4345 
4346     final void clearNodeMnemonics(Node node) {
4347         getInternalEventDispatcher().getKeyboardShortcutsHandler()
4348                 .clearNodeMnemonics(node);
4349     }
4350 
4351 
4352     /**
4353      * Gets the list of mnemonics for this {@code Scene}.
4354      *
4355      * @return the list of mnemonics
4356      */
4357     public ObservableMap&lt;KeyCombination, ObservableList&lt;Mnemonic&gt;&gt; getMnemonics() {
4358         return getInternalEventDispatcher().getKeyboardShortcutsHandler()
4359                                            .getMnemonics();
4360     }
4361 
4362     /**
4363      * Gets the list of accelerators for this {@code Scene}.
4364      *
4365      * @return the list of accelerators
4366      */
4367     public ObservableMap&lt;KeyCombination, Runnable&gt; getAccelerators() {
4368         return getInternalEventDispatcher().getKeyboardShortcutsHandler()
4369                                            .getAccelerators();
4370     }
4371 
4372     // PENDING_DOC_REVIEW
4373     /**
4374      * Construct an event dispatch chain for this scene. The event dispatch
4375      * chain contains all event dispatchers from the stage to this scene.
4376      *
4377      * @param tail the initial chain to build from
4378      * @return the resulting event dispatch chain for this scene
4379      */
4380     @Override
4381     public EventDispatchChain buildEventDispatchChain(
4382             EventDispatchChain tail) {
4383         if (eventDispatcher != null) {
4384             final EventDispatcher eventDispatcherValue = eventDispatcher.get();
4385             if (eventDispatcherValue != null) {
4386                 tail = tail.prepend(eventDispatcherValue);
4387             }
4388         }
4389 
4390         if (getWindow() != null) {
4391             tail = getWindow().buildEventDispatchChain(tail);
4392         }
4393 
4394         return tail;
4395     }
4396 
4397     /***************************************************************************
4398      *                                                                         *
4399      *                             Context Menus                               *
4400      *                                                                         *
4401      **************************************************************************/
4402 
4403     /**
4404      * Defines a function to be called when a mouse button has been clicked
4405      * (pressed and released) on this {@code Scene}.
4406      * @since JavaFX 2.1
4407      */
4408 
4409     private ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequested;
4410 
4411     public final void setOnContextMenuRequested(EventHandler&lt;? super ContextMenuEvent&gt; value) {
4412         onContextMenuRequestedProperty().set(value);
4413     }
4414 
4415     public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
4416         return onContextMenuRequested == null ? null : onContextMenuRequested.get();
4417     }
4418 
4419     public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequestedProperty() {
4420         if (onContextMenuRequested == null) {
4421             onContextMenuRequested = new ObjectPropertyBase&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;() {
4422 
4423                 @Override
4424                 protected void invalidated() {
4425                     setEventHandler(ContextMenuEvent.CONTEXT_MENU_REQUESTED, get());
4426                 }
4427 
4428                 @Override
4429                 public Object getBean() {
4430                     return Scene.this;
4431                 }
4432 
4433                 @Override
4434                 public String getName() {
4435                     return &quot;onContextMenuRequested&quot;;
4436                 }
4437             };
4438         }
4439         return onContextMenuRequested;
4440     }
4441 
4442     /***************************************************************************
4443      *                                                                         *
4444      *                             Mouse Handling                              *
4445      *                                                                         *
4446      **************************************************************************/
4447 
4448     /**
4449      * Defines a function to be called when a mouse button has been clicked
4450      * (pressed and released) on this {@code Scene}.
4451      */
4452     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClicked;
4453 
4454     public final void setOnMouseClicked(EventHandler&lt;? super MouseEvent&gt; value) {
4455         onMouseClickedProperty().set(value);
4456     }
4457 
4458     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
4459         return onMouseClicked == null ? null : onMouseClicked.get();
4460     }
4461 
4462     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClickedProperty() {
4463         if (onMouseClicked == null) {
4464             onMouseClicked = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4465 
4466                 @Override
4467                 protected void invalidated() {
4468                     setEventHandler(MouseEvent.MOUSE_CLICKED, get());
4469                 }
4470 
4471                 @Override
4472                 public Object getBean() {
4473                     return Scene.this;
4474                 }
4475 
4476                 @Override
4477                 public String getName() {
4478                     return &quot;onMouseClicked&quot;;
4479                 }
4480             };
4481         }
4482         return onMouseClicked;
4483     }
4484 
4485     /**
4486      * Defines a function to be called when a mouse button is pressed
4487      * on this {@code Scene} and then dragged.
4488      */
4489     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDragged;
4490 
4491     public final void setOnMouseDragged(EventHandler&lt;? super MouseEvent&gt; value) {
4492         onMouseDraggedProperty().set(value);
4493     }
4494 
4495     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
4496         return onMouseDragged == null ? null : onMouseDragged.get();
4497     }
4498 
4499     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDraggedProperty() {
4500         if (onMouseDragged == null) {
4501             onMouseDragged = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4502 
4503                 @Override
4504                 protected void invalidated() {
4505                     setEventHandler(MouseEvent.MOUSE_DRAGGED, get());
4506                 }
4507 
4508                 @Override
4509                 public Object getBean() {
4510                     return Scene.this;
4511                 }
4512 
4513                 @Override
4514                 public String getName() {
4515                     return &quot;onMouseDragged&quot;;
4516                 }
4517             };
4518         }
4519         return onMouseDragged;
4520     }
4521 
4522     /**
4523      * Defines a function to be called when the mouse enters this {@code Scene}.
4524      */
4525     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEntered;
4526 
4527     public final void setOnMouseEntered(EventHandler&lt;? super MouseEvent&gt; value) {
4528         onMouseEnteredProperty().set(value);
4529     }
4530 
4531     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
4532         return onMouseEntered == null ? null : onMouseEntered.get();
4533     }
4534 
4535     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEnteredProperty() {
4536         if (onMouseEntered == null) {
4537             onMouseEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4538 
4539                 @Override
4540                 protected void invalidated() {
4541                     setEventHandler(MouseEvent.MOUSE_ENTERED, get());
4542                 }
4543 
4544                 @Override
4545                 public Object getBean() {
4546                     return Scene.this;
4547                 }
4548 
4549                 @Override
4550                 public String getName() {
4551                     return &quot;onMouseEntered&quot;;
4552                 }
4553             };
4554         }
4555         return onMouseEntered;
4556     }
4557 
4558     /**
4559      * Defines a function to be called when the mouse exits this {@code Scene}.
4560      */
4561     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExited;
4562 
4563     public final void setOnMouseExited(EventHandler&lt;? super MouseEvent&gt; value) {
4564         onMouseExitedProperty().set(value);
4565     }
4566 
4567     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
4568         return onMouseExited == null ? null : onMouseExited.get();
4569     }
4570 
4571     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExitedProperty() {
4572         if (onMouseExited == null) {
4573             onMouseExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4574 
4575                 @Override
4576                 protected void invalidated() {
4577                     setEventHandler(MouseEvent.MOUSE_EXITED, get());
4578                 }
4579 
4580                 @Override
4581                 public Object getBean() {
4582                     return Scene.this;
4583                 }
4584 
4585                 @Override
4586                 public String getName() {
4587                     return &quot;onMouseExited&quot;;
4588                 }
4589             };
4590         }
4591         return onMouseExited;
4592     }
4593 
4594     /**
4595      * Defines a function to be called when mouse cursor moves within
4596      * this {@code Scene} but no buttons have been pushed.
4597      */
4598     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMoved;
4599 
4600     public final void setOnMouseMoved(EventHandler&lt;? super MouseEvent&gt; value) {
4601         onMouseMovedProperty().set(value);
4602     }
4603 
4604     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
4605         return onMouseMoved == null ? null : onMouseMoved.get();
4606     }
4607 
4608     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMovedProperty() {
4609         if (onMouseMoved == null) {
4610             onMouseMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4611 
4612                 @Override
4613                 protected void invalidated() {
4614                     setEventHandler(MouseEvent.MOUSE_MOVED, get());
4615                 }
4616 
4617                 @Override
4618                 public Object getBean() {
4619                     return Scene.this;
4620                 }
4621 
4622                 @Override
4623                 public String getName() {
4624                     return &quot;onMouseMoved&quot;;
4625                 }
4626             };
4627         }
4628         return onMouseMoved;
4629     }
4630 
4631     /**
4632      * Defines a function to be called when a mouse button
4633      * has been pressed on this {@code Scene}.
4634      */
4635     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressed;
4636 
4637     public final void setOnMousePressed(EventHandler&lt;? super MouseEvent&gt; value) {
4638         onMousePressedProperty().set(value);
4639     }
4640 
4641     public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
4642         return onMousePressed == null ? null : onMousePressed.get();
4643     }
4644 
4645     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressedProperty() {
4646         if (onMousePressed == null) {
4647             onMousePressed = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4648 
4649                 @Override
4650                 protected void invalidated() {
4651                     setEventHandler(MouseEvent.MOUSE_PRESSED, get());
4652                 }
4653 
4654                 @Override
4655                 public Object getBean() {
4656                     return Scene.this;
4657                 }
4658 
4659                 @Override
4660                 public String getName() {
4661                     return &quot;onMousePressed&quot;;
4662                 }
4663             };
4664         }
4665         return onMousePressed;
4666     }
4667 
4668     /**
4669      * Defines a function to be called when a mouse button
4670      * has been released on this {@code Scene}.
4671      */
4672     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleased;
4673 
4674     public final void setOnMouseReleased(EventHandler&lt;? super MouseEvent&gt; value) {
4675         onMouseReleasedProperty().set(value);
4676     }
4677 
4678     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
4679         return onMouseReleased == null ? null : onMouseReleased.get();
4680     }
4681 
4682     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleasedProperty() {
4683         if (onMouseReleased == null) {
4684             onMouseReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4685 
4686                 @Override
4687                 protected void invalidated() {
4688                     setEventHandler(MouseEvent.MOUSE_RELEASED, get());
4689                 }
4690 
4691                 @Override
4692                 public Object getBean() {
4693                     return Scene.this;
4694                 }
4695 
4696                 @Override
4697                 public String getName() {
4698                     return &quot;onMouseReleased&quot;;
4699                 }
4700             };
4701         }
4702         return onMouseReleased;
4703     }
4704 
4705     /**
4706      * Defines a function to be called when drag gesture has been
4707      * detected. This is the right place to start drag and drop operation.
4708      */
4709     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetected;
4710 
4711     public final void setOnDragDetected(EventHandler&lt;? super MouseEvent&gt; value) {
4712         onDragDetectedProperty().set(value);
4713     }
4714 
4715     public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
4716         return onDragDetected == null ? null : onDragDetected.get();
4717     }
4718 
4719     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetectedProperty() {
4720         if (onDragDetected == null) {
4721             onDragDetected = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4722 
4723                 @Override
4724                 protected void invalidated() {
4725                     setEventHandler(MouseEvent.DRAG_DETECTED, get());
4726                 }
4727 
4728                 @Override
4729                 public Object getBean() {
4730                     return Scene.this;
4731                 }
4732 
4733                 @Override
4734                 public String getName() {
4735                     return &quot;onDragDetected&quot;;
4736                 }
4737             };
4738         }
4739         return onDragDetected;
4740     }
4741 
4742     /**
4743      * Defines a function to be called when a full press-drag-release gesture
4744      * progresses within this {@code Scene}.
4745      * @since JavaFX 2.1
4746      */
4747     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOver;
4748 
4749     public final void setOnMouseDragOver(EventHandler&lt;? super MouseDragEvent&gt; value) {
4750         onMouseDragOverProperty().set(value);
4751     }
4752 
4753     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
4754         return onMouseDragOver == null ? null : onMouseDragOver.get();
4755     }
4756 
4757     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOverProperty() {
4758         if (onMouseDragOver == null) {
4759             onMouseDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4760 
4761                 @Override
4762                 protected void invalidated() {
4763                     setEventHandler(MouseDragEvent.MOUSE_DRAG_OVER, get());
4764                 }
4765 
4766                 @Override
4767                 public Object getBean() {
4768                     return Scene.this;
4769                 }
4770 
4771                 @Override
4772                 public String getName() {
4773                     return &quot;onMouseDragOver&quot;;
4774                 }
4775             };
4776         }
4777         return onMouseDragOver;
4778     }
4779 
4780     /**
4781      * Defines a function to be called when a full press-drag-release gesture
4782      * ends within this {@code Scene}.
4783      * @since JavaFX 2.1
4784      */
4785     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleased;
4786 
4787     public final void setOnMouseDragReleased(EventHandler&lt;? super MouseDragEvent&gt; value) {
4788         onMouseDragReleasedProperty().set(value);
4789     }
4790 
4791     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
4792         return onMouseDragReleased == null ? null : onMouseDragReleased.get();
4793     }
4794 
4795     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleasedProperty() {
4796         if (onMouseDragReleased == null) {
4797             onMouseDragReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4798 
4799                 @Override
4800                 protected void invalidated() {
4801                     setEventHandler(MouseDragEvent.MOUSE_DRAG_RELEASED, get());
4802                 }
4803 
4804                 @Override
4805                 public Object getBean() {
4806                     return Scene.this;
4807                 }
4808 
4809                 @Override
4810                 public String getName() {
4811                     return &quot;onMouseDragReleased&quot;;
4812                 }
4813             };
4814         }
4815         return onMouseDragReleased;
4816     }
4817 
4818     /**
4819      * Defines a function to be called when a full press-drag-release gesture
4820      * enters this {@code Scene}.
4821      * @since JavaFX 2.1
4822      */
4823     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEntered;
4824 
4825     public final void setOnMouseDragEntered(EventHandler&lt;? super MouseDragEvent&gt; value) {
4826         onMouseDragEnteredProperty().set(value);
4827     }
4828 
4829     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
4830         return onMouseDragEntered == null ? null : onMouseDragEntered.get();
4831     }
4832 
4833     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEnteredProperty() {
4834         if (onMouseDragEntered == null) {
4835             onMouseDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4836 
4837                 @Override
4838                 protected void invalidated() {
4839                     setEventHandler(MouseDragEvent.MOUSE_DRAG_ENTERED, get());
4840                 }
4841 
4842                 @Override
4843                 public Object getBean() {
4844                     return Scene.this;
4845                 }
4846 
4847                 @Override
4848                 public String getName() {
4849                     return &quot;onMouseDragEntered&quot;;
4850                 }
4851             };
4852         }
4853         return onMouseDragEntered;
4854     }
4855 
4856     /**
4857      * Defines a function to be called when a full press-drag-release gesture
4858      * exits this {@code Scene}.
4859      * @since JavaFX 2.1
4860      */
4861     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExited;
4862 
4863     public final void setOnMouseDragExited(EventHandler&lt;? super MouseDragEvent&gt; value) {
4864         onMouseDragExitedProperty().set(value);
4865     }
4866 
4867     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
4868         return onMouseDragExited == null ? null : onMouseDragExited.get();
4869     }
4870 
4871     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExitedProperty() {
4872         if (onMouseDragExited == null) {
4873             onMouseDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4874 
4875                 @Override
4876                 protected void invalidated() {
4877                     setEventHandler(MouseDragEvent.MOUSE_DRAG_EXITED, get());
4878                 }
4879 
4880                 @Override
4881                 public Object getBean() {
4882                     return Scene.this;
4883                 }
4884 
4885                 @Override
4886                 public String getName() {
4887                     return &quot;onMouseDragExited&quot;;
4888                 }
4889             };
4890         }
4891         return onMouseDragExited;
4892     }
4893 
4894 
4895     /***************************************************************************
4896      *                                                                         *
4897      *                           Gestures Handling                             *
4898      *                                                                         *
4899      **************************************************************************/
4900 
4901     /**
4902      * Defines a function to be called when a scrolling gesture is detected.
4903      * @since JavaFX 2.2
4904      */
4905     private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStarted;
4906 
4907     public final void setOnScrollStarted(EventHandler&lt;? super ScrollEvent&gt; value) {
4908         onScrollStartedProperty().set(value);
4909     }
4910 
4911     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
4912         return onScrollStarted == null ? null : onScrollStarted.get();
4913     }
4914 
4915     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStartedProperty() {
4916         if (onScrollStarted == null) {
4917             onScrollStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {
4918 
4919                 @Override
4920                 protected void invalidated() {
4921                     setEventHandler(ScrollEvent.SCROLL_STARTED, get());
4922                 }
4923 
4924                 @Override
4925                 public Object getBean() {
4926                     return Scene.this;
4927                 }
4928 
4929                 @Override
4930                 public String getName() {
4931                     return &quot;onScrollStarted&quot;;
4932                 }
4933             };
4934         }
4935         return onScrollStarted;
4936     }
4937 
4938     /**
4939      * Defines a function to be called when user performs a scrolling action.
4940      */
4941     private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScroll;
4942 
4943     public final void setOnScroll(EventHandler&lt;? super ScrollEvent&gt; value) {
4944         onScrollProperty().set(value);
4945     }
4946 
4947     public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
4948         return onScroll == null ? null : onScroll.get();
4949     }
4950 
4951     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollProperty() {
4952         if (onScroll == null) {
4953             onScroll = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {
4954 
4955                 @Override
4956                 protected void invalidated() {
4957                     setEventHandler(ScrollEvent.SCROLL, get());
4958                 }
4959 
4960                 @Override
4961                 public Object getBean() {
4962                     return Scene.this;
4963                 }
4964 
4965                 @Override
4966                 public String getName() {
4967                     return &quot;onScroll&quot;;
4968                 }
4969             };
4970         }
4971         return onScroll;
4972     }
4973 
4974     /**
4975      * Defines a function to be called when a scrolling gesture ends.
4976      * @since JavaFX 2.2
4977      */
4978     private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinished;
4979 
4980     public final void setOnScrollFinished(EventHandler&lt;? super ScrollEvent&gt; value) {
4981         onScrollFinishedProperty().set(value);
4982     }
4983 
4984     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
4985         return onScrollFinished == null ? null : onScrollFinished.get();
4986     }
4987 
4988     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinishedProperty() {
4989         if (onScrollFinished == null) {
4990             onScrollFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {
4991 
4992                 @Override
4993                 protected void invalidated() {
4994                     setEventHandler(ScrollEvent.SCROLL_FINISHED, get());
4995                 }
4996 
4997                 @Override
4998                 public Object getBean() {
4999                     return Scene.this;
5000                 }
5001 
5002                 @Override
5003                 public String getName() {
5004                     return &quot;onScrollFinished&quot;;
5005                 }
5006             };
5007         }
5008         return onScrollFinished;
5009     }
5010 
5011     /**
5012      * Defines a function to be called when a rotating gesture is detected.
5013      * @since JavaFX 2.2
5014      */
5015     private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStarted;
5016 
5017     public final void setOnRotationStarted(EventHandler&lt;? super RotateEvent&gt; value) {
5018         onRotationStartedProperty().set(value);
5019     }
5020 
5021     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
5022         return onRotationStarted == null ? null : onRotationStarted.get();
5023     }
5024 
5025     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStartedProperty() {
5026         if (onRotationStarted == null) {
5027             onRotationStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {
5028 
5029                 @Override
5030                 protected void invalidated() {
5031                     setEventHandler(RotateEvent.ROTATION_STARTED, get());
5032                 }
5033 
5034                 @Override
5035                 public Object getBean() {
5036                     return Scene.this;
5037                 }
5038 
5039                 @Override
5040                 public String getName() {
5041                     return &quot;onRotationStarted&quot;;
5042                 }
5043             };
5044         }
5045         return onRotationStarted;
5046     }
5047 
5048     /**
5049      * Defines a function to be called when user performs a rotating action.
5050      * @since JavaFX 2.2
5051      */
5052     private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotate;
5053 
5054     public final void setOnRotate(EventHandler&lt;? super RotateEvent&gt; value) {
5055         onRotateProperty().set(value);
5056     }
5057 
5058     public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
5059         return onRotate == null ? null : onRotate.get();
5060     }
5061 
5062     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotateProperty() {
5063         if (onRotate == null) {
5064             onRotate = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {
5065 
5066                 @Override
5067                 protected void invalidated() {
5068                     setEventHandler(RotateEvent.ROTATE, get());
5069                 }
5070 
5071                 @Override
5072                 public Object getBean() {
5073                     return Scene.this;
5074                 }
5075 
5076                 @Override
5077                 public String getName() {
5078                     return &quot;onRotate&quot;;
5079                 }
5080             };
5081         }
5082         return onRotate;
5083     }
5084 
5085     /**
5086      * Defines a function to be called when a rotating gesture ends.
5087      * @since JavaFX 2.2
5088      */
5089     private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinished;
5090 
5091     public final void setOnRotationFinished(EventHandler&lt;? super RotateEvent&gt; value) {
5092         onRotationFinishedProperty().set(value);
5093     }
5094 
5095     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
5096         return onRotationFinished == null ? null : onRotationFinished.get();
5097     }
5098 
5099     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinishedProperty() {
5100         if (onRotationFinished == null) {
5101             onRotationFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {
5102 
5103                 @Override
5104                 protected void invalidated() {
5105                     setEventHandler(RotateEvent.ROTATION_FINISHED, get());
5106                 }
5107 
5108                 @Override
5109                 public Object getBean() {
5110                     return Scene.this;
5111                 }
5112 
5113                 @Override
5114                 public String getName() {
5115                     return &quot;onRotationFinished&quot;;
5116                 }
5117             };
5118         }
5119         return onRotationFinished;
5120     }
5121 
5122     /**
5123      * Defines a function to be called when a zooming gesture is detected.
5124      * @since JavaFX 2.2
5125      */
5126     private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStarted;
5127 
5128     public final void setOnZoomStarted(EventHandler&lt;? super ZoomEvent&gt; value) {
5129         onZoomStartedProperty().set(value);
5130     }
5131 
5132     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
5133         return onZoomStarted == null ? null : onZoomStarted.get();
5134     }
5135 
5136     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStartedProperty() {
5137         if (onZoomStarted == null) {
5138             onZoomStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {
5139 
5140                 @Override
5141                 protected void invalidated() {
5142                     setEventHandler(ZoomEvent.ZOOM_STARTED, get());
5143                 }
5144 
5145                 @Override
5146                 public Object getBean() {
5147                     return Scene.this;
5148                 }
5149 
5150                 @Override
5151                 public String getName() {
5152                     return &quot;onZoomStarted&quot;;
5153                 }
5154             };
5155         }
5156         return onZoomStarted;
5157     }
5158 
5159     /**
5160      * Defines a function to be called when user performs a zooming action.
5161      * @since JavaFX 2.2
5162      */
5163     private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoom;
5164 
5165     public final void setOnZoom(EventHandler&lt;? super ZoomEvent&gt; value) {
5166         onZoomProperty().set(value);
5167     }
5168 
5169     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
5170         return onZoom == null ? null : onZoom.get();
5171     }
5172 
5173     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomProperty() {
5174         if (onZoom == null) {
5175             onZoom = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {
5176 
5177                 @Override
5178                 protected void invalidated() {
5179                     setEventHandler(ZoomEvent.ZOOM, get());
5180                 }
5181 
5182                 @Override
5183                 public Object getBean() {
5184                     return Scene.this;
5185                 }
5186 
5187                 @Override
5188                 public String getName() {
5189                     return &quot;onZoom&quot;;
5190                 }
5191             };
5192         }
5193         return onZoom;
5194     }
5195 
5196     /**
5197      * Defines a function to be called when a zooming gesture ends.
5198      * @since JavaFX 2.2
5199      */
5200     private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinished;
5201 
5202     public final void setOnZoomFinished(EventHandler&lt;? super ZoomEvent&gt; value) {
5203         onZoomFinishedProperty().set(value);
5204     }
5205 
5206     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
5207         return onZoomFinished == null ? null : onZoomFinished.get();
5208     }
5209 
5210     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinishedProperty() {
5211         if (onZoomFinished == null) {
5212             onZoomFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {
5213 
5214                 @Override
5215                 protected void invalidated() {
5216                     setEventHandler(ZoomEvent.ZOOM_FINISHED, get());
5217                 }
5218 
5219                 @Override
5220                 public Object getBean() {
5221                     return Scene.this;
5222                 }
5223 
5224                 @Override
5225                 public String getName() {
5226                     return &quot;onZoomFinished&quot;;
5227                 }
5228             };
5229         }
5230         return onZoomFinished;
5231     }
5232 
5233     /**
5234      * Defines a function to be called when an upward swipe gesture
5235      * happens in this scene.
5236      * @since JavaFX 2.2
5237      */
5238     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUp;
5239 
5240     public final void setOnSwipeUp(EventHandler&lt;? super SwipeEvent&gt; value) {
5241         onSwipeUpProperty().set(value);
5242     }
5243 
5244     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
5245         return onSwipeUp == null ? null : onSwipeUp.get();
5246     }
5247 
5248     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUpProperty() {
5249         if (onSwipeUp == null) {
5250             onSwipeUp = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5251 
5252                 @Override
5253                 protected void invalidated() {
5254                     setEventHandler(SwipeEvent.SWIPE_UP, get());
5255                 }
5256 
5257                 @Override
5258                 public Object getBean() {
5259                     return Scene.this;
5260                 }
5261 
5262                 @Override
5263                 public String getName() {
5264                     return &quot;onSwipeUp&quot;;
5265                 }
5266             };
5267         }
5268         return onSwipeUp;
5269     }
5270 
5271     /**
5272      * Defines a function to be called when an downward swipe gesture
5273      * happens in this scene.
5274      * @since JavaFX 2.2
5275      */
5276     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDown;
5277 
5278     public final void setOnSwipeDown(EventHandler&lt;? super SwipeEvent&gt; value) {
5279         onSwipeDownProperty().set(value);
5280     }
5281 
5282     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
5283         return onSwipeDown == null ? null : onSwipeDown.get();
5284     }
5285 
5286     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDownProperty() {
5287         if (onSwipeDown == null) {
5288             onSwipeDown = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5289 
5290                 @Override
5291                 protected void invalidated() {
5292                     setEventHandler(SwipeEvent.SWIPE_DOWN, get());
5293                 }
5294 
5295                 @Override
5296                 public Object getBean() {
5297                     return Scene.this;
5298                 }
5299 
5300                 @Override
5301                 public String getName() {
5302                     return &quot;onSwipeDown&quot;;
5303                 }
5304             };
5305         }
5306         return onSwipeDown;
5307     }
5308 
5309     /**
5310      * Defines a function to be called when an leftward swipe gesture
5311      * happens in this scene.
5312      * @since JavaFX 2.2
5313      */
5314     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeft;
5315 
5316     public final void setOnSwipeLeft(EventHandler&lt;? super SwipeEvent&gt; value) {
5317         onSwipeLeftProperty().set(value);
5318     }
5319 
5320     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
5321         return onSwipeLeft == null ? null : onSwipeLeft.get();
5322     }
5323 
5324     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeftProperty() {
5325         if (onSwipeLeft == null) {
5326             onSwipeLeft = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5327 
5328                 @Override
5329                 protected void invalidated() {
5330                     setEventHandler(SwipeEvent.SWIPE_LEFT, get());
5331                 }
5332 
5333                 @Override
5334                 public Object getBean() {
5335                     return Scene.this;
5336                 }
5337 
5338                 @Override
5339                 public String getName() {
5340                     return &quot;onSwipeLeft&quot;;
5341                 }
5342             };
5343         }
5344         return onSwipeLeft;
5345     }
5346 
5347     /**
5348      * Defines a function to be called when an rightward swipe gesture
5349      * happens in this scene.
5350      * @since JavaFX 2.2
5351      */
5352     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRight;
5353 
5354     public final void setOnSwipeRight(EventHandler&lt;? super SwipeEvent&gt; value) {
5355         onSwipeRightProperty().set(value);
5356     }
5357 
5358     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
5359         return onSwipeRight == null ? null : onSwipeRight.get();
5360     }
5361 
5362     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRightProperty() {
5363         if (onSwipeRight == null) {
5364             onSwipeRight = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5365 
5366                 @Override
5367                 protected void invalidated() {
5368                     setEventHandler(SwipeEvent.SWIPE_RIGHT, get());
5369                 }
5370 
5371                 @Override
5372                 public Object getBean() {
5373                     return Scene.this;
5374                 }
5375 
5376                 @Override
5377                 public String getName() {
5378                     return &quot;onSwipeRight&quot;;
5379                 }
5380             };
5381         }
5382         return onSwipeRight;
5383     }
5384 
5385     /***************************************************************************
5386      *                                                                         *
5387      *                            Touch Handling                               *
5388      *                                                                         *
5389      **************************************************************************/
5390 
5391     /**
5392      * Defines a function to be called when a new touch point is pressed.
5393      * @since JavaFX 2.2
5394      */
5395     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressed;
5396 
5397     public final void setOnTouchPressed(EventHandler&lt;? super TouchEvent&gt; value) {
5398         onTouchPressedProperty().set(value);
5399     }
5400 
5401     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
5402         return onTouchPressed == null ? null : onTouchPressed.get();
5403     }
5404 
5405     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressedProperty() {
5406         if (onTouchPressed == null) {
5407             onTouchPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5408 
5409                 @Override
5410                 protected void invalidated() {
5411                     setEventHandler(TouchEvent.TOUCH_PRESSED, get());
5412                 }
5413 
5414                 @Override
5415                 public Object getBean() {
5416                     return Scene.this;
5417                 }
5418 
5419                 @Override
5420                 public String getName() {
5421                     return &quot;onTouchPressed&quot;;
5422                 }
5423             };
5424         }
5425         return onTouchPressed;
5426     }
5427 
5428     /**
5429      * Defines a function to be called when a touch point is moved.
5430      * @since JavaFX 2.2
5431      */
5432     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMoved;
5433 
5434     public final void setOnTouchMoved(EventHandler&lt;? super TouchEvent&gt; value) {
5435         onTouchMovedProperty().set(value);
5436     }
5437 
5438     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
5439         return onTouchMoved == null ? null : onTouchMoved.get();
5440     }
5441 
5442     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMovedProperty() {
5443         if (onTouchMoved == null) {
5444             onTouchMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5445 
5446                 @Override
5447                 protected void invalidated() {
5448                     setEventHandler(TouchEvent.TOUCH_MOVED, get());
5449                 }
5450 
5451                 @Override
5452                 public Object getBean() {
5453                     return Scene.this;
5454                 }
5455 
5456                 @Override
5457                 public String getName() {
5458                     return &quot;onTouchMoved&quot;;
5459                 }
5460             };
5461         }
5462         return onTouchMoved;
5463     }
5464 
5465     /**
5466      * Defines a function to be called when a new touch point is pressed.
5467      * @since JavaFX 2.2
5468      */
5469     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleased;
5470 
5471     public final void setOnTouchReleased(EventHandler&lt;? super TouchEvent&gt; value) {
5472         onTouchReleasedProperty().set(value);
5473     }
5474 
5475     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
5476         return onTouchReleased == null ? null : onTouchReleased.get();
5477     }
5478 
5479     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleasedProperty() {
5480         if (onTouchReleased == null) {
5481             onTouchReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5482 
5483                 @Override
5484                 protected void invalidated() {
5485                     setEventHandler(TouchEvent.TOUCH_RELEASED, get());
5486                 }
5487 
5488                 @Override
5489                 public Object getBean() {
5490                     return Scene.this;
5491                 }
5492 
5493                 @Override
5494                 public String getName() {
5495                     return &quot;onTouchReleased&quot;;
5496                 }
5497             };
5498         }
5499         return onTouchReleased;
5500     }
5501 
5502     /**
5503      * Defines a function to be called when a touch point stays pressed and
5504      * still.
5505      * @since JavaFX 2.2
5506      */
5507     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationary;
5508 
5509     public final void setOnTouchStationary(EventHandler&lt;? super TouchEvent&gt; value) {
5510         onTouchStationaryProperty().set(value);
5511     }
5512 
5513     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
5514         return onTouchStationary == null ? null : onTouchStationary.get();
5515     }
5516 
5517     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationaryProperty() {
5518         if (onTouchStationary == null) {
5519             onTouchStationary = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5520 
5521                 @Override
5522                 protected void invalidated() {
5523                     setEventHandler(TouchEvent.TOUCH_STATIONARY, get());
5524                 }
5525 
5526                 @Override
5527                 public Object getBean() {
5528                     return Scene.this;
5529                 }
5530 
5531                 @Override
5532                 public String getName() {
5533                     return &quot;onTouchStationary&quot;;
5534                 }
5535             };
5536         }
5537         return onTouchStationary;
5538     }
5539 
5540     /*
5541      * This class provides reordering and ID mapping of particular touch points.
5542      * Platform may report arbitrary touch point IDs and they may be reused
5543      * during one gesture. This class keeps track of it and provides
5544      * sequentially sorted IDs, unique in scope of a gesture.
5545      *
5546      * Some platforms report always small numbers, these take fast paths through
5547      * the algorithm, directly indexing an array. Bigger numbers take a slow
5548      * path using a hash map.
5549      *
5550      * The algorithm performance was measured and it doesn&#39;t impose
5551      * any significant slowdown on the event delivery.
5552      */
5553     private static class TouchMap {
5554         private static final int FAST_THRESHOLD = 10;
5555         int[] fastMap = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
5556         Map&lt;Long, Integer&gt; slowMap = new HashMap&lt;Long, Integer&gt;();
5557         List&lt;Integer&gt; order = new LinkedList&lt;Integer&gt;();
5558         List&lt;Long&gt; removed = new ArrayList&lt;Long&gt;(10);
5559         int counter = 0;
5560         int active = 0;
5561 
5562         public int add(long id) {
5563             counter++;
5564             active++;
5565             if (id &lt; FAST_THRESHOLD) {
5566                 fastMap[(int) id] = counter;
5567             } else {
5568                 slowMap.put(id, counter);
5569             }
5570             order.add(counter);
5571             return counter;
5572         }
5573 
5574         public void remove(long id) {
5575             // book the removal - it needs to be done after all touch points
5576             // of an event are processed - see cleanup()
5577             removed.add(id);
5578         }
5579 
5580         public int get(long id) {
5581             if (id &lt; FAST_THRESHOLD) {
5582                 int result = fastMap[(int) id];
5583                 if (result == 0) {
5584                     throw new RuntimeException(&quot;Platform reported wrong &quot;
5585                             + &quot;touch point ID&quot;);
5586                 }
5587                 return result;
5588             } else {
5589                 try {
5590                     return slowMap.get(id);
5591                 } catch (NullPointerException e) {
5592                     throw new RuntimeException(&quot;Platform reported wrong &quot;
5593                             + &quot;touch point ID&quot;);
5594                 }
5595             }
5596         }
5597 
5598         public int getOrder(int id) {
5599             return order.indexOf(id);
5600         }
5601 
5602         // returns true if gesture finished (no finger is touched)
5603         public boolean cleanup() {
5604             for (long id : removed) {
5605                 active--;
5606                 order.remove(Integer.valueOf(get(id)));
5607                 if (id &lt; FAST_THRESHOLD) {
5608                     fastMap[(int) id] = 0;
5609                 } else {
5610                     slowMap.remove(id);
5611                 }
5612                 if (active == 0) {
5613                     // gesture finished
5614                     counter = 0;
5615                 }
5616             }
5617             removed.clear();
5618             return active == 0;
5619         }
5620     }
5621 
5622 
5623     /***************************************************************************
5624      *                                                                         *
5625      *                         Drag and Drop Handling                          *
5626      *                                                                         *
5627      **************************************************************************/
5628 
5629     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEntered;
5630 
5631     public final void setOnDragEntered(EventHandler&lt;? super DragEvent&gt; value) {
5632         onDragEnteredProperty().set(value);
5633     }
5634 
5635     public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
5636         return onDragEntered == null ? null : onDragEntered.get();
5637     }
5638 
5639     /**
5640      * Defines a function to be called when drag gesture
5641      * enters this {@code Scene}.
5642      * @return function to be called when drag gesture enters this scene
5643      */
5644     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEnteredProperty() {
5645         if (onDragEntered == null) {
5646             onDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5647 
5648                 @Override
5649                 protected void invalidated() {
5650                     setEventHandler(DragEvent.DRAG_ENTERED, get());
5651                 }
5652 
5653                 @Override
5654                 public Object getBean() {
5655                     return Scene.this;
5656                 }
5657 
5658                 @Override
5659                 public String getName() {
5660                     return &quot;onDragEntered&quot;;
5661                 }
5662             };
5663         }
5664         return onDragEntered;
5665     }
5666 
5667     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExited;
5668 
5669     public final void setOnDragExited(EventHandler&lt;? super DragEvent&gt; value) {
5670         onDragExitedProperty().set(value);
5671     }
5672 
5673     public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
5674         return onDragExited == null ? null : onDragExited.get();
5675     }
5676 
5677     /**
5678      * Defines a function to be called when drag gesture
5679      * exits this {@code Scene}.
5680      * @return the function to be called when drag gesture exits this scene
5681      */
5682     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExitedProperty() {
5683         if (onDragExited == null) {
5684             onDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5685 
5686                 @Override
5687                 protected void invalidated() {
5688                     setEventHandler(DragEvent.DRAG_EXITED, get());
5689                 }
5690 
5691                 @Override
5692                 public Object getBean() {
5693                     return Scene.this;
5694                 }
5695 
5696                 @Override
5697                 public String getName() {
5698                     return &quot;onDragExited&quot;;
5699                 }
5700             };
5701         }
5702         return onDragExited;
5703     }
5704 
5705     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOver;
5706 
5707     public final void setOnDragOver(EventHandler&lt;? super DragEvent&gt; value) {
5708         onDragOverProperty().set(value);
5709     }
5710 
5711     public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
5712         return onDragOver == null ? null : onDragOver.get();
5713     }
5714 
5715     /**
5716      * Defines a function to be called when drag gesture progresses
5717      * within this {@code Scene}.
5718      * @return the function to be called when drag gesture progresses within
5719      * this scene
5720      */
5721     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOverProperty() {
5722         if (onDragOver == null) {
5723             onDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5724 
5725                 @Override
5726                 protected void invalidated() {
5727                     setEventHandler(DragEvent.DRAG_OVER, get());
5728                 }
5729 
5730                 @Override
5731                 public Object getBean() {
5732                     return Scene.this;
5733                 }
5734 
5735                 @Override
5736                 public String getName() {
5737                     return &quot;onDragOver&quot;;
5738                 }
5739             };
5740         }
5741         return onDragOver;
5742     }
5743 
5744     // Do we want DRAG_TRANSFER_MODE_CHANGED event?
5745 //    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChanged;
5746 //
5747 //    public final void setOnDragTransferModeChanged(EventHandler&lt;? super DragEvent&gt; value) {
5748 //        onDragTransferModeChangedProperty().set(value);
5749 //    }
5750 //
5751 //    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
5752 //        return onDragTransferModeChanged == null ? null : onDragTransferModeChanged.get();
5753 //    }
5754 //
5755 //    /**
5756 //     * Defines a function to be called this {@code Scene} if it is a potential
5757 //     * drag-and-drop target when the user takes action to change the intended
5758 //     * {@code TransferMode}.
5759 //     * The user can change the intended {@link TransferMode} by holding down
5760 //     * or releasing key modifiers.
5761 //     */
5762 //    public ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChangedProperty() {
5763 //        if (onDragTransferModeChanged == null) {
5764 //            onDragTransferModeChanged = new SimpleObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5765 //
5766 //                @Override
5767 //                protected void invalidated() {
5768 //                    setEventHandler(DragEvent.DRAG_TRANSFER_MODE_CHANGED, get());
5769 //                }
5770 //            };
5771 //        }
5772 //        return onDragTransferModeChanged;
5773 //    }
5774 
5775     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDropped;
5776 
5777     public final void setOnDragDropped(EventHandler&lt;? super DragEvent&gt; value) {
5778         onDragDroppedProperty().set(value);
5779     }
5780 
5781     public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
5782         return onDragDropped == null ? null : onDragDropped.get();
5783     }
5784 
5785     /**
5786      * Defines a function to be called when the mouse button is released
5787      * on this {@code Scene} during drag and drop gesture. Transfer of data from
5788      * the {@link DragEvent}&#39;s {@link DragEvent#getDragboard() dragboard} should
5789      * happen in this function.
5790      * @return the function to be called when the mouse button is released on
5791      * this scene during drag and drop gesture
5792      */
5793     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDroppedProperty() {
5794         if (onDragDropped == null) {
5795             onDragDropped = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5796 
5797                 @Override
5798                 protected void invalidated() {
5799                     setEventHandler(DragEvent.DRAG_DROPPED, get());
5800                 }
5801 
5802                 @Override
5803                 public Object getBean() {
5804                     return Scene.this;
5805                 }
5806 
5807                 @Override
5808                 public String getName() {
5809                     return &quot;onDragDropped&quot;;
5810                 }
5811             };
5812         }
5813         return onDragDropped;
5814     }
5815 
5816     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDone;
5817 
5818     public final void setOnDragDone(EventHandler&lt;? super DragEvent&gt; value) {
5819         onDragDoneProperty().set(value);
5820     }
5821 
5822     public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
5823         return onDragDone == null ? null : onDragDone.get();
5824     }
5825 
5826     /**
5827      * Defines a function to be called when this {@code Scene} is a
5828      * drag and drop gesture source after its data has
5829      * been dropped on a drop target. The {@code transferMode} of the
5830      * event shows what just happened at the drop target.
5831      * If {@code transferMode} has the value {@code MOVE}, then the source can
5832      * clear out its data. Clearing the source&#39;s data gives the appropriate
5833      * appearance to a user that the data has been moved by the drag and drop
5834      * gesture. A {@code transferMode} that has the value {@code NONE}
5835      * indicates that no data was transferred during the drag and drop gesture.
5836      * Positional data for the {@code DragEvent} is invalid.  Valid positional
5837      * data for the {@code DragEvent} is presented in the
5838      * {@link #onDragDroppedProperty() onDragDropped} event handler.
5839      * @return the function to be called when this scene is a drag and drop
5840      * gesture source after its data has been dropped on a drop target
5841      */
5842     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDoneProperty() {
5843         if (onDragDone == null) {
5844             onDragDone = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5845 
5846                 @Override
5847                 protected void invalidated() {
5848                     setEventHandler(DragEvent.DRAG_DONE, get());
5849                 }
5850 
5851                 @Override
5852                 public Object getBean() {
5853                     return Scene.this;
5854                 }
5855 
5856                 @Override
5857                 public String getName() {
5858                     return &quot;onDragDone&quot;;
5859                 }
5860             };
5861         }
5862         return onDragDone;
5863     }
5864 
5865     /**
5866      * Confirms a potential drag and drop gesture that is recognized over this
5867      * {@code Scene}.
5868      * Can be called only from a DRAG_DETECTED event handler. The returned
5869      * {@link Dragboard} is used to transfer data during
5870      * the drag and drop gesture. Placing this {@code Scene}&#39;s data on the
5871      * {@link Dragboard} also identifies this {@code Scene} as the source of
5872      * the drag and drop gesture.
5873      * More detail about drag and drop gestures is described in the overivew
5874      * of {@link DragEvent}.
5875      *
5876      * @see DragEvent
5877      * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
5878      * @return A {@code Dragboard} to place this {@code Scene}&#39;s data on
5879      * @throws IllegalStateException if drag and drop cannot be started at this
5880      * moment (it&#39;s called outside of {@code DRAG_DETECTED} event handling).
5881      */
5882     public Dragboard startDragAndDrop(TransferMode... transferModes) {
5883         return startDragAndDrop(this, transferModes);
5884     }
5885 
5886     /**
5887      * Starts a full press-drag-release gesture with this scene as gesture
5888      * source. This method can be called only from a {@code DRAG_DETECTED} mouse
5889      * event handler. More detail about dragging gestures can be found
5890      * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
5891      *
5892      * @see MouseEvent
5893      * @see MouseDragEvent
5894      * @throws IllegalStateException if the full press-drag-release gesture
5895      * cannot be started at this moment (it&#39;s called outside of
5896      * {@code DRAG_DETECTED} event handling).
5897      * @since JavaFX 2.1
5898      */
5899     public void startFullDrag() {
5900         startFullDrag(this);
5901     }
5902 
5903 
5904     Dragboard startDragAndDrop(EventTarget source, TransferMode... transferModes) {
5905         Toolkit.getToolkit().checkFxUserThread();
5906         if (dndGesture == null ||
5907             (dndGesture.dragDetected != DragDetectedState.PROCESSING))
5908         {
5909             throw new IllegalStateException(&quot;Cannot start drag and drop &quot; +
5910                     &quot;outside of DRAG_DETECTED event handler&quot;);
5911         }
5912 
5913         Set&lt;TransferMode&gt; set = EnumSet.noneOf(TransferMode.class);
5914         for (TransferMode tm : InputEventUtils.safeTransferModes(transferModes)) {
5915             set.add(tm);
5916         }
5917         return dndGesture.startDrag(source, set);
5918     }
5919 
5920     void startFullDrag(EventTarget source) {
5921         Toolkit.getToolkit().checkFxUserThread();
5922         if (dndGesture.dragDetected != DragDetectedState.PROCESSING) {
5923             throw new IllegalStateException(&quot;Cannot start full drag &quot; +
5924                     &quot;outside of DRAG_DETECTED event handler&quot;);
5925         }
5926 
5927         if (dndGesture != null) {
5928             dndGesture.startFullPDR(source);
5929             return;
5930         }
5931 
5932         throw new IllegalStateException(&quot;Cannot start full drag when &quot;
5933                 + &quot;mouse button is not pressed&quot;);
5934     }
5935 
5936     /***************************************************************************
5937      *                                                                         *
5938      *                           Keyboard Handling                             *
5939      *                                                                         *
5940      **************************************************************************/
5941 
5942     /**
5943      * Defines a function to be called when some {@code Node} of this
5944      * {@code Scene} has input focus and a key has been pressed. The function
5945      * is called only if the event hasn&#39;t been already consumed during its
5946      * capturing or bubbling phase.
5947      */
5948     private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressed;
5949 
5950     public final void setOnKeyPressed(EventHandler&lt;? super KeyEvent&gt; value) {
5951         onKeyPressedProperty().set(value);
5952     }
5953 
5954     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
5955         return onKeyPressed == null ? null : onKeyPressed.get();
5956     }
5957 
5958     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressedProperty() {
5959         if (onKeyPressed == null) {
5960             onKeyPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {
5961 
5962                 @Override
5963                 protected void invalidated() {
5964                     setEventHandler(KeyEvent.KEY_PRESSED, get());
5965                 }
5966 
5967                 @Override
5968                 public Object getBean() {
5969                     return Scene.this;
5970                 }
5971 
5972                 @Override
5973                 public String getName() {
5974                     return &quot;onKeyPressed&quot;;
5975                 }
5976             };
5977         }
5978         return onKeyPressed;
5979     }
5980 
5981     /**
5982      * Defines a function to be called when some {@code Node} of this
5983      * {@code Scene} has input focus and a key has been released. The function
5984      * is called only if the event hasn&#39;t been already consumed during its
5985      * capturing or bubbling phase.
5986      */
5987     private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleased;
5988 
5989     public final void setOnKeyReleased(EventHandler&lt;? super KeyEvent&gt; value) {
5990         onKeyReleasedProperty().set(value);
5991     }
5992 
5993     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
5994         return onKeyReleased == null ? null : onKeyReleased.get();
5995     }
5996 
5997     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleasedProperty() {
5998         if (onKeyReleased == null) {
5999             onKeyReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {
6000 
6001                 @Override
6002                 protected void invalidated() {
6003                     setEventHandler(KeyEvent.KEY_RELEASED, get());
6004                 }
6005 
6006                 @Override
6007                 public Object getBean() {
6008                     return Scene.this;
6009                 }
6010 
6011                 @Override
6012                 public String getName() {
6013                     return &quot;onKeyReleased&quot;;
6014                 }
6015             };
6016         }
6017         return onKeyReleased;
6018     }
6019 
6020     /**
6021      * Defines a function to be called when some {@code Node} of this
6022      * {@code Scene} has input focus and a key has been typed. The function
6023      * is called only if the event hasn&#39;t been already consumed during its
6024      * capturing or bubbling phase.
6025      */
6026     private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTyped;
6027 
6028     public final void setOnKeyTyped(
6029             EventHandler&lt;? super KeyEvent&gt; value) {
6030         onKeyTypedProperty().set( value);
6031 
6032     }
6033 
6034     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped(
6035             ) {
6036         return onKeyTyped == null ? null : onKeyTyped.get();
6037     }
6038 
6039     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTypedProperty(
6040     ) {
6041         if (onKeyTyped == null) {
6042             onKeyTyped = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {
6043 
6044                 @Override
6045                 protected void invalidated() {
6046                     setEventHandler(KeyEvent.KEY_TYPED, get());
6047                 }
6048 
6049                 @Override
6050                 public Object getBean() {
6051                     return Scene.this;
6052                 }
6053 
6054                 @Override
6055                 public String getName() {
6056                     return &quot;onKeyTyped&quot;;
6057                 }
6058             };
6059         }
6060         return onKeyTyped;
6061     }
6062 
6063     /***************************************************************************
6064      *                                                                         *
6065      *                           Input Method Handling                         *
6066      *                                                                         *
6067      **************************************************************************/
6068 
6069     /**
6070      * Defines a function to be called when this {@code Node}
6071      * has input focus and the input method text has changed.  If this
6072      * function is not defined in this {@code Node}, then it
6073      * receives the result string of the input method composition as a
6074      * series of {@code onKeyTyped} function calls.
6075      * &lt;p&gt;
6076      * When the {@code Node} loses the input focus, the JavaFX runtime
6077      * automatically commits the existing composed text if any.
6078      */
6079     private ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChanged;
6080 
6081     public final void setOnInputMethodTextChanged(
6082             EventHandler&lt;? super InputMethodEvent&gt; value) {
6083         onInputMethodTextChangedProperty().set( value);
6084     }
6085 
6086     public final EventHandler&lt;? super InputMethodEvent&gt; getOnInputMethodTextChanged() {
6087         return onInputMethodTextChanged == null ? null : onInputMethodTextChanged.get();
6088     }
6089 
6090     public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChangedProperty() {
6091         if (onInputMethodTextChanged == null) {
6092             onInputMethodTextChanged = new ObjectPropertyBase&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;() {
6093 
6094                 @Override
6095                 protected void invalidated() {
6096                     setEventHandler(InputMethodEvent.INPUT_METHOD_TEXT_CHANGED, get());
6097                 }
6098 
6099                 @Override
6100                 public Object getBean() {
6101                     return Scene.this;
6102                 }
6103 
6104                 @Override
6105                 public String getName() {
6106                     return &quot;onInputMethodTextChanged&quot;;
6107                 }
6108             };
6109         }
6110         return onInputMethodTextChanged;
6111     }
6112 
6113     /*
6114      * This class represents a picked target - either node, or scne, or null.
6115      * It provides functionality needed for the targets and covers the fact
6116      * that they are different kinds of animals.
6117      */
6118     private static class TargetWrapper {
6119         private Scene scene;
6120         private Node node;
6121         private PickResult result;
6122 
6123         /**
6124          * Fills the list with the target and all its parents (including scene)
6125          */
6126         public void fillHierarchy(final List&lt;EventTarget&gt; list) {
6127             list.clear();
6128             Node n = node;
6129             while(n != null) {
6130                 list.add(n);
6131                 final Parent p = n.getParent();
6132                 n = p != null ? p : n.getSubScene();
6133             }
6134 
6135             if (scene != null) {
6136                 list.add(scene);
6137             }
6138         }
6139 
6140         public EventTarget getEventTarget() {
6141             return node != null ? node : scene;
6142         }
6143 
6144         public Cursor getCursor() {
6145             Cursor cursor = null;
6146             if (node != null) {
6147                 cursor = node.getCursor();
6148                 Node n = node.getParent();
6149                 while (cursor == null &amp;&amp; n != null) {
6150                     cursor = n.getCursor();
6151 
6152                     final Parent p = n.getParent();
6153                     n = p != null ? p : n.getSubScene();
6154                 }
6155             }
6156             return cursor;
6157         }
6158 
6159         public void clear() {
6160             set(null, null);
6161             result = null;
6162         }
6163 
6164         public void setNodeResult(PickResult result) {
6165             if (result != null) {
6166                 this.result = result;
6167                 final Node n = result.getIntersectedNode();
6168                 set(n, n.getScene());
6169             }
6170         }
6171 
6172         // Pass null scene if the mouse is outside of the window content
6173         public void setSceneResult(PickResult result, Scene scene) {
6174             if (result != null) {
6175                 this.result = result;
6176                 set(null, scene);
6177             }
6178         }
6179 
6180         public PickResult getResult() {
6181             return result;
6182         }
6183 
6184         public void copy(TargetWrapper tw) {
6185             node = tw.node;
6186             scene = tw.scene;
6187             result = tw.result;
6188         }
6189 
6190         private void set(Node n, Scene s) {
6191             node = n;
6192             scene = s;
6193         }
6194     }
6195 
6196     /*************************************************************************
6197     *                                                                        *
6198     *                                                                        *
6199     *                                                                        *
6200     *************************************************************************/
6201 
6202     private static final Object USER_DATA_KEY = new Object();
6203     // A map containing a set of properties for this scene
6204     private ObservableMap&lt;Object, Object&gt; properties;
6205 
6206     /**
6207       * Returns an observable map of properties on this node for use primarily
6208       * by application developers.
6209       *
6210       * @return an observable map of properties on this node for use primarily
6211       * by application developers
6212       *
6213       * @since JavaFX 8u40
6214       */
6215      public final ObservableMap&lt;Object, Object&gt; getProperties() {
6216         if (properties == null) {
6217             properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
6218         }
6219         return properties;
6220     }
6221 
6222     /**
6223      * Tests if Scene has properties.
6224      * @return true if node has properties.
6225      *
6226      * @since JavaFX 8u40
6227      */
6228      public boolean hasProperties() {
6229         return properties != null &amp;&amp; !properties.isEmpty();
6230     }
6231 
6232     /**
6233      * Convenience method for setting a single Object property that can be
6234      * retrieved at a later date. This is functionally equivalent to calling
6235      * the getProperties().put(Object key, Object value) method. This can later
6236      * be retrieved by calling {@link Scene#getUserData()}.
6237      *
6238      * @param value The value to be stored - this can later be retrieved by calling
6239      *          {@link Scene#getUserData()}.
6240      *
6241      * @since JavaFX 8u40
6242      */
6243     public void setUserData(Object value) {
6244         getProperties().put(USER_DATA_KEY, value);
6245     }
6246 
6247     /**
6248      * Returns a previously set Object property, or null if no such property
6249      * has been set using the {@link Scene#setUserData(java.lang.Object)} method.
6250      *
6251      * @return The Object that was previously set, or null if no property
6252      *          has been set or if null was set.
6253      *
6254      * @since JavaFX 8u40
6255      */
6256     public Object getUserData() {
6257         return getProperties().get(USER_DATA_KEY);
6258     }
6259 
6260     /***************************************************************************
6261      *                                                                         *
6262      *                       Component Orientation Properties                  *
6263      *                                                                         *
6264      **************************************************************************/
6265 
6266     private static final NodeOrientation defaultNodeOrientation =
6267         AccessController.doPrivileged(
6268                 (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.nodeOrientation.RTL&quot;)) ? NodeOrientation.RIGHT_TO_LEFT : NodeOrientation.INHERIT;
6269 
6270 
6271 
6272     private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
6273     private EffectiveOrientationProperty effectiveNodeOrientationProperty;
6274 
6275     private NodeOrientation effectiveNodeOrientation;
6276 
6277     public final void setNodeOrientation(NodeOrientation orientation) {
6278         nodeOrientationProperty().set(orientation);
6279     }
6280 
6281     public final NodeOrientation getNodeOrientation() {
6282         return nodeOrientation == null ? defaultNodeOrientation : nodeOrientation.get();
6283     }
6284 
6285     /**
6286      * Property holding NodeOrientation.
6287      * &lt;p&gt;
6288      * Node orientation describes the flow of visual data within a node.
6289      * In the English speaking world, visual data normally flows from
6290      * left-to-right. In an Arabic or Hebrew world, visual data flows
6291      * from right-to-left.  This is consistent with the reading order
6292      * of text in both worlds.  The default value is left-to-right.
6293      * &lt;/p&gt;
6294      *
6295      * @return NodeOrientation
6296      * @since JavaFX 8.0
6297      */
6298     public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
6299         if (nodeOrientation == null) {
6300             nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(defaultNodeOrientation) {
6301                 @Override
6302                 protected void invalidated() {
6303                     sceneEffectiveOrientationInvalidated();
6304                     getRoot().applyCss();
6305                 }
6306 
6307                 @Override
6308                 public Object getBean() {
6309                     return Scene.this;
6310                 }
6311 
6312                 @Override
6313                 public String getName() {
6314                     return &quot;nodeOrientation&quot;;
6315                 }
6316 
6317                 @Override
6318                 public CssMetaData getCssMetaData() {
6319                     //TODO - not yet supported
6320                     throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
6321                 }
6322             };
6323         }
6324         return nodeOrientation;
6325     }
6326 
6327     public final NodeOrientation getEffectiveNodeOrientation() {
6328         if (effectiveNodeOrientation == null) {
6329             effectiveNodeOrientation = calcEffectiveNodeOrientation();
6330         }
6331 
6332         return effectiveNodeOrientation;
6333     }
6334 
6335     /**
6336      * The effective node orientation of a scene resolves the inheritance of
6337      * node orientation, returning either left-to-right or right-to-left.
6338      * @return the effective node orientation of this scene
6339      * @since JavaFX 8.0
6340      */
6341     public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
6342             effectiveNodeOrientationProperty() {
6343         if (effectiveNodeOrientationProperty == null) {
6344             effectiveNodeOrientationProperty =
6345                     new EffectiveOrientationProperty();
6346         }
6347 
6348         return effectiveNodeOrientationProperty;
6349     }
6350 
6351     private void parentEffectiveOrientationInvalidated() {
6352         if (getNodeOrientation() == NodeOrientation.INHERIT) {
6353             sceneEffectiveOrientationInvalidated();
6354         }
6355     }
6356 
6357     private void sceneEffectiveOrientationInvalidated() {
6358         effectiveNodeOrientation = null;
6359 
6360         if (effectiveNodeOrientationProperty != null) {
6361             effectiveNodeOrientationProperty.invalidate();
6362         }
6363 
6364         getRoot().parentResolvedOrientationInvalidated();
6365     }
6366 
6367     private NodeOrientation calcEffectiveNodeOrientation() {
6368         NodeOrientation orientation = getNodeOrientation();
6369         if (orientation == NodeOrientation.INHERIT) {
6370             Window window = getWindow();
6371             if (window != null) {
6372                 Window parent = null;
6373                 if (window instanceof Stage) {
6374                     parent = ((Stage)window).getOwner();
6375                 } else {
6376                     if (window instanceof PopupWindow) {
6377                         parent = ((PopupWindow)window).getOwnerWindow();
6378                     }
6379                 }
6380                 if (parent != null) {
6381                     Scene scene = parent.getScene();
6382                     if (scene != null) return scene.getEffectiveNodeOrientation();
6383                 }
6384             }
6385             return NodeOrientation.LEFT_TO_RIGHT;
6386         }
6387         return orientation;
6388     }
6389 
6390     private final class EffectiveOrientationProperty
6391             extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
6392         @Override
6393         public NodeOrientation get() {
6394             return getEffectiveNodeOrientation();
6395         }
6396 
6397         @Override
6398         public Object getBean() {
6399             return Scene.this;
6400         }
6401 
6402         @Override
6403         public String getName() {
6404             return &quot;effectiveNodeOrientation&quot;;
6405         }
6406 
6407         public void invalidate() {
6408             fireValueChangedEvent();
6409         }
6410     }
6411 
6412     private Map&lt;Node, Accessible&gt; accMap;
6413     Accessible removeAccessible(Node node) {
6414         if (accMap == null) return null;
6415         return accMap.remove(node);
6416     }
6417 
6418     void addAccessible(Node node, Accessible acc) {
6419         if (accMap == null) {
6420             accMap = new HashMap&lt;Node, Accessible&gt;();
6421         }
6422         accMap.put(node, acc);
6423     }
6424 
6425     private void disposeAccessibles() {
6426         if (accMap != null) {
6427             for (Map.Entry&lt;Node, Accessible&gt; entry : accMap.entrySet()) {
6428                 Node node = entry.getKey();
6429                 Accessible acc = entry.getValue();
6430                 if (node.accessible != null) {
6431                     /* This node has already been initialized to another scene.
6432                      * Note an accessible can be returned to the node before the
6433                      * pulse if getAccessible() is called. In which case it must
6434                      * already being removed from accMap.
6435                      */
6436                     if (node.accessible == acc) {
6437                         System.err.println(&quot;[A11y] &#39;node.accessible == acc&#39; should never happen.&quot;);
6438                     }
6439                     if (node.getScene() == this) {
6440                         System.err.println(&quot;[A11y] &#39;node.getScene() == this&#39; should never happen.&quot;);
6441                     }
6442                     acc.dispose();
6443                 } else {
6444                     if (node.getScene() == this) {
6445                         node.accessible = acc;
6446                     } else {
6447                         acc.dispose();
6448                     }
6449                 }
6450             }
6451             accMap.clear();
6452         }
6453     }
6454 
6455     private Accessible accessible;
6456     Accessible getAccessible() {
6457         /*
6458          * The accessible for the Scene should never be
6459          * requested when the peer is not set.
6460          * This can only happen in a error case where a
6461          * descender of this Scene was not disposed and
6462          * it still being used by the AT client and trying
6463          * to reach to the top level window.
6464          */
6465         if (peer == null) return null;
6466         if (accessible == null) {
6467             accessible = Application.GetApplication().createAccessible();
6468             accessible.setEventHandler(new Accessible.EventHandler() {
6469                 @Override public AccessControlContext getAccessControlContext() {
6470                     return getPeer().getAccessControlContext();
6471                 }
6472 
6473                 @Override public Object getAttribute(AccessibleAttribute attribute,
6474                                                      Object... parameters) {
6475                     switch (attribute) {
6476                         case CHILDREN: {
6477                             Parent root = getRoot();
6478                             if (root != null) {
6479                                 return FXCollections.observableArrayList(root);
6480                             }
6481                             break;
6482                         }
6483                         case TEXT: {
6484                             Window w = getWindow();
6485                             if (w instanceof Stage) {
6486                                 return ((Stage)w).getTitle();
6487                             }
6488                             break;
6489                         }
6490                         case NODE_AT_POINT: {
6491                             Window window = getWindow();
6492                             /* is this screen to scene translation correct ? not considering camera ? */
6493                             Point2D pt = (Point2D)parameters[0];
6494                             PickResult res = pick(pt.getX() - getX() - window.getX(), pt.getY() - getY() - window.getY());
6495                             if (res != null) {
6496                                 Node node = res.getIntersectedNode();
6497                                 if (node != null) return node;
6498                             }
6499                             return getRoot();//not sure
6500                         }
6501                         case ROLE: return AccessibleRole.PARENT;
6502                         case SCENE: return Scene.this;
6503                         case FOCUS_NODE: {
6504                             if (transientFocusContainer != null) {
6505                                 return transientFocusContainer.queryAccessibleAttribute(AccessibleAttribute.FOCUS_NODE);
6506                             }
6507                             return getFocusOwner();
6508                         }
6509                         default:
6510                     }
6511                     return super.getAttribute(attribute, parameters);
6512                 }
6513             });
6514             PlatformImpl.accessibilityActiveProperty().set(true);
6515         }
6516         return accessible;
6517     }
6518 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>