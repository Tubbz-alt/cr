<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/java/javafx/scene/Scene.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>modules/javafx.graphics/src/main/java/javafx/scene/Scene.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1264 
1265         getRoot().updateBounds();
1266         if (peer != null) {
1267             peer.waitForRenderingToComplete();
1268             peer.waitForSynchronization();
1269             try {
1270                 // Run the synchronizer while holding the render lock
1271                 scenePulseListener.synchronizeSceneNodes();
1272             } finally {
1273                 peer.releaseSynchronization(false);
1274             }
1275         } else {
1276             scenePulseListener.synchronizeSceneNodes();
1277         }
1278 
1279     }
1280 
1281     // Shared method for Scene.snapshot and Node.snapshot. It is static because
1282     // we might be doing a Node snapshot with a null scene
1283     static WritableImage doSnapshot(Scene scene,
<span class="line-modified">1284             double x, double y, double w, double h,</span>
<span class="line-modified">1285             Node root, BaseTransform transform, boolean depthBuffer,</span>
<span class="line-modified">1286             Paint fill, Camera camera, WritableImage wimg) {</span>
<span class="line-modified">1287 </span>
<span class="line-modified">1288         Toolkit tk = Toolkit.getToolkit();</span>
<span class="line-modified">1289         Toolkit.ImageRenderingContext context = new Toolkit.ImageRenderingContext();</span>
<span class="line-modified">1290 </span>
<span class="line-modified">1291         int xMin = (int)Math.floor(x);</span>
<span class="line-removed">1292         int yMin = (int)Math.floor(y);</span>
<span class="line-removed">1293         int xMax = (int)Math.ceil(x + w);</span>
<span class="line-removed">1294         int yMax = (int)Math.ceil(y + h);</span>
1295         int width = Math.max(xMax - xMin, 1);
1296         int height = Math.max(yMax - yMin, 1);
1297         if (wimg == null) {
1298             wimg = new WritableImage(width, height);
<span class="line-modified">1299         } else {</span>
<span class="line-modified">1300             width = (int)wimg.getWidth();</span>
<span class="line-modified">1301             height = (int)wimg.getHeight();</span>































1302         }
1303 















1304         setAllowPGAccess(true);
<span class="line-modified">1305         context.x = xMin;</span>
<span class="line-modified">1306         context.y = yMin;</span>
<span class="line-modified">1307         context.width = width;</span>
<span class="line-modified">1308         context.height = height;</span>
1309         context.transform = transform;
1310         context.depthBuffer = depthBuffer;
1311         context.root = root.getPeer();
1312         context.platformPaint = fill == null ? null : tk.getPaint(fill);
1313         double cameraViewWidth = 1.0;
1314         double cameraViewHeight = 1.0;
1315         if (camera != null) {
1316             // temporarily adjust camera viewport to the snapshot size
1317             cameraViewWidth = camera.getViewWidth();
1318             cameraViewHeight = camera.getViewHeight();
<span class="line-modified">1319             camera.setViewWidth(width);</span>
<span class="line-modified">1320             camera.setViewHeight(height);</span>
1321             NodeHelper.updatePeer(camera);
1322             context.camera = camera.getPeer();
1323         } else {
1324             context.camera = null;
1325         }
1326 
1327         // Grab the lights from the scene
1328         context.lights = null;
1329         if (scene != null &amp;&amp; !scene.lights.isEmpty()) {
1330             context.lights = new NGLightBase[scene.lights.size()];
1331             for (int i = 0; i &lt; scene.lights.size(); i++) {
1332                 context.lights[i] = scene.lights.get(i).getPeer();
1333             }
1334         }
1335 
1336         Toolkit.WritableImageAccessor accessor = Toolkit.getWritableImageAccessor();
<span class="line-modified">1337         context.platformImage = accessor.getTkImageLoader(wimg);</span>
1338         setAllowPGAccess(false);
1339         Object tkImage = tk.renderToImage(context);
<span class="line-modified">1340         accessor.loadTkImage(wimg, tkImage);</span>
1341 
1342         if (camera != null) {
1343             setAllowPGAccess(true);
1344             camera.setViewWidth(cameraViewWidth);
1345             camera.setViewHeight(cameraViewHeight);
1346             NodeHelper.updatePeer(camera);
1347             setAllowPGAccess(false);
1348         }
<span class="line-modified">1349 </span>
<span class="line-removed">1350         // if this scene belongs to some stage</span>
<span class="line-removed">1351         // we need to mark the entire scene as dirty</span>
<span class="line-removed">1352         // because dirty logic is buggy</span>
<span class="line-removed">1353         if (scene != null &amp;&amp; scene.peer != null) {</span>
<span class="line-removed">1354             scene.setNeedsRepaint();</span>
<span class="line-removed">1355         }</span>
<span class="line-removed">1356 </span>
<span class="line-removed">1357         return wimg;</span>
1358     }
1359 
1360     /**
1361      * Implementation method for snapshot
1362      */
1363     private WritableImage doSnapshot(WritableImage img) {
1364         // TODO: no need to do CSS, layout or sync in the deferred case,
1365         // if this scene is attached to a visible stage
1366         doCSSLayoutSyncForSnapshot(getRoot());
1367 
1368         double w = getWidth();
1369         double h = getHeight();
1370         BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;
1371 
1372         return doSnapshot(this, 0, 0, w, h,
1373                 getRoot(), transform, isDepthBufferInternal(),
1374                 getFill(), getEffectiveCamera(), img);
1375     }
1376 
1377     // Pulse listener used to run all deferred (async) snapshot requests
</pre>
</td>
<td>
<hr />
<pre>
1264 
1265         getRoot().updateBounds();
1266         if (peer != null) {
1267             peer.waitForRenderingToComplete();
1268             peer.waitForSynchronization();
1269             try {
1270                 // Run the synchronizer while holding the render lock
1271                 scenePulseListener.synchronizeSceneNodes();
1272             } finally {
1273                 peer.releaseSynchronization(false);
1274             }
1275         } else {
1276             scenePulseListener.synchronizeSceneNodes();
1277         }
1278 
1279     }
1280 
1281     // Shared method for Scene.snapshot and Node.snapshot. It is static because
1282     // we might be doing a Node snapshot with a null scene
1283     static WritableImage doSnapshot(Scene scene,
<span class="line-modified">1284                                     double x, double y, double w, double h,</span>
<span class="line-modified">1285                                     Node root, BaseTransform transform, boolean depthBuffer,</span>
<span class="line-modified">1286                                     Paint fill, Camera camera, WritableImage wimg) {</span>
<span class="line-modified">1287 </span>
<span class="line-modified">1288         int xMin = (int) Math.floor(x);</span>
<span class="line-modified">1289         int yMin = (int) Math.floor(y);</span>
<span class="line-modified">1290         int xMax = (int) Math.ceil(x + w);</span>
<span class="line-modified">1291         int yMax = (int) Math.ceil(y + h);</span>



1292         int width = Math.max(xMax - xMin, 1);
1293         int height = Math.max(yMax - yMin, 1);
1294         if (wimg == null) {
1295             wimg = new WritableImage(width, height);
<span class="line-modified">1296         }</span>
<span class="line-modified">1297         else {</span>
<span class="line-modified">1298             width = (int) wimg.getWidth();</span>
<span class="line-added">1299             height = (int) wimg.getHeight();</span>
<span class="line-added">1300         }</span>
<span class="line-added">1301 </span>
<span class="line-added">1302         int maxTextureSize = PrismSettings.maxTextureSize;</span>
<span class="line-added">1303         if (height &gt; maxTextureSize || width &gt; maxTextureSize) {</span>
<span class="line-added">1304             // The requested size for the screenshot is to big to fit a single texture,</span>
<span class="line-added">1305             // so we need to take several snapshot tiles and merge them into single image (fixes JDK-8088198)</span>
<span class="line-added">1306             int verticalTileNb = (int) Math.ceil(height / (double) maxTextureSize);</span>
<span class="line-added">1307             int horizontalTileNb = (int) Math.ceil(width / (double) maxTextureSize);</span>
<span class="line-added">1308             for (int i = 0; i &lt; horizontalTileNb; i++) {</span>
<span class="line-added">1309                 for (int j = 0; j &lt; verticalTileNb; j++) {</span>
<span class="line-added">1310                     int xOffset = i * maxTextureSize;</span>
<span class="line-added">1311                     int yOffset = j * maxTextureSize;</span>
<span class="line-added">1312                     int tileWidth = Math.min(maxTextureSize, width - xOffset);</span>
<span class="line-added">1313                     int tileHeight = Math.min(maxTextureSize, height - yOffset);</span>
<span class="line-added">1314                     WritableImage tile = doSnapshotTile(scene, xMin + xOffset, yMin + yOffset, tileWidth, tileHeight, root, transform, depthBuffer, fill, camera, null);</span>
<span class="line-added">1315                     wimg.getPixelWriter().setPixels(xOffset, yOffset, tileWidth, tileHeight, tile.getPixelReader(), 0, 0);</span>
<span class="line-added">1316                 }</span>
<span class="line-added">1317             }</span>
<span class="line-added">1318         }</span>
<span class="line-added">1319         else {</span>
<span class="line-added">1320             // The requested size for the screenshot fits max texture size,</span>
<span class="line-added">1321             // so we can directly return the one generated tile and avoid the extra pixel copy.</span>
<span class="line-added">1322             wimg = doSnapshotTile(scene, xMin, yMin, width, height, root, transform, depthBuffer, fill, camera, wimg);</span>
<span class="line-added">1323         }</span>
<span class="line-added">1324 </span>
<span class="line-added">1325         // if this scene belongs to some stage</span>
<span class="line-added">1326         // we need to mark the entire scene as dirty</span>
<span class="line-added">1327         // because dirty logic is buggy</span>
<span class="line-added">1328         if (scene != null &amp;&amp; scene.peer != null) {</span>
<span class="line-added">1329             scene.setNeedsRepaint();</span>
1330         }
1331 
<span class="line-added">1332         return wimg;</span>
<span class="line-added">1333     }</span>
<span class="line-added">1334 </span>
<span class="line-added">1335     /**</span>
<span class="line-added">1336      * Capture a single snapshot tile</span>
<span class="line-added">1337      */</span>
<span class="line-added">1338     private static WritableImage doSnapshotTile(Scene scene,</span>
<span class="line-added">1339                                                 int x, int y, int w, int h,</span>
<span class="line-added">1340                                                 Node root, BaseTransform transform, boolean depthBuffer,</span>
<span class="line-added">1341                                                 Paint fill, Camera camera, WritableImage tileImg) {</span>
<span class="line-added">1342         Toolkit tk = Toolkit.getToolkit();</span>
<span class="line-added">1343         Toolkit.ImageRenderingContext context = new Toolkit.ImageRenderingContext();</span>
<span class="line-added">1344         if (tileImg == null) {</span>
<span class="line-added">1345             tileImg = new WritableImage(w, h);</span>
<span class="line-added">1346         }</span>
1347         setAllowPGAccess(true);
<span class="line-modified">1348         context.x = x;</span>
<span class="line-modified">1349         context.y = y;</span>
<span class="line-modified">1350         context.width = w;</span>
<span class="line-modified">1351         context.height = h;</span>
1352         context.transform = transform;
1353         context.depthBuffer = depthBuffer;
1354         context.root = root.getPeer();
1355         context.platformPaint = fill == null ? null : tk.getPaint(fill);
1356         double cameraViewWidth = 1.0;
1357         double cameraViewHeight = 1.0;
1358         if (camera != null) {
1359             // temporarily adjust camera viewport to the snapshot size
1360             cameraViewWidth = camera.getViewWidth();
1361             cameraViewHeight = camera.getViewHeight();
<span class="line-modified">1362             camera.setViewWidth(w);</span>
<span class="line-modified">1363             camera.setViewHeight(h);</span>
1364             NodeHelper.updatePeer(camera);
1365             context.camera = camera.getPeer();
1366         } else {
1367             context.camera = null;
1368         }
1369 
1370         // Grab the lights from the scene
1371         context.lights = null;
1372         if (scene != null &amp;&amp; !scene.lights.isEmpty()) {
1373             context.lights = new NGLightBase[scene.lights.size()];
1374             for (int i = 0; i &lt; scene.lights.size(); i++) {
1375                 context.lights[i] = scene.lights.get(i).getPeer();
1376             }
1377         }
1378 
1379         Toolkit.WritableImageAccessor accessor = Toolkit.getWritableImageAccessor();
<span class="line-modified">1380         context.platformImage = accessor.getTkImageLoader(tileImg);</span>
1381         setAllowPGAccess(false);
1382         Object tkImage = tk.renderToImage(context);
<span class="line-modified">1383         accessor.loadTkImage(tileImg, tkImage);</span>
1384 
1385         if (camera != null) {
1386             setAllowPGAccess(true);
1387             camera.setViewWidth(cameraViewWidth);
1388             camera.setViewHeight(cameraViewHeight);
1389             NodeHelper.updatePeer(camera);
1390             setAllowPGAccess(false);
1391         }
<span class="line-modified">1392         return tileImg;</span>








1393     }
1394 
1395     /**
1396      * Implementation method for snapshot
1397      */
1398     private WritableImage doSnapshot(WritableImage img) {
1399         // TODO: no need to do CSS, layout or sync in the deferred case,
1400         // if this scene is attached to a visible stage
1401         doCSSLayoutSyncForSnapshot(getRoot());
1402 
1403         double w = getWidth();
1404         double h = getHeight();
1405         BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;
1406 
1407         return doSnapshot(this, 0, 0, w, h,
1408                 getRoot(), transform, isDepthBufferInternal(),
1409                 getFill(), getEffectiveCamera(), img);
1410     }
1411 
1412     // Pulse listener used to run all deferred (async) snapshot requests
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>