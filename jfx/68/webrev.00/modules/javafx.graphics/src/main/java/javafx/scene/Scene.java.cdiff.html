<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.graphics/src/main/java/javafx/scene/Scene.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>modules/javafx.graphics/src/main/java/javafx/scene/Scene.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1279,47 ***</span>
      }
  
      // Shared method for Scene.snapshot and Node.snapshot. It is static because
      // we might be doing a Node snapshot with a null scene
      static WritableImage doSnapshot(Scene scene,
<span class="line-modified">!             double x, double y, double w, double h,</span>
<span class="line-modified">!             Node root, BaseTransform transform, boolean depthBuffer,</span>
<span class="line-modified">!             Paint fill, Camera camera, WritableImage wimg) {</span>
<span class="line-modified">! </span>
<span class="line-modified">!         Toolkit tk = Toolkit.getToolkit();</span>
<span class="line-modified">!         Toolkit.ImageRenderingContext context = new Toolkit.ImageRenderingContext();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         int xMin = (int)Math.floor(x);</span>
<span class="line-removed">-         int yMin = (int)Math.floor(y);</span>
<span class="line-removed">-         int xMax = (int)Math.ceil(x + w);</span>
<span class="line-removed">-         int yMax = (int)Math.ceil(y + h);</span>
          int width = Math.max(xMax - xMin, 1);
          int height = Math.max(yMax - yMin, 1);
          if (wimg == null) {
              wimg = new WritableImage(width, height);
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             width = (int)wimg.getWidth();</span>
<span class="line-modified">!             height = (int)wimg.getHeight();</span>
          }
  
          setAllowPGAccess(true);
<span class="line-modified">!         context.x = xMin;</span>
<span class="line-modified">!         context.y = yMin;</span>
<span class="line-modified">!         context.width = width;</span>
<span class="line-modified">!         context.height = height;</span>
          context.transform = transform;
          context.depthBuffer = depthBuffer;
          context.root = root.getPeer();
          context.platformPaint = fill == null ? null : tk.getPaint(fill);
          double cameraViewWidth = 1.0;
          double cameraViewHeight = 1.0;
          if (camera != null) {
              // temporarily adjust camera viewport to the snapshot size
              cameraViewWidth = camera.getViewWidth();
              cameraViewHeight = camera.getViewHeight();
<span class="line-modified">!             camera.setViewWidth(width);</span>
<span class="line-modified">!             camera.setViewHeight(height);</span>
              NodeHelper.updatePeer(camera);
              context.camera = camera.getPeer();
          } else {
              context.camera = null;
          }
<span class="line-new-header">--- 1279,90 ---</span>
      }
  
      // Shared method for Scene.snapshot and Node.snapshot. It is static because
      // we might be doing a Node snapshot with a null scene
      static WritableImage doSnapshot(Scene scene,
<span class="line-modified">!                                     double x, double y, double w, double h,</span>
<span class="line-modified">!                                     Node root, BaseTransform transform, boolean depthBuffer,</span>
<span class="line-modified">!                                     Paint fill, Camera camera, WritableImage wimg) {</span>
<span class="line-modified">! </span>
<span class="line-modified">!         int xMin = (int) Math.floor(x);</span>
<span class="line-modified">!         int yMin = (int) Math.floor(y);</span>
<span class="line-modified">!         int xMax = (int) Math.ceil(x + w);</span>
<span class="line-modified">!         int yMax = (int) Math.ceil(y + h);</span>
          int width = Math.max(xMax - xMin, 1);
          int height = Math.max(yMax - yMin, 1);
          if (wimg == null) {
              wimg = new WritableImage(width, height);
<span class="line-modified">!         }</span>
<span class="line-modified">!         else {</span>
<span class="line-modified">!             width = (int) wimg.getWidth();</span>
<span class="line-added">+             height = (int) wimg.getHeight();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         int maxTextureSize = PrismSettings.maxTextureSize;</span>
<span class="line-added">+         if (height &gt; maxTextureSize || width &gt; maxTextureSize) {</span>
<span class="line-added">+             // The requested size for the screenshot is to big to fit a single texture,</span>
<span class="line-added">+             // so we need to take several snapshot tiles and merge them into single image (fixes JDK-8088198)</span>
<span class="line-added">+             int verticalTileNb = (int) Math.ceil(height / (double) maxTextureSize);</span>
<span class="line-added">+             int horizontalTileNb = (int) Math.ceil(width / (double) maxTextureSize);</span>
<span class="line-added">+             for (int i = 0; i &lt; horizontalTileNb; i++) {</span>
<span class="line-added">+                 for (int j = 0; j &lt; verticalTileNb; j++) {</span>
<span class="line-added">+                     int xOffset = i * maxTextureSize;</span>
<span class="line-added">+                     int yOffset = j * maxTextureSize;</span>
<span class="line-added">+                     int tileWidth = Math.min(maxTextureSize, width - xOffset);</span>
<span class="line-added">+                     int tileHeight = Math.min(maxTextureSize, height - yOffset);</span>
<span class="line-added">+                     WritableImage tile = doSnapshotTile(scene, xMin + xOffset, yMin + yOffset, tileWidth, tileHeight, root, transform, depthBuffer, fill, camera, null);</span>
<span class="line-added">+                     wimg.getPixelWriter().setPixels(xOffset, yOffset, tileWidth, tileHeight, tile.getPixelReader(), 0, 0);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             // The requested size for the screenshot fits max texture size,</span>
<span class="line-added">+             // so we can directly return the one generated tile and avoid the extra pixel copy.</span>
<span class="line-added">+             wimg = doSnapshotTile(scene, xMin, yMin, width, height, root, transform, depthBuffer, fill, camera, wimg);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // if this scene belongs to some stage</span>
<span class="line-added">+         // we need to mark the entire scene as dirty</span>
<span class="line-added">+         // because dirty logic is buggy</span>
<span class="line-added">+         if (scene != null &amp;&amp; scene.peer != null) {</span>
<span class="line-added">+             scene.setNeedsRepaint();</span>
          }
  
<span class="line-added">+         return wimg;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Capture a single snapshot tile</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static WritableImage doSnapshotTile(Scene scene,</span>
<span class="line-added">+                                                 int x, int y, int w, int h,</span>
<span class="line-added">+                                                 Node root, BaseTransform transform, boolean depthBuffer,</span>
<span class="line-added">+                                                 Paint fill, Camera camera, WritableImage tileImg) {</span>
<span class="line-added">+         Toolkit tk = Toolkit.getToolkit();</span>
<span class="line-added">+         Toolkit.ImageRenderingContext context = new Toolkit.ImageRenderingContext();</span>
<span class="line-added">+         if (tileImg == null) {</span>
<span class="line-added">+             tileImg = new WritableImage(w, h);</span>
<span class="line-added">+         }</span>
          setAllowPGAccess(true);
<span class="line-modified">!         context.x = x;</span>
<span class="line-modified">!         context.y = y;</span>
<span class="line-modified">!         context.width = w;</span>
<span class="line-modified">!         context.height = h;</span>
          context.transform = transform;
          context.depthBuffer = depthBuffer;
          context.root = root.getPeer();
          context.platformPaint = fill == null ? null : tk.getPaint(fill);
          double cameraViewWidth = 1.0;
          double cameraViewHeight = 1.0;
          if (camera != null) {
              // temporarily adjust camera viewport to the snapshot size
              cameraViewWidth = camera.getViewWidth();
              cameraViewHeight = camera.getViewHeight();
<span class="line-modified">!             camera.setViewWidth(w);</span>
<span class="line-modified">!             camera.setViewHeight(h);</span>
              NodeHelper.updatePeer(camera);
              context.camera = camera.getPeer();
          } else {
              context.camera = null;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1332,31 ***</span>
                  context.lights[i] = scene.lights.get(i).getPeer();
              }
          }
  
          Toolkit.WritableImageAccessor accessor = Toolkit.getWritableImageAccessor();
<span class="line-modified">!         context.platformImage = accessor.getTkImageLoader(wimg);</span>
          setAllowPGAccess(false);
          Object tkImage = tk.renderToImage(context);
<span class="line-modified">!         accessor.loadTkImage(wimg, tkImage);</span>
  
          if (camera != null) {
              setAllowPGAccess(true);
              camera.setViewWidth(cameraViewWidth);
              camera.setViewHeight(cameraViewHeight);
              NodeHelper.updatePeer(camera);
              setAllowPGAccess(false);
          }
<span class="line-modified">! </span>
<span class="line-removed">-         // if this scene belongs to some stage</span>
<span class="line-removed">-         // we need to mark the entire scene as dirty</span>
<span class="line-removed">-         // because dirty logic is buggy</span>
<span class="line-removed">-         if (scene != null &amp;&amp; scene.peer != null) {</span>
<span class="line-removed">-             scene.setNeedsRepaint();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return wimg;</span>
      }
  
      /**
       * Implementation method for snapshot
       */
<span class="line-new-header">--- 1375,23 ---</span>
                  context.lights[i] = scene.lights.get(i).getPeer();
              }
          }
  
          Toolkit.WritableImageAccessor accessor = Toolkit.getWritableImageAccessor();
<span class="line-modified">!         context.platformImage = accessor.getTkImageLoader(tileImg);</span>
          setAllowPGAccess(false);
          Object tkImage = tk.renderToImage(context);
<span class="line-modified">!         accessor.loadTkImage(tileImg, tkImage);</span>
  
          if (camera != null) {
              setAllowPGAccess(true);
              camera.setViewWidth(cameraViewWidth);
              camera.setViewHeight(cameraViewHeight);
              NodeHelper.updatePeer(camera);
              setAllowPGAccess(false);
          }
<span class="line-modified">!         return tileImg;</span>
      }
  
      /**
       * Implementation method for snapshot
       */
</pre>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>