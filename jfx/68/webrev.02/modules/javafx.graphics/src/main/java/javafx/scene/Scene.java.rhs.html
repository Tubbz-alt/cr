<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/javafx/scene/Scene.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene;
  27 
  28 import com.sun.glass.ui.Application;
  29 import com.sun.glass.ui.Accessible;
  30 import com.sun.javafx.util.Logging;
  31 import com.sun.javafx.util.Utils;
  32 import com.sun.javafx.application.PlatformImpl;
  33 import com.sun.javafx.collections.TrackableObservableList;
  34 import com.sun.javafx.css.StyleManager;
  35 import com.sun.javafx.cursor.CursorFrame;
  36 import com.sun.javafx.event.EventQueue;
  37 import com.sun.javafx.geom.PickRay;
  38 import com.sun.javafx.geom.Vec3d;
  39 import com.sun.javafx.geom.transform.BaseTransform;
  40 import com.sun.javafx.perf.PerformanceTracker;
  41 import com.sun.javafx.scene.CssFlags;
  42 import com.sun.javafx.scene.LayoutFlags;
  43 import com.sun.javafx.scene.SceneEventDispatcher;
  44 import com.sun.javafx.scene.SceneHelper;
  45 import com.sun.javafx.scene.input.DragboardHelper;
  46 import com.sun.javafx.scene.input.ExtendedInputMethodRequests;
  47 import com.sun.javafx.scene.input.InputEventUtils;
  48 import com.sun.javafx.scene.input.PickResultChooser;
  49 import com.sun.javafx.scene.traversal.Direction;
  50 import com.sun.javafx.scene.traversal.SceneTraversalEngine;
  51 import com.sun.javafx.scene.traversal.TopMostTraversalEngine;
  52 import com.sun.javafx.sg.prism.NGCamera;
  53 import com.sun.javafx.sg.prism.NGLightBase;
  54 import com.sun.javafx.tk.*;
  55 import com.sun.prism.impl.PrismSettings;
  56 
  57 import javafx.animation.KeyFrame;
  58 import javafx.animation.Timeline;
  59 import javafx.application.ConditionalFeature;
  60 import javafx.application.Platform;
  61 import javafx.beans.DefaultProperty;
  62 import javafx.beans.InvalidationListener;
  63 import javafx.beans.NamedArg;
  64 import javafx.beans.property.*;
  65 import javafx.collections.FXCollections;
  66 import javafx.collections.ListChangeListener.Change;
  67 import javafx.collections.ObservableList;
  68 import javafx.collections.ObservableMap;
  69 import javafx.css.CssMetaData;
  70 import javafx.css.StyleableObjectProperty;
  71 import javafx.event.*;
  72 import javafx.geometry.*;
  73 import javafx.scene.image.WritableImage;
  74 import javafx.scene.input.*;
  75 import javafx.scene.paint.Color;
  76 import javafx.scene.paint.Paint;
  77 import javafx.stage.PopupWindow;
  78 import javafx.stage.Stage;
  79 import javafx.stage.StageStyle;
  80 import javafx.stage.Window;
  81 import javafx.util.Callback;
  82 import javafx.util.Duration;
  83 import com.sun.javafx.logging.PlatformLogger;
  84 import com.sun.javafx.logging.PlatformLogger.Level;
  85 
  86 import java.security.AccessControlContext;
  87 import java.security.AccessController;
  88 import java.security.PrivilegedAction;
  89 import java.util.*;
  90 import java.util.concurrent.CopyOnWriteArrayList;
  91 
  92 import com.sun.javafx.logging.PulseLogger;
  93 
  94 import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;
  95 import com.sun.javafx.scene.NodeHelper;
  96 import com.sun.javafx.stage.WindowHelper;
  97 import com.sun.javafx.scene.input.ClipboardHelper;
  98 import com.sun.javafx.scene.input.TouchPointHelper;
  99 import java.lang.ref.WeakReference;
 100 
 101 /**
 102  * The JavaFX {@code Scene} class is the container for all content in a scene graph.
 103  * The background of the scene is filled as specified by the {@code fill} property.
 104  * &lt;p&gt;
 105  * The application must specify the root {@code Node} for the scene graph by setting
 106  * the {@code root} property.   If a {@code Group} is used as the root, the
 107  * contents of the scene graph will be clipped by the scene&#39;s width and height and
 108  * changes to the scene&#39;s size (if user resizes the stage) will not alter the
 109  * layout of the scene graph. If a resizable node (layout {@code Region} or
 110  * {@code Control}) is set as the root, then the root&#39;s size will track the
 111  * scene&#39;s size, causing the contents to be relayed out as necessary.
 112  * &lt;p&gt;
 113  * The scene&#39;s size may be initialized by the application during construction.
 114  * If no size is specified, the scene will automatically compute its initial
 115  * size based on the preferred size of its content. If only one dimension is specified,
 116  * the other dimension is computed using the specified dimension, respecting content bias
 117  * of a root.
 118  * &lt;p&gt;
 119  * An application may request depth buffer support or scene anti-aliasing
 120  * support at the creation of a {@code Scene}. A scene with only 2D shapes and
 121  * without any 3D transforms does not need a depth buffer nor scene
 122  * anti-aliasing support. A scene containing 3D shapes or 2D shapes with 3D
 123  * transforms may use depth buffer support for proper depth sorted rendering; to
 124  * avoid depth fighting (also known as Z fighting), disable depth testing on 2D
 125  * shapes that have no 3D transforms. See
 126  * {@link Node#depthTestProperty() depthTest} for more information. A scene with
 127  * 3D shapes may enable scene anti-aliasing to improve its rendering quality.
 128  * &lt;p&gt;
 129  * The depthBuffer and antiAliasing flags are conditional features. With the
 130  * respective default values of: false and {@code SceneAntialiasing.DISABLED}.
 131  * See {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 132  * for more information.
 133  * &lt;p&gt;
 134  * A default headlight will be added to a scene that contains one or more
 135  * {@code Shape3D} nodes, but no light nodes. This light source is a
 136  * {@code Color.WHITE} {@code PointLight} placed at the camera position.
 137  *
 138  * &lt;p&gt;
 139  * A {@code Scene} may be created and modified on any thread until it is attached
 140  * to a {@link Window} that is {@link Window#isShowing() showing}.
 141  * After that, it must be modified only on the JavaFX Application Thread.
 142  * Note that {@code Scene} is not thread-safe; modifying a {@code Scene} on
 143  * multiple threads at the same time will lead to unpredictable results and
 144  * must be avoided.
 145  * &lt;/p&gt;
 146  *
 147  * &lt;p&gt;
 148  * The JavaFX Application Thread is created as part of the startup process for
 149  * the JavaFX runtime. See the {@link javafx.application.Application} class and
 150  * the {@link Platform#startup(Runnable)} method for more information.
 151  * &lt;/p&gt;
 152  *
 153  * &lt;p&gt;Example:&lt;/p&gt;
 154  *
 155  * &lt;pre&gt;
 156 import javafx.scene.*;
 157 import javafx.scene.paint.*;
 158 import javafx.scene.shape.*;
 159 
 160 Group root = new Group();
 161 Scene s = new Scene(root, 300, 300, Color.BLACK);
 162 
 163 Rectangle r = new Rectangle(25,25,250,250);
 164 r.setFill(Color.BLUE);
 165 
 166 root.getChildren().add(r);
 167  * &lt;/pre&gt;
 168  *
 169  * @since JavaFX 2.0
 170  */
 171 @DefaultProperty(&quot;root&quot;)
 172 public class Scene implements EventTarget {
 173 
 174     private double widthSetByUser = -1.0;
 175     private double heightSetByUser = -1.0;
 176     private boolean sizeInitialized = false;
 177     private final boolean depthBuffer;
 178     private final SceneAntialiasing antiAliasing;
 179 
 180     private EnumSet&lt;DirtyBits&gt; dirtyBits = EnumSet.noneOf(DirtyBits.class);
 181 
 182     final AccessControlContext acc = AccessController.getContext();
 183 
 184     private Camera defaultCamera;
 185 
 186     /**
 187      * A node that is temporarily responsible for the FOCUS_NODE
 188      * accessibility attribute. E.g. a currently active MenuBar.
 189      */
 190     private Node transientFocusContainer;
 191 
 192     //Neither width nor height are initialized and will be calculated according to content when this Scene
 193     //is shown for the first time.
 194 //    public Scene() {
 195 //        //this(-1, -1, (Parent) new Group());
 196 //        this(-1, -1, (Parent)null);
 197 //    }
 198 
 199     /**
 200      * Creates a Scene for a specific root Node.
 201      *
 202      * @param root The root node of the scene graph
 203      *
 204      * @throws NullPointerException if root is null
 205      */
 206     public Scene(@NamedArg(&quot;root&quot;) Parent root) {
 207         this(root, -1, -1, Color.WHITE, false, SceneAntialiasing.DISABLED);
 208     }
 209 
 210 //Public constructor initializing public-init properties
 211 //When width &lt; 0, and or height &lt; 0 is passed, then width and/or height are understood as unitialized
 212 //Unitialized dimension is calculated when Scene is shown for the first time.
 213 //    public Scene(
 214 //            @Default(&quot;-1&quot;) double width,
 215 //            @Default(&quot;-1&quot;) double height) {
 216 //        //this(width, height, (Parent)new Group());
 217 //        this(width, height, (Parent)null);
 218 //    }
 219 //
 220 //    public Scene(double width, double height, Paint fill) {
 221 //        //this(width, height, (Parent) new Group());
 222 //        this(width, height, (Parent)null);
 223 //        setFill(fill);
 224 //    }
 225 
 226     /**
 227      * Creates a Scene for a specific root Node with a specific size.
 228      *
 229      * @param root The root node of the scene graph
 230      * @param width The width of the scene
 231      * @param height The height of the scene
 232      *
 233      * @throws NullPointerException if root is null
 234      */
 235     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height) {
 236         this(root, width, height, Color.WHITE, false, SceneAntialiasing.DISABLED);
 237     }
 238 
 239     /**
 240      * Creates a Scene for a specific root Node with a fill.
 241      *
 242      * @param root The parent
 243      * @param fill The fill
 244      *
 245      * @throws NullPointerException if root is null
 246      */
 247     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
 248         this(root, -1, -1, fill, false, SceneAntialiasing.DISABLED);
 249     }
 250 
 251     /**
 252      * Creates a Scene for a specific root Node with a specific size and fill.
 253      *
 254      * @param root The root node of the scene graph
 255      * @param width The width of the scene
 256      * @param height The height of the scene
 257      * @param fill The fill
 258      *
 259      * @throws NullPointerException if root is null
 260      */
 261     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height,
 262             @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
 263         this(root, width, height, fill, false, SceneAntialiasing.DISABLED);
 264     }
 265 
 266     /**
 267      * Constructs a scene consisting of a root, with a dimension of width and
 268      * height, and specifies whether a depth buffer is created for this scene.
 269      * &lt;p&gt;
 270      * A scene with only 2D shapes and without any 3D transforms does not need a
 271      * depth buffer. A scene containing 3D shapes or 2D shapes with 3D
 272      * transforms may use depth buffer support for proper depth sorted
 273      * rendering; to avoid depth fighting (also known as Z fighting), disable
 274      * depth testing on 2D shapes that have no 3D transforms. See
 275      * {@link Node#depthTestProperty() depthTest} for more information.
 276      *
 277      * @param root The root node of the scene graph
 278      * @param width The width of the scene
 279      * @param height The height of the scene
 280      * @param depthBuffer The depth buffer flag
 281      * &lt;p&gt;
 282      * The depthBuffer flag is a conditional feature and its default value is
 283      * false. See
 284      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 285      * for more information.
 286      *
 287      * @throws NullPointerException if root is null
 288      *
 289      * @see javafx.scene.Node#setDepthTest(DepthTest)
 290      */
 291     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height, @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer) {
 292         this(root, width, height, Color.WHITE, depthBuffer, SceneAntialiasing.DISABLED);
 293     }
 294 
 295     /**
 296      * Constructs a scene consisting of a root, with a dimension of width and
 297      * height, specifies whether a depth buffer is created for this scene and
 298      * specifies whether scene anti-aliasing is requested.
 299      * &lt;p&gt;
 300      * A scene with only 2D shapes and without any 3D transforms does not need a
 301      * depth buffer nor scene anti-aliasing support. A scene containing 3D
 302      * shapes or 2D shapes with 3D transforms may use depth buffer support for
 303      * proper depth sorted rendering; to avoid depth fighting (also known as Z
 304      * fighting), disable depth testing on 2D shapes that have no 3D transforms.
 305      * See {@link Node#depthTestProperty() depthTest} for more information. A
 306      * scene with 3D shapes may enable scene anti-aliasing to improve its
 307      * rendering quality.
 308      *
 309      * @param root The root node of the scene graph
 310      * @param width The width of the scene
 311      * @param height The height of the scene
 312      * @param depthBuffer The depth buffer flag
 313      * @param antiAliasing The scene anti-aliasing attribute. A value of
 314      * {@code null} is treated as DISABLED.
 315      * &lt;p&gt;
 316      * The depthBuffer and antiAliasing are conditional features. With the
 317      * respective default values of: false and {@code SceneAntialiasing.DISABLED}. See
 318      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 319      * for more information.
 320      *
 321      * @throws NullPointerException if root is null
 322      *
 323      * @see javafx.scene.Node#setDepthTest(DepthTest)
 324      * @since JavaFX 8.0
 325      */
 326     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height,
 327             @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer,
 328             @NamedArg(value=&quot;antiAliasing&quot;, defaultValue=&quot;DISABLED&quot;) SceneAntialiasing antiAliasing) {
 329         this(root, width, height, Color.WHITE, depthBuffer, antiAliasing);
 330 
 331         if (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED &amp;&amp;
 332                 !Toolkit.getToolkit().isMSAASupported())
 333         {
 334             String logname = Scene.class.getName();
 335             PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;
 336                 + &quot;antiAliasing&quot;);
 337         }
 338     }
 339 
 340     private Scene(Parent root, double width, double height, Paint fill,
 341             boolean depthBuffer, SceneAntialiasing antiAliasing) {
 342         this.depthBuffer = depthBuffer;
 343         this.antiAliasing = antiAliasing;
 344         if (root == null) {
 345             throw new NullPointerException(&quot;Root cannot be null&quot;);
 346         }
 347 
 348         if ((depthBuffer || (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED))
 349                 &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
 350             String logname = Scene.class.getName();
 351             PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;
 352                     + &quot;ConditionalFeature.SCENE3D&quot;);
 353         }
 354 
 355         init();
 356         setRoot(root);
 357         init(width, height);
 358         setFill(fill);
 359     }
 360 
 361     static {
 362             PerformanceTracker.setSceneAccessor(new PerformanceTracker.SceneAccessor() {
 363                 public void setPerfTracker(Scene scene, PerformanceTracker tracker) {
 364                     synchronized (trackerMonitor) {
 365                         scene.tracker = tracker;
 366                     }
 367                 }
 368                 public PerformanceTracker getPerfTracker(Scene scene) {
 369                     synchronized (trackerMonitor) {
 370                         return scene.tracker;
 371                     }
 372                 }
 373             });
 374             SceneHelper.setSceneAccessor(
 375                     new SceneHelper.SceneAccessor() {
 376                         @Override
 377                         public void enableInputMethodEvents(Scene scene, boolean enable) {
 378                             scene.enableInputMethodEvents(enable);
 379                         }
 380 
 381                         @Override
 382                         public void processKeyEvent(Scene scene, KeyEvent e) {
 383                             scene.processKeyEvent(e);
 384                         }
 385 
 386                         @Override
 387                         public void processMouseEvent(Scene scene, MouseEvent e) {
 388                             scene.processMouseEvent(e);
 389                         }
 390 
 391                         @Override
 392                         public void preferredSize(Scene scene) {
 393                             scene.preferredSize();
 394                         }
 395 
 396                         @Override
 397                         public void disposePeer(Scene scene) {
 398                             scene.disposePeer();
 399                         }
 400 
 401                         @Override
 402                         public void initPeer(Scene scene) {
 403                             scene.initPeer();
 404                         }
 405 
 406                         @Override
 407                         public void setWindow(Scene scene, Window window) {
 408                             scene.setWindow(window);
 409                         }
 410 
 411                         @Override
 412                         public TKScene getPeer(Scene scene) {
 413                             return scene.getPeer();
 414                         }
 415 
 416                         @Override
 417                         public void setAllowPGAccess(boolean flag) {
 418                             Scene.setAllowPGAccess(flag);
 419                         }
 420 
 421                         @Override
 422                         public void parentEffectiveOrientationInvalidated(
 423                                 final Scene scene) {
 424                             scene.parentEffectiveOrientationInvalidated();
 425                         }
 426 
 427                         @Override
 428                         public Camera getEffectiveCamera(Scene scene) {
 429                             return scene.getEffectiveCamera();
 430                         }
 431 
 432                         @Override
 433                         public Scene createPopupScene(Parent root) {
 434                             return new Scene(root) {
 435                                        @Override
 436                                        void doLayoutPass() {
 437                                            resizeRootToPreferredSize(getRoot());
 438                                            super.doLayoutPass();
 439                                        }
 440 
 441                                        @Override
 442                                        void resizeRootOnSceneSizeChange(
 443                                                double newWidth,
 444                                                double newHeight) {
 445                                            // don&#39;t resize
 446                                        }
 447                                    };
 448                         }
 449 
 450                         @Override
 451                         public void setTransientFocusContainer(Scene scene, Node node) {
 452                             if (scene != null) {
 453                                 scene.transientFocusContainer = node;
 454                             }
 455                         }
 456 
 457                         @Override
 458                         public Accessible getAccessible(Scene scene) {
 459                             return scene.getAccessible();
 460                         }
 461                     });
 462         }
 463 
 464         // Reserve space for 30 nodes in the dirtyNodes set.
 465         private static final int MIN_DIRTY_CAPACITY = 30;
 466 
 467         // For debugging
 468         private static boolean inSynchronizer = false;
 469         private static boolean inMousePick = false;
 470         private static boolean allowPGAccess = false;
 471         private static int pgAccessCount = 0;
 472 
 473         /**
 474          * Used for debugging purposes. Returns true if we are in either the
 475          * mouse event code (picking) or the synchronizer, or if the scene is
 476          * not yet initialized,
 477          *
 478          */
 479         static boolean isPGAccessAllowed() {
 480             return inSynchronizer || inMousePick || allowPGAccess;
 481         }
 482 
 483         static void setAllowPGAccess(boolean flag) {
 484             if (Utils.assertionEnabled()) {
 485                 if (flag) {
 486                     pgAccessCount++;
 487                     allowPGAccess = true;
 488                 }
 489                 else {
 490                     if (pgAccessCount &lt;= 0) {
 491                         throw new java.lang.AssertionError(&quot;*** pgAccessCount underflow&quot;);
 492                     }
 493                     if (--pgAccessCount == 0) {
 494                         allowPGAccess = false;
 495                     }
 496                 }
 497             }
 498         }
 499 
 500         /**
 501          * If true, use the platform&#39;s drag gesture detection
 502          * else use Scene-level detection as per DnDGesture.process(MouseEvent, List)
 503          */
 504         private static final boolean PLATFORM_DRAG_GESTURE_INITIATION = false;
 505 
 506     /**
 507      * Set of dirty nodes; processed once per frame by the synchronizer.
 508      * When a node&#39;s state changes such that it becomes &quot;dirty&quot; with respect
 509      * to the graphics stack and requires synchronization, then that node
 510      * is added to this list. Note that if state on the Node changes, but it
 511      * was already dirty, then the Node doesn&#39;t add itself again.
 512      * &lt;p&gt;
 513      * Because at initialization time every node in the scene graph is dirty,
 514      * we have a special state and special code path during initialization
 515      * that does not involve adding each node to the dirtyNodes list. When
 516      * dirtyNodes is null, that means this Scene has not yet been synchronized.
 517      * A good default size is then created for the dirtyNodes list.
 518      * &lt;p&gt;
 519      * We double-buffer the set so that we can add new nodes to the
 520      * set while processing the existing set. This avoids our having to
 521      * take a snapshot of the set (e.g., with toArray()) and reduces garbage.
 522      */
 523     private Node[] dirtyNodes;
 524     private int dirtyNodesSize;
 525 
 526     /**
 527      * Add the specified node to this scene&#39;s dirty list. Called by the
 528      * markDirty method in Node or when the Node&#39;s scene changes.
 529      */
 530     void addToDirtyList(Node n) {
 531         if (dirtyNodes == null || dirtyNodesSize == 0) {
 532             if (peer != null) {
 533                 Toolkit.getToolkit().requestNextPulse();
 534             }
 535         }
 536 
 537         if (dirtyNodes != null) {
 538             if (dirtyNodesSize == dirtyNodes.length) {
 539                 Node[] tmp = new Node[dirtyNodesSize + (dirtyNodesSize &gt;&gt; 1)];
 540                 System.arraycopy(dirtyNodes, 0, tmp, 0, dirtyNodesSize);
 541                 dirtyNodes = tmp;
 542             }
 543             dirtyNodes[dirtyNodesSize++] = n;
 544         }
 545     }
 546 
 547     private void doCSSPass() {
 548         final Parent sceneRoot = getRoot();
 549         //
 550         // RT-17547: when the tree is synchronized, the dirty bits are
 551         // are cleared but the cssFlag might still be something other than
 552         // clean.
 553         //
 554         // Before RT-17547, the code checked the dirty bit. But this is
 555         // superfluous since the dirty bit will be set if the flag is not clean,
 556         // but the flag will never be anything other than clean if the dirty
 557         // bit is not set. The dirty bit is still needed, however, since setting
 558         // it ensures a pulse if no other dirty bits have been set.
 559         //
 560         // For the purpose of showing the change, the dirty bit
 561         // check code was commented out and not removed.
 562         //
 563 //        if (sceneRoot.isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS)) {
 564         if (sceneRoot.cssFlag != CssFlags.CLEAN) {
 565             // The dirty bit isn&#39;t checked but we must ensure it is cleared.
 566             // The cssFlag is set to clean in either Node.processCSS or
 567             // NodeHelper.processCSS
 568             sceneRoot.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
 569             sceneRoot.processCSS();
 570         }
 571     }
 572 
 573     void doLayoutPass() {
 574         final Parent r = getRoot();
 575         if (r != null) {
 576             r.layout();
 577         }
 578     }
 579 
 580     /**
 581      * The peer of this scene
 582      */
 583     private TKScene peer;
 584 
 585     /*
 586      * Get Scene&#39;s peer
 587      */
 588     TKScene getPeer() {
 589         return peer;
 590     }
 591 
 592     /**
 593      * The scene pulse listener that gets called on toolkit pulses
 594      */
 595     ScenePulseListener scenePulseListener = new ScenePulseListener();
 596 
 597     private List&lt;Runnable&gt; preLayoutPulseListeners;
 598     private List&lt;Runnable&gt; postLayoutPulseListeners;
 599 
 600     /**
 601      * Adds a new scene pre layout pulse listener to this scene. Every time a pulse occurs,
 602      * this listener will be called on the JavaFX Application Thread directly
 603      * &lt;strong&gt;before&lt;/strong&gt; the CSS and layout passes, and also before
 604      * any rendering is done for
 605      * this frame. This scene pulse listener is suitable for knowing when a
 606      * scenegraph pulse is happening and also for modifying the scenegraph
 607      * (as it is called before CSS and layout, so any changes made will be properly
 608      * styled and positioned).
 609      *
 610      * This method must be called on the JavaFX Application thread.
 611      *
 612      * @param r The Runnable to be called when the pulse occurs.
 613      *
 614      * @throws IllegalStateException if this method is called on a thread
 615      * other than the JavaFX Application Thread.
 616      *
 617      * @throws NullPointerException if the provided Runnable is null.
 618      *
 619      * @since 9
 620      */
 621     public final void addPreLayoutPulseListener(Runnable r) {
 622         Toolkit.getToolkit().checkFxUserThread();
 623 
 624         if (r == null) {
 625             throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
 626         }
 627         if (preLayoutPulseListeners == null) {
 628             preLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
 629         }
 630         preLayoutPulseListeners.add(r);
 631     }
 632 
 633     /**
 634      * Removes a previously registered scene pre layout pulse listener from listening to
 635      * pulses in this scene. This method does nothing if the specified Runnable is
 636      * not already in the list.
 637      *
 638      * This method must be called on the JavaFX Application thread.
 639      *
 640      * @param r The Runnable that should no longer be called when the pulse
 641      * occurs for this scene.
 642      *
 643      * @throws IllegalStateException if this method is called on a thread
 644      * other than the JavaFX Application Thread.
 645      *
 646      * @since 9
 647      */
 648     public final void removePreLayoutPulseListener(Runnable r) {
 649         Toolkit.getToolkit().checkFxUserThread();
 650 
 651         if (preLayoutPulseListeners == null) {
 652             return;
 653         }
 654         preLayoutPulseListeners.remove(r);
 655     }
 656 
 657     /**
 658      * Adds a new scene post layout pulse listener to this scene. Every time a pulse occurs,
 659      * this listener will be called on the JavaFX Application Thread directly
 660      * &lt;strong&gt;after&lt;/strong&gt; the CSS and layout passes, but before any rendering is done for
 661      * this frame. This scene pulse listener is suitable for knowing when a
 662      * scenegraph pulse is happening, but it is not suited to use cases related
 663      * to modifying the scenegraph (as it is called after CSS and layout, so
 664      * any changes will possibly be incorrect until the next pulse is run).
 665      * An alternative (and better) solution for situations where a scenegraph
 666      * modification is required to happen is to use either the
 667      * {@link #addPreLayoutPulseListener(Runnable)} API or the the
 668      * {@link javafx.animation.AnimationTimer} API.
 669      *
 670      * This method must be called on the JavaFX Application thread.
 671      *
 672      * @param r The Runnable to be called when the pulse occurs.
 673      *
 674      * @throws IllegalStateException if this method is called on a thread
 675      * other than the JavaFX Application Thread.
 676      *
 677      * @throws NullPointerException if the provided Runnable is null.
 678      *
 679      * @since 9
 680      */
 681     public final void addPostLayoutPulseListener(Runnable r) {
 682         Toolkit.getToolkit().checkFxUserThread();
 683 
 684         if (r == null) {
 685             throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
 686         }
 687         if (postLayoutPulseListeners == null) {
 688             postLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
 689         }
 690         postLayoutPulseListeners.add(r);
 691     }
 692 
 693     /**
 694      * Removes a previously registered scene post layout pulse listener from listening to
 695      * pulses in this scene. This method does nothing if the specified Runnable is
 696      * not already in the list.
 697      *
 698      * This method must be called on the JavaFX Application thread.
 699      *
 700      * @param r The Runnable that should no longer be called when the pulse
 701      * occurs for this scene.
 702      *
 703      * @throws IllegalStateException if this method is called on a thread
 704      * other than the JavaFX Application Thread.
 705      *
 706      * @since 9
 707      */
 708     public final void removePostLayoutPulseListener(Runnable r) {
 709         Toolkit.getToolkit().checkFxUserThread();
 710 
 711         if (postLayoutPulseListeners == null) {
 712             return;
 713         }
 714         postLayoutPulseListeners.remove(r);
 715     }
 716 
 717     /**
 718      * Return the defined {@code SceneAntialiasing} for this {@code Scene}.
 719      * &lt;p&gt;
 720      * Note: this is a conditional feature. See
 721      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 722      * and {@link javafx.scene.SceneAntialiasing SceneAntialiasing}
 723      * for more information.
 724      * @return the SceneAntialiasing for this scene
 725      * @since JavaFX 8.0
 726      */
 727     public final SceneAntialiasing getAntiAliasing() {
 728         return antiAliasing;
 729     }
 730 
 731     private boolean getAntiAliasingInternal() {
 732         return (antiAliasing != null &amp;&amp;
 733                 Toolkit.getToolkit().isMSAASupported() &amp;&amp;
 734                 Platform.isSupported(ConditionalFeature.SCENE3D)) ?
 735                 antiAliasing != SceneAntialiasing.DISABLED : false;
 736     }
 737 
 738     /**
 739      * The {@code Window} for this {@code Scene}
 740      */
 741     private ReadOnlyObjectWrapper&lt;Window&gt; window;
 742 
 743     void setWindow(Window value) {
 744         windowPropertyImpl().set(value);
 745     }
 746 
 747     public final Window getWindow() {
 748         return window == null ? null : window.get();
 749     }
 750 
 751     public final ReadOnlyObjectProperty&lt;Window&gt; windowProperty() {
 752         return windowPropertyImpl().getReadOnlyProperty();
 753     }
 754 
 755     private ReadOnlyObjectWrapper&lt;Window&gt; windowPropertyImpl() {
 756         if (window == null) {
 757             window = new ReadOnlyObjectWrapper&lt;Window&gt;() {
 758                 private Window oldWindow;
 759 
 760                 @Override protected void invalidated() {
 761                     final Window newWindow = get();
 762                     getKeyHandler().windowForSceneChanged(oldWindow, newWindow);
 763                     if (oldWindow != null) {
 764                         disposePeer();
 765                     }
 766                     if (newWindow != null) {
 767                         initPeer();
 768                     }
 769                     parentEffectiveOrientationInvalidated();
 770 
 771                     oldWindow = newWindow;
 772                 }
 773 
 774                 @Override
 775                 public Object getBean() {
 776                     return Scene.this;
 777                 }
 778 
 779                 @Override
 780                 public String getName() {
 781                     return &quot;window&quot;;
 782                 }
 783             };
 784         }
 785         return window;
 786     }
 787 
 788     void initPeer() {
 789         assert peer == null;
 790 
 791         Window window = getWindow();
 792         // initPeer() is only called from Window, either when the window
 793         // is being shown, or the window scene is being changed. In any case
 794         // this scene&#39;s window cannot be null.
 795         assert window != null;
 796 
 797         TKStage windowPeer = WindowHelper.getPeer(window);
 798         if (windowPeer == null) {
 799             // This is fine, the window is not visible. initPeer() will
 800             // be called again later, when the window is being shown.
 801             return;
 802         }
 803 
 804         final boolean isTransparentWindowsSupported = Platform.isSupported(ConditionalFeature.TRANSPARENT_WINDOW);
 805         if (!isTransparentWindowsSupported) {
 806             PlatformImpl.addNoTransparencyStylesheetToScene(this);
 807         }
 808 
 809         PerformanceTracker.logEvent(&quot;Scene.initPeer started&quot;);
 810 
 811         setAllowPGAccess(true);
 812 
 813         Toolkit tk = Toolkit.getToolkit();
 814         peer = windowPeer.createTKScene(isDepthBufferInternal(), getAntiAliasingInternal(), acc);
 815         PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene created&quot;);
 816         peer.setTKSceneListener(new ScenePeerListener());
 817         peer.setTKScenePaintListener(new ScenePeerPaintListener());
 818         PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene set&quot;);
 819         peer.setRoot(getRoot().getPeer());
 820         peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
 821         NodeHelper.updatePeer(getEffectiveCamera());
 822         peer.setCamera((NGCamera) getEffectiveCamera().getPeer());
 823         peer.markDirty();
 824         PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene initialized&quot;);
 825 
 826         setAllowPGAccess(false);
 827 
 828         tk.addSceneTkPulseListener(scenePulseListener);
 829         // listen to dnd gestures coming from the platform
 830         if (PLATFORM_DRAG_GESTURE_INITIATION) {
 831             if (dragGestureListener == null) {
 832                 dragGestureListener = new DragGestureListener();
 833             }
 834             tk.registerDragGestureListener(peer, EnumSet.allOf(TransferMode.class), dragGestureListener);
 835         }
 836         tk.enableDrop(peer, new DropTargetListener());
 837         tk.installInputMethodRequests(peer, new InputMethodRequestsDelegate());
 838 
 839         PerformanceTracker.logEvent(&quot;Scene.initPeer finished&quot;);
 840     }
 841 
 842     public void disposePeer() {
 843         if (peer == null) {
 844             // This is fine, the window is either not shown yet and there is no
 845             // need in disposing scene peer, or is hidden and disposePeer()
 846             // has already been called.
 847             return;
 848         }
 849 
 850         PerformanceTracker.logEvent(&quot;Scene.disposePeer started&quot;);
 851 
 852         Toolkit tk = Toolkit.getToolkit();
 853         tk.removeSceneTkPulseListener(scenePulseListener);
 854         if (accessible != null) {
 855             disposeAccessibles();
 856             Node root = getRoot();
 857             if (root != null) root.releaseAccessible();
 858             accessible.dispose();
 859             accessible = null;
 860         }
 861         peer.dispose();
 862         peer = null;
 863 
 864         PerformanceTracker.logEvent(&quot;Scene.disposePeer finished&quot;);
 865     }
 866 
 867     DnDGesture dndGesture = null;
 868     DragGestureListener dragGestureListener;
 869     /**
 870      * The horizontal location of this {@code Scene} on the {@code Window}.
 871      */
 872     private ReadOnlyDoubleWrapper x;
 873 
 874     private final void setX(double value) {
 875         xPropertyImpl().set(value);
 876     }
 877 
 878     public final double getX() {
 879         return x == null ? 0.0 : x.get();
 880     }
 881 
 882     public final ReadOnlyDoubleProperty xProperty() {
 883         return xPropertyImpl().getReadOnlyProperty();
 884     }
 885 
 886     private ReadOnlyDoubleWrapper xPropertyImpl() {
 887         if (x == null) {
 888             x = new ReadOnlyDoubleWrapper(this, &quot;x&quot;);
 889         }
 890         return x;
 891     }
 892 
 893     /**
 894      * The vertical location of this {@code Scene} on the {@code Window}.
 895      */
 896     private ReadOnlyDoubleWrapper y;
 897 
 898     private final void setY(double value) {
 899         yPropertyImpl().set(value);
 900     }
 901 
 902     public final double getY() {
 903         return y == null ? 0.0 : y.get();
 904     }
 905 
 906     public final ReadOnlyDoubleProperty yProperty() {
 907         return yPropertyImpl().getReadOnlyProperty();
 908     }
 909 
 910     private ReadOnlyDoubleWrapper yPropertyImpl() {
 911         if (y == null) {
 912             y = new ReadOnlyDoubleWrapper(this, &quot;y&quot;);
 913         }
 914         return y;
 915     }
 916 
 917     /**
 918      * The width of this {@code Scene}
 919      */
 920     private ReadOnlyDoubleWrapper width;
 921 
 922     private final void setWidth(double value) {
 923         widthPropertyImpl().set(value);
 924     }
 925 
 926     public final double getWidth() {
 927         return width == null ? 0.0 : width.get();
 928     }
 929 
 930     public final ReadOnlyDoubleProperty widthProperty() {
 931         return widthPropertyImpl().getReadOnlyProperty();
 932     }
 933 
 934     private ReadOnlyDoubleWrapper widthPropertyImpl() {
 935         if (width == null) {
 936             width = new ReadOnlyDoubleWrapper() {
 937 
 938                 @Override
 939                 protected void invalidated() {
 940                     final Parent _root = getRoot();
 941                     //TODO - use a better method to update mirroring
 942                     if (_root.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
 943                         NodeHelper.transformsChanged(_root);
 944                     }
 945                     if (_root.isResizable()) {
 946                         resizeRootOnSceneSizeChange(get() - _root.getLayoutX() - _root.getTranslateX(), _root.getLayoutBounds().getHeight());
 947                     }
 948 
 949                     getEffectiveCamera().setViewWidth(get());
 950                 }
 951 
 952                 @Override
 953                 public Object getBean() {
 954                     return Scene.this;
 955                 }
 956 
 957                 @Override
 958                 public String getName() {
 959                     return &quot;width&quot;;
 960                 }
 961             };
 962         }
 963         return width;
 964     }
 965 
 966     /**
 967      * The height of this {@code Scene}
 968      */
 969     private ReadOnlyDoubleWrapper height;
 970 
 971     private final void setHeight(double value) {
 972         heightPropertyImpl().set(value);
 973     }
 974 
 975     public final double getHeight() {
 976         return height == null ? 0.0 : height.get();
 977     }
 978 
 979     public final ReadOnlyDoubleProperty heightProperty() {
 980         return heightPropertyImpl().getReadOnlyProperty();
 981     }
 982 
 983     private ReadOnlyDoubleWrapper heightPropertyImpl() {
 984         if (height == null) {
 985             height = new ReadOnlyDoubleWrapper() {
 986 
 987                 @Override
 988                 protected void invalidated() {
 989                     final Parent _root = getRoot();
 990                     if (_root.isResizable()) {
 991                         resizeRootOnSceneSizeChange(_root.getLayoutBounds().getWidth(), get() - _root.getLayoutY() - _root.getTranslateY());
 992                     }
 993 
 994                     getEffectiveCamera().setViewHeight(get());
 995                 }
 996 
 997                 @Override
 998                 public Object getBean() {
 999                     return Scene.this;
1000                 }
1001 
1002                 @Override
1003                 public String getName() {
1004                     return &quot;height&quot;;
1005                 }
1006             };
1007         }
1008         return height;
1009     }
1010 
1011     void resizeRootOnSceneSizeChange(double newWidth, double newHeight) {
1012         getRoot().resize(newWidth, newHeight);
1013     }
1014 
1015     // Reusable target wrapper (to avoid creating new one for each picking)
1016     private TargetWrapper tmpTargetWrapper = new TargetWrapper();
1017 
1018     /**
1019      * Specifies the type of camera use for rendering this {@code Scene}.
1020      * If {@code camera} is null, a parallel camera is used for rendering.
1021      * It is illegal to set a camera that belongs to other {@code Scene}
1022      * or {@code SubScene}.
1023      * &lt;p&gt;
1024      * Note: this is a conditional feature. See
1025      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
1026      * for more information.
1027      *
1028      * @defaultValue null
1029      */
1030     private ObjectProperty&lt;Camera&gt; camera;
1031 
1032     public final void setCamera(Camera value) {
1033         cameraProperty().set(value);
1034     }
1035 
1036     public final Camera getCamera() {
1037         return camera == null ? null : camera.get();
1038     }
1039 
1040     public final ObjectProperty&lt;Camera&gt; cameraProperty() {
1041         if (camera == null) {
1042             camera = new ObjectPropertyBase&lt;Camera&gt;() {
1043                 Camera oldCamera = null;
1044 
1045                 @Override
1046                 protected void invalidated() {
1047                     Camera _value = get();
1048                     if (_value != null) {
1049                         if (_value instanceof PerspectiveCamera
1050                                 &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
1051                             String logname = Scene.class.getName();
1052                             PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;
1053                                     + &quot;ConditionalFeature.SCENE3D&quot;);
1054                         }
1055                         // Illegal value if it belongs to other scene or any subscene
1056                         if ((_value.getScene() != null &amp;&amp; _value.getScene() != Scene.this)
1057                                 || _value.getSubScene() != null) {
1058                             throw new IllegalArgumentException(_value
1059                                     + &quot;is already part of other scene or subscene&quot;);
1060                         }
1061                         // throws exception if the camera already has a different owner
1062                         _value.setOwnerScene(Scene.this);
1063                         _value.setViewWidth(getWidth());
1064                         _value.setViewHeight(getHeight());
1065                     }
1066                     if (oldCamera != null &amp;&amp; oldCamera != _value) {
1067                         oldCamera.setOwnerScene(null);
1068                     }
1069                     oldCamera = _value;
1070                 }
1071 
1072                 @Override
1073                 public Object getBean() {
1074                     return Scene.this;
1075                 }
1076 
1077                 @Override
1078                 public String getName() {
1079                     return &quot;camera&quot;;
1080                 }
1081             };
1082         }
1083         return camera;
1084     }
1085 
1086     Camera getEffectiveCamera() {
1087         final Camera cam = getCamera();
1088         if (cam == null
1089                 || (cam instanceof PerspectiveCamera
1090                 &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D))) {
1091             if (defaultCamera == null) {
1092                 defaultCamera = new ParallelCamera();
1093                 defaultCamera.setOwnerScene(this);
1094                 defaultCamera.setViewWidth(getWidth());
1095                 defaultCamera.setViewHeight(getHeight());
1096             }
1097             return defaultCamera;
1098         }
1099 
1100         return cam;
1101     }
1102 
1103     // Used by the camera
1104     void markCameraDirty() {
1105         markDirty(DirtyBits.CAMERA_DIRTY);
1106         setNeedsRepaint();
1107     }
1108 
1109     void markCursorDirty() {
1110         markDirty(DirtyBits.CURSOR_DIRTY);
1111     }
1112 
1113     /**
1114      * Defines the background fill of this {@code Scene}. Both a {@code null}
1115      * value meaning &#39;paint no background&#39; and a {@link javafx.scene.paint.Paint}
1116      * with transparency are supported. The default fill of the Scene is
1117      * {@link Color#WHITE}, but it is more commonly the case that the initial
1118      * color shown to users is the background fill of the
1119      * {@link #rootProperty() root node} of the {@code Scene}, as it typically is
1120      * stretched to take up all available space in the {@code Scene}. The
1121      * root node of the {@code Scene} is given the CSS style class &#39;root&#39;, and
1122      * the default user agent stylesheets that ship with JavaFX (presently
1123      * Caspian and Modena) apply styling on to this root style class. In the
1124      * case of Caspian this does not impact the background fill color of the
1125      * root node, but in the case of Modena the default fill is set to be a
1126      * light gray color.
1127      *
1128      * @defaultValue WHITE
1129      */
1130     private ObjectProperty&lt;Paint&gt; fill;
1131 
1132     public final void setFill(Paint value) {
1133         fillProperty().set(value);
1134     }
1135 
1136     public final Paint getFill() {
1137         return fill == null ? Color.WHITE : fill.get();
1138     }
1139 
1140     public final ObjectProperty&lt;Paint&gt; fillProperty() {
1141         if (fill == null) {
1142             fill = new ObjectPropertyBase&lt;Paint&gt;(Color.WHITE) {
1143 
1144                 @Override
1145                 protected void invalidated() {
1146                     markDirty(DirtyBits.FILL_DIRTY);
1147                 }
1148 
1149                 @Override
1150                 public Object getBean() {
1151                     return Scene.this;
1152                 }
1153 
1154                 @Override
1155                 public String getName() {
1156                     return &quot;fill&quot;;
1157                 }
1158             };
1159         }
1160         return fill;
1161     }
1162 
1163     /**
1164      * Defines the root {@code Node} of the scene graph.
1165      * If a {@code Group} is used as the root, the
1166      * contents of the scene graph will be clipped by the scene&#39;s width and height and
1167      * changes to the scene&#39;s size (if user resizes the stage) will not alter the
1168      * layout of the scene graph.    If a resizable node (layout {@code Region} or
1169      * {@code Control}) is set as the root, then the root&#39;s size will track the
1170      * scene&#39;s size, causing the contents to be relayed out as necessary.
1171      *
1172      * Scene doesn&#39;t accept null root.
1173      *
1174      */
1175     private ObjectProperty&lt;Parent&gt; root;
1176 
1177     public final void setRoot(Parent value) {
1178         rootProperty().set(value);
1179     }
1180 
1181     public final Parent getRoot() {
1182         return root == null ? null : root.get();
1183     }
1184 
1185     Parent oldRoot;
1186     public final ObjectProperty&lt;Parent&gt; rootProperty() {
1187         if (root == null) {
1188             root = new ObjectPropertyBase&lt;Parent&gt;() {
1189 
1190                 private void forceUnbind() {
1191                     System.err.println(&quot;Unbinding illegal root.&quot;);
1192                     unbind();
1193                 }
1194 
1195                 @Override
1196                 protected void invalidated() {
1197                     Parent _value = get();
1198 
1199                     if (_value == null) {
1200                         if (isBound()) forceUnbind();
1201                         throw new NullPointerException(&quot;Scene&#39;s root cannot be null&quot;);
1202                     }
1203 
1204                     if (_value.getParent() != null) {
1205                         if (isBound()) forceUnbind();
1206                         throw new IllegalArgumentException(_value +
1207                                 &quot;is already inside a scene-graph and cannot be set as root&quot;);
1208                     }
1209                     if (_value.getClipParent() != null) {
1210                         if (isBound()) forceUnbind();
1211                         throw new IllegalArgumentException(_value +
1212                                 &quot;is set as a clip on another node, so cannot be set as root&quot;);
1213                     }
1214                     if (_value.getScene() != null &amp;&amp; _value.getScene().getRoot() == _value &amp;&amp; _value.getScene() != Scene.this) {
1215                         if (isBound()) forceUnbind();
1216                         throw new IllegalArgumentException(_value +
1217                                 &quot;is already set as root of another scene&quot;);
1218                     }
1219 
1220                     if (oldRoot != null) {
1221                         oldRoot.setScenes(null, null);
1222                     }
1223                     oldRoot = _value;
1224                     _value.getStyleClass().add(0, &quot;root&quot;);
1225                     _value.setScenes(Scene.this, null);
1226                     markDirty(DirtyBits.ROOT_DIRTY);
1227                     _value.resize(getWidth(), getHeight()); // maybe no-op if root is not resizable
1228                     _value.requestLayout();
1229                 }
1230 
1231                 @Override
1232                 public Object getBean() {
1233                     return Scene.this;
1234                 }
1235 
1236                 @Override
1237                 public String getName() {
1238                     return &quot;root&quot;;
1239                 }
1240             };
1241         }
1242         return root;
1243     }
1244 
1245     void setNeedsRepaint() {
1246         if (this.peer != null) {
1247             peer.entireSceneNeedsRepaint();
1248         }
1249     }
1250 
1251     // Process CSS and layout and sync the scene prior to the snapshot
1252     // operation of the given node for this scene (currently the node
1253     // is unused but could possibly be used in the future to optimize this)
1254     void doCSSLayoutSyncForSnapshot(Node node) {
1255         if (!sizeInitialized) {
1256             preferredSize();
1257         } else {
1258             doCSSPass();
1259         }
1260 
1261         // we do not need pulse in the snapshot code
1262         // because this scene can be stage-less
1263         doLayoutPass();
1264 
1265         getRoot().updateBounds();
1266         if (peer != null) {
1267             peer.waitForRenderingToComplete();
1268             peer.waitForSynchronization();
1269             try {
1270                 // Run the synchronizer while holding the render lock
1271                 scenePulseListener.synchronizeSceneNodes();
1272             } finally {
1273                 peer.releaseSynchronization(false);
1274             }
1275         } else {
1276             scenePulseListener.synchronizeSceneNodes();
1277         }
1278 
1279     }
1280 
1281     // Shared method for Scene.snapshot and Node.snapshot. It is static because
1282     // we might be doing a Node snapshot with a null scene
1283     static WritableImage doSnapshot(Scene scene,
1284             double x, double y, double w, double h,
1285             Node root, BaseTransform transform, boolean depthBuffer,
1286             Paint fill, Camera camera, WritableImage wimg) {
1287 
<a name="1" id="anc1"></a>


1288         int xMin = (int)Math.floor(x);
1289         int yMin = (int)Math.floor(y);
1290         int xMax = (int)Math.ceil(x + w);
1291         int yMax = (int)Math.ceil(y + h);
1292         int width = Math.max(xMax - xMin, 1);
1293         int height = Math.max(yMax - yMin, 1);
1294         if (wimg == null) {
1295             wimg = new WritableImage(width, height);
1296         } else {
1297             width = (int)wimg.getWidth();
1298             height = (int)wimg.getHeight();
1299         }
1300 
<a name="2" id="anc2"></a><span class="line-added">1301         int maxTextureSize = PrismSettings.maxTextureSize;</span>
<span class="line-added">1302         if (height &gt; maxTextureSize || width &gt; maxTextureSize) {</span>
<span class="line-added">1303             // The requested size for the screenshot is too big to fit a single texture,</span>
<span class="line-added">1304             // so we need to take several snapshot tiles and merge them into single image (fixes JDK-8088198)</span>
<span class="line-added">1305             int numVerticalTiles = (int) Math.ceil(height / (double) maxTextureSize);</span>
<span class="line-added">1306             int numHorizontalTiles = (int) Math.ceil(width / (double) maxTextureSize);</span>
<span class="line-added">1307             for (int i = 0; i &lt; numHorizontalTiles; i++) {</span>
<span class="line-added">1308                 int xOffset = i * maxTextureSize;</span>
<span class="line-added">1309                 int tileWidth = Math.min(maxTextureSize, width - xOffset);</span>
<span class="line-added">1310                 for (int j = 0; j &lt; numVerticalTiles; j++) {</span>
<span class="line-added">1311                     int yOffset = j * maxTextureSize;</span>
<span class="line-added">1312                     int tileHeight = Math.min(maxTextureSize, height - yOffset);</span>
<span class="line-added">1313                     WritableImage tile = doSnapshotTile(scene, xMin + xOffset, yMin + yOffset, tileWidth, tileHeight, root, transform, depthBuffer, fill, camera, null);</span>
<span class="line-added">1314                     wimg.getPixelWriter().setPixels(xOffset, yOffset, tileWidth, tileHeight, tile.getPixelReader(), 0, 0);</span>
<span class="line-added">1315                 }</span>
<span class="line-added">1316             }</span>
<span class="line-added">1317         } else {</span>
<span class="line-added">1318             // The requested size for the screenshot fits max texture size,</span>
<span class="line-added">1319             // so we can directly return the one generated tile and avoid the extra pixel copy.</span>
<span class="line-added">1320             wimg = doSnapshotTile(scene, xMin, yMin, width, height, root, transform, depthBuffer, fill, camera, wimg);</span>
<span class="line-added">1321         }</span>
<span class="line-added">1322 </span>
<span class="line-added">1323         // if this scene belongs to some stage</span>
<span class="line-added">1324         // we need to mark the entire scene as dirty</span>
<span class="line-added">1325         // because dirty logic is buggy</span>
<span class="line-added">1326         if (scene != null &amp;&amp; scene.peer != null) {</span>
<span class="line-added">1327             scene.setNeedsRepaint();</span>
<span class="line-added">1328         }</span>
<span class="line-added">1329 </span>
<span class="line-added">1330         return wimg;</span>
<span class="line-added">1331     }</span>
<span class="line-added">1332 </span>
<span class="line-added">1333     /**</span>
<span class="line-added">1334      * Capture a single snapshot tile</span>
<span class="line-added">1335      */</span>
<span class="line-added">1336     private static WritableImage doSnapshotTile(Scene scene,</span>
<span class="line-added">1337                     int x, int y, int w, int h,</span>
<span class="line-added">1338                     Node root, BaseTransform transform, boolean depthBuffer,</span>
<span class="line-added">1339                     Paint fill, Camera camera, WritableImage tileImg) {</span>
<span class="line-added">1340         Toolkit tk = Toolkit.getToolkit();</span>
<span class="line-added">1341         Toolkit.ImageRenderingContext context = new Toolkit.ImageRenderingContext();</span>
<span class="line-added">1342         if (tileImg == null) {</span>
<span class="line-added">1343             tileImg = new WritableImage(w, h);</span>
<span class="line-added">1344         }</span>
1345         setAllowPGAccess(true);
<a name="3" id="anc3"></a><span class="line-modified">1346         context.x = x;</span>
<span class="line-modified">1347         context.y = y;</span>
<span class="line-modified">1348         context.width = w;</span>
<span class="line-modified">1349         context.height = h;</span>
1350         context.transform = transform;
1351         context.depthBuffer = depthBuffer;
1352         context.root = root.getPeer();
1353         context.platformPaint = fill == null ? null : tk.getPaint(fill);
1354         double cameraViewWidth = 1.0;
1355         double cameraViewHeight = 1.0;
1356         if (camera != null) {
1357             // temporarily adjust camera viewport to the snapshot size
1358             cameraViewWidth = camera.getViewWidth();
1359             cameraViewHeight = camera.getViewHeight();
<a name="4" id="anc4"></a><span class="line-modified">1360             camera.setViewWidth(w);</span>
<span class="line-modified">1361             camera.setViewHeight(h);</span>
1362             NodeHelper.updatePeer(camera);
1363             context.camera = camera.getPeer();
1364         } else {
1365             context.camera = null;
1366         }
1367 
1368         // Grab the lights from the scene
1369         context.lights = null;
1370         if (scene != null &amp;&amp; !scene.lights.isEmpty()) {
1371             context.lights = new NGLightBase[scene.lights.size()];
1372             for (int i = 0; i &lt; scene.lights.size(); i++) {
1373                 context.lights[i] = scene.lights.get(i).getPeer();
1374             }
1375         }
1376 
1377         Toolkit.WritableImageAccessor accessor = Toolkit.getWritableImageAccessor();
<a name="5" id="anc5"></a><span class="line-modified">1378         context.platformImage = accessor.getTkImageLoader(tileImg);</span>
1379         setAllowPGAccess(false);
1380         Object tkImage = tk.renderToImage(context);
<a name="6" id="anc6"></a><span class="line-modified">1381         accessor.loadTkImage(tileImg, tkImage);</span>
1382 
1383         if (camera != null) {
1384             setAllowPGAccess(true);
1385             camera.setViewWidth(cameraViewWidth);
1386             camera.setViewHeight(cameraViewHeight);
1387             NodeHelper.updatePeer(camera);
1388             setAllowPGAccess(false);
1389         }
<a name="7" id="anc7"></a><span class="line-modified">1390         return tileImg;</span>








1391     }
1392 
1393     /**
1394      * Implementation method for snapshot
1395      */
1396     private WritableImage doSnapshot(WritableImage img) {
1397         // TODO: no need to do CSS, layout or sync in the deferred case,
1398         // if this scene is attached to a visible stage
1399         doCSSLayoutSyncForSnapshot(getRoot());
1400 
1401         double w = getWidth();
1402         double h = getHeight();
1403         BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;
1404 
1405         return doSnapshot(this, 0, 0, w, h,
1406                 getRoot(), transform, isDepthBufferInternal(),
1407                 getFill(), getEffectiveCamera(), img);
1408     }
1409 
1410     // Pulse listener used to run all deferred (async) snapshot requests
1411     private static TKPulseListener snapshotPulseListener = null;
1412 
1413     private static List&lt;Runnable&gt; snapshotRunnableListA;
1414     private static List&lt;Runnable&gt; snapshotRunnableListB;
1415     private static List&lt;Runnable&gt; snapshotRunnableList;
1416 
1417     static void addSnapshotRunnable(final Runnable runnable) {
1418         Toolkit.getToolkit().checkFxUserThread();
1419 
1420         if (snapshotPulseListener == null) {
1421             snapshotRunnableListA = new ArrayList&lt;Runnable&gt;();
1422             snapshotRunnableListB = new ArrayList&lt;Runnable&gt;();
1423             snapshotRunnableList = snapshotRunnableListA;
1424 
1425             snapshotPulseListener = () -&gt; {
1426                 if (snapshotRunnableList.size() &gt; 0) {
1427                     List&lt;Runnable&gt; runnables = snapshotRunnableList;
1428                     if (snapshotRunnableList == snapshotRunnableListA) {
1429                         snapshotRunnableList = snapshotRunnableListB;
1430                     } else {
1431                         snapshotRunnableList = snapshotRunnableListA;
1432                     }
1433                     for (Runnable r : runnables) {
1434                         try {
1435                             r.run();
1436                         } catch (Throwable th) {
1437                             System.err.println(&quot;Exception in snapshot runnable&quot;);
1438                             th.printStackTrace(System.err);
1439                         }
1440                     }
1441                     runnables.clear();
1442                 }
1443             };
1444 
1445             // Add listener that will be called after all of the scenes have
1446             // had layout and CSS processing, and have been synced
1447             Toolkit.getToolkit().addPostSceneTkPulseListener(snapshotPulseListener);
1448         }
1449 
1450         final AccessControlContext acc = AccessController.getContext();
1451         snapshotRunnableList.add(() -&gt; {
1452             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
1453                 runnable.run();
1454                 return null;
1455             }, acc);
1456         });
1457         Toolkit.getToolkit().requestNextPulse();
1458     }
1459 
1460     /**
1461      * Takes a snapshot of this scene and returns the rendered image when
1462      * it is ready.
1463      * CSS and layout processing will be done for the scene prior to
1464      * rendering it.
1465      * The entire destination image is cleared using the fill {@code Paint}
1466      * of this scene. The nodes in the scene are then rendered to the image.
1467      * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
1468      * If the image is smaller than the size of the scene, then the rendering
1469      * will be clipped by the image.
1470      *
1471      * &lt;p&gt;
1472      * When taking a snapshot of a scene that is being animated, either
1473      * explicitly by the application or implicitly (such as chart animation),
1474      * the snapshot will be rendered based on the state of the scene graph at
1475      * the moment the snapshot is taken and will not reflect any subsequent
1476      * animation changes.
1477      * &lt;/p&gt;
1478      *
1479      * @param image the writable image that will be used to hold the rendered scene.
1480      * It may be null in which case a new WritableImage will be constructed.
1481      * If the image is non-null, the scene will be rendered into the
1482      * existing image.
1483      * In this case, the width and height of the image determine the area
1484      * that is rendered instead of the width and height of the scene.
1485      *
1486      * @throws IllegalStateException if this method is called on a thread
1487      *     other than the JavaFX Application Thread.
1488      *
1489      * @return the rendered image
1490      * @since JavaFX 2.2
1491      */
1492     public WritableImage snapshot(WritableImage image) {
1493         Toolkit.getToolkit().checkFxUserThread();
1494 
1495         return doSnapshot(image);
1496     }
1497 
1498     /**
1499      * Takes a snapshot of this scene at the next frame and calls the
1500      * specified callback method when the image is ready.
1501      * CSS and layout processing will be done for the scene prior to
1502      * rendering it.
1503      * The entire destination image is cleared using the fill {@code Paint}
1504      * of this scene. The nodes in the scene are then rendered to the image.
1505      * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
1506      * If the image is smaller than the size of the scene, then the rendering
1507      * will be clipped by the image.
1508      *
1509      * &lt;p&gt;
1510      * This is an asynchronous call, which means that other
1511      * events or animation might be processed before the scene is rendered.
1512      * If any such events modify a node in the scene that modification will
1513      * be reflected in the rendered image (as it will also be reflected in
1514      * the frame rendered to the Stage).
1515      * &lt;/p&gt;
1516      *
1517      * &lt;p&gt;
1518      * When taking a snapshot of a scene that is being animated, either
1519      * explicitly by the application or implicitly (such as chart animation),
1520      * the snapshot will be rendered based on the state of the scene graph at
1521      * the moment the snapshot is taken and will not reflect any subsequent
1522      * animation changes.
1523      * &lt;/p&gt;
1524      *
1525      * @param callback a class whose call method will be called when the image
1526      * is ready. The SnapshotResult that is passed into the call method of
1527      * the callback will contain the rendered image and the source scene
1528      * that was rendered. The callback parameter must not be null.
1529      *
1530      * @param image the writable image that will be used to hold the rendered scene.
1531      * It may be null in which case a new WritableImage will be constructed.
1532      * If the image is non-null, the scene will be rendered into the
1533      * existing image.
1534      * In this case, the width and height of the image determine the area
1535      * that is rendered instead of the width and height of the scene.
1536      *
1537      * @throws IllegalStateException if this method is called on a thread
1538      *     other than the JavaFX Application Thread.
1539      *
1540      * @throws NullPointerException if the callback parameter is null.
1541      * @since JavaFX 2.2
1542      */
1543     public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback, WritableImage image) {
1544         Toolkit.getToolkit().checkFxUserThread();
1545         if (callback == null) {
1546             throw new NullPointerException(&quot;The callback must not be null&quot;);
1547         }
1548 
1549         final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;
1550         final WritableImage theImage = image;
1551 
1552         // Create a deferred runnable that will be run from a pulse listener
1553         // that is called after all of the scenes have been synced but before
1554         // any of them have been rendered.
1555         final Runnable snapshotRunnable = () -&gt; {
1556             WritableImage img = doSnapshot(theImage);
1557 //                System.err.println(&quot;Calling snapshot callback&quot;);
1558             SnapshotResult result = new SnapshotResult(img, Scene.this, null);
1559             try {
1560                 Void v = theCallback.call(result);
1561             } catch (Throwable th) {
1562                 System.err.println(&quot;Exception in snapshot callback&quot;);
1563                 th.printStackTrace(System.err);
1564             }
1565         };
1566 //        System.err.println(&quot;Schedule a snapshot in the future&quot;);
1567         addSnapshotRunnable(snapshotRunnable);
1568     }
1569 
1570     /**
1571      * Defines the mouse cursor for this {@code Scene}.
1572      */
1573     private ObjectProperty&lt;Cursor&gt; cursor;
1574 
1575     public final void setCursor(Cursor value) {
1576         cursorProperty().set(value);
1577     }
1578 
1579     public final Cursor getCursor() {
1580         return cursor == null ? null : cursor.get();
1581     }
1582 
1583     public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
1584         if (cursor == null) {
1585             cursor = new ObjectPropertyBase&lt;Cursor&gt;() {
1586                          @Override
1587                          protected void invalidated() {
1588                              markCursorDirty();
1589                          }
1590 
1591                          @Override
1592                          public Object getBean() {
1593                              return Scene.this;
1594                          }
1595 
1596                          @Override
1597                          public String getName() {
1598                              return &quot;cursor&quot;;
1599                          }
1600                      };
1601         }
1602         return cursor;
1603     }
1604 
1605     /**
1606      * Looks for any node within the scene graph based on the specified CSS selector.
1607      * If more than one node matches the specified selector, this function
1608      * returns the first of them.
1609      * If no nodes are found with this id, then null is returned.
1610      *
1611      * @param selector The css selector to look up
1612      * @return the {@code Node} in the scene which matches the CSS {@code selector},
1613      * or {@code null} if none is found.
1614      */
1615      public Node lookup(String selector) {
1616          return getRoot().lookup(selector);
1617      }
1618     /**
1619      * A ObservableList of string URLs linking to the stylesheets to use with this scene&#39;s
1620      * contents. For additional information about using CSS with the
1621      * scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
1622      * Guide&lt;/a&gt;.
1623      */
1624     private final ObservableList&lt;String&gt; stylesheets  = new TrackableObservableList&lt;String&gt;() {
1625         @Override
1626         protected void onChanged(Change&lt;String&gt; c) {
1627             StyleManager.getInstance().stylesheetsChanged(Scene.this, c);
1628             // RT-9784 - if stylesheet is removed, reset styled properties to
1629             // their initial value.
1630             c.reset();
1631             while(c.next()) {
1632                 if (c.wasRemoved() == false) {
1633                     continue;
1634                 }
1635                 break; // no point in resetting more than once...
1636             }
1637             getRoot().reapplyCSS();
1638         }
1639     };
1640 
1641     /**
1642      * Gets an observable list of string URLs linking to the stylesheets to use
1643      * with this scene&#39;s contents.
1644      * &lt;p&gt;
1645      * The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
1646      * does not have a [scheme:] component, the URL is considered to be the [path] component only.
1647      * Any leading &#39;/&#39; character of the [path] is ignored and the [path] is treated as a path relative to
1648      * the root of the application&#39;s classpath.
1649      * &lt;/p&gt;
1650      * &lt;pre&gt;&lt;code&gt;
1651      *
1652      * package com.example.javafx.app;
1653      *
1654      * import javafx.application.Application;
1655      * import javafx.scene.Group;
1656      * import javafx.scene.Scene;
1657      * import javafx.stage.Stage;
1658      *
1659      * public class MyApp extends Application {
1660      *
1661      *     {@literal @}Override public void start(Stage stage) {
1662      *         Scene scene = new Scene(new Group());
1663      *         scene.getStylesheets().add(&quot;/com/example/javafx/app/mystyles.css&quot;);
1664      *         stage.setScene(scene);
1665      *         stage.show();
1666      *     }
1667      *
1668      *     public static void main(String[] args) {
1669      *         launch(args);
1670      *     }
1671      * }
1672      * &lt;/code&gt;&lt;/pre&gt;
1673      * For additional information about using CSS with the scene graph,
1674      * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
1675      *
1676      * @return the list of stylesheets to use with this scene
1677      */
1678     public final ObservableList&lt;String&gt; getStylesheets() { return stylesheets; }
1679 
1680     private ObjectProperty&lt;String&gt; userAgentStylesheet = null;
1681 
1682     /**
1683      * @return the userAgentStylesheet property.
1684      * @see #getUserAgentStylesheet()
1685      * @see #setUserAgentStylesheet(String)
1686      * @since  JavaFX 8u20
1687      */
1688     public final ObjectProperty&lt;String&gt; userAgentStylesheetProperty() {
1689         if (userAgentStylesheet == null) {
1690             userAgentStylesheet = new SimpleObjectProperty&lt;String&gt;(Scene.this, &quot;userAgentStylesheet&quot;, null) {
1691                 @Override protected void invalidated() {
1692                     StyleManager.getInstance().forget(Scene.this);
1693                     getRoot().reapplyCSS();
1694                 }
1695             };
1696         }
1697         return userAgentStylesheet;
1698     }
1699 
1700     /**
1701      * Get the URL of the user-agent stylesheet that will be used by this Scene. If the URL has not been set,
1702      * the platform-default user-agent stylesheet will be used.
1703      * &lt;p&gt;
1704      * For additional information about using CSS with the scene graph,
1705      * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
1706      * &lt;/p&gt;
1707      * @return The URL of the user-agent stylesheet that will be used by this Scene,
1708      * or null if has not been set.
1709      * @since  JavaFX 8u20
1710      */
1711     public final String getUserAgentStylesheet() {
1712         return userAgentStylesheet == null ? null : userAgentStylesheet.get();
1713     }
1714 
1715     /**
1716      * Set the URL of the user-agent stylesheet that will be used by this Scene in place of the
1717      * the platform-default user-agent stylesheet. If the URL does not resolve to a valid location,
1718      * the platform-default user-agent stylesheet will be used.
1719      * &lt;p&gt;
1720      * For additional information about using CSS with the scene graph,
1721      * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
1722      * &lt;/p&gt;
1723      * @param url The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
1724      * does not have a [scheme:] component, the URL is considered to be the [path] component only.
1725      * Any leading &#39;/&#39; character of the [path] is ignored and the [path] is treated as a path relative to
1726      * the root of the application&#39;s classpath.
1727      * @since  JavaFX 8u20
1728      */
1729     public final void setUserAgentStylesheet(String url) {
1730         userAgentStylesheetProperty().set(url);
1731     }
1732 
1733     /**
1734      * Retrieves the depth buffer attribute for this scene.
1735      * @return the depth buffer attribute.
1736      */
1737     public final boolean isDepthBuffer() {
1738         return depthBuffer;
1739     }
1740 
1741     boolean isDepthBufferInternal() {
1742         if (!Platform.isSupported(ConditionalFeature.SCENE3D)) {
1743             return false;
1744         }
1745         return depthBuffer;
1746     }
1747 
1748     private void init(double width, double height) {
1749         if (width &gt;= 0) {
1750             widthSetByUser = width;
1751             setWidth((float)width);
1752         }
1753         if (height &gt;= 0) {
1754             heightSetByUser = height;
1755             setHeight((float)height);
1756         }
1757         sizeInitialized = (widthSetByUser &gt;= 0 &amp;&amp; heightSetByUser &gt;= 0);
1758     }
1759 
1760     private void init() {
1761         if (PerformanceTracker.isLoggingEnabled()) {
1762             PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;]&quot;);
1763         }
1764         mouseHandler = new MouseHandler();
1765         clickGenerator = new ClickGenerator();
1766 
1767         if (PerformanceTracker.isLoggingEnabled()) {
1768             PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;] - finished&quot;);
1769         }
1770     }
1771 
1772     void preferredSize() {
1773         final Parent root = getRoot();
1774 
1775         // one or the other isn&#39;t initialized, need to perform layout in
1776         // order to ensure we can properly measure the preferred size of the
1777         // scene
1778         doCSSPass();
1779 
1780         resizeRootToPreferredSize(root);
1781         doLayoutPass();
1782 
1783         if (widthSetByUser &lt; 0) {
1784             setWidth(root.isResizable()? root.getLayoutX() + root.getTranslateX() + root.getLayoutBounds().getWidth() :
1785                             root.getBoundsInParent().getMaxX());
1786         } else {
1787             setWidth(widthSetByUser);
1788         }
1789 
1790         if (heightSetByUser &lt; 0) {
1791             setHeight(root.isResizable()? root.getLayoutY() + root.getTranslateY() + root.getLayoutBounds().getHeight() :
1792                             root.getBoundsInParent().getMaxY());
1793         } else {
1794             setHeight(heightSetByUser);
1795         }
1796 
1797         sizeInitialized = (getWidth() &gt; 0) &amp;&amp; (getHeight() &gt; 0);
1798 
1799         PerformanceTracker.logEvent(&quot;Scene preferred bounds computation complete&quot;);
1800     }
1801 
1802     final void resizeRootToPreferredSize(Parent root) {
1803         final double preferredWidth;
1804         final double preferredHeight;
1805 
1806         final Orientation contentBias = root.getContentBias();
1807         if (contentBias == null) {
1808             preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
1809             preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
1810         } else if (contentBias == Orientation.HORIZONTAL) {
1811             // height depends on width
1812             preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
1813             preferredHeight = getPreferredHeight(root, heightSetByUser,
1814                                                        preferredWidth);
1815         } else /* if (contentBias == Orientation.VERTICAL) */ {
1816             // width depends on height
1817             preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
1818             preferredWidth = getPreferredWidth(root, widthSetByUser,
1819                                                      preferredHeight);
1820         }
1821 
1822         root.resize(preferredWidth, preferredHeight);
1823     }
1824 
1825     private static double getPreferredWidth(Parent root,
1826                                             double forcedWidth,
1827                                             double height) {
1828         if (forcedWidth &gt;= 0) {
1829             return forcedWidth;
1830         }
1831         final double normalizedHeight = (height &gt;= 0) ? height : -1;
1832         return root.boundedSize(root.prefWidth(normalizedHeight),
1833                                 root.minWidth(normalizedHeight),
1834                                 root.maxWidth(normalizedHeight));
1835     }
1836 
1837     private static double getPreferredHeight(Parent root,
1838                                              double forcedHeight,
1839                                              double width) {
1840         if (forcedHeight &gt;= 0) {
1841             return forcedHeight;
1842         }
1843         final double normalizedWidth = (width &gt;= 0) ? width : -1;
1844         return root.boundedSize(root.prefHeight(normalizedWidth),
1845                                 root.minHeight(normalizedWidth),
1846                                 root.maxHeight(normalizedWidth));
1847     }
1848 
1849     private PerformanceTracker tracker;
1850     private static final Object trackerMonitor = new Object();
1851 
1852     // mouse events handling
1853     private MouseHandler mouseHandler;
1854     private ClickGenerator clickGenerator;
1855 
1856     // gesture events handling
1857     private Point2D cursorScreenPos;
1858     private Point2D cursorScenePos;
1859 
1860     private static class TouchGesture {
1861         WeakReference&lt;EventTarget&gt; target;
1862         Point2D sceneCoords;
1863         Point2D screenCoords;
1864         boolean finished;
1865     }
1866 
1867     private final TouchGesture scrollGesture = new TouchGesture();
1868     private final TouchGesture zoomGesture = new TouchGesture();
1869     private final TouchGesture rotateGesture = new TouchGesture();
1870     private final TouchGesture swipeGesture = new TouchGesture();
1871 
1872     // touch events handling
1873     private TouchMap touchMap = new TouchMap();
1874     private TouchEvent nextTouchEvent = null;
1875     private TouchPoint[] touchPoints = null;
1876     private int touchEventSetId = 0;
1877     private int touchPointIndex = 0;
1878     private Map&lt;Integer, EventTarget&gt; touchTargets =
1879             new HashMap&lt;Integer, EventTarget&gt;();
1880 
1881     void processMouseEvent(MouseEvent e) {
1882         mouseHandler.process(e, false);
1883     }
1884 
1885     private void processMenuEvent(double x2, double y2, double xAbs, double yAbs, boolean isKeyboardTrigger) {
1886         EventTarget eventTarget = null;
1887         Scene.inMousePick = true;
1888         if (isKeyboardTrigger) {
1889             Node sceneFocusOwner = getFocusOwner();
1890 
1891             // for keyboard triggers set coordinates inside focus owner
1892             final double xOffset = xAbs - x2;
1893             final double yOffset = yAbs - y2;
1894             if (sceneFocusOwner != null) {
1895                 final Bounds bounds = sceneFocusOwner.localToScene(
1896                         sceneFocusOwner.getBoundsInLocal());
1897                 x2 = bounds.getMinX() + bounds.getWidth() / 4;
1898                 y2 = bounds.getMinY() + bounds.getHeight() / 2;
1899                 eventTarget = sceneFocusOwner;
1900             } else {
1901                 x2 = Scene.this.getWidth() / 4;
1902                 y2 = Scene.this.getWidth() / 2;
1903                 eventTarget = Scene.this;
1904             }
1905 
1906             xAbs = x2 + xOffset;
1907             yAbs = y2 + yOffset;
1908         }
1909 
1910         final PickResult res = pick(x2, y2);
1911 
1912         if (!isKeyboardTrigger) {
1913             eventTarget = res.getIntersectedNode();
1914             if (eventTarget == null) {
1915                 eventTarget = this;
1916             }
1917         }
1918 
1919         if (eventTarget != null) {
1920             ContextMenuEvent context = new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,
1921                     x2, y2, xAbs, yAbs, isKeyboardTrigger, res);
1922             Event.fireEvent(eventTarget, context);
1923         }
1924         Scene.inMousePick = false;
1925     }
1926 
1927     private void processGestureEvent(GestureEvent e, TouchGesture gesture) {
1928         EventTarget pickedTarget = null;
1929 
1930         if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
1931                 e.getEventType() == RotateEvent.ROTATION_STARTED ||
1932                 e.getEventType() == ScrollEvent.SCROLL_STARTED) {
1933             gesture.target = null;
1934             gesture.finished = false;
1935         }
1936 
1937         if (gesture.target != null &amp;&amp; (!gesture.finished || e.isInertia())) {
1938             pickedTarget = gesture.target.get();
1939         } else {
1940             pickedTarget = e.getPickResult().getIntersectedNode();
1941             if (pickedTarget == null) {
1942                 pickedTarget = this;
1943             }
1944         }
1945 
1946         if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
1947                 e.getEventType() == RotateEvent.ROTATION_STARTED ||
1948                 e.getEventType() == ScrollEvent.SCROLL_STARTED) {
1949             gesture.target = new WeakReference&lt;&gt;(pickedTarget);
1950         }
1951         if (e.getEventType() != ZoomEvent.ZOOM_FINISHED &amp;&amp;
1952                 e.getEventType() != RotateEvent.ROTATION_FINISHED &amp;&amp;
1953                 e.getEventType() != ScrollEvent.SCROLL_FINISHED &amp;&amp;
1954                 !e.isInertia()) {
1955             gesture.sceneCoords = new Point2D(e.getSceneX(), e.getSceneY());
1956             gesture.screenCoords = new Point2D(e.getScreenX(), e.getScreenY());
1957         }
1958 
1959         if (pickedTarget != null) {
1960             Event.fireEvent(pickedTarget, e);
1961         }
1962 
1963         if (e.getEventType() == ZoomEvent.ZOOM_FINISHED ||
1964                 e.getEventType() == RotateEvent.ROTATION_FINISHED ||
1965                 e.getEventType() == ScrollEvent.SCROLL_FINISHED) {
1966             gesture.finished = true;
1967         }
1968     }
1969 
1970     private void processTouchEvent(TouchEvent e, TouchPoint[] touchPoints) {
1971         inMousePick = true;
1972         touchEventSetId++;
1973 
1974         List&lt;TouchPoint&gt; touchList = Arrays.asList(touchPoints);
1975 
1976         // fire all the events
1977         for (TouchPoint tp : touchPoints) {
1978             if (tp.getTarget() != null) {
1979                 EventType&lt;TouchEvent&gt; type = null;
1980                 switch (tp.getState()) {
1981                     case MOVED:
1982                         type = TouchEvent.TOUCH_MOVED;
1983                         break;
1984                     case PRESSED:
1985                         type = TouchEvent.TOUCH_PRESSED;
1986                         break;
1987                     case RELEASED:
1988                         type = TouchEvent.TOUCH_RELEASED;
1989                         break;
1990                     case STATIONARY:
1991                         type = TouchEvent.TOUCH_STATIONARY;
1992                         break;
1993                 }
1994 
1995                 for (TouchPoint t : touchPoints) {
1996                     TouchPointHelper.reset(t);
1997                 }
1998 
1999                 TouchEvent te = new TouchEvent(type, tp, touchList,
2000                         touchEventSetId, e.isShiftDown(), e.isControlDown(),
2001                         e.isAltDown(), e.isMetaDown());
2002 
2003                 Event.fireEvent(tp.getTarget(), te);
2004             }
2005         }
2006 
2007         // process grabbing
2008         for (TouchPoint tp : touchPoints) {
2009             EventTarget grabbed = tp.getGrabbed();
2010             if (grabbed != null) {
2011                 touchTargets.put(tp.getId(), grabbed);
2012             };
2013 
2014             if (grabbed == null || tp.getState() == TouchPoint.State.RELEASED) {
2015                 touchTargets.remove(tp.getId());
2016             }
2017         }
2018 
2019         inMousePick = false;
2020     }
2021 
2022     /**
2023      * Note: The only user of this method is in unit test: PickAndContainTest.
2024      */
2025     Node test_pick(double x, double y) {
2026         inMousePick = true;
2027         PickResult result = mouseHandler.pickNode(new PickRay(x, y, 1,
2028                 Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY));
2029         inMousePick = false;
2030         if (result != null) {
2031             return result.getIntersectedNode();
2032         }
2033         return null;
2034     }
2035 
2036     private PickResult pick(final double x, final double y) {
2037         pick(tmpTargetWrapper, x, y);
2038         return tmpTargetWrapper.getResult();
2039     }
2040 
2041     private boolean isInScene(double x, double y) {
2042         if (x &lt; 0 || y &lt; 0 || x &gt; getWidth() || y &gt; getHeight())  {
2043             return false;
2044         }
2045 
2046         Window w = getWindow();
2047         if (w instanceof Stage
2048                 &amp;&amp; ((Stage) w).getStyle() == StageStyle.TRANSPARENT
2049                 &amp;&amp; getFill() == null) {
2050             return false;
2051         }
2052 
2053         return true;
2054     }
2055 
2056     private void pick(TargetWrapper target, final double x, final double y) {
2057         final PickRay pickRay = getEffectiveCamera().computePickRay(
2058                 x, y, null);
2059 
2060         final double mag = pickRay.getDirectionNoClone().length();
2061         pickRay.getDirectionNoClone().normalize();
2062         final PickResult res = mouseHandler.pickNode(pickRay);
2063         if (res != null) {
2064             target.setNodeResult(res);
2065         } else {
2066             //TODO: is this the intersection with projection plane?
2067             Vec3d o = pickRay.getOriginNoClone();
2068             Vec3d d = pickRay.getDirectionNoClone();
2069             target.setSceneResult(new PickResult(
2070                     null, new Point3D(
2071                     o.x + mag * d.x,
2072                     o.y + mag * d.y,
2073                     o.z + mag * d.z),
2074                     mag),
2075                     isInScene(x, y) ? this : null);
2076         }
2077     }
2078 
2079     /***************************************************************************
2080      *                                                                         *
2081      * Key Events and Focus Traversal                                          *
2082      *                                                                         *
2083      **************************************************************************/
2084 
2085     /*
2086      * We cannot initialize keyHandler in init because some of the triggers
2087      * access it before the init block.
2088      * No clue why def keyHandler = bind lazy {KeyHandler{scene:this};}
2089      * does not compile.
2090      */
2091     private KeyHandler keyHandler = null;
2092     private KeyHandler getKeyHandler() {
2093         if (keyHandler == null) {
2094             keyHandler = new KeyHandler();
2095         }
2096         return keyHandler;
2097     }
2098     /**
2099      * Set to true if something has happened to the focused node that makes
2100      * it no longer eligible to have the focus.
2101      *
2102      */
2103     private boolean focusDirty = true;
2104 
2105     final void setFocusDirty(boolean value) {
2106         if (!focusDirty) {
2107             Toolkit.getToolkit().requestNextPulse();
2108         }
2109         focusDirty = value;
2110     }
2111 
2112     final boolean isFocusDirty() {
2113         return focusDirty;
2114     }
2115 
2116     private TopMostTraversalEngine traversalEngine = new SceneTraversalEngine(this);
2117 
2118     /**
2119      * Traverses focus from the given node in the given direction.
2120      */
2121     boolean traverse(Node node, Direction dir) {
2122         if (node.getSubScene() != null) {
2123             return node.getSubScene().traverse(node, dir);
2124         }
2125         return traversalEngine.trav(node, dir) != null;
2126     }
2127 
2128     /**
2129      * Moves the focus to a reasonable initial location. Called when a scene&#39;s
2130      * focus is dirty and there&#39;s no current owner, or if the owner has been
2131      * removed from the scene.
2132      */
2133     private void focusInitial() {
2134         traversalEngine.traverseToFirst();
2135     }
2136 
2137     /**
2138      * Moves the focus to a reasonble location &quot;near&quot; the given node.
2139      * Called when the focused node is no longer eligible to have
2140      * the focus because it has become invisible or disabled. This
2141      * function assumes that it is still a member of the same scene.
2142      */
2143     private void focusIneligible(Node node) {
2144         traverse(node, Direction.NEXT);
2145     }
2146 
2147     public void processKeyEvent(KeyEvent e) {
2148         if (dndGesture != null) {
2149             if (!dndGesture.processKey(e)) {
2150                 dndGesture = null;
2151             }
2152         }
2153 
2154         getKeyHandler().process(e);
2155     }
2156 
2157     void requestFocus(Node node) {
2158         getKeyHandler().requestFocus(node);
2159     }
2160 
2161     private Node oldFocusOwner;
2162 
2163     /**
2164       * The scene&#39;s current focus owner node. This node&#39;s &quot;focused&quot;
2165       * variable might be false if this scene has no window, or if the
2166       * window is inactive (window.focused == false).
2167       * @since JavaFX 2.2
2168       */
2169     private ReadOnlyObjectWrapper&lt;Node&gt; focusOwner = new ReadOnlyObjectWrapper&lt;Node&gt;(this, &quot;focusOwner&quot;) {
2170 
2171         @Override
2172         protected void invalidated() {
2173             if (oldFocusOwner != null) {
2174                 ((Node.FocusedProperty) oldFocusOwner.focusedProperty()).store(false);
2175             }
2176             Node value = get();
2177             if (value != null) {
2178                 ((Node.FocusedProperty) value.focusedProperty()).store(keyHandler.windowFocused);
2179                 if (value != oldFocusOwner) {
2180                     value.getScene().enableInputMethodEvents(
2181                             value.getInputMethodRequests() != null
2182                             &amp;&amp; value.getOnInputMethodTextChanged() != null);
2183                 }
2184             }
2185             // for the rest of the method we need to update the oldFocusOwner
2186             // and use a local copy of it because the user handlers can cause
2187             // recurrent calls of requestFocus
2188             Node localOldOwner = oldFocusOwner;
2189             oldFocusOwner = value;
2190             if (localOldOwner != null) {
2191                 ((Node.FocusedProperty) localOldOwner.focusedProperty()).notifyListeners();
2192             }
2193             if (value != null) {
2194                 ((Node.FocusedProperty) value.focusedProperty()).notifyListeners();
2195             }
2196             PlatformLogger logger = Logging.getFocusLogger();
2197             if (logger.isLoggable(Level.FINE)) {
2198                 if (value == get()) {
2199                     logger.fine(&quot;Changed focus from &quot;
2200                             + localOldOwner + &quot; to &quot; + value);
2201                 } else {
2202                     logger.fine(&quot;Changing focus from &quot;
2203                             + localOldOwner + &quot; to &quot; + value
2204                             + &quot; canceled by nested requestFocus&quot;);
2205                 }
2206             }
2207             if (accessible != null) {
2208                 accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
2209             }
2210         }
2211     };
2212 
2213     public final Node getFocusOwner() {
2214         return focusOwner.get();
2215     }
2216 
2217     public final ReadOnlyObjectProperty&lt;Node&gt; focusOwnerProperty() {
2218         return focusOwner.getReadOnlyProperty();
2219     }
2220 
2221     // For testing.
2222     void focusCleanup() {
2223         scenePulseListener.focusCleanup();
2224     }
2225 
2226     private void processInputMethodEvent(InputMethodEvent e) {
2227         Node node = getFocusOwner();
2228         if (node != null) {
2229             node.fireEvent(e);
2230         }
2231     }
2232 
2233     public void enableInputMethodEvents(boolean enable) {
2234        if (peer != null) {
2235            peer.enableInputMethodEvents(enable);
2236        }
2237     }
2238 
2239     /**
2240      * Returns true if this scene is quiescent, i.e. it has no activity
2241      * pending on it such as CSS processing or layout requests.
2242      *
2243      * Intended to be used for tests only
2244      *
2245      * @return boolean indicating whether the scene is quiescent
2246      */
2247     boolean isQuiescent() {
2248         final Parent r = getRoot();
2249         return !isFocusDirty()
2250                &amp;&amp; (r == null || (r.cssFlag == CssFlags.CLEAN &amp;&amp;
2251                 r.layoutFlag == LayoutFlags.CLEAN));
2252     }
2253 
2254     /**
2255      * A listener for pulses, used for testing. If non-null, this is called at
2256      * the very end of ScenePulseListener.pulse().
2257      *
2258      * Intended to be used for tests only
2259      */
2260     Runnable testPulseListener = null;
2261 
2262     /**
2263      * Set the specified dirty bit and mark the peer as dirty
2264      */
2265     private void markDirty(DirtyBits dirtyBit) {
2266         setDirty(dirtyBit);
2267         if (peer != null) {
2268             Toolkit.getToolkit().requestNextPulse();
2269         }
2270     }
2271 
2272     /**
2273      * Set the specified dirty bit
2274      */
2275     private void setDirty(DirtyBits dirtyBit) {
2276         dirtyBits.add(dirtyBit);
2277     }
2278 
2279     /**
2280      * Test the specified dirty bit
2281      */
2282     private boolean isDirty(DirtyBits dirtyBit) {
2283         return dirtyBits.contains(dirtyBit);
2284     }
2285 
2286     /**
2287      * Test whether the dirty bits are empty
2288      */
2289     private boolean isDirtyEmpty() {
2290         return dirtyBits.isEmpty();
2291     }
2292 
2293     /**
2294      * Clear all dirty bits
2295      */
2296     private void clearDirty() {
2297         dirtyBits.clear();
2298     }
2299 
2300     private enum DirtyBits {
2301         FILL_DIRTY,
2302         ROOT_DIRTY,
2303         CAMERA_DIRTY,
2304         LIGHTS_DIRTY,
2305         CURSOR_DIRTY;
2306     }
2307 
2308     private List&lt;LightBase&gt; lights = new ArrayList&lt;&gt;();
2309 
2310     // @param light must not be null
2311     final void addLight(LightBase light) {
2312         if (!lights.contains(light)) {
2313             lights.add(light);
2314             markDirty(DirtyBits.LIGHTS_DIRTY);
2315         }
2316     }
2317 
2318     final void removeLight(LightBase light) {
2319         if (lights.remove(light)) {
2320             markDirty(DirtyBits.LIGHTS_DIRTY);
2321         }
2322     }
2323 
2324     /**
2325      * PG Light synchronizer.
2326      */
2327     private void syncLights() {
2328         if (!isDirty(DirtyBits.LIGHTS_DIRTY)) {
2329             return;
2330         }
2331         inSynchronizer = true;
2332         NGLightBase peerLights[] = peer.getLights();
2333         if (!lights.isEmpty() || (peerLights != null)) {
2334             if (lights.isEmpty()) {
2335                 peer.setLights(null);
2336             } else {
2337                 if (peerLights == null || peerLights.length &lt; lights.size()) {
2338                     peerLights = new NGLightBase[lights.size()];
2339                 }
2340                 int i = 0;
2341                 for (; i &lt; lights.size(); i++) {
2342                     peerLights[i] = lights.get(i).getPeer();
2343                 }
2344                 // Clear the rest of the list
2345                 while (i &lt; peerLights.length &amp;&amp; peerLights[i] != null) {
2346                     peerLights[i++] = null;
2347                 }
2348                 peer.setLights(peerLights);
2349             }
2350         }
2351         inSynchronizer = false;
2352     }
2353 
2354     //INNER CLASSES
2355 
2356     /*******************************************************************************
2357      *                                                                             *
2358      * Scene Pulse Listener                                                        *
2359      *                                                                             *
2360      ******************************************************************************/
2361 
2362     class ScenePulseListener implements TKPulseListener {
2363 
2364         private boolean firstPulse = true;
2365 
2366         /**
2367          * PG synchronizer. Called once per frame from the pulse listener.
2368          * This function calls the synchronizePGNode method on each node in
2369          * the dirty list.
2370          */
2371         private void synchronizeSceneNodes() {
2372             Toolkit.getToolkit().checkFxUserThread();
2373 
2374             Scene.inSynchronizer = true;
2375 
2376             // if dirtyNodes is null then that means this Scene has not yet been
2377             // synchronized, and so we will simply synchronize every node in the
2378             // scene and then create the dirty nodes array list
2379             if (Scene.this.dirtyNodes == null) {
2380                 // must do this recursively
2381                 syncAll(getRoot());
2382                 dirtyNodes = new Node[MIN_DIRTY_CAPACITY];
2383 
2384             } else {
2385                 // This is not the first time this scene has been synchronized,
2386                 // so we will only synchronize those nodes that need it
2387                 for (int i = 0 ; i &lt; dirtyNodesSize; ++i) {
2388                     Node node = dirtyNodes[i];
2389                     dirtyNodes[i] = null;
2390                     if (node.getScene() == Scene.this) {
2391                             node.syncPeer();
2392                         }
2393                     }
2394                 dirtyNodesSize = 0;
2395             }
2396 
2397             Scene.inSynchronizer = false;
2398         }
2399 
2400         /**
2401          * Recursive function for synchronizing every node in the scenegraph.
2402          * The return value is the number of nodes in the graph.
2403          */
2404         private int syncAll(Node node) {
2405             node.syncPeer();
2406             int size = 1;
2407             if (node instanceof Parent) {
2408                 Parent p = (Parent) node;
2409                 final int childrenCount = p.getChildren().size();
2410 
2411                 for (int i = 0; i &lt; childrenCount; i++) {
2412                     Node n = p.getChildren().get(i);
2413                     if (n != null) {
2414                         size += syncAll(n);
2415                     }
2416                 }
2417             } else if (node instanceof SubScene) {
2418                 SubScene subScene = (SubScene)node;
2419                 size += syncAll(subScene.getRoot());
2420             }
2421             if (node.getClip() != null) {
2422                 size += syncAll(node.getClip());
2423             }
2424 
2425             return size;
2426         }
2427 
2428         private void synchronizeSceneProperties() {
2429             inSynchronizer = true;
2430             if (isDirty(DirtyBits.ROOT_DIRTY)) {
2431                 peer.setRoot(getRoot().getPeer());
2432             }
2433 
2434             if (isDirty(DirtyBits.FILL_DIRTY)) {
2435                 Toolkit tk = Toolkit.getToolkit();
2436                 peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
2437             }
2438 
2439             // new camera was set on the scene or old camera changed
2440             final Camera cam = getEffectiveCamera();
2441             if (isDirty(DirtyBits.CAMERA_DIRTY)) {
2442                 NodeHelper.updatePeer(cam);
2443                 peer.setCamera((NGCamera) cam.getPeer());
2444             }
2445 
2446             if (isDirty(DirtyBits.CURSOR_DIRTY)) {
2447                 mouseHandler.updateCursor(getCursor());
2448                 mouseHandler.updateCursorFrame();
2449             }
2450 
2451             clearDirty();
2452             inSynchronizer = false;
2453         }
2454 
2455         /**
2456          * The focus is considered dirty if something happened to
2457          * the scene graph that may require the focus to be moved.
2458          * This must handle cases where (a) the focus owner may have
2459          * become ineligible to have the focus, and (b) where the focus
2460          * owner is null and a node may have become traversable and eligible.
2461          */
2462         private void focusCleanup() {
2463             if (Scene.this.isFocusDirty()) {
2464                 final Node oldOwner = Scene.this.getFocusOwner();
2465                 if (oldOwner == null) {
2466                     Scene.this.focusInitial();
2467                 } else if (oldOwner.getScene() != Scene.this) {
2468                     Scene.this.requestFocus(null);
2469                     Scene.this.focusInitial();
2470                 } else if (!oldOwner.isCanReceiveFocus()) {
2471                     Scene.this.requestFocus(null);
2472                     Scene.this.focusIneligible(oldOwner);
2473                 }
2474                 Scene.this.setFocusDirty(false);
2475             }
2476         }
2477 
2478         @Override
2479         public void pulse() {
2480             if (Scene.this.tracker != null) {
2481                 Scene.this.tracker.pulse();
2482             }
2483             if (firstPulse) {
2484                 PerformanceTracker.logEvent(&quot;Scene - first repaint&quot;);
2485             }
2486 
2487             focusCleanup();
2488 
2489             disposeAccessibles();
2490 
2491             // run any scene pre pulse listeners immediately _before_ css / layout,
2492             // and before scene synchronization
2493             if (preLayoutPulseListeners != null) {
2494                 for (Runnable r : preLayoutPulseListeners) {
2495                     r.run();
2496                 }
2497             }
2498 
2499             if (PULSE_LOGGING_ENABLED) {
2500                 PulseLogger.newPhase(&quot;CSS Pass&quot;);
2501             }
2502             Scene.this.doCSSPass();
2503 
2504             if (PULSE_LOGGING_ENABLED) {
2505                 PulseLogger.newPhase(&quot;Layout Pass&quot;);
2506             }
2507             Scene.this.doLayoutPass();
2508 
2509             // run any scene post pulse listeners immediately _after_ css / layout,
2510             // and before scene synchronization
2511             if (postLayoutPulseListeners != null) {
2512                 for (Runnable r : postLayoutPulseListeners) {
2513                     r.run();
2514                 }
2515             }
2516 
2517             boolean dirty = dirtyNodes == null || dirtyNodesSize != 0 || !isDirtyEmpty();
2518             if (dirty) {
2519                 if (PULSE_LOGGING_ENABLED) {
2520                     PulseLogger.newPhase(&quot;Update bounds&quot;);
2521                 }
2522                 getRoot().updateBounds();
2523                 if (peer != null) {
2524                     try {
2525                         if (PULSE_LOGGING_ENABLED) {
2526                             PulseLogger.newPhase(&quot;Waiting for previous rendering&quot;);
2527                         }
2528                         peer.waitForRenderingToComplete();
2529                         peer.waitForSynchronization();
2530                         // synchronize scene properties
2531                         if (PULSE_LOGGING_ENABLED) {
2532                             PulseLogger.newPhase(&quot;Copy state to render graph&quot;);
2533                         }
2534                         syncLights();
2535                         synchronizeSceneProperties();
2536                         // Run the synchronizer
2537                         synchronizeSceneNodes();
2538                         Scene.this.mouseHandler.pulse();
2539                         // Tell the scene peer that it needs to repaint
2540                         peer.markDirty();
2541                     } finally {
2542                         peer.releaseSynchronization(true);
2543                     }
2544                 } else {
2545                     if (PULSE_LOGGING_ENABLED) {
2546                         PulseLogger.newPhase(&quot;Synchronize with null peer&quot;);
2547                     }
2548                     synchronizeSceneNodes();
2549                     Scene.this.mouseHandler.pulse();
2550                 }
2551 
2552                 if (Scene.this.getRoot().cssFlag != CssFlags.CLEAN) {
2553                     NodeHelper.markDirty(Scene.this.getRoot(),
2554                             com.sun.javafx.scene.DirtyBits.NODE_CSS);
2555                 }
2556             }
2557 
2558             // required for image cursor created from animated image
2559             Scene.this.mouseHandler.updateCursorFrame();
2560 
2561             if (firstPulse) {
2562                 if (PerformanceTracker.isLoggingEnabled()) {
2563                     PerformanceTracker.logEvent(&quot;Scene - first repaint - layout complete&quot;);
2564                     if (PrismSettings.perfLogFirstPaintFlush) {
2565                         PerformanceTracker.outputLog();
2566                     }
2567                     if (PrismSettings.perfLogFirstPaintExit) {
2568                         System.exit(0);
2569                     }
2570                 }
2571                 firstPulse = false;
2572             }
2573 
2574             if (testPulseListener != null) {
2575                 testPulseListener.run();
2576             }
2577         }
2578     }
2579 
2580     /*******************************************************************************
2581      *                                                                             *
2582      * Scene Peer Listener                                                         *
2583      *                                                                             *
2584      ******************************************************************************/
2585 
2586     class ScenePeerListener implements TKSceneListener {
2587         @Override
2588         public void changedLocation(float x, float y) {
2589             if (x != Scene.this.getX()) {
2590                 Scene.this.setX(x);
2591             }
2592             if (y != Scene.this.getY()) {
2593                 Scene.this.setY(y);
2594             }
2595         }
2596 
2597         @Override
2598         public void changedSize(float w, float h) {
2599             if (w != Scene.this.getWidth()) Scene.this.setWidth(w);
2600             if (h != Scene.this.getHeight()) Scene.this.setHeight(h);
2601         }
2602 
2603         @Override
2604         public void mouseEvent(EventType&lt;MouseEvent&gt; type, double x, double y, double screenX, double screenY,
2605                                MouseButton button, boolean popupTrigger, boolean synthesized,
2606                                boolean shiftDown, boolean controlDown, boolean altDown, boolean metaDown,
2607                                boolean primaryDown, boolean middleDown, boolean secondaryDown,
2608                                boolean backDown, boolean forwardDown)
2609         {
2610             MouseEvent mouseEvent = new MouseEvent(type, x, y, screenX, screenY, button,
2611                     0, // click count will be adjusted by clickGenerator later anyway
2612                     shiftDown, controlDown, altDown, metaDown,
2613                     primaryDown, middleDown, secondaryDown, backDown, forwardDown,
2614                     synthesized, popupTrigger, false, null);
2615             processMouseEvent(mouseEvent);
2616         }
2617 
2618 
2619         @Override
2620         public void keyEvent(KeyEvent keyEvent)
2621         {
2622             processKeyEvent(keyEvent);
2623         }
2624 
2625         @Override
2626         public void inputMethodEvent(EventType&lt;InputMethodEvent&gt; type,
2627                                      ObservableList&lt;InputMethodTextRun&gt; composed, String committed,
2628                                      int caretPosition)
2629         {
2630             InputMethodEvent inputMethodEvent = new InputMethodEvent(
2631                type, composed, committed, caretPosition);
2632             processInputMethodEvent(inputMethodEvent);
2633         }
2634 
2635         public void menuEvent(double x, double y, double xAbs, double yAbs,
2636                 boolean isKeyboardTrigger) {
2637             Scene.this.processMenuEvent(x, y, xAbs,yAbs, isKeyboardTrigger);
2638         }
2639 
2640         @Override
2641         public void scrollEvent(
2642                 EventType&lt;ScrollEvent&gt; eventType,
2643                 double scrollX, double scrollY,
2644                 double totalScrollX, double totalScrollY,
2645                 double xMultiplier, double yMultiplier,
2646                 int touchCount,
2647                 int scrollTextX, int scrollTextY,
2648                 int defaultTextX, int defaultTextY,
2649                 double x, double y, double screenX, double screenY,
2650                 boolean _shiftDown, boolean _controlDown,
2651                 boolean _altDown, boolean _metaDown,
2652                 boolean _direct, boolean _inertia) {
2653 
2654             ScrollEvent.HorizontalTextScrollUnits xUnits = scrollTextX &gt; 0 ?
2655                     ScrollEvent.HorizontalTextScrollUnits.CHARACTERS :
2656                     ScrollEvent.HorizontalTextScrollUnits.NONE;
2657 
2658             double xText = scrollTextX &lt; 0 ? 0 : scrollTextX * scrollX;
2659 
2660             ScrollEvent.VerticalTextScrollUnits yUnits = scrollTextY &gt; 0 ?
2661                     ScrollEvent.VerticalTextScrollUnits.LINES :
2662                     (scrollTextY &lt; 0 ?
2663                         ScrollEvent.VerticalTextScrollUnits.PAGES :
2664                         ScrollEvent.VerticalTextScrollUnits.NONE);
2665 
2666             double yText = scrollTextY &lt; 0 ? scrollY : scrollTextY * scrollY;
2667 
2668             xMultiplier = defaultTextX &gt; 0 &amp;&amp; scrollTextX &gt;= 0
2669                     ? Math.round(xMultiplier * scrollTextX / defaultTextX)
2670                     : xMultiplier;
2671 
2672             yMultiplier = defaultTextY &gt; 0 &amp;&amp; scrollTextY &gt;= 0
2673                     ? Math.round(yMultiplier * scrollTextY / defaultTextY)
2674                     : yMultiplier;
2675 
2676             if (eventType == ScrollEvent.SCROLL_FINISHED) {
2677                 x = scrollGesture.sceneCoords.getX();
2678                 y = scrollGesture.sceneCoords.getY();
2679                 screenX = scrollGesture.screenCoords.getX();
2680                 screenY = scrollGesture.screenCoords.getY();
2681             } else if (Double.isNaN(x) || Double.isNaN(y) ||
2682                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2683                 if (cursorScenePos == null || cursorScreenPos == null) {
2684                     return;
2685                 }
2686                 x = cursorScenePos.getX();
2687                 y = cursorScenePos.getY();
2688                 screenX = cursorScreenPos.getX();
2689                 screenY = cursorScreenPos.getY();
2690             }
2691 
2692             inMousePick = true;
2693             Scene.this.processGestureEvent(new ScrollEvent(
2694                     eventType,
2695                     x, y, screenX, screenY,
2696                     _shiftDown, _controlDown, _altDown, _metaDown,
2697                     _direct, _inertia,
2698                     scrollX * xMultiplier, scrollY * yMultiplier,
2699                     totalScrollX * xMultiplier, totalScrollY * yMultiplier,
2700                     xMultiplier, yMultiplier,
2701                     xUnits, xText, yUnits, yText, touchCount, pick(x, y)),
2702                     scrollGesture);
2703             inMousePick = false;
2704         }
2705 
2706         @Override
2707         public void zoomEvent(
2708                 EventType&lt;ZoomEvent&gt; eventType,
2709                 double zoomFactor, double totalZoomFactor,
2710                 double x, double y, double screenX, double screenY,
2711                 boolean _shiftDown, boolean _controlDown,
2712                 boolean _altDown, boolean _metaDown,
2713                 boolean _direct, boolean _inertia) {
2714 
2715             if (eventType == ZoomEvent.ZOOM_FINISHED) {
2716                 x = zoomGesture.sceneCoords.getX();
2717                 y = zoomGesture.sceneCoords.getY();
2718                 screenX = zoomGesture.screenCoords.getX();
2719                 screenY = zoomGesture.screenCoords.getY();
2720             } else if (Double.isNaN(x) || Double.isNaN(y) ||
2721                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2722                 if (cursorScenePos == null || cursorScreenPos == null) {
2723                     return;
2724                 }
2725                 x = cursorScenePos.getX();
2726                 y = cursorScenePos.getY();
2727                 screenX = cursorScreenPos.getX();
2728                 screenY = cursorScreenPos.getY();
2729             }
2730 
2731             inMousePick = true;
2732             Scene.this.processGestureEvent(new ZoomEvent(eventType,
2733                     x, y, screenX, screenY,
2734                     _shiftDown, _controlDown, _altDown, _metaDown,
2735                     _direct, _inertia,
2736                     zoomFactor, totalZoomFactor, pick(x, y)),
2737                     zoomGesture);
2738             inMousePick = false;
2739         }
2740 
2741         @Override
2742         public void rotateEvent(
2743                 EventType&lt;RotateEvent&gt; eventType, double angle, double totalAngle,
2744                 double x, double y, double screenX, double screenY,
2745                 boolean _shiftDown, boolean _controlDown,
2746                 boolean _altDown, boolean _metaDown,
2747                 boolean _direct, boolean _inertia) {
2748 
2749             if (eventType == RotateEvent.ROTATION_FINISHED) {
2750                 x = rotateGesture.sceneCoords.getX();
2751                 y = rotateGesture.sceneCoords.getY();
2752                 screenX = rotateGesture.screenCoords.getX();
2753                 screenY = rotateGesture.screenCoords.getY();
2754             } else if (Double.isNaN(x) || Double.isNaN(y) ||
2755                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2756                 if (cursorScenePos == null || cursorScreenPos == null) {
2757                     return;
2758                 }
2759                 x = cursorScenePos.getX();
2760                 y = cursorScenePos.getY();
2761                 screenX = cursorScreenPos.getX();
2762                 screenY = cursorScreenPos.getY();
2763             }
2764 
2765             inMousePick = true;
2766             Scene.this.processGestureEvent(new RotateEvent(
2767                     eventType, x, y, screenX, screenY,
2768                     _shiftDown, _controlDown, _altDown, _metaDown,
2769                     _direct, _inertia, angle, totalAngle, pick(x, y)),
2770                     rotateGesture);
2771             inMousePick = false;
2772 
2773         }
2774 
2775         @Override
2776         public void swipeEvent(
2777                 EventType&lt;SwipeEvent&gt; eventType, int touchCount,
2778                 double x, double y, double screenX, double screenY,
2779                 boolean _shiftDown, boolean _controlDown,
2780                 boolean _altDown, boolean _metaDown, boolean _direct) {
2781 
2782             if (Double.isNaN(x) || Double.isNaN(y) ||
2783                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2784                 if (cursorScenePos == null || cursorScreenPos == null) {
2785                     return;
2786                 }
2787                 x = cursorScenePos.getX();
2788                 y = cursorScenePos.getY();
2789                 screenX = cursorScreenPos.getX();
2790                 screenY = cursorScreenPos.getY();
2791             }
2792 
2793             inMousePick = true;
2794             Scene.this.processGestureEvent(new SwipeEvent(
2795                     eventType, x, y, screenX, screenY,
2796                     _shiftDown, _controlDown, _altDown, _metaDown, _direct,
2797                     touchCount, pick(x, y)),
2798                     swipeGesture);
2799             inMousePick = false;
2800         }
2801 
2802         @Override
2803         public void touchEventBegin(
2804                 long time, int touchCount, boolean isDirect,
2805                 boolean _shiftDown, boolean _controlDown,
2806                 boolean _altDown, boolean _metaDown) {
2807 
2808             if (!isDirect) {
2809                 nextTouchEvent = null;
2810                 return;
2811             }
2812             nextTouchEvent = new TouchEvent(
2813                     TouchEvent.ANY, null, null, 0,
2814                     _shiftDown, _controlDown, _altDown, _metaDown);
2815             if (touchPoints == null || touchPoints.length != touchCount) {
2816                 touchPoints = new TouchPoint[touchCount];
2817             }
2818             touchPointIndex = 0;
2819         }
2820 
2821         @Override
2822         public void touchEventNext(
2823                 TouchPoint.State state, long touchId,
2824                 double x, double y, double screenX, double screenY) {
2825 
2826             inMousePick = true;
2827             if (nextTouchEvent == null) {
2828                 // ignore indirect touch events
2829                 return;
2830             }
2831             touchPointIndex++;
2832             int id = (state == TouchPoint.State.PRESSED
2833                     ? touchMap.add(touchId) :  touchMap.get(touchId));
2834             if (state == TouchPoint.State.RELEASED) {
2835                 touchMap.remove(touchId);
2836             }
2837             int order = touchMap.getOrder(id);
2838 
2839             if (order &gt;= touchPoints.length) {
2840                 throw new RuntimeException(&quot;Too many touch points reported&quot;);
2841             }
2842 
2843             // pick target
2844             boolean isGrabbed = false;
2845             PickResult pickRes = pick(x, y);
2846             EventTarget pickedTarget = touchTargets.get(id);
2847             if (pickedTarget == null) {
2848                 pickedTarget = pickRes.getIntersectedNode();
2849                 if (pickedTarget == null) {
2850                     pickedTarget = Scene.this;
2851                 }
2852             } else {
2853                 isGrabbed = true;
2854             }
2855 
2856             TouchPoint tp = new TouchPoint(id, state,
2857                     x, y, screenX, screenY, pickedTarget, pickRes);
2858 
2859             touchPoints[order] = tp;
2860 
2861             if (isGrabbed) {
2862                 tp.grab(pickedTarget);
2863             }
2864             if (tp.getState() == TouchPoint.State.PRESSED) {
2865                 tp.grab(pickedTarget);
2866                 touchTargets.put(tp.getId(), pickedTarget);
2867             } else if (tp.getState() == TouchPoint.State.RELEASED) {
2868                 touchTargets.remove(tp.getId());
2869             }
2870             inMousePick = false;
2871         }
2872 
2873         @Override
2874         public void touchEventEnd() {
2875             if (nextTouchEvent == null) {
2876                 // ignore indirect touch events
2877                 return;
2878             }
2879 
2880             if (touchPointIndex != touchPoints.length) {
2881                 throw new RuntimeException(&quot;Wrong number of touch points reported&quot;);
2882             }
2883 
2884             Scene.this.processTouchEvent(nextTouchEvent, touchPoints);
2885 
2886             if (touchMap.cleanup()) {
2887                 // gesture finished
2888                 touchEventSetId = 0;
2889             }
2890         }
2891 
2892         @Override
2893         public Accessible getSceneAccessible() {
2894             return getAccessible();
2895         }
2896     }
2897 
2898     private class ScenePeerPaintListener implements TKScenePaintListener {
2899         @Override
2900         public void frameRendered() {
2901             // must use tracker with synchronization since this method is called on render thread
2902             synchronized (trackerMonitor) {
2903                 if (Scene.this.tracker != null) {
2904                     Scene.this.tracker.frameRendered();
2905                 }
2906             }
2907         }
2908     }
2909 
2910     /*******************************************************************************
2911      *                                                                             *
2912      * Drag and Drop                                                               *
2913      *                                                                             *
2914      ******************************************************************************/
2915 
2916     class DropTargetListener implements TKDropTargetListener {
2917 
2918         /*
2919          * This function is called when an drag operation enters a valid drop target.
2920          * This may be from either an internal or external dnd operation.
2921          */
2922         @Override
2923         public TransferMode dragEnter(double x, double y, double screenX, double screenY,
2924                                       TransferMode transferMode, TKClipboard dragboard)
2925         {
2926             if (dndGesture == null) {
2927                 dndGesture = new DnDGesture();
2928             }
2929             Dragboard db = DragboardHelper.createDragboard(dragboard);
2930             dndGesture.dragboard = db;
2931             DragEvent dragEvent =
2932                     new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2933                             transferMode, null, null, pick(x, y));
2934             return dndGesture.processTargetEnterOver(dragEvent);
2935         }
2936 
2937         @Override
2938         public TransferMode dragOver(double x, double y, double screenX, double screenY,
2939                                      TransferMode transferMode)
2940         {
2941             if (Scene.this.dndGesture == null) {
2942                 System.err.println(&quot;GOT A dragOver when dndGesture is null!&quot;);
2943                 return null;
2944             } else {
2945                 if (dndGesture.dragboard == null) {
2946                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragOver&quot;);
2947                 }
2948                 DragEvent dragEvent =
2949                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2950                                 transferMode, null, null, pick(x, y));
2951                 return dndGesture.processTargetEnterOver(dragEvent);
2952             }
2953         }
2954 
2955         @Override
2956         public void dragExit(double x, double y, double screenX, double screenY) {
2957             if (dndGesture == null) {
2958                 System.err.println(&quot;GOT A dragExit when dndGesture is null!&quot;);
2959             } else {
2960                 if (dndGesture.dragboard == null) {
2961                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragExit&quot;);
2962                 }
2963                 DragEvent dragEvent =
2964                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2965                                 null, null, null, pick(x, y));
2966                 dndGesture.processTargetExit(dragEvent);
2967                 if (dndGesture.source == null) {
2968                     dndGesture.dragboard = null;
2969                     dndGesture = null;
2970                 }
2971             }
2972         }
2973 
2974 
2975         @Override
2976         public TransferMode drop(double x, double y, double screenX, double screenY,
2977                                   TransferMode transferMode)
2978         {
2979             if (dndGesture == null) {
2980                 System.err.println(&quot;GOT A drop when dndGesture is null!&quot;);
2981                 return null;
2982             } else {
2983                 if (dndGesture.dragboard == null) {
2984                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDrop&quot;);
2985                 }
2986                 DragEvent dragEvent =
2987                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2988                                 transferMode, null, null, pick(x, y));
2989                 // Data dropped to the app can be accessed without restriction
2990                 DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);
2991 
2992                 TransferMode tm;
2993                 try {
2994                     tm = dndGesture.processTargetDrop(dragEvent);
2995                 } finally {
2996                     DragboardHelper.setDataAccessRestriction(
2997                             dndGesture.dragboard, true);
2998                 }
2999 
3000                 if (dndGesture.source == null) {
3001                     dndGesture.dragboard = null;
3002                     dndGesture = null;
3003                 }
3004                 return tm;
3005             }
3006         }
3007     }
3008 
3009     class DragGestureListener implements TKDragGestureListener {
3010 
3011        @Override
3012        public void dragGestureRecognized(double x, double y, double screenX, double screenY,
3013                                          int button, TKClipboard dragboard)
3014        {
3015            Dragboard db = DragboardHelper.createDragboard(dragboard);
3016            dndGesture = new DnDGesture();
3017            dndGesture.dragboard = db;
3018            // TODO: support mouse buttons in DragEvent
3019            DragEvent dragEvent = new DragEvent(DragEvent.ANY, db, x, y, screenX, screenY,
3020                    null, null, null, pick(x, y));
3021            dndGesture.processRecognized(dragEvent);
3022            dndGesture = null;
3023         }
3024     }
3025 
3026     /**
3027      * A Drag and Drop gesture has a lifespan that lasts from mouse
3028      * PRESSED event to mouse RELEASED event.
3029      */
3030     class DnDGesture {
3031         private final double hysteresisSizeX =
3032                 Toolkit.getToolkit().getMultiClickMaxX();
3033         private final double hysteresisSizeY =
3034                 Toolkit.getToolkit().getMultiClickMaxY();
3035 
3036         private EventTarget source = null;
3037         private Set&lt;TransferMode&gt; sourceTransferModes = null;
3038         private TransferMode acceptedTransferMode = null;
3039         private Dragboard dragboard = null;
3040         private EventTarget potentialTarget = null;
3041         private EventTarget target = null;
3042         private DragDetectedState dragDetected = DragDetectedState.NOT_YET;
3043         private double pressedX;
3044         private double pressedY;
3045         private List&lt;EventTarget&gt; currentTargets = new ArrayList&lt;EventTarget&gt;();
3046         private List&lt;EventTarget&gt; newTargets = new ArrayList&lt;EventTarget&gt;();
3047         private EventTarget fullPDRSource = null;
3048 
3049         /**
3050          * Fires event on a given target or on scene if the node is null
3051          */
3052         private void fireEvent(EventTarget target, Event e) {
3053             if (target != null) {
3054                 Event.fireEvent(target, e);
3055             }
3056         }
3057 
3058         /**
3059          * Called when DRAG_DETECTED event is going to be processed by
3060          * application
3061          */
3062         private void processingDragDetected() {
3063             dragDetected = DragDetectedState.PROCESSING;
3064         }
3065 
3066         /**
3067          * Called after DRAG_DETECTED event has been processed by application
3068          */
3069         private void dragDetectedProcessed() {
3070             dragDetected = DragDetectedState.DONE;
3071             final boolean hasContent = (dragboard != null) &amp;&amp; (ClipboardHelper.contentPut(dragboard));
3072             if (hasContent) {
3073                 /* start DnD */
3074                 Toolkit.getToolkit().startDrag(Scene.this.peer,
3075                                                 sourceTransferModes,
3076                                                 new DragSourceListener(),
3077                                                 dragboard);
3078             } else if (fullPDRSource != null) {
3079                 /* start PDR */
3080                 Scene.this.mouseHandler.enterFullPDR(fullPDRSource);
3081             }
3082 
3083             fullPDRSource = null;
3084         }
3085 
3086         /**
3087          * Sets the default dragDetect value
3088          */
3089         private void processDragDetection(MouseEvent mouseEvent) {
3090 
3091             if (dragDetected != DragDetectedState.NOT_YET) {
3092                 mouseEvent.setDragDetect(false);
3093                 return;
3094             }
3095 
3096             if (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED) {
3097                 pressedX = mouseEvent.getSceneX();
3098                 pressedY = mouseEvent.getSceneY();
3099 
3100                 mouseEvent.setDragDetect(false);
3101 
3102             } else if (mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) {
3103 
3104                 double deltaX = Math.abs(mouseEvent.getSceneX() - pressedX);
3105                 double deltaY = Math.abs(mouseEvent.getSceneY() - pressedY);
3106                 mouseEvent.setDragDetect(deltaX &gt; hysteresisSizeX ||
3107                                          deltaY &gt; hysteresisSizeY);
3108 
3109             }
3110         }
3111 
3112         /**
3113          * This function is useful for drag gesture recognition from
3114          * within this Scene (as opposed to in the TK implementation... by the platform)
3115          */
3116         private boolean process(MouseEvent mouseEvent, EventTarget target) {
3117             boolean continueProcessing = true;
3118             if (!PLATFORM_DRAG_GESTURE_INITIATION) {
3119 
3120                 if (dragDetected != DragDetectedState.DONE &amp;&amp;
3121                         (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED ||
3122                         mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) &amp;&amp;
3123                         mouseEvent.isDragDetect()) {
3124 
3125                     processingDragDetected();
3126 
3127                     if (target != null) {
3128                         final MouseEvent detectedEvent = mouseEvent.copyFor(
3129                                 mouseEvent.getSource(), target,
3130                                 MouseEvent.DRAG_DETECTED);
3131 
3132                         try {
3133                             fireEvent(target, detectedEvent);
3134                         } finally {
3135                             // Putting data to dragboard finished, restrict access to them
3136                             if (dragboard != null) {
3137                                 DragboardHelper.setDataAccessRestriction(
3138                                         dragboard, true);
3139                             }
3140                         }
3141                     }
3142 
3143                     dragDetectedProcessed();
3144                 }
3145 
3146                 if (mouseEvent.getEventType() == MouseEvent.MOUSE_RELEASED) {
3147                     continueProcessing = false;
3148                 }
3149             }
3150             return continueProcessing;
3151         }
3152 
3153         /*
3154          * Called when a drag source is recognized. This occurs at the very start of
3155          * the publicly visible drag and drop API, as it is responsible for calling
3156          * the Node.onDragSourceRecognized function.
3157          */
3158         private boolean processRecognized(DragEvent de) {
3159             MouseEvent me = new MouseEvent(
3160                     MouseEvent.DRAG_DETECTED, de.getX(), de.getY(),
3161                     de.getSceneX(), de.getScreenY(), MouseButton.PRIMARY, 1,
3162                     false, false, false, false, false, true, false, false, false,
3163                     false, de.getPickResult());
3164 
3165             processingDragDetected();
3166 
3167             final EventTarget target = de.getPickResult().getIntersectedNode();
3168             try {
3169                 fireEvent(target != null ? target : Scene.this, me);
3170             } finally {
3171                 // Putting data to dragboard finished, restrict access to them
3172                 if (dragboard != null) {
3173                     DragboardHelper.setDataAccessRestriction(
3174                             dragboard, true);
3175                 }
3176             }
3177 
3178             dragDetectedProcessed();
3179 
3180             final boolean hasContent = dragboard != null
3181                     &amp;&amp; !dragboard.getContentTypes().isEmpty();
3182             return hasContent;
3183         }
3184 
3185         private void processDropEnd(DragEvent de) {
3186             if (source == null) {
3187                 System.out.println(&quot;Scene.DnDGesture.processDropEnd() - UNEXPECTD - source is NULL&quot;);
3188                 return;
3189             }
3190 
3191             de = new DragEvent(de.getSource(), source, DragEvent.DRAG_DONE,
3192                     de.getDragboard(), de.getSceneX(), de.getSceneY(),
3193                     de.getScreenX(), de.getScreenY(),
3194                     de.getTransferMode(), source, target, de.getPickResult());
3195 
3196             Event.fireEvent(source, de);
3197 
3198             tmpTargetWrapper.clear();
3199             handleExitEnter(de, tmpTargetWrapper);
3200 
3201             // at this point the drag and drop operation is completely over, so we
3202             // can tell the toolkit that it can clean up if needs be.
3203             Toolkit.getToolkit().stopDrag(dragboard);
3204         }
3205 
3206         private TransferMode processTargetEnterOver(DragEvent de) {
3207             pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
3208             final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();
3209 
3210             if (dragboard == null) {
3211                 dragboard = createDragboard(de, false);
3212             }
3213 
3214             de = new DragEvent(de.getSource(), pickedTarget, de.getEventType(),
3215                     dragboard, de.getSceneX(), de.getSceneY(),
3216                     de.getScreenX(), de.getScreenY(),
3217                     de.getTransferMode(), source, potentialTarget, de.getPickResult());
3218 
3219             handleExitEnter(de, tmpTargetWrapper);
3220 
3221             de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_OVER,
3222                     de.getDragboard(), de.getSceneX(), de.getSceneY(),
3223                     de.getScreenX(), de.getScreenY(),
3224                     de.getTransferMode(), source, potentialTarget, de.getPickResult());
3225 
3226             fireEvent(pickedTarget, de);
3227 
3228             Object acceptingObject = de.getAcceptingObject();
3229             potentialTarget = acceptingObject instanceof EventTarget
3230                     ? (EventTarget) acceptingObject : null;
3231             acceptedTransferMode = de.getAcceptedTransferMode();
3232             return acceptedTransferMode;
3233         }
3234 
3235         private void processTargetActionChanged(DragEvent de) {
3236             // Do we want DRAG_TRANSFER_MODE_CHANGED event?
3237 //            final Node pickedNode = Scene.this.mouseHandler.pickNode(de.getX(), de.getY());
3238 //            if (pickedNode != null &amp;&amp; pickedNode.isTreeVisible()) {
3239 //                de = DragEvent.copy(de.getSource(), pickedNode, source,
3240 //                        pickedNode, de, DragEvent.DRAG_TRANSFER_MODE_CHANGED);
3241 //
3242 //                if (dragboard == null) {
3243 //                    dragboard = createDragboard(de);
3244 //                }
3245 //                dragboard = de.getPlatformDragboard();
3246 //
3247 //                fireEvent(pickedNode, de);
3248 //            }
3249         }
3250 
3251         private void processTargetExit(DragEvent de) {
3252             if (dragboard == null) {
3253                 // dragboard should have been created in processTargetEnterOver()
3254                 throw new NullPointerException(&quot;dragboard is null in processTargetExit()&quot;);
3255             }
3256 
3257             if (currentTargets.size() &gt; 0) {
3258                 potentialTarget = null;
3259                 tmpTargetWrapper.clear();
3260                 handleExitEnter(de, tmpTargetWrapper);
3261             }
3262         }
3263 
3264         private TransferMode processTargetDrop(DragEvent de) {
3265             pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
3266             final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();
3267 
3268             de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_DROPPED,
3269                     de.getDragboard(), de.getSceneX(), de.getSceneY(),
3270                     de.getScreenX(), de.getScreenY(),
3271                     acceptedTransferMode, source, potentialTarget, de.getPickResult());
3272 
3273             if (dragboard == null) {
3274                 // dragboard should have been created in processTargetEnterOver()
3275                 throw new NullPointerException(&quot;dragboard is null in processTargetDrop()&quot;);
3276             }
3277 
3278             handleExitEnter(de, tmpTargetWrapper);
3279 
3280             fireEvent(pickedTarget, de);
3281 
3282             Object acceptingObject = de.getAcceptingObject();
3283             potentialTarget = acceptingObject instanceof EventTarget
3284                     ? (EventTarget) acceptingObject : null;
3285             target = potentialTarget;
3286 
3287             TransferMode result = de.isDropCompleted() ?
3288                 de.getAcceptedTransferMode() : null;
3289 
3290             tmpTargetWrapper.clear();
3291             handleExitEnter(de, tmpTargetWrapper);
3292 
3293             return result;
3294         }
3295 
3296         private void handleExitEnter(DragEvent e, TargetWrapper target) {
3297             EventTarget currentTarget =
3298                     currentTargets.size() &gt; 0 ? currentTargets.get(0) : null;
3299 
3300             if (target.getEventTarget() != currentTarget) {
3301 
3302                 target.fillHierarchy(newTargets);
3303 
3304                 int i = currentTargets.size() - 1;
3305                 int j = newTargets.size() - 1;
3306 
3307                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentTargets.get(i) == newTargets.get(j)) {
3308                     i--;
3309                     j--;
3310                 }
3311 
3312                 for (; i &gt;= 0; i--) {
3313                     EventTarget t = currentTargets.get(i);
3314                     if (potentialTarget == t) {
3315                         potentialTarget = null;
3316                     }
3317                     e = e.copyFor(e.getSource(), t, source,
3318                             potentialTarget, DragEvent.DRAG_EXITED_TARGET);
3319                     Event.fireEvent(t, e);
3320                 }
3321 
3322                 potentialTarget = null;
3323                 for (; j &gt;= 0; j--) {
3324                     EventTarget t = newTargets.get(j);
3325                     e = e.copyFor(e.getSource(), t, source,
3326                             potentialTarget, DragEvent.DRAG_ENTERED_TARGET);
3327                     Object acceptingObject = e.getAcceptingObject();
3328                     if (acceptingObject instanceof EventTarget) {
3329                         potentialTarget = (EventTarget) acceptingObject;
3330                     }
3331                     Event.fireEvent(t, e);
3332                 }
3333 
3334                 currentTargets.clear();
3335                 currentTargets.addAll(newTargets);
3336                 newTargets.clear();
3337             }
3338         }
3339 
3340 //        function getIntendedTransferMode(e:MouseEvent):TransferMode {
3341 //            return if (e.altDown) TransferMode.COPY else TransferMode.MOVE;
3342 //        }
3343 
3344         /*
3345          * Function that hooks into the key processing code in Scene to handle the
3346          * situation where a drag and drop event is taking place and the user presses
3347          * the escape key to cancel the drag and drop operation.
3348          */
3349         private boolean processKey(KeyEvent e) {
3350             //note: this seems not to be called, the DnD cancelation is provided by platform
3351             if ((e.getEventType() == KeyEvent.KEY_PRESSED) &amp;&amp; (e.getCode() == KeyCode.ESCAPE)) {
3352 
3353                 // cancel drag and drop
3354                 DragEvent de = new DragEvent(
3355                         source, source, DragEvent.DRAG_DONE, dragboard, 0, 0, 0, 0,
3356                         null, source, null, null);
3357                 if (source != null) {
3358                     Event.fireEvent(source, de);
3359                 }
3360 
3361                 tmpTargetWrapper.clear();
3362                 handleExitEnter(de, tmpTargetWrapper);
3363 
3364                 return false;
3365             }
3366             return true;
3367         }
3368 
3369         /*
3370          * This starts the drag gesture running, creating the dragboard used for
3371          * the remainder of this drag and drop operation.
3372          */
3373         private Dragboard startDrag(EventTarget source, Set&lt;TransferMode&gt; t) {
3374             if (dragDetected != DragDetectedState.PROCESSING) {
3375                 throw new IllegalStateException(&quot;Cannot start drag and drop &quot;
3376                         + &quot;outside of DRAG_DETECTED event handler&quot;);
3377             }
3378 
3379             if (t.isEmpty()) {
3380                 dragboard = null;
3381             } else if (dragboard == null) {
3382                 dragboard = createDragboard(null, true);
3383             }
3384 
3385             // The app can see what it puts to dragboard without restriction
3386             DragboardHelper.setDataAccessRestriction(dragboard, false);
3387 
3388             this.source = source;
3389             potentialTarget = source;
3390             sourceTransferModes = t;
3391             return dragboard;
3392         }
3393 
3394         /*
3395          * This starts the full PDR gesture.
3396          */
3397         private void startFullPDR(EventTarget source) {
3398             fullPDRSource = source;
3399         }
3400 
3401         private Dragboard createDragboard(final DragEvent de, boolean isDragSource) {
3402             Dragboard dragboard = null;
3403             if (de != null) {
3404                 dragboard = de.getDragboard();
3405                 if (dragboard != null) {
3406                     return dragboard;
3407                 }
3408             }
3409             TKClipboard dragboardPeer = peer.createDragboard(isDragSource);
3410             return DragboardHelper.createDragboard(dragboardPeer);
3411         }
3412     }
3413 
3414     /**
3415      * State of a drag gesture with regards to DRAG_DETECTED event.
3416      */
3417     private enum DragDetectedState {
3418         NOT_YET,
3419         PROCESSING,
3420         DONE
3421     }
3422 
3423     class DragSourceListener implements TKDragSourceListener {
3424 
3425         @Override
3426         public void dragDropEnd(double x, double y, double screenX, double screenY,
3427                                 TransferMode transferMode)
3428         {
3429             if (dndGesture != null) {
3430                 if (dndGesture.dragboard == null) {
3431                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDropEnd&quot;);
3432                 }
3433                 DragEvent dragEvent =
3434                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
3435                         transferMode, null, null, null);
3436 
3437                 // DRAG_DONE event is delivered to gesture source, it can access
3438                 // its own data without restriction
3439                 DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);
3440                 try {
3441                     dndGesture.processDropEnd(dragEvent);
3442                 } finally {
3443                     DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, true);
3444                 }
3445                 dndGesture = null;
3446             }
3447         }
3448     }
3449 
3450     /*******************************************************************************
3451      *                                                                             *
3452      * Mouse Event Handling                                                        *
3453      *                                                                             *
3454      ******************************************************************************/
3455 
3456     static class ClickCounter {
3457         Toolkit toolkit = Toolkit.getToolkit();
3458         private int count;
3459         private boolean out;
3460         private boolean still;
3461         private Timeline timeout;
3462         private double pressedX, pressedY;
3463 
3464         private void inc() { count++; }
3465         private int get() { return count; }
3466         private boolean isStill() { return still; }
3467 
3468         private void clear() {
3469             count = 0;
3470             stopTimeout();
3471         }
3472 
3473         private void out() {
3474             out = true;
3475             stopTimeout();
3476         }
3477 
3478         private void applyOut() {
3479             if (out) clear();
3480             out = false;
3481         }
3482 
3483         private void moved(double x, double y) {
3484             if (Math.abs(x - pressedX) &gt; toolkit.getMultiClickMaxX() ||
3485                     Math.abs(y - pressedY) &gt; toolkit.getMultiClickMaxY()) {
3486                 out();
3487                 still = false;
3488             }
3489         }
3490 
3491         private void start(double x, double y) {
3492             pressedX = x;
3493             pressedY = y;
3494             out = false;
3495 
3496             if (timeout != null) {
3497                 timeout.stop();
3498             }
3499             timeout = new Timeline();
3500             timeout.getKeyFrames().add(
3501                     new KeyFrame(new Duration(toolkit.getMultiClickTime()),
3502                             event -&gt; {
3503                                 out = true;
3504                                 timeout = null;
3505                             }
3506                     ));
3507             timeout.play();
3508             still = true;
3509         }
3510 
3511         private void stopTimeout() {
3512             if (timeout != null) {
3513                 timeout.stop();
3514                 timeout = null;
3515             }
3516         }
3517     }
3518 
3519     static class ClickGenerator {
3520         private ClickCounter lastPress = null;
3521 
3522         private Map&lt;MouseButton, ClickCounter&gt; counters =
3523                 new EnumMap&lt;MouseButton, ClickCounter&gt;(MouseButton.class);
3524         private List&lt;EventTarget&gt; pressedTargets = new ArrayList&lt;EventTarget&gt;();
3525         private List&lt;EventTarget&gt; releasedTargets = new ArrayList&lt;EventTarget&gt;();
3526 
3527         public ClickGenerator() {
3528             for (MouseButton mb : MouseButton.values()) {
3529                 if (mb != MouseButton.NONE) {
3530                     counters.put(mb, new ClickCounter());
3531                 }
3532             }
3533         }
3534 
3535         private MouseEvent preProcess(MouseEvent e) {
3536             for (ClickCounter cc : counters.values()) {
3537                 cc.moved(e.getSceneX(), e.getSceneY());
3538             }
3539 
3540             ClickCounter cc = counters.get(e.getButton());
3541             boolean still = lastPress != null ? lastPress.isStill() : false;
3542 
3543             if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {
3544 
3545                 if (! e.isPrimaryButtonDown()) { counters.get(MouseButton.PRIMARY).clear(); }
3546                 if (! e.isSecondaryButtonDown()) { counters.get(MouseButton.SECONDARY).clear(); }
3547                 if (! e.isMiddleButtonDown()) { counters.get(MouseButton.MIDDLE).clear(); }
3548                 if (! e.isBackButtonDown()) { counters.get(MouseButton.BACK).clear(); }
3549                 if (! e.isForwardButtonDown()) { counters.get(MouseButton.FORWARD).clear(); }
3550                 cc.applyOut();
3551                 cc.inc();
3552                 cc.start(e.getSceneX(), e.getSceneY());
3553                 lastPress = cc;
3554             }
3555 
3556             return new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
3557                     e.getScreenX(), e.getScreenY(), e.getButton(),
3558                     cc != null &amp;&amp; e.getEventType() != MouseEvent.MOUSE_MOVED ? cc.get() : 0,
3559                     e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
3560                     e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
3561                     e.isBackButtonDown(), e.isForwardButtonDown(),
3562                     e.isSynthesized(), e.isPopupTrigger(), still, e.getPickResult());
3563         }
3564 
3565         private void postProcess(MouseEvent e, TargetWrapper target, TargetWrapper pickedTarget) {
3566 
3567             if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
3568                 ClickCounter cc = counters.get(e.getButton());
3569 
3570                 target.fillHierarchy(pressedTargets);
3571                 pickedTarget.fillHierarchy(releasedTargets);
3572                 int i = pressedTargets.size() - 1;
3573                 int j = releasedTargets.size() - 1;
3574 
3575                 EventTarget clickedTarget = null;
3576                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; pressedTargets.get(i) == releasedTargets.get(j)) {
3577                     clickedTarget = pressedTargets.get(i);
3578                     i--;
3579                     j--;
3580                 }
3581 
3582                 pressedTargets.clear();
3583                 releasedTargets.clear();
3584 
3585                 if (clickedTarget != null &amp;&amp; lastPress != null) {
3586                     MouseEvent click = new MouseEvent(null, clickedTarget,
3587                             MouseEvent.MOUSE_CLICKED, e.getSceneX(), e.getSceneY(),
3588                             e.getScreenX(), e.getScreenY(), e.getButton(),
3589                             cc.get(),
3590                             e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
3591                             e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
3592                             e.isBackButtonDown(), e.isForwardButtonDown(),
3593                             e.isSynthesized(), e.isPopupTrigger(), lastPress.isStill(), e.getPickResult());
3594                     Event.fireEvent(clickedTarget, click);
3595                 }
3596             }
3597         }
3598     }
3599 
3600     /**
3601      * Generates mouse exited event for a node which is going to be removed
3602      * and its children, where appropriate.
3603      * @param removing Node which is going to be removed
3604      */
3605     void generateMouseExited(Node removing) {
3606         mouseHandler.handleNodeRemoval(removing);
3607     }
3608 
3609     class MouseHandler {
3610         private TargetWrapper pdrEventTarget = new TargetWrapper(); // pdr - press-drag-release
3611         private boolean pdrInProgress = false;
3612         private boolean fullPDREntered = false;
3613 
3614         private EventTarget currentEventTarget = null;
3615         private MouseEvent lastEvent;
3616         private boolean hover = false;
3617 
3618         private boolean primaryButtonDown = false;
3619         private boolean secondaryButtonDown = false;
3620         private boolean middleButtonDown = false;
3621         private boolean backButtonDown = false;
3622         private boolean forwardButtonDown = false;
3623 
3624         private EventTarget fullPDRSource = null;
3625         private TargetWrapper fullPDRTmpTargetWrapper = new TargetWrapper();
3626 
3627         /* lists needed for enter/exit events generation */
3628         private final List&lt;EventTarget&gt; pdrEventTargets = new ArrayList&lt;EventTarget&gt;();
3629         private final List&lt;EventTarget&gt; currentEventTargets = new ArrayList&lt;EventTarget&gt;();
3630         private final List&lt;EventTarget&gt; newEventTargets = new ArrayList&lt;EventTarget&gt;();
3631 
3632         private final List&lt;EventTarget&gt; fullPDRCurrentEventTargets = new ArrayList&lt;EventTarget&gt;();
3633         private final List&lt;EventTarget&gt; fullPDRNewEventTargets = new ArrayList&lt;EventTarget&gt;();
3634         private EventTarget fullPDRCurrentTarget = null;
3635 
3636         private Cursor currCursor;
3637         private CursorFrame currCursorFrame;
3638         private EventQueue queue = new EventQueue();
3639 
3640         private Runnable pickProcess = new Runnable() {
3641 
3642             @Override
3643             public void run() {
3644                 // Make sure this is run only if the peer is still alive
3645                 // and there is an event to deliver
3646                 if (Scene.this.peer != null &amp;&amp; lastEvent != null) {
3647                     process(lastEvent, true);
3648                 }
3649             }
3650         };
3651 
3652         private void pulse() {
3653             if (hover &amp;&amp; lastEvent != null) {
3654                 //Shouldn&#39;t run user code directly. User can call stage.showAndWait() and block the pulse.
3655                 Platform.runLater(pickProcess);
3656             }
3657         }
3658 
3659         private void clearPDREventTargets() {
3660             pdrInProgress = false;
3661             currentEventTarget = currentEventTargets.size() &gt; 0
3662                     ? currentEventTargets.get(0) : null;
3663             pdrEventTarget.clear();
3664         }
3665 
3666         public void enterFullPDR(EventTarget gestureSource) {
3667             fullPDREntered = true;
3668             fullPDRSource = gestureSource;
3669             fullPDRCurrentTarget = null;
3670             fullPDRCurrentEventTargets.clear();
3671         }
3672 
3673         public void exitFullPDR(MouseEvent e) {
3674             if (!fullPDREntered) {
3675                 return;
3676             }
3677             fullPDREntered = false;
3678             for (int i = fullPDRCurrentEventTargets.size() - 1; i &gt;= 0; i--) {
3679                 EventTarget entered = fullPDRCurrentEventTargets.get(i);
3680                 Event.fireEvent(entered, MouseEvent.copyForMouseDragEvent(e,
3681                         entered, entered,
3682                         MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
3683                         fullPDRSource, e.getPickResult()));
3684             }
3685             fullPDRSource = null;
3686             fullPDRCurrentEventTargets.clear();
3687             fullPDRCurrentTarget = null;
3688         }
3689 
3690         private void handleNodeRemoval(Node removing) {
3691             if (lastEvent == null) {
3692                 // this can happen only if everything has been exited anyway
3693                 return;
3694             }
3695 
3696 
3697             if (currentEventTargets.contains(removing)) {
3698                 int i = 0;
3699                 EventTarget trg = null;
3700                 while(trg != removing) {
3701                     trg = currentEventTargets.get(i++);
3702 
3703                     queue.postEvent(lastEvent.copyFor(trg, trg,
3704                             MouseEvent.MOUSE_EXITED_TARGET));
3705                 }
3706                 currentEventTargets.subList(0, i).clear();
3707             }
3708 
3709             if (fullPDREntered &amp;&amp; fullPDRCurrentEventTargets.contains(removing)) {
3710                 int i = 0;
3711                 EventTarget trg = null;
3712                 while (trg != removing) {
3713                     trg = fullPDRCurrentEventTargets.get(i++);
3714 
3715                     queue.postEvent(
3716                             MouseEvent.copyForMouseDragEvent(lastEvent, trg, trg,
3717                             MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
3718                             fullPDRSource, lastEvent.getPickResult()));
3719                 }
3720 
3721                 fullPDRCurrentEventTargets.subList(0, i).clear();
3722             }
3723 
3724             queue.fire();
3725 
3726             if (pdrInProgress &amp;&amp; pdrEventTargets.contains(removing)) {
3727                 int i = 0;
3728                 EventTarget trg = null;
3729                 while (trg != removing) {
3730                     trg = pdrEventTargets.get(i++);
3731 
3732                     // trg.setHover(false) - already taken care of
3733                     // by the code above which sent a mouse exited event
3734                     ((Node) trg).setPressed(false);
3735                 }
3736                 pdrEventTargets.subList(0, i).clear();
3737 
3738                 trg = pdrEventTargets.get(0);
3739                 final PickResult res = pdrEventTarget.getResult();
3740                 if (trg instanceof Node) {
3741                     pdrEventTarget.setNodeResult(new PickResult((Node) trg,
3742                             res.getIntersectedPoint(), res.getIntersectedDistance()));
3743                 } else {
3744                     pdrEventTarget.setSceneResult(new PickResult(null,
3745                             res.getIntersectedPoint(), res.getIntersectedDistance()),
3746                             (Scene) trg);
3747                 }
3748             }
3749         }
3750 
3751         private void handleEnterExit(MouseEvent e, TargetWrapper pickedTarget) {
3752             if (pickedTarget.getEventTarget() != currentEventTarget ||
3753                     e.getEventType() == MouseEvent.MOUSE_EXITED) {
3754 
3755                 if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
3756                     newEventTargets.clear();
3757                 } else {
3758                     pickedTarget.fillHierarchy(newEventTargets);
3759                 }
3760 
3761                 int newTargetsSize = newEventTargets.size();
3762                 int i = currentEventTargets.size() - 1;
3763                 int j = newTargetsSize - 1;
3764                 int k = pdrEventTargets.size() - 1;
3765 
3766                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentEventTargets.get(i) == newEventTargets.get(j)) {
3767                     i--;
3768                     j--;
3769                     k--;
3770                 }
3771 
3772                 final int memk = k;
3773                 for (; i &gt;= 0; i--, k--) {
3774                     final EventTarget exitedEventTarget = currentEventTargets.get(i);
3775                     if (pdrInProgress &amp;&amp;
3776                             (k &lt; 0 || exitedEventTarget != pdrEventTargets.get(k))) {
3777                          break;
3778                     }
3779                     queue.postEvent(e.copyFor(
3780                             exitedEventTarget, exitedEventTarget,
3781                             MouseEvent.MOUSE_EXITED_TARGET));
3782                 }
3783 
3784                 k = memk;
3785                 for (; j &gt;= 0; j--, k--) {
3786                     final EventTarget enteredEventTarget = newEventTargets.get(j);
3787                     if (pdrInProgress &amp;&amp;
3788                             (k &lt; 0 || enteredEventTarget != pdrEventTargets.get(k))) {
3789                         break;
3790                     }
3791                     queue.postEvent(e.copyFor(
3792                             enteredEventTarget, enteredEventTarget,
3793                             MouseEvent.MOUSE_ENTERED_TARGET));
3794                 }
3795 
3796                 currentEventTarget = pickedTarget.getEventTarget();
3797                 currentEventTargets.clear();
3798                 for (j++; j &lt; newTargetsSize; j++) {
3799                     currentEventTargets.add(newEventTargets.get(j));
3800                 }
3801             }
3802             queue.fire();
3803         }
3804 
3805         private void process(MouseEvent e, boolean onPulse) {
3806             Toolkit.getToolkit().checkFxUserThread();
3807             Scene.inMousePick = true;
3808 
3809             cursorScreenPos = new Point2D(e.getScreenX(), e.getScreenY());
3810             cursorScenePos = new Point2D(e.getSceneX(), e.getSceneY());
3811 
3812             boolean gestureStarted = false;
3813             if (!onPulse) {
3814                 if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {
3815                     if (!(primaryButtonDown || secondaryButtonDown || middleButtonDown ||
3816                             backButtonDown || forwardButtonDown)) {
3817                         //old gesture ended and new one started
3818                         gestureStarted = true;
3819                         if (!PLATFORM_DRAG_GESTURE_INITIATION) {
3820                             Scene.this.dndGesture = new DnDGesture();
3821                         }
3822                         clearPDREventTargets();
3823                     }
3824                 } else if (e.getEventType() == MouseEvent.MOUSE_MOVED) {
3825                     // gesture ended
3826                     clearPDREventTargets();
3827                 } else if (e.getEventType() == MouseEvent.MOUSE_ENTERED) {
3828                     hover = true;
3829                 } else if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
3830                     hover = false;
3831                 }
3832 
3833                 primaryButtonDown = e.isPrimaryButtonDown();
3834                 secondaryButtonDown = e.isSecondaryButtonDown();
3835                 middleButtonDown = e.isMiddleButtonDown();
3836                 backButtonDown = e.isBackButtonDown();
3837                 forwardButtonDown = e.isForwardButtonDown();
3838             }
3839 
3840             pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
3841             PickResult res = tmpTargetWrapper.getResult();
3842             if (res != null) {
3843                 e = new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
3844                     e.getScreenX(), e.getScreenY(), e.getButton(), e.getClickCount(),
3845                     e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
3846                     e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
3847                     e.isBackButtonDown(), e.isForwardButtonDown(),
3848                     e.isSynthesized(), e.isPopupTrigger(), e.isStillSincePress(), res);
3849             }
3850 
3851             if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
3852                 tmpTargetWrapper.clear();
3853             }
3854 
3855             TargetWrapper target;
3856             if (pdrInProgress) {
3857                 target = pdrEventTarget;
3858             } else {
3859                 target = tmpTargetWrapper;
3860             }
3861 
3862             if (gestureStarted) {
3863                 pdrEventTarget.copy(target);
3864                 pdrEventTarget.fillHierarchy(pdrEventTargets);
3865             }
3866 
3867             if (!onPulse) {
3868                 e = clickGenerator.preProcess(e);
3869             }
3870 
3871             // enter/exit handling
3872             handleEnterExit(e, tmpTargetWrapper);
3873 
3874             //deliver event to the target node
3875             if (Scene.this.dndGesture != null) {
3876                 Scene.this.dndGesture.processDragDetection(e);
3877             }
3878 
3879             if (fullPDREntered &amp;&amp; e.getEventType() == MouseEvent.MOUSE_RELEASED) {
3880                 processFullPDR(e, onPulse);
3881             }
3882 
3883             if (target.getEventTarget() != null) {
3884                 if (e.getEventType() != MouseEvent.MOUSE_ENTERED
3885                         &amp;&amp; e.getEventType() != MouseEvent.MOUSE_EXITED
3886                         &amp;&amp; !onPulse) {
3887                     Event.fireEvent(target.getEventTarget(), e);
3888                 }
3889             }
3890 
3891             if (fullPDREntered &amp;&amp; e.getEventType() != MouseEvent.MOUSE_RELEASED) {
3892                 processFullPDR(e, onPulse);
3893             }
3894 
3895             if (!onPulse) {
3896                 clickGenerator.postProcess(e, target, tmpTargetWrapper);
3897             }
3898 
3899             // handle drag and drop
3900 
3901             if (!PLATFORM_DRAG_GESTURE_INITIATION &amp;&amp; !onPulse) {
3902                 if (Scene.this.dndGesture != null) {
3903                     if (!Scene.this.dndGesture.process(e, target.getEventTarget())) {
3904                         dndGesture = null;
3905                     }
3906                 }
3907             }
3908 
3909             Cursor cursor = target.getCursor();
3910             if (e.getEventType() != MouseEvent.MOUSE_EXITED) {
3911                 if (cursor == null &amp;&amp; hover) {
3912                     cursor = Scene.this.getCursor();
3913                 }
3914 
3915                 updateCursor(cursor);
3916                 updateCursorFrame();
3917             }
3918 
3919             if (gestureStarted) {
3920                 pdrInProgress = true;
3921             }
3922 
3923             if (pdrInProgress &amp;&amp;
3924                     !(primaryButtonDown || secondaryButtonDown || middleButtonDown ||
3925                             backButtonDown || forwardButtonDown)) {
3926                 clearPDREventTargets();
3927                 exitFullPDR(e);
3928                 // we need to do new picking in case the originally picked node
3929                 // was moved or removed by the event handlers
3930                 pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
3931                 handleEnterExit(e, tmpTargetWrapper);
3932             }
3933 
3934             lastEvent = e.getEventType() == MouseEvent.MOUSE_EXITED ? null : e;
3935             Scene.inMousePick = false;
3936         }
3937 
3938         private void processFullPDR(MouseEvent e, boolean onPulse) {
3939 
3940             pick(fullPDRTmpTargetWrapper, e.getSceneX(), e.getSceneY());
3941             final PickResult result = fullPDRTmpTargetWrapper.getResult();
3942 
3943             final EventTarget eventTarget = fullPDRTmpTargetWrapper.getEventTarget();
3944 
3945             // enter/exit handling
3946             if (eventTarget != fullPDRCurrentTarget) {
3947 
3948                 fullPDRTmpTargetWrapper.fillHierarchy(fullPDRNewEventTargets);
3949 
3950                 int newTargetsSize = fullPDRNewEventTargets.size();
3951                 int i = fullPDRCurrentEventTargets.size() - 1;
3952                 int j = newTargetsSize - 1;
3953 
3954                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp;
3955                         fullPDRCurrentEventTargets.get(i) == fullPDRNewEventTargets.get(j)) {
3956                     i--;
3957                     j--;
3958                 }
3959 
3960                 for (; i &gt;= 0; i--) {
3961                     final EventTarget exitedEventTarget = fullPDRCurrentEventTargets.get(i);
3962                     Event.fireEvent(exitedEventTarget, MouseEvent.copyForMouseDragEvent(e,
3963                             exitedEventTarget, exitedEventTarget,
3964                             MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
3965                             fullPDRSource, result));
3966                 }
3967 
3968                 for (; j &gt;= 0; j--) {
3969                     final EventTarget enteredEventTarget = fullPDRNewEventTargets.get(j);
3970                     Event.fireEvent(enteredEventTarget, MouseEvent.copyForMouseDragEvent(e,
3971                             enteredEventTarget, enteredEventTarget,
3972                             MouseDragEvent.MOUSE_DRAG_ENTERED_TARGET,
3973                             fullPDRSource, result));
3974                 }
3975 
3976                 fullPDRCurrentTarget = eventTarget;
3977                 fullPDRCurrentEventTargets.clear();
3978                 fullPDRCurrentEventTargets.addAll(fullPDRNewEventTargets);
3979                 fullPDRNewEventTargets.clear();
3980             }
3981             // done enter/exit handling
3982 
3983             // event delivery
3984             if (eventTarget != null &amp;&amp; !onPulse) {
3985                 if (e.getEventType() == MouseEvent.MOUSE_DRAGGED) {
3986                     Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
3987                             eventTarget, eventTarget,
3988                             MouseDragEvent.MOUSE_DRAG_OVER,
3989                             fullPDRSource, result));
3990                 }
3991                 if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
3992                     Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
3993                             eventTarget, eventTarget,
3994                             MouseDragEvent.MOUSE_DRAG_RELEASED,
3995                             fullPDRSource, result));
3996                 }
3997             }
3998         }
3999 
4000         private void updateCursor(Cursor newCursor) {
4001             if (currCursor != newCursor) {
4002                 if (currCursor != null) {
4003                     currCursor.deactivate();
4004                 }
4005 
4006                 if (newCursor != null) {
4007                     newCursor.activate();
4008                 }
4009 
4010                 currCursor = newCursor;
4011             }
4012         }
4013 
4014         public void updateCursorFrame() {
4015             final CursorFrame newCursorFrame =
4016                     (currCursor != null)
4017                            ? currCursor.getCurrentFrame()
4018                            : Cursor.DEFAULT.getCurrentFrame();
4019             if (currCursorFrame != newCursorFrame) {
4020                 if (Scene.this.peer != null) {
4021                     Scene.this.peer.setCursor(newCursorFrame);
4022                 }
4023 
4024                 currCursorFrame = newCursorFrame;
4025             }
4026         }
4027 
4028         private PickResult pickNode(PickRay pickRay) {
4029             PickResultChooser r = new PickResultChooser();
4030             Scene.this.getRoot().pickNode(pickRay, r);
4031             return r.toPickResult();
4032         }
4033     }
4034 
4035     /*******************************************************************************
4036      *                                                                             *
4037      * Key Event Handling                                                          *
4038      *                                                                             *
4039      ******************************************************************************/
4040 
4041     class KeyHandler {
4042         private void setFocusOwner(final Node value) {
4043             // Cancel IM composition if there is one in progress.
4044             // This needs to be done before the focus owner is switched as it
4045             // generates event that needs to be delivered to the old focus owner.
4046             if (oldFocusOwner != null) {
4047                 final Scene s = oldFocusOwner.getScene();
4048                 if (s != null) {
4049                     final TKScene peer = s.getPeer();
4050                     if (peer != null) {
4051                         peer.finishInputMethodComposition();
4052                     }
4053                 }
4054             }
4055             focusOwner.set(value);
4056         }
4057 
4058         private boolean windowFocused;
4059         protected boolean isWindowFocused() { return windowFocused; }
4060         protected void setWindowFocused(boolean value) {
4061             windowFocused = value;
4062             if (getFocusOwner() != null) {
4063                 getFocusOwner().setFocused(windowFocused);
4064             }
4065             if (windowFocused) {
4066                 if (accessible != null) {
4067                     accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
4068                 }
4069             }
4070         }
4071 
4072         private void windowForSceneChanged(Window oldWindow, Window window) {
4073             if (oldWindow != null) {
4074                 oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);
4075             }
4076 
4077             if (window != null) {
4078                 window.focusedProperty().addListener(sceneWindowFocusedListener);
4079                 setWindowFocused(window.isFocused());
4080             } else {
4081                 setWindowFocused(false);
4082             }
4083         }
4084 
4085         private final InvalidationListener sceneWindowFocusedListener = valueModel -&gt; setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());
4086 
4087         private void process(KeyEvent e) {
4088             final Node sceneFocusOwner = getFocusOwner();
4089             final EventTarget eventTarget =
4090                     (sceneFocusOwner != null &amp;&amp; sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner
4091                                               : Scene.this;
4092 
4093             // send the key event to the current focus owner or to scene if
4094             // the focus owner is not set
4095             Event.fireEvent(eventTarget, e);
4096         }
4097 
4098         private void requestFocus(Node node) {
4099             if (getFocusOwner() == node || (node != null &amp;&amp; !node.isCanReceiveFocus())) {
4100                 return;
4101             }
4102             setFocusOwner(node);
4103         }
4104     }
4105     /***************************************************************************
4106      *                                                                         *
4107      *                         Event Dispatch                                  *
4108      *                                                                         *
4109      **************************************************************************/
4110     // PENDING_DOC_REVIEW
4111     /**
4112      * Specifies the event dispatcher for this scene. When replacing the value
4113      * with a new {@code EventDispatcher}, the new dispatcher should forward
4114      * events to the replaced dispatcher to keep the scene&#39;s default event
4115      * handling behavior.
4116      */
4117     private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;
4118 
4119     public final void setEventDispatcher(EventDispatcher value) {
4120         eventDispatcherProperty().set(value);
4121     }
4122 
4123     public final EventDispatcher getEventDispatcher() {
4124         return eventDispatcherProperty().get();
4125     }
4126 
4127     public final ObjectProperty&lt;EventDispatcher&gt;
4128             eventDispatcherProperty() {
4129         initializeInternalEventDispatcher();
4130         return eventDispatcher;
4131     }
4132 
4133     private SceneEventDispatcher internalEventDispatcher;
4134 
4135     // Delegates requests from platform input method to the focused
4136     // node&#39;s one, if any.
4137     class InputMethodRequestsDelegate implements ExtendedInputMethodRequests {
4138         @Override
4139         public Point2D getTextLocation(int offset) {
4140             InputMethodRequests requests = getClientRequests();
4141             if (requests != null) {
4142                 return requests.getTextLocation(offset);
4143             } else {
4144                 return new Point2D(0, 0);
4145             }
4146         }
4147 
4148         @Override
4149         public int getLocationOffset(int x, int y) {
4150             InputMethodRequests requests = getClientRequests();
4151             if (requests != null) {
4152                 return requests.getLocationOffset(x, y);
4153             } else {
4154                 return 0;
4155             }
4156         }
4157 
4158         @Override
4159         public void cancelLatestCommittedText() {
4160             InputMethodRequests requests = getClientRequests();
4161             if (requests != null) {
4162                 requests.cancelLatestCommittedText();
4163             }
4164         }
4165 
4166         @Override
4167         public String getSelectedText() {
4168             InputMethodRequests requests = getClientRequests();
4169             if (requests != null) {
4170                 return requests.getSelectedText();
4171             }
4172             return null;
4173         }
4174 
4175         @Override
4176         public int getInsertPositionOffset() {
4177             InputMethodRequests requests = getClientRequests();
4178             if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
4179                 return ((ExtendedInputMethodRequests)requests).getInsertPositionOffset();
4180             }
4181             return 0;
4182         }
4183 
4184         @Override
4185         public String getCommittedText(int begin, int end) {
4186             InputMethodRequests requests = getClientRequests();
4187             if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
4188                 return ((ExtendedInputMethodRequests)requests).getCommittedText(begin, end);
4189             }
4190             return null;
4191         }
4192 
4193         @Override
4194         public int getCommittedTextLength() {
4195             InputMethodRequests requests = getClientRequests();
4196             if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
4197                 return ((ExtendedInputMethodRequests)requests).getCommittedTextLength();
4198             }
4199             return 0;
4200         }
4201 
4202         private InputMethodRequests getClientRequests() {
4203             Node focusOwner = getFocusOwner();
4204             if (focusOwner != null) {
4205                 return focusOwner.getInputMethodRequests();
4206             }
4207             return null;
4208         }
4209     }
4210 
4211     // PENDING_DOC_REVIEW
4212     /**
4213      * Registers an event handler to this scene. The handler is called when the
4214      * scene receives an {@code Event} of the specified type during the bubbling
4215      * phase of event delivery.
4216      *
4217      * @param &lt;T&gt; the specific event class of the handler
4218      * @param eventType the type of the events to receive by the handler
4219      * @param eventHandler the handler to register
4220      * @throws NullPointerException if the event type or handler is null
4221      */
4222     public final &lt;T extends Event&gt; void addEventHandler(
4223             final EventType&lt;T&gt; eventType,
4224             final EventHandler&lt;? super T&gt; eventHandler) {
4225         getInternalEventDispatcher().getEventHandlerManager()
4226                                     .addEventHandler(eventType, eventHandler);
4227     }
4228 
4229     // PENDING_DOC_REVIEW
4230     /**
4231      * Unregisters a previously registered event handler from this scene. One
4232      * handler might have been registered for different event types, so the
4233      * caller needs to specify the particular event type from which to
4234      * unregister the handler.
4235      *
4236      * @param &lt;T&gt; the specific event class of the handler
4237      * @param eventType the event type from which to unregister
4238      * @param eventHandler the handler to unregister
4239      * @throws NullPointerException if the event type or handler is null
4240      */
4241     public final &lt;T extends Event&gt; void removeEventHandler(
4242             final EventType&lt;T&gt; eventType,
4243             final EventHandler&lt;? super T&gt; eventHandler) {
4244         getInternalEventDispatcher().getEventHandlerManager()
4245                                     .removeEventHandler(eventType,
4246                                                         eventHandler);
4247     }
4248 
4249     // PENDING_DOC_REVIEW
4250     /**
4251      * Registers an event filter to this scene. The filter is called when the
4252      * scene receives an {@code Event} of the specified type during the
4253      * capturing phase of event delivery.
4254      *
4255      * @param &lt;T&gt; the specific event class of the filter
4256      * @param eventType the type of the events to receive by the filter
4257      * @param eventFilter the filter to register
4258      * @throws NullPointerException if the event type or filter is null
4259      */
4260     public final &lt;T extends Event&gt; void addEventFilter(
4261             final EventType&lt;T&gt; eventType,
4262             final EventHandler&lt;? super T&gt; eventFilter) {
4263         getInternalEventDispatcher().getEventHandlerManager()
4264                                     .addEventFilter(eventType, eventFilter);
4265     }
4266 
4267     // PENDING_DOC_REVIEW
4268     /**
4269      * Unregisters a previously registered event filter from this scene. One
4270      * filter might have been registered for different event types, so the
4271      * caller needs to specify the particular event type from which to
4272      * unregister the filter.
4273      *
4274      * @param &lt;T&gt; the specific event class of the filter
4275      * @param eventType the event type from which to unregister
4276      * @param eventFilter the filter to unregister
4277      * @throws NullPointerException if the event type or filter is null
4278      */
4279     public final &lt;T extends Event&gt; void removeEventFilter(
4280             final EventType&lt;T&gt; eventType,
4281             final EventHandler&lt;? super T&gt; eventFilter) {
4282         getInternalEventDispatcher().getEventHandlerManager()
4283                                     .removeEventFilter(eventType, eventFilter);
4284     }
4285 
4286     /**
4287      * Sets the handler to use for this event type. There can only be one such
4288      * handler specified at a time. This handler is guaranteed to be called
4289      * first. This is used for registering the user-defined onFoo event
4290      * handlers.
4291      *
4292      * @param &lt;T&gt; the specific event class of the handler
4293      * @param eventType the event type to associate with the given eventHandler
4294      * @param eventHandler the handler to register, or null to unregister
4295      * @throws NullPointerException if the event type is null
4296      */
4297     protected final &lt;T extends Event&gt; void setEventHandler(
4298             final EventType&lt;T&gt; eventType,
4299             final EventHandler&lt;? super T&gt; eventHandler) {
4300         getInternalEventDispatcher().getEventHandlerManager()
4301                                     .setEventHandler(eventType, eventHandler);
4302     }
4303 
4304     private SceneEventDispatcher getInternalEventDispatcher() {
4305         initializeInternalEventDispatcher();
4306         return internalEventDispatcher;
4307     }
4308 
4309     final void initializeInternalEventDispatcher() {
4310         if (internalEventDispatcher == null) {
4311             internalEventDispatcher = createInternalEventDispatcher();
4312             eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(
4313                                           this,
4314                                           &quot;eventDispatcher&quot;,
4315                                           internalEventDispatcher);
4316         }
4317     }
4318 
4319     private SceneEventDispatcher createInternalEventDispatcher() {
4320         return new SceneEventDispatcher(this);
4321     }
4322 
4323     /**
4324      * Registers the specified mnemonic.
4325      *
4326      * @param m The mnemonic
4327      */
4328     public void addMnemonic(Mnemonic m) {
4329         getInternalEventDispatcher().getKeyboardShortcutsHandler()
4330                                     .addMnemonic(m);
4331     }
4332 
4333 
4334     /**
4335      * Unregisters the specified mnemonic.
4336      *
4337      * @param m The mnemonic
4338      */
4339     public void removeMnemonic(Mnemonic m) {
4340         getInternalEventDispatcher().getKeyboardShortcutsHandler()
4341                                     .removeMnemonic(m);
4342     }
4343 
4344     final void clearNodeMnemonics(Node node) {
4345         getInternalEventDispatcher().getKeyboardShortcutsHandler()
4346                 .clearNodeMnemonics(node);
4347     }
4348 
4349 
4350     /**
4351      * Gets the list of mnemonics for this {@code Scene}.
4352      *
4353      * @return the list of mnemonics
4354      */
4355     public ObservableMap&lt;KeyCombination, ObservableList&lt;Mnemonic&gt;&gt; getMnemonics() {
4356         return getInternalEventDispatcher().getKeyboardShortcutsHandler()
4357                                            .getMnemonics();
4358     }
4359 
4360     /**
4361      * Gets the list of accelerators for this {@code Scene}.
4362      *
4363      * @return the list of accelerators
4364      */
4365     public ObservableMap&lt;KeyCombination, Runnable&gt; getAccelerators() {
4366         return getInternalEventDispatcher().getKeyboardShortcutsHandler()
4367                                            .getAccelerators();
4368     }
4369 
4370     // PENDING_DOC_REVIEW
4371     /**
4372      * Construct an event dispatch chain for this scene. The event dispatch
4373      * chain contains all event dispatchers from the stage to this scene.
4374      *
4375      * @param tail the initial chain to build from
4376      * @return the resulting event dispatch chain for this scene
4377      */
4378     @Override
4379     public EventDispatchChain buildEventDispatchChain(
4380             EventDispatchChain tail) {
4381         if (eventDispatcher != null) {
4382             final EventDispatcher eventDispatcherValue = eventDispatcher.get();
4383             if (eventDispatcherValue != null) {
4384                 tail = tail.prepend(eventDispatcherValue);
4385             }
4386         }
4387 
4388         if (getWindow() != null) {
4389             tail = getWindow().buildEventDispatchChain(tail);
4390         }
4391 
4392         return tail;
4393     }
4394 
4395     /***************************************************************************
4396      *                                                                         *
4397      *                             Context Menus                               *
4398      *                                                                         *
4399      **************************************************************************/
4400 
4401     /**
4402      * Defines a function to be called when a mouse button has been clicked
4403      * (pressed and released) on this {@code Scene}.
4404      * @since JavaFX 2.1
4405      */
4406 
4407     private ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequested;
4408 
4409     public final void setOnContextMenuRequested(EventHandler&lt;? super ContextMenuEvent&gt; value) {
4410         onContextMenuRequestedProperty().set(value);
4411     }
4412 
4413     public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
4414         return onContextMenuRequested == null ? null : onContextMenuRequested.get();
4415     }
4416 
4417     public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequestedProperty() {
4418         if (onContextMenuRequested == null) {
4419             onContextMenuRequested = new ObjectPropertyBase&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;() {
4420 
4421                 @Override
4422                 protected void invalidated() {
4423                     setEventHandler(ContextMenuEvent.CONTEXT_MENU_REQUESTED, get());
4424                 }
4425 
4426                 @Override
4427                 public Object getBean() {
4428                     return Scene.this;
4429                 }
4430 
4431                 @Override
4432                 public String getName() {
4433                     return &quot;onContextMenuRequested&quot;;
4434                 }
4435             };
4436         }
4437         return onContextMenuRequested;
4438     }
4439 
4440     /***************************************************************************
4441      *                                                                         *
4442      *                             Mouse Handling                              *
4443      *                                                                         *
4444      **************************************************************************/
4445 
4446     /**
4447      * Defines a function to be called when a mouse button has been clicked
4448      * (pressed and released) on this {@code Scene}.
4449      */
4450     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClicked;
4451 
4452     public final void setOnMouseClicked(EventHandler&lt;? super MouseEvent&gt; value) {
4453         onMouseClickedProperty().set(value);
4454     }
4455 
4456     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
4457         return onMouseClicked == null ? null : onMouseClicked.get();
4458     }
4459 
4460     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClickedProperty() {
4461         if (onMouseClicked == null) {
4462             onMouseClicked = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4463 
4464                 @Override
4465                 protected void invalidated() {
4466                     setEventHandler(MouseEvent.MOUSE_CLICKED, get());
4467                 }
4468 
4469                 @Override
4470                 public Object getBean() {
4471                     return Scene.this;
4472                 }
4473 
4474                 @Override
4475                 public String getName() {
4476                     return &quot;onMouseClicked&quot;;
4477                 }
4478             };
4479         }
4480         return onMouseClicked;
4481     }
4482 
4483     /**
4484      * Defines a function to be called when a mouse button is pressed
4485      * on this {@code Scene} and then dragged.
4486      */
4487     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDragged;
4488 
4489     public final void setOnMouseDragged(EventHandler&lt;? super MouseEvent&gt; value) {
4490         onMouseDraggedProperty().set(value);
4491     }
4492 
4493     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
4494         return onMouseDragged == null ? null : onMouseDragged.get();
4495     }
4496 
4497     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDraggedProperty() {
4498         if (onMouseDragged == null) {
4499             onMouseDragged = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4500 
4501                 @Override
4502                 protected void invalidated() {
4503                     setEventHandler(MouseEvent.MOUSE_DRAGGED, get());
4504                 }
4505 
4506                 @Override
4507                 public Object getBean() {
4508                     return Scene.this;
4509                 }
4510 
4511                 @Override
4512                 public String getName() {
4513                     return &quot;onMouseDragged&quot;;
4514                 }
4515             };
4516         }
4517         return onMouseDragged;
4518     }
4519 
4520     /**
4521      * Defines a function to be called when the mouse enters this {@code Scene}.
4522      */
4523     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEntered;
4524 
4525     public final void setOnMouseEntered(EventHandler&lt;? super MouseEvent&gt; value) {
4526         onMouseEnteredProperty().set(value);
4527     }
4528 
4529     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
4530         return onMouseEntered == null ? null : onMouseEntered.get();
4531     }
4532 
4533     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEnteredProperty() {
4534         if (onMouseEntered == null) {
4535             onMouseEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4536 
4537                 @Override
4538                 protected void invalidated() {
4539                     setEventHandler(MouseEvent.MOUSE_ENTERED, get());
4540                 }
4541 
4542                 @Override
4543                 public Object getBean() {
4544                     return Scene.this;
4545                 }
4546 
4547                 @Override
4548                 public String getName() {
4549                     return &quot;onMouseEntered&quot;;
4550                 }
4551             };
4552         }
4553         return onMouseEntered;
4554     }
4555 
4556     /**
4557      * Defines a function to be called when the mouse exits this {@code Scene}.
4558      */
4559     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExited;
4560 
4561     public final void setOnMouseExited(EventHandler&lt;? super MouseEvent&gt; value) {
4562         onMouseExitedProperty().set(value);
4563     }
4564 
4565     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
4566         return onMouseExited == null ? null : onMouseExited.get();
4567     }
4568 
4569     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExitedProperty() {
4570         if (onMouseExited == null) {
4571             onMouseExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4572 
4573                 @Override
4574                 protected void invalidated() {
4575                     setEventHandler(MouseEvent.MOUSE_EXITED, get());
4576                 }
4577 
4578                 @Override
4579                 public Object getBean() {
4580                     return Scene.this;
4581                 }
4582 
4583                 @Override
4584                 public String getName() {
4585                     return &quot;onMouseExited&quot;;
4586                 }
4587             };
4588         }
4589         return onMouseExited;
4590     }
4591 
4592     /**
4593      * Defines a function to be called when mouse cursor moves within
4594      * this {@code Scene} but no buttons have been pushed.
4595      */
4596     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMoved;
4597 
4598     public final void setOnMouseMoved(EventHandler&lt;? super MouseEvent&gt; value) {
4599         onMouseMovedProperty().set(value);
4600     }
4601 
4602     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
4603         return onMouseMoved == null ? null : onMouseMoved.get();
4604     }
4605 
4606     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMovedProperty() {
4607         if (onMouseMoved == null) {
4608             onMouseMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4609 
4610                 @Override
4611                 protected void invalidated() {
4612                     setEventHandler(MouseEvent.MOUSE_MOVED, get());
4613                 }
4614 
4615                 @Override
4616                 public Object getBean() {
4617                     return Scene.this;
4618                 }
4619 
4620                 @Override
4621                 public String getName() {
4622                     return &quot;onMouseMoved&quot;;
4623                 }
4624             };
4625         }
4626         return onMouseMoved;
4627     }
4628 
4629     /**
4630      * Defines a function to be called when a mouse button
4631      * has been pressed on this {@code Scene}.
4632      */
4633     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressed;
4634 
4635     public final void setOnMousePressed(EventHandler&lt;? super MouseEvent&gt; value) {
4636         onMousePressedProperty().set(value);
4637     }
4638 
4639     public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
4640         return onMousePressed == null ? null : onMousePressed.get();
4641     }
4642 
4643     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressedProperty() {
4644         if (onMousePressed == null) {
4645             onMousePressed = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4646 
4647                 @Override
4648                 protected void invalidated() {
4649                     setEventHandler(MouseEvent.MOUSE_PRESSED, get());
4650                 }
4651 
4652                 @Override
4653                 public Object getBean() {
4654                     return Scene.this;
4655                 }
4656 
4657                 @Override
4658                 public String getName() {
4659                     return &quot;onMousePressed&quot;;
4660                 }
4661             };
4662         }
4663         return onMousePressed;
4664     }
4665 
4666     /**
4667      * Defines a function to be called when a mouse button
4668      * has been released on this {@code Scene}.
4669      */
4670     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleased;
4671 
4672     public final void setOnMouseReleased(EventHandler&lt;? super MouseEvent&gt; value) {
4673         onMouseReleasedProperty().set(value);
4674     }
4675 
4676     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
4677         return onMouseReleased == null ? null : onMouseReleased.get();
4678     }
4679 
4680     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleasedProperty() {
4681         if (onMouseReleased == null) {
4682             onMouseReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4683 
4684                 @Override
4685                 protected void invalidated() {
4686                     setEventHandler(MouseEvent.MOUSE_RELEASED, get());
4687                 }
4688 
4689                 @Override
4690                 public Object getBean() {
4691                     return Scene.this;
4692                 }
4693 
4694                 @Override
4695                 public String getName() {
4696                     return &quot;onMouseReleased&quot;;
4697                 }
4698             };
4699         }
4700         return onMouseReleased;
4701     }
4702 
4703     /**
4704      * Defines a function to be called when drag gesture has been
4705      * detected. This is the right place to start drag and drop operation.
4706      */
4707     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetected;
4708 
4709     public final void setOnDragDetected(EventHandler&lt;? super MouseEvent&gt; value) {
4710         onDragDetectedProperty().set(value);
4711     }
4712 
4713     public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
4714         return onDragDetected == null ? null : onDragDetected.get();
4715     }
4716 
4717     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetectedProperty() {
4718         if (onDragDetected == null) {
4719             onDragDetected = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4720 
4721                 @Override
4722                 protected void invalidated() {
4723                     setEventHandler(MouseEvent.DRAG_DETECTED, get());
4724                 }
4725 
4726                 @Override
4727                 public Object getBean() {
4728                     return Scene.this;
4729                 }
4730 
4731                 @Override
4732                 public String getName() {
4733                     return &quot;onDragDetected&quot;;
4734                 }
4735             };
4736         }
4737         return onDragDetected;
4738     }
4739 
4740     /**
4741      * Defines a function to be called when a full press-drag-release gesture
4742      * progresses within this {@code Scene}.
4743      * @since JavaFX 2.1
4744      */
4745     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOver;
4746 
4747     public final void setOnMouseDragOver(EventHandler&lt;? super MouseDragEvent&gt; value) {
4748         onMouseDragOverProperty().set(value);
4749     }
4750 
4751     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
4752         return onMouseDragOver == null ? null : onMouseDragOver.get();
4753     }
4754 
4755     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOverProperty() {
4756         if (onMouseDragOver == null) {
4757             onMouseDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4758 
4759                 @Override
4760                 protected void invalidated() {
4761                     setEventHandler(MouseDragEvent.MOUSE_DRAG_OVER, get());
4762                 }
4763 
4764                 @Override
4765                 public Object getBean() {
4766                     return Scene.this;
4767                 }
4768 
4769                 @Override
4770                 public String getName() {
4771                     return &quot;onMouseDragOver&quot;;
4772                 }
4773             };
4774         }
4775         return onMouseDragOver;
4776     }
4777 
4778     /**
4779      * Defines a function to be called when a full press-drag-release gesture
4780      * ends within this {@code Scene}.
4781      * @since JavaFX 2.1
4782      */
4783     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleased;
4784 
4785     public final void setOnMouseDragReleased(EventHandler&lt;? super MouseDragEvent&gt; value) {
4786         onMouseDragReleasedProperty().set(value);
4787     }
4788 
4789     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
4790         return onMouseDragReleased == null ? null : onMouseDragReleased.get();
4791     }
4792 
4793     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleasedProperty() {
4794         if (onMouseDragReleased == null) {
4795             onMouseDragReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4796 
4797                 @Override
4798                 protected void invalidated() {
4799                     setEventHandler(MouseDragEvent.MOUSE_DRAG_RELEASED, get());
4800                 }
4801 
4802                 @Override
4803                 public Object getBean() {
4804                     return Scene.this;
4805                 }
4806 
4807                 @Override
4808                 public String getName() {
4809                     return &quot;onMouseDragReleased&quot;;
4810                 }
4811             };
4812         }
4813         return onMouseDragReleased;
4814     }
4815 
4816     /**
4817      * Defines a function to be called when a full press-drag-release gesture
4818      * enters this {@code Scene}.
4819      * @since JavaFX 2.1
4820      */
4821     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEntered;
4822 
4823     public final void setOnMouseDragEntered(EventHandler&lt;? super MouseDragEvent&gt; value) {
4824         onMouseDragEnteredProperty().set(value);
4825     }
4826 
4827     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
4828         return onMouseDragEntered == null ? null : onMouseDragEntered.get();
4829     }
4830 
4831     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEnteredProperty() {
4832         if (onMouseDragEntered == null) {
4833             onMouseDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4834 
4835                 @Override
4836                 protected void invalidated() {
4837                     setEventHandler(MouseDragEvent.MOUSE_DRAG_ENTERED, get());
4838                 }
4839 
4840                 @Override
4841                 public Object getBean() {
4842                     return Scene.this;
4843                 }
4844 
4845                 @Override
4846                 public String getName() {
4847                     return &quot;onMouseDragEntered&quot;;
4848                 }
4849             };
4850         }
4851         return onMouseDragEntered;
4852     }
4853 
4854     /**
4855      * Defines a function to be called when a full press-drag-release gesture
4856      * exits this {@code Scene}.
4857      * @since JavaFX 2.1
4858      */
4859     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExited;
4860 
4861     public final void setOnMouseDragExited(EventHandler&lt;? super MouseDragEvent&gt; value) {
4862         onMouseDragExitedProperty().set(value);
4863     }
4864 
4865     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
4866         return onMouseDragExited == null ? null : onMouseDragExited.get();
4867     }
4868 
4869     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExitedProperty() {
4870         if (onMouseDragExited == null) {
4871             onMouseDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4872 
4873                 @Override
4874                 protected void invalidated() {
4875                     setEventHandler(MouseDragEvent.MOUSE_DRAG_EXITED, get());
4876                 }
4877 
4878                 @Override
4879                 public Object getBean() {
4880                     return Scene.this;
4881                 }
4882 
4883                 @Override
4884                 public String getName() {
4885                     return &quot;onMouseDragExited&quot;;
4886                 }
4887             };
4888         }
4889         return onMouseDragExited;
4890     }
4891 
4892 
4893     /***************************************************************************
4894      *                                                                         *
4895      *                           Gestures Handling                             *
4896      *                                                                         *
4897      **************************************************************************/
4898 
4899     /**
4900      * Defines a function to be called when a scrolling gesture is detected.
4901      * @since JavaFX 2.2
4902      */
4903     private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStarted;
4904 
4905     public final void setOnScrollStarted(EventHandler&lt;? super ScrollEvent&gt; value) {
4906         onScrollStartedProperty().set(value);
4907     }
4908 
4909     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
4910         return onScrollStarted == null ? null : onScrollStarted.get();
4911     }
4912 
4913     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStartedProperty() {
4914         if (onScrollStarted == null) {
4915             onScrollStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {
4916 
4917                 @Override
4918                 protected void invalidated() {
4919                     setEventHandler(ScrollEvent.SCROLL_STARTED, get());
4920                 }
4921 
4922                 @Override
4923                 public Object getBean() {
4924                     return Scene.this;
4925                 }
4926 
4927                 @Override
4928                 public String getName() {
4929                     return &quot;onScrollStarted&quot;;
4930                 }
4931             };
4932         }
4933         return onScrollStarted;
4934     }
4935 
4936     /**
4937      * Defines a function to be called when user performs a scrolling action.
4938      */
4939     private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScroll;
4940 
4941     public final void setOnScroll(EventHandler&lt;? super ScrollEvent&gt; value) {
4942         onScrollProperty().set(value);
4943     }
4944 
4945     public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
4946         return onScroll == null ? null : onScroll.get();
4947     }
4948 
4949     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollProperty() {
4950         if (onScroll == null) {
4951             onScroll = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {
4952 
4953                 @Override
4954                 protected void invalidated() {
4955                     setEventHandler(ScrollEvent.SCROLL, get());
4956                 }
4957 
4958                 @Override
4959                 public Object getBean() {
4960                     return Scene.this;
4961                 }
4962 
4963                 @Override
4964                 public String getName() {
4965                     return &quot;onScroll&quot;;
4966                 }
4967             };
4968         }
4969         return onScroll;
4970     }
4971 
4972     /**
4973      * Defines a function to be called when a scrolling gesture ends.
4974      * @since JavaFX 2.2
4975      */
4976     private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinished;
4977 
4978     public final void setOnScrollFinished(EventHandler&lt;? super ScrollEvent&gt; value) {
4979         onScrollFinishedProperty().set(value);
4980     }
4981 
4982     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
4983         return onScrollFinished == null ? null : onScrollFinished.get();
4984     }
4985 
4986     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinishedProperty() {
4987         if (onScrollFinished == null) {
4988             onScrollFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {
4989 
4990                 @Override
4991                 protected void invalidated() {
4992                     setEventHandler(ScrollEvent.SCROLL_FINISHED, get());
4993                 }
4994 
4995                 @Override
4996                 public Object getBean() {
4997                     return Scene.this;
4998                 }
4999 
5000                 @Override
5001                 public String getName() {
5002                     return &quot;onScrollFinished&quot;;
5003                 }
5004             };
5005         }
5006         return onScrollFinished;
5007     }
5008 
5009     /**
5010      * Defines a function to be called when a rotating gesture is detected.
5011      * @since JavaFX 2.2
5012      */
5013     private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStarted;
5014 
5015     public final void setOnRotationStarted(EventHandler&lt;? super RotateEvent&gt; value) {
5016         onRotationStartedProperty().set(value);
5017     }
5018 
5019     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
5020         return onRotationStarted == null ? null : onRotationStarted.get();
5021     }
5022 
5023     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStartedProperty() {
5024         if (onRotationStarted == null) {
5025             onRotationStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {
5026 
5027                 @Override
5028                 protected void invalidated() {
5029                     setEventHandler(RotateEvent.ROTATION_STARTED, get());
5030                 }
5031 
5032                 @Override
5033                 public Object getBean() {
5034                     return Scene.this;
5035                 }
5036 
5037                 @Override
5038                 public String getName() {
5039                     return &quot;onRotationStarted&quot;;
5040                 }
5041             };
5042         }
5043         return onRotationStarted;
5044     }
5045 
5046     /**
5047      * Defines a function to be called when user performs a rotating action.
5048      * @since JavaFX 2.2
5049      */
5050     private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotate;
5051 
5052     public final void setOnRotate(EventHandler&lt;? super RotateEvent&gt; value) {
5053         onRotateProperty().set(value);
5054     }
5055 
5056     public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
5057         return onRotate == null ? null : onRotate.get();
5058     }
5059 
5060     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotateProperty() {
5061         if (onRotate == null) {
5062             onRotate = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {
5063 
5064                 @Override
5065                 protected void invalidated() {
5066                     setEventHandler(RotateEvent.ROTATE, get());
5067                 }
5068 
5069                 @Override
5070                 public Object getBean() {
5071                     return Scene.this;
5072                 }
5073 
5074                 @Override
5075                 public String getName() {
5076                     return &quot;onRotate&quot;;
5077                 }
5078             };
5079         }
5080         return onRotate;
5081     }
5082 
5083     /**
5084      * Defines a function to be called when a rotating gesture ends.
5085      * @since JavaFX 2.2
5086      */
5087     private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinished;
5088 
5089     public final void setOnRotationFinished(EventHandler&lt;? super RotateEvent&gt; value) {
5090         onRotationFinishedProperty().set(value);
5091     }
5092 
5093     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
5094         return onRotationFinished == null ? null : onRotationFinished.get();
5095     }
5096 
5097     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinishedProperty() {
5098         if (onRotationFinished == null) {
5099             onRotationFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {
5100 
5101                 @Override
5102                 protected void invalidated() {
5103                     setEventHandler(RotateEvent.ROTATION_FINISHED, get());
5104                 }
5105 
5106                 @Override
5107                 public Object getBean() {
5108                     return Scene.this;
5109                 }
5110 
5111                 @Override
5112                 public String getName() {
5113                     return &quot;onRotationFinished&quot;;
5114                 }
5115             };
5116         }
5117         return onRotationFinished;
5118     }
5119 
5120     /**
5121      * Defines a function to be called when a zooming gesture is detected.
5122      * @since JavaFX 2.2
5123      */
5124     private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStarted;
5125 
5126     public final void setOnZoomStarted(EventHandler&lt;? super ZoomEvent&gt; value) {
5127         onZoomStartedProperty().set(value);
5128     }
5129 
5130     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
5131         return onZoomStarted == null ? null : onZoomStarted.get();
5132     }
5133 
5134     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStartedProperty() {
5135         if (onZoomStarted == null) {
5136             onZoomStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {
5137 
5138                 @Override
5139                 protected void invalidated() {
5140                     setEventHandler(ZoomEvent.ZOOM_STARTED, get());
5141                 }
5142 
5143                 @Override
5144                 public Object getBean() {
5145                     return Scene.this;
5146                 }
5147 
5148                 @Override
5149                 public String getName() {
5150                     return &quot;onZoomStarted&quot;;
5151                 }
5152             };
5153         }
5154         return onZoomStarted;
5155     }
5156 
5157     /**
5158      * Defines a function to be called when user performs a zooming action.
5159      * @since JavaFX 2.2
5160      */
5161     private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoom;
5162 
5163     public final void setOnZoom(EventHandler&lt;? super ZoomEvent&gt; value) {
5164         onZoomProperty().set(value);
5165     }
5166 
5167     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
5168         return onZoom == null ? null : onZoom.get();
5169     }
5170 
5171     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomProperty() {
5172         if (onZoom == null) {
5173             onZoom = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {
5174 
5175                 @Override
5176                 protected void invalidated() {
5177                     setEventHandler(ZoomEvent.ZOOM, get());
5178                 }
5179 
5180                 @Override
5181                 public Object getBean() {
5182                     return Scene.this;
5183                 }
5184 
5185                 @Override
5186                 public String getName() {
5187                     return &quot;onZoom&quot;;
5188                 }
5189             };
5190         }
5191         return onZoom;
5192     }
5193 
5194     /**
5195      * Defines a function to be called when a zooming gesture ends.
5196      * @since JavaFX 2.2
5197      */
5198     private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinished;
5199 
5200     public final void setOnZoomFinished(EventHandler&lt;? super ZoomEvent&gt; value) {
5201         onZoomFinishedProperty().set(value);
5202     }
5203 
5204     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
5205         return onZoomFinished == null ? null : onZoomFinished.get();
5206     }
5207 
5208     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinishedProperty() {
5209         if (onZoomFinished == null) {
5210             onZoomFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {
5211 
5212                 @Override
5213                 protected void invalidated() {
5214                     setEventHandler(ZoomEvent.ZOOM_FINISHED, get());
5215                 }
5216 
5217                 @Override
5218                 public Object getBean() {
5219                     return Scene.this;
5220                 }
5221 
5222                 @Override
5223                 public String getName() {
5224                     return &quot;onZoomFinished&quot;;
5225                 }
5226             };
5227         }
5228         return onZoomFinished;
5229     }
5230 
5231     /**
5232      * Defines a function to be called when an upward swipe gesture
5233      * happens in this scene.
5234      * @since JavaFX 2.2
5235      */
5236     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUp;
5237 
5238     public final void setOnSwipeUp(EventHandler&lt;? super SwipeEvent&gt; value) {
5239         onSwipeUpProperty().set(value);
5240     }
5241 
5242     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
5243         return onSwipeUp == null ? null : onSwipeUp.get();
5244     }
5245 
5246     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUpProperty() {
5247         if (onSwipeUp == null) {
5248             onSwipeUp = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5249 
5250                 @Override
5251                 protected void invalidated() {
5252                     setEventHandler(SwipeEvent.SWIPE_UP, get());
5253                 }
5254 
5255                 @Override
5256                 public Object getBean() {
5257                     return Scene.this;
5258                 }
5259 
5260                 @Override
5261                 public String getName() {
5262                     return &quot;onSwipeUp&quot;;
5263                 }
5264             };
5265         }
5266         return onSwipeUp;
5267     }
5268 
5269     /**
5270      * Defines a function to be called when an downward swipe gesture
5271      * happens in this scene.
5272      * @since JavaFX 2.2
5273      */
5274     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDown;
5275 
5276     public final void setOnSwipeDown(EventHandler&lt;? super SwipeEvent&gt; value) {
5277         onSwipeDownProperty().set(value);
5278     }
5279 
5280     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
5281         return onSwipeDown == null ? null : onSwipeDown.get();
5282     }
5283 
5284     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDownProperty() {
5285         if (onSwipeDown == null) {
5286             onSwipeDown = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5287 
5288                 @Override
5289                 protected void invalidated() {
5290                     setEventHandler(SwipeEvent.SWIPE_DOWN, get());
5291                 }
5292 
5293                 @Override
5294                 public Object getBean() {
5295                     return Scene.this;
5296                 }
5297 
5298                 @Override
5299                 public String getName() {
5300                     return &quot;onSwipeDown&quot;;
5301                 }
5302             };
5303         }
5304         return onSwipeDown;
5305     }
5306 
5307     /**
5308      * Defines a function to be called when an leftward swipe gesture
5309      * happens in this scene.
5310      * @since JavaFX 2.2
5311      */
5312     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeft;
5313 
5314     public final void setOnSwipeLeft(EventHandler&lt;? super SwipeEvent&gt; value) {
5315         onSwipeLeftProperty().set(value);
5316     }
5317 
5318     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
5319         return onSwipeLeft == null ? null : onSwipeLeft.get();
5320     }
5321 
5322     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeftProperty() {
5323         if (onSwipeLeft == null) {
5324             onSwipeLeft = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5325 
5326                 @Override
5327                 protected void invalidated() {
5328                     setEventHandler(SwipeEvent.SWIPE_LEFT, get());
5329                 }
5330 
5331                 @Override
5332                 public Object getBean() {
5333                     return Scene.this;
5334                 }
5335 
5336                 @Override
5337                 public String getName() {
5338                     return &quot;onSwipeLeft&quot;;
5339                 }
5340             };
5341         }
5342         return onSwipeLeft;
5343     }
5344 
5345     /**
5346      * Defines a function to be called when an rightward swipe gesture
5347      * happens in this scene.
5348      * @since JavaFX 2.2
5349      */
5350     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRight;
5351 
5352     public final void setOnSwipeRight(EventHandler&lt;? super SwipeEvent&gt; value) {
5353         onSwipeRightProperty().set(value);
5354     }
5355 
5356     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
5357         return onSwipeRight == null ? null : onSwipeRight.get();
5358     }
5359 
5360     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRightProperty() {
5361         if (onSwipeRight == null) {
5362             onSwipeRight = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5363 
5364                 @Override
5365                 protected void invalidated() {
5366                     setEventHandler(SwipeEvent.SWIPE_RIGHT, get());
5367                 }
5368 
5369                 @Override
5370                 public Object getBean() {
5371                     return Scene.this;
5372                 }
5373 
5374                 @Override
5375                 public String getName() {
5376                     return &quot;onSwipeRight&quot;;
5377                 }
5378             };
5379         }
5380         return onSwipeRight;
5381     }
5382 
5383     /***************************************************************************
5384      *                                                                         *
5385      *                            Touch Handling                               *
5386      *                                                                         *
5387      **************************************************************************/
5388 
5389     /**
5390      * Defines a function to be called when a new touch point is pressed.
5391      * @since JavaFX 2.2
5392      */
5393     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressed;
5394 
5395     public final void setOnTouchPressed(EventHandler&lt;? super TouchEvent&gt; value) {
5396         onTouchPressedProperty().set(value);
5397     }
5398 
5399     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
5400         return onTouchPressed == null ? null : onTouchPressed.get();
5401     }
5402 
5403     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressedProperty() {
5404         if (onTouchPressed == null) {
5405             onTouchPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5406 
5407                 @Override
5408                 protected void invalidated() {
5409                     setEventHandler(TouchEvent.TOUCH_PRESSED, get());
5410                 }
5411 
5412                 @Override
5413                 public Object getBean() {
5414                     return Scene.this;
5415                 }
5416 
5417                 @Override
5418                 public String getName() {
5419                     return &quot;onTouchPressed&quot;;
5420                 }
5421             };
5422         }
5423         return onTouchPressed;
5424     }
5425 
5426     /**
5427      * Defines a function to be called when a touch point is moved.
5428      * @since JavaFX 2.2
5429      */
5430     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMoved;
5431 
5432     public final void setOnTouchMoved(EventHandler&lt;? super TouchEvent&gt; value) {
5433         onTouchMovedProperty().set(value);
5434     }
5435 
5436     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
5437         return onTouchMoved == null ? null : onTouchMoved.get();
5438     }
5439 
5440     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMovedProperty() {
5441         if (onTouchMoved == null) {
5442             onTouchMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5443 
5444                 @Override
5445                 protected void invalidated() {
5446                     setEventHandler(TouchEvent.TOUCH_MOVED, get());
5447                 }
5448 
5449                 @Override
5450                 public Object getBean() {
5451                     return Scene.this;
5452                 }
5453 
5454                 @Override
5455                 public String getName() {
5456                     return &quot;onTouchMoved&quot;;
5457                 }
5458             };
5459         }
5460         return onTouchMoved;
5461     }
5462 
5463     /**
5464      * Defines a function to be called when a new touch point is pressed.
5465      * @since JavaFX 2.2
5466      */
5467     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleased;
5468 
5469     public final void setOnTouchReleased(EventHandler&lt;? super TouchEvent&gt; value) {
5470         onTouchReleasedProperty().set(value);
5471     }
5472 
5473     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
5474         return onTouchReleased == null ? null : onTouchReleased.get();
5475     }
5476 
5477     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleasedProperty() {
5478         if (onTouchReleased == null) {
5479             onTouchReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5480 
5481                 @Override
5482                 protected void invalidated() {
5483                     setEventHandler(TouchEvent.TOUCH_RELEASED, get());
5484                 }
5485 
5486                 @Override
5487                 public Object getBean() {
5488                     return Scene.this;
5489                 }
5490 
5491                 @Override
5492                 public String getName() {
5493                     return &quot;onTouchReleased&quot;;
5494                 }
5495             };
5496         }
5497         return onTouchReleased;
5498     }
5499 
5500     /**
5501      * Defines a function to be called when a touch point stays pressed and
5502      * still.
5503      * @since JavaFX 2.2
5504      */
5505     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationary;
5506 
5507     public final void setOnTouchStationary(EventHandler&lt;? super TouchEvent&gt; value) {
5508         onTouchStationaryProperty().set(value);
5509     }
5510 
5511     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
5512         return onTouchStationary == null ? null : onTouchStationary.get();
5513     }
5514 
5515     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationaryProperty() {
5516         if (onTouchStationary == null) {
5517             onTouchStationary = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5518 
5519                 @Override
5520                 protected void invalidated() {
5521                     setEventHandler(TouchEvent.TOUCH_STATIONARY, get());
5522                 }
5523 
5524                 @Override
5525                 public Object getBean() {
5526                     return Scene.this;
5527                 }
5528 
5529                 @Override
5530                 public String getName() {
5531                     return &quot;onTouchStationary&quot;;
5532                 }
5533             };
5534         }
5535         return onTouchStationary;
5536     }
5537 
5538     /*
5539      * This class provides reordering and ID mapping of particular touch points.
5540      * Platform may report arbitrary touch point IDs and they may be reused
5541      * during one gesture. This class keeps track of it and provides
5542      * sequentially sorted IDs, unique in scope of a gesture.
5543      *
5544      * Some platforms report always small numbers, these take fast paths through
5545      * the algorithm, directly indexing an array. Bigger numbers take a slow
5546      * path using a hash map.
5547      *
5548      * The algorithm performance was measured and it doesn&#39;t impose
5549      * any significant slowdown on the event delivery.
5550      */
5551     private static class TouchMap {
5552         private static final int FAST_THRESHOLD = 10;
5553         int[] fastMap = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
5554         Map&lt;Long, Integer&gt; slowMap = new HashMap&lt;Long, Integer&gt;();
5555         List&lt;Integer&gt; order = new LinkedList&lt;Integer&gt;();
5556         List&lt;Long&gt; removed = new ArrayList&lt;Long&gt;(10);
5557         int counter = 0;
5558         int active = 0;
5559 
5560         public int add(long id) {
5561             counter++;
5562             active++;
5563             if (id &lt; FAST_THRESHOLD) {
5564                 fastMap[(int) id] = counter;
5565             } else {
5566                 slowMap.put(id, counter);
5567             }
5568             order.add(counter);
5569             return counter;
5570         }
5571 
5572         public void remove(long id) {
5573             // book the removal - it needs to be done after all touch points
5574             // of an event are processed - see cleanup()
5575             removed.add(id);
5576         }
5577 
5578         public int get(long id) {
5579             if (id &lt; FAST_THRESHOLD) {
5580                 int result = fastMap[(int) id];
5581                 if (result == 0) {
5582                     throw new RuntimeException(&quot;Platform reported wrong &quot;
5583                             + &quot;touch point ID&quot;);
5584                 }
5585                 return result;
5586             } else {
5587                 try {
5588                     return slowMap.get(id);
5589                 } catch (NullPointerException e) {
5590                     throw new RuntimeException(&quot;Platform reported wrong &quot;
5591                             + &quot;touch point ID&quot;);
5592                 }
5593             }
5594         }
5595 
5596         public int getOrder(int id) {
5597             return order.indexOf(id);
5598         }
5599 
5600         // returns true if gesture finished (no finger is touched)
5601         public boolean cleanup() {
5602             for (long id : removed) {
5603                 active--;
5604                 order.remove(Integer.valueOf(get(id)));
5605                 if (id &lt; FAST_THRESHOLD) {
5606                     fastMap[(int) id] = 0;
5607                 } else {
5608                     slowMap.remove(id);
5609                 }
5610                 if (active == 0) {
5611                     // gesture finished
5612                     counter = 0;
5613                 }
5614             }
5615             removed.clear();
5616             return active == 0;
5617         }
5618     }
5619 
5620 
5621     /***************************************************************************
5622      *                                                                         *
5623      *                         Drag and Drop Handling                          *
5624      *                                                                         *
5625      **************************************************************************/
5626 
5627     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEntered;
5628 
5629     public final void setOnDragEntered(EventHandler&lt;? super DragEvent&gt; value) {
5630         onDragEnteredProperty().set(value);
5631     }
5632 
5633     public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
5634         return onDragEntered == null ? null : onDragEntered.get();
5635     }
5636 
5637     /**
5638      * Defines a function to be called when drag gesture
5639      * enters this {@code Scene}.
5640      * @return function to be called when drag gesture enters this scene
5641      */
5642     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEnteredProperty() {
5643         if (onDragEntered == null) {
5644             onDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5645 
5646                 @Override
5647                 protected void invalidated() {
5648                     setEventHandler(DragEvent.DRAG_ENTERED, get());
5649                 }
5650 
5651                 @Override
5652                 public Object getBean() {
5653                     return Scene.this;
5654                 }
5655 
5656                 @Override
5657                 public String getName() {
5658                     return &quot;onDragEntered&quot;;
5659                 }
5660             };
5661         }
5662         return onDragEntered;
5663     }
5664 
5665     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExited;
5666 
5667     public final void setOnDragExited(EventHandler&lt;? super DragEvent&gt; value) {
5668         onDragExitedProperty().set(value);
5669     }
5670 
5671     public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
5672         return onDragExited == null ? null : onDragExited.get();
5673     }
5674 
5675     /**
5676      * Defines a function to be called when drag gesture
5677      * exits this {@code Scene}.
5678      * @return the function to be called when drag gesture exits this scene
5679      */
5680     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExitedProperty() {
5681         if (onDragExited == null) {
5682             onDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5683 
5684                 @Override
5685                 protected void invalidated() {
5686                     setEventHandler(DragEvent.DRAG_EXITED, get());
5687                 }
5688 
5689                 @Override
5690                 public Object getBean() {
5691                     return Scene.this;
5692                 }
5693 
5694                 @Override
5695                 public String getName() {
5696                     return &quot;onDragExited&quot;;
5697                 }
5698             };
5699         }
5700         return onDragExited;
5701     }
5702 
5703     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOver;
5704 
5705     public final void setOnDragOver(EventHandler&lt;? super DragEvent&gt; value) {
5706         onDragOverProperty().set(value);
5707     }
5708 
5709     public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
5710         return onDragOver == null ? null : onDragOver.get();
5711     }
5712 
5713     /**
5714      * Defines a function to be called when drag gesture progresses
5715      * within this {@code Scene}.
5716      * @return the function to be called when drag gesture progresses within
5717      * this scene
5718      */
5719     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOverProperty() {
5720         if (onDragOver == null) {
5721             onDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5722 
5723                 @Override
5724                 protected void invalidated() {
5725                     setEventHandler(DragEvent.DRAG_OVER, get());
5726                 }
5727 
5728                 @Override
5729                 public Object getBean() {
5730                     return Scene.this;
5731                 }
5732 
5733                 @Override
5734                 public String getName() {
5735                     return &quot;onDragOver&quot;;
5736                 }
5737             };
5738         }
5739         return onDragOver;
5740     }
5741 
5742     // Do we want DRAG_TRANSFER_MODE_CHANGED event?
5743 //    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChanged;
5744 //
5745 //    public final void setOnDragTransferModeChanged(EventHandler&lt;? super DragEvent&gt; value) {
5746 //        onDragTransferModeChangedProperty().set(value);
5747 //    }
5748 //
5749 //    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
5750 //        return onDragTransferModeChanged == null ? null : onDragTransferModeChanged.get();
5751 //    }
5752 //
5753 //    /**
5754 //     * Defines a function to be called this {@code Scene} if it is a potential
5755 //     * drag-and-drop target when the user takes action to change the intended
5756 //     * {@code TransferMode}.
5757 //     * The user can change the intended {@link TransferMode} by holding down
5758 //     * or releasing key modifiers.
5759 //     */
5760 //    public ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChangedProperty() {
5761 //        if (onDragTransferModeChanged == null) {
5762 //            onDragTransferModeChanged = new SimpleObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5763 //
5764 //                @Override
5765 //                protected void invalidated() {
5766 //                    setEventHandler(DragEvent.DRAG_TRANSFER_MODE_CHANGED, get());
5767 //                }
5768 //            };
5769 //        }
5770 //        return onDragTransferModeChanged;
5771 //    }
5772 
5773     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDropped;
5774 
5775     public final void setOnDragDropped(EventHandler&lt;? super DragEvent&gt; value) {
5776         onDragDroppedProperty().set(value);
5777     }
5778 
5779     public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
5780         return onDragDropped == null ? null : onDragDropped.get();
5781     }
5782 
5783     /**
5784      * Defines a function to be called when the mouse button is released
5785      * on this {@code Scene} during drag and drop gesture. Transfer of data from
5786      * the {@link DragEvent}&#39;s {@link DragEvent#getDragboard() dragboard} should
5787      * happen in this function.
5788      * @return the function to be called when the mouse button is released on
5789      * this scene during drag and drop gesture
5790      */
5791     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDroppedProperty() {
5792         if (onDragDropped == null) {
5793             onDragDropped = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5794 
5795                 @Override
5796                 protected void invalidated() {
5797                     setEventHandler(DragEvent.DRAG_DROPPED, get());
5798                 }
5799 
5800                 @Override
5801                 public Object getBean() {
5802                     return Scene.this;
5803                 }
5804 
5805                 @Override
5806                 public String getName() {
5807                     return &quot;onDragDropped&quot;;
5808                 }
5809             };
5810         }
5811         return onDragDropped;
5812     }
5813 
5814     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDone;
5815 
5816     public final void setOnDragDone(EventHandler&lt;? super DragEvent&gt; value) {
5817         onDragDoneProperty().set(value);
5818     }
5819 
5820     public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
5821         return onDragDone == null ? null : onDragDone.get();
5822     }
5823 
5824     /**
5825      * Defines a function to be called when this {@code Scene} is a
5826      * drag and drop gesture source after its data has
5827      * been dropped on a drop target. The {@code transferMode} of the
5828      * event shows what just happened at the drop target.
5829      * If {@code transferMode} has the value {@code MOVE}, then the source can
5830      * clear out its data. Clearing the source&#39;s data gives the appropriate
5831      * appearance to a user that the data has been moved by the drag and drop
5832      * gesture. A {@code transferMode} that has the value {@code NONE}
5833      * indicates that no data was transferred during the drag and drop gesture.
5834      * Positional data for the {@code DragEvent} is invalid.  Valid positional
5835      * data for the {@code DragEvent} is presented in the
5836      * {@link #onDragDroppedProperty() onDragDropped} event handler.
5837      * @return the function to be called when this scene is a drag and drop
5838      * gesture source after its data has been dropped on a drop target
5839      */
5840     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDoneProperty() {
5841         if (onDragDone == null) {
5842             onDragDone = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5843 
5844                 @Override
5845                 protected void invalidated() {
5846                     setEventHandler(DragEvent.DRAG_DONE, get());
5847                 }
5848 
5849                 @Override
5850                 public Object getBean() {
5851                     return Scene.this;
5852                 }
5853 
5854                 @Override
5855                 public String getName() {
5856                     return &quot;onDragDone&quot;;
5857                 }
5858             };
5859         }
5860         return onDragDone;
5861     }
5862 
5863     /**
5864      * Confirms a potential drag and drop gesture that is recognized over this
5865      * {@code Scene}.
5866      * Can be called only from a DRAG_DETECTED event handler. The returned
5867      * {@link Dragboard} is used to transfer data during
5868      * the drag and drop gesture. Placing this {@code Scene}&#39;s data on the
5869      * {@link Dragboard} also identifies this {@code Scene} as the source of
5870      * the drag and drop gesture.
5871      * More detail about drag and drop gestures is described in the overivew
5872      * of {@link DragEvent}.
5873      *
5874      * @see DragEvent
5875      * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
5876      * @return A {@code Dragboard} to place this {@code Scene}&#39;s data on
5877      * @throws IllegalStateException if drag and drop cannot be started at this
5878      * moment (it&#39;s called outside of {@code DRAG_DETECTED} event handling).
5879      */
5880     public Dragboard startDragAndDrop(TransferMode... transferModes) {
5881         return startDragAndDrop(this, transferModes);
5882     }
5883 
5884     /**
5885      * Starts a full press-drag-release gesture with this scene as gesture
5886      * source. This method can be called only from a {@code DRAG_DETECTED} mouse
5887      * event handler. More detail about dragging gestures can be found
5888      * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
5889      *
5890      * @see MouseEvent
5891      * @see MouseDragEvent
5892      * @throws IllegalStateException if the full press-drag-release gesture
5893      * cannot be started at this moment (it&#39;s called outside of
5894      * {@code DRAG_DETECTED} event handling).
5895      * @since JavaFX 2.1
5896      */
5897     public void startFullDrag() {
5898         startFullDrag(this);
5899     }
5900 
5901 
5902     Dragboard startDragAndDrop(EventTarget source, TransferMode... transferModes) {
5903         Toolkit.getToolkit().checkFxUserThread();
5904         if (dndGesture == null ||
5905             (dndGesture.dragDetected != DragDetectedState.PROCESSING))
5906         {
5907             throw new IllegalStateException(&quot;Cannot start drag and drop &quot; +
5908                     &quot;outside of DRAG_DETECTED event handler&quot;);
5909         }
5910 
5911         Set&lt;TransferMode&gt; set = EnumSet.noneOf(TransferMode.class);
5912         for (TransferMode tm : InputEventUtils.safeTransferModes(transferModes)) {
5913             set.add(tm);
5914         }
5915         return dndGesture.startDrag(source, set);
5916     }
5917 
5918     void startFullDrag(EventTarget source) {
5919         Toolkit.getToolkit().checkFxUserThread();
5920         if (dndGesture.dragDetected != DragDetectedState.PROCESSING) {
5921             throw new IllegalStateException(&quot;Cannot start full drag &quot; +
5922                     &quot;outside of DRAG_DETECTED event handler&quot;);
5923         }
5924 
5925         if (dndGesture != null) {
5926             dndGesture.startFullPDR(source);
5927             return;
5928         }
5929 
5930         throw new IllegalStateException(&quot;Cannot start full drag when &quot;
5931                 + &quot;mouse button is not pressed&quot;);
5932     }
5933 
5934     /***************************************************************************
5935      *                                                                         *
5936      *                           Keyboard Handling                             *
5937      *                                                                         *
5938      **************************************************************************/
5939 
5940     /**
5941      * Defines a function to be called when some {@code Node} of this
5942      * {@code Scene} has input focus and a key has been pressed. The function
5943      * is called only if the event hasn&#39;t been already consumed during its
5944      * capturing or bubbling phase.
5945      */
5946     private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressed;
5947 
5948     public final void setOnKeyPressed(EventHandler&lt;? super KeyEvent&gt; value) {
5949         onKeyPressedProperty().set(value);
5950     }
5951 
5952     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
5953         return onKeyPressed == null ? null : onKeyPressed.get();
5954     }
5955 
5956     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressedProperty() {
5957         if (onKeyPressed == null) {
5958             onKeyPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {
5959 
5960                 @Override
5961                 protected void invalidated() {
5962                     setEventHandler(KeyEvent.KEY_PRESSED, get());
5963                 }
5964 
5965                 @Override
5966                 public Object getBean() {
5967                     return Scene.this;
5968                 }
5969 
5970                 @Override
5971                 public String getName() {
5972                     return &quot;onKeyPressed&quot;;
5973                 }
5974             };
5975         }
5976         return onKeyPressed;
5977     }
5978 
5979     /**
5980      * Defines a function to be called when some {@code Node} of this
5981      * {@code Scene} has input focus and a key has been released. The function
5982      * is called only if the event hasn&#39;t been already consumed during its
5983      * capturing or bubbling phase.
5984      */
5985     private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleased;
5986 
5987     public final void setOnKeyReleased(EventHandler&lt;? super KeyEvent&gt; value) {
5988         onKeyReleasedProperty().set(value);
5989     }
5990 
5991     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
5992         return onKeyReleased == null ? null : onKeyReleased.get();
5993     }
5994 
5995     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleasedProperty() {
5996         if (onKeyReleased == null) {
5997             onKeyReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {
5998 
5999                 @Override
6000                 protected void invalidated() {
6001                     setEventHandler(KeyEvent.KEY_RELEASED, get());
6002                 }
6003 
6004                 @Override
6005                 public Object getBean() {
6006                     return Scene.this;
6007                 }
6008 
6009                 @Override
6010                 public String getName() {
6011                     return &quot;onKeyReleased&quot;;
6012                 }
6013             };
6014         }
6015         return onKeyReleased;
6016     }
6017 
6018     /**
6019      * Defines a function to be called when some {@code Node} of this
6020      * {@code Scene} has input focus and a key has been typed. The function
6021      * is called only if the event hasn&#39;t been already consumed during its
6022      * capturing or bubbling phase.
6023      */
6024     private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTyped;
6025 
6026     public final void setOnKeyTyped(
6027             EventHandler&lt;? super KeyEvent&gt; value) {
6028         onKeyTypedProperty().set( value);
6029 
6030     }
6031 
6032     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped(
6033             ) {
6034         return onKeyTyped == null ? null : onKeyTyped.get();
6035     }
6036 
6037     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTypedProperty(
6038     ) {
6039         if (onKeyTyped == null) {
6040             onKeyTyped = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {
6041 
6042                 @Override
6043                 protected void invalidated() {
6044                     setEventHandler(KeyEvent.KEY_TYPED, get());
6045                 }
6046 
6047                 @Override
6048                 public Object getBean() {
6049                     return Scene.this;
6050                 }
6051 
6052                 @Override
6053                 public String getName() {
6054                     return &quot;onKeyTyped&quot;;
6055                 }
6056             };
6057         }
6058         return onKeyTyped;
6059     }
6060 
6061     /***************************************************************************
6062      *                                                                         *
6063      *                           Input Method Handling                         *
6064      *                                                                         *
6065      **************************************************************************/
6066 
6067     /**
6068      * Defines a function to be called when this {@code Node}
6069      * has input focus and the input method text has changed.  If this
6070      * function is not defined in this {@code Node}, then it
6071      * receives the result string of the input method composition as a
6072      * series of {@code onKeyTyped} function calls.
6073      * &lt;p&gt;
6074      * When the {@code Node} loses the input focus, the JavaFX runtime
6075      * automatically commits the existing composed text if any.
6076      */
6077     private ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChanged;
6078 
6079     public final void setOnInputMethodTextChanged(
6080             EventHandler&lt;? super InputMethodEvent&gt; value) {
6081         onInputMethodTextChangedProperty().set( value);
6082     }
6083 
6084     public final EventHandler&lt;? super InputMethodEvent&gt; getOnInputMethodTextChanged() {
6085         return onInputMethodTextChanged == null ? null : onInputMethodTextChanged.get();
6086     }
6087 
6088     public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChangedProperty() {
6089         if (onInputMethodTextChanged == null) {
6090             onInputMethodTextChanged = new ObjectPropertyBase&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;() {
6091 
6092                 @Override
6093                 protected void invalidated() {
6094                     setEventHandler(InputMethodEvent.INPUT_METHOD_TEXT_CHANGED, get());
6095                 }
6096 
6097                 @Override
6098                 public Object getBean() {
6099                     return Scene.this;
6100                 }
6101 
6102                 @Override
6103                 public String getName() {
6104                     return &quot;onInputMethodTextChanged&quot;;
6105                 }
6106             };
6107         }
6108         return onInputMethodTextChanged;
6109     }
6110 
6111     /*
6112      * This class represents a picked target - either node, or scne, or null.
6113      * It provides functionality needed for the targets and covers the fact
6114      * that they are different kinds of animals.
6115      */
6116     private static class TargetWrapper {
6117         private Scene scene;
6118         private Node node;
6119         private PickResult result;
6120 
6121         /**
6122          * Fills the list with the target and all its parents (including scene)
6123          */
6124         public void fillHierarchy(final List&lt;EventTarget&gt; list) {
6125             list.clear();
6126             Node n = node;
6127             while(n != null) {
6128                 list.add(n);
6129                 final Parent p = n.getParent();
6130                 n = p != null ? p : n.getSubScene();
6131             }
6132 
6133             if (scene != null) {
6134                 list.add(scene);
6135             }
6136         }
6137 
6138         public EventTarget getEventTarget() {
6139             return node != null ? node : scene;
6140         }
6141 
6142         public Cursor getCursor() {
6143             Cursor cursor = null;
6144             if (node != null) {
6145                 cursor = node.getCursor();
6146                 Node n = node.getParent();
6147                 while (cursor == null &amp;&amp; n != null) {
6148                     cursor = n.getCursor();
6149 
6150                     final Parent p = n.getParent();
6151                     n = p != null ? p : n.getSubScene();
6152                 }
6153             }
6154             return cursor;
6155         }
6156 
6157         public void clear() {
6158             set(null, null);
6159             result = null;
6160         }
6161 
6162         public void setNodeResult(PickResult result) {
6163             if (result != null) {
6164                 this.result = result;
6165                 final Node n = result.getIntersectedNode();
6166                 set(n, n.getScene());
6167             }
6168         }
6169 
6170         // Pass null scene if the mouse is outside of the window content
6171         public void setSceneResult(PickResult result, Scene scene) {
6172             if (result != null) {
6173                 this.result = result;
6174                 set(null, scene);
6175             }
6176         }
6177 
6178         public PickResult getResult() {
6179             return result;
6180         }
6181 
6182         public void copy(TargetWrapper tw) {
6183             node = tw.node;
6184             scene = tw.scene;
6185             result = tw.result;
6186         }
6187 
6188         private void set(Node n, Scene s) {
6189             node = n;
6190             scene = s;
6191         }
6192     }
6193 
6194     /*************************************************************************
6195     *                                                                        *
6196     *                                                                        *
6197     *                                                                        *
6198     *************************************************************************/
6199 
6200     private static final Object USER_DATA_KEY = new Object();
6201     // A map containing a set of properties for this scene
6202     private ObservableMap&lt;Object, Object&gt; properties;
6203 
6204     /**
6205       * Returns an observable map of properties on this node for use primarily
6206       * by application developers.
6207       *
6208       * @return an observable map of properties on this node for use primarily
6209       * by application developers
6210       *
6211       * @since JavaFX 8u40
6212       */
6213      public final ObservableMap&lt;Object, Object&gt; getProperties() {
6214         if (properties == null) {
6215             properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
6216         }
6217         return properties;
6218     }
6219 
6220     /**
6221      * Tests if Scene has properties.
6222      * @return true if node has properties.
6223      *
6224      * @since JavaFX 8u40
6225      */
6226      public boolean hasProperties() {
6227         return properties != null &amp;&amp; !properties.isEmpty();
6228     }
6229 
6230     /**
6231      * Convenience method for setting a single Object property that can be
6232      * retrieved at a later date. This is functionally equivalent to calling
6233      * the getProperties().put(Object key, Object value) method. This can later
6234      * be retrieved by calling {@link Scene#getUserData()}.
6235      *
6236      * @param value The value to be stored - this can later be retrieved by calling
6237      *          {@link Scene#getUserData()}.
6238      *
6239      * @since JavaFX 8u40
6240      */
6241     public void setUserData(Object value) {
6242         getProperties().put(USER_DATA_KEY, value);
6243     }
6244 
6245     /**
6246      * Returns a previously set Object property, or null if no such property
6247      * has been set using the {@link Scene#setUserData(java.lang.Object)} method.
6248      *
6249      * @return The Object that was previously set, or null if no property
6250      *          has been set or if null was set.
6251      *
6252      * @since JavaFX 8u40
6253      */
6254     public Object getUserData() {
6255         return getProperties().get(USER_DATA_KEY);
6256     }
6257 
6258     /***************************************************************************
6259      *                                                                         *
6260      *                       Component Orientation Properties                  *
6261      *                                                                         *
6262      **************************************************************************/
6263 
6264     private static final NodeOrientation defaultNodeOrientation =
6265         AccessController.doPrivileged(
6266                 (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.nodeOrientation.RTL&quot;)) ? NodeOrientation.RIGHT_TO_LEFT : NodeOrientation.INHERIT;
6267 
6268 
6269 
6270     private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
6271     private EffectiveOrientationProperty effectiveNodeOrientationProperty;
6272 
6273     private NodeOrientation effectiveNodeOrientation;
6274 
6275     public final void setNodeOrientation(NodeOrientation orientation) {
6276         nodeOrientationProperty().set(orientation);
6277     }
6278 
6279     public final NodeOrientation getNodeOrientation() {
6280         return nodeOrientation == null ? defaultNodeOrientation : nodeOrientation.get();
6281     }
6282 
6283     /**
6284      * Property holding NodeOrientation.
6285      * &lt;p&gt;
6286      * Node orientation describes the flow of visual data within a node.
6287      * In the English speaking world, visual data normally flows from
6288      * left-to-right. In an Arabic or Hebrew world, visual data flows
6289      * from right-to-left.  This is consistent with the reading order
6290      * of text in both worlds.  The default value is left-to-right.
6291      * &lt;/p&gt;
6292      *
6293      * @return NodeOrientation
6294      * @since JavaFX 8.0
6295      */
6296     public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
6297         if (nodeOrientation == null) {
6298             nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(defaultNodeOrientation) {
6299                 @Override
6300                 protected void invalidated() {
6301                     sceneEffectiveOrientationInvalidated();
6302                     getRoot().applyCss();
6303                 }
6304 
6305                 @Override
6306                 public Object getBean() {
6307                     return Scene.this;
6308                 }
6309 
6310                 @Override
6311                 public String getName() {
6312                     return &quot;nodeOrientation&quot;;
6313                 }
6314 
6315                 @Override
6316                 public CssMetaData getCssMetaData() {
6317                     //TODO - not yet supported
6318                     throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
6319                 }
6320             };
6321         }
6322         return nodeOrientation;
6323     }
6324 
6325     public final NodeOrientation getEffectiveNodeOrientation() {
6326         if (effectiveNodeOrientation == null) {
6327             effectiveNodeOrientation = calcEffectiveNodeOrientation();
6328         }
6329 
6330         return effectiveNodeOrientation;
6331     }
6332 
6333     /**
6334      * The effective node orientation of a scene resolves the inheritance of
6335      * node orientation, returning either left-to-right or right-to-left.
6336      * @return the effective node orientation of this scene
6337      * @since JavaFX 8.0
6338      */
6339     public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
6340             effectiveNodeOrientationProperty() {
6341         if (effectiveNodeOrientationProperty == null) {
6342             effectiveNodeOrientationProperty =
6343                     new EffectiveOrientationProperty();
6344         }
6345 
6346         return effectiveNodeOrientationProperty;
6347     }
6348 
6349     private void parentEffectiveOrientationInvalidated() {
6350         if (getNodeOrientation() == NodeOrientation.INHERIT) {
6351             sceneEffectiveOrientationInvalidated();
6352         }
6353     }
6354 
6355     private void sceneEffectiveOrientationInvalidated() {
6356         effectiveNodeOrientation = null;
6357 
6358         if (effectiveNodeOrientationProperty != null) {
6359             effectiveNodeOrientationProperty.invalidate();
6360         }
6361 
6362         getRoot().parentResolvedOrientationInvalidated();
6363     }
6364 
6365     private NodeOrientation calcEffectiveNodeOrientation() {
6366         NodeOrientation orientation = getNodeOrientation();
6367         if (orientation == NodeOrientation.INHERIT) {
6368             Window window = getWindow();
6369             if (window != null) {
6370                 Window parent = null;
6371                 if (window instanceof Stage) {
6372                     parent = ((Stage)window).getOwner();
6373                 } else {
6374                     if (window instanceof PopupWindow) {
6375                         parent = ((PopupWindow)window).getOwnerWindow();
6376                     }
6377                 }
6378                 if (parent != null) {
6379                     Scene scene = parent.getScene();
6380                     if (scene != null) return scene.getEffectiveNodeOrientation();
6381                 }
6382             }
6383             return NodeOrientation.LEFT_TO_RIGHT;
6384         }
6385         return orientation;
6386     }
6387 
6388     private final class EffectiveOrientationProperty
6389             extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
6390         @Override
6391         public NodeOrientation get() {
6392             return getEffectiveNodeOrientation();
6393         }
6394 
6395         @Override
6396         public Object getBean() {
6397             return Scene.this;
6398         }
6399 
6400         @Override
6401         public String getName() {
6402             return &quot;effectiveNodeOrientation&quot;;
6403         }
6404 
6405         public void invalidate() {
6406             fireValueChangedEvent();
6407         }
6408     }
6409 
6410     private Map&lt;Node, Accessible&gt; accMap;
6411     Accessible removeAccessible(Node node) {
6412         if (accMap == null) return null;
6413         return accMap.remove(node);
6414     }
6415 
6416     void addAccessible(Node node, Accessible acc) {
6417         if (accMap == null) {
6418             accMap = new HashMap&lt;Node, Accessible&gt;();
6419         }
6420         accMap.put(node, acc);
6421     }
6422 
6423     private void disposeAccessibles() {
6424         if (accMap != null) {
6425             for (Map.Entry&lt;Node, Accessible&gt; entry : accMap.entrySet()) {
6426                 Node node = entry.getKey();
6427                 Accessible acc = entry.getValue();
6428                 if (node.accessible != null) {
6429                     /* This node has already been initialized to another scene.
6430                      * Note an accessible can be returned to the node before the
6431                      * pulse if getAccessible() is called. In which case it must
6432                      * already being removed from accMap.
6433                      */
6434                     if (node.accessible == acc) {
6435                         System.err.println(&quot;[A11y] &#39;node.accessible == acc&#39; should never happen.&quot;);
6436                     }
6437                     if (node.getScene() == this) {
6438                         System.err.println(&quot;[A11y] &#39;node.getScene() == this&#39; should never happen.&quot;);
6439                     }
6440                     acc.dispose();
6441                 } else {
6442                     if (node.getScene() == this) {
6443                         node.accessible = acc;
6444                     } else {
6445                         acc.dispose();
6446                     }
6447                 }
6448             }
6449             accMap.clear();
6450         }
6451     }
6452 
6453     private Accessible accessible;
6454     Accessible getAccessible() {
6455         /*
6456          * The accessible for the Scene should never be
6457          * requested when the peer is not set.
6458          * This can only happen in a error case where a
6459          * descender of this Scene was not disposed and
6460          * it still being used by the AT client and trying
6461          * to reach to the top level window.
6462          */
6463         if (peer == null) return null;
6464         if (accessible == null) {
6465             accessible = Application.GetApplication().createAccessible();
6466             accessible.setEventHandler(new Accessible.EventHandler() {
6467                 @Override public AccessControlContext getAccessControlContext() {
6468                     return getPeer().getAccessControlContext();
6469                 }
6470 
6471                 @Override public Object getAttribute(AccessibleAttribute attribute,
6472                                                      Object... parameters) {
6473                     switch (attribute) {
6474                         case CHILDREN: {
6475                             Parent root = getRoot();
6476                             if (root != null) {
6477                                 return FXCollections.observableArrayList(root);
6478                             }
6479                             break;
6480                         }
6481                         case TEXT: {
6482                             Window w = getWindow();
6483                             if (w instanceof Stage) {
6484                                 return ((Stage)w).getTitle();
6485                             }
6486                             break;
6487                         }
6488                         case NODE_AT_POINT: {
6489                             Window window = getWindow();
6490                             /* is this screen to scene translation correct ? not considering camera ? */
6491                             Point2D pt = (Point2D)parameters[0];
6492                             PickResult res = pick(pt.getX() - getX() - window.getX(), pt.getY() - getY() - window.getY());
6493                             if (res != null) {
6494                                 Node node = res.getIntersectedNode();
6495                                 if (node != null) return node;
6496                             }
6497                             return getRoot();//not sure
6498                         }
6499                         case ROLE: return AccessibleRole.PARENT;
6500                         case SCENE: return Scene.this;
6501                         case FOCUS_NODE: {
6502                             if (transientFocusContainer != null) {
6503                                 return transientFocusContainer.queryAccessibleAttribute(AccessibleAttribute.FOCUS_NODE);
6504                             }
6505                             return getFocusOwner();
6506                         }
6507                         default:
6508                     }
6509                     return super.getAttribute(attribute, parameters);
6510                 }
6511             });
6512             PlatformImpl.accessibilityActiveProperty().set(true);
6513         }
6514         return accessible;
6515     }
6516 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>