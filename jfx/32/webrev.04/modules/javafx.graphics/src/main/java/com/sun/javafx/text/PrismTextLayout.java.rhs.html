<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/com/sun/javafx/text/PrismTextLayout.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.text;
  27 
  28 
  29 import javafx.scene.shape.LineTo;
  30 import javafx.scene.shape.MoveTo;
  31 import javafx.scene.shape.PathElement;
  32 import com.sun.javafx.font.CharToGlyphMapper;
  33 import com.sun.javafx.font.FontResource;
  34 import com.sun.javafx.font.FontStrike;
  35 import com.sun.javafx.font.Metrics;
  36 import com.sun.javafx.font.PGFont;
  37 import com.sun.javafx.font.PrismFontFactory;
  38 import com.sun.javafx.geom.BaseBounds;
  39 import com.sun.javafx.geom.Path2D;
  40 import com.sun.javafx.geom.Point2D;
  41 import com.sun.javafx.geom.RectBounds;
  42 import com.sun.javafx.geom.RoundRectangle2D;
  43 import com.sun.javafx.geom.Shape;
  44 import com.sun.javafx.geom.transform.BaseTransform;
  45 import com.sun.javafx.geom.transform.Translate2D;
  46 import com.sun.javafx.scene.text.GlyphList;
  47 import com.sun.javafx.scene.text.TextLayout;
  48 import com.sun.javafx.scene.text.TextSpan;
  49 import java.text.Bidi;
  50 import java.text.BreakIterator;
  51 import java.util.ArrayList;
  52 import java.util.Arrays;
  53 import java.util.Hashtable;
  54 
  55 public class PrismTextLayout implements TextLayout {
  56     private static final BaseTransform IDENTITY = BaseTransform.IDENTITY_TRANSFORM;
  57     private static final int X_MIN_INDEX = 0;
  58     private static final int Y_MIN_INDEX = 1;
  59     private static final int X_MAX_INDEX = 2;
  60     private static final int Y_MAX_INDEX = 3;
  61 
  62     private static final Hashtable&lt;Integer, LayoutCache&gt; stringCache = new Hashtable&lt;&gt;();
  63     private static final Object  CACHE_SIZE_LOCK = new Object();
  64     private static int cacheSize = 0;
  65     private static final int MAX_STRING_SIZE = 256;
  66     private static final int MAX_CACHE_SIZE = PrismFontFactory.cacheLayoutSize;
  67 
  68     private char[] text;
  69     private TextSpan[] spans;   /* Rich text  (null for single font text) */
  70     private PGFont font;        /* Single font text (null for rich text) */
  71     private FontStrike strike;  /* cached strike of font (identity) */
  72     private Integer cacheKey;
  73     private TextLine[] lines;
  74     private TextRun[] runs;
  75     private int runCount;
  76     private BaseBounds logicalBounds;
  77     private RectBounds visualBounds;
  78     private float layoutWidth, layoutHeight;
  79     private float wrapWidth, spacing;
  80     private LayoutCache layoutCache;
  81     private Shape shape;
  82     private int flags;
<a name="2" id="anc2"></a><span class="line-added">  83     private int tabSize = DEFAULT_TAB_SIZE;</span>
  84 
  85     public PrismTextLayout() {
  86         logicalBounds = new RectBounds();
  87         flags = ALIGN_LEFT;
  88     }
  89 
  90     private void reset() {
  91         layoutCache = null;
  92         runs = null;
  93         flags &amp;= ~ANALYSIS_MASK;
  94         relayout();
  95     }
  96 
  97     private void relayout() {
  98         logicalBounds.makeEmpty();
  99         visualBounds = null;
 100         layoutWidth = layoutHeight = 0;
 101         flags &amp;= ~(FLAGS_WRAPPED | FLAGS_CACHED_UNDERLINE | FLAGS_CACHED_STRIKETHROUGH);
 102         lines = null;
 103         shape = null;
 104     }
 105 
 106     /***************************************************************************
 107      *                                                                         *
 108      *                            TextLayout API                               *
 109      *                                                                         *
 110      **************************************************************************/
 111 
 112     public boolean setContent(TextSpan[] spans) {
 113         if (spans == null &amp;&amp; this.spans == null) return false;
 114         if (spans != null &amp;&amp; this.spans != null) {
 115             if (spans.length == this.spans.length) {
 116                 int i = 0;
 117                 while (i &lt; spans.length) {
 118                     if (spans[i] != this.spans[i]) break;
 119                     i++;
 120                 }
 121                 if (i == spans.length) return false;
 122             }
 123         }
 124 
 125         reset();
 126         this.spans = spans;
 127         this.font = null;
 128         this.strike = null;
 129         this.text = null;   /* Initialized in getText() */
 130         this.cacheKey = null;
 131         return true;
 132     }
 133 
 134     public boolean setContent(String text, Object font) {
 135         reset();
 136         this.spans = null;
 137         this.font = (PGFont)font;
 138         this.strike = ((PGFont)font).getStrike(IDENTITY);
 139         this.text = text.toCharArray();
 140         if (MAX_CACHE_SIZE &gt; 0) {
 141             int length = text.length();
 142             if (0 &lt; length &amp;&amp; length &lt;= MAX_STRING_SIZE) {
 143                 cacheKey = text.hashCode() * strike.hashCode();
 144             }
 145         }
 146         return true;
 147     }
 148 
 149     public boolean setDirection(int direction) {
 150         if ((flags &amp; DIRECTION_MASK) == direction) return false;
 151         flags &amp;= ~DIRECTION_MASK;
 152         flags |= (direction &amp; DIRECTION_MASK);
 153         reset();
 154         return true;
 155     }
 156 
 157     public boolean setBoundsType(int type) {
 158         if ((flags &amp; BOUNDS_MASK) == type) return false;
 159         flags &amp;= ~BOUNDS_MASK;
 160         flags |= (type &amp; BOUNDS_MASK);
 161         reset();
 162         return true;
 163     }
 164 
 165     public boolean setAlignment(int alignment) {
 166         int align = ALIGN_LEFT;
 167         switch (alignment) {
 168         case 0: align = ALIGN_LEFT; break;
 169         case 1: align = ALIGN_CENTER; break;
 170         case 2: align = ALIGN_RIGHT; break;
 171         case 3: align = ALIGN_JUSTIFY; break;
 172         }
 173         if ((flags &amp; ALIGN_MASK) == align) return false;
 174         if (align == ALIGN_JUSTIFY || (flags &amp; ALIGN_JUSTIFY) != 0) {
 175             reset();
 176         }
 177         flags &amp;= ~ALIGN_MASK;
 178         flags |= align;
 179         relayout();
 180         return true;
 181     }
 182 
 183     public boolean setWrapWidth(float newWidth) {
 184         if (Float.isInfinite(newWidth)) newWidth = 0;
 185         if (Float.isNaN(newWidth)) newWidth = 0;
 186         float oldWidth = this.wrapWidth;
 187         this.wrapWidth = Math.max(0, newWidth);
 188 
 189         boolean needsLayout = true;
 190         if (lines != null &amp;&amp; oldWidth != 0 &amp;&amp; newWidth != 0) {
 191             if ((flags &amp; ALIGN_LEFT) != 0) {
 192                 if (newWidth &gt; oldWidth) {
 193                     /* If wrapping width is increasing and there is no
 194                      * wrapped lines then the text remains valid.
 195                      */
 196                     if ((flags &amp; FLAGS_WRAPPED) == 0) {
 197                         needsLayout = false;
 198                     }
 199                 } else {
 200                     /* If wrapping width is decreasing but it is still
 201                      * greater than the max line width then the text
 202                      * remains valid.
 203                      */
 204                     if (newWidth &gt;= layoutWidth) {
 205                         needsLayout = false;
 206                     }
 207                 }
 208             }
 209         }
 210         if (needsLayout) relayout();
 211         return needsLayout;
 212     }
 213 
 214     public boolean setLineSpacing(float spacing) {
 215         if (this.spacing == spacing) return false;
 216         this.spacing = spacing;
 217         relayout();
 218         return true;
 219     }
 220 
 221     private void ensureLayout() {
 222         if (lines == null) {
 223             layout();
 224         }
 225     }
 226 
 227     public com.sun.javafx.scene.text.TextLine[] getLines() {
 228         ensureLayout();
 229         return lines;
 230     }
 231 
 232     public GlyphList[] getRuns() {
 233         ensureLayout();
 234         GlyphList[] result = new GlyphList[runCount];
 235         int count = 0;
 236         for (int i = 0; i &lt; lines.length; i++) {
 237             GlyphList[] lineRuns = lines[i].getRuns();
 238             int length = lineRuns.length;
 239             System.arraycopy(lineRuns, 0, result, count, length);
 240             count += length;
 241         }
 242         return result;
 243     }
 244 
 245     public BaseBounds getBounds() {
 246         ensureLayout();
 247         return logicalBounds;
 248     }
 249 
 250     public BaseBounds getBounds(TextSpan filter, BaseBounds bounds) {
 251         ensureLayout();
 252         float left = Float.POSITIVE_INFINITY;
 253         float top = Float.POSITIVE_INFINITY;
 254         float right = Float.NEGATIVE_INFINITY;
 255         float bottom = Float.NEGATIVE_INFINITY;
 256         if (filter != null) {
 257             for (int i = 0; i &lt; lines.length; i++) {
 258                 TextLine line = lines[i];
 259                 TextRun[] lineRuns = line.getRuns();
 260                 for (int j = 0; j &lt; lineRuns.length; j++) {
 261                     TextRun run = lineRuns[j];
 262                     TextSpan span = run.getTextSpan();
 263                     if (span != filter) continue;
 264                     Point2D location = run.getLocation();
 265                     float runLeft = location.x;
 266                     if (run.isLeftBearing()) {
 267                         runLeft += line.getLeftSideBearing();
 268                     }
 269                     float runRight = location.x + run.getWidth();
 270                     if (run.isRightBearing()) {
 271                         runRight += line.getRightSideBearing();
 272                     }
 273                     float runTop = location.y;
 274                     float runBottom = location.y + line.getBounds().getHeight() + spacing;
 275                     if (runLeft &lt; left) left = runLeft;
 276                     if (runTop &lt; top) top = runTop;
 277                     if (runRight &gt; right) right = runRight;
 278                     if (runBottom &gt; bottom) bottom = runBottom;
 279                 }
 280             }
 281         } else {
 282             top = bottom = 0;
 283             for (int i = 0; i &lt; lines.length; i++) {
 284                 TextLine line = lines[i];
 285                 RectBounds lineBounds = line.getBounds();
 286                 float lineLeft = lineBounds.getMinX() + line.getLeftSideBearing();
 287                 if (lineLeft &lt; left) left = lineLeft;
 288                 float lineRight = lineBounds.getMaxX() + line.getRightSideBearing();
 289                 if (lineRight &gt; right) right = lineRight;
 290                 bottom += lineBounds.getHeight();
 291             }
 292             if (isMirrored()) {
 293                 float width = getMirroringWidth();
 294                 float bearing = left;
 295                 left = width - right;
 296                 right = width - bearing;
 297             }
 298         }
 299         return bounds.deriveWithNewBounds(left, top, 0, right, bottom, 0);
 300     }
 301 
 302     public PathElement[] getCaretShape(int offset, boolean isLeading,
 303                                        float x, float y) {
 304         ensureLayout();
 305         int lineIndex = 0;
 306         int lineCount = getLineCount();
 307         while (lineIndex &lt; lineCount - 1) {
 308             TextLine line = lines[lineIndex];
 309             int lineEnd = line.getStart() + line.getLength();
 310             if (lineEnd &gt; offset) break;
 311             lineIndex++;
 312         }
 313         int sliptCaretOffset = -1;
 314         int level = 0;
 315         float lineX = 0, lineY = 0, lineHeight = 0;
 316         TextLine line = lines[lineIndex];
 317         TextRun[] runs = line.getRuns();
 318         int runCount = runs.length;
 319         int runIndex = -1;
 320         for (int i = 0; i &lt; runCount; i++) {
 321             TextRun run = runs[i];
 322             int runStart = run.getStart();
 323             int runEnd = run.getEnd();
 324             if (runStart &lt;= offset &amp;&amp; offset &lt; runEnd) {
 325                 if (!run.isLinebreak()) {
 326                     runIndex = i;
 327                 }
 328                 break;
 329             }
 330         }
 331         if (runIndex != -1) {
 332             TextRun run = runs[runIndex];
 333             int runStart = run.getStart();
 334             Point2D location = run.getLocation();
 335             lineX = location.x + run.getXAtOffset(offset - runStart, isLeading);
 336             lineY = location.y;
 337             lineHeight = line.getBounds().getHeight();
 338 
 339             if (isLeading) {
 340                 if (runIndex &gt; 0 &amp;&amp; offset == runStart) {
 341                     level = run.getLevel();
 342                     sliptCaretOffset = offset - 1;
 343                 }
 344             } else {
 345                 int runEnd = run.getEnd();
 346                 if (runIndex + 1 &lt; runs.length &amp;&amp; offset + 1 == runEnd) {
 347                     level = run.getLevel();
 348                     sliptCaretOffset = offset + 1;
 349                 }
 350             }
 351         } else {
 352             /* end of line (line break or offset&gt;=charCount) */
 353             int maxOffset = 0;
 354 
 355             /* set run index to zero to handle empty line case (only break line) */
 356             runIndex = 0;
 357             for (int i = 0; i &lt; runCount; i++) {
 358                 TextRun run = runs[i];
 359                 /*use the trailing edge of the last logical run*/
 360                 if (run.getStart() &gt;= maxOffset &amp;&amp; !run.isLinebreak()) {
 361                     maxOffset = run.getStart();
 362                     runIndex = i;
 363                 }
 364             }
 365             TextRun run = runs[runIndex];
 366             Point2D location = run.getLocation();
 367             lineX = location.x + (run.isLeftToRight() ? run.getWidth() : 0);
 368             lineY = location.y;
 369             lineHeight = line.getBounds().getHeight();
 370         }
 371         if (isMirrored()) {
 372             lineX = getMirroringWidth() - lineX;
 373         }
 374         lineX += x;
 375         lineY += y;
 376         if (sliptCaretOffset != -1) {
 377             for (int i = 0; i &lt; runs.length; i++) {
 378                 TextRun run = runs[i];
 379                 int runStart = run.getStart();
 380                 int runEnd = run.getEnd();
 381                 if (runStart &lt;= sliptCaretOffset &amp;&amp; sliptCaretOffset &lt; runEnd) {
 382                     if ((run.getLevel() &amp; 1) != (level &amp; 1)) {
 383                         Point2D location = run.getLocation();
 384                         float lineX2 = location.x;
 385                         if (isLeading) {
 386                             if ((level &amp; 1) != 0) lineX2 += run.getWidth();
 387                         } else {
 388                             if ((level &amp; 1) == 0) lineX2 += run.getWidth();
 389                         }
 390                         if (isMirrored()) {
 391                             lineX2 = getMirroringWidth() - lineX2;
 392                         }
 393                         lineX2 += x;
 394                         PathElement[] result = new PathElement[4];
 395                         result[0] = new MoveTo(lineX, lineY);
 396                         result[1] = new LineTo(lineX, lineY + lineHeight / 2);
 397                         result[2] = new MoveTo(lineX2, lineY + lineHeight / 2);
 398                         result[3] = new LineTo(lineX2, lineY + lineHeight);
 399                         return result;
 400                     }
 401                 }
 402             }
 403         }
 404         PathElement[] result = new PathElement[2];
 405         result[0] = new MoveTo(lineX, lineY);
 406         result[1] = new LineTo(lineX, lineY + lineHeight);
 407         return result;
 408     }
 409 
 410     public Hit getHitInfo(float x, float y) {
 411         int charIndex = -1;
 412         boolean leading = false;
 413 
 414         ensureLayout();
 415         int lineIndex = getLineIndex(y);
 416         if (lineIndex &gt;= getLineCount()) {
 417             charIndex = getCharCount();
 418         } else {
 419             if (isMirrored()) {
 420                 x = getMirroringWidth() - x;
 421             }
 422             TextLine line = lines[lineIndex];
 423             TextRun[] runs = line.getRuns();
 424             RectBounds bounds = line.getBounds();
 425             TextRun run = null;
 426             x -= bounds.getMinX();
 427             //TODO binary search
 428             for (int i = 0; i &lt; runs.length; i++) {
 429                 run = runs[i];
 430                 if (x &lt; run.getWidth()) break;
 431                 if (i + 1 &lt; runs.length) {
 432                     if (runs[i + 1].isLinebreak()) break;
 433                     x -= run.getWidth();
 434                 }
 435             }
 436             if (run != null) {
 437                 int[] trailing = new int[1];
 438                 charIndex = run.getStart() + run.getOffsetAtX(x, trailing);
 439                 leading = (trailing[0] == 0);
 440             } else {
 441                 //empty line, set to line break leading
 442                 charIndex = line.getStart();
 443                 leading = true;
 444             }
 445         }
 446         return new Hit(charIndex, -1, leading);
 447     }
 448 
 449     public PathElement[] getRange(int start, int end, int type,
 450                                   float x, float y) {
 451         ensureLayout();
 452         int lineCount = getLineCount();
 453         ArrayList&lt;PathElement&gt; result = new ArrayList&lt;PathElement&gt;();
 454         float lineY = 0;
 455 
 456         for  (int lineIndex = 0; lineIndex &lt; lineCount; lineIndex++) {
 457             TextLine line = lines[lineIndex];
 458             RectBounds lineBounds = line.getBounds();
 459             int lineStart = line.getStart();
 460             if (lineStart &gt;= end) break;
 461             int lineEnd = lineStart + line.getLength();
 462             if (start &gt; lineEnd) {
 463                 lineY += lineBounds.getHeight() + spacing;
 464                 continue;
 465             }
 466 
 467             /* The list of runs in the line is visually ordered.
 468              * Thus, finding the run that includes the selection end offset
 469              * does not mean that all selected runs have being visited.
 470              * Instead, this implementation first computes the number of selected
 471              * characters in the current line, then iterates over the runs consuming
 472              * selected characters till all of them are found.
 473              */
 474             TextRun[] runs = line.getRuns();
 475             int count = Math.min(lineEnd, end) - Math.max(lineStart, start);
 476             int runIndex = 0;
 477             float left = -1;
 478             float right = -1;
 479             float lineX = lineBounds.getMinX();
 480             while (count &gt; 0 &amp;&amp; runIndex &lt; runs.length) {
 481                 TextRun run = runs[runIndex];
 482                 int runStart = run.getStart();
 483                 int runEnd = run.getEnd();
 484                 float runWidth = run.getWidth();
 485                 int clmapStart = Math.max(runStart, Math.min(start, runEnd));
 486                 int clampEnd = Math.max(runStart, Math.min(end, runEnd));
 487                 int runCount = clampEnd - clmapStart;
 488                 if (runCount != 0) {
 489                     boolean ltr = run.isLeftToRight();
 490                     float runLeft;
 491                     if (runStart &gt; start) {
 492                         runLeft = ltr ? lineX : lineX + runWidth;
 493                     } else {
 494                         runLeft = lineX + run.getXAtOffset(start - runStart, true);
 495                     }
 496                     float runRight;
 497                     if (runEnd &lt; end) {
 498                         runRight = ltr ? lineX + runWidth : lineX;
 499                     } else {
 500                         runRight = lineX + run.getXAtOffset(end - runStart, true);
 501                     }
 502                     if (runLeft &gt; runRight) {
 503                         float tmp = runLeft;
 504                         runLeft = runRight;
 505                         runRight = tmp;
 506                     }
 507                     count -= runCount;
 508                     float top = 0, bottom = 0;
 509                     switch (type) {
 510                     case TYPE_TEXT:
 511                         top = lineY;
 512                         bottom = lineY + lineBounds.getHeight();
 513                         break;
 514                     case TYPE_UNDERLINE:
 515                     case TYPE_STRIKETHROUGH:
 516                         FontStrike fontStrike = null;
 517                         if (spans != null) {
 518                             TextSpan span = run.getTextSpan();
 519                             PGFont font = (PGFont)span.getFont();
 520                             if (font == null) break;
 521                             fontStrike = font.getStrike(IDENTITY);
 522                         } else {
 523                             fontStrike = strike;
 524                         }
 525                         top = lineY - run.getAscent();
 526                         Metrics metrics = fontStrike.getMetrics();
 527                         if (type == TYPE_UNDERLINE) {
 528                             top += metrics.getUnderLineOffset();
 529                             bottom = top + metrics.getUnderLineThickness();
 530                         } else {
 531                             top += metrics.getStrikethroughOffset();
 532                             bottom = top + metrics.getStrikethroughThickness();
 533                         }
 534                         break;
 535                     }
 536 
 537                     /* Merge continuous rectangles */
 538                     if (runLeft != right) {
 539                         if (left != -1 &amp;&amp; right != -1) {
 540                             float l = left, r = right;
 541                             if (isMirrored()) {
 542                                 float width = getMirroringWidth();
 543                                 l = width - l;
 544                                 r = width - r;
 545                             }
 546                             result.add(new MoveTo(x + l,  y + top));
 547                             result.add(new LineTo(x + r, y + top));
 548                             result.add(new LineTo(x + r, y + bottom));
 549                             result.add(new LineTo(x + l,  y + bottom));
 550                             result.add(new LineTo(x + l,  y + top));
 551                         }
 552                         left = runLeft;
 553                         right = runRight;
 554                     }
 555                     right = runRight;
 556                     if (count == 0) {
 557                         float l = left, r = right;
 558                         if (isMirrored()) {
 559                             float width = getMirroringWidth();
 560                             l = width - l;
 561                             r = width - r;
 562                         }
 563                         result.add(new MoveTo(x + l,  y + top));
 564                         result.add(new LineTo(x + r, y + top));
 565                         result.add(new LineTo(x + r, y + bottom));
 566                         result.add(new LineTo(x + l,  y + bottom));
 567                         result.add(new LineTo(x + l,  y + top));
 568                     }
 569                 }
 570                 lineX += runWidth;
 571                 runIndex++;
 572             }
 573             lineY += lineBounds.getHeight() + spacing;
 574         }
 575         return result.toArray(new PathElement[result.size()]);
 576     }
 577 
 578     public Shape getShape(int type, TextSpan filter) {
 579         ensureLayout();
 580         boolean text = (type &amp; TYPE_TEXT) != 0;
 581         boolean underline = (type &amp; TYPE_UNDERLINE) != 0;
 582         boolean strikethrough = (type &amp; TYPE_STRIKETHROUGH) != 0;
 583         boolean baselineType = (type &amp; TYPE_BASELINE) != 0;
 584         if (shape != null &amp;&amp; text &amp;&amp; !underline &amp;&amp; !strikethrough &amp;&amp; baselineType) {
 585             return shape;
 586         }
 587 
 588         Path2D outline = new Path2D();
 589         BaseTransform tx = new Translate2D(0, 0);
 590         /* Return a shape relative to the baseline of the first line so
 591          * it can be used for layout */
 592         float firstBaseline = 0;
 593         if (baselineType) {
 594             firstBaseline = -lines[0].getBounds().getMinY();
 595         }
 596         for (int i = 0; i &lt; lines.length; i++) {
 597             TextLine line = lines[i];
 598             TextRun[] runs = line.getRuns();
 599             RectBounds bounds = line.getBounds();
 600             float baseline = -bounds.getMinY();
 601             for (int j = 0; j &lt; runs.length; j++) {
 602                 TextRun run = runs[j];
 603                 FontStrike fontStrike = null;
 604                 if (spans != null) {
 605                     TextSpan span = run.getTextSpan();
 606                     if (filter != null &amp;&amp; span != filter) continue;
 607                     PGFont font = (PGFont)span.getFont();
 608 
 609                     /* skip embedded runs */
 610                     if (font == null) continue;
 611                     fontStrike = font.getStrike(IDENTITY);
 612                 } else {
 613                     fontStrike = strike;
 614                 }
 615                 Point2D location = run.getLocation();
 616                 float runX = location.x;
 617                 float runY = location.y + baseline - firstBaseline;
 618                 Metrics metrics = null;
 619                 if (underline || strikethrough) {
 620                     metrics = fontStrike.getMetrics();
 621                 }
 622                 if (underline) {
 623                     RoundRectangle2D rect = new RoundRectangle2D();
 624                     rect.x = runX;
 625                     rect.y = runY + metrics.getUnderLineOffset();
 626                     rect.width = run.getWidth();
 627                     rect.height = metrics.getUnderLineThickness();
 628                     outline.append(rect, false);
 629                 }
 630                 if (strikethrough) {
 631                     RoundRectangle2D rect = new RoundRectangle2D();
 632                     rect.x = runX;
 633                     rect.y = runY + metrics.getStrikethroughOffset();
 634                     rect.width = run.getWidth();
 635                     rect.height = metrics.getStrikethroughThickness();
 636                     outline.append(rect, false);
 637                 }
 638                 if (text &amp;&amp; run.getGlyphCount() &gt; 0) {
 639                     tx.restoreTransform(1, 0, 0, 1, runX, runY);
 640                     Path2D path = (Path2D)fontStrike.getOutline(run, tx);
 641                     outline.append(path, false);
 642                 }
 643             }
 644         }
 645 
 646         if (text &amp;&amp; !underline &amp;&amp; !strikethrough) {
 647             shape = outline;
 648         }
 649         return outline;
 650     }
 651 
<a name="3" id="anc3"></a><span class="line-added"> 652     @Override</span>
<span class="line-added"> 653     public boolean setTabSize(int spaces) {</span>
<span class="line-added"> 654         if (spaces &lt; 1) {</span>
<span class="line-added"> 655             spaces = 1;</span>
<span class="line-added"> 656         }</span>
<span class="line-added"> 657         if (tabSize != spaces) {</span>
<span class="line-added"> 658             tabSize = spaces;</span>
<span class="line-added"> 659             relayout();</span>
<span class="line-added"> 660             return true;</span>
<span class="line-added"> 661         }</span>
<span class="line-added"> 662         return false;</span>
<span class="line-added"> 663     }</span>
<span class="line-added"> 664 </span>
 665     /***************************************************************************
 666      *                                                                         *
 667      *                     Text Layout Implementation                          *
 668      *                                                                         *
 669      **************************************************************************/
 670 
 671     private int getLineIndex(float y) {
 672         int index = 0;
 673         float bottom = 0;
 674         int lineCount = getLineCount();
 675         while (index &lt; lineCount) {
 676             bottom += lines[index].getBounds().getHeight() + spacing;
 677             if (index + 1 == lineCount) bottom -= lines[index].getLeading();
 678             if (bottom &gt; y) break;
 679             index++;
 680         }
 681         return index;
 682     }
 683 
 684     private boolean copyCache() {
 685         int align = flags &amp; ALIGN_MASK;
 686         int boundsType = flags &amp; BOUNDS_MASK;
 687         /* Caching for boundsType == Center, bias towards  Modena */
 688         return wrapWidth != 0 || align != ALIGN_LEFT || boundsType == 0 || isMirrored();
 689     }
 690 
 691     private void initCache() {
 692         if (cacheKey != null) {
 693             if (layoutCache == null) {
 694                 LayoutCache cache = stringCache.get(cacheKey);
 695                 if (cache != null &amp;&amp; cache.font.equals(font) &amp;&amp; Arrays.equals(cache.text, text)) {
 696                     layoutCache = cache;
 697                     runs = cache.runs;
 698                     runCount = cache.runCount;
 699                     flags |= cache.analysis;
 700                 }
 701             }
 702             if (layoutCache != null) {
 703                 if (copyCache()) {
 704                     /* This instance has some property that requires it to
 705                      * build its own lines (i.e. wrapping width). Thus, only use
 706                      * the runs from the cache (and it needs to make a copy
 707                      * before using it as they will be modified).
 708                      * Note: the copy of the elements in the array happens in
 709                      * reuseRuns().
 710                      */
 711                     if (layoutCache.runs == runs) {
 712                         runs = new TextRun[runCount];
 713                         System.arraycopy(layoutCache.runs, 0, runs, 0, runCount);
 714                     }
 715                 } else {
 716                     if (layoutCache.lines != null) {
 717                         runs = layoutCache.runs;
 718                         runCount = layoutCache.runCount;
 719                         flags |= layoutCache.analysis;
 720                         lines = layoutCache.lines;
 721                         layoutWidth = layoutCache.layoutWidth;
 722                         layoutHeight = layoutCache.layoutHeight;
 723                         float ascent = lines[0].getBounds().getMinY();
 724                         logicalBounds = logicalBounds.deriveWithNewBounds(0, ascent, 0,
 725                                 layoutWidth, layoutHeight + ascent, 0);
 726                     }
 727                 }
 728             }
 729         }
 730     }
 731 
 732     private int getLineCount() {
 733         return lines.length;
 734     }
 735 
 736     private int getCharCount() {
 737         if (text != null) return text.length;
 738         int count = 0;
 739         for (int i = 0; i &lt; lines.length; i++) {
 740             count += lines[i].getLength();
 741         }
 742         return count;
 743     }
 744 
 745     public TextSpan[] getTextSpans() {
 746         return spans;
 747     }
 748 
 749     public PGFont getFont() {
 750         return font;
 751     }
 752 
 753     public int getDirection() {
 754         if ((flags &amp; DIRECTION_LTR) != 0) {
 755             return Bidi.DIRECTION_LEFT_TO_RIGHT;
 756         }
 757         if ((flags &amp; DIRECTION_RTL) != 0) {
 758             return Bidi.DIRECTION_RIGHT_TO_LEFT;
 759         }
 760         if ((flags &amp; DIRECTION_DEFAULT_LTR) != 0) {
 761             return Bidi.DIRECTION_DEFAULT_LEFT_TO_RIGHT;
 762         }
 763         if ((flags &amp; DIRECTION_DEFAULT_RTL) != 0) {
 764             return Bidi.DIRECTION_DEFAULT_RIGHT_TO_LEFT;
 765         }
 766         return Bidi.DIRECTION_DEFAULT_LEFT_TO_RIGHT;
 767     }
 768 
 769     public void addTextRun(TextRun run) {
 770         if (runCount + 1 &gt; runs.length) {
 771             TextRun[] newRuns = new TextRun[runs.length + 64];
 772             System.arraycopy(runs, 0, newRuns, 0, runs.length);
 773             runs = newRuns;
 774         }
 775         runs[runCount++] = run;
 776     }
 777 
 778     private void buildRuns(char[] chars) {
 779         runCount = 0;
 780         if (runs == null) {
 781             int count = Math.max(4, Math.min(chars.length / 16, 16));
 782             runs = new TextRun[count];
 783         }
 784         GlyphLayout layout = GlyphLayout.getInstance();
 785         flags = layout.breakRuns(this, chars, flags);
 786         layout.dispose();
 787         for (int j = runCount; j &lt; runs.length; j++) {
 788             runs[j] = null;
 789         }
 790     }
 791 
 792     private void shape(TextRun run, char[] chars, GlyphLayout layout) {
 793         FontStrike strike;
 794         PGFont font;
 795         if (spans != null) {
 796             if (spans.length == 0) return;
 797             TextSpan span = run.getTextSpan();
 798             font = (PGFont)span.getFont();
 799             if (font == null) {
 800                 RectBounds bounds = span.getBounds();
 801                 run.setEmbedded(bounds, span.getText().length());
 802                 return;
 803             }
 804             strike = font.getStrike(IDENTITY);
 805         } else {
 806             font = this.font;
 807             strike = this.strike;
 808         }
 809 
 810         /* init metrics for line breaks for empty lines */
 811         if (run.getAscent() == 0) {
 812             Metrics m = strike.getMetrics();
 813 
 814             /* The implementation of the center layoutBounds mode is to assure the
 815              * layout has the same number of pixels above and bellow the cap
 816              * height.
 817              */
 818             if ((flags &amp; BOUNDS_MASK) == BOUNDS_CENTER) {
 819                 float ascent = m.getAscent();
 820                 /* Segoe UI has a very large internal leading area, applying the
 821                  * center layoutBounds heuristics on it would result in several pixels
 822                  * being added to the descent. The final results would be
 823                  * overly large and visually unappealing. The fix is to reduce
 824                  * the ascent before applying the algorithm. */
 825                 if (font.getFamilyName().equals(&quot;Segoe UI&quot;)) {
 826                     ascent *= 0.80;
 827                 }
 828                 ascent = (int)(ascent-0.75);
 829                 float descent = (int)(m.getDescent()+0.75);
 830                 float leading = (int)(m.getLineGap()+0.75);
 831                 float capHeight = (int)(m.getCapHeight()+0.75);
 832                 float topPadding = -ascent - capHeight;
 833                 if (topPadding &gt; descent) {
 834                     descent = topPadding;
 835                 } else {
 836                     ascent += (topPadding - descent);
 837                 }
 838                 run.setMetrics(ascent, descent, leading);
 839             } else {
 840                 run.setMetrics(m.getAscent(), m.getDescent(), m.getLineGap());
 841             }
 842         }
 843 
 844         if (run.isTab()) return;
 845         if (run.isLinebreak()) return;
 846         if (run.getGlyphCount() &gt; 0) return;
 847         if (run.isComplex()) {
 848             /* Use GlyphLayout to shape complex text */
 849             layout.layout(run, font, strike, chars);
 850         } else {
 851             FontResource fr = strike.getFontResource();
 852             int start = run.getStart();
 853             int length = run.getLength();
 854 
 855             /* No glyph layout required */
 856             if (layoutCache == null) {
 857                 float fontSize = strike.getSize();
 858                 CharToGlyphMapper mapper  = fr.getGlyphMapper();
 859 
 860                 /* The text contains complex and non-complex runs */
 861                 int[] glyphs = new int[length];
 862                 mapper.charsToGlyphs(start, length, chars, glyphs);
 863                 float[] positions = new float[(length + 1) &lt;&lt; 1];
 864                 float xadvance = 0;
 865                 for (int i = 0; i &lt; length; i++) {
 866                     float width = fr.getAdvance(glyphs[i], fontSize);
 867                     positions[i&lt;&lt;1] = xadvance;
 868                     //yadvance always zero
 869                     xadvance += width;
 870                 }
 871                 positions[length&lt;&lt;1] = xadvance;
 872                 run.shape(length, glyphs, positions, null);
 873             } else {
 874 
 875                 /* The text only contains non-complex runs, all the glyphs and
 876                  * advances are stored in the shapeCache */
 877                 if (!layoutCache.valid) {
 878                     float fontSize = strike.getSize();
 879                     CharToGlyphMapper mapper  = fr.getGlyphMapper();
 880                     mapper.charsToGlyphs(start, length, chars, layoutCache.glyphs, start);
 881                     int end = start + length;
 882                     float width = 0;
 883                     for (int i = start; i &lt; end; i++) {
 884                         float adv = fr.getAdvance(layoutCache.glyphs[i], fontSize);
 885                         layoutCache.advances[i] = adv;
 886                         width += adv;
 887                     }
 888                     run.setWidth(width);
 889                 }
 890                 run.shape(length, layoutCache.glyphs, layoutCache.advances);
 891             }
 892         }
 893     }
 894 
 895     private TextLine createLine(int start, int end, int startOffset) {
 896         int count = end - start + 1;
 897         TextRun[] lineRuns = new TextRun[count];
 898         if (start &lt; runCount) {
 899             System.arraycopy(runs, start, lineRuns, 0, count);
 900         }
 901 
 902         /* Recompute line width, height, and length (wrapping) */
 903         float width = 0, ascent = 0, descent = 0, leading = 0;
 904         int length = 0;
 905         for (int i = 0; i &lt; lineRuns.length; i++) {
 906             TextRun run = lineRuns[i];
 907             width += run.getWidth();
 908             ascent = Math.min(ascent, run.getAscent());
 909             descent = Math.max(descent, run.getDescent());
 910             leading = Math.max(leading, run.getLeading());
 911             length += run.getLength();
 912         }
 913         if (width &gt; layoutWidth) layoutWidth = width;
 914         return new TextLine(startOffset, length, lineRuns,
 915                             width, ascent, descent, leading);
 916     }
 917 
 918     private void reorderLine(TextLine line) {
 919         TextRun[] runs = line.getRuns();
 920         int length = runs.length;
 921         if (length &gt; 0 &amp;&amp; runs[length - 1].isLinebreak()) {
 922             length--;
 923         }
 924         if (length &lt; 2) return;
 925         byte[] levels = new byte[length];
 926         for (int i = 0; i &lt; length; i++) {
 927             levels[i] = runs[i].getLevel();
 928         }
 929         Bidi.reorderVisually(levels, 0, runs, 0, length);
 930     }
 931 
 932     private char[] getText() {
 933         if (text == null) {
 934             int count = 0;
 935             for (int i = 0; i &lt; spans.length; i++) {
 936                 count += spans[i].getText().length();
 937             }
 938             text = new char[count];
 939             int offset = 0;
 940             for (int i = 0; i &lt; spans.length; i++) {
 941                 String string = spans[i].getText();
 942                 int length = string.length();
 943                 string.getChars(0, length, text, offset);
 944                 offset += length;
 945             }
 946         }
 947         return text;
 948     }
 949 
 950     private boolean isSimpleLayout() {
 951         int textAlignment = flags &amp; ALIGN_MASK;
 952         boolean justify = wrapWidth &gt; 0 &amp;&amp; textAlignment == ALIGN_JUSTIFY;
 953         int mask = FLAGS_HAS_BIDI | FLAGS_HAS_COMPLEX;
 954         return (flags &amp; mask) == 0 &amp;&amp; !justify;
 955     }
 956 
 957     private boolean isMirrored() {
 958         boolean mirrored = false;
 959         switch (flags &amp; DIRECTION_MASK) {
 960         case DIRECTION_RTL: mirrored = true; break;
 961         case DIRECTION_LTR: mirrored = false; break;
 962         case DIRECTION_DEFAULT_LTR:
 963         case DIRECTION_DEFAULT_RTL:
 964             mirrored = (flags &amp; FLAGS_RTL_BASE) != 0;
 965         }
 966         return mirrored;
 967     }
 968 
 969     private float getMirroringWidth() {
 970         /* The text node in the scene layer is mirrored based on
 971          * result of computeLayoutBounds. The coordinate translation
 972          * in text layout has to be based on the same width.
 973          */
 974         return wrapWidth != 0 ? wrapWidth : layoutWidth;
 975     }
 976 
 977     private void reuseRuns() {
 978         /* The runs list is always accessed by the same thread (as TextLayout
 979          * is not thread safe) thus it can be modified at any time, but the
 980          * elements inside of the list are shared among threads and cannot be
 981          * modified. Each reused element has to be cloned.*/
 982         runCount = 0;
 983         int index = 0;;
 984         while (index &lt; runs.length) {
 985             TextRun run = runs[index];
 986             if (run == null) break;
 987             runs[index] = null;
 988             index++;
 989             runs[runCount++] = run = run.unwrap();
 990 
 991             if (run.isSplit()) {
 992                 run.merge(null); /* unmark split */
 993                 while (index &lt; runs.length) {
 994                     TextRun nextRun = runs[index];
 995                     if (nextRun == null) break;
 996                     run.merge(nextRun);
 997                     runs[index] = null;
 998                     index++;
 999                     if (nextRun.isSplitLast()) break;
1000                 }
1001             }
1002         }
1003     }
1004 
1005     private float getTabAdvance() {
1006         float spaceAdvance = 0;
1007         if (spans != null) {
1008             /* Rich text case - use the first font (for now) */
1009             for (int i = 0; i &lt; spans.length; i++) {
1010                 TextSpan span = spans[i];
1011                 PGFont font = (PGFont)span.getFont();
1012                 if (font != null) {
1013                     FontStrike strike = font.getStrike(IDENTITY);
1014                     spaceAdvance = strike.getCharAdvance(&#39; &#39;);
1015                     break;
1016                 }
1017             }
1018         } else {
1019             spaceAdvance = strike.getCharAdvance(&#39; &#39;);
1020         }
<a name="4" id="anc4"></a><span class="line-modified">1021         return tabSize * spaceAdvance;</span>
1022     }
1023 
1024     private void layout() {
1025         /* Try the cache */
1026         initCache();
1027 
1028         /* Whole layout retrieved from the cache */
1029         if (lines != null) return;
1030         char[] chars = getText();
1031 
1032         /* runs and runCount are set in reuseRuns or buildRuns */
1033         if ((flags &amp; FLAGS_ANALYSIS_VALID) != 0 &amp;&amp; isSimpleLayout()) {
1034             reuseRuns();
1035         } else {
1036             buildRuns(chars);
1037         }
1038 
1039         GlyphLayout layout = null;
1040         if ((flags &amp; (FLAGS_HAS_COMPLEX)) != 0) {
1041             layout = GlyphLayout.getInstance();
1042         }
1043 
1044         float tabAdvance = 0;
1045         if ((flags &amp; FLAGS_HAS_TABS) != 0) {
1046             tabAdvance = getTabAdvance();
1047         }
1048 
1049         BreakIterator boundary = null;
1050         if (wrapWidth &gt; 0) {
1051             if ((flags &amp; (FLAGS_HAS_COMPLEX | FLAGS_HAS_CJK)) != 0) {
1052                 boundary = BreakIterator.getLineInstance();
1053                 boundary.setText(new CharArrayIterator(chars));
1054             }
1055         }
1056         int textAlignment = flags &amp; ALIGN_MASK;
1057 
1058         /* Optimize simple case: reuse the glyphs and advances as long as the
1059          * text and font are the same.
1060          * The simple case is no bidi, no complex, no justify, no features.
1061          */
1062 
1063         if (isSimpleLayout()) {
1064             if (layoutCache == null) {
1065                 layoutCache = new LayoutCache();
1066                 layoutCache.glyphs = new int[chars.length];
1067                 layoutCache.advances = new float[chars.length];
1068             }
1069         } else {
1070             layoutCache = null;
1071         }
1072 
1073         float lineWidth = 0;
1074         int startIndex = 0;
1075         int startOffset = 0;
1076         ArrayList&lt;TextLine&gt; linesList = new ArrayList&lt;TextLine&gt;();
1077         for (int i = 0; i &lt; runCount; i++) {
1078             TextRun run = runs[i];
1079             shape(run, chars, layout);
1080             if (run.isTab()) {
1081                 float tabStop = ((int)(lineWidth / tabAdvance) +1) * tabAdvance;
1082                 run.setWidth(tabStop - lineWidth);
1083             }
1084 
1085             float runWidth = run.getWidth();
1086             if (wrapWidth &gt; 0 &amp;&amp; lineWidth + runWidth &gt; wrapWidth &amp;&amp; !run.isLinebreak()) {
1087 
1088                 /* Find offset of the first character that does not fit on the line */
1089                 int hitOffset = run.getStart() + run.getWrapIndex(wrapWidth - lineWidth);
1090 
1091                 /* Only keep whitespaces (not tabs) in the current run to avoid
1092                  * dealing with unshaped runs.
1093                  */
1094                 int offset = hitOffset;
1095                 int runEnd = run.getEnd();
1096                 while (offset + 1 &lt; runEnd &amp;&amp; chars[offset] == &#39; &#39;) {
1097                     offset++;
1098                     /* Preserve behaviour: only keep one white space in the line
1099                      * before wrapping. Needed API to allow change.
1100                      */
1101                     break;
1102                 }
1103 
1104                 /* Find the break opportunity */
1105                 int breakOffset = offset;
1106                 if (boundary != null) {
1107                     /* Use Java BreakIterator when complex script are present */
1108                     breakOffset = boundary.isBoundary(offset) || chars[offset] == &#39;\t&#39; ? offset : boundary.preceding(offset);
1109                 } else {
1110                     /* Simple break strategy for latin text (Performance) */
1111                     boolean currentChar = Character.isWhitespace(chars[breakOffset]);
1112                     while (breakOffset &gt; startOffset) {
1113                         boolean previousChar = Character.isWhitespace(chars[breakOffset - 1]);
1114                         if (!currentChar &amp;&amp; previousChar) break;
1115                         currentChar = previousChar;
1116                         breakOffset--;
1117                     }
1118                 }
1119 
1120                 /* Never break before the line start offset */
1121                 if (breakOffset &lt; startOffset) breakOffset = startOffset;
1122 
1123                 /* Find the run that contains the break offset */
1124                 int breakRunIndex = startIndex;
1125                 TextRun breakRun = null;
1126                 while (breakRunIndex &lt; runCount) {
1127                     breakRun = runs[breakRunIndex];
1128                     if (breakRun.getEnd() &gt; breakOffset) break;
1129                     breakRunIndex++;
1130                 }
1131 
1132                 /* No line breaks  between hit offset and line start offset.
1133                  * Try character wrapping mode at the hit offset.
1134                  */
1135                 if (breakOffset == startOffset) {
1136                     breakRun = run;
1137                     breakRunIndex = i;
1138                     breakOffset = hitOffset;
1139                 }
1140 
1141                 int breakOffsetInRun = breakOffset - breakRun.getStart();
1142                 /* Wrap the entire run to the next (only if it is not the first
1143                  * run of the line).
1144                  */
1145                 if (breakOffsetInRun == 0 &amp;&amp; breakRunIndex != startIndex) {
1146                     i = breakRunIndex - 1;
1147                 } else {
1148                     i = breakRunIndex;
1149 
1150                     /* The break offset is at the first offset of the first run of the line.
1151                      * This happens when the wrap width is smaller than the width require
1152                      * to show the first character for the line.
1153                      */
1154                     if (breakOffsetInRun == 0) {
1155                         breakOffsetInRun++;
1156                     }
1157                     if (breakOffsetInRun &lt; breakRun.getLength()) {
1158                         if (runCount &gt;= runs.length) {
1159                             TextRun[] newRuns = new TextRun[runs.length + 64];
1160                             System.arraycopy(runs, 0, newRuns, 0, i + 1);
1161                             System.arraycopy(runs, i + 1, newRuns, i + 2, runs.length - i - 1);
1162                             runs = newRuns;
1163                         } else {
1164                             System.arraycopy(runs, i + 1, runs, i + 2, runCount - i - 1);
1165                         }
1166                         runs[i + 1] = breakRun.split(breakOffsetInRun);
1167                         if (breakRun.isComplex()) {
1168                             shape(breakRun, chars, layout);
1169                         }
1170                         runCount++;
1171                     }
1172                 }
1173 
1174                 /* No point marking the last run of a line a softbreak */
1175                 if (i + 1 &lt; runCount &amp;&amp; !runs[i + 1].isLinebreak()) {
1176                     run = runs[i];
1177                     run.setSoftbreak();
1178                     flags |= FLAGS_WRAPPED;
1179 
1180                     // Tabs should preserve width
1181 
1182                     /*
1183                      * Due to contextual forms (arabic) it is possible this line
1184                      * is still too big since the splitting of the arabic run
1185                      * changes the shape of boundary glyphs. For now the
1186                      * implementation has opted to have the appropriate
1187                      * initial/final shapes and allow those glyphs to
1188                      * potentially overlap the wrapping width, rather than use
1189                      * the medial form within the wrappingWidth. A better place
1190                      * to solve this would be TextRun#getWrapIndex - but its TBD
1191                      * there too.
1192                      */
1193                 }
1194             }
1195 
1196             lineWidth += runWidth;
1197             if (run.isBreak()) {
1198                 TextLine line = createLine(startIndex, i, startOffset);
1199                 linesList.add(line);
1200                 startIndex = i + 1;
1201                 startOffset += line.getLength();
1202                 lineWidth = 0;
1203             }
1204         }
1205         if (layout != null) layout.dispose();
1206 
1207         linesList.add(createLine(startIndex, runCount - 1, startOffset));
1208         lines = new TextLine[linesList.size()];
1209         linesList.toArray(lines);
1210 
1211         float fullWidth = Math.max(wrapWidth, layoutWidth);
1212         float lineY = 0;
1213         float align;
1214         if (isMirrored()) {
1215             align = 1; /* Left and Justify */
1216             if (textAlignment == ALIGN_RIGHT) align = 0;
1217         } else {
1218             align = 0; /* Left and Justify */
1219             if (textAlignment == ALIGN_RIGHT) align = 1;
1220         }
1221         if (textAlignment == ALIGN_CENTER) align = 0.5f;
1222         for (int i = 0; i &lt; lines.length; i++) {
1223             TextLine line = lines[i];
1224             int lineStart = line.getStart();
1225             RectBounds bounds = line.getBounds();
1226 
1227             /* Center and right alignment */
1228             float lineX = (fullWidth - bounds.getWidth()) * align;
1229             line.setAlignment(lineX);
1230 
1231             /* Justify */
1232             boolean justify = wrapWidth &gt; 0 &amp;&amp; textAlignment == ALIGN_JUSTIFY;
1233             if (justify) {
1234                 TextRun[] lineRuns = line.getRuns();
1235                 int lineRunCount = lineRuns.length;
1236                 if (lineRunCount &gt; 0 &amp;&amp; lineRuns[lineRunCount - 1].isSoftbreak()) {
1237                     /* count white spaces but skipping trailings whitespaces */
1238                     int lineEnd = lineStart + line.getLength();
1239                     int wsCount = 0;
1240                     boolean hitChar = false;
1241                     for (int j = lineEnd - 1; j &gt;= lineStart; j--) {
1242                         if (!hitChar &amp;&amp; chars[j] != &#39; &#39;) hitChar = true;
1243                         if (hitChar &amp;&amp; chars[j] == &#39; &#39;) wsCount++;
1244                     }
1245                     if (wsCount != 0) {
1246                         float inc = (fullWidth - bounds.getWidth()) / wsCount;
1247                         done:
1248                         for (int j = 0; j &lt; lineRunCount; j++) {
1249                             TextRun textRun = lineRuns[j];
1250                             int runStart = textRun.getStart();
1251                             int runEnd = textRun.getEnd();
1252                             for (int k = runStart; k &lt; runEnd; k++) {
1253                                 // TODO kashidas
1254                                 if (chars[k] == &#39; &#39;) {
1255                                     textRun.justify(k - runStart, inc);
1256                                     if (--wsCount == 0) break done;
1257                                 }
1258                             }
1259                         }
1260                         lineX = 0;
1261                         line.setAlignment(lineX);
1262                         line.setWidth(fullWidth);
1263                     }
1264                 }
1265             }
1266 
1267             if ((flags &amp; FLAGS_HAS_BIDI) != 0) {
1268                 reorderLine(line);
1269             }
1270 
1271             computeSideBearings(line);
1272 
1273             /* Set run location */
1274             float runX = lineX;
1275             TextRun[] lineRuns = line.getRuns();
1276             for (int j = 0; j &lt; lineRuns.length; j++) {
1277                 TextRun run = lineRuns[j];
1278                 run.setLocation(runX, lineY);
1279                 run.setLine(line);
1280                 runX += run.getWidth();
1281             }
1282             if (i + 1 &lt; lines.length) {
1283                 lineY = Math.max(lineY, lineY + bounds.getHeight() + spacing);
1284             } else {
1285                 lineY += (bounds.getHeight() - line.getLeading());
1286             }
1287         }
1288         float ascent = lines[0].getBounds().getMinY();
1289         layoutHeight = lineY;
1290         logicalBounds = logicalBounds.deriveWithNewBounds(0, ascent, 0, layoutWidth,
1291                                             layoutHeight + ascent, 0);
1292 
1293 
1294         if (layoutCache != null) {
1295             if (cacheKey != null &amp;&amp; !layoutCache.valid &amp;&amp; !copyCache()) {
1296                 /* After layoutCache is added to the stringCache it can be
1297                  * accessed by multiple threads. All the data in it must
1298                  * be immutable. See copyCache() for the cases where the entire
1299                  * layout is immutable.
1300                  */
1301                 layoutCache.font = font;
1302                 layoutCache.text = text;
1303                 layoutCache.runs = runs;
1304                 layoutCache.runCount = runCount;
1305                 layoutCache.lines = lines;
1306                 layoutCache.layoutWidth = layoutWidth;
1307                 layoutCache.layoutHeight = layoutHeight;
1308                 layoutCache.analysis = flags &amp; ANALYSIS_MASK;
1309                 synchronized (CACHE_SIZE_LOCK) {
1310                     int charCount = chars.length;
1311                     if (cacheSize + charCount &gt; MAX_CACHE_SIZE) {
1312                         stringCache.clear();
1313                         cacheSize = 0;
1314                     }
1315                     stringCache.put(cacheKey, layoutCache);
1316                     cacheSize += charCount;
1317                 }
1318             }
1319             layoutCache.valid = true;
1320         }
1321     }
1322 
1323     @Override
1324     public BaseBounds getVisualBounds(int type) {
1325         ensureLayout();
1326 
1327         /* Not defined for rich text */
1328         if (strike == null) {
1329             return null;
1330         }
1331 
1332         boolean underline = (type &amp; TYPE_UNDERLINE) != 0;
1333         boolean hasUnderline = (flags &amp; FLAGS_CACHED_UNDERLINE) != 0;
1334         boolean strikethrough = (type &amp; TYPE_STRIKETHROUGH) != 0;
1335         boolean hasStrikethrough = (flags &amp; FLAGS_CACHED_STRIKETHROUGH) != 0;
1336         if (visualBounds != null &amp;&amp; underline == hasUnderline
1337                 &amp;&amp; strikethrough == hasStrikethrough) {
1338             /* Return last cached value */
1339             return visualBounds;
1340         }
1341 
1342         flags &amp;= ~(FLAGS_CACHED_STRIKETHROUGH | FLAGS_CACHED_UNDERLINE);
1343         if (underline) flags |= FLAGS_CACHED_UNDERLINE;
1344         if (strikethrough) flags |= FLAGS_CACHED_STRIKETHROUGH;
1345         visualBounds = new RectBounds();
1346 
1347         float xMin = Float.POSITIVE_INFINITY;
1348         float yMin = Float.POSITIVE_INFINITY;
1349         float xMax = Float.NEGATIVE_INFINITY;
1350         float yMax = Float.NEGATIVE_INFINITY;
1351         float bounds[] = new float[4];
1352         FontResource fr = strike.getFontResource();
1353         Metrics metrics = strike.getMetrics();
1354         float size = strike.getSize();
1355         for (int i = 0; i &lt; lines.length; i++) {
1356             TextLine line = lines[i];
1357             TextRun[] runs = line.getRuns();
1358             for (int j = 0; j &lt; runs.length; j++) {
1359                 TextRun run = runs[j];
1360                 Point2D pt = run.getLocation();
1361                 if (run.isLinebreak()) continue;
1362                 int glyphCount = run.getGlyphCount();
1363                 for (int gi = 0; gi &lt; glyphCount; gi++) {
1364                     int gc = run.getGlyphCode(gi);
1365                     if (gc != CharToGlyphMapper.INVISIBLE_GLYPH_ID) {
1366                         fr.getGlyphBoundingBox(run.getGlyphCode(gi), size, bounds);
1367                         if (bounds[X_MIN_INDEX] != bounds[X_MAX_INDEX]) {
1368                             float glyphX = pt.x + run.getPosX(gi);
1369                             float glyphY = pt.y + run.getPosY(gi);
1370                             float glyphMinX = glyphX + bounds[X_MIN_INDEX];
1371                             float glyphMinY = glyphY - bounds[Y_MAX_INDEX];
1372                             float glyphMaxX = glyphX + bounds[X_MAX_INDEX];
1373                             float glyphMaxY = glyphY - bounds[Y_MIN_INDEX];
1374                             if (glyphMinX &lt; xMin) xMin = glyphMinX;
1375                             if (glyphMinY &lt; yMin) yMin = glyphMinY;
1376                             if (glyphMaxX &gt; xMax) xMax = glyphMaxX;
1377                             if (glyphMaxY &gt; yMax) yMax = glyphMaxY;
1378                         }
1379                     }
1380                 }
1381                 if (underline) {
1382                     float underlineMinX = pt.x;
1383                     float underlineMinY = pt.y + metrics.getUnderLineOffset();
1384                     float underlineMaxX = underlineMinX + run.getWidth();
1385                     float underlineMaxY = underlineMinY + metrics.getUnderLineThickness();
1386                     if (underlineMinX &lt; xMin) xMin = underlineMinX;
1387                     if (underlineMinY &lt; yMin) yMin = underlineMinY;
1388                     if (underlineMaxX &gt; xMax) xMax = underlineMaxX;
1389                     if (underlineMaxY &gt; yMax) yMax = underlineMaxY;
1390                 }
1391                 if (strikethrough) {
1392                     float strikethroughMinX = pt.x;
1393                     float strikethroughMinY = pt.y + metrics.getStrikethroughOffset();
1394                     float strikethroughMaxX = strikethroughMinX + run.getWidth();
1395                     float strikethroughMaxY = strikethroughMinY + metrics.getStrikethroughThickness();
1396                     if (strikethroughMinX &lt; xMin) xMin = strikethroughMinX;
1397                     if (strikethroughMinY &lt; yMin) yMin = strikethroughMinY;
1398                     if (strikethroughMaxX &gt; xMax) xMax = strikethroughMaxX;
1399                     if (strikethroughMaxY &gt; yMax) yMax = strikethroughMaxY;
1400                 }
1401             }
1402         }
1403 
1404         if (xMin &lt; xMax &amp;&amp; yMin &lt; yMax) {
1405             visualBounds.setBounds(xMin, yMin, xMax, yMax);
1406         }
1407         return visualBounds;
1408     }
1409 
1410     private void computeSideBearings(TextLine line) {
1411         TextRun[] runs = line.getRuns();
1412         if (runs.length == 0) return;
1413         float bounds[] = new float[4];
1414         FontResource defaultFontResource = null;
1415         float size = 0;
1416         if (strike != null) {
1417             defaultFontResource = strike.getFontResource();
1418             size = strike.getSize();
1419         }
1420 
1421         /* The line lsb is the lsb of the first visual character in the line */
1422         float lsb = 0;
1423         float width = 0;
1424         lsbdone:
1425         for (int i = 0; i &lt; runs.length; i++) {
1426             TextRun run = runs[i];
1427             int glyphCount = run.getGlyphCount();
1428             for (int gi = 0; gi &lt; glyphCount; gi++) {
1429                 float advance = run.getAdvance(gi);
1430                 /* Skip any leading zero-width glyphs in the line */
1431                 if (advance != 0) {
1432                     int gc = run.getGlyphCode(gi);
1433                     /* Skip any leading invisible glyphs in the line */
1434                     if (gc != CharToGlyphMapper.INVISIBLE_GLYPH_ID) {
1435                         FontResource fr = defaultFontResource;
1436                         if (fr == null) {
1437                             TextSpan span = run.getTextSpan();
1438                             PGFont font = (PGFont)span.getFont();
1439                             /* No need to check font != null (run.glyphCount &gt; 0)  */
1440                             size = font.getSize();
1441                             fr = font.getFontResource();
1442                         }
1443                         fr.getGlyphBoundingBox(gc, size, bounds);
1444                         float glyphLsb = bounds[X_MIN_INDEX];
1445                         lsb = Math.min(0, glyphLsb + width);
1446                         run.setLeftBearing();
1447                         break lsbdone;
1448                     }
1449                 }
1450                 width += advance;
1451             }
1452             // tabs
1453             if (glyphCount == 0) {
1454                 width += run.getWidth();
1455             }
1456         }
1457 
1458         /* The line rsb is the rsb of the last visual character in the line */
1459         float rsb = 0;
1460         width = 0;
1461         rsbdone:
1462         for (int i = runs.length - 1; i &gt;= 0 ; i--) {
1463             TextRun run = runs[i];
1464             int glyphCount = run.getGlyphCount();
1465             for (int gi = glyphCount - 1; gi &gt;= 0; gi--) {
1466                 float advance = run.getAdvance(gi);
1467                 /* Skip any trailing zero-width glyphs in the line */
1468                 if (advance != 0) {
1469                     int gc = run.getGlyphCode(gi);
1470                     /* Skip any trailing invisible glyphs in the line */
1471                     if (gc != CharToGlyphMapper.INVISIBLE_GLYPH_ID) {
1472                         FontResource fr = defaultFontResource;
1473                         if (fr == null) {
1474                             TextSpan span = run.getTextSpan();
1475                             PGFont font = (PGFont)span.getFont();
1476                             /* No need to check font != null (run.glyphCount &gt; 0)  */
1477                             size = font.getSize();
1478                             fr = font.getFontResource();
1479                         }
1480                         fr.getGlyphBoundingBox(gc, size, bounds);
1481                         float glyphRsb = bounds[X_MAX_INDEX] - advance;
1482                         rsb = Math.max(0, glyphRsb - width);
1483                         run.setRightBearing();
1484                         break rsbdone;
1485                     }
1486                 }
1487                 width += advance;
1488             }
1489             // tabs
1490             if (glyphCount == 0) {
1491                 width += run.getWidth();
1492             }
1493         }
1494         line.setSideBearings(lsb, rsb);
1495     }
1496 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>