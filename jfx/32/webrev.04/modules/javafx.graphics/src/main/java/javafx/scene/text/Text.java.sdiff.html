<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/java/javafx/scene/text/Text.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../com/sun/javafx/text/PrismTextLayout.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TextFlow.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/java/javafx/scene/text/Text.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  65 import java.util.List;
  66 import javafx.beans.property.BooleanProperty;
  67 import javafx.beans.property.DoubleProperty;
  68 import javafx.beans.property.DoublePropertyBase;
  69 import javafx.beans.property.IntegerProperty;
  70 import javafx.beans.property.IntegerPropertyBase;
  71 import javafx.beans.property.ObjectProperty;
  72 import javafx.beans.property.ObjectPropertyBase;
  73 import javafx.beans.property.ReadOnlyDoubleProperty;
  74 import javafx.beans.property.ReadOnlyDoubleWrapper;
  75 import javafx.beans.property.ReadOnlyObjectProperty;
  76 import javafx.beans.property.SimpleBooleanProperty;
  77 import javafx.beans.property.SimpleObjectProperty;
  78 import javafx.beans.property.StringProperty;
  79 import javafx.beans.property.StringPropertyBase;
  80 import javafx.css.CssMetaData;
  81 import javafx.css.FontCssMetaData;
  82 import javafx.css.Styleable;
  83 import javafx.css.StyleableBooleanProperty;
  84 import javafx.css.StyleableDoubleProperty;

  85 import javafx.css.StyleableObjectProperty;
  86 import javafx.css.StyleableProperty;
  87 import javafx.geometry.BoundingBox;
  88 import javafx.geometry.Bounds;
  89 import javafx.geometry.NodeOrientation;
  90 import javafx.geometry.Point2D;
  91 import javafx.geometry.VPos;
  92 import javafx.scene.Node;
  93 
  94 /**
  95  * The {@code Text} class defines a node that displays a text.
  96  *
  97  * Paragraphs are separated by {@code &#39;\n&#39;} and the text is wrapped on
  98  * paragraph boundaries.
  99  *
 100 &lt;PRE&gt;
 101 import javafx.scene.text.*;
 102 
 103 Text t = new Text(10, 50, &quot;This is a test&quot;);
 104 t.setFont(new Font(20));
</pre>
<hr />
<pre>
 290             layout = null;
 291             TextFlow parent = (TextFlow)getParent();
 292             return parent.getTextLayout();
 293         }
 294         if (layout == null) {
 295             TextLayoutFactory factory = Toolkit.getToolkit().getTextLayoutFactory();
 296             layout = factory.createLayout();
 297             String string = getTextInternal();
 298             Object font = getFontInternal();
 299             TextAlignment alignment = getTextAlignment();
 300             if (alignment == null) alignment = DEFAULT_TEXT_ALIGNMENT;
 301             layout.setContent(string, font);
 302             layout.setAlignment(alignment.ordinal());
 303             layout.setLineSpacing((float)getLineSpacing());
 304             layout.setWrapWidth((float)getWrappingWidth());
 305             if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
 306                 layout.setDirection(TextLayout.DIRECTION_RTL);
 307             } else {
 308                 layout.setDirection(TextLayout.DIRECTION_LTR);
 309             }

 310         }
 311         return layout;
 312     }
 313 
 314     private GlyphList[] textRuns = null;
 315     private BaseBounds spanBounds = new RectBounds(); /* relative to the textlayout */
 316     private boolean spanBoundsInvalid = true;
 317 
 318     void layoutSpan(GlyphList[] runs) {
 319         TextSpan span = getTextSpan();
 320         int count = 0;
 321         for (int i = 0; i &lt; runs.length; i++) {
 322             GlyphList run = runs[i];
 323             if (run.getTextSpan() == span) {
 324                 count++;
 325             }
 326         }
 327         textRuns = new GlyphList[count];
 328         count = 0;
 329         for (int i = 0; i &lt; runs.length; i++) {
</pre>
<hr />
<pre>
1250     /*
1251      * Note: This method MUST only be called via its accessor method.
1252      */
1253     private com.sun.javafx.geom.Shape doConfigShape() {
1254         if (ShapeHelper.getMode(this) == NGShape.Mode.EMPTY || getTextInternal().length() == 0) {
1255             return new Path2D();
1256         }
1257         com.sun.javafx.geom.Shape shape = getShape();
1258         float x, y;
1259         if (isSpan()) {
1260             BaseBounds bounds = getSpanBounds();
1261             x = -bounds.getMinX();
1262             y = -bounds.getMinY();
1263         } else {
1264             x = (float)getX();
1265             y = getYAdjustment(getVisualBounds()) + (float)getY();
1266         }
1267         return TransformedShape.translatedShape(shape, x, y);
1268     }
1269 
























1270    /***************************************************************************
1271     *                                                                         *
1272     *                            Stylesheet Handling                          *
1273     *                                                                         *
1274     **************************************************************************/
1275 
1276     /*
1277      * Super-lazy instantiation pattern from Bill Pugh.
1278      */
<span class="line-modified">1279      private static class StyleableProperties {</span>
1280 
<span class="line-modified">1281          private static final CssMetaData&lt;Text,Font&gt; FONT =</span>
1282             new FontCssMetaData&lt;Text&gt;(&quot;-fx-font&quot;, Font.getDefault()) {
1283 
1284             @Override
1285             public boolean isSettable(Text node) {
1286                 return node.font == null || !node.font.isBound();
1287             }
1288 
1289             @Override
1290             public StyleableProperty&lt;Font&gt; getStyleableProperty(Text node) {
1291                 return (StyleableProperty&lt;Font&gt;)node.fontProperty();
1292             }
<span class="line-modified">1293          };</span>
1294 
<span class="line-modified">1295          private static final CssMetaData&lt;Text,Boolean&gt; UNDERLINE =</span>
1296             new CssMetaData&lt;Text,Boolean&gt;(&quot;-fx-underline&quot;,
<span class="line-modified">1297                  BooleanConverter.getInstance(), Boolean.FALSE) {</span>
1298 
1299             @Override
1300             public boolean isSettable(Text node) {
1301                 return node.attributes == null ||
1302                        node.attributes.underline == null ||
1303                       !node.attributes.underline.isBound();
1304             }
1305 
1306             @Override
1307             public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Text node) {
1308                 return (StyleableProperty&lt;Boolean&gt;)node.underlineProperty();
1309             }
<span class="line-modified">1310          };</span>
1311 
<span class="line-modified">1312          private static final CssMetaData&lt;Text,Boolean&gt; STRIKETHROUGH =</span>
1313             new CssMetaData&lt;Text,Boolean&gt;(&quot;-fx-strikethrough&quot;,
<span class="line-modified">1314                  BooleanConverter.getInstance(), Boolean.FALSE) {</span>
1315 
1316             @Override
1317             public boolean isSettable(Text node) {
1318                 return node.attributes == null ||
1319                        node.attributes.strikethrough == null ||
1320                       !node.attributes.strikethrough.isBound();
1321             }
1322 
1323             @Override
1324             public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Text node) {
1325                 return (StyleableProperty&lt;Boolean&gt;)node.strikethroughProperty();
1326             }
<span class="line-modified">1327          };</span>
1328 
<span class="line-modified">1329          private static final</span>
<span class="line-modified">1330              CssMetaData&lt;Text,TextAlignment&gt; TEXT_ALIGNMENT =</span>
<span class="line-modified">1331                  new CssMetaData&lt;Text,TextAlignment&gt;(&quot;-fx-text-alignment&quot;,</span>
<span class="line-modified">1332                  new EnumConverter&lt;TextAlignment&gt;(TextAlignment.class),</span>
<span class="line-modified">1333                  TextAlignment.LEFT) {</span>
1334 
1335             @Override
1336             public boolean isSettable(Text node) {
1337                 return node.attributes == null ||
1338                        node.attributes.textAlignment == null ||
1339                       !node.attributes.textAlignment.isBound();
1340             }
1341 
1342             @Override
1343             public StyleableProperty&lt;TextAlignment&gt; getStyleableProperty(Text node) {
1344                 return (StyleableProperty&lt;TextAlignment&gt;)node.textAlignmentProperty();
1345             }
<span class="line-modified">1346          };</span>
1347 
<span class="line-modified">1348          private static final CssMetaData&lt;Text,VPos&gt; TEXT_ORIGIN =</span>
<span class="line-modified">1349                  new CssMetaData&lt;Text,VPos&gt;(&quot;-fx-text-origin&quot;,</span>
<span class="line-modified">1350                  new EnumConverter&lt;VPos&gt;(VPos.class),</span>
<span class="line-modified">1351                  VPos.BASELINE) {</span>
1352 
1353             @Override
1354             public boolean isSettable(Text node) {
1355                 return node.attributes == null ||
1356                        node.attributes.textOrigin == null ||
1357                       !node.attributes.textOrigin.isBound();
1358             }
1359 
1360             @Override
1361             public StyleableProperty&lt;VPos&gt; getStyleableProperty(Text node) {
1362                 return (StyleableProperty&lt;VPos&gt;)node.textOriginProperty();
1363             }
<span class="line-modified">1364          };</span>
1365 
<span class="line-modified">1366          private static final CssMetaData&lt;Text,FontSmoothingType&gt;</span>
<span class="line-modified">1367              FONT_SMOOTHING_TYPE =</span>
<span class="line-modified">1368              new CssMetaData&lt;Text,FontSmoothingType&gt;(</span>
<span class="line-modified">1369                  &quot;-fx-font-smoothing-type&quot;,</span>
<span class="line-modified">1370                  new EnumConverter&lt;FontSmoothingType&gt;(FontSmoothingType.class),</span>
<span class="line-modified">1371                  FontSmoothingType.GRAY) {</span>
1372 
1373             @Override
1374             public boolean isSettable(Text node) {
1375                 return node.fontSmoothingType == null ||
1376                        !node.fontSmoothingType.isBound();
1377             }
1378 
1379             @Override
1380             public StyleableProperty&lt;FontSmoothingType&gt;
1381                                  getStyleableProperty(Text node) {
1382 
1383                 return (StyleableProperty&lt;FontSmoothingType&gt;)node.fontSmoothingTypeProperty();
1384             }
<span class="line-modified">1385          };</span>
1386 
<span class="line-modified">1387          private static final</span>
<span class="line-modified">1388              CssMetaData&lt;Text,Number&gt; LINE_SPACING =</span>
<span class="line-modified">1389                  new CssMetaData&lt;Text,Number&gt;(&quot;-fx-line-spacing&quot;,</span>
<span class="line-modified">1390                  SizeConverter.getInstance(), 0) {</span>
1391 
1392             @Override
1393             public boolean isSettable(Text node) {
1394                 return node.attributes == null ||
1395                        node.attributes.lineSpacing == null ||
1396                       !node.attributes.lineSpacing.isBound();
1397             }
1398 
1399             @Override
1400             public StyleableProperty&lt;Number&gt; getStyleableProperty(Text node) {
1401                 return (StyleableProperty&lt;Number&gt;)node.lineSpacingProperty();
1402             }
<span class="line-modified">1403          };</span>
1404 
<span class="line-modified">1405          private static final CssMetaData&lt;Text, TextBoundsType&gt;</span>
<span class="line-modified">1406              BOUNDS_TYPE =</span>
<span class="line-modified">1407              new CssMetaData&lt;Text,TextBoundsType&gt;(</span>
<span class="line-modified">1408                  &quot;-fx-bounds-type&quot;,</span>
<span class="line-modified">1409                  new EnumConverter&lt;TextBoundsType&gt;(TextBoundsType.class),</span>
<span class="line-modified">1410                  DEFAULT_BOUNDS_TYPE) {</span>
1411 
1412             @Override
1413             public boolean isSettable(Text node) {
1414                 return node.boundsType == null || !node.boundsType.isBound();
1415             }
1416 
1417             @Override
1418             public StyleableProperty&lt;TextBoundsType&gt; getStyleableProperty(Text node) {
1419                 return (StyleableProperty&lt;TextBoundsType&gt;)node.boundsTypeProperty();
1420             }
<span class="line-modified">1421          };</span>

















1422 
<span class="line-modified">1423      private final static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;</span>
<span class="line-modified">1424          static {</span>
1425             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1426                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Shape.getClassCssMetaData());
1427             styleables.add(FONT);
1428             styleables.add(UNDERLINE);
1429             styleables.add(STRIKETHROUGH);
1430             styleables.add(TEXT_ALIGNMENT);
1431             styleables.add(TEXT_ORIGIN);
1432             styleables.add(FONT_SMOOTHING_TYPE);
1433             styleables.add(LINE_SPACING);
1434             styleables.add(BOUNDS_TYPE);

1435             STYLEABLES = Collections.unmodifiableList(styleables);
<span class="line-modified">1436          }</span>
1437     }
1438 
1439     /**
1440      * @return The CssMetaData associated with this class, which may include the
1441      * CssMetaData of its superclasses.
1442      * @since JavaFX 8.0
1443      */
1444     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1445         return StyleableProperties.STYLEABLES;
1446     }
1447 
1448     /**
1449      * {@inheritDoc}
1450      *
1451      * @since JavaFX 8.0
1452      */
1453 
1454 
1455     @Override
1456     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
</pre>
<hr />
<pre>
1804                             notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_END);
1805                         }
1806                     };
1807             }
1808             return caretPosition;
1809         }
1810 
1811         private BooleanProperty caretBias;
1812 
1813         final boolean isCaretBias() {
1814             return caretBias == null ? DEFAULT_CARET_BIAS : caretBias.get();
1815         }
1816 
1817         final BooleanProperty caretBiasProperty() {
1818             if (caretBias == null) {
1819                 caretBias =
1820                         new SimpleBooleanProperty(Text.this, &quot;caretBias&quot;, DEFAULT_CARET_BIAS);
1821             }
1822             return caretBias;
1823         }































1824     }
1825 
1826     /**
1827      * Returns a string representation of this {@code Text} object.
1828      * @return a string representation of this {@code Text} object.
1829      */
1830     @Override
1831     public String toString() {
1832         final StringBuilder sb = new StringBuilder(&quot;Text[&quot;);
1833 
1834         String id = getId();
1835         if (id != null) {
1836             sb.append(&quot;id=&quot;).append(id).append(&quot;, &quot;);
1837         }
1838 
1839         sb.append(&quot;text=\&quot;&quot;).append(getText()).append(&quot;\&quot;&quot;);
1840         sb.append(&quot;, x=&quot;).append(getX());
1841         sb.append(&quot;, y=&quot;).append(getY());
1842         sb.append(&quot;, alignment=&quot;).append(getTextAlignment());
1843         sb.append(&quot;, origin=&quot;).append(getTextOrigin());
1844         sb.append(&quot;, boundsType=&quot;).append(getBoundsType());
1845 
1846         double spacing = getLineSpacing();
1847         if (spacing != DEFAULT_LINE_SPACING) {
1848             sb.append(&quot;, lineSpacing=&quot;).append(spacing);
1849         }
1850 
1851         double wrap = getWrappingWidth();
1852         if (wrap != 0) {
1853             sb.append(&quot;, wrappingWidth=&quot;).append(wrap);
1854         }
1855 





1856         sb.append(&quot;, font=&quot;).append(getFont());
1857         sb.append(&quot;, fontSmoothingType=&quot;).append(getFontSmoothingType());
1858 
1859         if (isStrikethrough()) {
1860             sb.append(&quot;, strikethrough&quot;);
1861         }
1862         if (isUnderline()) {
1863             sb.append(&quot;, underline&quot;);
1864         }
1865 
1866         sb.append(&quot;, fill=&quot;).append(getFill());
1867 
1868         Paint stroke = getStroke();
1869         if (stroke != null) {
1870             sb.append(&quot;, stroke=&quot;).append(stroke);
1871             sb.append(&quot;, strokeWidth=&quot;).append(getStrokeWidth());
1872         }
1873 
1874         return sb.append(&quot;]&quot;).toString();
1875     }
</pre>
</td>
<td>
<hr />
<pre>
  65 import java.util.List;
  66 import javafx.beans.property.BooleanProperty;
  67 import javafx.beans.property.DoubleProperty;
  68 import javafx.beans.property.DoublePropertyBase;
  69 import javafx.beans.property.IntegerProperty;
  70 import javafx.beans.property.IntegerPropertyBase;
  71 import javafx.beans.property.ObjectProperty;
  72 import javafx.beans.property.ObjectPropertyBase;
  73 import javafx.beans.property.ReadOnlyDoubleProperty;
  74 import javafx.beans.property.ReadOnlyDoubleWrapper;
  75 import javafx.beans.property.ReadOnlyObjectProperty;
  76 import javafx.beans.property.SimpleBooleanProperty;
  77 import javafx.beans.property.SimpleObjectProperty;
  78 import javafx.beans.property.StringProperty;
  79 import javafx.beans.property.StringPropertyBase;
  80 import javafx.css.CssMetaData;
  81 import javafx.css.FontCssMetaData;
  82 import javafx.css.Styleable;
  83 import javafx.css.StyleableBooleanProperty;
  84 import javafx.css.StyleableDoubleProperty;
<span class="line-added">  85 import javafx.css.StyleableIntegerProperty;</span>
  86 import javafx.css.StyleableObjectProperty;
  87 import javafx.css.StyleableProperty;
  88 import javafx.geometry.BoundingBox;
  89 import javafx.geometry.Bounds;
  90 import javafx.geometry.NodeOrientation;
  91 import javafx.geometry.Point2D;
  92 import javafx.geometry.VPos;
  93 import javafx.scene.Node;
  94 
  95 /**
  96  * The {@code Text} class defines a node that displays a text.
  97  *
  98  * Paragraphs are separated by {@code &#39;\n&#39;} and the text is wrapped on
  99  * paragraph boundaries.
 100  *
 101 &lt;PRE&gt;
 102 import javafx.scene.text.*;
 103 
 104 Text t = new Text(10, 50, &quot;This is a test&quot;);
 105 t.setFont(new Font(20));
</pre>
<hr />
<pre>
 291             layout = null;
 292             TextFlow parent = (TextFlow)getParent();
 293             return parent.getTextLayout();
 294         }
 295         if (layout == null) {
 296             TextLayoutFactory factory = Toolkit.getToolkit().getTextLayoutFactory();
 297             layout = factory.createLayout();
 298             String string = getTextInternal();
 299             Object font = getFontInternal();
 300             TextAlignment alignment = getTextAlignment();
 301             if (alignment == null) alignment = DEFAULT_TEXT_ALIGNMENT;
 302             layout.setContent(string, font);
 303             layout.setAlignment(alignment.ordinal());
 304             layout.setLineSpacing((float)getLineSpacing());
 305             layout.setWrapWidth((float)getWrappingWidth());
 306             if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
 307                 layout.setDirection(TextLayout.DIRECTION_RTL);
 308             } else {
 309                 layout.setDirection(TextLayout.DIRECTION_LTR);
 310             }
<span class="line-added"> 311             layout.setTabSize(getTabSize());</span>
 312         }
 313         return layout;
 314     }
 315 
 316     private GlyphList[] textRuns = null;
 317     private BaseBounds spanBounds = new RectBounds(); /* relative to the textlayout */
 318     private boolean spanBoundsInvalid = true;
 319 
 320     void layoutSpan(GlyphList[] runs) {
 321         TextSpan span = getTextSpan();
 322         int count = 0;
 323         for (int i = 0; i &lt; runs.length; i++) {
 324             GlyphList run = runs[i];
 325             if (run.getTextSpan() == span) {
 326                 count++;
 327             }
 328         }
 329         textRuns = new GlyphList[count];
 330         count = 0;
 331         for (int i = 0; i &lt; runs.length; i++) {
</pre>
<hr />
<pre>
1252     /*
1253      * Note: This method MUST only be called via its accessor method.
1254      */
1255     private com.sun.javafx.geom.Shape doConfigShape() {
1256         if (ShapeHelper.getMode(this) == NGShape.Mode.EMPTY || getTextInternal().length() == 0) {
1257             return new Path2D();
1258         }
1259         com.sun.javafx.geom.Shape shape = getShape();
1260         float x, y;
1261         if (isSpan()) {
1262             BaseBounds bounds = getSpanBounds();
1263             x = -bounds.getMinX();
1264             y = -bounds.getMinY();
1265         } else {
1266             x = (float)getX();
1267             y = getYAdjustment(getVisualBounds()) + (float)getY();
1268         }
1269         return TransformedShape.translatedShape(shape, x, y);
1270     }
1271 
<span class="line-added">1272     /**</span>
<span class="line-added">1273      * The size of a tab stop in spaces.</span>
<span class="line-added">1274      * Values less than 1 are treated as 1.</span>
<span class="line-added">1275      *</span>
<span class="line-added">1276      * @defaultValue {@code 8}</span>
<span class="line-added">1277      *</span>
<span class="line-added">1278      * @since 14</span>
<span class="line-added">1279      */</span>
<span class="line-added">1280     public final IntegerProperty tabSizeProperty() {</span>
<span class="line-added">1281         return getTextAttribute().tabSizeProperty();</span>
<span class="line-added">1282     }</span>
<span class="line-added">1283 </span>
<span class="line-added">1284     public final int getTabSize() {</span>
<span class="line-added">1285         if (attributes == null || attributes.tabSize == null) {</span>
<span class="line-added">1286             return TextLayout.DEFAULT_TAB_SIZE;</span>
<span class="line-added">1287         }</span>
<span class="line-added">1288         return getTextAttribute().getTabSize();</span>
<span class="line-added">1289     }</span>
<span class="line-added">1290 </span>
<span class="line-added">1291     public final void setTabSize(int spaces) {</span>
<span class="line-added">1292         tabSizeProperty().set(spaces);</span>
<span class="line-added">1293     }</span>
<span class="line-added">1294 </span>
<span class="line-added">1295 </span>
1296    /***************************************************************************
1297     *                                                                         *
1298     *                            Stylesheet Handling                          *
1299     *                                                                         *
1300     **************************************************************************/
1301 
1302     /*
1303      * Super-lazy instantiation pattern from Bill Pugh.
1304      */
<span class="line-modified">1305     private static class StyleableProperties {</span>
1306 
<span class="line-modified">1307         private static final CssMetaData&lt;Text,Font&gt; FONT =</span>
1308             new FontCssMetaData&lt;Text&gt;(&quot;-fx-font&quot;, Font.getDefault()) {
1309 
1310             @Override
1311             public boolean isSettable(Text node) {
1312                 return node.font == null || !node.font.isBound();
1313             }
1314 
1315             @Override
1316             public StyleableProperty&lt;Font&gt; getStyleableProperty(Text node) {
1317                 return (StyleableProperty&lt;Font&gt;)node.fontProperty();
1318             }
<span class="line-modified">1319         };</span>
1320 
<span class="line-modified">1321         private static final CssMetaData&lt;Text,Boolean&gt; UNDERLINE =</span>
1322             new CssMetaData&lt;Text,Boolean&gt;(&quot;-fx-underline&quot;,
<span class="line-modified">1323                 BooleanConverter.getInstance(), Boolean.FALSE) {</span>
1324 
1325             @Override
1326             public boolean isSettable(Text node) {
1327                 return node.attributes == null ||
1328                        node.attributes.underline == null ||
1329                       !node.attributes.underline.isBound();
1330             }
1331 
1332             @Override
1333             public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Text node) {
1334                 return (StyleableProperty&lt;Boolean&gt;)node.underlineProperty();
1335             }
<span class="line-modified">1336         };</span>
1337 
<span class="line-modified">1338         private static final CssMetaData&lt;Text,Boolean&gt; STRIKETHROUGH =</span>
1339             new CssMetaData&lt;Text,Boolean&gt;(&quot;-fx-strikethrough&quot;,
<span class="line-modified">1340                 BooleanConverter.getInstance(), Boolean.FALSE) {</span>
1341 
1342             @Override
1343             public boolean isSettable(Text node) {
1344                 return node.attributes == null ||
1345                        node.attributes.strikethrough == null ||
1346                       !node.attributes.strikethrough.isBound();
1347             }
1348 
1349             @Override
1350             public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Text node) {
1351                 return (StyleableProperty&lt;Boolean&gt;)node.strikethroughProperty();
1352             }
<span class="line-modified">1353         };</span>
1354 
<span class="line-modified">1355         private static final</span>
<span class="line-modified">1356             CssMetaData&lt;Text,TextAlignment&gt; TEXT_ALIGNMENT =</span>
<span class="line-modified">1357                 new CssMetaData&lt;Text,TextAlignment&gt;(&quot;-fx-text-alignment&quot;,</span>
<span class="line-modified">1358                 new EnumConverter&lt;TextAlignment&gt;(TextAlignment.class),</span>
<span class="line-modified">1359                 TextAlignment.LEFT) {</span>
1360 
1361             @Override
1362             public boolean isSettable(Text node) {
1363                 return node.attributes == null ||
1364                        node.attributes.textAlignment == null ||
1365                       !node.attributes.textAlignment.isBound();
1366             }
1367 
1368             @Override
1369             public StyleableProperty&lt;TextAlignment&gt; getStyleableProperty(Text node) {
1370                 return (StyleableProperty&lt;TextAlignment&gt;)node.textAlignmentProperty();
1371             }
<span class="line-modified">1372         };</span>
1373 
<span class="line-modified">1374         private static final CssMetaData&lt;Text,VPos&gt; TEXT_ORIGIN =</span>
<span class="line-modified">1375                 new CssMetaData&lt;Text,VPos&gt;(&quot;-fx-text-origin&quot;,</span>
<span class="line-modified">1376                 new EnumConverter&lt;VPos&gt;(VPos.class),</span>
<span class="line-modified">1377                 VPos.BASELINE) {</span>
1378 
1379             @Override
1380             public boolean isSettable(Text node) {
1381                 return node.attributes == null ||
1382                        node.attributes.textOrigin == null ||
1383                       !node.attributes.textOrigin.isBound();
1384             }
1385 
1386             @Override
1387             public StyleableProperty&lt;VPos&gt; getStyleableProperty(Text node) {
1388                 return (StyleableProperty&lt;VPos&gt;)node.textOriginProperty();
1389             }
<span class="line-modified">1390         };</span>
1391 
<span class="line-modified">1392         private static final CssMetaData&lt;Text,FontSmoothingType&gt;</span>
<span class="line-modified">1393             FONT_SMOOTHING_TYPE =</span>
<span class="line-modified">1394             new CssMetaData&lt;Text,FontSmoothingType&gt;(</span>
<span class="line-modified">1395                 &quot;-fx-font-smoothing-type&quot;,</span>
<span class="line-modified">1396                 new EnumConverter&lt;FontSmoothingType&gt;(FontSmoothingType.class),</span>
<span class="line-modified">1397                 FontSmoothingType.GRAY) {</span>
1398 
1399             @Override
1400             public boolean isSettable(Text node) {
1401                 return node.fontSmoothingType == null ||
1402                        !node.fontSmoothingType.isBound();
1403             }
1404 
1405             @Override
1406             public StyleableProperty&lt;FontSmoothingType&gt;
1407                                  getStyleableProperty(Text node) {
1408 
1409                 return (StyleableProperty&lt;FontSmoothingType&gt;)node.fontSmoothingTypeProperty();
1410             }
<span class="line-modified">1411         };</span>
1412 
<span class="line-modified">1413         private static final</span>
<span class="line-modified">1414             CssMetaData&lt;Text,Number&gt; LINE_SPACING =</span>
<span class="line-modified">1415                 new CssMetaData&lt;Text,Number&gt;(&quot;-fx-line-spacing&quot;,</span>
<span class="line-modified">1416                 SizeConverter.getInstance(), 0) {</span>
1417 
1418             @Override
1419             public boolean isSettable(Text node) {
1420                 return node.attributes == null ||
1421                        node.attributes.lineSpacing == null ||
1422                       !node.attributes.lineSpacing.isBound();
1423             }
1424 
1425             @Override
1426             public StyleableProperty&lt;Number&gt; getStyleableProperty(Text node) {
1427                 return (StyleableProperty&lt;Number&gt;)node.lineSpacingProperty();
1428             }
<span class="line-modified">1429         };</span>
1430 
<span class="line-modified">1431         private static final CssMetaData&lt;Text, TextBoundsType&gt;</span>
<span class="line-modified">1432             BOUNDS_TYPE =</span>
<span class="line-modified">1433             new CssMetaData&lt;Text,TextBoundsType&gt;(</span>
<span class="line-modified">1434                 &quot;-fx-bounds-type&quot;,</span>
<span class="line-modified">1435                 new EnumConverter&lt;TextBoundsType&gt;(TextBoundsType.class),</span>
<span class="line-modified">1436                 DEFAULT_BOUNDS_TYPE) {</span>
1437 
1438             @Override
1439             public boolean isSettable(Text node) {
1440                 return node.boundsType == null || !node.boundsType.isBound();
1441             }
1442 
1443             @Override
1444             public StyleableProperty&lt;TextBoundsType&gt; getStyleableProperty(Text node) {
1445                 return (StyleableProperty&lt;TextBoundsType&gt;)node.boundsTypeProperty();
1446             }
<span class="line-modified">1447         };</span>
<span class="line-added">1448 </span>
<span class="line-added">1449         private static final CssMetaData&lt;Text,Number&gt; TAB_SIZE =</span>
<span class="line-added">1450                 new CssMetaData&lt;Text,Number&gt;(&quot;-fx-tab-size&quot;,</span>
<span class="line-added">1451                 SizeConverter.getInstance(), TextLayout.DEFAULT_TAB_SIZE) {</span>
<span class="line-added">1452 </span>
<span class="line-added">1453             @Override</span>
<span class="line-added">1454             public boolean isSettable(Text node) {</span>
<span class="line-added">1455                 return node.attributes == null ||</span>
<span class="line-added">1456                        node.attributes.tabSize == null ||</span>
<span class="line-added">1457                       !node.attributes.tabSize.isBound();</span>
<span class="line-added">1458             }</span>
<span class="line-added">1459 </span>
<span class="line-added">1460             @Override</span>
<span class="line-added">1461             public StyleableProperty&lt;Number&gt; getStyleableProperty(Text node) {</span>
<span class="line-added">1462                 return (StyleableProperty&lt;Number&gt;)node.tabSizeProperty();</span>
<span class="line-added">1463             }</span>
<span class="line-added">1464         };</span>
1465 
<span class="line-modified">1466     private final static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;</span>
<span class="line-modified">1467         static {</span>
1468             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1469                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Shape.getClassCssMetaData());
1470             styleables.add(FONT);
1471             styleables.add(UNDERLINE);
1472             styleables.add(STRIKETHROUGH);
1473             styleables.add(TEXT_ALIGNMENT);
1474             styleables.add(TEXT_ORIGIN);
1475             styleables.add(FONT_SMOOTHING_TYPE);
1476             styleables.add(LINE_SPACING);
1477             styleables.add(BOUNDS_TYPE);
<span class="line-added">1478             styleables.add(TAB_SIZE);</span>
1479             STYLEABLES = Collections.unmodifiableList(styleables);
<span class="line-modified">1480         }</span>
1481     }
1482 
1483     /**
1484      * @return The CssMetaData associated with this class, which may include the
1485      * CssMetaData of its superclasses.
1486      * @since JavaFX 8.0
1487      */
1488     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1489         return StyleableProperties.STYLEABLES;
1490     }
1491 
1492     /**
1493      * {@inheritDoc}
1494      *
1495      * @since JavaFX 8.0
1496      */
1497 
1498 
1499     @Override
1500     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
</pre>
<hr />
<pre>
1848                             notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_END);
1849                         }
1850                     };
1851             }
1852             return caretPosition;
1853         }
1854 
1855         private BooleanProperty caretBias;
1856 
1857         final boolean isCaretBias() {
1858             return caretBias == null ? DEFAULT_CARET_BIAS : caretBias.get();
1859         }
1860 
1861         final BooleanProperty caretBiasProperty() {
1862             if (caretBias == null) {
1863                 caretBias =
1864                         new SimpleBooleanProperty(Text.this, &quot;caretBias&quot;, DEFAULT_CARET_BIAS);
1865             }
1866             return caretBias;
1867         }
<span class="line-added">1868 </span>
<span class="line-added">1869         private IntegerProperty tabSize;</span>
<span class="line-added">1870 </span>
<span class="line-added">1871         final int getTabSize() {</span>
<span class="line-added">1872             return tabSize == null ? TextLayout.DEFAULT_TAB_SIZE : tabSize.get();</span>
<span class="line-added">1873         }</span>
<span class="line-added">1874 </span>
<span class="line-added">1875         final IntegerProperty tabSizeProperty() {</span>
<span class="line-added">1876             if (tabSize == null) {</span>
<span class="line-added">1877                 tabSize = new StyleableIntegerProperty(TextLayout.DEFAULT_TAB_SIZE) {</span>
<span class="line-added">1878                     @Override public Object getBean() { return Text.this; }</span>
<span class="line-added">1879                     @Override public String getName() { return &quot;tabSize&quot;; }</span>
<span class="line-added">1880                     @Override public CssMetaData getCssMetaData() {</span>
<span class="line-added">1881                         return StyleableProperties.TAB_SIZE;</span>
<span class="line-added">1882                     }</span>
<span class="line-added">1883                     @Override protected void invalidated() {</span>
<span class="line-added">1884                         if (!isSpan()) {</span>
<span class="line-added">1885                             TextLayout layout = getTextLayout();</span>
<span class="line-added">1886                             if (layout.setTabSize(get())) {</span>
<span class="line-added">1887                                 needsTextLayout();</span>
<span class="line-added">1888                             }</span>
<span class="line-added">1889                             NodeHelper.markDirty(Text.this, DirtyBits.TEXT_ATTRS);</span>
<span class="line-added">1890                             if (getBoundsType() == TextBoundsType.VISUAL) {</span>
<span class="line-added">1891                                 NodeHelper.geomChanged(Text.this);</span>
<span class="line-added">1892                             }</span>
<span class="line-added">1893                         }</span>
<span class="line-added">1894                     }</span>
<span class="line-added">1895                 };</span>
<span class="line-added">1896             }</span>
<span class="line-added">1897             return tabSize;</span>
<span class="line-added">1898         }</span>
1899     }
1900 
1901     /**
1902      * Returns a string representation of this {@code Text} object.
1903      * @return a string representation of this {@code Text} object.
1904      */
1905     @Override
1906     public String toString() {
1907         final StringBuilder sb = new StringBuilder(&quot;Text[&quot;);
1908 
1909         String id = getId();
1910         if (id != null) {
1911             sb.append(&quot;id=&quot;).append(id).append(&quot;, &quot;);
1912         }
1913 
1914         sb.append(&quot;text=\&quot;&quot;).append(getText()).append(&quot;\&quot;&quot;);
1915         sb.append(&quot;, x=&quot;).append(getX());
1916         sb.append(&quot;, y=&quot;).append(getY());
1917         sb.append(&quot;, alignment=&quot;).append(getTextAlignment());
1918         sb.append(&quot;, origin=&quot;).append(getTextOrigin());
1919         sb.append(&quot;, boundsType=&quot;).append(getBoundsType());
1920 
1921         double spacing = getLineSpacing();
1922         if (spacing != DEFAULT_LINE_SPACING) {
1923             sb.append(&quot;, lineSpacing=&quot;).append(spacing);
1924         }
1925 
1926         double wrap = getWrappingWidth();
1927         if (wrap != 0) {
1928             sb.append(&quot;, wrappingWidth=&quot;).append(wrap);
1929         }
1930 
<span class="line-added">1931         int tab = getTabSize();</span>
<span class="line-added">1932         if (tab != TextLayout.DEFAULT_TAB_SIZE) {</span>
<span class="line-added">1933             sb.append(&quot;, tabSize=&quot;).append(tab);</span>
<span class="line-added">1934         }</span>
<span class="line-added">1935 </span>
1936         sb.append(&quot;, font=&quot;).append(getFont());
1937         sb.append(&quot;, fontSmoothingType=&quot;).append(getFontSmoothingType());
1938 
1939         if (isStrikethrough()) {
1940             sb.append(&quot;, strikethrough&quot;);
1941         }
1942         if (isUnderline()) {
1943             sb.append(&quot;, underline&quot;);
1944         }
1945 
1946         sb.append(&quot;, fill=&quot;).append(getFill());
1947 
1948         Paint stroke = getStroke();
1949         if (stroke != null) {
1950             sb.append(&quot;, stroke=&quot;).append(stroke);
1951             sb.append(&quot;, strokeWidth=&quot;).append(getStrokeWidth());
1952         }
1953 
1954         return sb.append(&quot;]&quot;).toString();
1955     }
</pre>
</td>
</tr>
</table>
<center><a href="../../../com/sun/javafx/text/PrismTextLayout.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TextFlow.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>